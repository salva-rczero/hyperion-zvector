; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159831 DB	'CP', 00H
	ORG $+5
$SG159832 DB	'CP              ', 00H
	ORG $+3
$SG159833 DB	'??', 00H
	ORG $+1
$SG159834 DB	'                ', 00H
	ORG $+3
$SG159835 DB	'AP', 00H
	ORG $+1
$SG159836 DB	'ZAAP            ', 00H
	ORG $+3
$SG159837 DB	'IL', 00H
	ORG $+1
$SG159838 DB	'IFL             ', 00H
	ORG $+3
$SG159839 DB	'CF', 00H
	ORG $+1
$SG159840 DB	'ICF             ', 00H
	ORG $+3
$SG159841 DB	'IP', 00H
	ORG $+1
$SG159842 DB	'ZIIP            ', 00H
	ORG $+3
$SG160004 DB	'Sense', 00H
	ORG $+6
$SG159928 DB	'Operation exception', 00H
	ORG $+4
$SG159929 DB	'Privileged-operation exception', 00H
	ORG $+1
$SG159930 DB	'Execute exception', 00H
	ORG $+6
$SG159931 DB	'Protection exception', 00H
	ORG $+3
$SG159932 DB	'Addressing exception', 00H
	ORG $+3
$SG159933 DB	'Specification exception', 00H
$SG159934 DB	'Data exception', 00H
	ORG $+1
$SG159935 DB	'Fixed-point-overflow exception', 00H
	ORG $+1
$SG159936 DB	'Fixed-point-divide exception', 00H
	ORG $+3
$SG159937 DB	'Decimal-overflow exception', 00H
	ORG $+5
$SG159938 DB	'Decimal-divide exception', 00H
	ORG $+7
$SG159939 DB	'HFP-exponent-overflow exception', 00H
$SG159940 DB	'HFP-exponent-underflow exception', 00H
	ORG $+7
$SG159941 DB	'HFP-significance exception', 00H
	ORG $+5
$SG159942 DB	'HFP-floating-point-divide exception', 00H
	ORG $+4
$SG159943 DB	'Segment-translation exception', 00H
	ORG $+2
$SG159944 DB	'Page-translation exception', 00H
	ORG $+5
$SG159945 DB	'Translation-specification exception', 00H
	ORG $+4
$SG159946 DB	'Special-operation exception', 00H
	ORG $+4
$SG159947 DB	'Pseudo-page-fault exception', 00H
	ORG $+4
$SG159948 DB	'Operand exception', 00H
	ORG $+6
$SG159949 DB	'Trace-table exception', 00H
	ORG $+2
$SG159950 DB	'ASN-translation exception', 00H
	ORG $+6
$SG159951 DB	'Transaction constraint exception', 00H
	ORG $+7
$SG159952 DB	'Vector/Crypto operation exception', 00H
	ORG $+6
$SG159953 DB	'Page state exception', 00H
	ORG $+3
$SG159954 DB	'Vector processing exception', 00H
	ORG $+4
$SG159955 DB	'Space-switch event', 00H
	ORG $+5
$SG159956 DB	'Square-root exception', 00H
	ORG $+2
$SG159957 DB	'Unnormalized-operand exception', 00H
	ORG $+1
$SG159958 DB	'PC-translation specification exception', 00H
	ORG $+1
$SG159959 DB	'AFX-translation exception', 00H
	ORG $+6
$SG159960 DB	'ASX-translation exception', 00H
	ORG $+6
$SG159961 DB	'LX-translation exception', 00H
	ORG $+7
$SG159962 DB	'EX-translation exception', 00H
	ORG $+7
$SG159963 DB	'Primary-authority exception', 00H
	ORG $+4
$SG159964 DB	'Secondary-authority exception', 00H
	ORG $+2
$SG159965 DB	'LFX-translation exception', 00H
	ORG $+6
$SG159966 DB	'LSX-translation exception', 00H
	ORG $+6
$SG159967 DB	'ALET-specification exception', 00H
	ORG $+3
$SG159968 DB	'ALEN-translation exception', 00H
	ORG $+5
$SG159969 DB	'ALE-sequence exception', 00H
	ORG $+1
$SG159970 DB	'ASTE-validity exception', 00H
$SG159971 DB	'ASTE-sequence exception', 00H
$SG159972 DB	'Extended-authority exception', 00H
	ORG $+3
$SG159973 DB	'LSTE-sequence exception', 00H
$SG159974 DB	'ASTE-instance exception', 00H
$SG159975 DB	'Stack-full exception', 00H
	ORG $+3
$SG159976 DB	'Stack-empty exception', 00H
	ORG $+2
$SG159977 DB	'Stack-specification exception', 00H
	ORG $+2
$SG159978 DB	'Stack-type exception', 00H
	ORG $+3
$SG159979 DB	'Stack-operation exception', 00H
	ORG $+6
$SG159980 DB	'Unassigned exception', 00H
	ORG $+3
$SG159981 DB	'Unassigned exception', 00H
	ORG $+3
$SG159982 DB	'Unassigned exception', 00H
	ORG $+3
$SG159983 DB	'ASCE-type exception', 00H
	ORG $+4
$SG159984 DB	'Region-first-translation exception', 00H
	ORG $+5
$SG159985 DB	'Region-second-translation exception', 00H
	ORG $+4
$SG159986 DB	'Region-third-translation exception', 00H
	ORG $+5
$SG159987 DB	'Unassigned exception', 00H
	ORG $+3
$SG159988 DB	'Unassigned exception', 00H
	ORG $+3
$SG159989 DB	'Unassigned exception', 00H
	ORG $+3
$SG159990 DB	'Unassigned exception', 00H
	ORG $+3
$SG159991 DB	'Monitor event', 00H
	ORG $+2
$SG160003 DB	'Unassigned', 00H
	ORG $+5
$SG160005 DB	'External call', 00H
	ORG $+2
$SG160006 DB	'Emergency signal', 00H
	ORG $+3
$SG160007 DB	'Start', 00H
	ORG $+2
$SG160008 DB	'Stop', 00H
	ORG $+7
$SG160009 DB	'Restart', 00H
$SG160010 DB	'Initial program reset', 00H
	ORG $+2
$SG160011 DB	'Program reset', 00H
	ORG $+2
$SG160012 DB	'Stop and store status', 00H
	ORG $+2
$SG160013 DB	'Initial microprogram load', 00H
	ORG $+6
$SG160014 DB	'Initial CPU reset', 00H
	ORG $+6
$SG160015 DB	'CPU reset', 00H
	ORG $+6
$SG160016 DB	'Set prefix', 00H
	ORG $+5
$SG160017 DB	'Store status', 00H
	ORG $+3
$SG160018 DB	'Unassigned', 00H
	ORG $+5
$SG160019 DB	'Unassigned', 00H
	ORG $+5
$SG160020 DB	'Store extended status at address', 00H
	ORG $+7
$SG160021 DB	'Set architecture mode', 00H
	ORG $+2
$SG160022 DB	'Conditional emergency', 00H
	ORG $+2
$SG160023 DB	'Unassigned', 00H
	ORG $+5
$SG160024 DB	'Sense running state', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
tfsys_size DQ	00000000000000f0H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	get_symbol
PUBLIC	resolve_symbol_string
PUBLIC	set_symbol
PUBLIC	del_symbol
PUBLIC	list_all_symbols
PUBLIC	strlcpy
PUBLIC	strlcat
PUBLIC	timeval_subtract
PUBLIC	timeval_add
PUBLIC	timed_wait_condition_relative_usecs_impl
PUBLIC	hprintf
PUBLIC	hwrite
PUBLIC	hgetc
PUBLIC	hgets
PUBLIC	hpcalloc
PUBLIC	hpcfree
PUBLIC	trimloc
PUBLIC	FormatTIMEVAL
PUBLIC	fmt_memsize
PUBLIC	fmt_memsize_KB
PUBLIC	fmt_memsize_MB
PUBLIC	fmt_S64
PUBLIC	initialize_utility
PUBLIC	reverse_bits
PUBLIC	FormatFCB
PUBLIC	FormatCCTAPE
PUBLIC	tkcount
PUBLIC	ltrim
PUBLIC	rtrim
PUBLIC	trim
PUBLIC	parse_args
PUBLIC	init_random
PUBLIC	is_numeric
PUBLIC	is_numeric_l
PUBLIC	is_hex
PUBLIC	is_hex_l
PUBLIC	string_to_upper
PUBLIC	string_to_lower
PUBLIC	convert_to_ebcdic
PUBLIC	make_asciiz
PUBLIC	idx_snprintf
PUBLIC	ptyp2long
PUBLIC	ptyp2short
PUBLIC	short2ptyp
PUBLIC	do_make_psw64
PUBLIC	PIC2Name
PUBLIC	order2name
PUBLIC	perc2name
PUBLIC	FormatORB
PUBLIC	are_big_endian
PUBLIC	tf_0423
PUBLIC	tf_0424
PUBLIC	tf_0425
PUBLIC	tf_0426
PUBLIC	tf_0427
PUBLIC	tf_0428
PUBLIC	tf_0429
PUBLIC	tf_0430
PUBLIC	tf_0431
PUBLIC	tf_0432
PUBLIC	tf_0433
PUBLIC	tf_0434
PUBLIC	tf_0435
PUBLIC	tf_0436
PUBLIC	tf_0437
PUBLIC	tf_0438
PUBLIC	tf_0439
PUBLIC	tf_0440
PUBLIC	tf_0441
PUBLIC	tf_0442
PUBLIC	tf_0516
PUBLIC	tf_0517
PUBLIC	tf_0518
PUBLIC	tf_0519
PUBLIC	tf_0520
PUBLIC	tf_0800
PUBLIC	tf_0801
PUBLIC	tf_0802
PUBLIC	tf_0803
PUBLIC	tf_0804
PUBLIC	tf_0806
PUBLIC	tf_0807
PUBLIC	tf_0808
PUBLIC	tf_0809
PUBLIC	tf_0811
PUBLIC	tf_0812
PUBLIC	tf_0814
PUBLIC	tf_0840
PUBLIC	tf_0844
PUBLIC	tf_0845
PUBLIC	tf_0846
PUBLIC	tf_1300
PUBLIC	tf_1301
PUBLIC	tf_1304
PUBLIC	tf_1305
PUBLIC	tf_1306
PUBLIC	tf_1307
PUBLIC	tf_1308
PUBLIC	tf_1309
PUBLIC	tf_1310
PUBLIC	tf_1311
PUBLIC	tf_1312
PUBLIC	tf_1313
PUBLIC	tf_1315
PUBLIC	tf_1316
PUBLIC	tf_1317
PUBLIC	tf_1318
PUBLIC	tf_1320
PUBLIC	tf_1321
PUBLIC	tf_1329
PUBLIC	tf_1330
PUBLIC	tf_1331
PUBLIC	tf_1332
PUBLIC	tf_1333
PUBLIC	tf_1334
PUBLIC	tf_1336
PUBLIC	tf_2269
PUBLIC	tf_2270
PUBLIC	tf_2271
PUBLIC	tf_2272
PUBLIC	tf_2276
PUBLIC	tf_2277
PUBLIC	tf_2324
PUBLIC	tf_2326
PUBLIC	tf_MAX_RECSIZE
PUBLIC	tf_close
PUBLIC	tf_close_locked
PUBLIC	tf_autostop
PUBLIC	tf_are_swaps_needed
PUBLIC	tf_swap_sys
PUBLIC	tf_swap_hdr
PUBLIC	tf_swap_rec
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp_tolower:PROC
EXTRN	__imp__errno:PROC
EXTRN	strrchr:PROC
EXTRN	strstr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_strtok:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_getenv:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp_strftime:PROC
EXTRN	__imp__time64:PROC
EXTRN	hthreads_internal_init:PROC
EXTRN	hthread_initialize_lock:PROC
EXTRN	hthread_obtain_lock:PROC
EXTRN	hthread_release_lock:PROC
EXTRN	hthread_initialize_condition:PROC
EXTRN	hthread_signal_condition:PROC
EXTRN	hthread_wait_condition:PROC
EXTRN	hthread_timed_wait_condition:PROC
EXTRN	hthread_initialize_join_attr:PROC
EXTRN	hthread_initialize_detach_attr:PROC
EXTRN	hthread_set_thread_name:PROC
EXTRN	init_hostinfo:PROC
EXTRN	init_sysblk_version_str_arrays:PROC
EXTRN	display_version:PROC
EXTRN	w32_strerror:PROC
EXTRN	strtok_r:PROC
EXTRN	gettimeofday:PROC
EXTRN	w32_fwrite:PROC
EXTRN	w32_vsnprintf:PROC
EXTRN	w32_snprintf:PROC
EXTRN	w32_fclose:PROC
EXTRN	w32_set_thread_name:PROC
EXTRN	w32_hpagesize:PROC
EXTRN	w32_basename:PROC
EXTRN	set_codepage:PROC
EXTRN	host_to_guest:PROC
EXTRN	guest_to_host:PROC
EXTRN	hdl_addshut:PROC
EXTRN	fwritemsg:PROC
EXTRN	logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	hostinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
symbols	DQ	01H DUP (?)
symbol_count DD	01H DUP (?)
symbol_max DD	01H DUP (?)
$SG159187 DB	01H DUP (?)
	ALIGN	4

$SG159262 DB	01H DUP (?)
	ALIGN	4

$SG159617 DB	01H DUP (?)
	ALIGN	4

$SG159619 DB	01H DUP (?)
	ALIGN	4

tfsys	DB	0f0H DUP (?)
?bufsize@?1??tf_write@@9@9 DQ 01H DUP (?)		; `tf_write'::`2'::bufsize
?prev@?1??tf_write@@9@9 DW 01H DUP (?)			; `tf_write'::`2'::prev
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$strcaseabbrev DD imagerel strcaseabbrev
	DD	imagerel strcaseabbrev+320
	DD	imagerel $unwind$strcaseabbrev
$pdata$get_symbol DD imagerel $LN9
	DD	imagerel $LN9+433
	DD	imagerel $unwind$get_symbol
$pdata$resolve_symbol_string DD imagerel $LN39
	DD	imagerel $LN39+1208
	DD	imagerel $unwind$resolve_symbol_string
$pdata$set_symbol DD imagerel $LN8
	DD	imagerel $LN8+188
	DD	imagerel $unwind$set_symbol
$pdata$del_symbol DD imagerel $LN10
	DD	imagerel $LN10+205
	DD	imagerel $unwind$del_symbol
$pdata$list_all_symbols DD imagerel $LN9
	DD	imagerel $LN9+216
	DD	imagerel $unwind$list_all_symbols
$pdata$strlcpy DD imagerel $LN12
	DD	imagerel $LN12+241
	DD	imagerel $unwind$strlcpy
$pdata$strlcat DD imagerel $LN9
	DD	imagerel $LN9+296
	DD	imagerel $unwind$strlcat
$pdata$timeval_subtract DD imagerel $LN27
	DD	imagerel $LN27+417
	DD	imagerel $unwind$timeval_subtract
$pdata$timeval_add DD imagerel $LN26
	DD	imagerel $LN26+423
	DD	imagerel $unwind$timeval_add
$pdata$timed_wait_condition_relative_usecs_impl DD imagerel $LN5
	DD	imagerel $LN5+240
	DD	imagerel $unwind$timed_wait_condition_relative_usecs_impl
$pdata$hprintf DD imagerel $LN7
	DD	imagerel $LN7+223
	DD	imagerel $unwind$hprintf
$pdata$hwrite DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$hwrite
$pdata$hgetc DD	imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$hgetc
$pdata$hgets DD	imagerel $LN7
	DD	imagerel $LN7+171
	DD	imagerel $unwind$hgets
$pdata$hpcalloc DD imagerel $LN6
	DD	imagerel $LN6+246
	DD	imagerel $unwind$hpcalloc
$pdata$hpcfree DD imagerel $LN5
	DD	imagerel $LN5+123
	DD	imagerel $unwind$hpcfree
$pdata$trimloc DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$trimloc
$pdata$FormatTIMEVAL DD imagerel $LN7
	DD	imagerel $LN7+217
	DD	imagerel $unwind$FormatTIMEVAL
$pdata$fmt_memsize DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$fmt_memsize
$pdata$fmt_memsize_KB DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fmt_memsize_KB
$pdata$fmt_memsize_MB DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fmt_memsize_MB
$pdata$fmt_S64 DD imagerel $LN8
	DD	imagerel $LN8+349
	DD	imagerel $unwind$fmt_S64
$pdata$initialize_utility DD imagerel $LN15
	DD	imagerel $LN15+875
	DD	imagerel $unwind$initialize_utility
$pdata$FormatFCB DD imagerel $LN9
	DD	imagerel $LN9+383
	DD	imagerel $unwind$FormatFCB
$pdata$FormatCCTAPE DD imagerel $LN21
	DD	imagerel $LN21+795
	DD	imagerel $unwind$FormatCCTAPE
$pdata$tkcount DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$tkcount
$pdata$ltrim DD	imagerel $LN11
	DD	imagerel $LN11+194
	DD	imagerel $unwind$ltrim
$pdata$rtrim DD	imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$rtrim
$pdata$trim DD	imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$trim
$pdata$parse_args DD imagerel $LN20
	DD	imagerel $LN20+467
	DD	imagerel $unwind$parse_args
$pdata$init_random DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$init_random
$pdata$is_numeric DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$is_numeric
$pdata$is_numeric_l DD imagerel $LN12
	DD	imagerel $LN12+162
	DD	imagerel $unwind$is_numeric_l
$pdata$is_hex DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$is_hex
$pdata$is_hex_l DD imagerel $LN14
	DD	imagerel $LN14+275
	DD	imagerel $unwind$is_hex_l
$pdata$string_to_upper DD imagerel $LN6
	DD	imagerel $LN6+89
	DD	imagerel $unwind$string_to_upper
$pdata$string_to_lower DD imagerel $LN6
	DD	imagerel $LN6+89
	DD	imagerel $unwind$string_to_lower
$pdata$convert_to_ebcdic DD imagerel $LN8
	DD	imagerel $LN8+141
	DD	imagerel $unwind$convert_to_ebcdic
$pdata$make_asciiz DD imagerel $LN8
	DD	imagerel $LN8+163
	DD	imagerel $unwind$make_asciiz
$pdata$idx_snprintf DD imagerel $LN7
	DD	imagerel $LN7+300
	DD	imagerel $unwind$idx_snprintf
$pdata$ptyp2long DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$ptyp2long
$pdata$ptyp2short DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$ptyp2short
$pdata$short2ptyp DD imagerel $LN7
	DD	imagerel $LN7+104
	DD	imagerel $unwind$short2ptyp
$pdata$do_make_psw64 DD imagerel $LN20
	DD	imagerel $LN20+788
	DD	imagerel $unwind$do_make_psw64
$pdata$PIC2Name DD imagerel $LN8
	DD	imagerel $LN8+130
	DD	imagerel $unwind$PIC2Name
$pdata$order2name DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$order2name
$pdata$perc2name DD imagerel $LN19
	DD	imagerel $LN19+460
	DD	imagerel $unwind$perc2name
$pdata$FormatORB DD imagerel $LN39
	DD	imagerel $LN39+1392
	DD	imagerel $unwind$FormatORB
$pdata$are_big_endian DD imagerel $LN7
	DD	imagerel $LN7+79
	DD	imagerel $unwind$are_big_endian
$pdata$tf_0423 DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$tf_0423
$pdata$tf_0424 DD imagerel $LN3
	DD	imagerel $LN3+185
	DD	imagerel $unwind$tf_0424
$pdata$tf_0425 DD imagerel $LN3
	DD	imagerel $LN3+170
	DD	imagerel $unwind$tf_0425
$pdata$tf_0426 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0426
$pdata$tf_0427 DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$tf_0427
$pdata$tf_0428 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0428
$pdata$tf_0429 DD imagerel $LN3
	DD	imagerel $LN3+221
	DD	imagerel $unwind$tf_0429
$pdata$tf_0430 DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$tf_0430
$pdata$tf_0431 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0431
$pdata$tf_0432 DD imagerel $LN3
	DD	imagerel $LN3+190
	DD	imagerel $unwind$tf_0432
$pdata$tf_0433 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0433
$pdata$tf_0434 DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$tf_0434
$pdata$tf_0435 DD imagerel $LN3
	DD	imagerel $LN3+268
	DD	imagerel $unwind$tf_0435
$pdata$tf_0436 DD imagerel $LN3
	DD	imagerel $LN3+170
	DD	imagerel $unwind$tf_0436
$pdata$tf_0437 DD imagerel $LN3
	DD	imagerel $LN3+172
	DD	imagerel $unwind$tf_0437
$pdata$tf_0438 DD imagerel $LN3
	DD	imagerel $LN3+240
	DD	imagerel $unwind$tf_0438
$pdata$tf_0439 DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$tf_0439
$pdata$tf_0440 DD imagerel $LN3
	DD	imagerel $LN3+244
	DD	imagerel $unwind$tf_0440
$pdata$tf_0441 DD imagerel $LN3
	DD	imagerel $LN3+226
	DD	imagerel $unwind$tf_0441
$pdata$tf_0442 DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$tf_0442
$pdata$tf_0516 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0516
$pdata$tf_0517 DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$tf_0517
$pdata$tf_0518 DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$tf_0518
$pdata$tf_0519 DD imagerel $LN3
	DD	imagerel $LN3+201
	DD	imagerel $unwind$tf_0519
$pdata$tf_0520 DD imagerel $LN3
	DD	imagerel $LN3+172
	DD	imagerel $unwind$tf_0520
$pdata$tf_0800 DD imagerel $LN13
	DD	imagerel $LN13+301
	DD	imagerel $unwind$tf_0800
$pdata$tf_0801 DD imagerel $LN7
	DD	imagerel $LN7+214
	DD	imagerel $unwind$tf_0801
$pdata$tf_0802 DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$tf_0802
$pdata$tf_0803 DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$tf_0803
$pdata$tf_0804 DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$tf_0804
$pdata$tf_0806 DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$tf_0806
$pdata$tf_0807 DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$tf_0807
$pdata$tf_0808 DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$tf_0808
$pdata$tf_0809 DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$tf_0809
$pdata$tf_0811 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_0811
$pdata$tf_0812 DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$tf_0812
$pdata$tf_0814 DD imagerel $LN3
	DD	imagerel $LN3+152
	DD	imagerel $unwind$tf_0814
$pdata$tf_0840 DD imagerel $LN5
	DD	imagerel $LN5+138
	DD	imagerel $unwind$tf_0840
$pdata$tf_0844 DD imagerel $LN3
	DD	imagerel $LN3+188
	DD	imagerel $unwind$tf_0844
$pdata$tf_0845 DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$tf_0845
$pdata$tf_0846 DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$tf_0846
$pdata$tf_1300 DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$tf_1300
$pdata$tf_1301 DD imagerel $LN3
	DD	imagerel $LN3+209
	DD	imagerel $unwind$tf_1301
$pdata$tf_1304 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1304
$pdata$tf_1305 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1305
$pdata$tf_1306 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1306
$pdata$tf_1307 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1307
$pdata$tf_1308 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1308
$pdata$tf_1309 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1309
$pdata$tf_1310 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1310
$pdata$tf_1311 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1311
$pdata$tf_1312 DD imagerel $LN3
	DD	imagerel $LN3+192
	DD	imagerel $unwind$tf_1312
$pdata$tf_1313 DD imagerel $LN5
	DD	imagerel $LN5+212
	DD	imagerel $unwind$tf_1313
$pdata$tf_1315 DD imagerel $LN3
	DD	imagerel $LN3+199
	DD	imagerel $unwind$tf_1315
$pdata$tf_1316 DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$tf_1316
$pdata$tf_1317 DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$tf_1317
$pdata$tf_1318 DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$tf_1318
$pdata$tf_1320 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1320
$pdata$tf_1321 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1321
$pdata$tf_1329 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1329
$pdata$tf_1330 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1330
$pdata$tf_1331 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1331
$pdata$tf_1332 DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$tf_1332
$pdata$tf_1333 DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$tf_1333
$pdata$tf_1334 DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$tf_1334
$pdata$tf_1336 DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$tf_1336
$pdata$tf_2269 DD imagerel $LN5
	DD	imagerel $LN5+182
	DD	imagerel $unwind$tf_2269
$pdata$tf_2270 DD imagerel $LN5
	DD	imagerel $LN5+179
	DD	imagerel $unwind$tf_2270
$pdata$tf_2271 DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$tf_2271
$pdata$tf_2272 DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$tf_2272
$pdata$tf_2276 DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$tf_2276
$pdata$tf_2277 DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$tf_2277
$pdata$tf_2324 DD imagerel $LN7
	DD	imagerel $LN7+303
	DD	imagerel $unwind$tf_2324
$pdata$tf_2326 DD imagerel $LN6
	DD	imagerel $LN6+256
	DD	imagerel $unwind$tf_2326
$pdata$tf_MAX_RECSIZE DD imagerel $LN76
	DD	imagerel $LN76+1203
	DD	imagerel $unwind$tf_MAX_RECSIZE
$pdata$tf_close DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$tf_close
$pdata$tf_close_locked DD imagerel $LN16
	DD	imagerel $LN16+488
	DD	imagerel $unwind$tf_close_locked
$pdata$tf_autostop DD imagerel $LN22
	DD	imagerel $LN22+628
	DD	imagerel $unwind$tf_autostop
$pdata$tf_are_swaps_needed DD imagerel $LN9
	DD	imagerel $LN9+133
	DD	imagerel $unwind$tf_are_swaps_needed
$pdata$tf_swap_sys DD imagerel $LN5
	DD	imagerel $LN5+188
	DD	imagerel $unwind$tf_swap_sys
$pdata$tf_swap_hdr DD imagerel $LN3
	DD	imagerel $LN3+169
	DD	imagerel $unwind$tf_swap_hdr
$pdata$tf_swap_rec DD imagerel $LN116
	DD	imagerel $LN116+4973
	DD	imagerel $unwind$tf_swap_rec
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+267
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+87
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+70
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$get_symbol_token DD imagerel get_symbol_token
	DD	imagerel get_symbol_token+511
	DD	imagerel $unwind$get_symbol_token
$pdata$_fmt_memsize DD imagerel _fmt_memsize
	DD	imagerel _fmt_memsize+243
	DD	imagerel $unwind$_fmt_memsize
$pdata$tf_virt_to_real DD imagerel tf_virt_to_real
	DD	imagerel tf_virt_to_real+252
	DD	imagerel $unwind$tf_virt_to_real
$pdata$tf_get_storage_key DD imagerel tf_get_storage_key
	DD	imagerel tf_get_storage_key+137
	DD	imagerel $unwind$tf_get_storage_key
$pdata$tf_store_int_timer DD imagerel tf_store_int_timer
	DD	imagerel tf_store_int_timer+174
	DD	imagerel $unwind$tf_store_int_timer
$pdata$tf_apply_prefixing DD imagerel tf_apply_prefixing
	DD	imagerel tf_apply_prefixing+325
	DD	imagerel $unwind$tf_apply_prefixing
$pdata$tf_write_initial_TFSYS_locked DD imagerel tf_write_initial_TFSYS_locked
	DD	imagerel tf_write_initial_TFSYS_locked+597
	DD	imagerel $unwind$tf_write_initial_TFSYS_locked
$pdata$tf_write DD imagerel tf_write
	DD	imagerel tf_write+1161
	DD	imagerel $unwind$tf_write
$pdata$tf_2326_op DD imagerel tf_2326_op
	DD	imagerel tf_2326_op+616
	DD	imagerel $unwind$tf_2326_op
pdata	ENDS
_DATA	SEGMENT
$SG159179 DB	'DATE', 00H
	ORG $+3
$SG159180 DB	'%Y%m%d', 00H
	ORG $+1
$SG159181 DB	'DATE', 00H
	ORG $+3
$SG159183 DB	'TIME', 00H
	ORG $+3
$SG159184 DB	'%H%M%S', 00H
	ORG $+1
$SG159185 DB	'TIME', 00H
	ORG $+3
$SG159188 DB	'%s', 00H
	ORG $+1
$SG159219 DB	'$(', 00H
	ORG $+1
$SG159220 DB	'${', 00H
	ORG $+1
$SG159224 DB	'E', 00H
	ORG $+6
$SG159225 DB	'HHC01418%s Symbol expansion will result in buffer overfl'
	DB	'ow; ignored', 0aH, 00H
	ORG $+3
$SG159226 DB	'resolve_symbol_string', 00H
	ORG $+2
$SG159227 DB	'hscutl.c', 00H
	ORG $+3
$SG159241 DB	'E', 00H
	ORG $+2
$SG159242 DB	'HHC01418%s Symbol expansion will result in buffer overfl'
	DB	'ow; ignored', 0aH, 00H
	ORG $+3
$SG159243 DB	'resolve_symbol_string', 00H
	ORG $+2
$SG159244 DB	'hscutl.c', 00H
	ORG $+3
$SG159245 DB	'%s', 00H
	ORG $+1
$SG159263 DB	'I', 00H
	ORG $+2
$SG159491 DB	'%llu%c', 00H
	ORG $+1
$SG159572 DB	'.', 00H
	ORG $+2
$SG159264 DB	'HHC02199%s Symbol %-12s %s', 0aH, 00H
$SG159613 DB	'%d', 00H
	ORG $+1
$SG159265 DB	'list_all_symbols', 00H
	ORG $+3
$SG159473 DB	'.%06d', 00H
	ORG $+2
$SG159615 DB	',', 00H
	ORG $+2
$SG159266 DB	'hscutl.c', 00H
	ORG $+3
$SG159616 DB	')', 00H
	ORG $+2
$SG159292 DB	'timeval_subtract', 00H
	ORG $+3
$SG159618 DB	'(', 00H
	ORG $+2
$SG159293 DB	'hscutl.c', 00H
	ORG $+7
$SG159296 DB	'timeval_subtract', 00H
	ORG $+7
$SG159294 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159297 DB	'hscutl.c', 00H
	ORG $+7
$SG159302 DB	'timeval_subtract', 00H
	ORG $+7
$SG159298 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159303 DB	'hscutl.c', 00H
	ORG $+7
$SG159306 DB	'timeval_subtract', 00H
	ORG $+7
$SG159304 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159307 DB	'hscutl.c', 00H
	ORG $+7
$SG159332 DB	'timeval_add', 00H
$SG159528 DB	'%lld', 00H
	ORG $+7
$SG159308 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159333 DB	'hscutl.c', 00H
	ORG $+7
$SG159336 DB	'timeval_add', 00H
$SG159622 DB	', ...', 00H
	ORG $+6
$SG159334 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159337 DB	'hscutl.c', 00H
	ORG $+7
$SG159342 DB	'timeval_add', 00H
$SG159650 DB	', ...', 00H
	ORG $+6
$SG159338 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159343 DB	'hscutl.c', 00H
	ORG $+7
$SG159346 DB	'timeval_add', 00H
$SG159652 DB	'=0', 00H
	ORG $+1
$SG159471 DB	'%Y-%m-%d %H:%M:%S', 00H
	ORG $+6
$SG159344 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159347 DB	'hscutl.c', 00H
	ORG $+7
$SG159561 DB	'EXTERNALGUI', 00H
$SG159821 DB	'W', 00H
	ORG $+2
$SG159567 DB	'&sysblk.dasdcache_lock', 00H
	ORG $+1
$SG159348 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159566 DB	'hscutl.c:1388', 00H
	ORG $+2
$SG159568 DB	'hscutl.c:1389', 00H
	ORG $+2
$SG159569 DB	'&sysblk.scrlock', 00H
$SG159570 DB	'hscutl.c:1390', 00H
	ORG $+2
$SG159574 DB	'%s - %s', 00H
$SG159577 DB	'hercifc', 00H
rev_nib_bits_tab DB 00H
	DB	08H
	DB	04H
	DB	0cH
	DB	02H
	DB	0aH
	DB	06H
	DB	0eH
	DB	01H
	DB	09H
	DB	05H
	DB	0dH
	DB	03H
	DB	0bH
	DB	07H
	DB	0fH
$SG159610 DB	'lpi=%d lpp=%d cctape=(', 00H
	ORG $+1
$SG159620 DB	'%d=%s%s%s,', 00H
	ORG $+1
$SG159860 DB	'??', 00H
	ORG $+1
$SG159646 DB	'index=%d lpi=%d lpp=%d fcb', 00H
	ORG $+1
$SG160045 DB	'ZAD', 00H
$SG159648 DB	'%c%d:%d', 00H
$SG159819 DB	'OVERFLOW (bufsiz too small)', 00H
?test@?1??are_big_endian@@9@9 DD 01020304H		; `are_big_endian'::`2'::test
$SG159820 DB	'idx_snprintf', 00H
	ORG $+3
$SG159822 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159823 DB	'idx_snprintf', 00H
	ORG $+3
$SG159824 DB	'hscutl.c', 00H
	ORG $+7
ptypes	DB	00H
	ORG $+7
	DQ	FLAT:$SG159831
	DQ	FLAT:$SG159832
	DB	01H
	ORG $+7
	DQ	FLAT:$SG159833
	DQ	FLAT:$SG159834
	DB	02H
	ORG $+7
	DQ	FLAT:$SG159835
	DQ	FLAT:$SG159836
	DB	03H
	ORG $+7
	DQ	FLAT:$SG159837
	DQ	FLAT:$SG159838
	DB	04H
	ORG $+7
	DQ	FLAT:$SG159839
	DQ	FLAT:$SG159840
	DB	05H
	ORG $+7
	DQ	FLAT:$SG159841
	DQ	FLAT:$SG159842
$SG159851 DB	'                ', 00H
	ORG $+7
$SG159993 DB	'PER event', 00H
	ORG $+6
$SG159996 DB	'Unassigned exception', 00H
	ORG $+3
?pgmintname@?1??PIC2Name@@9@9 DQ FLAT:$SG159928		; `PIC2Name'::`2'::pgmintname
	DQ	FLAT:$SG159929
	DQ	FLAT:$SG159930
	DQ	FLAT:$SG159931
	DQ	FLAT:$SG159932
	DQ	FLAT:$SG159933
	DQ	FLAT:$SG159934
	DQ	FLAT:$SG159935
	DQ	FLAT:$SG159936
	DQ	FLAT:$SG159937
	DQ	FLAT:$SG159938
	DQ	FLAT:$SG159939
	DQ	FLAT:$SG159940
	DQ	FLAT:$SG159941
	DQ	FLAT:$SG159942
	DQ	FLAT:$SG159943
	DQ	FLAT:$SG159944
	DQ	FLAT:$SG159945
	DQ	FLAT:$SG159946
	DQ	FLAT:$SG159947
	DQ	FLAT:$SG159948
	DQ	FLAT:$SG159949
	DQ	FLAT:$SG159950
	DQ	FLAT:$SG159951
	DQ	FLAT:$SG159952
	DQ	FLAT:$SG159953
	DQ	FLAT:$SG159954
	DQ	FLAT:$SG159955
	DQ	FLAT:$SG159956
	DQ	FLAT:$SG159957
	DQ	FLAT:$SG159958
	DQ	FLAT:$SG159959
	DQ	FLAT:$SG159960
	DQ	FLAT:$SG159961
	DQ	FLAT:$SG159962
	DQ	FLAT:$SG159963
	DQ	FLAT:$SG159964
	DQ	FLAT:$SG159965
	DQ	FLAT:$SG159966
	DQ	FLAT:$SG159967
	DQ	FLAT:$SG159968
	DQ	FLAT:$SG159969
	DQ	FLAT:$SG159970
	DQ	FLAT:$SG159971
	DQ	FLAT:$SG159972
	DQ	FLAT:$SG159973
	DQ	FLAT:$SG159974
	DQ	FLAT:$SG159975
	DQ	FLAT:$SG159976
	DQ	FLAT:$SG159977
	DQ	FLAT:$SG159978
	DQ	FLAT:$SG159979
	DQ	FLAT:$SG159980
	DQ	FLAT:$SG159981
	DQ	FLAT:$SG159982
	DQ	FLAT:$SG159983
	DQ	FLAT:$SG159984
	DQ	FLAT:$SG159985
	DQ	FLAT:$SG159986
	DQ	FLAT:$SG159987
	DQ	FLAT:$SG159988
	DQ	FLAT:$SG159989
	DQ	FLAT:$SG159990
	DQ	FLAT:$SG159991
$SG159997 DB	'Unassigned exception', 00H
	ORG $+3
$SG160037 DB	'BRANCH', 00H
	ORG $+1
?ordername@?1??order2name@@9@9 DQ FLAT:$SG160003	; `order2name'::`2'::ordername
	DQ	FLAT:$SG160004
	DQ	FLAT:$SG160005
	DQ	FLAT:$SG160006
	DQ	FLAT:$SG160007
	DQ	FLAT:$SG160008
	DQ	FLAT:$SG160009
	DQ	FLAT:$SG160010
	DQ	FLAT:$SG160011
	DQ	FLAT:$SG160012
	DQ	FLAT:$SG160013
	DQ	FLAT:$SG160014
	DQ	FLAT:$SG160015
	DQ	FLAT:$SG160016
	DQ	FLAT:$SG160017
	DQ	FLAT:$SG160018
	DQ	FLAT:$SG160019
	DQ	FLAT:$SG160020
	DQ	FLAT:$SG160021
	DQ	FLAT:$SG160022
	DQ	FLAT:$SG160023
	DQ	FLAT:$SG160024
$SG160025 DB	'Unassigned', 00H
	ORG $+1
$SG160039 DB	'IFETCH', 00H
	ORG $+1
$SG160041 DB	'STOR', 00H
	ORG $+3
$SG160043 DB	'SKEY', 00H
	ORG $+3
$SG160047 DB	'TEND', 00H
	ORG $+3
$SG160049 DB	'IFNULL', 00H
	ORG $+1
$SG160051 DB	'STOR', 00H
	ORG $+3
$SG160053 DB	'STURA', 00H
	ORG $+2
$SG160179 DB	'E', 00H
	ORG $+2
$SG160055 DB	'IFETCH+IFNULL', 00H
	ORG $+2
$SG160057 DB	'IFETCH+TEND', 00H
$SG160183 DB	'I', 00H
	ORG $+2
$SG160059 DB	'UNKNOWN!', 00H
	ORG $+7
$SG160180 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG160072 DB	'IntP:%2.2X%2.2X%2.2X%2.2X Key:%d LPM:%2.2X Flags:%X%2.2X'
	DB	'%2.2X %c%c%c%c%c%c%c%c%c%c%c%c %c%c.....%c %cCW:%2.2X%2.2X%2.'
	DB	'2X%2.2X', 00H
	ORG $+3
$SG160178 DB	'fwrite()', 00H
	ORG $+3
$SG160199 DB	'E', 00H
	ORG $+2
$SG160181 DB	'tf_write_initial_TFSYS_locked', 00H
	ORG $+2
$SG160182 DB	'hscutl.c', 00H
	ORG $+3
$SG160205 DB	'E', 00H
	ORG $+2
$SG160184 DB	'HHC02383%s Trace file tracing begun...', 0aH, 00H
$SG160185 DB	'tf_write_initial_TFSYS_locked', 00H
	ORG $+2
$SG160186 DB	'hscutl.c', 00H
	ORG $+3
$SG160266 DB	'E', 00H
	ORG $+2
$SG160198 DB	'fseek()', 00H
$SG160200 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG160201 DB	'tf_close_locked', 00H
$SG160202 DB	'hscutl.c', 00H
	ORG $+3
$SG160279 DB	'I', 00H
	ORG $+2
$SG160204 DB	'fwrite()', 00H
	ORG $+3
$SG160284 DB	'I', 00H
	ORG $+2
$SG160206 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG160207 DB	'tf_close_locked', 00H
$SG160208 DB	'hscutl.c', 00H
	ORG $+7
$SG160210 DB	'tf_close_locked', 00H
$SG160211 DB	'hscutl.c', 00H
	ORG $+7
$SG160212 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160214 DB	'tf_close_locked', 00H
$SG160215 DB	'hscutl.c', 00H
	ORG $+15
$SG160216 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160224 DB	'hscutl.c:2710', 00H
	ORG $+2
$SG160225 DB	'hscutl.c:2714', 00H
	ORG $+2
$SG160256 DB	'hscutl.c:2732', 00H
	ORG $+2
$SG160258 DB	'hscutl.c:2737', 00H
	ORG $+2
$SG160261 DB	'hscutl.c:2749', 00H
	ORG $+2
$SG160262 DB	'tf_close', 00H
	ORG $+7
$SG160265 DB	'fwrite()', 00H
	ORG $+7
$SG160267 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG160268 DB	'tf_write', 00H
	ORG $+7
$SG160269 DB	'hscutl.c', 00H
	ORG $+7
$SG160274 DB	'hscutl.c:2806', 00H
	ORG $+2
$SG160278 DB	'continues', 00H
	ORG $+6
$SG160280 DB	'HHC02379%s Trace file MAX= reached; file closed, tracing'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG160281 DB	'tf_write', 00H
	ORG $+7
$SG160282 DB	'hscutl.c', 00H
	ORG $+7
$SG160283 DB	'auto-stopped', 00H
	ORG $+3
$SG160285 DB	'HHC02379%s Trace file MAX= reached; file closed, tracing'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG160286 DB	'tf_write', 00H
	ORG $+7
$SG160287 DB	'hscutl.c', 00H
	ORG $+7
$SG160302 DB	'hscutl.c:2837', 00H
	ORG $+2
$SG160304 DB	'hscutl.c:2865', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_fmt_memsize
	DD	021H
	DD	0e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2324
	DD	01dH
	DD	0115H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2277
	DD	018H
	DD	05aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2276
	DD	013H
	DD	079H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2272
	DD	018H
	DD	05aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2271
	DD	018H
	DD	064H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2270
	DD	018H
	DD	099H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_2269
	DD	01dH
	DD	09cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1336
	DD	013H
	DD	075H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1334
	DD	01aH
	DD	06fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1333
	DD	017H
	DD	058H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1332
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1331
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1330
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1329
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1321
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1320
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1318
	DD	017H
	DD	058H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1317
	DD	01aH
	DD	066H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1316
	DD	018H
	DD	05dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1315
	DD	025H
	DD	0b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1313
	DD	018H
	DD	0baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1312
	DD	023H
	DD	0acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1311
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1310
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1309
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1308
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1307
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1306
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1305
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1304
	DD	013H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1301
	DD	025H
	DD	0bdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_1300
	DD	017H
	DD	058H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0846
	DD	013H
	DD	042H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0845
	DD	013H
	DD	056H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0844
	DD	013H
	DD	0aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0840
	DD	018H
	DD	078H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0814
	DD	022H
	DD	086H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0812
	DD	013H
	DD	031H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0811
	DD	018H
	DD	04bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0809
	DD	018H
	DD	051H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0808
	DD	013H
	DD	031H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0807
	DD	022H
	DD	062H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0806
	DD	021H
	DD	057H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0804
	DD	023H
	DD	061H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0803
	DD	018H
	DD	051H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0802
	DD	023H
	DD	05dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0801
	DD	01dH
	DD	0c4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0800
	DD	018H
	DD	0113H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0520
	DD	016H
	DD	094H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0519
	DD	024H
	DD	0b1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0518
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0517
	DD	01aH
	DD	08fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0516
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0442
	DD	016H
	DD	093H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0441
	DD	016H
	DD	0caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0440
	DD	016H
	DD	0dcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0439
	DD	01aH
	DD	0b4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0438
	DD	025H
	DD	0d8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0437
	DD	016H
	DD	094H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0436
	DD	016H
	DD	092H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0435
	DD	016H
	DD	0f4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0434
	DD	016H
	DD	093H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0433
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0432
	DD	016H
	DD	0a6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0431
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0430
	DD	01cH
	DD	0b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0429
	DD	01fH
	DD	0c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0428
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0427
	DD	01aH
	DD	08fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0426
	DD	01fH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0425
	DD	016H
	DD	092H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0424
	DD	01aH
	DD	0a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tf_0423
	DD	022H
	DD	0b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatCCTAPE
	DD	025H
	DD	0303H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatFCB
	DD	022H
	DD	016dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:initialize_utility
	DD	025H
	DD	0352H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fmt_S64
	DD	018H
	DD	014bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:timed_wait_condition_relative_usecs_impl
	DD	022H
	DD	0deH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:resolve_symbol_string
	DD	017H
	DD	049fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_symbol
	DD	01cH
	DD	0199H
voltbl	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$strcaseabbrev DD 011301H
	DD	08213H
$unwind$get_symbol DD 022419H
	DD	0100d0112H
	DD	imagerel __GSHandlerCheck
	DD	08050H
$unwind$resolve_symbol_string DD 031f19H
	DD	011a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	08c0H
$unwind$set_symbol DD 010e01H
	DD	0620eH
$unwind$del_symbol DD 010901H
	DD	06209H
$unwind$list_all_symbols DD 010401H
	DD	0e204H
$unwind$strlcpy DD 011301H
	DD	04213H
$unwind$strlcat DD 011301H
	DD	0a213H
$unwind$timeval_subtract DD 011301H
	DD	08213H
$unwind$timeval_add DD 010e01H
	DD	0620eH
$unwind$timed_wait_condition_relative_usecs_impl DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$hprintf DD 011701H
	DD	08217H
$unwind$hwrite DD 011201H
	DD	04212H
$unwind$hgetc DD 010801H
	DD	06208H
$unwind$hgets DD 011301H
	DD	06213H
$unwind$hpcalloc DD 010d01H
	DD	0a20dH
$unwind$hpcfree DD 010d01H
	DD	0620dH
$unwind$trimloc DD 010901H
	DD	06209H
$unwind$FormatTIMEVAL DD 011301H
	DD	08213H
$unwind$fmt_memsize DD 011301H
	DD	04213H
$unwind$fmt_memsize_KB DD 011301H
	DD	04213H
$unwind$fmt_memsize_MB DD 011301H
	DD	04213H
$unwind$fmt_S64 DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$initialize_utility DD 032d19H
	DD	04e011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$FormatFCB DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$FormatCCTAPE DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$tkcount DD 010e01H
	DD	0820eH
$unwind$ltrim DD 010e01H
	DD	0420eH
$unwind$rtrim DD 010e01H
	DD	0620eH
$unwind$trim DD	010e01H
	DD	0420eH
$unwind$parse_args DD 011701H
	DD	06217H
$unwind$init_random DD 020601H
	DD	070025206H
$unwind$is_numeric DD 010901H
	DD	04209H
$unwind$is_numeric_l DD 010e01H
	DD	0220eH
$unwind$is_hex DD 010901H
	DD	04209H
$unwind$is_hex_l DD 010e01H
	DD	0220eH
$unwind$string_to_upper DD 010901H
	DD	06209H
$unwind$string_to_lower DD 010901H
	DD	06209H
$unwind$convert_to_ebcdic DD 011201H
	DD	06212H
$unwind$make_asciiz DD 011701H
	DD	06217H
$unwind$idx_snprintf DD 011701H
	DD	0e217H
$unwind$ptyp2long DD 010801H
	DD	02208H
$unwind$ptyp2short DD 010801H
	DD	02208H
$unwind$short2ptyp DD 010901H
	DD	06209H
$unwind$do_make_psw64 DD 011701H
	DD	06217H
$unwind$PIC2Name DD 010801H
	DD	02208H
$unwind$order2name DD 010801H
	DD	02208H
$unwind$perc2name DD 011201H
	DD	06212H
$unwind$FormatORB DD 092001H
	DD	0280120H
	DD	0e017f019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
$unwind$are_big_endian DD 010401H
	DD	02204H
$unwind$tf_0423 DD 042a19H
	DD	0310118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$tf_0424 DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0425 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0426 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0427 DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0428 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0429 DD 022719H
	DD	02d0115H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0430 DD 042419H
	DD	02d0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0431 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0432 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0433 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0434 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0435 DD 021e19H
	DD	02d010cH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0436 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0437 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0438 DD 022d19H
	DD	02d011bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0439 DD 022219H
	DD	02d0110H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0440 DD 021e19H
	DD	02d010cH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0441 DD 021e19H
	DD	02d010cH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0442 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0516 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0517 DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0518 DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0519 DD 022c19H
	DD	02d011aH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$tf_0520 DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$tf_0800 DD 042019H
	DD	013010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$tf_0801 DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_0802 DD 012819H
	DD	0a219H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_0803 DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$tf_0804 DD 012819H
	DD	0a219H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_0806 DD 012619H
	DD	0a217H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_0807 DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_0808 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_0809 DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$tf_0811 DD 011d19H
	DD	0a20eH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_0812 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_0814 DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_0840 DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_0844 DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_0845 DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_0846 DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_1300 DD 011c19H
	DD	0a20dH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_1301 DD 032a19H
	DD	07017c21bH
	DD	06016H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$tf_1304 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1305 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1306 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1307 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1308 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1309 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1310 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1311 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1312 DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_1313 DD 042019H
	DD	01f010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$tf_1315 DD 032a19H
	DD	07017c21bH
	DD	06016H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$tf_1316 DD 011d19H
	DD	0a20eH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_1317 DD 031f19H
	DD	0700ca210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_1318 DD 011c19H
	DD	0a20dH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_1320 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1321 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1329 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1330 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1331 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1332 DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$tf_1333 DD 011c19H
	DD	0a20dH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_1334 DD 031f19H
	DD	0700cc210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$tf_1336 DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$tf_2269 DD 042519H
	DD	01d0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$tf_2270 DD 042019H
	DD	01d010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$tf_2271 DD 042019H
	DD	01b010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$tf_2272 DD 042019H
	DD	013010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$tf_2276 DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$tf_2277 DD 042019H
	DD	04b010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$tf_2324 DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$tf_2326 DD 011801H
	DD	08218H
$unwind$tf_MAX_RECSIZE DD 010401H
	DD	02204H
$unwind$tf_close DD 010901H
	DD	04209H
$unwind$tf_close_locked DD 010401H
	DD	0c204H
$unwind$tf_autostop DD 010401H
	DD	0a204H
$unwind$tf_are_swaps_needed DD 010901H
	DD	06209H
$unwind$tf_swap_sys DD 010901H
	DD	06209H
$unwind$tf_swap_hdr DD 010901H
	DD	04209H
$unwind$tf_swap_rec DD 021101H
	DD	0370111H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$get_symbol_token DD 010d01H
	DD	0620dH
$unwind$_fmt_memsize DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$tf_virt_to_real DD 011801H
	DD	08218H
$unwind$tf_get_storage_key DD 010e01H
	DD	0620eH
$unwind$tf_store_int_timer DD 010e01H
	DD	0820eH
$unwind$tf_apply_prefixing DD 010e01H
	DD	0620eH
$unwind$tf_write_initial_TFSYS_locked DD 030b01H
	DD	07007e20bH
	DD	06006H
$unwind$tf_write DD 041f01H
	DD	013011fH
	DD	060177018H
$unwind$tf_2326_op DD 031a01H
	DD	07016c21aH
	DD	06015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
ar$1 = 48
tv94 = 52
stid$2 = 56
amt$3 = 64
abs$4 = 72
bytemask$5 = 80
pagesize$6 = 88
regs$ = 128
op$ = 136
opcode1$ = 144
opcode2$ = 152
b$ = 160
isop2$ = 168
tf_2326_op PROC

; 3825 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3826 :     if (b >= 0)

  0001a	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR b$[rsp], 0
  00022	0f 8c 39 02 00
	00		 jl	 $LN2@tf_2326_op

; 3827 :     {
; 3828 :         int ar, stid;
; 3829 : 
; 3830 :         /* Determine if operand should be treated as a real address */
; 3831 :         if (0
; 3832 :             || REAL_MODE( &regs->psw )
; 3833 :             || (isop2 && IS_REAL_ADDR_OP( opcode1, opcode2 ))

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 b4 00 00
	00		 jne	 $LN5@tf_2326_op
  00032	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0003e	83 e0 08	 and	 eax, 8
  00041	85 c0		 test	 eax, eax
  00043	0f 84 9d 00 00
	00		 je	 $LN5@tf_2326_op
  00049	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00051	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00055	83 e0 04	 and	 eax, 4
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 86 00 00
	00		 je	 $LN5@tf_2326_op
  00060	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR isop2$[rsp]
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 80 00 00
	00		 je	 $LN3@tf_2326_op
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 70		 jne	 SHORT $LN6@tf_2326_op
  00076	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR opcode1$[rsp]
  0007e	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00083	75 0d		 jne	 SHORT $LN7@tf_2326_op
  00085	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR opcode2$[rsp]
  0008d	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00090	74 54		 je	 SHORT $LN6@tf_2326_op
$LN7@tf_2326_op:
  00092	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR opcode1$[rsp]
  0009a	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  0009f	75 0d		 jne	 SHORT $LN8@tf_2326_op
  000a1	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR opcode2$[rsp]
  000a9	83 f8 46	 cmp	 eax, 70			; 00000046H
  000ac	74 38		 je	 SHORT $LN6@tf_2326_op
$LN8@tf_2326_op:
  000ae	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR opcode1$[rsp]
  000b6	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  000bb	75 0d		 jne	 SHORT $LN9@tf_2326_op
  000bd	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR opcode2$[rsp]
  000c5	83 f8 05	 cmp	 eax, 5
  000c8	74 1c		 je	 SHORT $LN6@tf_2326_op
$LN9@tf_2326_op:
  000ca	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR opcode1$[rsp]
  000d2	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  000d7	75 17		 jne	 SHORT $LN3@tf_2326_op
  000d9	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR opcode2$[rsp]
  000e1	83 f8 25	 cmp	 eax, 37			; 00000025H
  000e4	75 0a		 jne	 SHORT $LN3@tf_2326_op
$LN6@tf_2326_op:
$LN5@tf_2326_op:

; 3834 :         )
; 3835 :             ar = USE_REAL_ADDR;

  000e6	c7 44 24 30 fe
	ff ff ff	 mov	 DWORD PTR ar$1[rsp], -2
  000ee	eb 0b		 jmp	 SHORT $LN4@tf_2326_op
$LN3@tf_2326_op:

; 3836 :         else
; 3837 :             ar = b;

  000f0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  000f7	89 44 24 30	 mov	 DWORD PTR ar$1[rsp], eax
$LN4@tf_2326_op:

; 3838 : 
; 3839 :         /* Get the real address for this virtual address */
; 3840 :         if ((op->xcode = tf_virt_to_real( &op->raddr, &stid,
; 3841 :              op->vaddr, ar, regs, ACCTYPE_HW )) == 0)

  000fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR op$[rsp]
  00103	48 83 c0 08	 add	 rax, 8
  00107	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0010f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0011c	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ar$1[rsp]
  00121	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR op$[rsp]
  00129	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0012c	48 8d 54 24 38	 lea	 rdx, QWORD PTR stid$2[rsp]
  00131	48 8b c8	 mov	 rcx, rax
  00134	e8 00 00 00 00	 call	 tf_virt_to_real
  00139	89 44 24 34	 mov	 DWORD PTR tv94[rsp], eax
  0013d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR op$[rsp]
  00145	0f b7 4c 24 34	 movzx	 ecx, WORD PTR tv94[rsp]
  0014a	66 89 48 20	 mov	 WORD PTR [rax+32], cx
  0014e	0f b7 44 24 34	 movzx	 eax, WORD PTR tv94[rsp]
  00153	85 c0		 test	 eax, eax
  00155	0f 85 06 01 00
	00		 jne	 $LN10@tf_2326_op

; 3842 :         {
; 3843 :             U64 pagesize, bytemask, abs;
; 3844 :             size_t amt = sizeof( op->stor );

  0015b	48 c7 44 24 40
	10 00 00 00	 mov	 QWORD PTR amt$3[rsp], 16

; 3845 : 
; 3846 :             /* Convert real address to absolute address */
; 3847 :             abs = tf_apply_prefixing( op->raddr, regs );

  00164	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0016c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR op$[rsp]
  00174	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00178	e8 00 00 00 00	 call	 tf_apply_prefixing
  0017d	48 89 44 24 48	 mov	 QWORD PTR abs$4[rsp], rax

; 3848 : 
; 3849 :             /* Determine page size and byte mask */
; 3850 :             if (regs->arch_mode == ARCH_370_IDX)

  00182	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  0018e	75 14		 jne	 SHORT $LN11@tf_2326_op

; 3851 :             {
; 3852 :                 pagesize = STORAGE_KEY_2K_PAGESIZE;

  00190	48 c7 44 24 58
	00 08 00 00	 mov	 QWORD PTR pagesize$6[rsp], 2048 ; 00000800H

; 3853 :                 bytemask = STORAGE_KEY_2K_BYTEMASK;

  00199	48 c7 44 24 50
	ff 07 00 00	 mov	 QWORD PTR bytemask$5[rsp], 2047 ; 000007ffH

; 3854 :             }

  001a2	eb 12		 jmp	 SHORT $LN12@tf_2326_op
$LN11@tf_2326_op:

; 3855 :             else
; 3856 :             {
; 3857 :                 pagesize = STORAGE_KEY_4K_PAGESIZE;

  001a4	48 c7 44 24 58
	00 10 00 00	 mov	 QWORD PTR pagesize$6[rsp], 4096 ; 00001000H

; 3858 :                 bytemask = STORAGE_KEY_4K_BYTEMASK;

  001ad	48 c7 44 24 50
	ff 0f 00 00	 mov	 QWORD PTR bytemask$5[rsp], 4095 ; 00000fffH
$LN12@tf_2326_op:

; 3859 :             }
; 3860 : 
; 3861 :             /* If virtual storage, only save the data that's
; 3862 :                on this one page (i.e. to the end of the page) */
; 3863 :             if (ar != USE_REAL_ADDR)

  001b6	83 7c 24 30 fe	 cmp	 DWORD PTR ar$1[rsp], -2
  001bb	74 31		 je	 SHORT $LN13@tf_2326_op

; 3864 :             {
; 3865 :                 amt = pagesize - (abs & bytemask);

  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR bytemask$5[rsp]
  001c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR abs$4[rsp]
  001c7	48 23 c8	 and	 rcx, rax
  001ca	48 8b c1	 mov	 rax, rcx
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pagesize$6[rsp]
  001d2	48 2b c8	 sub	 rcx, rax
  001d5	48 8b c1	 mov	 rax, rcx
  001d8	48 89 44 24 40	 mov	 QWORD PTR amt$3[rsp], rax

; 3866 : 
; 3867 :                 if (amt > sizeof( op->stor ))

  001dd	48 83 7c 24 40
	10		 cmp	 QWORD PTR amt$3[rsp], 16
  001e3	76 09		 jbe	 SHORT $LN14@tf_2326_op

; 3868 :                     amt = sizeof( op->stor );

  001e5	48 c7 44 24 40
	10 00 00 00	 mov	 QWORD PTR amt$3[rsp], 16
$LN14@tf_2326_op:
$LN13@tf_2326_op:

; 3869 :             }
; 3870 : 
; 3871 :             /* Update Interval Timer beforehand, if needed */
; 3872 : #if defined( _FEATURE_INTERVAL_TIMER )
; 3873 :             tf_store_int_timer( regs, op->raddr );

  001ee	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR op$[rsp]
  001f6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	e8 00 00 00 00	 call	 tf_store_int_timer

; 3874 : #endif
; 3875 :             /* Save as much operand data as possible */
; 3876 :             memcpy( op->stor, regs->mainstor + abs, amt );

  00207	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00216	48 03 44 24 48	 add	 rax, QWORD PTR abs$4[rsp]
  0021b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR op$[rsp]
  00223	48 83 c1 10	 add	 rcx, 16
  00227	48 8b f9	 mov	 rdi, rcx
  0022a	48 8b f0	 mov	 rsi, rax
  0022d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR amt$3[rsp]
  00232	f3 a4		 rep movsb

; 3877 : 
; 3878 :             /* Save the amount we saved and its storage key */
; 3879 :             op->amt = (BYTE) amt; // (how much we saved)

  00234	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR op$[rsp]
  0023c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR amt$3[rsp]
  00241	88 48 23	 mov	 BYTE PTR [rax+35], cl

; 3880 :             op->skey = tf_get_storage_key( regs, abs );

  00244	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$4[rsp]
  00249	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	e8 00 00 00 00	 call	 tf_get_storage_key
  00256	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR op$[rsp]
  0025e	88 41 22	 mov	 BYTE PTR [rcx+34], al
$LN10@tf_2326_op:
$LN2@tf_2326_op:

; 3881 :         }
; 3882 :     }
; 3883 : }

  00261	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00265	5f		 pop	 rdi
  00266	5e		 pop	 rsi
  00267	c3		 ret	 0
tf_2326_op ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
auto_closed$ = 80
ret$ = 81
nostop$ = 82
hdr$ = 88
tv135 = 96
tv141 = 100
tv192 = 104
tv194 = 108
tod$ = 112
written$ = 120
p$1 = 128
tv160 = 136
regs$ = 176
rec$ = 184
curr$ = 192
msgnum$ = 200
tf_write PROC

; 2721 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2722 :     static size_t  bufsize  = 0;
; 2723 :     static U16     prev     = 0;
; 2724 : 
; 2725 :     TFHDR*   hdr;
; 2726 :     size_t   written;
; 2727 :     TIMEVAL  tod;
; 2728 :     bool     nostop;
; 2729 :     bool     auto_closed = false; // (true when MAX= reached)

  0001f	c6 44 24 50 00	 mov	 BYTE PTR auto_closed$[rsp], 0

; 2730 :     bool     ret = true;

  00024	c6 44 24 51 01	 mov	 BYTE PTR ret$[rsp], 1

; 2731 : 
; 2732 :     OBTAIN_TRACEFILE_LOCK();

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160256
  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 hthread_obtain_lock

; 2733 :     {
; 2734 :         /* Quick exit if tracefile tracing isn't active */
; 2735 :         if (!sysblk.traceFILE)

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00054	75 23		 jne	 SHORT $LN5@tf_write

; 2736 :         {
; 2737 :             RELEASE_TRACEFILE_LOCK();

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005d	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160258
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 hthread_release_lock

; 2738 :             return true;

  00072	b0 01		 mov	 al, 1
  00074	e9 06 04 00 00	 jmp	 $LN1@tf_write
$LN5@tf_write:

; 2739 :         }
; 2740 : 
; 2741 :         gettimeofday( (TIMEVAL*) &tod, NULL );

  00079	33 d2		 xor	 edx, edx
  0007b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tod$[rsp]
  00080	e8 00 00 00 00	 call	 gettimeofday

; 2742 : 
; 2743 :         /* Write TFSYS record if first time */
; 2744 :         if (!sysblk.curtracesize)

  00085	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008c	48 83 b8 28 14
	00 00 00	 cmp	 QWORD PTR [rax+5160], 0
  00094	75 5f		 jne	 SHORT $LN6@tf_write

; 2745 :         {
; 2746 :             if (!tf_write_initial_TFSYS_locked( &tod ))

  00096	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tod$[rsp]
  0009b	e8 00 00 00 00	 call	 tf_write_initial_TFSYS_locked
  000a0	0f b6 c0	 movzx	 eax, al
  000a3	85 c0		 test	 eax, eax
  000a5	75 23		 jne	 SHORT $LN7@tf_write

; 2747 :             {
; 2748 :                 // (error message already issued)
; 2749 :                 RELEASE_TRACEFILE_LOCK();

  000a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ae	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160261
  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 hthread_release_lock

; 2750 :                 return false;

  000c3	32 c0		 xor	 al, al
  000c5	e9 b5 03 00 00	 jmp	 $LN1@tf_write
$LN7@tf_write:

; 2751 :             }
; 2752 : 
; 2753 :             bufsize = tf_MAX_RECSIZE();

  000ca	e8 00 00 00 00	 call	 tf_MAX_RECSIZE
  000cf	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?bufsize@?1??tf_write@@9@9, rax

; 2754 :             prev = 0;

  000d6	33 c0		 xor	 eax, eax
  000d8	66 89 05 00 00
	00 00		 mov	 WORD PTR ?prev@?1??tf_write@@9@9, ax

; 2755 : 
; 2756 :             /* Register shutdown function so close updates TFSYS */
; 2757 :             hdl_addshut( "tf_close", tf_close, NULL );

  000df	45 33 c0	 xor	 r8d, r8d
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tf_close
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160262
  000f0	e8 00 00 00 00	 call	 hdl_addshut
$LN6@tf_write:

; 2758 :         }
; 2759 : 
; 2760 :         /* Copy caller's entire record into our buffer */
; 2761 :         if ((size_t)curr > bufsize) CRASH();

  000f5	0f b7 84 24 c0
	00 00 00	 movzx	 eax, WORD PTR curr$[rsp]
  000fd	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ?bufsize@?1??tf_write@@9@9
  00104	76 1d		 jbe	 SHORT $LN8@tf_write
$LN4@tf_write:
  00106	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$1[rsp], 0
  00112	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$1[rsp]
  0011a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0011d	33 c0		 xor	 eax, eax
  0011f	85 c0		 test	 eax, eax
  00121	75 e3		 jne	 SHORT $LN4@tf_write
$LN8@tf_write:

; 2762 :         hdr = (TFHDR*) sysblk.tracefilebuff;

  00123	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012a	48 8b 80 38 14
	00 00		 mov	 rax, QWORD PTR [rax+5176]
  00131	48 89 44 24 58	 mov	 QWORD PTR hdr$[rsp], rax

; 2763 :         memcpy( hdr, rec, curr );

  00136	0f b7 84 24 c0
	00 00 00	 movzx	 eax, WORD PTR curr$[rsp]
  0013e	48 8b 7c 24 58	 mov	 rdi, QWORD PTR hdr$[rsp]
  00143	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR rec$[rsp]
  0014b	8b c8		 mov	 ecx, eax
  0014d	f3 a4		 rep movsb

; 2764 : 
; 2765 :         /* Finish building their header */
; 2766 :         hdr->prev      = prev;

  0014f	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  00154	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?prev@?1??tf_write@@9@9
  0015b	66 89 08	 mov	 WORD PTR [rax], cx

; 2767 :         hdr->curr      = curr;

  0015e	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  00163	0f b7 8c 24 c0
	00 00 00	 movzx	 ecx, WORD PTR curr$[rsp]
  0016b	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 2768 :         hdr->cpuad     = regs ? regs->cpuad : 0xFFFF;

  0016f	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR regs$[rsp], 0
  00178	74 15		 je	 SHORT $LN18@tf_write
  0017a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00189	89 44 24 60	 mov	 DWORD PTR tv135[rsp], eax
  0018d	eb 08		 jmp	 SHORT $LN19@tf_write
$LN18@tf_write:
  0018f	c7 44 24 60 ff
	ff 00 00	 mov	 DWORD PTR tv135[rsp], 65535 ; 0000ffffH
$LN19@tf_write:
  00197	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  0019c	0f b7 4c 24 60	 movzx	 ecx, WORD PTR tv135[rsp]
  001a1	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2769 :         hdr->msgnum    = msgnum;

  001a5	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  001aa	0f b7 8c 24 c8
	00 00 00	 movzx	 ecx, WORD PTR msgnum$[rsp]
  001b2	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 2770 :         hdr->arch_mode = regs ? regs->arch_mode : 0xFF;

  001b6	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR regs$[rsp], 0
  001bf	74 11		 je	 SHORT $LN20@tf_write
  001c1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  001cc	89 44 24 64	 mov	 DWORD PTR tv141[rsp], eax
  001d0	eb 08		 jmp	 SHORT $LN21@tf_write
$LN20@tf_write:
  001d2	c7 44 24 64 ff
	00 00 00	 mov	 DWORD PTR tv141[rsp], 255 ; 000000ffH
$LN21@tf_write:
  001da	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  001df	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv141[rsp]
  001e4	88 48 10	 mov	 BYTE PTR [rax+16], cl

; 2771 :         hdr->tod       = tod;

  001e7	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  001ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tod$[rsp]
  001f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2772 : 
; 2773 :         /* Update the TFSYS record's end time too */
; 2774 :         memcpy( &tfsys.end_tod, &tod, sizeof( tfsys.end_tod ));

  001f5	48 8b 44 24 70	 mov	 rax, QWORD PTR tod$[rsp]
  001fa	48 89 05 18 00
	00 00		 mov	 QWORD PTR tfsys+24, rax

; 2775 : 
; 2776 :         /* Write caller's entire record to the trace file */
; 2777 :         if ((written = fwrite( hdr, 1, curr,
; 2778 :                 sysblk.traceFILE )) <  curr)

  00201	0f b7 84 24 c0
	00 00 00	 movzx	 eax, WORD PTR curr$[rsp]
  00209	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00210	4c 8b 89 20 14
	00 00		 mov	 r9, QWORD PTR [rcx+5152]
  00217	44 8b c0	 mov	 r8d, eax
  0021a	ba 01 00 00 00	 mov	 edx, 1
  0021f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hdr$[rsp]
  00224	e8 00 00 00 00	 call	 w32_fwrite
  00229	48 89 44 24 78	 mov	 QWORD PTR written$[rsp], rax
  0022e	0f b7 84 24 c0
	00 00 00	 movzx	 eax, WORD PTR curr$[rsp]
  00236	48 39 44 24 78	 cmp	 QWORD PTR written$[rsp], rax
  0023b	73 79		 jae	 SHORT $LN9@tf_write

; 2779 :         {
; 2780 :             // "Error in function %s: %s"
; 2781 :             WRMSG( HHC00075, "E", "fwrite()", strerror( errno ));

  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00243	8b 08		 mov	 ecx, DWORD PTR [rax]
  00245	e8 00 00 00 00	 call	 w32_strerror
  0024a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  00252	b9 01 00 00 00	 mov	 ecx, 1
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0025d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  00265	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160265
  00271	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160266
  0027d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160267
  00289	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00293	41 b9 03 00 00
	00		 mov	 r9d, 3
  00299	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160268
  002a0	ba dd 0a 00 00	 mov	 edx, 2781		; 00000addH
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160269
  002ac	e8 00 00 00 00	 call	 fwritemsg

; 2782 :             ret = false;

  002b1	c6 44 24 51 00	 mov	 BYTE PTR ret$[rsp], 0
$LN9@tf_write:

; 2783 :         }
; 2784 : 
; 2785 :         /* Update variables for next time */
; 2786 :         sysblk.curtracesize += written;

  002b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002bd	48 8b 80 28 14
	00 00		 mov	 rax, QWORD PTR [rax+5160]
  002c4	48 03 44 24 78	 add	 rax, QWORD PTR written$[rsp]
  002c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002d0	48 89 81 28 14
	00 00		 mov	 QWORD PTR [rcx+5160], rax

; 2787 :         prev = curr;

  002d7	0f b7 84 24 c0
	00 00 00	 movzx	 eax, WORD PTR curr$[rsp]
  002df	66 89 05 00 00
	00 00		 mov	 WORD PTR ?prev@?1??tf_write@@9@9, ax

; 2788 : 
; 2789 :         /* Count total trace records */
; 2790 :         if (hdr->cpuad == 0xFFFF)

  002e6	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  002eb	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  002ef	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  002f4	75 13		 jne	 SHORT $LN10@tf_write

; 2791 :             tfsys.tot_dev++;

  002f6	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR tfsys+40
  002fd	48 ff c0	 inc	 rax
  00300	48 89 05 28 00
	00 00		 mov	 QWORD PTR tfsys+40, rax
  00307	eb 21		 jmp	 SHORT $LN11@tf_write
$LN10@tf_write:

; 2792 :         else
; 2793 :         {
; 2794 :             if (hdr->msgnum == 2324)

  00309	48 8b 44 24 58	 mov	 rax, QWORD PTR hdr$[rsp]
  0030e	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00312	3d 14 09 00 00	 cmp	 eax, 2324		; 00000914H
  00317	75 11		 jne	 SHORT $LN12@tf_write

; 2795 :                 tfsys.tot_ins++;

  00319	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR tfsys+32
  00320	48 ff c0	 inc	 rax
  00323	48 89 05 20 00
	00 00		 mov	 QWORD PTR tfsys+32, rax
$LN12@tf_write:
$LN11@tf_write:

; 2796 :         }
; 2797 : 
; 2798 :         /* Stop tracing when MAX size exceeded */
; 2799 :         if (sysblk.curtracesize > sysblk.maxtracesize)

  0032a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00331	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00338	48 8b 89 30 14
	00 00		 mov	 rcx, QWORD PTR [rcx+5168]
  0033f	48 39 88 28 14
	00 00		 cmp	 QWORD PTR [rax+5160], rcx
  00346	76 55		 jbe	 SHORT $LN13@tf_write

; 2800 :         {
; 2801 :             tf_close_locked();

  00348	e8 00 00 00 00	 call	 tf_close_locked

; 2802 :             auto_closed = true; // (handled further below)

  0034d	c6 44 24 50 01	 mov	 BYTE PTR auto_closed$[rsp], 1

; 2803 :             nostop = sysblk.tfnostop ? true : false;

  00352	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00359	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0035f	c1 e8 09	 shr	 eax, 9
  00362	83 e0 01	 and	 eax, 1
  00365	85 c0		 test	 eax, eax
  00367	74 0a		 je	 SHORT $LN22@tf_write
  00369	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  00371	eb 08		 jmp	 SHORT $LN23@tf_write
$LN22@tf_write:
  00373	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN23@tf_write:
  0037b	83 7c 24 68 00	 cmp	 DWORD PTR tv192[rsp], 0
  00380	75 0a		 jne	 SHORT $LN24@tf_write
  00382	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
  0038a	eb 08		 jmp	 SHORT $LN25@tf_write
$LN24@tf_write:
  0038c	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
$LN25@tf_write:
  00394	0f b6 44 24 6c	 movzx	 eax, BYTE PTR tv194[rsp]
  00399	88 44 24 52	 mov	 BYTE PTR nostop$[rsp], al
$LN13@tf_write:

; 2804 :         }
; 2805 :     }
; 2806 :     RELEASE_TRACEFILE_LOCK();

  0039d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a4	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  003aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160274
  003b1	48 8b c8	 mov	 rcx, rax
  003b4	e8 00 00 00 00	 call	 hthread_release_lock

; 2807 : 
; 2808 :     /* If file automatically closed due to MAX= being reached... */
; 2809 :     if (auto_closed)

  003b9	0f b6 44 24 50	 movzx	 eax, BYTE PTR auto_closed$[rsp]
  003be	85 c0		 test	 eax, eax
  003c0	0f 84 b4 00 00
	00		 je	 $LN14@tf_write

; 2810 :     {
; 2811 :         /* Stop all instruction tracing too unless asked not to */
; 2812 :         if (nostop)

  003c6	0f b6 44 24 52	 movzx	 eax, BYTE PTR nostop$[rsp]
  003cb	85 c0		 test	 eax, eax
  003cd	74 54		 je	 SHORT $LN15@tf_write

; 2813 :         {
; 2814 :             // "Trace file MAX= reached; file closed, tracing %s"
; 2815 :             WRMSG( HHC02379, "I", "continues" );

  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160278
  003e1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160279
  003ed	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160280
  003f9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00403	41 b9 03 00 00
	00		 mov	 r9d, 3
  00409	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160281
  00410	ba ff 0a 00 00	 mov	 edx, 2815		; 00000affH
  00415	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160282
  0041c	e8 00 00 00 00	 call	 fwritemsg

; 2816 :         }

  00421	eb 57		 jmp	 SHORT $LN16@tf_write
$LN15@tf_write:

; 2817 :         else
; 2818 :         {
; 2819 :             tf_autostop();

  00423	e8 00 00 00 00	 call	 tf_autostop

; 2820 : 
; 2821 :             // "Trace file MAX= reached; file closed, tracing %s"
; 2822 :             WRMSG( HHC02379, "I", "auto-stopped" );

  00428	b9 01 00 00 00	 mov	 ecx, 1
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00433	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160283
  0043a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0043f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160284
  00446	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0044b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160285
  00452	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00457	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0045c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00462	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160286
  00469	ba 06 0b 00 00	 mov	 edx, 2822		; 00000b06H
  0046e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160287
  00475	e8 00 00 00 00	 call	 fwritemsg
$LN16@tf_write:
$LN14@tf_write:

; 2823 :         }
; 2824 :     }
; 2825 : 
; 2826 :     return ret;

  0047a	0f b6 44 24 51	 movzx	 eax, BYTE PTR ret$[rsp]
$LN1@tf_write:

; 2827 : }

  0047f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00486	5f		 pop	 rdi
  00487	5e		 pop	 rsi
  00488	c3		 ret	 0
tf_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
ret$ = 80
tv75 = 84
written$ = 88
tv205 = 96
tv144 = 104
tod$ = 144
tf_write_initial_TFSYS_locked PROC

; 2641 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2642 :     size_t  written;
; 2643 :     bool    ret = true;

  0000b	c6 44 24 50 01	 mov	 BYTE PTR ret$[rsp], 1

; 2644 : 
; 2645 :     /* Initialize TFSYS record */
; 2646 : 
; 2647 :     tfsys.ffmt[0] = '%';

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 00	 imul	 rax, rax, 0
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  00020	c6 04 01 25	 mov	 BYTE PTR [rcx+rax], 37	; 00000025H

; 2648 :     tfsys.ffmt[1] = 'T';

  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	48 6b c0 01	 imul	 rax, rax, 1
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  00034	c6 04 01 54	 mov	 BYTE PTR [rcx+rax], 84	; 00000054H

; 2649 :     tfsys.ffmt[2] = 'F';

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	48 6b c0 02	 imul	 rax, rax, 2
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  00048	c6 04 01 46	 mov	 BYTE PTR [rcx+rax], 70	; 00000046H

; 2650 :     tfsys.ffmt[3] = TF_FMT;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	48 6b c0 03	 imul	 rax, rax, 3
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  0005c	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H

; 2651 : 
; 2652 :     tfsys.bigend   = are_big_endian() ? 1 : 0;

  00060	e8 00 00 00 00	 call	 are_big_endian
  00065	0f b6 c0	 movzx	 eax, al
  00068	85 c0		 test	 eax, eax
  0006a	74 0a		 je	 SHORT $LN4@tf_write_i
  0006c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00074	eb 08		 jmp	 SHORT $LN5@tf_write_i
$LN4@tf_write_i:
  00076	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN5@tf_write_i:
  0007e	0f b6 44 24 54	 movzx	 eax, BYTE PTR tv75[rsp]
  00083	88 05 04 00 00
	00		 mov	 BYTE PTR tfsys+4, al

; 2653 :     tfsys.engs     = MAX_CPU_ENGS;

  00089	c6 05 05 00 00
	00 40		 mov	 BYTE PTR tfsys+5, 64	; 00000040H

; 2654 :     tfsys.archnum0 = _ARCH_NUM_0;

  00090	b8 72 01 00 00	 mov	 eax, 370		; 00000172H
  00095	66 89 05 06 00
	00 00		 mov	 WORD PTR tfsys+6, ax

; 2655 :     tfsys.archnum1 = _ARCH_NUM_1;

  0009c	b8 86 01 00 00	 mov	 eax, 390		; 00000186H
  000a1	66 89 05 08 00
	00 00		 mov	 WORD PTR tfsys+8, ax

; 2656 :     tfsys.archnum2 = _ARCH_NUM_2;

  000a8	b8 84 03 00 00	 mov	 eax, 900		; 00000384H
  000ad	66 89 05 0a 00
	00 00		 mov	 WORD PTR tfsys+10, ax

; 2657 : 
; 2658 :     memcpy( &tfsys.beg_tod, tod, sizeof( tfsys.beg_tod ));

  000b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tod$[rsp]
  000bc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bf	48 89 05 10 00
	00 00		 mov	 QWORD PTR tfsys+16, rax

; 2659 :     memset( &tfsys.end_tod,  0,  sizeof( tfsys.end_tod ));

  000c6	48 8d 05 18 00
	00 00		 lea	 rax, OFFSET FLAT:tfsys+24
  000cd	48 8b f8	 mov	 rdi, rax
  000d0	33 c0		 xor	 eax, eax
  000d2	b9 08 00 00 00	 mov	 ecx, 8
  000d7	f3 aa		 rep stosb

; 2660 : 
; 2661 :     STRLCPY( tfsys.version, *sysblk.vers_info );

  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e0	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000e4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  000ea	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ed	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys+48
  000f4	e8 00 00 00 00	 call	 strlcpy

; 2662 :     memcpy( &tfsys.ptyp[0], &sysblk.ptyp[0], MAX_CPU_ENGS );

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	b9 01 00 00 00	 mov	 ecx, 1
  00107	48 6b c9 00	 imul	 rcx, rcx, 0
  0010b	48 8d 15 b0 00
	00 00		 lea	 rdx, OFFSET FLAT:tfsys+176
  00112	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00119	48 89 7c 24 60	 mov	 QWORD PTR tv205[rsp], rdi
  0011e	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv205[rsp]
  00127	48 8d b4 01 48
	0b 00 00	 lea	 rsi, QWORD PTR [rcx+rax+2888]
  0012f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00134	f3 a4		 rep movsb

; 2663 : 
; 2664 :     if ((written = fwrite( &tfsys, 1, tfsys_size,
; 2665 :                 sysblk.traceFILE )) < tfsys_size)

  00136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013d	4c 8b 88 20 14
	00 00		 mov	 r9, QWORD PTR [rax+5152]
  00144	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR tfsys_size
  0014b	ba 01 00 00 00	 mov	 edx, 1
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  00157	e8 00 00 00 00	 call	 w32_fwrite
  0015c	48 89 44 24 58	 mov	 QWORD PTR written$[rsp], rax
  00161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR tfsys_size
  00168	48 39 44 24 58	 cmp	 QWORD PTR written$[rsp], rax
  0016d	73 73		 jae	 SHORT $LN2@tf_write_i

; 2666 :     {
; 2667 :         // "Error in function %s: %s"
; 2668 :         WRMSG( HHC00075, "E", "fwrite()", strerror( errno ));

  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00175	8b 08		 mov	 ecx, DWORD PTR [rax]
  00177	e8 00 00 00 00	 call	 w32_strerror
  0017c	48 89 44 24 68	 mov	 QWORD PTR tv144[rsp], rax
  00181	b9 01 00 00 00	 mov	 ecx, 1
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv144[rsp]
  00191	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160178
  0019d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160179
  001a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160180
  001b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160181
  001cc	ba 6c 0a 00 00	 mov	 edx, 2668		; 00000a6cH
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160182
  001d8	e8 00 00 00 00	 call	 fwritemsg

; 2669 :         ret = false;

  001dd	c6 44 24 50 00	 mov	 BYTE PTR ret$[rsp], 0
$LN2@tf_write_i:

; 2670 :     }
; 2671 : 
; 2672 :     sysblk.curtracesize += written;

  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e9	48 8b 80 28 14
	00 00		 mov	 rax, QWORD PTR [rax+5160]
  001f0	48 03 44 24 58	 add	 rax, QWORD PTR written$[rsp]
  001f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001fc	48 89 81 28 14
	00 00		 mov	 QWORD PTR [rcx+5160], rax

; 2673 : 
; 2674 :     // "Trace file tracing begun..."
; 2675 :     WRMSG( HHC02383, "I" );

  00203	b9 01 00 00 00	 mov	 ecx, 1
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160183
  00215	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160184
  00221	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00231	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160185
  00238	ba 73 0a 00 00	 mov	 edx, 2675		; 00000a73H
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160186
  00244	e8 00 00 00 00	 call	 fwritemsg

; 2676 : 
; 2677 :     return ret;

  00249	0f b6 44 24 50	 movzx	 eax, BYTE PTR ret$[rsp]

; 2678 : }

  0024e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
tf_write_initial_TFSYS_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 0
tv77 = 8
tv89 = 16
tv129 = 24
p$1 = 32
radr$ = 64
regs$ = 72
tf_apply_prefixing PROC

; 2611 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2612 :     switch (regs->arch_mode)

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00016	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00019	83 3c 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  0001d	74 15		 je	 SHORT $LN7@tf_apply_p
  0001f	83 3c 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  00023	74 62		 je	 SHORT $LN8@tf_apply_p
  00025	83 3c 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00029	0f 84 a8 00 00
	00		 je	 $LN9@tf_apply_p
  0002f	e9 f5 00 00 00	 jmp	 $LN10@tf_apply_p
$LN7@tf_apply_p:

; 2613 :     {
; 2614 : #if defined(            _370 )
; 2615 :         case        ARCH_370_IDX:
; 2616 :             return APPLY_370_PREFIXING( radr, regs->PX_370 );

  00034	8b 44 24 40	 mov	 eax, DWORD PTR radr$[rsp]
  00038	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0003e	48 85 c0	 test	 rax, rax
  00041	74 23		 je	 SHORT $LN12@tf_apply_p
  00043	8b 44 24 40	 mov	 eax, DWORD PTR radr$[rsp]
  00047	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00055	48 3b c1	 cmp	 rax, rcx
  00058	74 0c		 je	 SHORT $LN12@tf_apply_p
  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR radr$[rsp]
  0005f	48 89 44 24 08	 mov	 QWORD PTR tv77[rsp], rax
  00064	eb 17		 jmp	 SHORT $LN13@tf_apply_p
$LN12@tf_apply_p:
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0006e	8b 4c 24 40	 mov	 ecx, DWORD PTR radr$[rsp]
  00072	33 c8		 xor	 ecx, eax
  00074	8b c1		 mov	 eax, ecx
  00076	8b c0		 mov	 eax, eax
  00078	48 89 44 24 08	 mov	 QWORD PTR tv77[rsp], rax
$LN13@tf_apply_p:
  0007d	48 8b 44 24 08	 mov	 rax, QWORD PTR tv77[rsp]
  00082	e9 b9 00 00 00	 jmp	 $LN1@tf_apply_p
$LN8@tf_apply_p:

; 2617 : #endif
; 2618 : #if defined(            _390 )
; 2619 :         case        ARCH_390_IDX:
; 2620 :             return APPLY_390_PREFIXING( radr, regs->PX_390 );

  00087	8b 44 24 40	 mov	 eax, DWORD PTR radr$[rsp]
  0008b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00091	48 85 c0	 test	 rax, rax
  00094	74 23		 je	 SHORT $LN14@tf_apply_p
  00096	8b 44 24 40	 mov	 eax, DWORD PTR radr$[rsp]
  0009a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000a8	48 3b c1	 cmp	 rax, rcx
  000ab	74 0c		 je	 SHORT $LN14@tf_apply_p
  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR radr$[rsp]
  000b2	48 89 44 24 10	 mov	 QWORD PTR tv89[rsp], rax
  000b7	eb 17		 jmp	 SHORT $LN15@tf_apply_p
$LN14@tf_apply_p:
  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c1	8b 4c 24 40	 mov	 ecx, DWORD PTR radr$[rsp]
  000c5	33 c8		 xor	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	8b c0		 mov	 eax, eax
  000cb	48 89 44 24 10	 mov	 QWORD PTR tv89[rsp], rax
$LN15@tf_apply_p:
  000d0	48 8b 44 24 10	 mov	 rax, QWORD PTR tv89[rsp]
  000d5	eb 69		 jmp	 SHORT $LN1@tf_apply_p
$LN9@tf_apply_p:

; 2621 : #endif
; 2622 : #if defined(            _900 )
; 2623 :         case        ARCH_900_IDX:
; 2624 :             return APPLY_900_PREFIXING( radr, regs->PX_900 );

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR radr$[rsp]
  000dc	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000e2	48 85 c0	 test	 rax, rax
  000e5	74 22		 je	 SHORT $LN16@tf_apply_p
  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR radr$[rsp]
  000ec	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  000fb	74 0c		 je	 SHORT $LN16@tf_apply_p
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR radr$[rsp]
  00102	48 89 44 24 18	 mov	 QWORD PTR tv129[rsp], rax
  00107	eb 19		 jmp	 SHORT $LN17@tf_apply_p
$LN16@tf_apply_p:
  00109	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00112	48 8b 4c 24 40	 mov	 rcx, QWORD PTR radr$[rsp]
  00117	48 33 c8	 xor	 rcx, rax
  0011a	48 8b c1	 mov	 rax, rcx
  0011d	48 89 44 24 18	 mov	 QWORD PTR tv129[rsp], rax
$LN17@tf_apply_p:
  00122	48 8b 44 24 18	 mov	 rax, QWORD PTR tv129[rsp]
  00127	eb 17		 jmp	 SHORT $LN1@tf_apply_p
$LN10@tf_apply_p:
$LN6@tf_apply_p:

; 2625 : #endif
; 2626 :         default: CRASH();

  00129	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00132	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00137	c6 00 00	 mov	 BYTE PTR [rax], 0
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 e9		 jne	 SHORT $LN6@tf_apply_p
$LN1@tf_apply_p:
$LN11@tf_apply_p:

; 2627 :             UNREACHABLE_CODE( return 0 );
; 2628 :     }
; 2629 : }

  00140	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00144	c3		 ret	 0
tf_apply_prefixing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 32
tv70 = 36
tv82 = 40
p$1 = 48
regs$ = 80
raddr$ = 88
tf_store_int_timer PROC

; 2583 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2584 :     switch (regs->arch_mode)

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  0001f	74 10		 je	 SHORT $LN7@tf_store_i
  00021	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00026	74 66		 je	 SHORT $LN9@tf_store_i
  00028	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002d	74 61		 je	 SHORT $LN10@tf_store_i
  0002f	eb 61		 jmp	 SHORT $LN11@tf_store_i
$LN7@tf_store_i:

; 2585 :     {
; 2586 : #if defined(     _370 )
; 2587 :         case ARCH_370_IDX:
; 2588 :             if (ITIMER_ACCESS( raddr, 16 ))

  00031	48 83 7c 24 58
	54		 cmp	 QWORD PTR raddr$[rsp], 84 ; 00000054H
  00037	73 0a		 jae	 SHORT $LN15@tf_store_i
  00039	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN16@tf_store_i
$LN15@tf_store_i:
  00043	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN16@tf_store_i:
  0004b	83 7c 24 24 00	 cmp	 DWORD PTR tv70[rsp], 0
  00050	74 19		 je	 SHORT $LN17@tf_store_i
  00052	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  00057	48 83 c0 10	 add	 rax, 16
  0005b	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  0005f	72 0a		 jb	 SHORT $LN17@tf_store_i
  00061	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00069	eb 08		 jmp	 SHORT $LN23@tf_store_i
$LN17@tf_store_i:
  0006b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN23@tf_store_i:
  00073	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  00078	74 12		 je	 SHORT $LN8@tf_store_i

; 2589 :                  sysblk.s370_sit( regs );

  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00086	ff 90 70 14 00
	00		 call	 QWORD PTR [rax+5232]
$LN8@tf_store_i:

; 2590 :             return;

  0008c	eb 1b		 jmp	 SHORT $LN1@tf_store_i
$LN9@tf_store_i:

; 2591 : #endif
; 2592 : #if defined(     _390 )
; 2593 :         case ARCH_390_IDX:
; 2594 :             //    390 doesn't have interval timers
; 2595 :             return;

  0008e	eb 19		 jmp	 SHORT $LN1@tf_store_i
$LN10@tf_store_i:

; 2596 : #endif
; 2597 : #if defined(     _900 )
; 2598 :         case ARCH_900_IDX:
; 2599 :             //    900 doesn't have interval timers
; 2600 :             return;

  00090	eb 17		 jmp	 SHORT $LN1@tf_store_i
$LN11@tf_store_i:
$LN6@tf_store_i:

; 2601 : #endif
; 2602 :         default: CRASH();

  00092	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$1[rsp]
  000a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  000a3	33 c0		 xor	 eax, eax
  000a5	85 c0		 test	 eax, eax
  000a7	75 e9		 jne	 SHORT $LN6@tf_store_i
$LN1@tf_store_i:
$LN12@tf_store_i:

; 2603 :             UNREACHABLE_CODE( return );
; 2604 :     }
; 2605 : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
tf_store_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
regs$ = 64
abs$ = 72
tf_get_storage_key PROC

; 2559 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2560 :     switch (regs->arch_mode)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  0001f	74 10		 je	 SHORT $LN7@tf_get_sto
  00021	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00026	74 1d		 je	 SHORT $LN8@tf_get_sto
  00028	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002d	74 2a		 je	 SHORT $LN9@tf_get_sto
  0002f	eb 3c		 jmp	 SHORT $LN10@tf_get_sto
$LN7@tf_get_sto:

; 2561 :     {
; 2562 : #if defined(       _370 )
; 2563 :         case   ARCH_370_IDX:
; 2564 :             return sysblk.s370_gsk( abs );

  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR abs$[rsp]
  00036	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003d	ff 90 40 14 00
	00		 call	 QWORD PTR [rax+5184]
  00043	eb 3f		 jmp	 SHORT $LN1@tf_get_sto
$LN8@tf_get_sto:

; 2565 : #endif
; 2566 : #if defined(       _390 )
; 2567 :         case   ARCH_390_IDX:
; 2568 :             return sysblk.s390_gsk( abs );

  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR abs$[rsp]
  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00051	ff 90 48 14 00
	00		 call	 QWORD PTR [rax+5192]
  00057	eb 2b		 jmp	 SHORT $LN1@tf_get_sto
$LN9@tf_get_sto:

; 2569 : #endif
; 2570 : #if defined(       _900 )
; 2571 :         case   ARCH_900_IDX:
; 2572 :             return sysblk.z900_gsk( abs );

  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR abs$[rsp]
  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00065	ff 90 50 14 00
	00		 call	 QWORD PTR [rax+5200]
  0006b	eb 17		 jmp	 SHORT $LN1@tf_get_sto
$LN10@tf_get_sto:
$LN6@tf_get_sto:

; 2573 : #endif
; 2574 :         default: CRASH();

  0006d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 e9		 jne	 SHORT $LN6@tf_get_sto
$LN1@tf_get_sto:
$LN11@tf_get_sto:

; 2575 :             UNREACHABLE_CODE( return 0 );
; 2576 :     }
; 2577 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
tf_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 48
p$1 = 56
raptr$ = 80
siptr$ = 88
vaddr$ = 96
arn$ = 104
regs$ = 112
acctype$ = 120
tf_virt_to_real PROC

; 2535 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2536 :     switch (regs->arch_mode)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00020	89 44 24 30	 mov	 DWORD PTR tv65[rsp], eax
  00024	83 7c 24 30 00	 cmp	 DWORD PTR tv65[rsp], 0
  00029	74 13		 je	 SHORT $LN7@tf_virt_to
  0002b	83 7c 24 30 01	 cmp	 DWORD PTR tv65[rsp], 1
  00030	74 44		 je	 SHORT $LN8@tf_virt_to
  00032	83 7c 24 30 02	 cmp	 DWORD PTR tv65[rsp], 2
  00037	74 72		 je	 SHORT $LN9@tf_virt_to
  00039	e9 a2 00 00 00	 jmp	 $LN10@tf_virt_to
$LN7@tf_virt_to:

; 2537 :     {
; 2538 : #if defined(       _370 )
; 2539 :         case   ARCH_370_IDX:
; 2540 :             return sysblk.s370_vtr( raptr, siptr, vaddr, arn, regs, acctype );

  0003e	8b 44 24 78	 mov	 eax, DWORD PTR acctype$[rsp]
  00042	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00050	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  00055	4c 8b 44 24 60	 mov	 r8, QWORD PTR vaddr$[rsp]
  0005a	48 8b 54 24 58	 mov	 rdx, QWORD PTR siptr$[rsp]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR raptr$[rsp]
  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006b	ff 90 58 14 00
	00		 call	 QWORD PTR [rax+5208]
  00071	e9 81 00 00 00	 jmp	 $LN1@tf_virt_to
$LN8@tf_virt_to:

; 2541 : #endif
; 2542 : #if defined(       _390 )
; 2543 :         case   ARCH_390_IDX:
; 2544 :             return sysblk.s390_vtr( raptr, siptr, vaddr, arn, regs, acctype );

  00076	8b 44 24 78	 mov	 eax, DWORD PTR acctype$[rsp]
  0007a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0008d	4c 8b 44 24 60	 mov	 r8, QWORD PTR vaddr$[rsp]
  00092	48 8b 54 24 58	 mov	 rdx, QWORD PTR siptr$[rsp]
  00097	48 8b 4c 24 50	 mov	 rcx, QWORD PTR raptr$[rsp]
  0009c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a3	ff 90 60 14 00
	00		 call	 QWORD PTR [rax+5216]
  000a9	eb 4c		 jmp	 SHORT $LN1@tf_virt_to
$LN9@tf_virt_to:

; 2545 : #endif
; 2546 : #if defined(       _900 )
; 2547 :         case   ARCH_900_IDX:
; 2548 :             return sysblk.z900_vtr( raptr, siptr, vaddr, arn, regs, acctype );

  000ab	8b 44 24 78	 mov	 eax, DWORD PTR acctype$[rsp]
  000af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b3	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  000c2	4c 8b 44 24 60	 mov	 r8, QWORD PTR vaddr$[rsp]
  000c7	48 8b 54 24 58	 mov	 rdx, QWORD PTR siptr$[rsp]
  000cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR raptr$[rsp]
  000d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d8	ff 90 68 14 00
	00		 call	 QWORD PTR [rax+5224]
  000de	eb 17		 jmp	 SHORT $LN1@tf_virt_to
$LN10@tf_virt_to:
$LN6@tf_virt_to:

; 2549 : #endif
; 2550 :         default: CRASH();

  000e0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000e9	48 8b 44 24 38	 mov	 rax, QWORD PTR p$1[rsp]
  000ee	c6 00 00	 mov	 BYTE PTR [rax], 0
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 e9		 jne	 SHORT $LN6@tf_virt_to
$LN1@tf_virt_to:
$LN11@tf_virt_to:

; 2551 :             UNREACHABLE_CODE( return 0 );
; 2552 :     }
; 2553 : }

  000f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fb	c3		 ret	 0
tf_virt_to_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 48
mem$ = 56
suffix$ = 64
__$ArrayPad$ = 80
memsize$ = 112
n$ = 120
buf$ = 128
bufsz$ = 136
_fmt_memsize PROC

; 1234 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1235 :     /* Format storage in 2**(10*n) values at the highest integral
; 1236 :      * integer boundary.
; 1237 :      *
; 1238 :      * Mainframe memory and DASD amounts are reported in 2**(10*n)
; 1239 :      * values, (x_iB international format, and shown as x_ or x_B,
; 1240 :      * when x >= 1024; x when x < 1024).  Open Systems and Windows
; 1241 :      * report memory in the same format, but report DASD storage in
; 1242 :      * 10**(3*n) values.  (Thank you, various marketing groups and
; 1243 :      * international standards committees...)
; 1244 :      *
; 1245 :      * For Hercules, mainframe oriented reporting characteristics
; 1246 :      * will be formatted and shown as x_, when x >= 1024, and as x
; 1247 :      * when x < 1024.  Reporting of Open Systems and Windows specifics
; 1248 :      * should follow the international format, shown as x_iB,
; 1249 :      * when x >= 1024, and x or xB when x < 1024.
; 1250 :      *
; 1251 :      * Reporting is done at the highest integral boundary.
; 1252 :      */
; 1253 :     //------------------------------------------------------------------
; 1254 :     // The 'n' value passed to us determines which suffix we start with
; 1255 :     //------------------------------------------------------------------
; 1256 :     const  char  suffix[9] = {0x00, 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'};

  00026	c6 44 24 40 00	 mov	 BYTE PTR suffix$[rsp], 0
  0002b	c6 44 24 41 4b	 mov	 BYTE PTR suffix$[rsp+1], 75 ; 0000004bH
  00030	c6 44 24 42 4d	 mov	 BYTE PTR suffix$[rsp+2], 77 ; 0000004dH
  00035	c6 44 24 43 47	 mov	 BYTE PTR suffix$[rsp+3], 71 ; 00000047H
  0003a	c6 44 24 44 54	 mov	 BYTE PTR suffix$[rsp+4], 84 ; 00000054H
  0003f	c6 44 24 45 50	 mov	 BYTE PTR suffix$[rsp+5], 80 ; 00000050H
  00044	c6 44 24 46 45	 mov	 BYTE PTR suffix$[rsp+6], 69 ; 00000045H
  00049	c6 44 24 47 5a	 mov	 BYTE PTR suffix$[rsp+7], 90 ; 0000005aH
  0004e	c6 44 24 48 59	 mov	 BYTE PTR suffix$[rsp+8], 89 ; 00000059H

; 1257 :     U64          mem  = memsize;

  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR memsize$[rsp]
  00058	48 89 44 24 38	 mov	 QWORD PTR mem$[rsp], rax

; 1258 :     u_int        i    = 0;

  0005d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1259 : 
; 1260 :     if (mem)

  00065	48 83 7c 24 38
	00		 cmp	 QWORD PTR mem$[rsp], 0
  0006b	74 3e		 je	 SHORT $LN5@fmt_memsiz

; 1261 :         for (i = n;

  0006d	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  00071	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00075	eb 18		 jmp	 SHORT $LN4@fmt_memsiz
$LN2@fmt_memsiz:

; 1263 :              mem >>= 10, ++i);

  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR mem$[rsp]
  0007c	48 c1 e8 0a	 shr	 rax, 10
  00080	48 89 44 24 38	 mov	 QWORD PTR mem$[rsp], rax
  00085	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00089	ff c0		 inc	 eax
  0008b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@fmt_memsiz:

; 1262 :              i < _countof( suffix ) && !(mem & 0x03FF);

  0008f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00093	48 83 f8 09	 cmp	 rax, 9
  00097	73 12		 jae	 SHORT $LN3@fmt_memsiz
  00099	48 8b 44 24 38	 mov	 rax, QWORD PTR mem$[rsp]
  0009e	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  000a4	48 85 c0	 test	 rax, rax
  000a7	75 02		 jne	 SHORT $LN3@fmt_memsiz

; 1263 :              mem >>= 10, ++i);

  000a9	eb cc		 jmp	 SHORT $LN2@fmt_memsiz
$LN3@fmt_memsiz:
$LN5@fmt_memsiz:

; 1264 : 
; 1265 :     snprintf( buf, bufsz, "%"PRIu64"%c", mem, suffix[ i ]);

  000ab	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000af	0f be 44 04 40	 movsx	 eax, BYTE PTR suffix$[rsp+rax]
  000b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b8	4c 8b 4c 24 38	 mov	 r9, QWORD PTR mem$[rsp]
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159491
  000c4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  000cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000d4	e8 00 00 00 00	 call	 w32_snprintf

; 1266 :     return buf;

  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]

; 1267 : }

  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e6	48 33 cc	 xor	 rcx, rsp
  000e9	e8 00 00 00 00	 call	 __security_check_cookie
  000ee	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f2	c3		 ret	 0
_fmt_memsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
tok$ = 40
sym$ = 64
alloc$ = 72
get_symbol_token PROC

; 275  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 276  :     SYMBOL_TOKEN        *tok;
; 277  :     int i;
; 278  : 
; 279  :     for(i=0;i<symbol_count;i++)

  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00015	eb 0a		 jmp	 SHORT $LN4@get_symbol
$LN2@get_symbol:
  00017	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001b	ff c0		 inc	 eax
  0001d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@get_symbol:
  00021	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_count
  00027	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002b	7d 58		 jge	 SHORT $LN3@get_symbol

; 280  :     {
; 281  :         tok=symbols[i];

  0002d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00039	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0003d	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax

; 282  :         if(tok==NULL)

  00042	48 83 7c 24 28
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00048	75 02		 jne	 SHORT $LN5@get_symbol

; 283  :         {
; 284  :             continue;

  0004a	eb cb		 jmp	 SHORT $LN2@get_symbol
$LN5@get_symbol:

; 285  :         }
; 286  : #if defined( CASELESS_SYMBOLS )
; 287  :         if(strcasecmp(symbols[i]->var,sym)==0)

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00058	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0005c	48 8b 54 24 40	 mov	 rdx, QWORD PTR sym$[rsp]
  00061	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0006a	85 c0		 test	 eax, eax
  0006c	75 15		 jne	 SHORT $LN6@get_symbol

; 288  : #else
; 289  :         if(strcmp(symbols[i]->var,sym)==0)
; 290  : #endif
; 291  :         {
; 292  :             return(symbols[i]);

  0006e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  0007a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007e	e9 77 01 00 00	 jmp	 $LN1@get_symbol
$LN6@get_symbol:

; 293  :         }
; 294  :     }

  00083	eb 92		 jmp	 SHORT $LN2@get_symbol
$LN3@get_symbol:

; 295  :     if(!alloc)

  00085	83 7c 24 48 00	 cmp	 DWORD PTR alloc$[rsp], 0
  0008a	75 07		 jne	 SHORT $LN7@get_symbol

; 296  :     {
; 297  :         return(NULL);

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 67 01 00 00	 jmp	 $LN1@get_symbol
$LN7@get_symbol:

; 298  :     }
; 299  :     if(symbol_count>=symbol_max)

  00093	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_max
  00099	39 05 00 00 00
	00		 cmp	 DWORD PTR symbol_count, eax
  0009f	0f 8c a4 00 00
	00		 jl	 $LN8@get_symbol

; 300  :     {
; 301  :         symbol_max+=SYMBOL_TABLE_INCREMENT;

  000a5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_max
  000ab	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000b0	89 05 00 00 00
	00		 mov	 DWORD PTR symbol_max, eax

; 302  :         if(symbols==NULL)

  000b6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR symbols, 0
  000be	75 42		 jne	 SHORT $LN9@get_symbol

; 303  :         {
; 304  :         symbols=malloc(sizeof(SYMBOL_TOKEN *)*symbol_max);

  000c0	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR symbol_max
  000c7	48 c1 e0 03	 shl	 rax, 3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000d4	48 89 05 00 00
	00 00		 mov	 QWORD PTR symbols, rax

; 305  :         if(symbols==NULL)

  000db	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR symbols, 0
  000e3	75 1b		 jne	 SHORT $LN11@get_symbol

; 306  :         {
; 307  :             symbol_max=0;

  000e5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR symbol_max, 0

; 308  :             symbol_count=0;

  000ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR symbol_count, 0

; 309  :             return(NULL);

  000f9	33 c0		 xor	 eax, eax
  000fb	e9 fa 00 00 00	 jmp	 $LN1@get_symbol
$LN11@get_symbol:

; 310  :         }
; 311  :         }

  00100	eb 47		 jmp	 SHORT $LN10@get_symbol
$LN9@get_symbol:

; 312  :         else
; 313  :         {
; 314  :         symbols=realloc(symbols,sizeof(SYMBOL_TOKEN *)*symbol_max);

  00102	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR symbol_max
  00109	48 c1 e0 03	 shl	 rax, 3
  0010d	48 8b d0	 mov	 rdx, rax
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0011d	48 89 05 00 00
	00 00		 mov	 QWORD PTR symbols, rax

; 315  :         if(symbols==NULL)

  00124	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR symbols, 0
  0012c	75 1b		 jne	 SHORT $LN12@get_symbol

; 316  :         {
; 317  :             symbol_max=0;

  0012e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR symbol_max, 0

; 318  :             symbol_count=0;

  00138	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR symbol_count, 0

; 319  :             return(NULL);

  00142	33 c0		 xor	 eax, eax
  00144	e9 b1 00 00 00	 jmp	 $LN1@get_symbol
$LN12@get_symbol:
$LN10@get_symbol:
$LN8@get_symbol:

; 320  :         }
; 321  :         }
; 322  :     }
; 323  :     tok=malloc(sizeof(SYMBOL_TOKEN));

  00149	b9 10 00 00 00	 mov	 ecx, 16
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00154	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax

; 324  :     if(tok==NULL)

  00159	48 83 7c 24 28
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0015f	75 07		 jne	 SHORT $LN13@get_symbol

; 325  :     {
; 326  :         return(NULL);

  00161	33 c0		 xor	 eax, eax
  00163	e9 92 00 00 00	 jmp	 $LN1@get_symbol
$LN13@get_symbol:

; 327  :     }
; 328  : 
; 329  :     tok->var=malloc(MAX_SYMBOL_SIZE+1);

  00168	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00173	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  00178	48 89 01	 mov	 QWORD PTR [rcx], rax

; 330  :     if(tok->var==NULL)

  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00180	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00184	75 0f		 jne	 SHORT $LN14@get_symbol

; 331  :     {
; 332  :         free(tok);

  00186	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 333  :         return(NULL);

  00191	33 c0		 xor	 eax, eax
  00193	eb 65		 jmp	 SHORT $LN1@get_symbol
$LN14@get_symbol:

; 334  :     }
; 335  :     strncpy(tok->var,sym,MAX_SYMBOL_SIZE);

  00195	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0019b	48 8b 54 24 40	 mov	 rdx, QWORD PTR sym$[rsp]
  001a0	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  001a5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 336  :     tok->var[MAX_SYMBOL_SIZE]=0;    /* Ensure null termination */

  001ae	b8 01 00 00 00	 mov	 eax, 1
  001b3	48 6b c0 1f	 imul	 rax, rax, 31
  001b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  001bc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001bf	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 337  : 
; 338  :     tok->val=NULL;

  001c3	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  001c8	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 339  :     symbols[symbol_count]=tok;

  001d0	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR symbol_count
  001d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  001de	48 8b 54 24 28	 mov	 rdx, QWORD PTR tok$[rsp]
  001e3	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 340  :     symbol_count++;

  001e7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_count
  001ed	ff c0		 inc	 eax
  001ef	89 05 00 00 00
	00		 mov	 DWORD PTR symbol_count, eax

; 341  :     return(tok);

  001f5	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
$LN1@get_symbol:

; 342  : }

  001fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fe	c3		 ret	 0
get_symbol_token ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 hthread_release_lock

; 407  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00043	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 d9 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8d 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1a		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00090	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00097	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a4	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ab	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	e8 00 00 00 00	 call	 hthread_wait_condition

; 367  :         }

  000b8	e9 5d ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000c9	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d0	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ea	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f1	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f3	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ff	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00106	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010a	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 32
rec$1 = 40
rec$2 = 48
op$3 = 56
rec$4 = 64
i$5 = 72
i$6 = 76
i$7 = 80
i$8 = 84
rec$9 = 88
rec$10 = 96
rec$11 = 104
rec$12 = 112
rec$13 = 120
rec$14 = 128
rec$15 = 136
rec$16 = 144
rec$17 = 152
rec$18 = 160
rec$19 = 168
tv310 = 176
tv329 = 180
tv551 = 184
tv560 = 188
tv570 = 192
tv319 = 196
rec$20 = 200
rec$21 = 208
rec$22 = 216
rec$23 = 224
rec$24 = 232
rec$25 = 240
rec$26 = 248
rec$27 = 256
rec$28 = 264
rec$29 = 272
rec$30 = 280
rec$31 = 288
rec$32 = 296
rec$33 = 304
rec$34 = 312
rec$35 = 320
rec$36 = 328
rec$37 = 336
rec$38 = 344
rec$39 = 352
rec$40 = 360
rec$41 = 368
rec$42 = 376
rec$43 = 384
rec$44 = 392
rec$45 = 400
rec$46 = 408
rec$47 = 416
p$48 = 424
hdr$ = 448
msgnum$ = 456
tf_swap_rec PROC

; 4175 : {

$LN116:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H

; 4176 :     switch (msgnum)

  00011	0f b7 84 24 c8
	01 00 00	 movzx	 eax, WORD PTR msgnum$[rsp]
  00019	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001d	81 7c 24 20 20
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 800 ; 00000320H
  00025	7f 46		 jg	 SHORT $LN106@tf_swap_re
  00027	81 7c 24 20 20
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 800 ; 00000320H
  0002f	0f 84 4d 07 00
	00		 je	 $LN44@tf_swap_re
  00035	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00039	2d a7 01 00 00	 sub	 eax, 423		; 000001a7H
  0003e	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00042	83 7c 24 20 61	 cmp	 DWORD PTR tv65[rsp], 97	; 00000061H
  00047	0f 87 d8 10 00
	00		 ja	 $LN92@tf_swap_re
  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv65[rsp]
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00059	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN114@tf_swap_re[rcx+rax]
  00061	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN115@tf_swap_re[rcx+rax*4]
  00068	48 03 c1	 add	 rax, rcx
  0006b	ff e0		 jmp	 rax
$LN106@tf_swap_re:
  0006d	81 7c 24 20 14
	05 00 00	 cmp	 DWORD PTR tv65[rsp], 1300 ; 00000514H
  00075	7f 46		 jg	 SHORT $LN107@tf_swap_re
  00077	81 7c 24 20 14
	05 00 00	 cmp	 DWORD PTR tv65[rsp], 1300 ; 00000514H
  0007f	0f 84 97 0b 00
	00		 je	 $LN60@tf_swap_re
  00085	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00089	2d 21 03 00 00	 sub	 eax, 801		; 00000321H
  0008e	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00092	83 7c 24 20 2d	 cmp	 DWORD PTR tv65[rsp], 45	; 0000002dH
  00097	0f 87 88 10 00
	00		 ja	 $LN92@tf_swap_re
  0009d	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv65[rsp]
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a9	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN112@tf_swap_re[rcx+rax]
  000b1	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN113@tf_swap_re[rcx+rax*4]
  000b8	48 03 c1	 add	 rax, rcx
  000bb	ff e0		 jmp	 rax
$LN107@tf_swap_re:
  000bd	81 7c 24 20 dd
	08 00 00	 cmp	 DWORD PTR tv65[rsp], 2269 ; 000008ddH
  000c5	7f 3e		 jg	 SHORT $LN108@tf_swap_re
  000c7	81 7c 24 20 dd
	08 00 00	 cmp	 DWORD PTR tv65[rsp], 2269 ; 000008ddH
  000cf	0f 84 81 0c 00
	00		 je	 $LN85@tf_swap_re
  000d5	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  000d9	2d 15 05 00 00	 sub	 eax, 1301		; 00000515H
  000de	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  000e2	83 7c 24 20 23	 cmp	 DWORD PTR tv65[rsp], 35	; 00000023H
  000e7	0f 87 38 10 00
	00		 ja	 $LN92@tf_swap_re
  000ed	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv65[rsp]
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000f9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN111@tf_swap_re[rcx+rax*4]
  00100	48 03 c1	 add	 rax, rcx
  00103	ff e0		 jmp	 rax
$LN108@tf_swap_re:
  00105	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00109	2d de 08 00 00	 sub	 eax, 2270		; 000008deH
  0010e	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00112	83 7c 24 20 38	 cmp	 DWORD PTR tv65[rsp], 56	; 00000038H
  00117	0f 87 08 10 00
	00		 ja	 $LN92@tf_swap_re
  0011d	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv65[rsp]
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00129	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN109@tf_swap_re[rcx+rax]
  00131	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN110@tf_swap_re[rcx+rax*4]
  00138	48 03 c1	 add	 rax, rcx
  0013b	ff e0		 jmp	 rax
$LN19@tf_swap_re:

; 4177 :     {
; 4178 :         case  423:
; 4179 :         {
; 4180 :             // (nothing to swap!)
; 4181 :         }
; 4182 :         break;

  0013d	e9 00 10 00 00	 jmp	 $LN2@tf_swap_re
$LN20@tf_swap_re:

; 4183 : 
; 4184 :         case  424:
; 4185 :         {
; 4186 :             TF00424* rec = (TF00424*) hdr;

  00142	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0014a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rec$20[rsp], rax

; 4187 :             rec->trk     = SWAP32( rec->trk    );

  00152	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rec$20[rsp]
  0015a	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0015d	e8 00 00 00 00	 call	 _byteswap_ulong
  00162	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR rec$20[rsp]
  0016a	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4188 :             rec->bufcur  = SWAP32( rec->bufcur );

  0016d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rec$20[rsp]
  00175	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00178	e8 00 00 00 00	 call	 _byteswap_ulong
  0017d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR rec$20[rsp]
  00185	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4189 :         }
; 4190 :         break;

  00188	e9 b5 0f 00 00	 jmp	 $LN2@tf_swap_re
$LN21@tf_swap_re:

; 4191 : 
; 4192 :         case  425:
; 4193 :         {
; 4194 :             TF00425* rec = (TF00425*) hdr;

  0018d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00195	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR rec$32[rsp], rax

; 4195 :             rec->bufcur  = SWAP32( rec->bufcur );

  0019d	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR rec$32[rsp]
  001a5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  001a8	e8 00 00 00 00	 call	 _byteswap_ulong
  001ad	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR rec$32[rsp]
  001b5	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4196 :         }
; 4197 :         break;

  001b8	e9 85 0f 00 00	 jmp	 $LN2@tf_swap_re
$LN22@tf_swap_re:

; 4198 : 
; 4199 :         case  426:
; 4200 :         {
; 4201 :             TF00426* rec = (TF00426*) hdr;

  001bd	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  001c5	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR rec$21[rsp], rax

; 4202 :             rec->trk     = SWAP32( rec->trk );

  001cd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR rec$21[rsp]
  001d5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  001d8	e8 00 00 00 00	 call	 _byteswap_ulong
  001dd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR rec$21[rsp]
  001e5	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4203 :             rec->idx     = SWAP32( rec->idx );

  001e8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR rec$21[rsp]
  001f0	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  001f3	e8 00 00 00 00	 call	 _byteswap_ulong
  001f8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR rec$21[rsp]
  00200	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4204 :         }
; 4205 :         break;

  00203	e9 3a 0f 00 00	 jmp	 $LN2@tf_swap_re
$LN23@tf_swap_re:

; 4206 : 
; 4207 :         case  427:
; 4208 :         {
; 4209 :             TF00427* rec = (TF00427*) hdr;

  00208	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00210	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR rec$33[rsp], rax

; 4210 :             rec->trk     = SWAP32( rec->trk );

  00218	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rec$33[rsp]
  00220	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00223	e8 00 00 00 00	 call	 _byteswap_ulong
  00228	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rec$33[rsp]
  00230	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4211 :         }
; 4212 :         break;

  00233	e9 0a 0f 00 00	 jmp	 $LN2@tf_swap_re
$LN24@tf_swap_re:

; 4213 : 
; 4214 :         case  428:
; 4215 :         {
; 4216 :             TF00428* rec = (TF00428*) hdr;

  00238	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00240	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR rec$22[rsp], rax

; 4217 :             rec->trk     = SWAP32( rec->trk );

  00248	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR rec$22[rsp]
  00250	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00253	e8 00 00 00 00	 call	 _byteswap_ulong
  00258	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR rec$22[rsp]
  00260	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4218 :             rec->idx     = SWAP32( rec->idx );

  00263	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR rec$22[rsp]
  0026b	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0026e	e8 00 00 00 00	 call	 _byteswap_ulong
  00273	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR rec$22[rsp]
  0027b	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4219 :         }
; 4220 :         break;

  0027e	e9 bf 0e 00 00	 jmp	 $LN2@tf_swap_re
$LN25@tf_swap_re:

; 4221 : 
; 4222 :         case  429:
; 4223 :         {
; 4224 :             TF00429* rec = (TF00429*) hdr;

  00283	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0028b	48 89 44 24 60	 mov	 QWORD PTR rec$10[rsp], rax

; 4225 :             rec->trk     = SWAP32( rec->trk    );

  00290	48 8b 44 24 60	 mov	 rax, QWORD PTR rec$10[rsp]
  00295	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00298	e8 00 00 00 00	 call	 _byteswap_ulong
  0029d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$10[rsp]
  002a2	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4226 :             rec->fnum    = SWAP32( rec->fnum   );

  002a5	48 8b 44 24 60	 mov	 rax, QWORD PTR rec$10[rsp]
  002aa	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  002ad	e8 00 00 00 00	 call	 _byteswap_ulong
  002b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$10[rsp]
  002b7	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4227 :             rec->len     = SWAP32( rec->len    );

  002ba	48 8b 44 24 60	 mov	 rax, QWORD PTR rec$10[rsp]
  002bf	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  002c2	e8 00 00 00 00	 call	 _byteswap_ulong
  002c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$10[rsp]
  002cc	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4228 :             rec->offset  = SWAP64( rec->offset );

  002cf	48 8b 44 24 60	 mov	 rax, QWORD PTR rec$10[rsp]
  002d4	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  002d8	e8 00 00 00 00	 call	 _byteswap_uint64
  002dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$10[rsp]
  002e2	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4229 :         }
; 4230 :         break;

  002e6	e9 57 0e 00 00	 jmp	 $LN2@tf_swap_re
$LN26@tf_swap_re:

; 4231 : 
; 4232 :         case  430:
; 4233 :         {
; 4234 :             TF00430* rec = (TF00430*) hdr;

  002eb	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  002f3	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR rec$34[rsp], rax

; 4235 :             rec->trk     = SWAP32( rec->trk );

  002fb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR rec$34[rsp]
  00303	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00306	e8 00 00 00 00	 call	 _byteswap_ulong
  0030b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR rec$34[rsp]
  00313	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4236 :         }
; 4237 :         break;

  00316	e9 27 0e 00 00	 jmp	 $LN2@tf_swap_re
$LN27@tf_swap_re:

; 4238 : 
; 4239 :         case  431:
; 4240 :         {
; 4241 :             TF00431* rec = (TF00431*) hdr;

  0031b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00323	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR rec$23[rsp], rax

; 4242 :             rec->cyl     = SWAP32( rec->cyl  );

  0032b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR rec$23[rsp]
  00333	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00336	e8 00 00 00 00	 call	 _byteswap_ulong
  0033b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR rec$23[rsp]
  00343	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4243 :             rec->head    = SWAP32( rec->head );

  00346	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR rec$23[rsp]
  0034e	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00351	e8 00 00 00 00	 call	 _byteswap_ulong
  00356	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR rec$23[rsp]
  0035e	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4244 :         }
; 4245 :         break;

  00361	e9 dc 0d 00 00	 jmp	 $LN2@tf_swap_re
$LN28@tf_swap_re:

; 4246 : 
; 4247 :         case  432:
; 4248 :         {
; 4249 :             // (nothing to swap!)
; 4250 :         }
; 4251 :         break;

  00366	e9 d7 0d 00 00	 jmp	 $LN2@tf_swap_re
$LN29@tf_swap_re:

; 4252 : 
; 4253 :         case  433:
; 4254 :         {
; 4255 :             TF00433* rec = (TF00433*) hdr;

  0036b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00373	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rec$24[rsp], rax

; 4256 :             rec->cyl     = SWAP32( rec->cyl  );

  0037b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR rec$24[rsp]
  00383	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00386	e8 00 00 00 00	 call	 _byteswap_ulong
  0038b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR rec$24[rsp]
  00393	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4257 :             rec->head    = SWAP32( rec->head );

  00396	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR rec$24[rsp]
  0039e	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  003a1	e8 00 00 00 00	 call	 _byteswap_ulong
  003a6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR rec$24[rsp]
  003ae	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4258 :         }
; 4259 :         break;

  003b1	e9 8c 0d 00 00	 jmp	 $LN2@tf_swap_re
$LN30@tf_swap_re:

; 4260 : 
; 4261 :         case  434:
; 4262 :         {
; 4263 :             // (nothing to swap!)
; 4264 :         }
; 4265 :         break;

  003b6	e9 87 0d 00 00	 jmp	 $LN2@tf_swap_re
$LN31@tf_swap_re:

; 4266 : 
; 4267 :         case  435:
; 4268 :         {
; 4269 :             TF00435* rec = (TF00435*) hdr;

  003bb	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  003c3	48 89 44 24 40	 mov	 QWORD PTR rec$4[rsp], rax

; 4270 :             rec->dl      = SWAP16( rec->dl     );

  003c8	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  003cd	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  003d1	e8 00 00 00 00	 call	 _byteswap_ushort
  003d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  003db	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 4271 :             rec->cyl     = SWAP32( rec->cyl    );

  003df	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  003e4	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  003e7	e8 00 00 00 00	 call	 _byteswap_ulong
  003ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  003f1	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4272 :             rec->head    = SWAP32( rec->head   );

  003f4	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  003f9	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  003fc	e8 00 00 00 00	 call	 _byteswap_ulong
  00401	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  00406	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4273 :             rec->record  = SWAP32( rec->record );

  00409	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  0040e	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00411	e8 00 00 00 00	 call	 _byteswap_ulong
  00416	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  0041b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 4274 :             rec->kl      = SWAP32( rec->kl     );

  0041e	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  00423	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00426	e8 00 00 00 00	 call	 _byteswap_ulong
  0042b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  00430	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 4275 :             rec->offset  = SWAP32( rec->offset );

  00433	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$4[rsp]
  00438	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  0043b	e8 00 00 00 00	 call	 _byteswap_ulong
  00440	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$4[rsp]
  00445	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 4276 :         }
; 4277 :         break;

  00448	e9 f5 0c 00 00	 jmp	 $LN2@tf_swap_re
$LN32@tf_swap_re:

; 4278 : 
; 4279 :         case  436:
; 4280 :         {
; 4281 :             TF00436* rec = (TF00436*) hdr;

  0044d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00455	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR rec$35[rsp], rax

; 4282 :             rec->kl      = SWAP32( rec->kl );

  0045d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR rec$35[rsp]
  00465	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00468	e8 00 00 00 00	 call	 _byteswap_ulong
  0046d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR rec$35[rsp]
  00475	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4283 :         }
; 4284 :         break;

  00478	e9 c5 0c 00 00	 jmp	 $LN2@tf_swap_re
$LN33@tf_swap_re:

; 4285 : 
; 4286 :         case  437:
; 4287 :         {
; 4288 :             TF00437* rec = (TF00437*) hdr;

  0047d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00485	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR rec$36[rsp], rax

; 4289 :             rec->dl      = SWAP16( rec->dl );

  0048d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR rec$36[rsp]
  00495	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  00499	e8 00 00 00 00	 call	 _byteswap_ushort
  0049e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR rec$36[rsp]
  004a6	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 4290 :         }
; 4291 :         break;

  004aa	e9 93 0c 00 00	 jmp	 $LN2@tf_swap_re
$LN34@tf_swap_re:

; 4292 : 
; 4293 :         case  438:
; 4294 :         {
; 4295 :             TF00438* rec = (TF00438*) hdr;

  004af	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  004b7	48 89 44 24 70	 mov	 QWORD PTR rec$12[rsp], rax

; 4296 :             rec->datalen = SWAP16( rec->datalen );

  004bc	48 8b 44 24 70	 mov	 rax, QWORD PTR rec$12[rsp]
  004c1	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  004c5	e8 00 00 00 00	 call	 _byteswap_ushort
  004ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rec$12[rsp]
  004cf	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4297 :             rec->cyl     = SWAP32( rec->cyl     );

  004d3	48 8b 44 24 70	 mov	 rax, QWORD PTR rec$12[rsp]
  004d8	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  004db	e8 00 00 00 00	 call	 _byteswap_ulong
  004e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rec$12[rsp]
  004e5	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4298 :             rec->head    = SWAP32( rec->head    );

  004e8	48 8b 44 24 70	 mov	 rax, QWORD PTR rec$12[rsp]
  004ed	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004f0	e8 00 00 00 00	 call	 _byteswap_ulong
  004f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rec$12[rsp]
  004fa	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4299 :         }
; 4300 :         break;

  004fd	e9 40 0c 00 00	 jmp	 $LN2@tf_swap_re
$LN35@tf_swap_re:

; 4301 : 
; 4302 :         case  439:
; 4303 :         {
; 4304 :             TF00439* rec = (TF00439*) hdr;

  00502	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0050a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR rec$25[rsp], rax

; 4305 :             rec->cyl     = SWAP32( rec->cyl  );

  00512	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR rec$25[rsp]
  0051a	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0051d	e8 00 00 00 00	 call	 _byteswap_ulong
  00522	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR rec$25[rsp]
  0052a	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4306 :             rec->head    = SWAP32( rec->head );

  0052d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR rec$25[rsp]
  00535	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00538	e8 00 00 00 00	 call	 _byteswap_ulong
  0053d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR rec$25[rsp]
  00545	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4307 :         }
; 4308 :         break;

  00548	e9 f5 0b 00 00	 jmp	 $LN2@tf_swap_re
$LN36@tf_swap_re:

; 4309 : 
; 4310 :         case  440:
; 4311 :         {
; 4312 :             TF00440* rec = (TF00440*) hdr;

  0054d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00555	48 89 44 24 58	 mov	 QWORD PTR rec$9[rsp], rax

; 4313 :             rec->datalen = SWAP16( rec->datalen );

  0055a	48 8b 44 24 58	 mov	 rax, QWORD PTR rec$9[rsp]
  0055f	0f b7 48 28	 movzx	 ecx, WORD PTR [rax+40]
  00563	e8 00 00 00 00	 call	 _byteswap_ushort
  00568	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rec$9[rsp]
  0056d	66 89 41 28	 mov	 WORD PTR [rcx+40], ax

; 4314 :             rec->cyl     = SWAP32( rec->cyl     );

  00571	48 8b 44 24 58	 mov	 rax, QWORD PTR rec$9[rsp]
  00576	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00579	e8 00 00 00 00	 call	 _byteswap_ulong
  0057e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rec$9[rsp]
  00583	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4315 :             rec->head    = SWAP32( rec->head    );

  00586	48 8b 44 24 58	 mov	 rax, QWORD PTR rec$9[rsp]
  0058b	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0058e	e8 00 00 00 00	 call	 _byteswap_ulong
  00593	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rec$9[rsp]
  00598	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4316 :             rec->recnum  = SWAP32( rec->recnum  );

  0059b	48 8b 44 24 58	 mov	 rax, QWORD PTR rec$9[rsp]
  005a0	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  005a3	e8 00 00 00 00	 call	 _byteswap_ulong
  005a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rec$9[rsp]
  005ad	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4317 :             rec->keylen  = SWAP32( rec->keylen  );

  005b0	48 8b 44 24 58	 mov	 rax, QWORD PTR rec$9[rsp]
  005b5	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  005b8	e8 00 00 00 00	 call	 _byteswap_ulong
  005bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rec$9[rsp]
  005c2	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 4318 :         }
; 4319 :         break;

  005c5	e9 78 0b 00 00	 jmp	 $LN2@tf_swap_re
$LN37@tf_swap_re:

; 4320 : 
; 4321 :         case  441:
; 4322 :         {
; 4323 :             TF00441* rec = (TF00441*) hdr;

  005ca	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  005d2	48 89 44 24 68	 mov	 QWORD PTR rec$11[rsp], rax

; 4324 :             rec->datalen = SWAP16( rec->datalen );

  005d7	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$11[rsp]
  005dc	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  005e0	e8 00 00 00 00	 call	 _byteswap_ushort
  005e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$11[rsp]
  005ea	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 4325 :             rec->cyl     = SWAP32( rec->cyl     );

  005ee	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$11[rsp]
  005f3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  005f6	e8 00 00 00 00	 call	 _byteswap_ulong
  005fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$11[rsp]
  00600	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4326 :             rec->head    = SWAP32( rec->head    );

  00603	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$11[rsp]
  00608	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0060b	e8 00 00 00 00	 call	 _byteswap_ulong
  00610	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$11[rsp]
  00615	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4327 :             rec->recnum  = SWAP32( rec->recnum  );

  00618	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$11[rsp]
  0061d	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00620	e8 00 00 00 00	 call	 _byteswap_ulong
  00625	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$11[rsp]
  0062a	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4328 :         }
; 4329 :         break;

  0062d	e9 10 0b 00 00	 jmp	 $LN2@tf_swap_re
$LN38@tf_swap_re:

; 4330 : 
; 4331 :         case  442:
; 4332 :         {
; 4333 :             // (nothing to swap!)
; 4334 :         }
; 4335 :         break;

  00632	e9 0b 0b 00 00	 jmp	 $LN2@tf_swap_re
$LN39@tf_swap_re:

; 4336 : 
; 4337 :         case  516:
; 4338 :         {
; 4339 :             TF00516* rec = (TF00516*) hdr;

  00637	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0063f	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR rec$26[rsp], rax

; 4340 :             rec->blkgrp  = SWAP32( rec->blkgrp );

  00647	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR rec$26[rsp]
  0064f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00652	e8 00 00 00 00	 call	 _byteswap_ulong
  00657	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR rec$26[rsp]
  0065f	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4341 :             rec->idx     = SWAP32( rec->idx    );

  00662	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR rec$26[rsp]
  0066a	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0066d	e8 00 00 00 00	 call	 _byteswap_ulong
  00672	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR rec$26[rsp]
  0067a	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4342 :         }
; 4343 :         break;

  0067d	e9 c0 0a 00 00	 jmp	 $LN2@tf_swap_re
$LN40@tf_swap_re:

; 4344 : 
; 4345 :         case  517:
; 4346 :         {
; 4347 :             TF00517* rec = (TF00517*) hdr;

  00682	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0068a	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR rec$37[rsp], rax

; 4348 :             rec->blkgrp  = SWAP32( rec->blkgrp );

  00692	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rec$37[rsp]
  0069a	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0069d	e8 00 00 00 00	 call	 _byteswap_ulong
  006a2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rec$37[rsp]
  006aa	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4349 :         }
; 4350 :         break;

  006ad	e9 90 0a 00 00	 jmp	 $LN2@tf_swap_re
$LN41@tf_swap_re:

; 4351 : 
; 4352 :         case  518:
; 4353 :         {
; 4354 :             TF00518* rec = (TF00518*) hdr;

  006b2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  006ba	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR rec$27[rsp], rax

; 4355 :             rec->blkgrp  = SWAP32( rec->blkgrp );

  006c2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR rec$27[rsp]
  006ca	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  006cd	e8 00 00 00 00	 call	 _byteswap_ulong
  006d2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR rec$27[rsp]
  006da	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4356 :             rec->idx     = SWAP32( rec->idx    );

  006dd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR rec$27[rsp]
  006e5	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  006e8	e8 00 00 00 00	 call	 _byteswap_ulong
  006ed	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR rec$27[rsp]
  006f5	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4357 :         }
; 4358 :         break;

  006f8	e9 45 0a 00 00	 jmp	 $LN2@tf_swap_re
$LN42@tf_swap_re:

; 4359 : 
; 4360 :         case  519:
; 4361 :         {
; 4362 :             TF00519* rec = (TF00519*) hdr;

  006fd	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00705	48 89 44 24 78	 mov	 QWORD PTR rec$13[rsp], rax

; 4363 :             rec->blkgrp  = SWAP32( rec->blkgrp );

  0070a	48 8b 44 24 78	 mov	 rax, QWORD PTR rec$13[rsp]
  0070f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00712	e8 00 00 00 00	 call	 _byteswap_ulong
  00717	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rec$13[rsp]
  0071c	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4364 :             rec->len     = SWAP32( rec->len    );

  0071f	48 8b 44 24 78	 mov	 rax, QWORD PTR rec$13[rsp]
  00724	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00727	e8 00 00 00 00	 call	 _byteswap_ulong
  0072c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rec$13[rsp]
  00731	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4365 :             rec->offset  = SWAP64( rec->offset );

  00734	48 8b 44 24 78	 mov	 rax, QWORD PTR rec$13[rsp]
  00739	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0073d	e8 00 00 00 00	 call	 _byteswap_uint64
  00742	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rec$13[rsp]
  00747	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4366 :         }
; 4367 :         break;

  0074b	e9 f2 09 00 00	 jmp	 $LN2@tf_swap_re
$LN43@tf_swap_re:

; 4368 : 
; 4369 :         case  520:
; 4370 :         {
; 4371 :             TF00520* rec = (TF00520*) hdr;

  00750	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00758	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR rec$38[rsp], rax

; 4372 :             rec->rba     = SWAP64( rec->rba );

  00760	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR rec$38[rsp]
  00768	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0076c	e8 00 00 00 00	 call	 _byteswap_uint64
  00771	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR rec$38[rsp]
  00779	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4373 :         }
; 4374 :         break;

  0077d	e9 c0 09 00 00	 jmp	 $LN2@tf_swap_re
$LN44@tf_swap_re:

; 4375 : 
; 4376 :         case  800:
; 4377 :         {
; 4378 :             TF00800* rec = (TF00800*) hdr;

  00782	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0078a	48 89 44 24 30	 mov	 QWORD PTR rec$2[rsp], rax

; 4379 : 
; 4380 :             rec->psw.intcode  = SWAP16( rec->psw.intcode  );

  0078f	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  00794	0f b7 48 38	 movzx	 ecx, WORD PTR [rax+56]
  00798	e8 00 00 00 00	 call	 _byteswap_ushort
  0079d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  007a2	66 89 41 38	 mov	 WORD PTR [rcx+56], ax

; 4381 :             rec->psw.zeroword = SWAP32( rec->psw.zeroword );

  007a6	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  007ab	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  007ae	e8 00 00 00 00	 call	 _byteswap_ulong
  007b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  007b8	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 4382 :             rec->psw.ia.D     = SWAP64( rec->psw.ia.D     );

  007bb	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  007c0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  007c4	e8 00 00 00 00	 call	 _byteswap_uint64
  007c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  007ce	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4383 :             rec->psw.amask.D  = SWAP64( rec->psw.amask.D  );

  007d2	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  007d7	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  007db	e8 00 00 00 00	 call	 _byteswap_uint64
  007e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  007e5	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 4384 : 
; 4385 :             rec->psw.amode64  = rec->amode64 ? 1 : 0;

  007e9	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  007ee	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  007f2	85 c0		 test	 eax, eax
  007f4	74 0d		 je	 SHORT $LN94@tf_swap_re
  007f6	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv310[rsp], 1
  00801	eb 0b		 jmp	 SHORT $LN95@tf_swap_re
$LN94@tf_swap_re:
  00803	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv310[rsp], 0
$LN95@tf_swap_re:
  0080e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  00815	83 e0 01	 and	 eax, 1
  00818	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  0081d	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00820	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00823	0b c8		 or	 ecx, eax
  00825	8b c1		 mov	 eax, ecx
  00827	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  0082c	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4386 :             rec->psw.amode    = rec->amode   ? 1 : 0;

  0082f	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  00834	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00838	85 c0		 test	 eax, eax
  0083a	74 0d		 je	 SHORT $LN96@tf_swap_re
  0083c	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv319[rsp], 1
  00847	eb 0b		 jmp	 SHORT $LN97@tf_swap_re
$LN96@tf_swap_re:
  00849	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv319[rsp], 0
$LN97@tf_swap_re:
  00854	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv319[rsp]
  0085b	83 e0 01	 and	 eax, 1
  0085e	d1 e0		 shl	 eax, 1
  00860	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  00865	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00868	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0086b	0b c8		 or	 ecx, eax
  0086d	8b c1		 mov	 eax, ecx
  0086f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  00874	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4387 :             rec->psw.zeroilc  = rec->zeroilc ? 1 : 0;

  00877	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$2[rsp]
  0087c	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00880	85 c0		 test	 eax, eax
  00882	74 0d		 je	 SHORT $LN98@tf_swap_re
  00884	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv329[rsp], 1
  0088f	eb 0b		 jmp	 SHORT $LN99@tf_swap_re
$LN98@tf_swap_re:
  00891	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv329[rsp], 0
$LN99@tf_swap_re:
  0089c	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv329[rsp]
  008a3	83 e0 01	 and	 eax, 1
  008a6	c1 e0 02	 shl	 eax, 2
  008a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  008ae	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  008b1	83 e1 fb	 and	 ecx, -5			; fffffffbH
  008b4	0b c8		 or	 ecx, eax
  008b6	8b c1		 mov	 eax, ecx
  008b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$2[rsp]
  008bd	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4388 :         }
; 4389 :         break;

  008c0	e9 7d 08 00 00	 jmp	 $LN2@tf_swap_re
$LN45@tf_swap_re:

; 4390 : 
; 4391 :         case  801:
; 4392 :         {
; 4393 :             TF00801* rec = (TF00801*) hdr;

  008c5	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  008cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rec$14[rsp], rax

; 4394 :             rec->pcode  = SWAP16( rec->pcode );

  008d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rec$14[rsp]
  008dd	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  008e1	e8 00 00 00 00	 call	 _byteswap_ushort
  008e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rec$14[rsp]
  008ee	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 4395 :             rec->dxc    = SWAP32( rec->dxc   );

  008f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rec$14[rsp]
  008fa	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  008fd	e8 00 00 00 00	 call	 _byteswap_ulong
  00902	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rec$14[rsp]
  0090a	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4396 :             rec->why    = SWAP32( rec->why   );

  0090d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rec$14[rsp]
  00915	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00918	e8 00 00 00 00	 call	 _byteswap_ulong
  0091d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rec$14[rsp]
  00925	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4397 :         }
; 4398 :         break;

  00928	e9 15 08 00 00	 jmp	 $LN2@tf_swap_re
$LN46@tf_swap_re:

; 4399 : 
; 4400 :         case  802:
; 4401 :         {
; 4402 :             TF00802* rec = (TF00802*) hdr;

  0092d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00935	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rec$15[rsp], rax

; 4403 :             rec->perc   = SWAP16( rec->perc  );

  0093d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rec$15[rsp]
  00945	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  00949	e8 00 00 00 00	 call	 _byteswap_ushort
  0094e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rec$15[rsp]
  00956	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 4404 :             rec->pcode  = SWAP32( rec->pcode );

  0095a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rec$15[rsp]
  00962	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00965	e8 00 00 00 00	 call	 _byteswap_ulong
  0096a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rec$15[rsp]
  00972	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4405 :             rec->ia     = SWAP64( rec->ia    );

  00975	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rec$15[rsp]
  0097d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00981	e8 00 00 00 00	 call	 _byteswap_uint64
  00986	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rec$15[rsp]
  0098e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4406 :         }
; 4407 :         break;

  00992	e9 ab 07 00 00	 jmp	 $LN2@tf_swap_re
$LN47@tf_swap_re:

; 4408 : 
; 4409 :         case  803:
; 4410 :         {
; 4411 :             // (nothing to swap!)
; 4412 :         }
; 4413 :         break;

  00997	e9 a6 07 00 00	 jmp	 $LN2@tf_swap_re
$LN48@tf_swap_re:

; 4414 : 
; 4415 :         case  804:
; 4416 :         {
; 4417 :             TF00804* rec = (TF00804*) hdr;

  0099c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  009a4	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR rec$39[rsp], rax

; 4418 :             rec->ioid    = SWAP16( rec->ioid );

  009ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR rec$39[rsp]
  009b4	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  009b8	e8 00 00 00 00	 call	 _byteswap_ushort
  009bd	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR rec$39[rsp]
  009c5	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4419 :         }
; 4420 :         break;

  009c9	e9 74 07 00 00	 jmp	 $LN2@tf_swap_re
$LN49@tf_swap_re:

; 4421 : 
; 4422 :         case  806:
; 4423 :         {
; 4424 :             TF00806* rec = (TF00806*) hdr;

  009ce	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  009d6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rec$16[rsp], rax

; 4425 :             rec->ioid    = SWAP32( rec->ioid    );

  009de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rec$16[rsp]
  009e6	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  009e9	e8 00 00 00 00	 call	 _byteswap_ulong
  009ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rec$16[rsp]
  009f6	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4426 :             rec->ioparm  = SWAP32( rec->ioparm  );

  009f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rec$16[rsp]
  00a01	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00a04	e8 00 00 00 00	 call	 _byteswap_ulong
  00a09	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rec$16[rsp]
  00a11	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4427 :             rec->iointid = SWAP32( rec->iointid );

  00a14	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rec$16[rsp]
  00a1c	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00a1f	e8 00 00 00 00	 call	 _byteswap_ulong
  00a24	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rec$16[rsp]
  00a2c	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4428 :         }
; 4429 :         break;

  00a2f	e9 0e 07 00 00	 jmp	 $LN2@tf_swap_re
$LN50@tf_swap_re:

; 4430 : 
; 4431 :         case  807:
; 4432 :         {
; 4433 :             TF00807* rec = (TF00807*) hdr;

  00a34	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00a3c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rec$17[rsp], rax

; 4434 :             rec->xdmg    = SWAP32( rec->xdmg );

  00a44	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rec$17[rsp]
  00a4c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00a4f	e8 00 00 00 00	 call	 _byteswap_ulong
  00a54	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rec$17[rsp]
  00a5c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 4435 :             rec->mcic    = SWAP64( rec->mcic );

  00a5f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rec$17[rsp]
  00a67	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00a6b	e8 00 00 00 00	 call	 _byteswap_uint64
  00a70	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rec$17[rsp]
  00a78	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4436 :             rec->fsta    = SWAP64( rec->fsta );

  00a7c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rec$17[rsp]
  00a84	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00a88	e8 00 00 00 00	 call	 _byteswap_uint64
  00a8d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rec$17[rsp]
  00a95	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4437 :         }
; 4438 :         break;

  00a99	e9 a4 06 00 00	 jmp	 $LN2@tf_swap_re
$LN51@tf_swap_re:

; 4439 : 
; 4440 :         case  808:
; 4441 :         {
; 4442 :             // (nothing to swap!)
; 4443 :         }
; 4444 :         break;

  00a9e	e9 9f 06 00 00	 jmp	 $LN2@tf_swap_re
$LN52@tf_swap_re:

; 4445 : 
; 4446 :         case  809:
; 4447 :         {
; 4448 :             // (nothing to swap!)
; 4449 :         }
; 4450 :         break;

  00aa3	e9 9a 06 00 00	 jmp	 $LN2@tf_swap_re
$LN53@tf_swap_re:

; 4451 : 
; 4452 :         case  811:
; 4453 :         {
; 4454 :             // (nothing to swap!)
; 4455 :         }
; 4456 :         break;

  00aa8	e9 95 06 00 00	 jmp	 $LN2@tf_swap_re
$LN54@tf_swap_re:

; 4457 : 
; 4458 :         case  812:
; 4459 :         {
; 4460 :             // (nothing to swap!)
; 4461 :         }
; 4462 :         break;

  00aad	e9 90 06 00 00	 jmp	 $LN2@tf_swap_re
$LN55@tf_swap_re:

; 4463 : 
; 4464 :         case  814:
; 4465 :         {
; 4466 :             TF00814* rec = (TF00814*) hdr;

  00ab2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00aba	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rec$18[rsp], rax

; 4467 :             rec->cpad    = SWAP16( rec->cpad   );

  00ac2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rec$18[rsp]
  00aca	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  00ace	e8 00 00 00 00	 call	 _byteswap_ushort
  00ad3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rec$18[rsp]
  00adb	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 4468 :             rec->status  = SWAP32( rec->status );

  00adf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rec$18[rsp]
  00ae7	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00aea	e8 00 00 00 00	 call	 _byteswap_ulong
  00aef	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rec$18[rsp]
  00af7	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4469 :             rec->parm    = SWAP64( rec->parm   );

  00afa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rec$18[rsp]
  00b02	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00b06	e8 00 00 00 00	 call	 _byteswap_uint64
  00b0b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rec$18[rsp]
  00b13	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4470 :         }
; 4471 :         break;

  00b17	e9 26 06 00 00	 jmp	 $LN2@tf_swap_re
$LN56@tf_swap_re:

; 4472 : 
; 4473 :         case  840:
; 4474 :         {
; 4475 :             TF00840* rec   = (TF00840*) hdr;

  00b1c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00b24	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR rec$28[rsp], rax

; 4476 :             rec->icode     = SWAP16( rec->icode     );

  00b2c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR rec$28[rsp]
  00b34	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  00b38	e8 00 00 00 00	 call	 _byteswap_ushort
  00b3d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR rec$28[rsp]
  00b45	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4477 :             rec->cpu_timer = SWAP64( rec->cpu_timer );

  00b49	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR rec$28[rsp]
  00b51	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00b55	e8 00 00 00 00	 call	 _byteswap_uint64
  00b5a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR rec$28[rsp]
  00b62	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4478 :         }
; 4479 :         break;

  00b66	e9 d7 05 00 00	 jmp	 $LN2@tf_swap_re
$LN57@tf_swap_re:

; 4480 : 
; 4481 :         case  844:
; 4482 :         {
; 4483 :             TF00844* rec  = (TF00844*) hdr;

  00b6b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00b73	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR rec$29[rsp], rax

; 4484 :             rec->servcode = SWAP16( rec->servcode );

  00b7b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rec$29[rsp]
  00b83	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  00b87	e8 00 00 00 00	 call	 _byteswap_ushort
  00b8c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR rec$29[rsp]
  00b94	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4485 :             rec->bioparm  = SWAP64( rec->bioparm  );

  00b98	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR rec$29[rsp]
  00ba0	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00ba4	e8 00 00 00 00	 call	 _byteswap_uint64
  00ba9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR rec$29[rsp]
  00bb1	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4486 :         }
; 4487 :         break;

  00bb5	e9 88 05 00 00	 jmp	 $LN2@tf_swap_re
$LN58@tf_swap_re:

; 4488 : 
; 4489 :         case  845:
; 4490 :         {
; 4491 :             TF00845* rec = (TF00845*) hdr;

  00bba	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00bc2	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR rec$40[rsp], rax

; 4492 :             rec->bioparm = SWAP64( rec->bioparm );

  00bca	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR rec$40[rsp]
  00bd2	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00bd6	e8 00 00 00 00	 call	 _byteswap_uint64
  00bdb	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR rec$40[rsp]
  00be3	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4493 :         }
; 4494 :         break;

  00be7	e9 56 05 00 00	 jmp	 $LN2@tf_swap_re
$LN59@tf_swap_re:

; 4495 : 
; 4496 :         case  846:
; 4497 :         {
; 4498 :             TF00846* rec  = (TF00846*) hdr;

  00bec	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00bf4	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR rec$41[rsp], rax

; 4499 :             rec->servparm = SWAP32( rec->servparm );

  00bfc	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR rec$41[rsp]
  00c04	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00c07	e8 00 00 00 00	 call	 _byteswap_ulong
  00c0c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR rec$41[rsp]
  00c14	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4500 :         }
; 4501 :         break;

  00c17	e9 26 05 00 00	 jmp	 $LN2@tf_swap_re
$LN60@tf_swap_re:

; 4502 : 
; 4503 :         case 1300:
; 4504 :         {
; 4505 :             // (nothing to swap!)
; 4506 :         }
; 4507 :         break;

  00c1c	e9 21 05 00 00	 jmp	 $LN2@tf_swap_re
$LN61@tf_swap_re:

; 4508 : 
; 4509 :         case 1301:
; 4510 :         {
; 4511 :             TF01301* rec = (TF01301*) hdr;

  00c21	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c29	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR rec$30[rsp], rax

; 4512 :             rec->count   = SWAP16( rec->count );

  00c31	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR rec$30[rsp]
  00c39	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  00c3d	e8 00 00 00 00	 call	 _byteswap_ushort
  00c42	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR rec$30[rsp]
  00c4a	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4513 :             rec->addr    = SWAP64( rec->addr  );

  00c4e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR rec$30[rsp]
  00c56	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00c5a	e8 00 00 00 00	 call	 _byteswap_uint64
  00c5f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR rec$30[rsp]
  00c67	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4514 :         }
; 4515 :         break;

  00c6b	e9 d2 04 00 00	 jmp	 $LN2@tf_swap_re
$LN62@tf_swap_re:

; 4516 : 
; 4517 :         case 1304:
; 4518 :         {
; 4519 :             // (nothing to swap!)
; 4520 :         }
; 4521 :         break;

  00c70	e9 cd 04 00 00	 jmp	 $LN2@tf_swap_re
$LN63@tf_swap_re:

; 4522 : 
; 4523 :         case 1305:
; 4524 :         {
; 4525 :             // (nothing to swap!)
; 4526 :         }
; 4527 :         break;

  00c75	e9 c8 04 00 00	 jmp	 $LN2@tf_swap_re
$LN64@tf_swap_re:

; 4528 : 
; 4529 :         case 1306:
; 4530 :         {
; 4531 :             // (nothing to swap!)
; 4532 :         }
; 4533 :         break;

  00c7a	e9 c3 04 00 00	 jmp	 $LN2@tf_swap_re
$LN65@tf_swap_re:

; 4534 : 
; 4535 :         case 1307:
; 4536 :         {
; 4537 :             // (nothing to swap!)
; 4538 :         }
; 4539 :         break;

  00c7f	e9 be 04 00 00	 jmp	 $LN2@tf_swap_re
$LN66@tf_swap_re:

; 4540 : 
; 4541 :         case 1308:
; 4542 :         {
; 4543 :             // (nothing to swap!)
; 4544 :         }
; 4545 :         break;

  00c84	e9 b9 04 00 00	 jmp	 $LN2@tf_swap_re
$LN67@tf_swap_re:

; 4546 : 
; 4547 :         case 1309:
; 4548 :         {
; 4549 :             // (nothing to swap!)
; 4550 :         }
; 4551 :         break;

  00c89	e9 b4 04 00 00	 jmp	 $LN2@tf_swap_re
$LN68@tf_swap_re:

; 4552 : 
; 4553 :         case 1310:
; 4554 :         {
; 4555 :             // (nothing to swap!)
; 4556 :         }
; 4557 :         break;

  00c8e	e9 af 04 00 00	 jmp	 $LN2@tf_swap_re
$LN69@tf_swap_re:

; 4558 : 
; 4559 :         case 1311:
; 4560 :         {
; 4561 :             // (nothing to swap!)
; 4562 :         }
; 4563 :         break;

  00c93	e9 aa 04 00 00	 jmp	 $LN2@tf_swap_re
$LN70@tf_swap_re:

; 4564 : 
; 4565 :         case 1312:
; 4566 :         {
; 4567 :             TF01312* rec  = (TF01312*) hdr;

  00c98	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00ca0	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR rec$42[rsp], rax

; 4568 :             rec->residual = SWAP32( rec->residual );

  00ca8	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR rec$42[rsp]
  00cb0	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00cb3	e8 00 00 00 00	 call	 _byteswap_ulong
  00cb8	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR rec$42[rsp]
  00cc0	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4569 :         }
; 4570 :         break;

  00cc3	e9 7a 04 00 00	 jmp	 $LN2@tf_swap_re
$LN71@tf_swap_re:

; 4571 : 
; 4572 :         case 1313:
; 4573 :         {
; 4574 :             // (nothing to swap!)
; 4575 :         }
; 4576 :         break;

  00cc8	e9 75 04 00 00	 jmp	 $LN2@tf_swap_re
$LN72@tf_swap_re:

; 4577 : 
; 4578 :         case 1315:
; 4579 :         {
; 4580 :             TF01315* rec = (TF01315*) hdr;

  00ccd	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00cd5	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR rec$31[rsp], rax

; 4581 :             rec->count   = SWAP16( rec->count );

  00cdd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR rec$31[rsp]
  00ce5	0f b7 48 1c	 movzx	 ecx, WORD PTR [rax+28]
  00ce9	e8 00 00 00 00	 call	 _byteswap_ushort
  00cee	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rec$31[rsp]
  00cf6	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 4582 :             rec->addr    = SWAP32( rec->addr  );

  00cfa	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR rec$31[rsp]
  00d02	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00d05	e8 00 00 00 00	 call	 _byteswap_ulong
  00d0a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rec$31[rsp]
  00d12	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4583 :         }
; 4584 :         break;

  00d15	e9 28 04 00 00	 jmp	 $LN2@tf_swap_re
$LN73@tf_swap_re:

; 4585 : 
; 4586 :         case 1316:
; 4587 :         {
; 4588 :             // (nothing to swap!)
; 4589 :         }
; 4590 :         break;

  00d1a	e9 23 04 00 00	 jmp	 $LN2@tf_swap_re
$LN74@tf_swap_re:

; 4591 : 
; 4592 :         case 1317:
; 4593 :         {
; 4594 :             // (nothing to swap!)
; 4595 :         }
; 4596 :         break;

  00d1f	e9 1e 04 00 00	 jmp	 $LN2@tf_swap_re
$LN75@tf_swap_re:

; 4597 : 
; 4598 :         case 1318:
; 4599 :         {
; 4600 :             // (nothing to swap!)
; 4601 :         }
; 4602 :         break;

  00d24	e9 19 04 00 00	 jmp	 $LN2@tf_swap_re
$LN76@tf_swap_re:

; 4603 : 
; 4604 :         case 1320:
; 4605 :         {
; 4606 :             // (nothing to swap!)
; 4607 :         }
; 4608 :         break;

  00d29	e9 14 04 00 00	 jmp	 $LN2@tf_swap_re
$LN77@tf_swap_re:

; 4609 : 
; 4610 :         case 1321:
; 4611 :         {
; 4612 :             // (nothing to swap!)
; 4613 :         }
; 4614 :         break;

  00d2e	e9 0f 04 00 00	 jmp	 $LN2@tf_swap_re
$LN78@tf_swap_re:

; 4615 : 
; 4616 :         case 1329:
; 4617 :         {
; 4618 :             // (nothing to swap!)
; 4619 :         }
; 4620 :         break;

  00d33	e9 0a 04 00 00	 jmp	 $LN2@tf_swap_re
$LN79@tf_swap_re:

; 4621 : 
; 4622 :         case 1330:
; 4623 :         {
; 4624 :             // (nothing to swap!)
; 4625 :         }
; 4626 :         break;

  00d38	e9 05 04 00 00	 jmp	 $LN2@tf_swap_re
$LN80@tf_swap_re:

; 4627 : 
; 4628 :         case 1331:
; 4629 :         {
; 4630 :             // (nothing to swap!)
; 4631 :         }
; 4632 :         break;

  00d3d	e9 00 04 00 00	 jmp	 $LN2@tf_swap_re
$LN81@tf_swap_re:

; 4633 : 
; 4634 :         case 1332:
; 4635 :         {
; 4636 :             // (nothing to swap!)
; 4637 :         }
; 4638 :         break;

  00d42	e9 fb 03 00 00	 jmp	 $LN2@tf_swap_re
$LN82@tf_swap_re:

; 4639 : 
; 4640 :         case 1333:
; 4641 :         {
; 4642 :             // (nothing to swap!)
; 4643 :         }
; 4644 :         break;

  00d47	e9 f6 03 00 00	 jmp	 $LN2@tf_swap_re
$LN83@tf_swap_re:

; 4645 : 
; 4646 :         case 1334:
; 4647 :         {
; 4648 :             // (nothing to swap!)
; 4649 :         }
; 4650 :         break;

  00d4c	e9 f1 03 00 00	 jmp	 $LN2@tf_swap_re
$LN84@tf_swap_re:

; 4651 : 
; 4652 :         case 1336:
; 4653 :         {
; 4654 :             // (nothing to swap!)
; 4655 :         }
; 4656 :         break;

  00d51	e9 ec 03 00 00	 jmp	 $LN2@tf_swap_re
$LN85@tf_swap_re:

; 4657 : 
; 4658 :         case 2269:
; 4659 :         {
; 4660 :             TF02269* rec = (TF02269*) hdr;

  00d56	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00d5e	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR rec$43[rsp], rax

; 4661 :             int  i;
; 4662 :             for (i=0; i < 16; ++i)

  00d66	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$5[rsp], 0
  00d6e	eb 0a		 jmp	 SHORT $LN6@tf_swap_re
$LN4@tf_swap_re:
  00d70	8b 44 24 48	 mov	 eax, DWORD PTR i$5[rsp]
  00d74	ff c0		 inc	 eax
  00d76	89 44 24 48	 mov	 DWORD PTR i$5[rsp], eax
$LN6@tf_swap_re:
  00d7a	83 7c 24 48 10	 cmp	 DWORD PTR i$5[rsp], 16
  00d7f	7d 2b		 jge	 SHORT $LN5@tf_swap_re

; 4663 :                 rec->gr[i].D   = SWAP64( rec->gr[i].D );

  00d81	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$5[rsp]
  00d86	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR rec$43[rsp]
  00d8e	48 8b 4c c1 20	 mov	 rcx, QWORD PTR [rcx+rax*8+32]
  00d93	e8 00 00 00 00	 call	 _byteswap_uint64
  00d98	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR i$5[rsp]
  00d9d	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR rec$43[rsp]
  00da5	48 89 44 ca 20	 mov	 QWORD PTR [rdx+rcx*8+32], rax
  00daa	eb c4		 jmp	 SHORT $LN4@tf_swap_re
$LN5@tf_swap_re:

; 4664 :         }
; 4665 :         break;

  00dac	e9 91 03 00 00	 jmp	 $LN2@tf_swap_re
$LN86@tf_swap_re:

; 4666 : 
; 4667 :         case 2270:
; 4668 :         {
; 4669 :             TF02270* rec = (TF02270*) hdr;

  00db1	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00db9	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR rec$44[rsp], rax

; 4670 :             int  i;
; 4671 :             for (i=0; i < 32; ++i)

  00dc1	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00dc9	eb 0a		 jmp	 SHORT $LN9@tf_swap_re
$LN7@tf_swap_re:
  00dcb	8b 44 24 4c	 mov	 eax, DWORD PTR i$6[rsp]
  00dcf	ff c0		 inc	 eax
  00dd1	89 44 24 4c	 mov	 DWORD PTR i$6[rsp], eax
$LN9@tf_swap_re:
  00dd5	83 7c 24 4c 20	 cmp	 DWORD PTR i$6[rsp], 32	; 00000020H
  00dda	7d 29		 jge	 SHORT $LN8@tf_swap_re

; 4672 :                 rec->fpr[i]   = SWAP32( rec->fpr[i] );

  00ddc	48 63 44 24 4c	 movsxd	 rax, DWORD PTR i$6[rsp]
  00de1	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR rec$44[rsp]
  00de9	8b 4c 81 18	 mov	 ecx, DWORD PTR [rcx+rax*4+24]
  00ded	e8 00 00 00 00	 call	 _byteswap_ulong
  00df2	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR i$6[rsp]
  00df7	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR rec$44[rsp]
  00dff	89 44 8a 18	 mov	 DWORD PTR [rdx+rcx*4+24], eax
  00e03	eb c6		 jmp	 SHORT $LN7@tf_swap_re
$LN8@tf_swap_re:

; 4673 :         }
; 4674 :         break;

  00e05	e9 38 03 00 00	 jmp	 $LN2@tf_swap_re
$LN87@tf_swap_re:

; 4675 : 
; 4676 :         case 2271:
; 4677 :         {
; 4678 :             TF02271* rec = (TF02271*) hdr;

  00e0a	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00e12	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR rec$45[rsp], rax

; 4679 :             int  i;
; 4680 :             for (i=0; i < 16; ++i)

  00e1a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$7[rsp], 0
  00e22	eb 0a		 jmp	 SHORT $LN12@tf_swap_re
$LN10@tf_swap_re:
  00e24	8b 44 24 50	 mov	 eax, DWORD PTR i$7[rsp]
  00e28	ff c0		 inc	 eax
  00e2a	89 44 24 50	 mov	 DWORD PTR i$7[rsp], eax
$LN12@tf_swap_re:
  00e2e	83 7c 24 50 10	 cmp	 DWORD PTR i$7[rsp], 16
  00e33	7d 2b		 jge	 SHORT $LN11@tf_swap_re

; 4681 :                 rec->cr[i].D   = SWAP64( rec->cr[i].D );

  00e35	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$7[rsp]
  00e3a	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR rec$45[rsp]
  00e42	48 8b 4c c1 18	 mov	 rcx, QWORD PTR [rcx+rax*8+24]
  00e47	e8 00 00 00 00	 call	 _byteswap_uint64
  00e4c	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$7[rsp]
  00e51	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR rec$45[rsp]
  00e59	48 89 44 ca 18	 mov	 QWORD PTR [rdx+rcx*8+24], rax
  00e5e	eb c4		 jmp	 SHORT $LN10@tf_swap_re
$LN11@tf_swap_re:

; 4682 :         }
; 4683 :         break;

  00e60	e9 dd 02 00 00	 jmp	 $LN2@tf_swap_re
$LN88@tf_swap_re:

; 4684 : 
; 4685 :         case 2272:
; 4686 :         {
; 4687 :             TF02272* rec = (TF02272*) hdr;

  00e65	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00e6d	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR rec$46[rsp], rax

; 4688 :             int  i;
; 4689 :             for (i=0; i < 16; ++i)

  00e75	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  00e7d	eb 0a		 jmp	 SHORT $LN15@tf_swap_re
$LN13@tf_swap_re:
  00e7f	8b 44 24 54	 mov	 eax, DWORD PTR i$8[rsp]
  00e83	ff c0		 inc	 eax
  00e85	89 44 24 54	 mov	 DWORD PTR i$8[rsp], eax
$LN15@tf_swap_re:
  00e89	83 7c 24 54 10	 cmp	 DWORD PTR i$8[rsp], 16
  00e8e	7d 29		 jge	 SHORT $LN14@tf_swap_re

; 4690 :                 rec->ar[i]   = SWAP32( rec->ar[i] );

  00e90	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$8[rsp]
  00e95	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR rec$46[rsp]
  00e9d	8b 4c 81 18	 mov	 ecx, DWORD PTR [rcx+rax*4+24]
  00ea1	e8 00 00 00 00	 call	 _byteswap_ulong
  00ea6	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$8[rsp]
  00eab	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR rec$46[rsp]
  00eb3	89 44 8a 18	 mov	 DWORD PTR [rdx+rcx*4+24], eax
  00eb7	eb c6		 jmp	 SHORT $LN13@tf_swap_re
$LN14@tf_swap_re:

; 4691 :         }
; 4692 :         break;

  00eb9	e9 84 02 00 00	 jmp	 $LN2@tf_swap_re
$LN89@tf_swap_re:

; 4693 : 
; 4694 :         case 2276:
; 4695 :         {
; 4696 :             TF02276* rec = (TF02276*) hdr;

  00ebe	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00ec6	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR rec$47[rsp], rax

; 4697 :             rec->fpc     = SWAP32( rec->fpc );

  00ece	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR rec$47[rsp]
  00ed6	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00ed9	e8 00 00 00 00	 call	 _byteswap_ulong
  00ede	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR rec$47[rsp]
  00ee6	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4698 :         }
; 4699 :         break;

  00ee9	e9 54 02 00 00	 jmp	 $LN2@tf_swap_re
$LN90@tf_swap_re:

; 4700 : 
; 4701 :         case 2324:
; 4702 :         {
; 4703 :             TF02324* rec = (TF02324*) hdr;

  00eee	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00ef6	48 89 44 24 28	 mov	 QWORD PTR rec$1[rsp], rax

; 4704 : 
; 4705 :             rec->psw.intcode  = SWAP16( rec->psw.intcode  );

  00efb	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00f00	0f b7 48 38	 movzx	 ecx, WORD PTR [rax+56]
  00f04	e8 00 00 00 00	 call	 _byteswap_ushort
  00f09	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f0e	66 89 41 38	 mov	 WORD PTR [rcx+56], ax

; 4706 :             rec->psw.zeroword = SWAP32( rec->psw.zeroword );

  00f12	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00f17	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00f1a	e8 00 00 00 00	 call	 _byteswap_ulong
  00f1f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f24	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 4707 :             rec->psw.ia.D     = SWAP64( rec->psw.ia.D     );

  00f27	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00f2c	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00f30	e8 00 00 00 00	 call	 _byteswap_uint64
  00f35	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f3a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4708 :             rec->psw.amask.D  = SWAP64( rec->psw.amask.D  );

  00f3e	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00f43	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00f47	e8 00 00 00 00	 call	 _byteswap_uint64
  00f4c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f51	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 4709 : 
; 4710 :             rec->psw.amode64  = rec->amode64 ? 1 : 0;

  00f55	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00f5a	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  00f5e	85 c0		 test	 eax, eax
  00f60	74 0d		 je	 SHORT $LN100@tf_swap_re
  00f62	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv551[rsp], 1
  00f6d	eb 0b		 jmp	 SHORT $LN101@tf_swap_re
$LN100@tf_swap_re:
  00f6f	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv551[rsp], 0
$LN101@tf_swap_re:
  00f7a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv551[rsp]
  00f81	83 e0 01	 and	 eax, 1
  00f84	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f89	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00f8c	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00f8f	0b c8		 or	 ecx, eax
  00f91	8b c1		 mov	 eax, ecx
  00f93	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00f98	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4711 :             rec->psw.amode    = rec->amode   ? 1 : 0;

  00f9b	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00fa0	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00fa4	85 c0		 test	 eax, eax
  00fa6	74 0d		 je	 SHORT $LN102@tf_swap_re
  00fa8	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv560[rsp], 1
  00fb3	eb 0b		 jmp	 SHORT $LN103@tf_swap_re
$LN102@tf_swap_re:
  00fb5	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv560[rsp], 0
$LN103@tf_swap_re:
  00fc0	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv560[rsp]
  00fc7	83 e0 01	 and	 eax, 1
  00fca	d1 e0		 shl	 eax, 1
  00fcc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00fd1	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00fd4	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00fd7	0b c8		 or	 ecx, eax
  00fd9	8b c1		 mov	 eax, ecx
  00fdb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  00fe0	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4712 :             rec->psw.zeroilc  = rec->zeroilc ? 1 : 0;

  00fe3	48 8b 44 24 28	 mov	 rax, QWORD PTR rec$1[rsp]
  00fe8	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00fec	85 c0		 test	 eax, eax
  00fee	74 0d		 je	 SHORT $LN104@tf_swap_re
  00ff0	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv570[rsp], 1
  00ffb	eb 0b		 jmp	 SHORT $LN105@tf_swap_re
$LN104@tf_swap_re:
  00ffd	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv570[rsp], 0
$LN105@tf_swap_re:
  01008	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv570[rsp]
  0100f	83 e0 01	 and	 eax, 1
  01012	c1 e0 02	 shl	 eax, 2
  01015	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  0101a	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  0101d	83 e1 fb	 and	 ecx, -5			; fffffffbH
  01020	0b c8		 or	 ecx, eax
  01022	8b c1		 mov	 eax, ecx
  01024	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rec$1[rsp]
  01029	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 4713 :         }
; 4714 :         break;

  0102c	e9 11 01 00 00	 jmp	 $LN2@tf_swap_re
$LN91@tf_swap_re:

; 4715 : 
; 4716 :         case 2326:
; 4717 :         {
; 4718 :             TF02326* rec = (TF02326*) hdr;

  01031	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01039	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rec$19[rsp], rax

; 4719 :             TFOP* op;
; 4720 : 
; 4721 :             rec->b1   = SWAP16( rec->b1 );

  01041	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rec$19[rsp]
  01049	0f b7 48 1c	 movzx	 ecx, WORD PTR [rax+28]
  0104d	e8 00 00 00 00	 call	 _byteswap_ushort
  01052	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$19[rsp]
  0105a	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 4722 :             rec->b2   = SWAP16( rec->b2 );

  0105e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rec$19[rsp]
  01066	0f b7 48 1e	 movzx	 ecx, WORD PTR [rax+30]
  0106a	e8 00 00 00 00	 call	 _byteswap_ushort
  0106f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$19[rsp]
  01077	66 89 41 1e	 mov	 WORD PTR [rcx+30], ax

; 4723 : 
; 4724 :             op = &rec->op1;

  0107b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rec$19[rsp]
  01083	48 83 c0 20	 add	 rax, 32			; 00000020H
  01087	48 89 44 24 38	 mov	 QWORD PTR op$3[rsp], rax

; 4725 : 
; 4726 :             op->xcode = SWAP16( op->xcode );

  0108c	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  01091	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  01095	e8 00 00 00 00	 call	 _byteswap_ushort
  0109a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  0109f	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4727 :             op->vaddr = SWAP64( op->vaddr );

  010a3	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  010a8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  010ab	e8 00 00 00 00	 call	 _byteswap_uint64
  010b0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  010b5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4728 :             op->raddr = SWAP64( op->raddr );

  010b8	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  010bd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  010c1	e8 00 00 00 00	 call	 _byteswap_uint64
  010c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  010cb	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 4729 : 
; 4730 :             op = &rec->op2;

  010cf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rec$19[rsp]
  010d7	48 83 c0 48	 add	 rax, 72			; 00000048H
  010db	48 89 44 24 38	 mov	 QWORD PTR op$3[rsp], rax

; 4731 : 
; 4732 :             op->xcode = SWAP16( op->xcode );

  010e0	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  010e5	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  010e9	e8 00 00 00 00	 call	 _byteswap_ushort
  010ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  010f3	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 4733 :             op->vaddr = SWAP64( op->vaddr );

  010f7	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  010fc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  010ff	e8 00 00 00 00	 call	 _byteswap_uint64
  01104	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  01109	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4734 :             op->raddr = SWAP64( op->raddr );

  0110c	48 8b 44 24 38	 mov	 rax, QWORD PTR op$3[rsp]
  01111	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  01115	e8 00 00 00 00	 call	 _byteswap_uint64
  0111a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op$3[rsp]
  0111f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 4735 :         }
; 4736 :         break;

  01123	eb 1d		 jmp	 SHORT $LN2@tf_swap_re
$LN92@tf_swap_re:
$LN18@tf_swap_re:

; 4737 : 
; 4738 :         default: CRASH(); UNREACHABLE_CODE( return );

  01125	48 c7 84 24 a8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR p$48[rsp], 0
  01131	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR p$48[rsp]
  01139	c6 00 00	 mov	 BYTE PTR [rax], 0
  0113c	33 c0		 xor	 eax, eax
  0113e	85 c0		 test	 eax, eax
  01140	75 e3		 jne	 SHORT $LN18@tf_swap_re
$LN2@tf_swap_re:
$LN93@tf_swap_re:

; 4739 :     }
; 4740 : }

  01142	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  01149	c3		 ret	 0
  0114a	66 90		 npad	 2
$LN115@tf_swap_re:
  0114c	00 00 00 00	 DD	 $LN19@tf_swap_re
  01150	00 00 00 00	 DD	 $LN20@tf_swap_re
  01154	00 00 00 00	 DD	 $LN21@tf_swap_re
  01158	00 00 00 00	 DD	 $LN22@tf_swap_re
  0115c	00 00 00 00	 DD	 $LN23@tf_swap_re
  01160	00 00 00 00	 DD	 $LN24@tf_swap_re
  01164	00 00 00 00	 DD	 $LN25@tf_swap_re
  01168	00 00 00 00	 DD	 $LN26@tf_swap_re
  0116c	00 00 00 00	 DD	 $LN27@tf_swap_re
  01170	00 00 00 00	 DD	 $LN28@tf_swap_re
  01174	00 00 00 00	 DD	 $LN29@tf_swap_re
  01178	00 00 00 00	 DD	 $LN30@tf_swap_re
  0117c	00 00 00 00	 DD	 $LN31@tf_swap_re
  01180	00 00 00 00	 DD	 $LN32@tf_swap_re
  01184	00 00 00 00	 DD	 $LN33@tf_swap_re
  01188	00 00 00 00	 DD	 $LN34@tf_swap_re
  0118c	00 00 00 00	 DD	 $LN35@tf_swap_re
  01190	00 00 00 00	 DD	 $LN36@tf_swap_re
  01194	00 00 00 00	 DD	 $LN37@tf_swap_re
  01198	00 00 00 00	 DD	 $LN38@tf_swap_re
  0119c	00 00 00 00	 DD	 $LN39@tf_swap_re
  011a0	00 00 00 00	 DD	 $LN40@tf_swap_re
  011a4	00 00 00 00	 DD	 $LN41@tf_swap_re
  011a8	00 00 00 00	 DD	 $LN42@tf_swap_re
  011ac	00 00 00 00	 DD	 $LN43@tf_swap_re
  011b0	00 00 00 00	 DD	 $LN92@tf_swap_re
$LN114@tf_swap_re:
  011b4	00		 DB	 0
  011b5	01		 DB	 1
  011b6	02		 DB	 2
  011b7	03		 DB	 3
  011b8	04		 DB	 4
  011b9	05		 DB	 5
  011ba	06		 DB	 6
  011bb	07		 DB	 7
  011bc	08		 DB	 8
  011bd	09		 DB	 9
  011be	0a		 DB	 10
  011bf	0b		 DB	 11
  011c0	0c		 DB	 12
  011c1	0d		 DB	 13
  011c2	0e		 DB	 14
  011c3	0f		 DB	 15
  011c4	10		 DB	 16
  011c5	11		 DB	 17
  011c6	12		 DB	 18
  011c7	13		 DB	 19
  011c8	19		 DB	 25
  011c9	19		 DB	 25
  011ca	19		 DB	 25
  011cb	19		 DB	 25
  011cc	19		 DB	 25
  011cd	19		 DB	 25
  011ce	19		 DB	 25
  011cf	19		 DB	 25
  011d0	19		 DB	 25
  011d1	19		 DB	 25
  011d2	19		 DB	 25
  011d3	19		 DB	 25
  011d4	19		 DB	 25
  011d5	19		 DB	 25
  011d6	19		 DB	 25
  011d7	19		 DB	 25
  011d8	19		 DB	 25
  011d9	19		 DB	 25
  011da	19		 DB	 25
  011db	19		 DB	 25
  011dc	19		 DB	 25
  011dd	19		 DB	 25
  011de	19		 DB	 25
  011df	19		 DB	 25
  011e0	19		 DB	 25
  011e1	19		 DB	 25
  011e2	19		 DB	 25
  011e3	19		 DB	 25
  011e4	19		 DB	 25
  011e5	19		 DB	 25
  011e6	19		 DB	 25
  011e7	19		 DB	 25
  011e8	19		 DB	 25
  011e9	19		 DB	 25
  011ea	19		 DB	 25
  011eb	19		 DB	 25
  011ec	19		 DB	 25
  011ed	19		 DB	 25
  011ee	19		 DB	 25
  011ef	19		 DB	 25
  011f0	19		 DB	 25
  011f1	19		 DB	 25
  011f2	19		 DB	 25
  011f3	19		 DB	 25
  011f4	19		 DB	 25
  011f5	19		 DB	 25
  011f6	19		 DB	 25
  011f7	19		 DB	 25
  011f8	19		 DB	 25
  011f9	19		 DB	 25
  011fa	19		 DB	 25
  011fb	19		 DB	 25
  011fc	19		 DB	 25
  011fd	19		 DB	 25
  011fe	19		 DB	 25
  011ff	19		 DB	 25
  01200	19		 DB	 25
  01201	19		 DB	 25
  01202	19		 DB	 25
  01203	19		 DB	 25
  01204	19		 DB	 25
  01205	19		 DB	 25
  01206	19		 DB	 25
  01207	19		 DB	 25
  01208	19		 DB	 25
  01209	19		 DB	 25
  0120a	19		 DB	 25
  0120b	19		 DB	 25
  0120c	19		 DB	 25
  0120d	19		 DB	 25
  0120e	19		 DB	 25
  0120f	19		 DB	 25
  01210	19		 DB	 25
  01211	14		 DB	 20
  01212	15		 DB	 21
  01213	16		 DB	 22
  01214	17		 DB	 23
  01215	18		 DB	 24
  01216	66 90		 npad	 2
$LN113@tf_swap_re:
  01218	00 00 00 00	 DD	 $LN45@tf_swap_re
  0121c	00 00 00 00	 DD	 $LN46@tf_swap_re
  01220	00 00 00 00	 DD	 $LN47@tf_swap_re
  01224	00 00 00 00	 DD	 $LN48@tf_swap_re
  01228	00 00 00 00	 DD	 $LN49@tf_swap_re
  0122c	00 00 00 00	 DD	 $LN50@tf_swap_re
  01230	00 00 00 00	 DD	 $LN51@tf_swap_re
  01234	00 00 00 00	 DD	 $LN52@tf_swap_re
  01238	00 00 00 00	 DD	 $LN53@tf_swap_re
  0123c	00 00 00 00	 DD	 $LN54@tf_swap_re
  01240	00 00 00 00	 DD	 $LN55@tf_swap_re
  01244	00 00 00 00	 DD	 $LN56@tf_swap_re
  01248	00 00 00 00	 DD	 $LN57@tf_swap_re
  0124c	00 00 00 00	 DD	 $LN58@tf_swap_re
  01250	00 00 00 00	 DD	 $LN59@tf_swap_re
  01254	00 00 00 00	 DD	 $LN92@tf_swap_re
$LN112@tf_swap_re:
  01258	00		 DB	 0
  01259	01		 DB	 1
  0125a	02		 DB	 2
  0125b	03		 DB	 3
  0125c	0f		 DB	 15
  0125d	04		 DB	 4
  0125e	05		 DB	 5
  0125f	06		 DB	 6
  01260	07		 DB	 7
  01261	0f		 DB	 15
  01262	08		 DB	 8
  01263	09		 DB	 9
  01264	0f		 DB	 15
  01265	0a		 DB	 10
  01266	0f		 DB	 15
  01267	0f		 DB	 15
  01268	0f		 DB	 15
  01269	0f		 DB	 15
  0126a	0f		 DB	 15
  0126b	0f		 DB	 15
  0126c	0f		 DB	 15
  0126d	0f		 DB	 15
  0126e	0f		 DB	 15
  0126f	0f		 DB	 15
  01270	0f		 DB	 15
  01271	0f		 DB	 15
  01272	0f		 DB	 15
  01273	0f		 DB	 15
  01274	0f		 DB	 15
  01275	0f		 DB	 15
  01276	0f		 DB	 15
  01277	0f		 DB	 15
  01278	0f		 DB	 15
  01279	0f		 DB	 15
  0127a	0f		 DB	 15
  0127b	0f		 DB	 15
  0127c	0f		 DB	 15
  0127d	0f		 DB	 15
  0127e	0f		 DB	 15
  0127f	0b		 DB	 11
  01280	0f		 DB	 15
  01281	0f		 DB	 15
  01282	0f		 DB	 15
  01283	0c		 DB	 12
  01284	0d		 DB	 13
  01285	0e		 DB	 14
  01286	66 90		 npad	 2
$LN111@tf_swap_re:
  01288	00 00 00 00	 DD	 $LN61@tf_swap_re
  0128c	00 00 00 00	 DD	 $LN92@tf_swap_re
  01290	00 00 00 00	 DD	 $LN92@tf_swap_re
  01294	00 00 00 00	 DD	 $LN62@tf_swap_re
  01298	00 00 00 00	 DD	 $LN63@tf_swap_re
  0129c	00 00 00 00	 DD	 $LN64@tf_swap_re
  012a0	00 00 00 00	 DD	 $LN65@tf_swap_re
  012a4	00 00 00 00	 DD	 $LN66@tf_swap_re
  012a8	00 00 00 00	 DD	 $LN67@tf_swap_re
  012ac	00 00 00 00	 DD	 $LN68@tf_swap_re
  012b0	00 00 00 00	 DD	 $LN69@tf_swap_re
  012b4	00 00 00 00	 DD	 $LN70@tf_swap_re
  012b8	00 00 00 00	 DD	 $LN71@tf_swap_re
  012bc	00 00 00 00	 DD	 $LN92@tf_swap_re
  012c0	00 00 00 00	 DD	 $LN72@tf_swap_re
  012c4	00 00 00 00	 DD	 $LN73@tf_swap_re
  012c8	00 00 00 00	 DD	 $LN74@tf_swap_re
  012cc	00 00 00 00	 DD	 $LN75@tf_swap_re
  012d0	00 00 00 00	 DD	 $LN92@tf_swap_re
  012d4	00 00 00 00	 DD	 $LN76@tf_swap_re
  012d8	00 00 00 00	 DD	 $LN77@tf_swap_re
  012dc	00 00 00 00	 DD	 $LN92@tf_swap_re
  012e0	00 00 00 00	 DD	 $LN92@tf_swap_re
  012e4	00 00 00 00	 DD	 $LN92@tf_swap_re
  012e8	00 00 00 00	 DD	 $LN92@tf_swap_re
  012ec	00 00 00 00	 DD	 $LN92@tf_swap_re
  012f0	00 00 00 00	 DD	 $LN92@tf_swap_re
  012f4	00 00 00 00	 DD	 $LN92@tf_swap_re
  012f8	00 00 00 00	 DD	 $LN78@tf_swap_re
  012fc	00 00 00 00	 DD	 $LN79@tf_swap_re
  01300	00 00 00 00	 DD	 $LN80@tf_swap_re
  01304	00 00 00 00	 DD	 $LN81@tf_swap_re
  01308	00 00 00 00	 DD	 $LN82@tf_swap_re
  0130c	00 00 00 00	 DD	 $LN83@tf_swap_re
  01310	00 00 00 00	 DD	 $LN92@tf_swap_re
  01314	00 00 00 00	 DD	 $LN84@tf_swap_re
$LN110@tf_swap_re:
  01318	00 00 00 00	 DD	 $LN86@tf_swap_re
  0131c	00 00 00 00	 DD	 $LN87@tf_swap_re
  01320	00 00 00 00	 DD	 $LN88@tf_swap_re
  01324	00 00 00 00	 DD	 $LN89@tf_swap_re
  01328	00 00 00 00	 DD	 $LN90@tf_swap_re
  0132c	00 00 00 00	 DD	 $LN91@tf_swap_re
  01330	00 00 00 00	 DD	 $LN92@tf_swap_re
$LN109@tf_swap_re:
  01334	00		 DB	 0
  01335	01		 DB	 1
  01336	02		 DB	 2
  01337	06		 DB	 6
  01338	06		 DB	 6
  01339	06		 DB	 6
  0133a	03		 DB	 3
  0133b	06		 DB	 6
  0133c	06		 DB	 6
  0133d	06		 DB	 6
  0133e	06		 DB	 6
  0133f	06		 DB	 6
  01340	06		 DB	 6
  01341	06		 DB	 6
  01342	06		 DB	 6
  01343	06		 DB	 6
  01344	06		 DB	 6
  01345	06		 DB	 6
  01346	06		 DB	 6
  01347	06		 DB	 6
  01348	06		 DB	 6
  01349	06		 DB	 6
  0134a	06		 DB	 6
  0134b	06		 DB	 6
  0134c	06		 DB	 6
  0134d	06		 DB	 6
  0134e	06		 DB	 6
  0134f	06		 DB	 6
  01350	06		 DB	 6
  01351	06		 DB	 6
  01352	06		 DB	 6
  01353	06		 DB	 6
  01354	06		 DB	 6
  01355	06		 DB	 6
  01356	06		 DB	 6
  01357	06		 DB	 6
  01358	06		 DB	 6
  01359	06		 DB	 6
  0135a	06		 DB	 6
  0135b	06		 DB	 6
  0135c	06		 DB	 6
  0135d	06		 DB	 6
  0135e	06		 DB	 6
  0135f	06		 DB	 6
  01360	06		 DB	 6
  01361	06		 DB	 6
  01362	06		 DB	 6
  01363	06		 DB	 6
  01364	06		 DB	 6
  01365	06		 DB	 6
  01366	06		 DB	 6
  01367	06		 DB	 6
  01368	06		 DB	 6
  01369	06		 DB	 6
  0136a	04		 DB	 4
  0136b	06		 DB	 6
  0136c	05		 DB	 5
tf_swap_rec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
hdr$ = 48
tf_swap_hdr PROC

; 4161 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4162 :     hdr->prev        = SWAP16( hdr->prev        );

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  0000e	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00011	e8 00 00 00 00	 call	 _byteswap_ushort
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  0001b	66 89 01	 mov	 WORD PTR [rcx], ax

; 4163 :     hdr->curr        = SWAP16( hdr->curr        );

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  00023	0f b7 48 02	 movzx	 ecx, WORD PTR [rax+2]
  00027	e8 00 00 00 00	 call	 _byteswap_ushort
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  00031	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 4164 :     hdr->cpuad       = SWAP16( hdr->cpuad       );

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  0003a	0f b7 48 04	 movzx	 ecx, WORD PTR [rax+4]
  0003e	e8 00 00 00 00	 call	 _byteswap_ushort
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  00048	66 89 41 04	 mov	 WORD PTR [rcx+4], ax

; 4165 :     hdr->msgnum      = SWAP16( hdr->msgnum      );

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  00051	0f b7 48 06	 movzx	 ecx, WORD PTR [rax+6]
  00055	e8 00 00 00 00	 call	 _byteswap_ushort
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  0005f	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 4166 :     hdr->devnum      = SWAP16( hdr->devnum      );

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  00068	0f b7 48 12	 movzx	 ecx, WORD PTR [rax+18]
  0006c	e8 00 00 00 00	 call	 _byteswap_ushort
  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  00076	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 4167 :     hdr->tod.tv_sec  = SWAP32( hdr->tod.tv_sec  );

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  0007f	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00082	e8 00 00 00 00	 call	 _byteswap_ulong
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  0008c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4168 :     hdr->tod.tv_usec = SWAP32( hdr->tod.tv_usec );

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR hdr$[rsp]
  00094	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00097	e8 00 00 00 00	 call	 _byteswap_ulong
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hdr$[rsp]
  000a1	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 4169 : }

  000a4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a8	c3		 ret	 0
tf_swap_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv68 = 32
sys$ = 64
tf_swap_sys PROC

; 4147 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4148 :     sys->bigend          = !sys->bigend;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  0000e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00012	85 c0		 test	 eax, eax
  00014	75 0a		 jne	 SHORT $LN3@tf_swap_sy
  00016	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0001e	eb 08		 jmp	 SHORT $LN4@tf_swap_sy
$LN3@tf_swap_sy:
  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@tf_swap_sy:
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  0002d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv68[rsp]
  00032	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 4149 :     sys->beg_tod.tv_sec  = SWAP32( sys->beg_tod.tv_sec  );

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0003d	e8 00 00 00 00	 call	 _byteswap_ulong
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  00047	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4150 :     sys->beg_tod.tv_usec = SWAP32( sys->beg_tod.tv_usec );

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  0004f	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00052	e8 00 00 00 00	 call	 _byteswap_ulong
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  0005c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4151 :     sys->end_tod.tv_sec  = SWAP32( sys->end_tod.tv_sec  );

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  00064	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00067	e8 00 00 00 00	 call	 _byteswap_ulong
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  00071	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4152 :     sys->end_tod.tv_usec = SWAP32( sys->end_tod.tv_usec );

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  00079	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0007c	e8 00 00 00 00	 call	 _byteswap_ulong
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  00086	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 4153 :     sys->tot_ins         = SWAP64( sys->tot_ins         );

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  0008e	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00092	e8 00 00 00 00	 call	 _byteswap_uint64
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  0009c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4154 :     sys->tot_dev         = SWAP64( sys->tot_dev         );

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  000a5	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a9	e8 00 00 00 00	 call	 _byteswap_uint64
  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys$[rsp]
  000b3	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4155 : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
tf_swap_sys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv79 = 32
tv81 = 36
sys$ = 64
tf_are_swaps_needed PROC

; 2517 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2518 :     return

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 4b		 jne	 SHORT $LN4@tf_are_swa
  0000f	33 c0		 xor	 eax, eax
  00011	83 f8 01	 cmp	 eax, 1
  00014	74 19		 je	 SHORT $LN3@tf_are_swa
  00016	e8 00 00 00 00	 call	 are_big_endian
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	74 0d		 je	 SHORT $LN3@tf_are_swa
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  00027	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0002b	85 c0		 test	 eax, eax
  0002d	74 2b		 je	 SHORT $LN4@tf_are_swa
$LN3@tf_are_swa:
  0002f	33 c0		 xor	 eax, eax
  00031	83 f8 01	 cmp	 eax, 1
  00034	74 1a		 je	 SHORT $LN5@tf_are_swa
  00036	e8 00 00 00 00	 call	 are_big_endian
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	75 0e		 jne	 SHORT $LN5@tf_are_swa
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR sys$[rsp]
  00047	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0004b	83 f8 01	 cmp	 eax, 1
  0004e	74 0a		 je	 SHORT $LN4@tf_are_swa
$LN5@tf_are_swa:
  00050	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
  00058	eb 08		 jmp	 SHORT $LN6@tf_are_swa
$LN4@tf_are_swa:
  0005a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
$LN6@tf_are_swa:
  00062	83 7c 24 20 00	 cmp	 DWORD PTR tv79[rsp], 0
  00067	75 0a		 jne	 SHORT $LN7@tf_are_swa
  00069	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
  00071	eb 08		 jmp	 SHORT $LN8@tf_are_swa
$LN7@tf_are_swa:
  00073	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
$LN8@tf_are_swa:
  0007b	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv81[rsp]

; 2519 :     (0
; 2520 :         || (1
; 2521 :             && are_big_endian()     // (we are big endian)
; 2522 :             && sys->bigend == 0     // (but file is little endian)
; 2523 :            )
; 2524 :         || (1
; 2525 :             && !are_big_endian()    // (we are little endian)
; 2526 :             && sys->bigend == 1     // (but file is big endian)
; 2527 :            )
; 2528 :     );
; 2529 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
tf_are_swaps_needed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
bWasActive$ = 32
cpu$1 = 36
dev$2 = 40
tv70 = 48
tv72 = 52
tv95 = 56
tv129 = 60
tv159 = 64
tv161 = 68
tf_autostop PROC

; 2833 : {

$LN22:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2834 :     bool bWasActive;
; 2835 : 
; 2836 :     /* Stop all tracing */
; 2837 :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160302
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2838 :     {
; 2839 :         DEVBLK* dev;
; 2840 :         int cpu;
; 2841 : 
; 2842 :         /* Stop overall instruction tracing */
; 2843 :         bWasActive = sysblk.insttrace ? true : false;

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00019	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0001f	c1 e8 08	 shr	 eax, 8
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@tf_autosto
  00029	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@tf_autosto
$LN10@tf_autosto:
  00033	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN11@tf_autosto:
  0003b	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00040	75 0a		 jne	 SHORT $LN12@tf_autosto
  00042	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN13@tf_autosto
$LN12@tf_autosto:
  0004c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
$LN13@tf_autosto:
  00054	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv72[rsp]
  00059	88 44 24 20	 mov	 BYTE PTR bWasActive$[rsp], al

; 2844 :         sysblk.insttrace = false;

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0006a	0f ba f0 08	 btr	 eax, 8
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00075	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 2845 : 
; 2846 :         /* Stop instruction tracing for all CPUs */
; 2847 :         for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0007b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR cpu$1[rsp], 0
  00083	eb 0a		 jmp	 SHORT $LN4@tf_autosto
$LN2@tf_autosto:
  00085	8b 44 24 24	 mov	 eax, DWORD PTR cpu$1[rsp]
  00089	ff c0		 inc	 eax
  0008b	89 44 24 24	 mov	 DWORD PTR cpu$1[rsp], eax
$LN4@tf_autosto:
  0008f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00096	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009c	39 44 24 24	 cmp	 DWORD PTR cpu$1[rsp], eax
  000a0	0f 8d b9 00 00
	00		 jge	 $LN3@tf_autosto

; 2848 :         {
; 2849 :             if (IS_CPU_ONLINE( cpu ))

  000a6	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$1[rsp]
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000bb	0f 84 99 00 00
	00		 je	 $LN8@tf_autosto

; 2850 :             {
; 2851 :                 bWasActive = bWasActive || sysblk.regs[ cpu ]->insttrace;

  000c1	0f b6 44 24 20	 movzx	 eax, BYTE PTR bWasActive$[rsp]
  000c6	85 c0		 test	 eax, eax
  000c8	75 2e		 jne	 SHORT $LN14@tf_autosto
  000ca	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$1[rsp]
  000cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000d6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000de	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e4	c1 e8 0f	 shr	 eax, 15
  000e7	83 e0 01	 and	 eax, 1
  000ea	85 c0		 test	 eax, eax
  000ec	75 0a		 jne	 SHORT $LN14@tf_autosto
  000ee	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
  000f6	eb 08		 jmp	 SHORT $LN15@tf_autosto
$LN14@tf_autosto:
  000f8	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
$LN15@tf_autosto:
  00100	83 7c 24 38 00	 cmp	 DWORD PTR tv95[rsp], 0
  00105	75 0a		 jne	 SHORT $LN16@tf_autosto
  00107	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  0010f	eb 08		 jmp	 SHORT $LN17@tf_autosto
$LN16@tf_autosto:
  00111	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
$LN17@tf_autosto:
  00119	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv129[rsp]
  0011e	88 44 24 20	 mov	 BYTE PTR bWasActive$[rsp], al

; 2852 :                 sysblk.regs[ cpu ]->insttrace = false;

  00122	48 63 44 24 24	 movsxd	 rax, DWORD PTR cpu$1[rsp]
  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00136	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0013c	0f ba f0 0f	 btr	 eax, 15
  00140	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR cpu$1[rsp]
  00145	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0014c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00154	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN8@tf_autosto:

; 2853 :             }
; 2854 :         }

  0015a	e9 26 ff ff ff	 jmp	 $LN2@tf_autosto
$LN3@tf_autosto:

; 2855 : 
; 2856 :         /* Stop ORB/CCW/KEY tracing for all devices */
; 2857 :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0015f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00166	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0016d	48 89 44 24 28	 mov	 QWORD PTR dev$2[rsp], rax
  00172	eb 0e		 jmp	 SHORT $LN7@tf_autosto
$LN5@tf_autosto:
  00174	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  00179	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0017d	48 89 44 24 28	 mov	 QWORD PTR dev$2[rsp], rax
$LN7@tf_autosto:
  00182	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$2[rsp], 0
  00188	0f 84 ce 00 00
	00		 je	 $LN6@tf_autosto

; 2858 :         {
; 2859 :             bWasActive = bWasActive || dev->ccwtrace || dev->orbtrace || dev->ckdkeytrace;

  0018e	0f b6 44 24 20	 movzx	 eax, BYTE PTR bWasActive$[rsp]
  00193	85 c0		 test	 eax, eax
  00195	75 49		 jne	 SHORT $LN18@tf_autosto
  00197	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  0019c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a2	c1 e8 0f	 shr	 eax, 15
  001a5	83 e0 01	 and	 eax, 1
  001a8	85 c0		 test	 eax, eax
  001aa	75 34		 jne	 SHORT $LN18@tf_autosto
  001ac	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  001b1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001b7	c1 e8 0e	 shr	 eax, 14
  001ba	83 e0 01	 and	 eax, 1
  001bd	85 c0		 test	 eax, eax
  001bf	75 1f		 jne	 SHORT $LN18@tf_autosto
  001c1	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  001c6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001cc	c1 e8 02	 shr	 eax, 2
  001cf	83 e0 01	 and	 eax, 1
  001d2	85 c0		 test	 eax, eax
  001d4	75 0a		 jne	 SHORT $LN18@tf_autosto
  001d6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  001de	eb 08		 jmp	 SHORT $LN19@tf_autosto
$LN18@tf_autosto:
  001e0	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
$LN19@tf_autosto:
  001e8	83 7c 24 40 00	 cmp	 DWORD PTR tv159[rsp], 0
  001ed	75 0a		 jne	 SHORT $LN20@tf_autosto
  001ef	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
  001f7	eb 08		 jmp	 SHORT $LN21@tf_autosto
$LN20@tf_autosto:
  001f9	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
$LN21@tf_autosto:
  00201	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv161[rsp]
  00206	88 44 24 20	 mov	 BYTE PTR bWasActive$[rsp], al

; 2860 :             dev->ccwtrace    = false;

  0020a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  0020f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00215	0f ba f0 0f	 btr	 eax, 15
  00219	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$2[rsp]
  0021e	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2861 :             dev->orbtrace    = false;

  00224	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  00229	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0022f	0f ba f0 0e	 btr	 eax, 14
  00233	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$2[rsp]
  00238	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2862 :             dev->ckdkeytrace = false;

  0023e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$2[rsp]
  00243	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00249	83 e0 fb	 and	 eax, -5			; fffffffbH
  0024c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$2[rsp]
  00251	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2863 :         }

  00257	e9 18 ff ff ff	 jmp	 $LN5@tf_autosto
$LN6@tf_autosto:

; 2864 :     }
; 2865 :     RELEASE_INTLOCK( NULL );

  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160304
  00263	33 c9		 xor	 ecx, ecx
  00265	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2866 : 
; 2867 :     return bWasActive;

  0026a	0f b6 44 24 20	 movzx	 eax, BYTE PTR bWasActive$[rsp]

; 2868 : }

  0026f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00273	c3		 ret	 0
tf_autostop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv72 = 80
tv93 = 88
tf_close_locked PROC

; 2684 : {

$LN16:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2685 :     /* Quick exit if already closed */
; 2686 :     if (!sysblk.traceFILE)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00013	75 05		 jne	 SHORT $LN8@tf_close_l

; 2687 :         return;

  00015	e9 c9 01 00 00	 jmp	 $LN1@tf_close_l
$LN8@tf_close_l:

; 2688 : 
; 2689 :     if (fseek( sysblk.traceFILE, 0, SEEK_SET ) != 0)

  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	33 d2		 xor	 edx, edx
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	48 8b 88 20 14
	00 00		 mov	 rcx, QWORD PTR [rax+5152]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00033	85 c0		 test	 eax, eax
  00035	74 73		 je	 SHORT $LN9@tf_close_l

; 2690 :     {
; 2691 :         // "Error in function %s: %s"
; 2692 :         WRMSG( HHC00075, "E", "fseek()", strerror( errno ));

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0003f	e8 00 00 00 00	 call	 w32_strerror
  00044	48 89 44 24 50	 mov	 QWORD PTR tv72[rsp], rax
  00049	b9 01 00 00 00	 mov	 ecx, 1
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv72[rsp]
  00059	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160198
  00065	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160199
  00071	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160200
  0007d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00082	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00087	41 b9 03 00 00
	00		 mov	 r9d, 3
  0008d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160201
  00094	ba 84 0a 00 00	 mov	 edx, 2692		; 00000a84H
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160202
  000a0	e8 00 00 00 00	 call	 fwritemsg

; 2693 :     }

  000a5	e9 9d 00 00 00	 jmp	 $LN10@tf_close_l
$LN9@tf_close_l:

; 2694 :     else if (fwrite( &tfsys, 1, tfsys_size, sysblk.traceFILE ) < tfsys_size)

  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b1	4c 8b 88 20 14
	00 00		 mov	 r9, QWORD PTR [rax+5152]
  000b8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR tfsys_size
  000bf	ba 01 00 00 00	 mov	 edx, 1
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tfsys
  000cb	e8 00 00 00 00	 call	 w32_fwrite
  000d0	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR tfsys_size
  000d7	73 6e		 jae	 SHORT $LN11@tf_close_l

; 2695 :     {
; 2696 :         // "Error in function %s: %s"
; 2697 :         WRMSG( HHC00075, "E", "fwrite()", strerror( errno ));

  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000df	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e1	e8 00 00 00 00	 call	 w32_strerror
  000e6	48 89 44 24 58	 mov	 QWORD PTR tv93[rsp], rax
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv93[rsp]
  000fb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160204
  00107	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160205
  00113	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160206
  0011f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00124	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00129	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160207
  00136	ba 89 0a 00 00	 mov	 edx, 2697		; 00000a89H
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160208
  00142	e8 00 00 00 00	 call	 fwritemsg
$LN11@tf_close_l:
$LN10@tf_close_l:
$LN4@tf_close_l:

; 2698 :     }
; 2699 : 
; 2700 :     /* Now close the file */
; 2701 :     VERIFY( 0 == fclose( sysblk.traceFILE ));

  00147	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014e	48 8b 88 20 14
	00 00		 mov	 rcx, QWORD PTR [rax+5152]
  00155	e8 00 00 00 00	 call	 w32_fclose
  0015a	85 c0		 test	 eax, eax
  0015c	74 5b		 je	 SHORT $LN12@tf_close_l
$LN7@tf_close_l:
  0015e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160210
  00165	41 b8 8d 0a 00
	00		 mov	 r8d, 2701		; 00000a8dH
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160211
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160212
  00179	e8 00 00 00 00	 call	 logmsg
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00184	85 c0		 test	 eax, eax
  00186	74 20		 je	 SHORT $LN13@tf_close_l
  00188	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160214
  0018f	41 b8 8d 0a 00
	00		 mov	 r8d, 2701		; 00000a8dH
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160215
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160216
  001a3	e8 00 00 00 00	 call	 DebuggerTrace
$LN13@tf_close_l:
  001a8	33 c0		 xor	 eax, eax
  001aa	85 c0		 test	 eax, eax
  001ac	75 b0		 jne	 SHORT $LN7@tf_close_l
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001b4	85 c0		 test	 eax, eax
  001b6	74 01		 je	 SHORT $LN14@tf_close_l
  001b8	cc		 int	 3
$LN14@tf_close_l:
$LN12@tf_close_l:
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	75 88		 jne	 SHORT $LN4@tf_close_l

; 2702 :     sysblk.traceFILE = NULL;

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c6	48 c7 80 20 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5152], 0

; 2703 :     sysblk.curtracesize = 0;

  001d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d8	48 c7 80 28 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5160], 0
$LN1@tf_close_l:

; 2704 : }

  001e3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001e7	c3		 ret	 0
tf_close_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
notused$ = 48
tf_close PROC

; 2707 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@tf_close:

; 2708 :     UNREFERENCED( notused );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@tf_close

; 2709 : 
; 2710 :     OBTAIN_TRACEFILE_LOCK();

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160224
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 hthread_obtain_lock

; 2711 :     {
; 2712 :         tf_close_locked();

  0002b	e8 00 00 00 00	 call	 tf_close_locked

; 2713 :     }
; 2714 :     RELEASE_TRACEFILE_LOCK();

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00037	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160225
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 hthread_release_lock

; 2715 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
tf_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
max_recsize$ = 0
tf_MAX_RECSIZE PROC

; 3908 : {

$LN76:
  00000	48 83 ec 18	 sub	 rsp, 24

; 3909 :     size_t
; 3910 :         max_recsize = sizeof( TFSYS );

  00004	48 c7 04 24 f0
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 240 ; 000000f0H

; 3911 : 
; 3912 :     // Device tracing
; 3913 : 
; 3914 :     if (max_recsize < sizeof( TF00423 ))

  0000c	48 81 3c 24 48
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 328 ; 00000148H
  00014	73 08		 jae	 SHORT $LN2@tf_MAX_REC

; 3915 :         max_recsize = sizeof( TF00423 );

  00016	48 c7 04 24 48
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 328 ; 00000148H
$LN2@tf_MAX_REC:

; 3916 : 
; 3917 :     if (max_recsize < sizeof( TF00424 ))

  0001e	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  00026	73 08		 jae	 SHORT $LN3@tf_MAX_REC

; 3918 :         max_recsize = sizeof( TF00424 );

  00028	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN3@tf_MAX_REC:

; 3919 : 
; 3920 :     if (max_recsize < sizeof( TF00425 ))

  00030	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  00038	73 08		 jae	 SHORT $LN4@tf_MAX_REC

; 3921 :         max_recsize = sizeof( TF00425 );

  0003a	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN4@tf_MAX_REC:

; 3922 : 
; 3923 :     if (max_recsize < sizeof( TF00426 ))

  00042	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0004a	73 08		 jae	 SHORT $LN5@tf_MAX_REC

; 3924 :         max_recsize = sizeof( TF00426 );

  0004c	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN5@tf_MAX_REC:

; 3925 : 
; 3926 :     if (max_recsize < sizeof( TF00427 ))

  00054	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0005c	73 08		 jae	 SHORT $LN6@tf_MAX_REC

; 3927 :         max_recsize = sizeof( TF00427 );

  0005e	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN6@tf_MAX_REC:

; 3928 : 
; 3929 :     if (max_recsize < sizeof( TF00428 ))

  00066	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0006e	73 08		 jae	 SHORT $LN7@tf_MAX_REC

; 3930 :         max_recsize = sizeof( TF00428 );

  00070	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN7@tf_MAX_REC:

; 3931 : 
; 3932 :     if (max_recsize < sizeof( TF00429 ))

  00078	48 81 3c 24 30
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
  00080	73 08		 jae	 SHORT $LN8@tf_MAX_REC

; 3933 :         max_recsize = sizeof( TF00429 );

  00082	48 c7 04 24 30
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
$LN8@tf_MAX_REC:

; 3934 : 
; 3935 :     if (max_recsize < sizeof( TF00430 ))

  0008a	48 81 3c 24 28
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
  00092	73 08		 jae	 SHORT $LN9@tf_MAX_REC

; 3936 :         max_recsize = sizeof( TF00430 );

  00094	48 c7 04 24 28
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
$LN9@tf_MAX_REC:

; 3937 : 
; 3938 :     if (max_recsize < sizeof( TF00431 ))

  0009c	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  000a4	73 08		 jae	 SHORT $LN10@tf_MAX_REC

; 3939 :         max_recsize = sizeof( TF00431 );

  000a6	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN10@tf_MAX_REC:

; 3940 : 
; 3941 :     if (max_recsize < sizeof( TF00432 ))

  000ae	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  000b6	73 08		 jae	 SHORT $LN11@tf_MAX_REC

; 3942 :         max_recsize = sizeof( TF00432 );

  000b8	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN11@tf_MAX_REC:

; 3943 : 
; 3944 :     if (max_recsize < sizeof( TF00433 ))

  000c0	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  000c8	73 08		 jae	 SHORT $LN12@tf_MAX_REC

; 3945 :         max_recsize = sizeof( TF00433 );

  000ca	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN12@tf_MAX_REC:

; 3946 : 
; 3947 :     if (max_recsize < sizeof( TF00434 ))

  000d2	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  000da	73 08		 jae	 SHORT $LN13@tf_MAX_REC

; 3948 :         max_recsize = sizeof( TF00434 );

  000dc	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN13@tf_MAX_REC:

; 3949 : 
; 3950 :     if (max_recsize < sizeof( TF00435 ))

  000e4	48 81 3c 24 30
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
  000ec	73 08		 jae	 SHORT $LN14@tf_MAX_REC

; 3951 :         max_recsize = sizeof( TF00435 );

  000ee	48 c7 04 24 30
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
$LN14@tf_MAX_REC:

; 3952 : 
; 3953 :     if (max_recsize < sizeof( TF00436 ))

  000f6	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  000fe	73 08		 jae	 SHORT $LN15@tf_MAX_REC

; 3954 :         max_recsize = sizeof( TF00436 );

  00100	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN15@tf_MAX_REC:

; 3955 : 
; 3956 :     if (max_recsize < sizeof( TF00437 ))

  00108	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  00110	73 08		 jae	 SHORT $LN16@tf_MAX_REC

; 3957 :         max_recsize = sizeof( TF00437 );

  00112	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN16@tf_MAX_REC:

; 3958 : 
; 3959 :     if (max_recsize < sizeof( TF00438 ))

  0011a	48 81 3c 24 28
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
  00122	73 08		 jae	 SHORT $LN17@tf_MAX_REC

; 3960 :         max_recsize = sizeof( TF00438 );

  00124	48 c7 04 24 28
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
$LN17@tf_MAX_REC:

; 3961 : 
; 3962 :     if (max_recsize < sizeof( TF00439 ))

  0012c	48 81 3c 24 28
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
  00134	73 08		 jae	 SHORT $LN18@tf_MAX_REC

; 3963 :         max_recsize = sizeof( TF00439 );

  00136	48 c7 04 24 28
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
$LN18@tf_MAX_REC:

; 3964 : 
; 3965 :     if (max_recsize < sizeof( TF00440 ))

  0013e	48 81 3c 24 30
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
  00146	73 08		 jae	 SHORT $LN19@tf_MAX_REC

; 3966 :         max_recsize = sizeof( TF00440 );

  00148	48 c7 04 24 30
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 304 ; 00000130H
$LN19@tf_MAX_REC:

; 3967 : 
; 3968 :     if (max_recsize < sizeof( TF00441 ))

  00150	48 81 3c 24 28
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
  00158	73 08		 jae	 SHORT $LN20@tf_MAX_REC

; 3969 :         max_recsize = sizeof( TF00441 );

  0015a	48 c7 04 24 28
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
$LN20@tf_MAX_REC:

; 3970 : 
; 3971 :     if (max_recsize < sizeof( TF00442 ))

  00162	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0016a	73 08		 jae	 SHORT $LN21@tf_MAX_REC

; 3972 :         max_recsize = sizeof( TF00442 );

  0016c	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN21@tf_MAX_REC:

; 3973 : 
; 3974 :     if (max_recsize < sizeof( TF00516 ))

  00174	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0017c	73 08		 jae	 SHORT $LN22@tf_MAX_REC

; 3975 :         max_recsize = sizeof( TF00516 );

  0017e	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN22@tf_MAX_REC:

; 3976 : 
; 3977 :     if (max_recsize < sizeof( TF00517 ))

  00186	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  0018e	73 08		 jae	 SHORT $LN23@tf_MAX_REC

; 3978 :         max_recsize = sizeof( TF00517 );

  00190	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN23@tf_MAX_REC:

; 3979 : 
; 3980 :     if (max_recsize < sizeof( TF00518 ))

  00198	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  001a0	73 08		 jae	 SHORT $LN24@tf_MAX_REC

; 3981 :         max_recsize = sizeof( TF00518 );

  001a2	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN24@tf_MAX_REC:

; 3982 : 
; 3983 :     if (max_recsize < sizeof( TF00519 ))

  001aa	48 81 3c 24 28
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
  001b2	73 08		 jae	 SHORT $LN25@tf_MAX_REC

; 3984 :         max_recsize = sizeof( TF00519 );

  001b4	48 c7 04 24 28
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 296 ; 00000128H
$LN25@tf_MAX_REC:

; 3985 : 
; 3986 :     if (max_recsize < sizeof( TF00520 ))

  001bc	48 81 3c 24 20
	01 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
  001c4	73 08		 jae	 SHORT $LN26@tf_MAX_REC

; 3987 :         max_recsize = sizeof( TF00520 );

  001c6	48 c7 04 24 20
	01 00 00	 mov	 QWORD PTR max_recsize$[rsp], 288 ; 00000120H
$LN26@tf_MAX_REC:

; 3988 : 
; 3989 :     // Instruction tracing
; 3990 : 
; 3991 :     if (max_recsize < sizeof( TF00800 ))

  001ce	48 83 3c 24 48	 cmp	 QWORD PTR max_recsize$[rsp], 72 ; 00000048H
  001d3	73 08		 jae	 SHORT $LN27@tf_MAX_REC

; 3992 :         max_recsize = sizeof( TF00800 );

  001d5	48 c7 04 24 48
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 72 ; 00000048H
$LN27@tf_MAX_REC:

; 3993 : 
; 3994 :     if (max_recsize < sizeof( TF00801 ))

  001dd	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  001e2	73 08		 jae	 SHORT $LN28@tf_MAX_REC

; 3995 :         max_recsize = sizeof( TF00801 );

  001e4	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN28@tf_MAX_REC:

; 3996 : 
; 3997 :     if (max_recsize < sizeof( TF00802 ))

  001ec	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  001f1	73 08		 jae	 SHORT $LN29@tf_MAX_REC

; 3998 :         max_recsize = sizeof( TF00802 );

  001f3	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN29@tf_MAX_REC:

; 3999 : 
; 4000 :     if (max_recsize < sizeof( TF00803 ))

  001fb	48 83 3c 24 40	 cmp	 QWORD PTR max_recsize$[rsp], 64 ; 00000040H
  00200	73 08		 jae	 SHORT $LN30@tf_MAX_REC

; 4001 :         max_recsize = sizeof( TF00803 );

  00202	48 c7 04 24 40
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 64 ; 00000040H
$LN30@tf_MAX_REC:

; 4002 : 
; 4003 :     if (max_recsize < sizeof( TF00804 ))

  0020a	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  0020f	73 08		 jae	 SHORT $LN31@tf_MAX_REC

; 4004 :         max_recsize = sizeof( TF00804 );

  00211	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN31@tf_MAX_REC:

; 4005 : 
; 4006 :     if (max_recsize < sizeof( TF00806 ))

  00219	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  0021e	73 08		 jae	 SHORT $LN32@tf_MAX_REC

; 4007 :         max_recsize = sizeof( TF00806 );

  00220	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN32@tf_MAX_REC:

; 4008 : 
; 4009 :     if (max_recsize < sizeof( TF00807 ))

  00228	48 83 3c 24 30	 cmp	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
  0022d	73 08		 jae	 SHORT $LN33@tf_MAX_REC

; 4010 :         max_recsize = sizeof( TF00807 );

  0022f	48 c7 04 24 30
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
$LN33@tf_MAX_REC:

; 4011 : 
; 4012 :     if (max_recsize < sizeof( TF00808 ))

  00237	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0023c	73 08		 jae	 SHORT $LN34@tf_MAX_REC

; 4013 :         max_recsize = sizeof( TF00808 );

  0023e	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN34@tf_MAX_REC:

; 4014 : 
; 4015 :     if (max_recsize < sizeof( TF00809 ))

  00246	48 83 3c 24 40	 cmp	 QWORD PTR max_recsize$[rsp], 64 ; 00000040H
  0024b	73 08		 jae	 SHORT $LN35@tf_MAX_REC

; 4016 :         max_recsize = sizeof( TF00809 );

  0024d	48 c7 04 24 40
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 64 ; 00000040H
$LN35@tf_MAX_REC:

; 4017 : 
; 4018 :     if (max_recsize < sizeof( TF00811 ))

  00255	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  0025a	73 08		 jae	 SHORT $LN36@tf_MAX_REC

; 4019 :         max_recsize = sizeof( TF00811 );

  0025c	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN36@tf_MAX_REC:

; 4020 : 
; 4021 :     if (max_recsize < sizeof( TF00812 ))

  00264	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  00269	73 08		 jae	 SHORT $LN37@tf_MAX_REC

; 4022 :         max_recsize = sizeof( TF00812 );

  0026b	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN37@tf_MAX_REC:

; 4023 : 
; 4024 :     if (max_recsize < sizeof( TF00814 ))

  00273	48 83 3c 24 30	 cmp	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
  00278	73 08		 jae	 SHORT $LN38@tf_MAX_REC

; 4025 :         max_recsize = sizeof( TF00814 );

  0027a	48 c7 04 24 30
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
$LN38@tf_MAX_REC:

; 4026 : 
; 4027 :     if (max_recsize < sizeof( TF00840 ))

  00282	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  00287	73 08		 jae	 SHORT $LN39@tf_MAX_REC

; 4028 :         max_recsize = sizeof( TF00840 );

  00289	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN39@tf_MAX_REC:

; 4029 : 
; 4030 :     if (max_recsize < sizeof( TF00844 ))

  00291	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  00296	73 08		 jae	 SHORT $LN40@tf_MAX_REC

; 4031 :         max_recsize = sizeof( TF00844 );

  00298	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN40@tf_MAX_REC:

; 4032 : 
; 4033 :     if (max_recsize < sizeof( TF00845 ))

  002a0	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  002a5	73 08		 jae	 SHORT $LN41@tf_MAX_REC

; 4034 :         max_recsize = sizeof( TF00845 );

  002a7	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN41@tf_MAX_REC:

; 4035 : 
; 4036 :     if (max_recsize < sizeof( TF00846 ))

  002af	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  002b4	73 08		 jae	 SHORT $LN42@tf_MAX_REC

; 4037 :         max_recsize = sizeof( TF00846 );

  002b6	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN42@tf_MAX_REC:

; 4038 : 
; 4039 :     // Device tracing
; 4040 : 
; 4041 :     if (max_recsize < sizeof( TF01300 ))

  002be	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  002c3	73 08		 jae	 SHORT $LN43@tf_MAX_REC

; 4042 :         max_recsize = sizeof( TF01300 );

  002c5	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN43@tf_MAX_REC:

; 4043 : 
; 4044 :     if (max_recsize < sizeof( TF01301 ))

  002cd	48 83 3c 24 38	 cmp	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
  002d2	73 08		 jae	 SHORT $LN44@tf_MAX_REC

; 4045 :         max_recsize = sizeof( TF01301 );

  002d4	48 c7 04 24 38
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
$LN44@tf_MAX_REC:

; 4046 : 
; 4047 :     if (max_recsize < sizeof( TF01304 ))

  002dc	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  002e1	73 08		 jae	 SHORT $LN45@tf_MAX_REC

; 4048 :         max_recsize = sizeof( TF01304 );

  002e3	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN45@tf_MAX_REC:

; 4049 : 
; 4050 :     if (max_recsize < sizeof( TF01305 ))

  002eb	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  002f0	73 08		 jae	 SHORT $LN46@tf_MAX_REC

; 4051 :         max_recsize = sizeof( TF01305 );

  002f2	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN46@tf_MAX_REC:

; 4052 : 
; 4053 :     if (max_recsize < sizeof( TF01306 ))

  002fa	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  002ff	73 08		 jae	 SHORT $LN47@tf_MAX_REC

; 4054 :         max_recsize = sizeof( TF01306 );

  00301	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN47@tf_MAX_REC:

; 4055 : 
; 4056 :     if (max_recsize < sizeof( TF01307 ))

  00309	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0030e	73 08		 jae	 SHORT $LN48@tf_MAX_REC

; 4057 :         max_recsize = sizeof( TF01307 );

  00310	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN48@tf_MAX_REC:

; 4058 : 
; 4059 :     if (max_recsize < sizeof( TF01308 ))

  00318	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0031d	73 08		 jae	 SHORT $LN49@tf_MAX_REC

; 4060 :         max_recsize = sizeof( TF01308 );

  0031f	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN49@tf_MAX_REC:

; 4061 : 
; 4062 :     if (max_recsize < sizeof( TF01309 ))

  00327	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0032c	73 08		 jae	 SHORT $LN50@tf_MAX_REC

; 4063 :         max_recsize = sizeof( TF01309 );

  0032e	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN50@tf_MAX_REC:

; 4064 : 
; 4065 :     if (max_recsize < sizeof( TF01310 ))

  00336	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0033b	73 08		 jae	 SHORT $LN51@tf_MAX_REC

; 4066 :         max_recsize = sizeof( TF01310 );

  0033d	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN51@tf_MAX_REC:

; 4067 : 
; 4068 :     if (max_recsize < sizeof( TF01311 ))

  00345	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  0034a	73 08		 jae	 SHORT $LN52@tf_MAX_REC

; 4069 :         max_recsize = sizeof( TF01311 );

  0034c	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN52@tf_MAX_REC:

; 4070 : 
; 4071 :     if (max_recsize < sizeof( TF01312 ))

  00354	48 83 3c 24 30	 cmp	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
  00359	73 08		 jae	 SHORT $LN53@tf_MAX_REC

; 4072 :         max_recsize = sizeof( TF01312 );

  0035b	48 c7 04 24 30
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 48 ; 00000030H
$LN53@tf_MAX_REC:

; 4073 : 
; 4074 :     if (max_recsize < sizeof( TF01313 ))

  00363	48 81 3c 24 b8
	00 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 184 ; 000000b8H
  0036b	73 08		 jae	 SHORT $LN54@tf_MAX_REC

; 4075 :         max_recsize = sizeof( TF01313 );

  0036d	48 c7 04 24 b8
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 184 ; 000000b8H
$LN54@tf_MAX_REC:

; 4076 : 
; 4077 :     if (max_recsize < sizeof( TF01315 ))

  00375	48 83 3c 24 38	 cmp	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
  0037a	73 08		 jae	 SHORT $LN55@tf_MAX_REC

; 4078 :         max_recsize = sizeof( TF01315 );

  0037c	48 c7 04 24 38
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
$LN55@tf_MAX_REC:

; 4079 : 
; 4080 :     if (max_recsize < sizeof( TF01316 ))

  00384	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  00389	73 08		 jae	 SHORT $LN56@tf_MAX_REC

; 4081 :         max_recsize = sizeof( TF01316 );

  0038b	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN56@tf_MAX_REC:

; 4082 : 
; 4083 :     if (max_recsize < sizeof( TF01317 ))

  00393	48 83 3c 24 28	 cmp	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
  00398	73 08		 jae	 SHORT $LN57@tf_MAX_REC

; 4084 :         max_recsize = sizeof( TF01317 );

  0039a	48 c7 04 24 28
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 40 ; 00000028H
$LN57@tf_MAX_REC:

; 4085 : 
; 4086 :     if (max_recsize < sizeof( TF01318 ))

  003a2	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  003a7	73 08		 jae	 SHORT $LN58@tf_MAX_REC

; 4087 :         max_recsize = sizeof( TF01318 );

  003a9	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN58@tf_MAX_REC:

; 4088 : 
; 4089 :     if (max_recsize < sizeof( TF01320 ))

  003b1	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  003b6	73 08		 jae	 SHORT $LN59@tf_MAX_REC

; 4090 :         max_recsize = sizeof( TF01320 );

  003b8	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN59@tf_MAX_REC:

; 4091 : 
; 4092 :     if (max_recsize < sizeof( TF01321 ))

  003c0	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  003c5	73 08		 jae	 SHORT $LN60@tf_MAX_REC

; 4093 :         max_recsize = sizeof( TF01321 );

  003c7	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN60@tf_MAX_REC:

; 4094 :     
; 4095 :     if (max_recsize < sizeof( TF01329 ))

  003cf	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  003d4	73 08		 jae	 SHORT $LN61@tf_MAX_REC

; 4096 :         max_recsize = sizeof( TF01329 );

  003d6	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN61@tf_MAX_REC:

; 4097 : 
; 4098 :     if (max_recsize < sizeof( TF01330 ))

  003de	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  003e3	73 08		 jae	 SHORT $LN62@tf_MAX_REC

; 4099 :         max_recsize = sizeof( TF01330 );

  003e5	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN62@tf_MAX_REC:

; 4100 : 
; 4101 :     if (max_recsize < sizeof( TF01331 ))

  003ed	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  003f2	73 08		 jae	 SHORT $LN63@tf_MAX_REC

; 4102 :         max_recsize = sizeof( TF01331 );

  003f4	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN63@tf_MAX_REC:

; 4103 : 
; 4104 :     if (max_recsize < sizeof( TF01332 ))

  003fc	48 83 3c 24 18	 cmp	 QWORD PTR max_recsize$[rsp], 24
  00401	73 08		 jae	 SHORT $LN64@tf_MAX_REC

; 4105 :         max_recsize = sizeof( TF01332 );

  00403	48 c7 04 24 18
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 24
$LN64@tf_MAX_REC:

; 4106 : 
; 4107 :     if (max_recsize < sizeof( TF01333 ))

  0040b	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  00410	73 08		 jae	 SHORT $LN65@tf_MAX_REC

; 4108 :         max_recsize = sizeof( TF01333 );

  00412	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN65@tf_MAX_REC:

; 4109 : 
; 4110 :     if (max_recsize < sizeof( TF01334 ))

  0041a	48 83 3c 24 38	 cmp	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
  0041f	73 08		 jae	 SHORT $LN66@tf_MAX_REC

; 4111 :         max_recsize = sizeof( TF01334 );

  00421	48 c7 04 24 38
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 56 ; 00000038H
$LN66@tf_MAX_REC:

; 4112 : 
; 4113 :     if (max_recsize < sizeof( TF01336 ))

  00429	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  0042e	73 08		 jae	 SHORT $LN67@tf_MAX_REC

; 4114 :         max_recsize = sizeof( TF01336 );

  00430	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN67@tf_MAX_REC:

; 4115 : 
; 4116 :     // Instruction tracing
; 4117 : 
; 4118 :     if (max_recsize < sizeof( TF02269 ))

  00438	48 81 3c 24 a0
	00 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 160 ; 000000a0H
  00440	73 08		 jae	 SHORT $LN68@tf_MAX_REC

; 4119 :         max_recsize = sizeof( TF02269 );

  00442	48 c7 04 24 a0
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 160 ; 000000a0H
$LN68@tf_MAX_REC:

; 4120 : 
; 4121 :     if (max_recsize < sizeof( TF02270 ))

  0044a	48 81 3c 24 a0
	00 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 160 ; 000000a0H
  00452	73 08		 jae	 SHORT $LN69@tf_MAX_REC

; 4122 :         max_recsize = sizeof( TF02270 );

  00454	48 c7 04 24 a0
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 160 ; 000000a0H
$LN69@tf_MAX_REC:

; 4123 : 
; 4124 :     if (max_recsize < sizeof( TF02271 ))

  0045c	48 81 3c 24 98
	00 00 00	 cmp	 QWORD PTR max_recsize$[rsp], 152 ; 00000098H
  00464	73 08		 jae	 SHORT $LN70@tf_MAX_REC

; 4125 :         max_recsize = sizeof( TF02271 );

  00466	48 c7 04 24 98
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 152 ; 00000098H
$LN70@tf_MAX_REC:

; 4126 : 
; 4127 :     if (max_recsize < sizeof( TF02272 ))

  0046e	48 83 3c 24 58	 cmp	 QWORD PTR max_recsize$[rsp], 88 ; 00000058H
  00473	73 08		 jae	 SHORT $LN71@tf_MAX_REC

; 4128 :         max_recsize = sizeof( TF02272 );

  00475	48 c7 04 24 58
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 88 ; 00000058H
$LN71@tf_MAX_REC:

; 4129 : 
; 4130 :     if (max_recsize < sizeof( TF02276 ))

  0047d	48 83 3c 24 20	 cmp	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
  00482	73 08		 jae	 SHORT $LN72@tf_MAX_REC

; 4131 :         max_recsize = sizeof( TF02276 );

  00484	48 c7 04 24 20
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 32 ; 00000020H
$LN72@tf_MAX_REC:

; 4132 : 
; 4133 :     if (max_recsize < sizeof( TF02324))

  0048c	48 83 3c 24 50	 cmp	 QWORD PTR max_recsize$[rsp], 80 ; 00000050H
  00491	73 08		 jae	 SHORT $LN73@tf_MAX_REC

; 4134 :         max_recsize = sizeof( TF02324 );

  00493	48 c7 04 24 50
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 80 ; 00000050H
$LN73@tf_MAX_REC:

; 4135 : 
; 4136 :     if (max_recsize < sizeof( TF02326))

  0049b	48 83 3c 24 70	 cmp	 QWORD PTR max_recsize$[rsp], 112 ; 00000070H
  004a0	73 08		 jae	 SHORT $LN74@tf_MAX_REC

; 4137 :         max_recsize = sizeof( TF02326 );

  004a2	48 c7 04 24 70
	00 00 00	 mov	 QWORD PTR max_recsize$[rsp], 112 ; 00000070H
$LN74@tf_MAX_REC:

; 4138 : 
; 4139 :     return

  004aa	48 8b 04 24	 mov	 rax, QWORD PTR max_recsize$[rsp]

; 4140 :         max_recsize;
; 4141 : }

  004ae	48 83 c4 18	 add	 rsp, 24
  004b2	c3		 ret	 0
tf_MAX_RECSIZE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv76 = 48
regs$ = 80
tf2326$ = 88
opcode1$ = 96
opcode2$ = 104
b1$ = 112
b2$ = 120
tf_2326	PROC

; 3892 : {

$LN6:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3893 :     if (tf2326->valid)

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  0001d	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00021	85 c0		 test	 eax, eax
  00023	0f 84 b9 00 00
	00		 je	 $LN2@tf_2326

; 3894 :     {
; 3895 :         tf2326->real_mode = REAL_MODE( &regs->psw );

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00032	83 e0 08	 and	 eax, 8
  00035	85 c0		 test	 eax, eax
  00037	74 1a		 je	 SHORT $LN4@tf_2326
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00042	83 e0 04	 and	 eax, 4
  00045	85 c0		 test	 eax, eax
  00047	74 0a		 je	 SHORT $LN4@tf_2326
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00051	eb 08		 jmp	 SHORT $LN5@tf_2326
$LN4@tf_2326:
  00053	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
$LN5@tf_2326:
  0005b	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  00060	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv76[rsp]
  00065	88 48 1a	 mov	 BYTE PTR [rax+26], cl

; 3896 :         tf2326->b1 = b1;

  00068	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  0006d	0f b7 4c 24 70	 movzx	 ecx, WORD PTR b1$[rsp]
  00072	66 89 48 1c	 mov	 WORD PTR [rax+28], cx

; 3897 :         tf2326->b2 = b2;

  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  0007b	0f b7 4c 24 78	 movzx	 ecx, WORD PTR b2$[rsp]
  00080	66 89 48 1e	 mov	 WORD PTR [rax+30], cx

; 3898 :         tf_2326_op( regs, &tf2326->op1, opcode1, opcode2, b1, false );

  00084	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  00089	48 83 c0 20	 add	 rax, 32			; 00000020H
  0008d	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00092	8b 4c 24 70	 mov	 ecx, DWORD PTR b1$[rsp]
  00096	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009a	44 0f b6 4c 24
	68		 movzx	 r9d, BYTE PTR opcode2$[rsp]
  000a0	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR opcode1$[rsp]
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	e8 00 00 00 00	 call	 tf_2326_op

; 3899 :         tf_2326_op( regs, &tf2326->op2, opcode1, opcode2, b2, true  );

  000b3	48 8b 44 24 58	 mov	 rax, QWORD PTR tf2326$[rsp]
  000b8	48 83 c0 48	 add	 rax, 72			; 00000048H
  000bc	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  000c1	8b 4c 24 78	 mov	 ecx, DWORD PTR b2$[rsp]
  000c5	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000c9	44 0f b6 4c 24
	68		 movzx	 r9d, BYTE PTR opcode2$[rsp]
  000cf	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR opcode1$[rsp]
  000d5	48 8b d0	 mov	 rdx, rax
  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 tf_2326_op
$LN2@tf_2326:

; 3900 :     }
; 3901 :     return tf_write( regs, tf2326, sizeof( TF02326 ), 2326 );

  000e2	66 41 b9 16 09	 mov	 r9w, 2326		; 00000916H
  000e7	66 41 b8 70 00	 mov	 r8w, 112		; 00000070H
  000ec	48 8b 54 24 58	 mov	 rdx, QWORD PTR tf2326$[rsp]
  000f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 tf_write

; 3902 : }

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
tf_2326	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv76 = 32
tv77 = 36
rec$ = 48
__$ArrayPad$ = 128
regs$ = 176
inst$ = 184
tf_2324	PROC

; 3800 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3801 :     TF02324 rec;
; 3802 :     rec.sie =

  00025	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00033	d1 e8		 shr	 eax, 1
  00035	83 e0 01	 and	 eax, 1
  00038	88 44 24 73	 mov	 BYTE PTR rec$[rsp+67], al

; 3803 : #if defined( _FEATURE_SIE )
; 3804 :         SIE_MODE( regs );
; 3805 : #else
; 3806 :         false;
; 3807 : #endif
; 3808 :     rec.ilc = ILC( inst[0] ); // (value in regs not always right)

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	48 6b c0 00	 imul	 rax, rax, 0
  00045	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00051	83 f8 40	 cmp	 eax, 64			; 00000040H
  00054	7d 0a		 jge	 SHORT $LN5@tf_2324
  00056	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv77[rsp], 2
  0005e	eb 36		 jmp	 SHORT $LN6@tf_2324
$LN5@tf_2324:
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	48 6b c0 00	 imul	 rax, rax, 0
  00069	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00071	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00075	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0007a	7d 0a		 jge	 SHORT $LN3@tf_2324
  0007c	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv76[rsp], 4
  00084	eb 08		 jmp	 SHORT $LN4@tf_2324
$LN3@tf_2324:
  00086	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv76[rsp], 6
$LN4@tf_2324:
  0008e	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]
  00092	89 44 24 24	 mov	 DWORD PTR tv77[rsp], eax
$LN6@tf_2324:
  00096	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv77[rsp]
  0009b	88 44 24 74	 mov	 BYTE PTR rec$[rsp+68], al

; 3809 :     memcpy( &rec.psw,  &regs->psw, sizeof( rec.psw ));

  0009f	48 8d 44 24 48	 lea	 rax, QWORD PTR rec$[rsp+24]
  000a4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  000b3	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000b8	f3 a4		 rep movsb

; 3810 :     memcpy( rec.inst, inst, rec.ilc );

  000ba	0f b6 44 24 74	 movzx	 eax, BYTE PTR rec$[rsp+68]
  000bf	48 8d 4c 24 78	 lea	 rcx, QWORD PTR rec$[rsp+72]
  000c4	48 8b f9	 mov	 rdi, rcx
  000c7	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR inst$[rsp]
  000cf	8b c8		 mov	 ecx, eax
  000d1	f3 a4		 rep movsb

; 3811 :     rec.amode64 = rec.psw.amode64;

  000d3	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000d7	83 e0 01	 and	 eax, 1
  000da	88 44 24 70	 mov	 BYTE PTR rec$[rsp+64], al

; 3812 :     rec.amode   = rec.psw.amode;

  000de	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000e2	d1 e8		 shr	 eax, 1
  000e4	83 e0 01	 and	 eax, 1
  000e7	88 44 24 71	 mov	 BYTE PTR rec$[rsp+65], al

; 3813 :     rec.zeroilc = rec.psw.zeroilc;

  000eb	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000ef	c1 e8 02	 shr	 eax, 2
  000f2	83 e0 01	 and	 eax, 1
  000f5	88 44 24 72	 mov	 BYTE PTR rec$[rsp+66], al

; 3814 :     return tf_write( regs, &rec, sizeof( TF02324 ), 2324 );

  000f9	66 41 b9 14 09	 mov	 r9w, 2324		; 00000914H
  000fe	66 41 b8 50 00	 mov	 r8w, 80			; 00000050H
  00103	48 8d 54 24 30	 lea	 rdx, QWORD PTR rec$[rsp]
  00108	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	e8 00 00 00 00	 call	 tf_write

; 3815 : }

  00115	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011d	48 33 cc	 xor	 rcx, rsp
  00120	e8 00 00 00 00	 call	 __security_check_cookie
  00125	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0012c	5f		 pop	 rdi
  0012d	5e		 pop	 rsi
  0012e	c3		 ret	 0
tf_2324	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 576
regs$ = 624
tf_2277	PROC

; 3790 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3791 :     TF02277 rec;
; 3792 :     memcpy(rec.vr, regs->vr, sizeof(rec.vr));

  00020	48 8d 44 24 38	 lea	 rax, QWORD PTR rec$[rsp+24]
  00025	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	48 8d b1 c4 03
	00 00		 lea	 rsi, QWORD PTR [rcx+964]
  00037	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0003c	f3 a4		 rep movsb

; 3793 :     return tf_write(regs, &rec, sizeof(TF02277), 2277);

  0003e	66 41 b9 e5 08	 mov	 r9w, 2277		; 000008e5H
  00043	66 41 b8 18 02	 mov	 r8w, 536		; 00000218H
  00048	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0004d	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00055	e8 00 00 00 00	 call	 tf_write

; 3794 : }

  0005a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00071	5f		 pop	 rdi
  00072	5e		 pop	 rsi
  00073	c3		 ret	 0
tf_2277	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv71 = 32
rec$ = 40
__$ArrayPad$ = 72
regs$ = 96
tf_2276	PROC

; 3779 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3780 :     TF02276 rec;
; 3781 :     rec.fpc = regs->fpc;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00023	89 44 24 40	 mov	 DWORD PTR rec$[rsp+24], eax

; 3782 :     rec.afp = (regs->CR(0) & CR0_AFP) ? true : false;

  00027	b8 08 00 00 00	 mov	 eax, 8
  0002c	48 6b c0 01	 imul	 rax, rax, 1
  00030	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00035	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0003c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00041	85 c0		 test	 eax, eax
  00043	74 0a		 je	 SHORT $LN3@tf_2276
  00045	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN4@tf_2276
$LN3@tf_2276:
  0004f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN4@tf_2276:
  00057	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv71[rsp]
  0005c	88 44 24 44	 mov	 BYTE PTR rec$[rsp+28], al

; 3783 :     return tf_write( regs, &rec, sizeof( TF02276 ), 2276 );

  00060	66 41 b9 e4 08	 mov	 r9w, 2276		; 000008e4H
  00065	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  0006a	48 8d 54 24 28	 lea	 rdx, QWORD PTR rec$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	e8 00 00 00 00	 call	 tf_write

; 3784 : }

  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0008a	c3		 ret	 0
tf_2276	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 128
regs$ = 176
tf_2272	PROC

; 3769 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3770 :     TF02272 rec;
; 3771 :     memcpy( rec.ar, regs->ar, sizeof( rec.ar ));

  00020	48 8d 44 24 38	 lea	 rax, QWORD PTR rec$[rsp+24]
  00025	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  00037	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0003c	f3 a4		 rep movsb

; 3772 :     return tf_write( regs, &rec, sizeof( TF02272 ), 2272 );

  0003e	66 41 b9 e0 08	 mov	 r9w, 2272		; 000008e0H
  00043	66 41 b8 58 00	 mov	 r8w, 88			; 00000058H
  00048	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0004d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00055	e8 00 00 00 00	 call	 tf_write

; 3773 : }

  0005a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00071	5f		 pop	 rdi
  00072	5e		 pop	 rsi
  00073	c3		 ret	 0
tf_2272	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 192
regs$ = 240
tf_2271	PROC

; 3759 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3760 :     TF02271 rec;
; 3761 :     memcpy( rec.cr, &regs->cr_struct[1], sizeof( rec.cr ));

  00020	b8 08 00 00 00	 mov	 eax, 8
  00025	48 6b c0 01	 imul	 rax, rax, 1
  00029	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rec$[rsp+24]
  0002e	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00036	48 8b f9	 mov	 rdi, rcx
  00039	48 8d b4 02 00
	06 00 00	 lea	 rsi, QWORD PTR [rdx+rax+1536]
  00041	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00046	f3 a4		 rep movsb

; 3762 :     return tf_write( regs, &rec, sizeof( TF02271 ), 2271 );

  00048	66 41 b9 df 08	 mov	 r9w, 2271		; 000008dfH
  0004d	66 41 b8 98 00	 mov	 r8w, 152		; 00000098H
  00052	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00057	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	e8 00 00 00 00	 call	 tf_write

; 3763 : }

  00064	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0007b	5f		 pop	 rdi
  0007c	5e		 pop	 rsi
  0007d	c3		 ret	 0
tf_2271	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv78 = 32
rec$ = 48
__$ArrayPad$ = 208
regs$ = 256
tf_2270	PROC

; 3748 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3749 :     TF02270 rec;
; 3750 :     memcpy( rec.fpr, regs->fpr, sizeof( rec.fpr ));

  00020	48 8d 44 24 48	 lea	 rax, QWORD PTR rec$[rsp+24]
  00025	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	48 8d b1 40 03
	00 00		 lea	 rsi, QWORD PTR [rcx+832]
  00037	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0003c	f3 a4		 rep movsb

; 3751 :     rec.afp = (regs->CR(0) & CR0_AFP) ? true : false;

  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	48 6b c0 01	 imul	 rax, rax, 1
  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00056	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $LN3@tf_2270
  0005f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00067	eb 08		 jmp	 SHORT $LN4@tf_2270
$LN3@tf_2270:
  00069	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN4@tf_2270:
  00071	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv78[rsp]
  00076	88 84 24 c8 00
	00 00		 mov	 BYTE PTR rec$[rsp+152], al

; 3752 :     return tf_write( regs, &rec, sizeof( TF02270 ), 2270 );

  0007d	66 41 b9 de 08	 mov	 r9w, 2270		; 000008deH
  00082	66 41 b8 a0 00	 mov	 r8w, 160		; 000000a0H
  00087	48 8d 54 24 30	 lea	 rdx, QWORD PTR rec$[rsp]
  0008c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	e8 00 00 00 00	 call	 tf_write

; 3753 : }

  00099	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a1	48 33 cc	 xor	 rcx, rsp
  000a4	e8 00 00 00 00	 call	 __security_check_cookie
  000a9	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  000b0	5f		 pop	 rdi
  000b1	5e		 pop	 rsi
  000b2	c3		 ret	 0
tf_2270	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv73 = 32
rec$ = 48
__$ArrayPad$ = 208
regs$ = 256
inst$ = 264
tf_2269	PROC

; 3731 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3732 :     TF02269 rec;
; 3733 :     memcpy( rec.gr, regs->gr, sizeof( rec.gr ));

  00025	48 8d 44 24 50	 lea	 rax, QWORD PTR rec$[rsp+32]
  0002a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	48 8b f8	 mov	 rdi, rax
  00035	48 8d b1 80 02
	00 00		 lea	 rsi, QWORD PTR [rcx+640]
  0003c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00041	f3 a4		 rep movsb

; 3734 :     rec.ifetch_error = inst ? false : true;

  00043	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR inst$[rsp], 0
  0004c	74 0a		 je	 SHORT $LN3@tf_2269
  0004e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00056	eb 08		 jmp	 SHORT $LN4@tf_2269
$LN3@tf_2269:
  00058	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN4@tf_2269:
  00060	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv73[rsp]
  00065	88 44 24 48	 mov	 BYTE PTR rec$[rsp+24], al

; 3735 :     rec.sie =

  00069	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00071	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00077	d1 e8		 shr	 eax, 1
  00079	83 e0 01	 and	 eax, 1
  0007c	88 44 24 49	 mov	 BYTE PTR rec$[rsp+25], al

; 3736 : #if defined( _FEATURE_SIE )
; 3737 :         SIE_MODE( regs );
; 3738 : #else
; 3739 :         false;
; 3740 : #endif
; 3741 :     return tf_write( regs, &rec, sizeof( TF02269 ), 2269 );

  00080	66 41 b9 dd 08	 mov	 r9w, 2269		; 000008ddH
  00085	66 41 b8 a0 00	 mov	 r8w, 160		; 000000a0H
  0008a	48 8d 54 24 30	 lea	 rdx, QWORD PTR rec$[rsp]
  0008f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	e8 00 00 00 00	 call	 tf_write

; 3742 : }

  0009c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a4	48 33 cc	 xor	 rcx, rsp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  000b3	5f		 pop	 rdi
  000b4	5e		 pop	 rsi
  000b5	c3		 ret	 0
tf_2269	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
dev$ = 96
tf_1336	PROC

; 3718 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3719 :     TF01336 rec;
; 3720 :     rec.rhdr.devnum  = dev->devnum;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3721 :     rec.rhdr.lcss    = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3722 :     rec.busy         = dev->busy;

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00040	c1 e8 13	 shr	 eax, 19
  00043	83 e0 01	 and	 eax, 1
  00046	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3723 :     rec.startpending = dev->startpending;

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0004f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00055	c1 e8 19	 shr	 eax, 25
  00058	83 e0 01	 and	 eax, 1
  0005b	88 44 24 39	 mov	 BYTE PTR rec$[rsp+25], al

; 3724 :     return tf_write( NULL, &rec, sizeof( TF01336 ), 1336 );

  0005f	66 41 b9 38 05	 mov	 r9w, 1336		; 00000538H
  00064	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  00069	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0006e	33 c9		 xor	 ecx, ecx
  00070	e8 00 00 00 00	 call	 tf_write

; 3725 : }

  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007a	48 33 cc	 xor	 rcx, rsp
  0007d	e8 00 00 00 00	 call	 __security_check_cookie
  00082	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00086	c3		 ret	 0
tf_1336	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 88
dev$ = 128
orb$ = 136
tf_1334	PROC

; 3706 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3707 :     TF01334 rec;
; 3708 :     rec.rhdr.devnum = dev->devnum;

  0001f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00027	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002b	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3709 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00030	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003c	d1 f8		 sar	 eax, 1
  0003e	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3710 :     memcpy( &rec.orb, orb, sizeof( rec.orb ));

  00042	48 8d 44 24 38	 lea	 rax, QWORD PTR rec$[rsp+24]
  00047	48 8b f8	 mov	 rdi, rax
  0004a	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  00052	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00057	f3 a4		 rep movsb

; 3711 :     return tf_write( NULL, &rec, sizeof( TF01334 ), 1334 );

  00059	66 41 b9 36 05	 mov	 r9w, 1334		; 00000536H
  0005e	66 41 b8 38 00	 mov	 r8w, 56			; 00000038H
  00063	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00068	33 c9		 xor	 ecx, ecx
  0006a	e8 00 00 00 00	 call	 tf_write

; 3712 : }

  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00074	48 33 cc	 xor	 rcx, rsp
  00077	e8 00 00 00 00	 call	 __security_check_cookie
  0007c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00080	5f		 pop	 rdi
  00081	5e		 pop	 rsi
  00082	c3		 ret	 0
tf_1334	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
dev$ = 96
cc$ = 104
tf_1333	PROC

; 3694 : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3695 :     TF01333 rec;
; 3696 :     rec.cc     = cc;

  0001c	0f b6 44 24 68	 movzx	 eax, BYTE PTR cc$[rsp]
  00021	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3697 :     rec.rhdr.devnum = dev->devnum;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3698 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003c	d1 f8		 sar	 eax, 1
  0003e	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3699 :     return tf_write( NULL, &rec, sizeof( TF01333 ), 1333 );

  00042	66 41 b9 35 05	 mov	 r9w, 1333		; 00000535H
  00047	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  0004c	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00051	33 c9		 xor	 ecx, ecx
  00053	e8 00 00 00 00	 call	 tf_write

; 3700 : }

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005d	48 33 cc	 xor	 rcx, rsp
  00060	e8 00 00 00 00	 call	 __security_check_cookie
  00065	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00069	c3		 ret	 0
tf_1333	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1332	PROC

; 3683 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3684 :     TF01332 rec;
; 3685 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3686 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3687 :     return tf_write( NULL, &rec, sizeof( TF01332 ), 1332 );

  00035	66 41 b9 34 05	 mov	 r9w, 1332		; 00000534H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3688 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1332	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1331	PROC

; 3672 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3673 :     TF01331 rec;
; 3674 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3675 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3676 :     return tf_write( NULL, &rec, sizeof( TF01331 ), 1331 );

  00035	66 41 b9 33 05	 mov	 r9w, 1331		; 00000533H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3677 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1331	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1330	PROC

; 3661 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3662 :     TF01330 rec;
; 3663 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3664 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3665 :     return tf_write( NULL, &rec, sizeof( TF01330 ), 1330 );

  00035	66 41 b9 32 05	 mov	 r9w, 1330		; 00000532H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3666 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1330	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1329	PROC

; 3650 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3651 :     TF01329 rec;
; 3652 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3653 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3654 :     return tf_write( NULL, &rec, sizeof( TF01329 ), 1329 );

  00035	66 41 b9 31 05	 mov	 r9w, 1329		; 00000531H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3655 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1329	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1321	PROC

; 3639 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3640 :     TF01321 rec;
; 3641 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3642 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3643 :     return tf_write( NULL, &rec, sizeof( TF01321 ), 1321 );

  00035	66 41 b9 29 05	 mov	 r9w, 1321		; 00000529H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3644 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1321	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1320	PROC

; 3628 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3629 :     TF01320 rec;
; 3630 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3631 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3632 :     return tf_write( NULL, &rec, sizeof( TF01320 ), 1320 );

  00035	66 41 b9 28 05	 mov	 r9w, 1320		; 00000528H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3633 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1320	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
dev$ = 96
cc$ = 104
tf_1318	PROC

; 3616 : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3617 :     TF01318 rec;
; 3618 :     rec.cc     = cc;

  0001c	0f b6 44 24 68	 movzx	 eax, BYTE PTR cc$[rsp]
  00021	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3619 :     rec.rhdr.devnum = dev->devnum;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3620 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003c	d1 f8		 sar	 eax, 1
  0003e	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3621 :     return tf_write( NULL, &rec, sizeof( TF01318 ), 1318 );

  00042	66 41 b9 26 05	 mov	 r9w, 1318		; 00000526H
  00047	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  0004c	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00051	33 c9		 xor	 ecx, ecx
  00053	e8 00 00 00 00	 call	 tf_write

; 3622 : }

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005d	48 33 cc	 xor	 rcx, rsp
  00060	e8 00 00 00 00	 call	 __security_check_cookie
  00065	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00069	c3		 ret	 0
tf_1318	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
dev$ = 112
scsw$ = 120
tf_1317	PROC

; 3604 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3605 :     TF01317 rec;
; 3606 :     rec.rhdr.devnum = dev->devnum;

  0001f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00024	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00028	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3607 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00032	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00036	d1 f8		 sar	 eax, 1
  00038	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3608 :     memcpy( &rec.scsw, &scsw, sizeof( rec.scsw ));

  0003c	48 8d 44 24 38	 lea	 rax, QWORD PTR rec$[rsp+24]
  00041	48 8b f8	 mov	 rdi, rax
  00044	48 8b 74 24 78	 mov	 rsi, QWORD PTR scsw$[rsp]
  00049	b9 0c 00 00 00	 mov	 ecx, 12
  0004e	f3 a4		 rep movsb

; 3609 :     return tf_write( NULL, &rec, sizeof( TF01317 ), 1317 );

  00050	66 41 b9 25 05	 mov	 r9w, 1317		; 00000525H
  00055	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  0005a	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0005f	33 c9		 xor	 ecx, ecx
  00061	e8 00 00 00 00	 call	 tf_write

; 3610 : }

  00066	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006b	48 33 cc	 xor	 rcx, rsp
  0006e	e8 00 00 00 00	 call	 __security_check_cookie
  00073	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00077	5f		 pop	 rdi
  00078	5e		 pop	 rsi
  00079	c3		 ret	 0
tf_1317	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
dev$ = 96
csw$ = 104
tf_1316	PROC

; 3592 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3593 :     TF01316 rec;
; 3594 :     rec.rhdr.devnum = dev->devnum;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00022	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00026	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3595 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00030	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00034	d1 f8		 sar	 eax, 1
  00036	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3596 :     memcpy( rec.csw, csw, sizeof( rec.csw ));

  0003a	48 8b 44 24 68	 mov	 rax, QWORD PTR csw$[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3597 :     return tf_write( NULL, &rec, sizeof( TF01316 ), 1316 );

  00047	66 41 b9 24 05	 mov	 r9w, 1316		; 00000524H
  0004c	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  00051	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00056	33 c9		 xor	 ecx, ecx
  00058	e8 00 00 00 00	 call	 tf_write

; 3598 : }

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006e	c3		 ret	 0
tf_1316	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 88
dev$ = 128
ccw$ = 136
addr$ = 144
count$ = 152
data$ = 160
amt$ = 168
tf_1315	PROC

; 3576 : {

$LN3:
  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3577 :     TF01315 rec;
; 3578 :     rec.rhdr.devnum = dev->devnum;

  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00036	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3579 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0003b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00047	d1 f8		 sar	 eax, 1
  00049	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3580 :     rec.amt   = amt;

  0004d	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  00055	88 44 24 3e	 mov	 BYTE PTR rec$[rsp+30], al

; 3581 :     rec.addr  = addr;

  00059	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00060	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3582 :     rec.count = count;

  00064	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR count$[rsp]
  0006c	66 89 44 24 3c	 mov	 WORD PTR rec$[rsp+28], ax

; 3583 :     memcpy( rec.ccw,  ccw,  sizeof( rec.ccw ));

  00071	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ccw$[rsp]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp+32], rax

; 3584 :     memcpy( rec.data, data, amt );

  00081	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  00089	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  0008e	48 8b f9	 mov	 rdi, rcx
  00091	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR data$[rsp]
  00099	8b c8		 mov	 ecx, eax
  0009b	f3 a4		 rep movsb

; 3585 :     return tf_write( NULL, &rec, sizeof( TF01315 ), 1315 );

  0009d	66 41 b9 23 05	 mov	 r9w, 1315		; 00000523H
  000a2	66 41 b8 38 00	 mov	 r8w, 56			; 00000038H
  000a7	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000ac	33 c9		 xor	 ecx, ecx
  000ae	e8 00 00 00 00	 call	 tf_write

; 3586 : }

  000b3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b8	48 33 cc	 xor	 rcx, rsp
  000bb	e8 00 00 00 00	 call	 __security_check_cookie
  000c0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000c4	5f		 pop	 rdi
  000c5	5e		 pop	 rsi
  000c6	c3		 ret	 0
tf_1315	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 224
dev$ = 272
tf_1313	PROC

; 3559 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3560 :     TF01313 rec;
; 3561 :     rec.rhdr.devnum = dev->devnum;

  00020	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002c	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3562 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00031	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00039	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003d	d1 f8		 sar	 eax, 1
  0003f	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3563 :     memcpy( rec.sense, dev->sense, sizeof( rec.sense ));

  00043	48 8d 44 24 38	 lea	 rax, QWORD PTR rec$[rsp+24]
  00048	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	48 8b f8	 mov	 rdi, rax
  00053	48 8d b1 64 03
	00 00		 lea	 rsi, QWORD PTR [rcx+868]
  0005a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005f	f3 a4		 rep movsb

; 3564 :     if (dev->sns)

  00061	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 83 b8 c0 02
	00 00 00	 cmp	 QWORD PTR [rax+704], 0
  00071	74 23		 je	 SHORT $LN2@tf_1313

; 3565 :         dev->sns( dev, rec.sns, sizeof( rec.sns ));

  00073	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00079	48 8d 54 24 58	 lea	 rdx, QWORD PTR rec$[rsp+56]
  0007e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	ff 90 c0 02 00
	00		 call	 QWORD PTR [rax+704]
  00094	eb 0e		 jmp	 SHORT $LN3@tf_1313
$LN2@tf_1313:

; 3566 :     else
; 3567 :         rec.sns[0] = 0;

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	48 6b c0 00	 imul	 rax, rax, 0
  0009f	c6 44 04 58 00	 mov	 BYTE PTR rec$[rsp+rax+56], 0
$LN3@tf_1313:

; 3568 :     return tf_write( NULL, &rec, sizeof( TF01313 ), 1313 );

  000a4	66 41 b9 21 05	 mov	 r9w, 1313		; 00000521H
  000a9	66 41 b8 b8 00	 mov	 r8w, 184		; 000000b8H
  000ae	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000b3	33 c9		 xor	 ecx, ecx
  000b5	e8 00 00 00 00	 call	 tf_write

; 3569 : }

  000ba	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c2	48 33 cc	 xor	 rcx, rsp
  000c5	e8 00 00 00 00	 call	 __security_check_cookie
  000ca	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  000d1	5f		 pop	 rdi
  000d2	5e		 pop	 rsi
  000d3	c3		 ret	 0
tf_1313	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 80
dev$ = 128
us$ = 136
cs$ = 144
amt$ = 152
resid$ = 160
data$ = 168
tf_1312	PROC

; 3543 : {

$LN3:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3544 :     TF01312 rec;
; 3545 :     rec.rhdr.devnum = dev->devnum;

  00028	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00030	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00034	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3546 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00045	d1 f8		 sar	 eax, 1
  00047	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3547 :     rec.unitstat = us;

  0004b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR us$[rsp]
  00053	88 44 24 3c	 mov	 BYTE PTR rec$[rsp+28], al

; 3548 :     rec.chanstat = cs;

  00057	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR cs$[rsp]
  0005f	88 44 24 3d	 mov	 BYTE PTR rec$[rsp+29], al

; 3549 :     rec.amt      = amt;

  00063	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  0006b	88 44 24 3e	 mov	 BYTE PTR rec$[rsp+30], al

; 3550 :     rec.residual = resid;

  0006f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR resid$[rsp]
  00076	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3551 :     memcpy( rec.data, data, amt );

  0007a	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  00082	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00087	48 8b f9	 mov	 rdi, rcx
  0008a	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR data$[rsp]
  00092	8b c8		 mov	 ecx, eax
  00094	f3 a4		 rep movsb

; 3552 :     return tf_write( NULL, &rec, sizeof( TF01312 ), 1312 );

  00096	66 41 b9 20 05	 mov	 r9w, 1312		; 00000520H
  0009b	66 41 b8 30 00	 mov	 r8w, 48			; 00000030H
  000a0	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000a5	33 c9		 xor	 ecx, ecx
  000a7	e8 00 00 00 00	 call	 tf_write

; 3553 : }

  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b1	48 33 cc	 xor	 rcx, rsp
  000b4	e8 00 00 00 00	 call	 __security_check_cookie
  000b9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000bd	5f		 pop	 rdi
  000be	5e		 pop	 rsi
  000bf	c3		 ret	 0
tf_1312	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1311	PROC

; 3532 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3533 :     TF01311 rec;
; 3534 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3535 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3536 :     return tf_write( NULL, &rec, sizeof( TF01311 ), 1311 );

  00035	66 41 b9 1f 05	 mov	 r9w, 1311		; 0000051fH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3537 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1311	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1310	PROC

; 3521 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3522 :     TF01310 rec;
; 3523 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3524 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3525 :     return tf_write( NULL, &rec, sizeof( TF01310 ), 1310 );

  00035	66 41 b9 1e 05	 mov	 r9w, 1310		; 0000051eH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3526 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1310	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1309	PROC

; 3510 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3511 :     TF01309 rec;
; 3512 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3513 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3514 :     return tf_write( NULL, &rec, sizeof( TF01309 ), 1309 );

  00035	66 41 b9 1d 05	 mov	 r9w, 1309		; 0000051dH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3515 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1309	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1308	PROC

; 3499 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3500 :     TF01308 rec;
; 3501 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3502 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3503 :     return tf_write( NULL, &rec, sizeof( TF01308 ), 1308 );

  00035	66 41 b9 1c 05	 mov	 r9w, 1308		; 0000051cH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3504 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1308	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1307	PROC

; 3488 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3489 :     TF01307 rec;
; 3490 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3491 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3492 :     return tf_write( NULL, &rec, sizeof( TF01307 ), 1307 );

  00035	66 41 b9 1b 05	 mov	 r9w, 1307		; 0000051bH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3493 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1307	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1306	PROC

; 3477 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3478 :     TF01306 rec;
; 3479 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3480 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3481 :     return tf_write( NULL, &rec, sizeof( TF01306 ), 1306 );

  00035	66 41 b9 1a 05	 mov	 r9w, 1306		; 0000051aH
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3482 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1306	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1305	PROC

; 3466 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3467 :     TF01305 rec;
; 3468 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3469 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3470 :     return tf_write( NULL, &rec, sizeof( TF01305 ), 1305 );

  00035	66 41 b9 19 05	 mov	 r9w, 1305		; 00000519H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3471 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1305	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
dev$ = 80
tf_1304	PROC

; 3455 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3456 :     TF01304 rec;
; 3457 :     rec.rhdr.devnum = dev->devnum;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00021	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3458 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0002f	d1 f8		 sar	 eax, 1
  00031	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3459 :     return tf_write( NULL, &rec, sizeof( TF01304 ), 1304 );

  00035	66 41 b9 18 05	 mov	 r9w, 1304		; 00000518H
  0003a	66 41 b8 18 00	 mov	 r8w, 24
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 tf_write

; 3460 : }

  0004b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
tf_1304	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 88
dev$ = 128
addr$ = 136
count$ = 144
data$ = 152
amt$ = 160
flag$ = 168
type$ = 176
tf_1301	PROC

; 3438 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3439 :     TF01301 rec;
; 3440 :     rec.rhdr.devnum = dev->devnum;

  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00036	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3441 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0003b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00047	d1 f8		 sar	 eax, 1
  00049	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3442 :     rec.amt   = amt;

  0004d	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  00055	88 44 24 42	 mov	 BYTE PTR rec$[rsp+34], al

; 3443 :     rec.addr  = addr;

  00059	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00061	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3444 :     rec.count = count;

  00066	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR count$[rsp]
  0006e	66 89 44 24 40	 mov	 WORD PTR rec$[rsp+32], ax

; 3445 :     rec.type  = type;

  00073	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR type$[rsp]
  0007b	88 44 24 43	 mov	 BYTE PTR rec$[rsp+35], al

; 3446 :     rec.mflag = flag;

  0007f	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR flag$[rsp]
  00087	88 44 24 44	 mov	 BYTE PTR rec$[rsp+36], al

; 3447 :     memcpy( rec.data, data, amt );

  0008b	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR amt$[rsp]
  00093	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  00098	48 8b f9	 mov	 rdi, rcx
  0009b	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR data$[rsp]
  000a3	8b c8		 mov	 ecx, eax
  000a5	f3 a4		 rep movsb

; 3448 :     return tf_write( NULL, &rec, sizeof( TF01301 ), 1301 );

  000a7	66 41 b9 15 05	 mov	 r9w, 1301		; 00000515H
  000ac	66 41 b8 38 00	 mov	 r8w, 56			; 00000038H
  000b1	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000b6	33 c9		 xor	 ecx, ecx
  000b8	e8 00 00 00 00	 call	 tf_write

; 3449 : }

  000bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c2	48 33 cc	 xor	 rcx, rsp
  000c5	e8 00 00 00 00	 call	 __security_check_cookie
  000ca	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ce	5f		 pop	 rdi
  000cf	5e		 pop	 rsi
  000d0	c3		 ret	 0
tf_1301	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
dev$ = 96
cc$ = 104
tf_1300	PROC

; 3425 : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3426 :     TF01300 rec;
; 3427 :     rec.cc     = cc;

  0001c	0f b6 44 24 68	 movzx	 eax, BYTE PTR cc$[rsp]
  00021	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3428 :     rec.rhdr.devnum = dev->devnum;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3429 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003c	d1 f8		 sar	 eax, 1
  0003e	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3430 :     return tf_write( NULL, &rec, sizeof( TF01300 ), 1300 );

  00042	66 41 b9 14 05	 mov	 r9w, 1300		; 00000514H
  00047	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  0004c	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00051	33 c9		 xor	 ecx, ecx
  00053	e8 00 00 00 00	 call	 tf_write

; 3431 : }

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005d	48 33 cc	 xor	 rcx, rsp
  00060	e8 00 00 00 00	 call	 __security_check_cookie
  00065	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00069	c3		 ret	 0
tf_1300	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
regs$ = 96
tf_0846	PROC

; 3415 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3416 :     TF00846 rec;
; 3417 :     rec.servparm = sysblk.servparm;

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00025	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3418 :     return tf_write( regs, &rec, sizeof( TF00846 ), 846 );

  00029	66 41 b9 4e 03	 mov	 r9w, 846		; 0000034eH
  0002e	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	e8 00 00 00 00	 call	 tf_write

; 3419 : }

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00047	48 33 cc	 xor	 rcx, rsp
  0004a	e8 00 00 00 00	 call	 __security_check_cookie
  0004f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00053	c3		 ret	 0
tf_0846	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
regs$ = 96
tf_0845	PROC

; 3404 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3405 :     TF00845 rec;
; 3406 :     rec.bioparm  = sysblk.bioparm;

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 8b 80 70 12
	00 00		 mov	 rax, QWORD PTR [rax+4720]
  00026	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3407 :     rec.biosubcd = sysblk.biosubcd;

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00032	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00039	88 44 24 40	 mov	 BYTE PTR rec$[rsp+32], al

; 3408 :     return tf_write( regs, &rec, sizeof( TF00845 ), 845 );

  0003d	66 41 b9 4d 03	 mov	 r9w, 845		; 0000034dH
  00042	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  00047	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	e8 00 00 00 00	 call	 tf_write

; 3409 : }

  00056	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005b	48 33 cc	 xor	 rcx, rsp
  0005e	e8 00 00 00 00	 call	 __security_check_cookie
  00063	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00067	c3		 ret	 0
tf_0845	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
regs$ = 96
tf_0844	PROC

; 3389 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3390 :     TF00844 rec;
; 3391 :     rec.rhdr.devnum   = sysblk.biodev->devnum;

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 8b 80 78 12
	00 00		 mov	 rax, QWORD PTR [rax+4728]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3392 :     rec.rhdr.lcss     = SSID_TO_LCSS( sysblk.biodev->ssid );

  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00036	48 8b 80 78 12
	00 00		 mov	 rax, QWORD PTR [rax+4728]
  0003d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00041	d1 f8		 sar	 eax, 1
  00043	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3393 :     rec.servcode = sysblk.servcode;

  00047	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004e	0f b7 80 68 12
	00 00		 movzx	 eax, WORD PTR [rax+4712]
  00055	66 89 44 24 40	 mov	 WORD PTR rec$[rsp+32], ax

; 3394 :     rec.bioparm  = sysblk.bioparm;

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00061	48 8b 80 70 12
	00 00		 mov	 rax, QWORD PTR [rax+4720]
  00068	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3395 :     rec.biostat  = sysblk.biostat;

  0006d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00074	0f b6 80 6b 12
	00 00		 movzx	 eax, BYTE PTR [rax+4715]
  0007b	88 44 24 42	 mov	 BYTE PTR rec$[rsp+34], al

; 3396 :     rec.biosubcd = sysblk.biosubcd;

  0007f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00086	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  0008d	88 44 24 43	 mov	 BYTE PTR rec$[rsp+35], al

; 3397 :     return tf_write( regs, &rec, sizeof( TF00844 ), 844 );

  00091	66 41 b9 4c 03	 mov	 r9w, 844		; 0000034cH
  00096	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  0009b	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	e8 00 00 00 00	 call	 tf_write

; 3398 : }

  000aa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000af	48 33 cc	 xor	 rcx, rsp
  000b2	e8 00 00 00 00	 call	 __security_check_cookie
  000b7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bb	c3		 ret	 0
tf_0844	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv69 = 32
rec$ = 40
__$ArrayPad$ = 80
regs$ = 112
icode$ = 120
tf_0840	PROC

; 3377 : {

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3378 :     TF00840 rec;
; 3379 :     rec.icode = icode;

  0001d	0f b7 44 24 78	 movzx	 eax, WORD PTR icode$[rsp]
  00022	66 89 44 24 48	 mov	 WORD PTR rec$[rsp+32], ax

; 3380 :     rec.cpu_timer = (EXT_CPU_TIMER_INTERRUPT == rec.icode)

  00027	0f b7 44 24 48	 movzx	 eax, WORD PTR rec$[rsp+32]
  0002c	3d 05 10 00 00	 cmp	 eax, 4101		; 00001005H
  00031	75 19		 jne	 SHORT $LN3@tf_0840
  00033	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003f	ff 90 78 14 00
	00		 call	 QWORD PTR [rax+5240]
  00045	48 89 44 24 20	 mov	 QWORD PTR tv69[rsp], rax
  0004a	eb 09		 jmp	 SHORT $LN4@tf_0840
$LN3@tf_0840:
  0004c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv69[rsp], 0
$LN4@tf_0840:
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR tv69[rsp]
  0005a	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp+24], rax

; 3381 :                   ? sysblk.gct( regs ) : 0;
; 3382 :     return tf_write( regs, &rec, sizeof( TF00840 ), 840 );

  0005f	66 41 b9 48 03	 mov	 r9w, 840		; 00000348H
  00064	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  00069	48 8d 54 24 28	 lea	 rdx, QWORD PTR rec$[rsp]
  0006e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	e8 00 00 00 00	 call	 tf_write

; 3383 : }

  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007d	48 33 cc	 xor	 rcx, rsp
  00080	e8 00 00 00 00	 call	 __security_check_cookie
  00085	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00089	c3		 ret	 0
tf_0840	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 80
regs$ = 112
order$ = 120
cc$ = 128
cpad$ = 136
status$ = 144
parm$ = 152
got_status$ = 160
tf_0814	PROC

; 3362 : {

$LN3:
  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3363 :     TF00814 rec;
; 3364 :     rec.order      = order;

  00027	0f b6 44 24 78	 movzx	 eax, BYTE PTR order$[rsp]
  0002c	88 44 24 3a	 mov	 BYTE PTR rec$[rsp+26], al

; 3365 :     rec.cc         = cc;

  00030	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR cc$[rsp]
  00038	88 44 24 3b	 mov	 BYTE PTR rec$[rsp+27], al

; 3366 :     rec.cpad       = cpad;

  0003c	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR cpad$[rsp]
  00044	66 89 44 24 38	 mov	 WORD PTR rec$[rsp+24], ax

; 3367 :     rec.status     = status;

  00049	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR status$[rsp]
  00050	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3368 :     rec.parm       = parm;

  00054	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR parm$[rsp]
  0005c	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp+32], rax

; 3369 :     rec.got_status = got_status;

  00061	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR got_status$[rsp]
  00069	88 44 24 48	 mov	 BYTE PTR rec$[rsp+40], al

; 3370 :     return tf_write( regs, &rec, sizeof( TF00814 ), 814 );

  0006d	66 41 b9 2e 03	 mov	 r9w, 814		; 0000032eH
  00072	66 41 b8 30 00	 mov	 r8w, 48			; 00000030H
  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	e8 00 00 00 00	 call	 tf_write

; 3371 : }

  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00097	c3		 ret	 0
tf_0814	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
regs$ = 80
tf_0812	PROC

; 3353 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3354 :     TF00812 rec;
; 3355 :     return tf_write( regs, &rec, sizeof( TF00812 ), 812 );

  00018	66 41 b9 2c 03	 mov	 r9w, 812		; 0000032cH
  0001d	66 41 b8 18 00	 mov	 r8w, 24
  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	e8 00 00 00 00	 call	 tf_write

; 3356 : }

  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00036	48 33 cc	 xor	 rcx, rsp
  00039	e8 00 00 00 00	 call	 __security_check_cookie
  0003e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00042	c3		 ret	 0
tf_0812	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 64
regs$ = 96
archname$ = 104
tf_0811	PROC

; 3343 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3344 :     TF00811 rec;
; 3345 :     STRLCPY( rec.archname, archname );

  0001d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00023	48 8b 54 24 68	 mov	 rdx, QWORD PTR archname$[rsp]
  00028	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rec$[rsp+24]
  0002d	e8 00 00 00 00	 call	 strlcpy

; 3346 :     return tf_write( regs, &rec, sizeof( TF00811 ), 811 );

  00032	66 41 b9 2b 03	 mov	 r9w, 811		; 0000032bH
  00037	66 41 b8 20 00	 mov	 r8w, 32			; 00000020H
  0003c	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	e8 00 00 00 00	 call	 tf_write

; 3347 : }

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00050	48 33 cc	 xor	 rcx, rsp
  00053	e8 00 00 00 00	 call	 __security_check_cookie
  00058	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0005c	c3		 ret	 0
tf_0811	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 96
regs$ = 128
str$ = 136
tf_0809	PROC

; 3333 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3334 :     TF00809 rec;
; 3335 :     STRLCPY( rec.str, str );

  0001d	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00023	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0002b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rec$[rsp+24]
  00030	e8 00 00 00 00	 call	 strlcpy

; 3336 :     return tf_write( regs, &rec, sizeof( TF00809 ), 809 );

  00035	66 41 b9 29 03	 mov	 r9w, 809		; 00000329H
  0003a	66 41 b8 40 00	 mov	 r8w, 64			; 00000040H
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	e8 00 00 00 00	 call	 tf_write

; 3337 : }

  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00056	48 33 cc	 xor	 rcx, rsp
  00059	e8 00 00 00 00	 call	 __security_check_cookie
  0005e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00062	c3		 ret	 0
tf_0809	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 56
regs$ = 80
tf_0808	PROC

; 3324 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3325 :     TF00808 rec;
; 3326 :     return tf_write( regs, &rec, sizeof( TF00808 ), 808 );

  00018	66 41 b9 28 03	 mov	 r9w, 808		; 00000328H
  0001d	66 41 b8 18 00	 mov	 r8w, 24
  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	e8 00 00 00 00	 call	 tf_write

; 3327 : }

  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00036	48 33 cc	 xor	 rcx, rsp
  00039	e8 00 00 00 00	 call	 __security_check_cookie
  0003e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00042	c3		 ret	 0
tf_0808	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 80
regs$ = 112
mcic$ = 120
fsta$ = 128
xdmg$ = 136
tf_0807	PROC

; 3312 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3313 :     TF00807 rec;
; 3314 :     rec.mcic = mcic;

  00027	48 8b 44 24 78	 mov	 rax, QWORD PTR mcic$[rsp]
  0002c	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3315 :     rec.xdmg = xdmg;

  00031	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR xdmg$[rsp]
  00038	89 44 24 48	 mov	 DWORD PTR rec$[rsp+40], eax

; 3316 :     rec.fsta = fsta;

  0003c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fsta$[rsp]
  00044	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp+32], rax

; 3317 :     return tf_write( regs, &rec, sizeof( TF00807 ), 807 );

  00049	66 41 b9 27 03	 mov	 r9w, 807		; 00000327H
  0004e	66 41 b8 30 00	 mov	 r8w, 48			; 00000030H
  00053	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	e8 00 00 00 00	 call	 tf_write

; 3318 : }

  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00067	48 33 cc	 xor	 rcx, rsp
  0006a	e8 00 00 00 00	 call	 __security_check_cookie
  0006f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00073	c3		 ret	 0
tf_0807	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
regs$ = 96
ioid$ = 104
ioparm$ = 112
iointid$ = 120
tf_0806	PROC

; 3300 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3301 :     TF00806 rec;
; 3302 :     rec.ioid    = ioid;

  00026	8b 44 24 68	 mov	 eax, DWORD PTR ioid$[rsp]
  0002a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3303 :     rec.ioparm  = ioparm;

  0002e	8b 44 24 70	 mov	 eax, DWORD PTR ioparm$[rsp]
  00032	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3304 :     rec.iointid = iointid;

  00036	8b 44 24 78	 mov	 eax, DWORD PTR iointid$[rsp]
  0003a	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 3305 :     return tf_write( regs, &rec, sizeof( TF00806 ), 806 );

  0003e	66 41 b9 26 03	 mov	 r9w, 806		; 00000326H
  00043	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  00048	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	e8 00 00 00 00	 call	 tf_write

; 3306 : }

  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005c	48 33 cc	 xor	 rcx, rsp
  0005f	e8 00 00 00 00	 call	 __security_check_cookie
  00064	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00068	c3		 ret	 0
tf_0806	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
regs$ = 96
csw$ = 104
ioid$ = 112
lcss$ = 120
tf_0804	PROC

; 3288 : {

$LN3:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3289 :     TF00804 rec;
; 3290 :     rec.ioid = ioid;

  00028	0f b7 44 24 70	 movzx	 eax, WORD PTR ioid$[rsp]
  0002d	66 89 44 24 40	 mov	 WORD PTR rec$[rsp+32], ax

; 3291 :     rec.rhdr.lcss = lcss;

  00032	0f b6 44 24 78	 movzx	 eax, BYTE PTR lcss$[rsp]
  00037	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3292 :     memcpy( rec.csw, csw, sizeof( rec.csw ));

  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR csw$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3293 :     return tf_write( regs, &rec, sizeof( TF00804 ), 804 );

  00048	66 41 b9 24 03	 mov	 r9w, 804		; 00000324H
  0004d	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  00052	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	e8 00 00 00 00	 call	 tf_write

; 3294 : }

  00061	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00066	48 33 cc	 xor	 rcx, rsp
  00069	e8 00 00 00 00	 call	 __security_check_cookie
  0006e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00072	c3		 ret	 0
tf_0804	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 96
regs$ = 128
str$ = 136
tf_0803	PROC

; 3278 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3279 :     TF00803 rec;
; 3280 :     STRLCPY( rec.str, str );

  0001d	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00023	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0002b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR rec$[rsp+24]
  00030	e8 00 00 00 00	 call	 strlcpy

; 3281 :     return tf_write( regs, &rec, sizeof( TF00803 ), 803 );

  00035	66 41 b9 23 03	 mov	 r9w, 803		; 00000323H
  0003a	66 41 b8 40 00	 mov	 r8w, 64			; 00000040H
  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00044	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	e8 00 00 00 00	 call	 tf_write

; 3282 : }

  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00056	48 33 cc	 xor	 rcx, rsp
  00059	e8 00 00 00 00	 call	 __security_check_cookie
  0005e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00062	c3		 ret	 0
tf_0803	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 72
regs$ = 96
ia$ = 104
pcode$ = 112
perc$ = 120
tf_0802	PROC

; 3266 : {

$LN3:
  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3267 :     TF00802 rec;
; 3268 :     rec.ia    = ia;

  00028	48 8b 44 24 68	 mov	 rax, QWORD PTR ia$[rsp]
  0002d	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3269 :     rec.pcode = pcode;

  00032	8b 44 24 70	 mov	 eax, DWORD PTR pcode$[rsp]
  00036	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 3270 :     rec.perc  = perc;

  0003a	0f b7 44 24 78	 movzx	 eax, WORD PTR perc$[rsp]
  0003f	66 89 44 24 44	 mov	 WORD PTR rec$[rsp+36], ax

; 3271 :     return tf_write( regs, &rec, sizeof( TF00802 ), 802 );

  00044	66 41 b9 22 03	 mov	 r9w, 802		; 00000322H
  00049	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  0004e	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	e8 00 00 00 00	 call	 tf_write

; 3272 : }

  0005d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006e	c3		 ret	 0
tf_0802	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv72 = 32
tv77 = 36
rec$ = 40
__$ArrayPad$ = 80
regs$ = 112
pcode$ = 120
ilc$ = 128
tf_0801	PROC

; 3247 : {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3248 :     TF00801 rec;
; 3249 :     rec.sie =

  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	d1 e8		 shr	 eax, 1
  0002f	83 e0 01	 and	 eax, 1
  00032	88 44 24 42	 mov	 BYTE PTR rec$[rsp+26], al

; 3250 : #if defined( _FEATURE_SIE )
; 3251 :         SIE_MODE( regs );
; 3252 : #else
; 3253 :         false;
; 3254 : #endif
; 3255 :     rec.ilc = ilc;

  00036	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR ilc$[rsp]
  0003e	88 44 24 43	 mov	 BYTE PTR rec$[rsp+27], al

; 3256 :     rec.pcode = pcode;

  00042	0f b7 44 24 78	 movzx	 eax, WORD PTR pcode$[rsp]
  00047	66 89 44 24 40	 mov	 WORD PTR rec$[rsp+24], ax

; 3257 :     rec.why = (pcode & PGM_TXF_EVENT) ? regs->txf_why : 0;

  0004c	0f b7 44 24 78	 movzx	 eax, WORD PTR pcode$[rsp]
  00051	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00056	85 c0		 test	 eax, eax
  00058	74 11		 je	 SHORT $LN3@tf_0801
  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00065	89 44 24 20	 mov	 DWORD PTR tv72[rsp], eax
  00069	eb 08		 jmp	 SHORT $LN4@tf_0801
$LN3@tf_0801:
  0006b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN4@tf_0801:
  00073	8b 44 24 20	 mov	 eax, DWORD PTR tv72[rsp]
  00077	89 44 24 48	 mov	 DWORD PTR rec$[rsp+32], eax

; 3258 :     rec.dxc = ((pcode & 0xFF) == PGM_DATA_EXCEPTION) ? regs->dxc : 0;

  0007b	0f b7 44 24 78	 movzx	 eax, WORD PTR pcode$[rsp]
  00080	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00085	83 f8 07	 cmp	 eax, 7
  00088	75 11		 jne	 SHORT $LN5@tf_0801
  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  00095	89 44 24 24	 mov	 DWORD PTR tv77[rsp], eax
  00099	eb 08		 jmp	 SHORT $LN6@tf_0801
$LN5@tf_0801:
  0009b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN6@tf_0801:
  000a3	8b 44 24 24	 mov	 eax, DWORD PTR tv77[rsp]
  000a7	89 44 24 44	 mov	 DWORD PTR rec$[rsp+28], eax

; 3259 :     return tf_write( regs, &rec, sizeof( TF00801 ), 801 );

  000ab	66 41 b9 21 03	 mov	 r9w, 801		; 00000321H
  000b0	66 41 b8 28 00	 mov	 r8w, 40			; 00000028H
  000b5	48 8d 54 24 28	 lea	 rdx, QWORD PTR rec$[rsp]
  000ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	e8 00 00 00 00	 call	 tf_write

; 3260 : }

  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c9	48 33 cc	 xor	 rcx, rsp
  000cc	e8 00 00 00 00	 call	 __security_check_cookie
  000d1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d5	c3		 ret	 0
tf_0801	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
tv89 = 40
tv91 = 44
rec$ = 48
__$ArrayPad$ = 128
regs$ = 176
tf_0800	PROC

; 3233 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3234 :     TF00800 rec;
; 3235 :     memcpy( &rec.psw, &regs->psw, sizeof( rec.psw ));

  00020	48 8d 44 24 48	 lea	 rax, QWORD PTR rec$[rsp+24]
  00025	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  00034	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00039	f3 a4		 rep movsb

; 3236 :     rec.psw.ilc = REAL_ILC( regs );

  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00043	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00049	83 e0 01	 and	 eax, 1
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN3@tf_0800
  00050	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00058	eb 08		 jmp	 SHORT $LN4@tf_0800
$LN3@tf_0800:
  0005a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN4@tf_0800:
  00062	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00067	74 0a		 je	 SHORT $LN7@tf_0800
  00069	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN8@tf_0800
$LN7@tf_0800:
  00073	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN8@tf_0800:
  0007b	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  00080	74 15		 je	 SHORT $LN11@tf_0800
  00082	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00091	89 44 24 2c	 mov	 DWORD PTR tv91[rsp], eax
  00095	eb 31		 jmp	 SHORT $LN12@tf_0800
$LN11@tf_0800:
  00097	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000a5	d1 e8		 shr	 eax, 1
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 0a		 je	 SHORT $LN9@tf_0800
  000ae	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv89[rsp], 6
  000b6	eb 08		 jmp	 SHORT $LN10@tf_0800
$LN9@tf_0800:
  000b8	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv89[rsp], 4
$LN10@tf_0800:
  000c0	8b 44 24 28	 mov	 eax, DWORD PTR tv89[rsp]
  000c4	89 44 24 2c	 mov	 DWORD PTR tv91[rsp], eax
$LN12@tf_0800:
  000c8	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv91[rsp]
  000cd	88 44 24 6a	 mov	 BYTE PTR rec$[rsp+58], al

; 3237 :     rec.amode64 = rec.psw.amode64;

  000d1	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000d5	83 e0 01	 and	 eax, 1
  000d8	88 44 24 70	 mov	 BYTE PTR rec$[rsp+64], al

; 3238 :     rec.amode   = rec.psw.amode;

  000dc	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000e0	d1 e8		 shr	 eax, 1
  000e2	83 e0 01	 and	 eax, 1
  000e5	88 44 24 71	 mov	 BYTE PTR rec$[rsp+65], al

; 3239 :     rec.zeroilc = rec.psw.zeroilc;

  000e9	8b 44 24 50	 mov	 eax, DWORD PTR rec$[rsp+32]
  000ed	c1 e8 02	 shr	 eax, 2
  000f0	83 e0 01	 and	 eax, 1
  000f3	88 44 24 72	 mov	 BYTE PTR rec$[rsp+66], al

; 3240 :     return tf_write( regs, &rec, sizeof( TF00800 ), 800 );

  000f7	66 41 b9 20 03	 mov	 r9w, 800		; 00000320H
  000fc	66 41 b8 48 00	 mov	 r8w, 72			; 00000048H
  00101	48 8d 54 24 30	 lea	 rdx, QWORD PTR rec$[rsp]
  00106	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	e8 00 00 00 00	 call	 tf_write

; 3241 : }

  00113	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0011b	48 33 cc	 xor	 rcx, rsp
  0011e	e8 00 00 00 00	 call	 __security_check_cookie
  00123	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0012a	5f		 pop	 rdi
  0012b	5e		 pop	 rsi
  0012c	c3		 ret	 0
tf_0800	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0520	PROC

; 3220 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3221 :     TF00520 rec;
; 3222 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3223 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3224 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3225 :     rec.rba    = dev->fbarba;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  00079	48 89 44 24 38	 mov	 QWORD PTR rec$[rsp+24], rax

; 3226 :     return tf_write( NULL, &rec, sizeof( TF00520 ), 520 );

  0007e	66 41 b9 08 02	 mov	 r9w, 520		; 00000208H
  00083	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00088	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008d	33 c9		 xor	 ecx, ecx
  0008f	e8 00 00 00 00	 call	 tf_write

; 3227 : }

  00094	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000ab	c3		 ret	 0
tf_0520	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
blkgrp$ = 376
offset$ = 384
len$ = 392
tf_0519	PROC

; 3205 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3206 :     TF00519 rec;
; 3207 :     rec.rhdr.devnum = dev->devnum;

  0002c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00038	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3208 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0003d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00049	d1 f8		 sar	 eax, 1
  0004b	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3209 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00057	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 trimloc
  00065	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0006b	48 8b d0	 mov	 rdx, rax
  0006e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  00073	e8 00 00 00 00	 call	 strlcpy

; 3210 :     rec.blkgrp = blkgrp;

  00078	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR blkgrp$[rsp]
  0007f	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3211 :     rec.offset = offset;

  00083	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0008b	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp+32], rax

; 3212 :     rec.len    = len;

  00090	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00097	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3213 :     return tf_write( NULL, &rec, sizeof( TF00519 ), 519 );

  0009b	66 41 b9 07 02	 mov	 r9w, 519		; 00000207H
  000a0	66 41 b8 28 01	 mov	 r8w, 296		; 00000128H
  000a5	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000aa	33 c9		 xor	 ecx, ecx
  000ac	e8 00 00 00 00	 call	 tf_write

; 3214 : }

  000b1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b9	48 33 cc	 xor	 rcx, rsp
  000bc	e8 00 00 00 00	 call	 __security_check_cookie
  000c1	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000c8	c3		 ret	 0
tf_0519	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
blkgrp$ = 360
o$ = 368
tf_0518	PROC

; 3191 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3192 :     TF00518 rec;
; 3193 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3194 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3195 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 3196 :     rec.blkgrp = blkgrp;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR blkgrp$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3197 :     rec.idx    = o;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR o$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3198 :     return tf_write( NULL, &rec, sizeof( TF00518 ), 518 );

  00089	66 41 b9 06 02	 mov	 r9w, 518		; 00000206H
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 3199 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0518	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
blkgrp$ = 360
tf_0517	PROC

; 3178 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3179 :     TF00517 rec;
; 3180 :     rec.rhdr.devnum = dev->devnum;

  00022	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3181 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003f	d1 f8		 sar	 eax, 1
  00041	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3182 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00045	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 trimloc
  0005b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00069	e8 00 00 00 00	 call	 strlcpy

; 3183 :     rec.blkgrp = blkgrp;

  0006e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR blkgrp$[rsp]
  00075	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3184 :     return tf_write( NULL, &rec, sizeof( TF00517 ), 517 );

  00079	66 41 b9 05 02	 mov	 r9w, 517		; 00000205H
  0007e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00083	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00088	33 c9		 xor	 ecx, ecx
  0008a	e8 00 00 00 00	 call	 tf_write

; 3185 : }

  0008f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00097	48 33 cc	 xor	 rcx, rsp
  0009a	e8 00 00 00 00	 call	 __security_check_cookie
  0009f	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000a6	c3		 ret	 0
tf_0517	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
blkgrp$ = 360
i$ = 368
tf_0516	PROC

; 3164 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3165 :     TF00516 rec;
; 3166 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3167 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3168 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 3169 :     rec.blkgrp = blkgrp;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR blkgrp$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3170 :     rec.idx    = i;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3171 :     return tf_write( NULL, &rec, sizeof( TF00516 ), 516 );

  00089	66 41 b9 04 02	 mov	 r9w, 516		; 00000204H
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 3172 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0516	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0442	PROC

; 3151 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3152 :     TF00442 rec;
; 3153 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3154 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3155 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3156 :     rec.mask = dev->ckdfmask;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  00079	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3157 :     return tf_write( NULL, &rec, sizeof( TF00442 ), 442 );

  0007d	66 41 b9 ba 01	 mov	 r9w, 442		; 000001baH
  00082	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00087	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 tf_write

; 3158 : }

  00093	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009b	48 33 cc	 xor	 rcx, rsp
  0009e	e8 00 00 00 00	 call	 __security_check_cookie
  000a3	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000aa	c3		 ret	 0
tf_0442	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
tf_0441	PROC

; 3135 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3136 :     TF00441 rec;
; 3137 :     rec.rhdr.devnum  = dev->devnum;

  0001e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3138 :     rec.rhdr.lcss    = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3139 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3140 :     rec.cyl     = dev->ckdcurcyl;

  0006a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  00078	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3141 :     rec.head    = dev->ckdcurhead;

  0007c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  0008a	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3142 :     rec.recnum  = dev->ckdcurrec;

  0008e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00096	8b 80 d0 12 00
	00		 mov	 eax, DWORD PTR [rax+4816]
  0009c	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 3143 :     rec.datalen = dev->ckdcurdl;

  000a0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  000af	66 89 44 24 44	 mov	 WORD PTR rec$[rsp+36], ax

; 3144 :     return tf_write( NULL, &rec, sizeof( TF00441 ), 441 );

  000b4	66 41 b9 b9 01	 mov	 r9w, 441		; 000001b9H
  000b9	66 41 b8 28 01	 mov	 r8w, 296		; 00000128H
  000be	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000c3	33 c9		 xor	 ecx, ecx
  000c5	e8 00 00 00 00	 call	 tf_write

; 3145 : }

  000ca	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d2	48 33 cc	 xor	 rcx, rsp
  000d5	e8 00 00 00 00	 call	 __security_check_cookie
  000da	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000e1	c3		 ret	 0
tf_0441	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
tf_0440	PROC

; 3117 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3118 :     TF00440 rec;
; 3119 :     rec.rhdr.devnum  = dev->devnum;

  0001e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3120 :     rec.rhdr.lcss    = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3121 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 50	 lea	 rcx, QWORD PTR rec$[rsp+48]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3122 :     rec.cyl     = dev->ckdcurcyl;

  0006a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  00078	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3123 :     rec.head    = dev->ckdcurhead;

  0007c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  0008a	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3124 :     rec.recnum  = dev->ckdcurrec;

  0008e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00096	8b 80 d0 12 00
	00		 mov	 eax, DWORD PTR [rax+4816]
  0009c	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 3125 :     rec.keylen  = dev->ckdcurkl;

  000a0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  000ae	89 44 24 44	 mov	 DWORD PTR rec$[rsp+36], eax

; 3126 :     rec.datalen = dev->ckdcurdl;

  000b2	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ba	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  000c1	66 89 44 24 48	 mov	 WORD PTR rec$[rsp+40], ax

; 3127 : 
; 3128 :     return tf_write( NULL, &rec, sizeof( TF00440 ), 440 );

  000c6	66 41 b9 b8 01	 mov	 r9w, 440		; 000001b8H
  000cb	66 41 b8 30 01	 mov	 r8w, 304		; 00000130H
  000d0	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000d5	33 c9		 xor	 ecx, ecx
  000d7	e8 00 00 00 00	 call	 tf_write

; 3129 : }

  000dc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e4	48 33 cc	 xor	 rcx, rsp
  000e7	e8 00 00 00 00	 call	 __security_check_cookie
  000ec	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000f3	c3		 ret	 0
tf_0440	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
recnum$ = 376
tf_0439	PROC

; 3102 : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3103 :     TF00439 rec;
; 3104 :     rec.rhdr.devnum = dev->devnum;

  00022	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3105 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003f	d1 f8		 sar	 eax, 1
  00041	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3106 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00045	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 trimloc
  0005b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  00069	e8 00 00 00 00	 call	 strlcpy

; 3107 :     rec.recnum = recnum;

  0006e	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR recnum$[rsp]
  00076	88 44 24 40	 mov	 BYTE PTR rec$[rsp+32], al

; 3108 :     rec.cyl    = dev->ckdcurcyl;

  0007a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00082	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  00088	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3109 :     rec.head   = dev->ckdcurhead;

  0008c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00094	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  0009a	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3110 :     return tf_write( NULL, &rec, sizeof( TF00439 ), 439 );

  0009e	66 41 b9 b7 01	 mov	 r9w, 439		; 000001b7H
  000a3	66 41 b8 28 01	 mov	 r8w, 296		; 00000128H
  000a8	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 tf_write

; 3111 : }

  000b4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000bc	48 33 cc	 xor	 rcx, rsp
  000bf	e8 00 00 00 00	 call	 __security_check_cookie
  000c4	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000cb	c3		 ret	 0
tf_0439	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
recnum$ = 376
keylen$ = 384
datalen$ = 392
tf_0438	PROC

; 3085 : {

$LN3:
  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3086 :     TF00438 rec;
; 3087 :     rec.rhdr.devnum  = dev->devnum;

  0002d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00039	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3088 :     rec.rhdr.lcss    = SSID_TO_LCSS( dev->ssid );

  0003e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00046	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0004a	d1 f8		 sar	 eax, 1
  0004c	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3089 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00050	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 trimloc
  00066	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  00074	e8 00 00 00 00	 call	 strlcpy

; 3090 :     rec.datalen = datalen;

  00079	0f b7 84 24 88
	01 00 00	 movzx	 eax, WORD PTR datalen$[rsp]
  00081	66 89 44 24 40	 mov	 WORD PTR rec$[rsp+32], ax

; 3091 :     rec.recnum  = recnum;

  00086	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR recnum$[rsp]
  0008e	88 44 24 42	 mov	 BYTE PTR rec$[rsp+34], al

; 3092 :     rec.keylen  = keylen;

  00092	0f b6 84 24 80
	01 00 00	 movzx	 eax, BYTE PTR keylen$[rsp]
  0009a	88 44 24 43	 mov	 BYTE PTR rec$[rsp+35], al

; 3093 :     rec.cyl     = dev->ckdcurcyl;

  0009e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  000ac	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3094 :     rec.head    = dev->ckdcurhead;

  000b0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b8	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  000be	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3095 :     return tf_write( NULL, &rec, sizeof( TF00438 ), 438 );

  000c2	66 41 b9 b6 01	 mov	 r9w, 438		; 000001b6H
  000c7	66 41 b8 28 01	 mov	 r8w, 296		; 00000128H
  000cc	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000d1	33 c9		 xor	 ecx, ecx
  000d3	e8 00 00 00 00	 call	 tf_write

; 3096 : }

  000d8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e0	48 33 cc	 xor	 rcx, rsp
  000e3	e8 00 00 00 00	 call	 __security_check_cookie
  000e8	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000ef	c3		 ret	 0
tf_0438	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0437	PROC

; 3072 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3073 :     TF00437 rec;
; 3074 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3075 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3076 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3077 :     rec.dl = dev->ckdcurdl;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00079	66 89 44 24 38	 mov	 WORD PTR rec$[rsp+24], ax

; 3078 :     return tf_write( NULL, &rec, sizeof( TF00437 ), 437 );

  0007e	66 41 b9 b5 01	 mov	 r9w, 437		; 000001b5H
  00083	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00088	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008d	33 c9		 xor	 ecx, ecx
  0008f	e8 00 00 00 00	 call	 tf_write

; 3079 : }

  00094	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000ab	c3		 ret	 0
tf_0437	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0436	PROC

; 3059 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3060 :     TF00436 rec;
; 3061 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3062 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3063 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3064 :     rec.kl = dev->ckdcurkl;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  00078	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3065 :     return tf_write( NULL, &rec, sizeof( TF00436 ), 436 );

  0007c	66 41 b9 b4 01	 mov	 r9w, 436		; 000001b4H
  00081	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00086	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008b	33 c9		 xor	 ecx, ecx
  0008d	e8 00 00 00 00	 call	 tf_write

; 3066 : }

  00092	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009a	48 33 cc	 xor	 rcx, rsp
  0009d	e8 00 00 00 00	 call	 __security_check_cookie
  000a2	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000a9	c3		 ret	 0
tf_0436	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
tf_0435	PROC

; 3041 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3042 :     TF00435 rec;
; 3043 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3044 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3045 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 50	 lea	 rcx, QWORD PTR rec$[rsp+48]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3046 :     rec.dl     = dev->ckdcurdl;

  0006a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00079	66 89 44 24 38	 mov	 WORD PTR rec$[rsp+24], ax

; 3047 :     rec.cyl    = dev->ckdcurcyl;

  0007e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  0008c	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3048 :     rec.head   = dev->ckdcurhead;

  00090	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00098	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  0009e	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 3049 :     rec.record = dev->ckdcurrec;

  000a2	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000aa	8b 80 d0 12 00
	00		 mov	 eax, DWORD PTR [rax+4816]
  000b0	89 44 24 44	 mov	 DWORD PTR rec$[rsp+36], eax

; 3050 :     rec.kl     = dev->ckdcurkl;

  000b4	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000bc	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  000c2	89 44 24 48	 mov	 DWORD PTR rec$[rsp+40], eax

; 3051 :     rec.offset = dev->ckdtrkof;

  000c6	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ce	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  000d4	c1 e8 0f	 shr	 eax, 15
  000d7	83 e0 01	 and	 eax, 1
  000da	89 44 24 4c	 mov	 DWORD PTR rec$[rsp+44], eax

; 3052 :     return tf_write( NULL, &rec, sizeof( TF00435 ), 435 );

  000de	66 41 b9 b3 01	 mov	 r9w, 435		; 000001b3H
  000e3	66 41 b8 30 01	 mov	 r8w, 304		; 00000130H
  000e8	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000ed	33 c9		 xor	 ecx, ecx
  000ef	e8 00 00 00 00	 call	 tf_write

; 3053 : }

  000f4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000fc	48 33 cc	 xor	 rcx, rsp
  000ff	e8 00 00 00 00	 call	 __security_check_cookie
  00104	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  0010b	c3		 ret	 0
tf_0435	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0434	PROC

; 3028 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3029 :     TF00434 rec;
; 3030 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3031 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3032 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3033 :     rec.orient = (BYTE) dev->ckdorient;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b6 80 d8 12
	00 00		 movzx	 eax, BYTE PTR [rax+4824]
  00079	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3034 :     return tf_write( NULL, &rec, sizeof( TF00434 ), 434 );

  0007d	66 41 b9 b2 01	 mov	 r9w, 434		; 000001b2H
  00082	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00087	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 tf_write

; 3035 : }

  00093	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009b	48 33 cc	 xor	 rcx, rsp
  0009e	e8 00 00 00 00	 call	 __security_check_cookie
  000a3	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000aa	c3		 ret	 0
tf_0434	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
cyl$ = 360
head$ = 368
tf_0433	PROC

; 3014 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3015 :     TF00433 rec;
; 3016 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3017 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3018 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 3019 :     rec.cyl  = cyl;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 3020 :     rec.head = head;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 3021 :     return tf_write( NULL, &rec, sizeof( TF00433 ), 433 );

  00089	66 41 b9 b1 01	 mov	 r9w, 433		; 000001b1H
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 3022 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0433	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0432	PROC

; 3000 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3001 :     TF00432 rec;
; 3002 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 3003 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 3004 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 3005 :     rec.count = dev->ckdlcount;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00079	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 3006 :     rec.mask  = dev->ckdfmask;

  0007d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00085	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  0008c	88 44 24 39	 mov	 BYTE PTR rec$[rsp+25], al

; 3007 :     return tf_write( NULL, &rec, sizeof( TF00432 ), 432 );

  00090	66 41 b9 b0 01	 mov	 r9w, 432		; 000001b0H
  00095	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  0009a	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0009f	33 c9		 xor	 ecx, ecx
  000a1	e8 00 00 00 00	 call	 tf_write

; 3008 : }

  000a6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ae	48 33 cc	 xor	 rcx, rsp
  000b1	e8 00 00 00 00	 call	 __security_check_cookie
  000b6	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000bd	c3		 ret	 0
tf_0432	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
cyl$ = 360
head$ = 368
tf_0431	PROC

; 2986 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2987 :     TF00431 rec;
; 2988 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2989 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2990 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 2991 :     rec.cyl  = cyl;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2992 :     rec.head = head;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 2993 :     return tf_write( NULL, &rec, sizeof( TF00431 ), 431 );

  00089	66 41 b9 af 01	 mov	 r9w, 431		; 000001afH
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 2994 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0431	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 384
trk$ = 392
tf_0430	PROC

; 2972 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2973 :     TF00430 rec;
; 2974 :     rec.rhdr.devnum = dev->devnum;

  00024	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00030	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2975 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00035	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00041	d1 f8		 sar	 eax, 1
  00043	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2976 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00047	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004f	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 trimloc
  0005d	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00063	48 8b d0	 mov	 rdx, rax
  00066	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rec$[rsp+40]
  0006b	e8 00 00 00 00	 call	 strlcpy

; 2977 :     rec.trk = trk;

  00070	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00077	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2978 :     memcpy( rec.buf, dev->buf, sizeof( rec.buf ));

  0007b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0008a	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR rec$[rsp+28]
  0008f	48 8b f9	 mov	 rdi, rcx
  00092	48 8b f0	 mov	 rsi, rax
  00095	b9 05 00 00 00	 mov	 ecx, 5
  0009a	f3 a4		 rep movsb

; 2979 :     return tf_write( NULL, &rec, sizeof( TF00430 ), 430 );

  0009c	66 41 b9 ae 01	 mov	 r9w, 430		; 000001aeH
  000a1	66 41 b8 28 01	 mov	 r8w, 296		; 00000128H
  000a6	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000ab	33 c9		 xor	 ecx, ecx
  000ad	e8 00 00 00 00	 call	 tf_write

; 2980 : }

  000b2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000c9	5f		 pop	 rdi
  000ca	5e		 pop	 rsi
  000cb	c3		 ret	 0
tf_0430	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 336
dev$ = 368
trk$ = 376
fnum$ = 384
tf_0429	PROC

; 2956 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2957 :     TF00429 rec;
; 2958 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2959 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2960 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 50	 lea	 rcx, QWORD PTR rec$[rsp+48]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 2961 :     rec.trk    = trk;

  00073	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2962 :     rec.offset = dev->ckdtrkoff;

  0007e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0008d	48 89 44 24 48	 mov	 QWORD PTR rec$[rsp+40], rax

; 2963 :     rec.len    = dev->ckdtrksz;

  00092	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009a	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  000a0	89 44 24 40	 mov	 DWORD PTR rec$[rsp+32], eax

; 2964 :     rec.fnum   = fnum;

  000a4	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR fnum$[rsp]
  000ab	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 2965 :     return tf_write( NULL, &rec, sizeof( TF00429 ), 429 );

  000af	66 41 b9 ad 01	 mov	 r9w, 429		; 000001adH
  000b4	66 41 b8 30 01	 mov	 r8w, 304		; 00000130H
  000b9	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000be	33 c9		 xor	 ecx, ecx
  000c0	e8 00 00 00 00	 call	 tf_write

; 2966 : }

  000c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cd	48 33 cc	 xor	 rcx, rsp
  000d0	e8 00 00 00 00	 call	 __security_check_cookie
  000d5	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  000dc	c3		 ret	 0
tf_0429	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
trk$ = 360
o$ = 368
tf_0428	PROC

; 2942 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2943 :     TF00428 rec;
; 2944 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2945 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2946 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 2947 :     rec.trk = trk;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2948 :     rec.idx = o;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR o$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 2949 :     return tf_write( NULL, &rec, sizeof( TF00428 ), 428 );

  00089	66 41 b9 ac 01	 mov	 r9w, 428		; 000001acH
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 2950 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0428	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
trk$ = 360
tf_0427	PROC

; 2929 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2930 :     TF00427 rec;
; 2931 :     rec.rhdr.devnum = dev->devnum;

  00022	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2932 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003f	d1 f8		 sar	 eax, 1
  00041	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2933 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00045	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 trimloc
  0005b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00069	e8 00 00 00 00	 call	 strlcpy

; 2934 :     rec.trk = trk;

  0006e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00075	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2935 :     return tf_write( NULL, &rec, sizeof( TF00427 ), 427 );

  00079	66 41 b9 ab 01	 mov	 r9w, 427		; 000001abH
  0007e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00083	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00088	33 c9		 xor	 ecx, ecx
  0008a	e8 00 00 00 00	 call	 tf_write

; 2936 : }

  0008f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00097	48 33 cc	 xor	 rcx, rsp
  0009a	e8 00 00 00 00	 call	 __security_check_cookie
  0009f	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000a6	c3		 ret	 0
tf_0427	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
trk$ = 360
i$ = 368
tf_0426	PROC

; 2915 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2916 :     TF00426 rec;
; 2917 :     rec.rhdr.devnum = dev->devnum;

  00027	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2918 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00038	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00044	d1 f8		 sar	 eax, 1
  00046	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2919 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 trimloc
  00060	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  0006e	e8 00 00 00 00	 call	 strlcpy

; 2920 :     rec.trk = trk;

  00073	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2921 :     rec.idx = i;

  0007e	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00085	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 2922 :     return tf_write( NULL, &rec, sizeof( TF00426 ), 426 );

  00089	66 41 b9 aa 01	 mov	 r9w, 426		; 000001aaH
  0008e	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00093	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  00098	33 c9		 xor	 ecx, ecx
  0009a	e8 00 00 00 00	 call	 tf_write

; 2923 : }

  0009f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a7	48 33 cc	 xor	 rcx, rsp
  000aa	e8 00 00 00 00	 call	 __security_check_cookie
  000af	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b6	c3		 ret	 0
tf_0426	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
tf_0425	PROC

; 2902 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2903 :     TF00425 rec;
; 2904 :     rec.rhdr.devnum = dev->devnum;

  0001e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2905 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0002f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003b	d1 f8		 sar	 eax, 1
  0003d	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2906 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00041	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 trimloc
  00057	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00065	e8 00 00 00 00	 call	 strlcpy

; 2907 :     rec.bufcur = dev->bufcur;

  0006a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00078	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2908 :     return tf_write( NULL, &rec, sizeof( TF00425 ), 425 );

  0007c	66 41 b9 a9 01	 mov	 r9w, 425		; 000001a9H
  00081	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00086	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0008b	33 c9		 xor	 ecx, ecx
  0008d	e8 00 00 00 00	 call	 tf_write

; 2909 : }

  00092	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009a	48 33 cc	 xor	 rcx, rsp
  0009d	e8 00 00 00 00	 call	 __security_check_cookie
  000a2	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000a9	c3		 ret	 0
tf_0425	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 320
dev$ = 352
trk$ = 360
tf_0424	PROC

; 2888 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2889 :     TF00424 rec;
; 2890 :     rec.rhdr.devnum = dev->devnum;

  00022	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002e	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2891 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  00033	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0003f	d1 f8		 sar	 eax, 1
  00041	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2892 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  00045	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 trimloc
  0005b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rec$[rsp+32]
  00069	e8 00 00 00 00	 call	 strlcpy

; 2893 :     rec.trk    = trk;

  0006e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00075	89 44 24 38	 mov	 DWORD PTR rec$[rsp+24], eax

; 2894 :     rec.bufcur = dev->bufcur;

  00079	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00087	89 44 24 3c	 mov	 DWORD PTR rec$[rsp+28], eax

; 2895 :     return tf_write( NULL, &rec, sizeof( TF00424 ), 424 );

  0008b	66 41 b9 a8 01	 mov	 r9w, 424		; 000001a8H
  00090	66 41 b8 20 01	 mov	 r8w, 288		; 00000120H
  00095	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  0009a	33 c9		 xor	 ecx, ecx
  0009c	e8 00 00 00 00	 call	 tf_write

; 2896 : }

  000a1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a9	48 33 cc	 xor	 rcx, rsp
  000ac	e8 00 00 00 00	 call	 __security_check_cookie
  000b1	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000b8	c3		 ret	 0
tf_0424	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rec$ = 32
__$ArrayPad$ = 368
dev$ = 416
kl$ = 424
key$ = 432
tf_0423	PROC

; 2874 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2875 :     TF00423 rec;
; 2876 :     rec.rhdr.devnum = dev->devnum;

  0002a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00036	66 89 44 24 32	 mov	 WORD PTR rec$[rsp+18], ax

; 2877 :     rec.rhdr.lcss   = SSID_TO_LCSS( dev->ssid );

  0003b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00047	d1 f8		 sar	 eax, 1
  00049	88 44 24 31	 mov	 BYTE PTR rec$[rsp+17], al

; 2878 :     STRLCPY( rec.filename, TRIMLOC( dev->filename ));

  0004d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 trimloc
  00063	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00069	48 8b d0	 mov	 rdx, rax
  0006c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR rec$[rsp+72]
  00071	e8 00 00 00 00	 call	 strlcpy

; 2879 :     rec.kl = (BYTE) kl;

  00076	0f b6 84 24 a8
	01 00 00	 movzx	 eax, BYTE PTR kl$[rsp]
  0007e	88 44 24 38	 mov	 BYTE PTR rec$[rsp+24], al

; 2880 :     memcpy( rec.key, key, kl );

  00082	48 8d 44 24 39	 lea	 rax, QWORD PTR rec$[rsp+25]
  00087	48 8b f8	 mov	 rdi, rax
  0008a	48 8b b4 24 b0
	01 00 00	 mov	 rsi, QWORD PTR key$[rsp]
  00092	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR kl$[rsp]
  0009a	f3 a4		 rep movsb

; 2881 :     return tf_write( NULL, &rec, sizeof( TF00423 ), 423 );

  0009c	66 41 b9 a7 01	 mov	 r9w, 423		; 000001a7H
  000a1	66 41 b8 48 01	 mov	 r8w, 328		; 00000148H
  000a6	48 8d 54 24 20	 lea	 rdx, QWORD PTR rec$[rsp]
  000ab	33 c9		 xor	 ecx, ecx
  000ad	e8 00 00 00 00	 call	 tf_write

; 2882 : }

  000b2	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  000c9	5f		 pop	 rdi
  000ca	5e		 pop	 rsi
  000cb	c3		 ret	 0
tf_0423	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv68 = 0
tv70 = 4
are_big_endian PROC

; 2495 : {

$LN7:
  00000	48 83 ec 18	 sub	 rsp, 24

; 2496 :     static union
; 2497 :     {
; 2498 :         uint32_t  ui32;
; 2499 :         char      b[4];
; 2500 :     }
; 2501 :     test = {0x01020304};
; 2502 :     return (0x01 == test.b[0]);

  00004	b8 01 00 00 00	 mov	 eax, 1
  00009	48 6b c0 00	 imul	 rax, rax, 0
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?test@?1??are_big_endian@@9@9
  00014	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00018	83 f8 01	 cmp	 eax, 1
  0001b	75 09		 jne	 SHORT $LN3@are_big_en
  0001d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00024	eb 07		 jmp	 SHORT $LN4@are_big_en
$LN3@are_big_en:
  00026	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN4@are_big_en:
  0002d	83 3c 24 00	 cmp	 DWORD PTR tv68[rsp], 0
  00031	75 0a		 jne	 SHORT $LN5@are_big_en
  00033	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0003b	eb 08		 jmp	 SHORT $LN6@are_big_en
$LN5@are_big_en:
  0003d	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN6@are_big_en:
  00045	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv70[rsp]

; 2503 : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
are_big_endian ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv93 = 256
tv131 = 260
tv137 = 264
tv143 = 268
tv149 = 272
tv155 = 276
tv161 = 280
tv167 = 284
tv173 = 288
tv179 = 292
tv185 = 296
tv191 = 300
tv197 = 304
tv203 = 308
tv209 = 312
tv215 = 316
orb$ = 384
buf$ = 392
bufsz$ = 400
FormatORB PROC

; 2440 : {

$LN39:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	55		 push	 rbp
  00011	56		 push	 rsi
  00012	57		 push	 rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H

; 2441 :     if (!buf)

  00020	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00029	75 07		 jne	 SHORT $LN2@FormatORB

; 2442 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 2c 05 00 00	 jmp	 $LN1@FormatORB
$LN2@FormatORB:

; 2443 : 
; 2444 :     if (bufsz)

  00032	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  0003b	74 0b		 je	 SHORT $LN3@FormatORB

; 2445 :         *buf = 0;

  0003d	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00045	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@FormatORB:

; 2446 : 
; 2447 :     if (bufsz <= 1 || !orb)

  00048	48 83 bc 24 90
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00051	76 0b		 jbe	 SHORT $LN5@FormatORB
  00053	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR orb$[rsp], 0
  0005c	75 0d		 jne	 SHORT $LN4@FormatORB
$LN5@FormatORB:

; 2448 :         return buf;

  0005e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00066	e9 f3 04 00 00	 jmp	 $LN1@FormatORB
$LN4@FormatORB:

; 2449 : 
; 2450 :     snprintf( buf, bufsz,

  0006b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  00073	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00077	83 e0 04	 and	 eax, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 0d		 je	 SHORT $LN7@FormatORB
  0007e	c7 84 24 00 01
	00 00 54 00 00
	00		 mov	 DWORD PTR tv93[rsp], 84	; 00000054H
  00089	eb 0b		 jmp	 SHORT $LN8@FormatORB
$LN7@FormatORB:
  0008b	c7 84 24 00 01
	00 00 43 00 00
	00		 mov	 DWORD PTR tv93[rsp], 67	; 00000043H
$LN8@FormatORB:
  00096	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0009e	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  000a2	83 e0 01	 and	 eax, 1
  000a5	85 c0		 test	 eax, eax
  000a7	74 0d		 je	 SHORT $LN9@FormatORB
  000a9	c7 84 24 04 01
	00 00 58 00 00
	00		 mov	 DWORD PTR tv131[rsp], 88 ; 00000058H
  000b4	eb 0b		 jmp	 SHORT $LN10@FormatORB
$LN9@FormatORB:
  000b6	c7 84 24 04 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv131[rsp], 46 ; 0000002eH
$LN10@FormatORB:
  000c1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  000c9	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  000cd	83 e0 40	 and	 eax, 64			; 00000040H
  000d0	85 c0		 test	 eax, eax
  000d2	74 0d		 je	 SHORT $LN11@FormatORB
  000d4	c7 84 24 08 01
	00 00 44 00 00
	00		 mov	 DWORD PTR tv137[rsp], 68 ; 00000044H
  000df	eb 0b		 jmp	 SHORT $LN12@FormatORB
$LN11@FormatORB:
  000e1	c7 84 24 08 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv137[rsp], 46 ; 0000002eH
$LN12@FormatORB:
  000ec	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  000f4	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  000f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fd	85 c0		 test	 eax, eax
  000ff	74 0d		 je	 SHORT $LN13@FormatORB
  00101	c7 84 24 0c 01
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv143[rsp], 76 ; 0000004cH
  0010c	eb 0b		 jmp	 SHORT $LN14@FormatORB
$LN13@FormatORB:
  0010e	c7 84 24 0c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv143[rsp], 46 ; 0000002eH
$LN14@FormatORB:
  00119	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  00121	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 0d		 je	 SHORT $LN15@FormatORB
  0012c	c7 84 24 10 01
	00 00 54 00 00
	00		 mov	 DWORD PTR tv149[rsp], 84 ; 00000054H
  00137	eb 0b		 jmp	 SHORT $LN16@FormatORB
$LN15@FormatORB:
  00139	c7 84 24 10 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv149[rsp], 46 ; 0000002eH
$LN16@FormatORB:
  00144	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0014c	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00150	83 e0 02	 and	 eax, 2
  00153	85 c0		 test	 eax, eax
  00155	74 0d		 je	 SHORT $LN17@FormatORB
  00157	c7 84 24 14 01
	00 00 48 00 00
	00		 mov	 DWORD PTR tv155[rsp], 72 ; 00000048H
  00162	eb 0b		 jmp	 SHORT $LN18@FormatORB
$LN17@FormatORB:
  00164	c7 84 24 14 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv155[rsp], 46 ; 0000002eH
$LN18@FormatORB:
  0016f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  00177	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0017b	83 e0 04	 and	 eax, 4
  0017e	85 c0		 test	 eax, eax
  00180	74 0d		 je	 SHORT $LN19@FormatORB
  00182	c7 84 24 18 01
	00 00 42 00 00
	00		 mov	 DWORD PTR tv161[rsp], 66 ; 00000042H
  0018d	eb 0b		 jmp	 SHORT $LN20@FormatORB
$LN19@FormatORB:
  0018f	c7 84 24 18 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv161[rsp], 46 ; 0000002eH
$LN20@FormatORB:
  0019a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  001a2	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  001a6	83 e0 08	 and	 eax, 8
  001a9	85 c0		 test	 eax, eax
  001ab	74 0d		 je	 SHORT $LN21@FormatORB
  001ad	c7 84 24 1c 01
	00 00 55 00 00
	00		 mov	 DWORD PTR tv167[rsp], 85 ; 00000055H
  001b8	eb 0b		 jmp	 SHORT $LN22@FormatORB
$LN21@FormatORB:
  001ba	c7 84 24 1c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv167[rsp], 46 ; 0000002eH
$LN22@FormatORB:
  001c5	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  001cd	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  001d1	83 e0 10	 and	 eax, 16
  001d4	85 c0		 test	 eax, eax
  001d6	74 0d		 je	 SHORT $LN23@FormatORB
  001d8	c7 84 24 20 01
	00 00 41 00 00
	00		 mov	 DWORD PTR tv173[rsp], 65 ; 00000041H
  001e3	eb 0b		 jmp	 SHORT $LN24@FormatORB
$LN23@FormatORB:
  001e5	c7 84 24 20 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv173[rsp], 46 ; 0000002eH
$LN24@FormatORB:
  001f0	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  001f8	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  001fc	83 e0 20	 and	 eax, 32			; 00000020H
  001ff	85 c0		 test	 eax, eax
  00201	74 0d		 je	 SHORT $LN25@FormatORB
  00203	c7 84 24 24 01
	00 00 49 00 00
	00		 mov	 DWORD PTR tv179[rsp], 73 ; 00000049H
  0020e	eb 0b		 jmp	 SHORT $LN26@FormatORB
$LN25@FormatORB:
  00210	c7 84 24 24 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv179[rsp], 46 ; 0000002eH
$LN26@FormatORB:
  0021b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  00223	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00227	83 e0 40	 and	 eax, 64			; 00000040H
  0022a	85 c0		 test	 eax, eax
  0022c	74 0d		 je	 SHORT $LN27@FormatORB
  0022e	c7 84 24 28 01
	00 00 50 00 00
	00		 mov	 DWORD PTR tv185[rsp], 80 ; 00000050H
  00239	eb 0b		 jmp	 SHORT $LN28@FormatORB
$LN27@FormatORB:
  0023b	c7 84 24 28 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv185[rsp], 46 ; 0000002eH
$LN28@FormatORB:
  00246	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0024e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00252	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00257	85 c0		 test	 eax, eax
  00259	74 0d		 je	 SHORT $LN29@FormatORB
  0025b	c7 84 24 2c 01
	00 00 46 00 00
	00		 mov	 DWORD PTR tv191[rsp], 70 ; 00000046H
  00266	eb 0b		 jmp	 SHORT $LN30@FormatORB
$LN29@FormatORB:
  00268	c7 84 24 2c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv191[rsp], 46 ; 0000002eH
$LN30@FormatORB:
  00273	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0027b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0027f	83 e0 01	 and	 eax, 1
  00282	85 c0		 test	 eax, eax
  00284	74 0d		 je	 SHORT $LN31@FormatORB
  00286	c7 84 24 30 01
	00 00 59 00 00
	00		 mov	 DWORD PTR tv197[rsp], 89 ; 00000059H
  00291	eb 0b		 jmp	 SHORT $LN32@FormatORB
$LN31@FormatORB:
  00293	c7 84 24 30 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv197[rsp], 46 ; 0000002eH
$LN32@FormatORB:
  0029e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  002a6	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  002aa	83 e0 02	 and	 eax, 2
  002ad	85 c0		 test	 eax, eax
  002af	74 0d		 je	 SHORT $LN33@FormatORB
  002b1	c7 84 24 34 01
	00 00 4d 00 00
	00		 mov	 DWORD PTR tv203[rsp], 77 ; 0000004dH
  002bc	eb 0b		 jmp	 SHORT $LN34@FormatORB
$LN33@FormatORB:
  002be	c7 84 24 34 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv203[rsp], 46 ; 0000002eH
$LN34@FormatORB:
  002c9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  002d1	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  002d5	83 e0 04	 and	 eax, 4
  002d8	85 c0		 test	 eax, eax
  002da	74 0d		 je	 SHORT $LN35@FormatORB
  002dc	c7 84 24 38 01
	00 00 43 00 00
	00		 mov	 DWORD PTR tv209[rsp], 67 ; 00000043H
  002e7	eb 0b		 jmp	 SHORT $LN36@FormatORB
$LN35@FormatORB:
  002e9	c7 84 24 38 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv209[rsp], 46 ; 0000002eH
$LN36@FormatORB:
  002f4	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  002fc	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00300	83 e0 08	 and	 eax, 8
  00303	85 c0		 test	 eax, eax
  00305	74 0d		 je	 SHORT $LN37@FormatORB
  00307	c7 84 24 3c 01
	00 00 53 00 00
	00		 mov	 DWORD PTR tv215[rsp], 83 ; 00000053H
  00312	eb 0b		 jmp	 SHORT $LN38@FormatORB
$LN37@FormatORB:
  00314	c7 84 24 3c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv215[rsp], 46 ; 0000002eH
$LN38@FormatORB:
  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	48 6b c0 03	 imul	 rax, rax, 3
  00328	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  00330	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  00335	b9 01 00 00 00	 mov	 ecx, 1
  0033a	48 6b c9 02	 imul	 rcx, rcx, 2
  0033e	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR orb$[rsp]
  00346	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  0034b	ba 01 00 00 00	 mov	 edx, 1
  00350	48 6b d2 01	 imul	 rdx, rdx, 1
  00354	4c 8b 84 24 80
	01 00 00	 mov	 r8, QWORD PTR orb$[rsp]
  0035c	41 0f b6 54 10
	08		 movzx	 edx, BYTE PTR [r8+rdx+8]
  00362	41 b8 01 00 00
	00		 mov	 r8d, 1
  00368	4d 6b c0 00	 imul	 r8, r8, 0
  0036c	4c 8b 8c 24 80
	01 00 00	 mov	 r9, QWORD PTR orb$[rsp]
  00374	47 0f b6 44 01
	08		 movzx	 r8d, BYTE PTR [r9+r8+8]
  0037a	4c 8b 8c 24 80
	01 00 00	 mov	 r9, QWORD PTR orb$[rsp]
  00382	45 0f b6 49 07	 movzx	 r9d, BYTE PTR [r9+7]
  00387	4c 8b 94 24 80
	01 00 00	 mov	 r10, QWORD PTR orb$[rsp]
  0038f	45 0f b6 52 05	 movzx	 r10d, BYTE PTR [r10+5]
  00394	4c 8b 9c 24 80
	01 00 00	 mov	 r11, QWORD PTR orb$[rsp]
  0039c	45 0f b6 5b 04	 movzx	 r11d, BYTE PTR [r11+4]
  003a1	41 81 e3 0f ff
	ff ff		 and	 r11d, -241		; ffffffffffffff0fH
  003a8	48 8b 9c 24 80
	01 00 00	 mov	 rbx, QWORD PTR orb$[rsp]
  003b0	0f b6 5b 06	 movzx	 ebx, BYTE PTR [rbx+6]
  003b4	48 8b bc 24 80
	01 00 00	 mov	 rdi, QWORD PTR orb$[rsp]
  003bc	0f b6 7f 04	 movzx	 edi, BYTE PTR [rdi+4]
  003c0	81 e7 f0 00 00
	00		 and	 edi, 240		; 000000f0H
  003c6	c1 ff 04	 sar	 edi, 4
  003c9	be 01 00 00 00	 mov	 esi, 1
  003ce	48 6b f6 03	 imul	 rsi, rsi, 3
  003d2	48 8b ac 24 80
	01 00 00	 mov	 rbp, QWORD PTR orb$[rsp]
  003da	0f b6 34 2e	 movzx	 esi, BYTE PTR [rsi+rbp]
  003de	bd 01 00 00 00	 mov	 ebp, 1
  003e3	48 6b ed 02	 imul	 rbp, rbp, 2
  003e7	4c 8b b4 24 80
	01 00 00	 mov	 r14, QWORD PTR orb$[rsp]
  003ef	41 0f b6 2c 2e	 movzx	 ebp, BYTE PTR [r14+rbp]
  003f4	41 be 01 00 00
	00		 mov	 r14d, 1
  003fa	4d 6b f6 01	 imul	 r14, r14, 1
  003fe	4c 8b bc 24 80
	01 00 00	 mov	 r15, QWORD PTR orb$[rsp]
  00406	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  0040b	41 bf 01 00 00
	00		 mov	 r15d, 1
  00411	4d 6b ff 00	 imul	 r15, r15, 0
  00415	4c 8b a4 24 80
	01 00 00	 mov	 r12, QWORD PTR orb$[rsp]
  0041d	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  00422	89 84 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], eax
  00429	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR [rsp+240], ecx
  00430	89 94 24 e8 00
	00 00		 mov	 DWORD PTR [rsp+232], edx
  00437	44 89 84 24 e0
	00 00 00	 mov	 DWORD PTR [rsp+224], r8d
  0043f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv93[rsp]
  00446	89 84 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], eax
  0044d	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv131[rsp]
  00454	89 84 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], eax
  0045b	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv137[rsp]
  00462	89 84 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], eax
  00469	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv143[rsp]
  00470	89 84 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], eax
  00477	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv149[rsp]
  0047e	89 84 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], eax
  00485	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv155[rsp]
  0048c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], eax
  00493	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv161[rsp]
  0049a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  004a1	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR tv167[rsp]
  004a8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  004af	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv173[rsp]
  004b6	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  004bd	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv179[rsp]
  004c4	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  004cb	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv185[rsp]
  004d2	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  004d9	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv191[rsp]
  004e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  004e7	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  004ee	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  004f2	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv203[rsp]
  004f9	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  004fd	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR tv209[rsp]
  00504	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00508	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR tv215[rsp]
  0050f	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00513	44 89 4c 24 58	 mov	 DWORD PTR [rsp+88], r9d
  00518	44 89 54 24 50	 mov	 DWORD PTR [rsp+80], r10d
  0051d	44 89 5c 24 48	 mov	 DWORD PTR [rsp+72], r11d
  00522	89 5c 24 40	 mov	 DWORD PTR [rsp+64], ebx
  00526	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  0052a	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  0052e	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  00532	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00537	45 8b cf	 mov	 r9d, r15d
  0053a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160072
  00541	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00549	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00551	e8 00 00 00 00	 call	 w32_snprintf

; 2451 : 
; 2452 :         "IntP:%2.2X%2.2X%2.2X%2.2X Key:%d LPM:%2.2X "
; 2453 :         "Flags:%X%2.2X%2.2X %c%c%c%c%c%c%c%c%c%c%c%c %c%c.....%c "
; 2454 :         "%cCW:%2.2X%2.2X%2.2X%2.2X"
; 2455 : 
; 2456 :         , orb->intparm[0], orb->intparm[1], orb->intparm[2], orb->intparm[3]
; 2457 :         , (orb->flag4 & ORB4_KEY) >> 4
; 2458 :         , orb->lpm
; 2459 : 
; 2460 :         , (orb->flag4 & ~ORB4_KEY)
; 2461 :         , orb->flag5
; 2462 :         , orb->flag7
; 2463 : 
; 2464 :         , ( orb->flag4 & ORB4_S ) ? 'S' : '.'
; 2465 :         , ( orb->flag4 & ORB4_C ) ? 'C' : '.'
; 2466 :         , ( orb->flag4 & ORB4_M ) ? 'M' : '.'
; 2467 :         , ( orb->flag4 & ORB4_Y ) ? 'Y' : '.'
; 2468 : 
; 2469 :         , ( orb->flag5 & ORB5_F ) ? 'F' : '.'
; 2470 :         , ( orb->flag5 & ORB5_P ) ? 'P' : '.'
; 2471 :         , ( orb->flag5 & ORB5_I ) ? 'I' : '.'
; 2472 :         , ( orb->flag5 & ORB5_A ) ? 'A' : '.'
; 2473 : 
; 2474 :         , ( orb->flag5 & ORB5_U ) ? 'U' : '.'
; 2475 :         , ( orb->flag5 & ORB5_B ) ? 'B' : '.'
; 2476 :         , ( orb->flag5 & ORB5_H ) ? 'H' : '.'
; 2477 :         , ( orb->flag5 & ORB5_T ) ? 'T' : '.'
; 2478 : 
; 2479 :         , ( orb->flag7 & ORB7_L ) ? 'L' : '.'
; 2480 :         , ( orb->flag7 & ORB7_D ) ? 'D' : '.'
; 2481 :         , ( orb->flag7 & ORB7_X ) ? 'X' : '.'
; 2482 : 
; 2483 :         , ( orb->flag5 & ORB5_B ) ? 'T' : 'C'  // (TCW or CCW)
; 2484 : 
; 2485 :         , orb->ccwaddr[0], orb->ccwaddr[1], orb->ccwaddr[2], orb->ccwaddr[3]
; 2486 :     );
; 2487 : 
; 2488 :     return buf;

  00556	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatORB:

; 2489 : }

  0055e	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  00565	41 5f		 pop	 r15
  00567	41 5e		 pop	 r14
  00569	41 5c		 pop	 r12
  0056b	5f		 pop	 rdi
  0056c	5e		 pop	 rsi
  0056d	5d		 pop	 rbp
  0056e	5b		 pop	 rbx
  0056f	c3		 ret	 0
FormatORB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv65 = 32
name$ = 40
perc$ = 64
buf$ = 72
bufsiz$ = 80
perc2name PROC

; 2291 : {   /*

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2292 :            Hex    Bit   PER Event
; 2293 :             80     0    Successful-branching 
; 2294 :             40     1    Instruction-fetching
; 2295 :             20     2    Storage-alteration
; 2296 :             10     3    Storage-key-alteration
; 2297 :             08     4    Store-using-real-address 
; 2298 :             04     5    Zero-address-detection 
; 2299 :             02     6    Transaction-end
; 2300 :             01     7    Instruction-fetching nullification (PER-3) */
; 2301 : 
; 2302 :     const char* name;
; 2303 : 
; 2304 :     switch (perc)

  00012	0f b6 44 24 40	 movzx	 eax, BYTE PTR perc$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001b	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  0001f	ff c8		 dec	 eax
  00021	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00025	83 7c 24 20 7f	 cmp	 DWORD PTR tv65[rsp], 127 ; 0000007fH
  0002a	0f 87 c0 00 00
	00		 ja	 $LN15@perc2name
  00030	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv65[rsp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0003c	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN17@perc2name[rcx+rax]
  00044	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@perc2name[rcx+rax*4]
  0004b	48 03 c1	 add	 rax, rcx
  0004e	ff e0		 jmp	 rax
$LN4@perc2name:

; 2305 :     {
; 2306 :         /*-----------------------------------------------------------*/
; 2307 :         /*               Basic single-bit events...                  */
; 2308 :         /*-----------------------------------------------------------*/
; 2309 : 
; 2310 :         case 0x80:
; 2311 :         {
; 2312 :             name = "BRANCH";

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160037
  00057	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2313 :             break;

  0005c	e9 9b 00 00 00	 jmp	 $LN2@perc2name
$LN5@perc2name:

; 2314 :         }
; 2315 : 
; 2316 :         case 0x40:
; 2317 :         {
; 2318 :             name = "IFETCH";

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160039
  00068	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2319 :             break;

  0006d	e9 8a 00 00 00	 jmp	 $LN2@perc2name
$LN6@perc2name:

; 2320 :         }
; 2321 : 
; 2322 :         case 0x20:
; 2323 :         {
; 2324 :             name = "STOR";

  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160041
  00079	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2325 :             break;

  0007e	eb 7c		 jmp	 SHORT $LN2@perc2name
$LN7@perc2name:

; 2326 :         }
; 2327 : 
; 2328 :         case 0x10:
; 2329 :         {
; 2330 :             /* NOTE: docs say: "A zero is stored in bit position 3 of
; 2331 :                locations 150-151", so this SHOULDN'T(?) occur, but if
; 2332 :                for some reason it does, let's return an indication.
; 2333 :             */
; 2334 :             name = "SKEY";

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160043
  00087	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2335 :             break;

  0008c	eb 6e		 jmp	 SHORT $LN2@perc2name
$LN8@perc2name:

; 2336 :         }
; 2337 : 
; 2338 : #if 0 // (probably illegal? i.e. should never occur? See 0x28 below!)
; 2339 : 
; 2340 :         case 0x08:
; 2341 :         {
; 2342 :             name = "STURA";
; 2343 :             break;
; 2344 :         }
; 2345 : #endif
; 2346 :         case 0x04:
; 2347 :         {
; 2348 :             name = "ZAD";

  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160045
  00095	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2349 :             break;

  0009a	eb 60		 jmp	 SHORT $LN2@perc2name
$LN9@perc2name:

; 2350 :         }
; 2351 : 
; 2352 :         case 0x02:
; 2353 :         {
; 2354 :             name = "TEND";

  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160047
  000a3	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2355 :             break;

  000a8	eb 52		 jmp	 SHORT $LN2@perc2name
$LN10@perc2name:

; 2356 :         }
; 2357 : 
; 2358 :         case 0x01:
; 2359 :         {
; 2360 :             name = "IFNULL";

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160049
  000b1	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2361 :             break;

  000b6	eb 44		 jmp	 SHORT $LN2@perc2name
$LN11@perc2name:

; 2362 :         }
; 2363 : 
; 2364 :         /*-----------------------------------------------------------*/
; 2365 :         /*    Exceptions to the rule requiring special handling      */
; 2366 :         /*-----------------------------------------------------------*/
; 2367 : 
; 2368 :         case 0x24:
; 2369 :         {
; 2370 :             /* "... when ... a storage-alteration ... event is re-
; 2371 :                cognized concurrently with a zero-address-detection
; 2372 :                event, only the storage alteration ... event is in-
; 2373 :                dicated." (Not sure whether that means ONLY the 0x20
; 2374 :                storage alteration bit is set, or whether the "event"
; 2375 :                should simply be TREATED AS a storage event, so to
; 2376 :                be safe, we'll code for it.)
; 2377 :             */
; 2378 :             name = "STOR";

  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160051
  000bf	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2379 :             break;

  000c4	eb 36		 jmp	 SHORT $LN2@perc2name
$LN12@perc2name:

; 2380 :         }
; 2381 : 
; 2382 :         case 0x28:
; 2383 :         {
; 2384 :             /* "... while ones in bit positions 2 and 4 indicate a
; 2385 :                store-using-real-address event."
; 2386 :             */
; 2387 :             name = "STURA";

  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160053
  000cd	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2388 :             break;

  000d2	eb 28		 jmp	 SHORT $LN2@perc2name
$LN13@perc2name:

; 2389 :         }
; 2390 : 
; 2391 : #if 0 // (probbaly illegal? i.e. should never occur?)
; 2392 : 
; 2393 :         case 0x2C:
; 2394 :         {
; 2395 :             /* "... when ... store-using-real-address event is re-
; 2396 :                cognized concurrently with a zero-address-detection
; 2397 :                event, only the ... store-using-real-address event
; 2398 :                is indicated."
; 2399 :             */
; 2400 :             name = "STURA";
; 2401 :             break;
; 2402 :         }
; 2403 : #endif
; 2404 :         case 0x41:
; 2405 :         {
; 2406 :             /* "When a program interruption occurs for a PER instruc-
; 2407 :                tion fetching nullification event, bits 1 and 7 are set
; 2408 :                to one in the PER code. No other PER events are concur-
; 2409 :                rently indicated.
; 2410 :             */
; 2411 :             name = "IFETCH+IFNULL";

  000d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160055
  000db	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2412 :             break;

  000e0	eb 1a		 jmp	 SHORT $LN2@perc2name
$LN14@perc2name:

; 2413 :         }
; 2414 : 
; 2415 :         case 0x42:
; 2416 :         {
; 2417 :             /* "If an instruction-fetching basic event coincides with
; 2418 :                the transaction-end event, bit 1 is also set to one
; 2419 :                in the PER code."
; 2420 :             */
; 2421 :             name = "IFETCH+TEND";

  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160057
  000e9	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 2422 :             break;

  000ee	eb 0c		 jmp	 SHORT $LN2@perc2name
$LN15@perc2name:

; 2423 :         }
; 2424 : 
; 2425 :         default:
; 2426 :         {
; 2427 :             name = "UNKNOWN!";

  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160059
  000f7	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax
$LN2@perc2name:

; 2428 :             break;
; 2429 :         }
; 2430 :     }
; 2431 : 
; 2432 :     strlcpy( buf, name, bufsiz );

  000fc	4c 8b 44 24 50	 mov	 r8, QWORD PTR bufsiz$[rsp]
  00101	48 8b 54 24 28	 mov	 rdx, QWORD PTR name$[rsp]
  00106	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0010b	e8 00 00 00 00	 call	 strlcpy

; 2433 :     return buf;

  00110	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]

; 2434 : }

  00115	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00119	c3		 ret	 0
  0011a	66 90		 npad	 2
$LN18@perc2name:
  0011c	00 00 00 00	 DD	 $LN10@perc2name
  00120	00 00 00 00	 DD	 $LN9@perc2name
  00124	00 00 00 00	 DD	 $LN8@perc2name
  00128	00 00 00 00	 DD	 $LN7@perc2name
  0012c	00 00 00 00	 DD	 $LN6@perc2name
  00130	00 00 00 00	 DD	 $LN11@perc2name
  00134	00 00 00 00	 DD	 $LN12@perc2name
  00138	00 00 00 00	 DD	 $LN5@perc2name
  0013c	00 00 00 00	 DD	 $LN13@perc2name
  00140	00 00 00 00	 DD	 $LN14@perc2name
  00144	00 00 00 00	 DD	 $LN4@perc2name
  00148	00 00 00 00	 DD	 $LN15@perc2name
$LN17@perc2name:
  0014c	00		 DB	 0
  0014d	01		 DB	 1
  0014e	0b		 DB	 11
  0014f	02		 DB	 2
  00150	0b		 DB	 11
  00151	0b		 DB	 11
  00152	0b		 DB	 11
  00153	0b		 DB	 11
  00154	0b		 DB	 11
  00155	0b		 DB	 11
  00156	0b		 DB	 11
  00157	0b		 DB	 11
  00158	0b		 DB	 11
  00159	0b		 DB	 11
  0015a	0b		 DB	 11
  0015b	03		 DB	 3
  0015c	0b		 DB	 11
  0015d	0b		 DB	 11
  0015e	0b		 DB	 11
  0015f	0b		 DB	 11
  00160	0b		 DB	 11
  00161	0b		 DB	 11
  00162	0b		 DB	 11
  00163	0b		 DB	 11
  00164	0b		 DB	 11
  00165	0b		 DB	 11
  00166	0b		 DB	 11
  00167	0b		 DB	 11
  00168	0b		 DB	 11
  00169	0b		 DB	 11
  0016a	0b		 DB	 11
  0016b	04		 DB	 4
  0016c	0b		 DB	 11
  0016d	0b		 DB	 11
  0016e	0b		 DB	 11
  0016f	05		 DB	 5
  00170	0b		 DB	 11
  00171	0b		 DB	 11
  00172	0b		 DB	 11
  00173	06		 DB	 6
  00174	0b		 DB	 11
  00175	0b		 DB	 11
  00176	0b		 DB	 11
  00177	0b		 DB	 11
  00178	0b		 DB	 11
  00179	0b		 DB	 11
  0017a	0b		 DB	 11
  0017b	0b		 DB	 11
  0017c	0b		 DB	 11
  0017d	0b		 DB	 11
  0017e	0b		 DB	 11
  0017f	0b		 DB	 11
  00180	0b		 DB	 11
  00181	0b		 DB	 11
  00182	0b		 DB	 11
  00183	0b		 DB	 11
  00184	0b		 DB	 11
  00185	0b		 DB	 11
  00186	0b		 DB	 11
  00187	0b		 DB	 11
  00188	0b		 DB	 11
  00189	0b		 DB	 11
  0018a	0b		 DB	 11
  0018b	07		 DB	 7
  0018c	08		 DB	 8
  0018d	09		 DB	 9
  0018e	0b		 DB	 11
  0018f	0b		 DB	 11
  00190	0b		 DB	 11
  00191	0b		 DB	 11
  00192	0b		 DB	 11
  00193	0b		 DB	 11
  00194	0b		 DB	 11
  00195	0b		 DB	 11
  00196	0b		 DB	 11
  00197	0b		 DB	 11
  00198	0b		 DB	 11
  00199	0b		 DB	 11
  0019a	0b		 DB	 11
  0019b	0b		 DB	 11
  0019c	0b		 DB	 11
  0019d	0b		 DB	 11
  0019e	0b		 DB	 11
  0019f	0b		 DB	 11
  001a0	0b		 DB	 11
  001a1	0b		 DB	 11
  001a2	0b		 DB	 11
  001a3	0b		 DB	 11
  001a4	0b		 DB	 11
  001a5	0b		 DB	 11
  001a6	0b		 DB	 11
  001a7	0b		 DB	 11
  001a8	0b		 DB	 11
  001a9	0b		 DB	 11
  001aa	0b		 DB	 11
  001ab	0b		 DB	 11
  001ac	0b		 DB	 11
  001ad	0b		 DB	 11
  001ae	0b		 DB	 11
  001af	0b		 DB	 11
  001b0	0b		 DB	 11
  001b1	0b		 DB	 11
  001b2	0b		 DB	 11
  001b3	0b		 DB	 11
  001b4	0b		 DB	 11
  001b5	0b		 DB	 11
  001b6	0b		 DB	 11
  001b7	0b		 DB	 11
  001b8	0b		 DB	 11
  001b9	0b		 DB	 11
  001ba	0b		 DB	 11
  001bb	0b		 DB	 11
  001bc	0b		 DB	 11
  001bd	0b		 DB	 11
  001be	0b		 DB	 11
  001bf	0b		 DB	 11
  001c0	0b		 DB	 11
  001c1	0b		 DB	 11
  001c2	0b		 DB	 11
  001c3	0b		 DB	 11
  001c4	0b		 DB	 11
  001c5	0b		 DB	 11
  001c6	0b		 DB	 11
  001c7	0b		 DB	 11
  001c8	0b		 DB	 11
  001c9	0b		 DB	 11
  001ca	0b		 DB	 11
  001cb	0a		 DB	 10
perc2name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv69 = 0
order$ = 32
order2name PROC

; 2257 : {

$LN5:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 2258 : static const char *ordername[] =
; 2259 : {
; 2260 : /* 0x00                          */  "Unassigned",
; 2261 : /* 0x01 SIGP_SENSE               */  "Sense",
; 2262 : /* 0x02 SIGP_EXTCALL             */  "External call",
; 2263 : /* 0x03 SIGP_EMERGENCY           */  "Emergency signal",
; 2264 : /* 0x04 SIGP_START               */  "Start",
; 2265 : /* 0x05 SIGP_STOP                */  "Stop",
; 2266 : /* 0x06 SIGP_RESTART             */  "Restart",
; 2267 : /* 0x07 SIGP_IPR                 */  "Initial program reset",
; 2268 : /* 0x08 SIGP_PR                  */  "Program reset",
; 2269 : /* 0x09 SIGP_STOPSTORE           */  "Stop and store status",
; 2270 : /* 0x0A SIGP_IMPL                */  "Initial microprogram load",
; 2271 : /* 0x0B SIGP_INITRESET           */  "Initial CPU reset",
; 2272 : /* 0x0C SIGP_RESET               */  "CPU reset",
; 2273 : /* 0x0D SIGP_SETPREFIX           */  "Set prefix",
; 2274 : /* 0x0E SIGP_STORE               */  "Store status",
; 2275 : /* 0x0F                          */  "Unassigned",
; 2276 : /* 0x10                          */  "Unassigned",
; 2277 : /* 0x11 SIGP_STOREX              */  "Store extended status at address",
; 2278 : /* 0x12 SIGP_SETARCH             */  "Set architecture mode",
; 2279 : /* 0x13 SIGP_COND_EMERGENCY      */  "Conditional emergency",
; 2280 : /* 0x14                          */  "Unassigned",
; 2281 : /* 0x15 SIGP_SENSE_RUNNING_STATE */  "Sense running state"
; 2282 : };
; 2283 :     return (order >= _countof( ordername )) ?

  00008	0f b6 44 24 20	 movzx	 eax, BYTE PTR order$[rsp]
  0000d	48 83 f8 16	 cmp	 rax, 22
  00011	72 0d		 jb	 SHORT $LN3@order2name
  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160025
  0001a	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
  0001e	eb 14		 jmp	 SHORT $LN4@order2name
$LN3@order2name:
  00020	0f b6 44 24 20	 movzx	 eax, BYTE PTR order$[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ordername@?1??order2name@@9@9
  0002c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00030	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@order2name:
  00034	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]

; 2284 :         "Unassigned" : ordername[ order ];
; 2285 : }

  00038	48 83 c4 18	 add	 rsp, 24
  0003c	c3		 ret	 0
order2name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
code$ = 0
ndx$ = 4
tv75 = 8
pcode$ = 32
PIC2Name PROC

; 2168 : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 2169 :     static const char* pgmintname[] =
; 2170 :     {
; 2171 :         /* 01 */    "Operation exception",
; 2172 :         /* 02 */    "Privileged-operation exception",
; 2173 :         /* 03 */    "Execute exception",
; 2174 :         /* 04 */    "Protection exception",
; 2175 :         /* 05 */    "Addressing exception",
; 2176 :         /* 06 */    "Specification exception",
; 2177 :         /* 07 */    "Data exception",
; 2178 :         /* 08 */    "Fixed-point-overflow exception",
; 2179 :         /* 09 */    "Fixed-point-divide exception",
; 2180 :         /* 0A */    "Decimal-overflow exception",
; 2181 :         /* 0B */    "Decimal-divide exception",
; 2182 :         /* 0C */    "HFP-exponent-overflow exception",
; 2183 :         /* 0D */    "HFP-exponent-underflow exception",
; 2184 :         /* 0E */    "HFP-significance exception",
; 2185 :         /* 0F */    "HFP-floating-point-divide exception",
; 2186 :         /* 10 */    "Segment-translation exception",
; 2187 :         /* 11 */    "Page-translation exception",
; 2188 :         /* 12 */    "Translation-specification exception",
; 2189 :         /* 13 */    "Special-operation exception",
; 2190 :         /* 14 */    "Pseudo-page-fault exception",
; 2191 :         /* 15 */    "Operand exception",
; 2192 :         /* 16 */    "Trace-table exception",
; 2193 :         /* 17 */    "ASN-translation exception",
; 2194 :         /* 18 */    "Transaction constraint exception",
; 2195 :         /* 19 */    "Vector/Crypto operation exception",
; 2196 :         /* 1A */    "Page state exception",
; 2197 :         /* 1B */    "Vector processing exception",
; 2198 :         /* 1C */    "Space-switch event",
; 2199 :         /* 1D */    "Square-root exception",
; 2200 :         /* 1E */    "Unnormalized-operand exception",
; 2201 :         /* 1F */    "PC-translation specification exception",
; 2202 :         /* 20 */    "AFX-translation exception",
; 2203 :         /* 21 */    "ASX-translation exception",
; 2204 :         /* 22 */    "LX-translation exception",
; 2205 :         /* 23 */    "EX-translation exception",
; 2206 :         /* 24 */    "Primary-authority exception",
; 2207 :         /* 25 */    "Secondary-authority exception",
; 2208 :         /* 26 */ /* "Page-fault-assist exception",          */
; 2209 :         /* 26 */    "LFX-translation exception",
; 2210 :         /* 27 */ /* "Control-switch exception",             */
; 2211 :         /* 27 */    "LSX-translation exception",
; 2212 :         /* 28 */    "ALET-specification exception",
; 2213 :         /* 29 */    "ALEN-translation exception",
; 2214 :         /* 2A */    "ALE-sequence exception",
; 2215 :         /* 2B */    "ASTE-validity exception",
; 2216 :         /* 2C */    "ASTE-sequence exception",
; 2217 :         /* 2D */    "Extended-authority exception",
; 2218 :         /* 2E */    "LSTE-sequence exception",
; 2219 :         /* 2F */    "ASTE-instance exception",
; 2220 :         /* 30 */    "Stack-full exception",
; 2221 :         /* 31 */    "Stack-empty exception",
; 2222 :         /* 32 */    "Stack-specification exception",
; 2223 :         /* 33 */    "Stack-type exception",
; 2224 :         /* 34 */    "Stack-operation exception",
; 2225 :         /* 35 */    "Unassigned exception",
; 2226 :         /* 36 */    "Unassigned exception",
; 2227 :         /* 37 */    "Unassigned exception",
; 2228 :         /* 38 */    "ASCE-type exception",
; 2229 :         /* 39 */    "Region-first-translation exception",
; 2230 :         /* 3A */    "Region-second-translation exception",
; 2231 :         /* 3B */    "Region-third-translation exception",
; 2232 :         /* 3C */    "Unassigned exception",
; 2233 :         /* 3D */    "Unassigned exception",
; 2234 :         /* 3E */    "Unassigned exception",
; 2235 :         /* 3F */    "Unassigned exception",
; 2236 :         /* 40 */    "Monitor event"
; 2237 :     };
; 2238 : 
; 2239 :     int ndx, code = (pcode & 0xFF);

  00008	8b 44 24 20	 mov	 eax, DWORD PTR pcode$[rsp]
  0000c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00011	89 04 24	 mov	 DWORD PTR code$[rsp], eax

; 2240 : 
; 2241 :     if (code == 0x80)

  00014	81 3c 24 80 00
	00 00		 cmp	 DWORD PTR code$[rsp], 128 ; 00000080H
  0001b	75 09		 jne	 SHORT $LN2@PIC2Name

; 2242 :         return "PER event";

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159993
  00024	eb 57		 jmp	 SHORT $LN1@PIC2Name
$LN2@PIC2Name:

; 2243 : 
; 2244 :     if (code < 1 || code > (int) _countof( pgmintname ))

  00026	83 3c 24 01	 cmp	 DWORD PTR code$[rsp], 1
  0002a	7c 06		 jl	 SHORT $LN4@PIC2Name
  0002c	83 3c 24 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  00030	7e 09		 jle	 SHORT $LN3@PIC2Name
$LN4@PIC2Name:

; 2245 :         return "Unassigned exception";

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159996
  00039	eb 42		 jmp	 SHORT $LN1@PIC2Name
$LN3@PIC2Name:

; 2246 : 
; 2247 :     ndx = ((code - 1) & 0x3F);

  0003b	8b 04 24	 mov	 eax, DWORD PTR code$[rsp]
  0003e	ff c8		 dec	 eax
  00040	83 e0 3f	 and	 eax, 63			; 0000003fH
  00043	89 44 24 04	 mov	 DWORD PTR ndx$[rsp], eax

; 2248 : 
; 2249 :     return (ndx >= 0 && ndx < (int) _countof( pgmintname )) ?

  00047	83 7c 24 04 00	 cmp	 DWORD PTR ndx$[rsp], 0
  0004c	7c 1e		 jl	 SHORT $LN6@PIC2Name
  0004e	83 7c 24 04 40	 cmp	 DWORD PTR ndx$[rsp], 64	; 00000040H
  00053	7d 17		 jge	 SHORT $LN6@PIC2Name
  00055	48 63 44 24 04	 movsxd	 rax, DWORD PTR ndx$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?pgmintname@?1??PIC2Name@@9@9
  00061	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00065	48 89 44 24 08	 mov	 QWORD PTR tv75[rsp], rax
  0006a	eb 0c		 jmp	 SHORT $LN7@PIC2Name
$LN6@PIC2Name:
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159997
  00073	48 89 44 24 08	 mov	 QWORD PTR tv75[rsp], rax
$LN7@PIC2Name:
  00078	48 8b 44 24 08	 mov	 rax, QWORD PTR tv75[rsp]
$LN1@PIC2Name:

; 2250 :         pgmintname[ ndx ] : "Unassigned exception";
; 2251 : }

  0007d	48 83 c4 18	 add	 rsp, 24
  00081	c3		 ret	 0
PIC2Name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
b0$ = 0
b1$ = 1
b3$ = 2
b2$ = 3
b4567$ = 4
b4$ = 8
b23$ = 12
tv64 = 16
b567$ = 20
tv163 = 24
psw64$ = 32
p$1 = 40
psw$ = 64
real_ilc$ = 72
arch$ = 80
bc$ = 88
do_make_psw64 PROC

; 1985 : {

$LN20:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1986 :     /* Return first/only 64-bit DWORD of the PSW -- IN HOST FORMAT!
; 1987 : 
; 1988 :        Caller is responsible for doing the STORE_DW on the returned
; 1989 :        value, which does a CSWAP to place it into guest storage in
; 1990 :        proper big endian format. The 900 mode caller (i.e. z/Arch)
; 1991 :        is also responsible for doing the store of the second DWORD
; 1992 :        of the 16-byte z/Arch PSW = the 64-bit instruction address.
; 1993 :     */
; 1994 : 
; 1995 :     BYTE  b0, b1, b2, b3, b4;
; 1996 :     U16   b23;
; 1997 :     U32   b567, b4567;
; 1998 :     U64   psw64 = 0;

  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR psw64$[rsp], 0

; 1999 : 
; 2000 :     switch (arch)

  00020	8b 44 24 50	 mov	 eax, DWORD PTR arch$[rsp]
  00024	89 44 24 10	 mov	 DWORD PTR tv64[rsp], eax
  00028	81 7c 24 10 72
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 370 ; 00000172H
  00030	74 21		 je	 SHORT $LN7@do_make_ps
  00032	81 7c 24 10 86
	01 00 00	 cmp	 DWORD PTR tv64[rsp], 390 ; 00000186H
  0003a	0f 84 de 00 00
	00		 je	 $LN10@do_make_ps
  00040	81 7c 24 10 84
	03 00 00	 cmp	 DWORD PTR tv64[rsp], 900 ; 00000384H
  00048	0f 84 d1 01 00
	00		 je	 $LN13@do_make_ps
  0004e	e9 a0 02 00 00	 jmp	 $LN16@do_make_ps
$LN7@do_make_ps:

; 2001 :     {
; 2002 :         case 370:
; 2003 : 
; 2004 :         if (bc) {

  00053	0f b6 44 24 58	 movzx	 eax, BYTE PTR bc$[rsp]
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 be 00 00
	00		 je	 $LN8@do_make_ps

; 2005 :             //                      370 BC-mode
; 2006 :             //
; 2007 :             //     +---------------+---+-----+------+---------------+----
; 2008 :             //     | channel masks | E | key | 0MWP | interupt code | ..
; 2009 :             //     +---------------+---+-----+------+---------------+----
; 2010 :             //     0               7   8     12     16             31
; 2011 : 
; 2012 :             //  ---+-----+----+------+------------------------------+
; 2013 :             //   ..| ilc | cc | mask |     instruction address      |
; 2014 :             //  ---+-----+----+------+------------------------------+
; 2015 :             //     32    34   36     40                            63
; 2016 : 
; 2017 :             b0 = psw->sysmask;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 04 24	 mov	 BYTE PTR b0$[rsp], al

; 2018 : 
; 2019 :             b1 = 0

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00070	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  00079	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0007d	0b c1		 or	 eax, ecx
  0007f	88 44 24 01	 mov	 BYTE PTR b1$[rsp], al

; 2020 :                  | psw->pkey
; 2021 :                  | psw->states
; 2022 :                  ;
; 2023 : 
; 2024 :             b23 = psw->intcode;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00088	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0008c	66 89 44 24 0c	 mov	 WORD PTR b23$[rsp], ax

; 2025 : 
; 2026 :             b4 = 0

  00091	0f b6 44 24 48	 movzx	 eax, BYTE PTR real_ilc$[rsp]
  00096	c1 e0 06	 shl	 eax, 6
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  0009e	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  000a2	c1 e1 04	 shl	 ecx, 4
  000a5	0b c1		 or	 eax, ecx
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  000ac	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  000b0	0b c1		 or	 eax, ecx
  000b2	88 44 24 08	 mov	 BYTE PTR b4$[rsp], al

; 2027 :                  | (real_ilc     << 6)
; 2028 :                  | (psw->cc << 4)
; 2029 :                  |  psw->progmask
; 2030 :                  ;
; 2031 : 
; 2032 :             b567 = psw->IA_L;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  000bb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000be	89 44 24 14	 mov	 DWORD PTR b567$[rsp], eax

; 2033 : 
; 2034 :             if (!psw->zeroilc)

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  000c7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ca	c1 e8 02	 shr	 eax, 2
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	75 0d		 jne	 SHORT $LN9@do_make_ps

; 2035 :                 b567 &= AMASK24;

  000d4	8b 44 24 14	 mov	 eax, DWORD PTR b567$[rsp]
  000d8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000dd	89 44 24 14	 mov	 DWORD PTR b567$[rsp], eax
$LN9@do_make_ps:

; 2036 : 
; 2037 :             psw64 = 0

  000e1	0f b6 04 24	 movzx	 eax, BYTE PTR b0$[rsp]
  000e5	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  000e9	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR b1$[rsp]
  000ee	48 c1 e1 30	 shl	 rcx, 48			; 00000030H
  000f2	48 0b c1	 or	 rax, rcx
  000f5	0f b7 4c 24 0c	 movzx	 ecx, WORD PTR b23$[rsp]
  000fa	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  000fe	48 0b c1	 or	 rax, rcx
  00101	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR b4$[rsp]
  00106	48 c1 e1 18	 shl	 rcx, 24
  0010a	48 0b c1	 or	 rax, rcx
  0010d	8b 4c 24 14	 mov	 ecx, DWORD PTR b567$[rsp]
  00111	48 0b c1	 or	 rax, rcx
  00114	48 89 44 24 20	 mov	 QWORD PTR psw64$[rsp], rax

; 2038 :                     | ( (U64) b0   << (64-(1*8)) )
; 2039 :                     | ( (U64) b1   << (64-(2*8)) )
; 2040 :                     | ( (U64) b23  << (64-(4*8)) )
; 2041 :                     | ( (U64) b4   << (64-(5*8)) )
; 2042 :                     | ( (U64) b567 << (64-(8*8)) )
; 2043 :                     ;
; 2044 :             break;

  00119	e9 ec 01 00 00	 jmp	 $LN2@do_make_ps
$LN8@do_make_ps:
$LN10@do_make_ps:

; 2045 :         }
; 2046 : 
; 2047 :         /* Not 370 BC-mode = 370 EC-mode. Fall through to the 390 case,
; 2048 :            which handles both ESA/390 mode and S/370 EC-mode PSWs too.
; 2049 : 
; 2050 :            The below special "FALLTHRU" comment lets GCC know that we are
; 2051 :            purposely falling through to the next switch case and is needed
; 2052 :            in order to suppress the warning that GCC would otherwise issue.
; 2053 :         */
; 2054 :         /* FALLTHRU */
; 2055 : 
; 2056 :         case 390:
; 2057 :             //                      370 EC-mode
; 2058 :             //
; 2059 :             //     +------+------+-----+------+----+----+------+----------+---
; 2060 :             //     | 0R00 | 0TIE | key | 1MWP | S0 | cc | mask | 00000000 | ..
; 2061 :             //     +------+------+-----+------+----+----+------+----------+---
; 2062 :             //     0      4      8     12     16   18   20     24
; 2063 : 
; 2064 :             //  ---+----------+-------------------------------------------+
; 2065 :             //   ..| 00000000 |       instruction address                 |  (370)
; 2066 :             //  ---+----------+-------------------------------------------+
; 2067 :             //     32         40                                         63
; 2068 :             //
; 2069 :             //                        ESA/390
; 2070 :             //
; 2071 :             //     +------+------+-----+------+----+----+------+----------+---
; 2072 :             //     | 0R00 | 0TIE | key | 1MWP | AS | cc | mask | 00000000 | ..
; 2073 :             //     +------+------+-----+------+----+----+------+----------+---
; 2074 :             //     0      4      8     12     16   18   20     24
; 2075 :             //
; 2076 :             //  ---+---+--------------------------------------------------+
; 2077 :             //   ..| A |              instruction address                 |  (390)
; 2078 :             //  ---+---+--------------------------------------------------+
; 2079 :             //     32  33                                                63
; 2080 : 
; 2081 :             b0 = psw->sysmask;

  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00123	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00126	88 04 24	 mov	 BYTE PTR b0$[rsp], al

; 2082 : 
; 2083 :             b1 = 0

  00129	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  0012e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  00137	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0013b	0b c1		 or	 eax, ecx
  0013d	88 44 24 01	 mov	 BYTE PTR b1$[rsp], al

; 2084 :                  | psw->pkey
; 2085 :                  | psw->states
; 2086 :                  ;
; 2087 : 
; 2088 :             b2 = 0

  00141	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00146	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0014a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  0014f	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00153	c1 e1 04	 shl	 ecx, 4
  00156	0b c1		 or	 eax, ecx
  00158	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  0015d	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00161	0b c1		 or	 eax, ecx
  00163	88 44 24 03	 mov	 BYTE PTR b2$[rsp], al

; 2089 :                  |  psw->asc           // (S0 or AS)
; 2090 :                  | (psw->cc << 4)
; 2091 :                  |  psw->progmask
; 2092 :                  ;
; 2093 : 
; 2094 :             b3 = psw->zerobyte;

  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  0016c	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00170	88 44 24 02	 mov	 BYTE PTR b3$[rsp], al

; 2095 : 
; 2096 :             b4567 = psw->IA_L;

  00174	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00179	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0017c	89 44 24 04	 mov	 DWORD PTR b4567$[rsp], eax

; 2097 : 
; 2098 :             if (!psw->zeroilc)

  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00185	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00188	c1 e8 02	 shr	 eax, 2
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	75 33		 jne	 SHORT $LN11@do_make_ps

; 2099 :                 b4567 &= psw->amode ? AMASK31 : AMASK24;

  00192	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00197	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0019a	d1 e8		 shr	 eax, 1
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	74 0a		 je	 SHORT $LN18@do_make_ps
  001a3	c7 44 24 18 ff
	ff ff 7f	 mov	 DWORD PTR tv163[rsp], 2147483647 ; 7fffffffH
  001ab	eb 08		 jmp	 SHORT $LN19@do_make_ps
$LN18@do_make_ps:
  001ad	c7 44 24 18 ff
	ff ff 00	 mov	 DWORD PTR tv163[rsp], 16777215 ; 00ffffffH
$LN19@do_make_ps:
  001b5	8b 44 24 18	 mov	 eax, DWORD PTR tv163[rsp]
  001b9	8b 4c 24 04	 mov	 ecx, DWORD PTR b4567$[rsp]
  001bd	23 c8		 and	 ecx, eax
  001bf	8b c1		 mov	 eax, ecx
  001c1	89 44 24 04	 mov	 DWORD PTR b4567$[rsp], eax
$LN11@do_make_ps:

; 2100 : 
; 2101 :             if (psw->amode)

  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  001ca	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001cd	d1 e8		 shr	 eax, 1
  001cf	83 e0 01	 and	 eax, 1
  001d2	85 c0		 test	 eax, eax
  001d4	74 0c		 je	 SHORT $LN12@do_make_ps

; 2102 :                 b4567 |= 0x80000000;

  001d6	8b 44 24 04	 mov	 eax, DWORD PTR b4567$[rsp]
  001da	0f ba e8 1f	 bts	 eax, 31
  001de	89 44 24 04	 mov	 DWORD PTR b4567$[rsp], eax
$LN12@do_make_ps:

; 2103 : 
; 2104 :             psw64 = 0

  001e2	0f b6 04 24	 movzx	 eax, BYTE PTR b0$[rsp]
  001e6	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  001ea	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR b1$[rsp]
  001ef	48 c1 e1 30	 shl	 rcx, 48			; 00000030H
  001f3	48 0b c1	 or	 rax, rcx
  001f6	0f b6 4c 24 03	 movzx	 ecx, BYTE PTR b2$[rsp]
  001fb	48 c1 e1 28	 shl	 rcx, 40			; 00000028H
  001ff	48 0b c1	 or	 rax, rcx
  00202	0f b6 4c 24 02	 movzx	 ecx, BYTE PTR b3$[rsp]
  00207	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  0020b	48 0b c1	 or	 rax, rcx
  0020e	8b 4c 24 04	 mov	 ecx, DWORD PTR b4567$[rsp]
  00212	48 0b c1	 or	 rax, rcx
  00215	48 89 44 24 20	 mov	 QWORD PTR psw64$[rsp], rax

; 2105 :                     | ( (U64) b0    << (64-(1*8)) )
; 2106 :                     | ( (U64) b1    << (64-(2*8)) )
; 2107 :                     | ( (U64) b2    << (64-(3*8)) )
; 2108 :                     | ( (U64) b3    << (64-(4*8)) )
; 2109 :                     | ( (U64) b4567 << (64-(8*8)) )
; 2110 :                     ;
; 2111 :             break;

  0021a	e9 eb 00 00 00	 jmp	 $LN2@do_make_ps
$LN13@do_make_ps:

; 2112 : 
; 2113 :         case 900:
; 2114 :             //                      z/Architecture
; 2115 :             //
; 2116 :             //     +------+------+-----+------+----+----+------+-----------+---
; 2117 :             //     | 0R00 | 0TIE | key | 0MWP | AS | cc | mask | 0000 000E | ..
; 2118 :             //     +------+------+-----+------+----+----+------+-----------+---
; 2119 :             //     0      4      8     12     16   18   20     24         31
; 2120 :             //
; 2121 :             //  ---+---+---------------------------------------------------+
; 2122 :             //   ..| B | 0000000000000000000000000000000000000000000000000 |
; 2123 :             //  ---+---+---------------------------------------------------+
; 2124 :             //     32  33                                                 63
; 2125 : 
; 2126 :             b0 = psw->sysmask;

  0021f	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00224	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00227	88 04 24	 mov	 BYTE PTR b0$[rsp], al

; 2127 : 
; 2128 :             b1 = 0

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  0022f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00233	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  00238	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0023c	0b c1		 or	 eax, ecx
  0023e	88 44 24 01	 mov	 BYTE PTR b1$[rsp], al

; 2129 :                  | psw->pkey
; 2130 :                  | psw->states
; 2131 :                  ;
; 2132 : 
; 2133 :             b2 = 0

  00242	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00247	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0024b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  00250	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00254	c1 e1 04	 shl	 ecx, 4
  00257	0b c1		 or	 eax, ecx
  00259	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psw$[rsp]
  0025e	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00262	0b c1		 or	 eax, ecx
  00264	88 44 24 03	 mov	 BYTE PTR b2$[rsp], al

; 2134 :                  |  psw->asc
; 2135 :                  | (psw->cc << 4)
; 2136 :                  |  psw->progmask
; 2137 :                  ;
; 2138 : 
; 2139 :             b3 = psw->zerobyte;

  00268	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  0026d	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00271	88 44 24 02	 mov	 BYTE PTR b3$[rsp], al

; 2140 : 
; 2141 :             if (psw->amode64)

  00275	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  0027a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0027d	83 e0 01	 and	 eax, 1
  00280	85 c0		 test	 eax, eax
  00282	74 0c		 je	 SHORT $LN14@do_make_ps

; 2142 :                 b3 |= 0x01;

  00284	0f b6 44 24 02	 movzx	 eax, BYTE PTR b3$[rsp]
  00289	83 c8 01	 or	 eax, 1
  0028c	88 44 24 02	 mov	 BYTE PTR b3$[rsp], al
$LN14@do_make_ps:

; 2143 : 
; 2144 :             b4567 = psw->zeroword;

  00290	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  00295	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00298	89 44 24 04	 mov	 DWORD PTR b4567$[rsp], eax

; 2145 : 
; 2146 :             if (psw->amode)

  0029c	48 8b 44 24 40	 mov	 rax, QWORD PTR psw$[rsp]
  002a1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002a4	d1 e8		 shr	 eax, 1
  002a6	83 e0 01	 and	 eax, 1
  002a9	85 c0		 test	 eax, eax
  002ab	74 0c		 je	 SHORT $LN15@do_make_ps

; 2147 :                 b4567 |= 0x80000000;

  002ad	8b 44 24 04	 mov	 eax, DWORD PTR b4567$[rsp]
  002b1	0f ba e8 1f	 bts	 eax, 31
  002b5	89 44 24 04	 mov	 DWORD PTR b4567$[rsp], eax
$LN15@do_make_ps:

; 2148 : 
; 2149 :             psw64 = 0

  002b9	0f b6 04 24	 movzx	 eax, BYTE PTR b0$[rsp]
  002bd	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  002c1	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR b1$[rsp]
  002c6	48 c1 e1 30	 shl	 rcx, 48			; 00000030H
  002ca	48 0b c1	 or	 rax, rcx
  002cd	0f b6 4c 24 03	 movzx	 ecx, BYTE PTR b2$[rsp]
  002d2	48 c1 e1 28	 shl	 rcx, 40			; 00000028H
  002d6	48 0b c1	 or	 rax, rcx
  002d9	0f b6 4c 24 02	 movzx	 ecx, BYTE PTR b3$[rsp]
  002de	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  002e2	48 0b c1	 or	 rax, rcx
  002e5	8b 4c 24 04	 mov	 ecx, DWORD PTR b4567$[rsp]
  002e9	48 0b c1	 or	 rax, rcx
  002ec	48 89 44 24 20	 mov	 QWORD PTR psw64$[rsp], rax

; 2150 :                     | ( (U64) b0    << (64-(1*8)) )
; 2151 :                     | ( (U64) b1    << (64-(2*8)) )
; 2152 :                     | ( (U64) b2    << (64-(3*8)) )
; 2153 :                     | ( (U64) b3    << (64-(4*8)) )
; 2154 :                     | ( (U64) b4567 << (64-(8*8)) )
; 2155 :                     ;
; 2156 :             break;

  002f1	eb 17		 jmp	 SHORT $LN2@do_make_ps
$LN16@do_make_ps:
$LN6@do_make_ps:

; 2157 : 
; 2158 :         default:        // LOGIC ERROR!
; 2159 :             CRASH();    // LOGIC ERROR!

  002f3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  002fc	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00301	c6 00 00	 mov	 BYTE PTR [rax], 0
  00304	33 c0		 xor	 eax, eax
  00306	85 c0		 test	 eax, eax
  00308	75 e9		 jne	 SHORT $LN6@do_make_ps
$LN2@do_make_ps:

; 2160 :     }
; 2161 :     return psw64;

  0030a	48 8b 44 24 20	 mov	 rax, QWORD PTR psw64$[rsp]

; 2162 : }

  0030f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00313	c3		 ret	 0
do_make_psw64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
shortname$ = 64
short2ptyp PROC

; 1976 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1977 :     unsigned int i;
; 1978 :     for (i=0; i < _countof( ptypes ); i++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@short2ptyp
$LN2@short2ptyp:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@short2ptyp:
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00021	48 83 f8 06	 cmp	 rax, 6
  00025	73 3a		 jae	 SHORT $LN3@short2ptyp

; 1979 :         if (strcasecmp( ptypes[i].shortname, shortname ) == 0)

  00027	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002b	48 6b c0 18	 imul	 rax, rax, 24
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  00036	48 8b 54 24 40	 mov	 rdx, QWORD PTR shortname$[rsp]
  0003b	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00046	85 c0		 test	 eax, eax
  00048	75 15		 jne	 SHORT $LN5@short2ptyp

; 1980 :             return ptypes[i].ptyp;

  0004a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004e	48 6b c0 18	 imul	 rax, rax, 24
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  00059	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005d	eb 04		 jmp	 SHORT $LN1@short2ptyp
$LN5@short2ptyp:
  0005f	eb b2		 jmp	 SHORT $LN2@short2ptyp
$LN3@short2ptyp:

; 1981 :     return SCCB_PTYP_UNKNOWN;

  00061	b0 01		 mov	 al, 1
$LN1@short2ptyp:

; 1982 : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
short2ptyp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 0
ptyp$ = 32
ptyp2short PROC

; 1967 : {

$LN7:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 1968 :     unsigned int i;
; 1969 :     for (i=0; i < _countof( ptypes ); i++)

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000f	eb 08		 jmp	 SHORT $LN4@ptyp2short
$LN2@ptyp2short:
  00011	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00014	ff c0		 inc	 eax
  00016	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@ptyp2short:
  00019	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001c	48 83 f8 06	 cmp	 rax, 6
  00020	73 32		 jae	 SHORT $LN3@ptyp2short

; 1970 :         if (ptypes[i].ptyp == ptyp)

  00022	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00025	48 6b c0 18	 imul	 rax, rax, 24
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR ptyp$[rsp]
  00039	3b c1		 cmp	 eax, ecx
  0003b	75 15		 jne	 SHORT $LN5@ptyp2short

; 1971 :             return ptypes[i].shortname;

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	48 6b c0 18	 imul	 rax, rax, 24
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  0004b	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00050	eb 09		 jmp	 SHORT $LN1@ptyp2short
$LN5@ptyp2short:
  00052	eb bd		 jmp	 SHORT $LN2@ptyp2short
$LN3@ptyp2short:

; 1972 :     return "??";

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159860
$LN1@ptyp2short:

; 1973 : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
ptyp2short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 0
ptyp$ = 32
ptyp2long PROC

; 1958 : {

$LN7:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 1959 :     unsigned int i;
; 1960 :     for (i=0; i < _countof( ptypes ); i++)

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000f	eb 08		 jmp	 SHORT $LN4@ptyp2long
$LN2@ptyp2long:
  00011	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00014	ff c0		 inc	 eax
  00016	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@ptyp2long:
  00019	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001c	48 83 f8 06	 cmp	 rax, 6
  00020	73 32		 jae	 SHORT $LN3@ptyp2long

; 1961 :         if (ptypes[i].ptyp == ptyp)

  00022	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00025	48 6b c0 18	 imul	 rax, rax, 24
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR ptyp$[rsp]
  00039	3b c1		 cmp	 eax, ecx
  0003b	75 15		 jne	 SHORT $LN5@ptyp2long

; 1962 :             return ptypes[i].longname;

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	48 6b c0 18	 imul	 rax, rax, 24
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptypes
  0004b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00050	eb 09		 jmp	 SHORT $LN1@ptyp2long
$LN5@ptyp2long:
  00052	eb bd		 jmp	 SHORT $LN2@ptyp2long
$LN3@ptyp2long:

; 1963 :     return "                ";              // 16 blanks

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159851
$LN1@ptyp2long:

; 1964 : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
ptyp2long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rc$ = 80
tv81 = 88
vargs$ = 96
idx$ = 128
buffer$ = 136
bufsiz$ = 144
fmt$ = 152
idx_snprintf PROC

; 1888 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1889 :     int rc;
; 1890 :     va_list vargs;
; 1891 : 
; 1892 :     if (idx < 0 || !bufsiz || (size_t)idx >= bufsiz)

  00017	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR idx$[rsp], 0
  0001f	7c 21		 jl	 SHORT $LN3@idx_snprin
  00021	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR bufsiz$[rsp], 0
  0002a	74 16		 je	 SHORT $LN3@idx_snprin
  0002c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR idx$[rsp]
  00034	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR bufsiz$[rsp]
  0003c	0f 82 8f 00 00
	00		 jb	 $LN2@idx_snprin
$LN3@idx_snprin:

; 1893 :     {
; 1894 :         // "Error in function %s: %s"
; 1895 :         WRMSG( HHC00075, "W", "idx_snprintf", "OVERFLOW (bufsiz too small)" );

  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159819
  00054	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159820
  00060	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159821
  0006c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159822
  00078	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00082	41 b9 03 00 00
	00		 mov	 r9d, 3
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159823
  0008f	ba 67 07 00 00	 mov	 edx, 1895		; 00000767H
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159824
  0009b	e8 00 00 00 00	 call	 fwritemsg

; 1896 :         idx = (int)(bufsiz ? bufsiz-1 : 0); /* (prevent buffer overflow) */

  000a0	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR bufsiz$[rsp], 0
  000a9	74 12		 je	 SHORT $LN5@idx_snprin
  000ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bufsiz$[rsp]
  000b3	48 ff c8	 dec	 rax
  000b6	48 89 44 24 58	 mov	 QWORD PTR tv81[rsp], rax
  000bb	eb 09		 jmp	 SHORT $LN6@idx_snprin
$LN5@idx_snprin:
  000bd	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
$LN6@idx_snprin:
  000c6	8b 44 24 58	 mov	 eax, DWORD PTR tv81[rsp]
  000ca	89 84 24 80 00
	00 00		 mov	 DWORD PTR idx$[rsp], eax
$LN2@idx_snprin:

; 1897 :     }
; 1898 : 
; 1899 :     va_start( vargs, fmt );

  000d1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  000d9	48 89 44 24 60	 mov	 QWORD PTR vargs$[rsp], rax

; 1900 :     rc = vsnprintf( buffer+idx, bufsiz-idx, fmt, vargs );

  000de	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR idx$[rsp]
  000e6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bufsiz$[rsp]
  000ee	48 2b c8	 sub	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR idx$[rsp]
  000fc	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00104	48 03 d1	 add	 rdx, rcx
  00107	48 8b ca	 mov	 rcx, rdx
  0010a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR vargs$[rsp]
  0010f	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  00117	48 8b d0	 mov	 rdx, rax
  0011a	e8 00 00 00 00	 call	 w32_vsnprintf
  0011f	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1901 :     return rc;

  00123	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 1902 : }

  00127	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0012b	c3		 ret	 0
idx_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
len$ = 32
dest$ = 64
destlen$ = 72
src$ = 80
srclen$ = 88
make_asciiz PROC

; 1830 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1831 :     int  len;
; 1832 :     for (len=0; len < srclen && len < destlen-1; len++)

  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN4@make_ascii
$LN2@make_ascii:
  00021	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN4@make_ascii:
  0002b	8b 44 24 58	 mov	 eax, DWORD PTR srclen$[rsp]
  0002f	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00033	7d 2e		 jge	 SHORT $LN3@make_ascii
  00035	8b 44 24 48	 mov	 eax, DWORD PTR destlen$[rsp]
  00039	ff c8		 dec	 eax
  0003b	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  0003f	7d 22		 jge	 SHORT $LN3@make_ascii

; 1833 :         dest[len] = guest_to_host( src[len] );

  00041	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR src$[rsp]
  0004b	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0004f	e8 00 00 00 00	 call	 guest_to_host
  00054	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR len$[rsp]
  00059	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  0005e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00061	eb be		 jmp	 SHORT $LN2@make_ascii
$LN3@make_ascii:
$LN5@make_ascii:

; 1834 :     while (len > 0 && dest[len-1] == SPACE)

  00063	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00068	7e 22		 jle	 SHORT $LN6@make_ascii
  0006a	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0006e	ff c8		 dec	 eax
  00070	48 98		 cdqe
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  00077	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0007b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007e	75 0c		 jne	 SHORT $LN6@make_ascii

; 1835 :         len--;

  00080	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00084	ff c8		 dec	 eax
  00086	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
  0008a	eb d7		 jmp	 SHORT $LN5@make_ascii
$LN6@make_ascii:

; 1836 :     dest[len] = 0;

  0008c	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  00096	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1837 :     return len;

  0009a	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]

; 1838 : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
make_asciiz ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
dest$ = 64
len$ = 72
source$ = 80
convert_to_ebcdic PROC

; 1816 : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1817 :     int  i;
; 1818 :     for (i=0; i < len && source[i]; i++)

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@convert_to
$LN2@convert_to:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@convert_to:
  00026	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0002a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002e	7d 34		 jge	 SHORT $LN3@convert_to
  00030	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR source$[rsp]
  0003a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003e	85 c0		 test	 eax, eax
  00040	74 22		 je	 SHORT $LN3@convert_to

; 1819 :         dest[i] = host_to_guest( source[i] );

  00042	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR source$[rsp]
  0004c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00050	e8 00 00 00 00	 call	 host_to_guest
  00055	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005a	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  0005f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00062	eb b8		 jmp	 SHORT $LN2@convert_to
$LN3@convert_to:
$LN5@convert_to:

; 1820 :     while (i < len)

  00064	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  00068	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0006c	7d 1a		 jge	 SHORT $LN6@convert_to

; 1821 :         dest[i++] = 0x40;

  0006e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  00078	c6 04 01 40	 mov	 BYTE PTR [rcx+rax], 64	; 00000040H
  0007c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00080	ff c0		 inc	 eax
  00082	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00086	eb dc		 jmp	 SHORT $LN5@convert_to
$LN6@convert_to:

; 1822 : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
convert_to_ebcdic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
source$ = 64
string_to_lower PROC

; 1806 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1807 :     int  i;
; 1808 :     for (i=0; source[i]; i++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@string_to_
$LN2@string_to_:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@string_to_:
  0001d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00027	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0002b	85 c0		 test	 eax, eax
  0002d	74 25		 je	 SHORT $LN3@string_to_

; 1809 :         source[i] = tolower( source[i] );

  0002f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00039	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003d	8b c8		 mov	 ecx, eax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  00045	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 40	 mov	 rdx, QWORD PTR source$[rsp]
  0004f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00052	eb bf		 jmp	 SHORT $LN2@string_to_
$LN3@string_to_:

; 1810 : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
string_to_lower ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
source$ = 64
string_to_upper PROC

; 1800 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1801 :     int  i;
; 1802 :     for (i=0; source[i]; i++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@string_to_
$LN2@string_to_:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@string_to_:
  0001d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00027	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0002b	85 c0		 test	 eax, eax
  0002d	74 25		 je	 SHORT $LN3@string_to_

; 1803 :         source[i] = toupper( source[i] );

  0002f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00039	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003d	8b c8		 mov	 ecx, eax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00045	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 40	 mov	 rdx, QWORD PTR source$[rsp]
  0004f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00052	eb bf		 jmp	 SHORT $LN2@string_to_
$LN3@string_to_:

; 1804 : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
string_to_upper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv92 = 0
tv94 = 4
i$ = 8
str$ = 32
len$ = 40
is_hex_l PROC

; 1784 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1785 :     size_t i;
; 1786 :     for (i=0; i < len; i++)

  0000e	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@is_hex_l
$LN2@is_hex_l:
  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
$LN4@is_hex_l:
  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0002b	48 39 44 24 08	 cmp	 QWORD PTR i$[rsp], rax
  00030	0f 83 a3 00 00
	00		 jae	 $LN3@is_hex_l

; 1787 :         if (!(0

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	0f 85 94 00 00
	00		 jne	 $LN5@is_hex_l
  00040	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  00045	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  0004a	48 03 c8	 add	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00053	83 f8 30	 cmp	 eax, 48			; 00000030H
  00056	7c 18		 jl	 SHORT $LN6@is_hex_l
  00058	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  00062	48 03 c8	 add	 rcx, rax
  00065	48 8b c1	 mov	 rax, rcx
  00068	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006b	83 f8 39	 cmp	 eax, 57			; 00000039H
  0006e	7e 64		 jle	 SHORT $LN5@is_hex_l
$LN6@is_hex_l:
  00070	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  0007a	48 03 c8	 add	 rcx, rax
  0007d	48 8b c1	 mov	 rax, rcx
  00080	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00083	83 f8 61	 cmp	 eax, 97			; 00000061H
  00086	7c 18		 jl	 SHORT $LN7@is_hex_l
  00088	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  00092	48 03 c8	 add	 rcx, rax
  00095	48 8b c1	 mov	 rax, rcx
  00098	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009b	83 f8 66	 cmp	 eax, 102		; 00000066H
  0009e	7e 34		 jle	 SHORT $LN5@is_hex_l
$LN7@is_hex_l:
  000a0	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000a5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b3	83 f8 41	 cmp	 eax, 65			; 00000041H
  000b6	7c 18		 jl	 SHORT $LN8@is_hex_l
  000b8	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cb	83 f8 46	 cmp	 eax, 70			; 00000046H
  000ce	7e 04		 jle	 SHORT $LN5@is_hex_l
$LN8@is_hex_l:

; 1788 :             || (str[i] >= '0' && str[i] <= '9')
; 1789 :             || (str[i] >= 'a' && str[i] <= 'f')
; 1790 :             || (str[i] >= 'A' && str[i] <= 'F')
; 1791 :         ))
; 1792 :             return false;

  000d0	32 c0		 xor	 al, al
  000d2	eb 3a		 jmp	 SHORT $LN1@is_hex_l
$LN5@is_hex_l:
  000d4	e9 40 ff ff ff	 jmp	 $LN2@is_hex_l
$LN3@is_hex_l:

; 1793 :     return len ? true : false; // (empty string is not hex)

  000d9	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  000df	74 09		 je	 SHORT $LN10@is_hex_l
  000e1	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv92[rsp], 1
  000e8	eb 07		 jmp	 SHORT $LN11@is_hex_l
$LN10@is_hex_l:
  000ea	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv92[rsp], 0
$LN11@is_hex_l:
  000f1	83 3c 24 00	 cmp	 DWORD PTR tv92[rsp], 0
  000f5	75 0a		 jne	 SHORT $LN12@is_hex_l
  000f7	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
  000ff	eb 08		 jmp	 SHORT $LN13@is_hex_l
$LN12@is_hex_l:
  00101	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
$LN13@is_hex_l:
  00109	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv94[rsp]
$LN1@is_hex_l:

; 1794 : }

  0010e	48 83 c4 18	 add	 rsp, 24
  00112	c3		 ret	 0
is_hex_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
str$ = 48
is_hex	PROC

; 1780 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1781 :     return is_hex_l( str, strlen( str ));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  0001b	e8 00 00 00 00	 call	 is_hex_l

; 1782 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
is_hex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv75 = 0
tv77 = 4
i$ = 8
str$ = 32
len$ = 40
is_numeric_l PROC

; 1772 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1773 :     size_t i;
; 1774 :     for (i=0; i < len; i++)

  0000e	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@is_numeric
$LN2@is_numeric:
  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 08	 mov	 QWORD PTR i$[rsp], rax
$LN4@is_numeric:
  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0002b	48 39 44 24 08	 cmp	 QWORD PTR i$[rsp], rax
  00030	73 36		 jae	 SHORT $LN3@is_numeric

; 1775 :         if (!(str[i] >= '0' && str[i] <= '9'))

  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  0003c	48 03 c8	 add	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00045	83 f8 30	 cmp	 eax, 48			; 00000030H
  00048	7c 18		 jl	 SHORT $LN6@is_numeric
  0004a	48 8b 44 24 08	 mov	 rax, QWORD PTR i$[rsp]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR str$[rsp]
  00054	48 03 c8	 add	 rcx, rax
  00057	48 8b c1	 mov	 rax, rcx
  0005a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00060	7e 04		 jle	 SHORT $LN5@is_numeric
$LN6@is_numeric:

; 1776 :             return false;

  00062	32 c0		 xor	 al, al
  00064	eb 37		 jmp	 SHORT $LN1@is_numeric
$LN5@is_numeric:
  00066	eb b1		 jmp	 SHORT $LN2@is_numeric
$LN3@is_numeric:

; 1777 :     return len ? true : false; // (empty string is not numeric)

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  0006e	74 09		 je	 SHORT $LN8@is_numeric
  00070	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv75[rsp], 1
  00077	eb 07		 jmp	 SHORT $LN9@is_numeric
$LN8@is_numeric:
  00079	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv75[rsp], 0
$LN9@is_numeric:
  00080	83 3c 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00084	75 0a		 jne	 SHORT $LN10@is_numeric
  00086	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  0008e	eb 08		 jmp	 SHORT $LN11@is_numeric
$LN10@is_numeric:
  00090	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
$LN11@is_numeric:
  00098	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv77[rsp]
$LN1@is_numeric:

; 1778 : }

  0009d	48 83 c4 18	 add	 rsp, 24
  000a1	c3		 ret	 0
is_numeric_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
str$ = 48
is_numeric PROC

; 1768 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1769 :     return is_numeric_l( str, strlen( str ));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  0001b	e8 00 00 00 00	 call	 is_numeric_l

; 1770 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
is_numeric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv$ = 32
init_random PROC

; 1758 : {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1759 :     struct timeval tv = {0};

  00006	48 8d 44 24 20	 lea	 rax, QWORD PTR tv$[rsp]
  0000b	48 8b f8	 mov	 rdi, rax
  0000e	33 c0		 xor	 eax, eax
  00010	b9 08 00 00 00	 mov	 ecx, 8
  00015	f3 aa		 rep stosb

; 1760 :     gettimeofday( &tv, NULL );

  00017	33 d2		 xor	 edx, edx
  00019	48 8d 4c 24 20	 lea	 rcx, QWORD PTR tv$[rsp]
  0001e	e8 00 00 00 00	 call	 gettimeofday

; 1761 :     srand( (U32) tv.tv_usec );

  00023	8b 4c 24 24	 mov	 ecx, DWORD PTR tv$[rsp+4]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 1762 : }

  0002d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
init_random ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
delim$1 = 32
p$ = 64
maxargc$ = 72
pargv$ = 80
pargc$ = 88
parse_args PROC

; 1700 : {

$LN20:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1701 :     *pargc = 0;

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR pargc$[rsp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1702 :     *pargv = NULL;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR pargv$[rsp]
  00027	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@parse_args:

; 1703 : 
; 1704 :     while (*p && *pargc < maxargc)

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00033	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00036	85 c0		 test	 eax, eax
  00038	0f 84 89 01 00
	00		 je	 $LN3@parse_args
  0003e	48 8b 44 24 58	 mov	 rax, QWORD PTR pargc$[rsp]
  00043	8b 4c 24 48	 mov	 ecx, DWORD PTR maxargc$[rsp]
  00047	39 08		 cmp	 DWORD PTR [rax], ecx
  00049	0f 8d 78 01 00
	00		 jge	 $LN3@parse_args
$LN4@parse_args:

; 1705 :     {
; 1706 :         while (*p && isspace(*p))

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00054	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00057	85 c0		 test	 eax, eax
  00059	74 23		 je	 SHORT $LN5@parse_args
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00060	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00063	8b c8		 mov	 ecx, eax
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0006b	85 c0		 test	 eax, eax
  0006d	74 0f		 je	 SHORT $LN5@parse_args

; 1707 :         {
; 1708 :             p++;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00074	48 ff c0	 inc	 rax
  00077	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 1709 :         }

  0007c	eb d1		 jmp	 SHORT $LN4@parse_args
$LN5@parse_args:

; 1710 :         if (!*p)

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00083	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00086	85 c0		 test	 eax, eax
  00088	75 05		 jne	 SHORT $LN11@parse_args

; 1711 :         {
; 1712 :             break; /* find start of arg */

  0008a	e9 38 01 00 00	 jmp	 $LN3@parse_args
$LN11@parse_args:

; 1713 :         }
; 1714 : 
; 1715 :         if (*p == '#' && *pargc)

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00094	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00097	83 f8 23	 cmp	 eax, 35			; 00000023H
  0009a	75 0f		 jne	 SHORT $LN12@parse_args
  0009c	48 8b 44 24 58	 mov	 rax, QWORD PTR pargc$[rsp]
  000a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  000a4	74 05		 je	 SHORT $LN12@parse_args

; 1716 :         {
; 1717 :             break; /* stop when line comment reached */

  000a6	e9 1c 01 00 00	 jmp	 $LN3@parse_args
$LN12@parse_args:

; 1718 :         }
; 1719 : 
; 1720 :         /* Count new arg */
; 1721 :         *pargv = p;

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR pargv$[rsp]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$[rsp]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1722 :         ++*pargc;

  000b8	48 8b 44 24 58	 mov	 rax, QWORD PTR pargc$[rsp]
  000bd	8b 00		 mov	 eax, DWORD PTR [rax]
  000bf	ff c0		 inc	 eax
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pargc$[rsp]
  000c6	89 01		 mov	 DWORD PTR [rcx], eax
$LN6@parse_args:

; 1723 : 
; 1724 :         while (*p && !isspace(*p) && *p != '\"' && *p != '\'')

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  000cd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d0	85 c0		 test	 eax, eax
  000d2	74 3d		 je	 SHORT $LN7@parse_args
  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  000d9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000dc	8b c8		 mov	 ecx, eax
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  000e4	85 c0		 test	 eax, eax
  000e6	75 29		 jne	 SHORT $LN7@parse_args
  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  000ed	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f0	83 f8 22	 cmp	 eax, 34			; 00000022H
  000f3	74 1c		 je	 SHORT $LN7@parse_args
  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  000fa	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fd	83 f8 27	 cmp	 eax, 39			; 00000027H
  00100	74 0f		 je	 SHORT $LN7@parse_args

; 1725 :         {
; 1726 :             p++;

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00107	48 ff c0	 inc	 rax
  0010a	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 1727 :         }

  0010f	eb b7		 jmp	 SHORT $LN6@parse_args
$LN7@parse_args:

; 1728 :         if (!*p)

  00111	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00116	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00119	85 c0		 test	 eax, eax
  0011b	75 05		 jne	 SHORT $LN13@parse_args

; 1729 :         {
; 1730 :             break; /* find end of arg */

  0011d	e9 a5 00 00 00	 jmp	 $LN3@parse_args
$LN13@parse_args:

; 1731 :         }
; 1732 : 
; 1733 :         if (*p == '\"' || *p == '\'')

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00127	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0012d	74 0d		 je	 SHORT $LN15@parse_args
  0012f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00134	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00137	83 f8 27	 cmp	 eax, 39			; 00000027H
  0013a	75 63		 jne	 SHORT $LN14@parse_args
$LN15@parse_args:

; 1734 :         {
; 1735 :             char delim = *p;

  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00141	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00144	88 44 24 20	 mov	 BYTE PTR delim$1[rsp], al

; 1736 :             if (p == *pargv)

  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR pargv$[rsp]
  0014d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00150	48 39 44 24 40	 cmp	 QWORD PTR p$[rsp], rax
  00155	75 10		 jne	 SHORT $LN16@parse_args

; 1737 :             {
; 1738 :                 *pargv = p+1;

  00157	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0015c	48 ff c0	 inc	 rax
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pargv$[rsp]
  00164	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN16@parse_args:
$LN10@parse_args:

; 1739 :             }
; 1740 :             do {} while (*++p && *p != delim);

  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0016c	48 ff c0	 inc	 rax
  0016f	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax
  00174	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00179	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017c	85 c0		 test	 eax, eax
  0017e	74 11		 je	 SHORT $LN17@parse_args
  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00185	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00188	0f be 4c 24 20	 movsx	 ecx, BYTE PTR delim$1[rsp]
  0018d	3b c1		 cmp	 eax, ecx
  0018f	75 d6		 jne	 SHORT $LN10@parse_args
$LN17@parse_args:

; 1741 :             if (!*p)

  00191	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  00196	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00199	85 c0		 test	 eax, eax
  0019b	75 02		 jne	 SHORT $LN18@parse_args

; 1742 :             {
; 1743 :                 break; /* find end of quoted string */

  0019d	eb 28		 jmp	 SHORT $LN3@parse_args
$LN18@parse_args:
$LN14@parse_args:

; 1744 :             }
; 1745 :         }
; 1746 : 
; 1747 :         *p++ = 0; /* mark end of arg */

  0019f	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  001a4	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a7	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  001ac	48 ff c0	 inc	 rax
  001af	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 1748 :         pargv++; /* next arg ptr */

  001b4	48 8b 44 24 50	 mov	 rax, QWORD PTR pargv$[rsp]
  001b9	48 83 c0 08	 add	 rax, 8
  001bd	48 89 44 24 50	 mov	 QWORD PTR pargv$[rsp], rax

; 1749 :     }

  001c2	e9 67 fe ff ff	 jmp	 $LN2@parse_args
$LN3@parse_args:

; 1750 : 
; 1751 :     return *pargc;

  001c7	48 8b 44 24 58	 mov	 rax, QWORD PTR pargc$[rsp]
  001cc	8b 00		 mov	 eax, DWORD PTR [rax]

; 1752 : }

  001ce	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001d2	c3		 ret	 0
parse_args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
str$ = 48
dlm$ = 56
trim	PROC

; 1642 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1643 :     return rtrim( ltrim( str, dlm ), dlm );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR dlm$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR str$[rsp]
  00018	e8 00 00 00 00	 call	 ltrim
  0001d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dlm$[rsp]
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 rtrim

; 1644 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
trim	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
p1$ = 32
d$ = 40
str$ = 64
dlm$ = 72
rtrim	PROC

; 1619 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1620 :     char* p1;       // (work ptr for iterating backward thru string)
; 1621 :     const char* d;  // (work ptr for iterating through delimiters)
; 1622 : 
; 1623 :     /* Point to last char of str */
; 1624 :     p1 = str + strlen( str ) - 1;

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  0001d	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  00022	48 89 44 24 20	 mov	 QWORD PTR p1$[rsp], rax

; 1625 : 
; 1626 :     /* Replace all trailing dlm's with nulls */
; 1627 :     for (d=dlm; p1 >= str && *d; )

  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR dlm$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
$LN2@rtrim:
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]
  00036	48 39 44 24 20	 cmp	 QWORD PTR p1$[rsp], rax
  0003b	72 50		 jb	 SHORT $LN3@rtrim
  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00042	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00045	85 c0		 test	 eax, eax
  00047	74 44		 je	 SHORT $LN3@rtrim

; 1628 :     {
; 1629 :         if (*p1 == *d)          // (is this one of the delimiters?)

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  0004e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d$[rsp]
  00056	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00059	3b c1		 cmp	 eax, ecx
  0005b	75 21		 jne	 SHORT $LN5@rtrim

; 1630 :             *p1-- = 0, d=dlm;   // (yes, remove it and reset scan)

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  00062	c6 00 00	 mov	 BYTE PTR [rax], 0
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  0006a	48 ff c8	 dec	 rax
  0006d	48 89 44 24 20	 mov	 QWORD PTR p1$[rsp], rax
  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR dlm$[rsp]
  00077	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
  0007c	eb 0d		 jmp	 SHORT $LN6@rtrim
$LN5@rtrim:

; 1631 :         else
; 1632 :             d++;                // (no, check next delimiter if any)

  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00083	48 ff c0	 inc	 rax
  00086	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
$LN6@rtrim:

; 1633 :     }

  0008b	eb a4		 jmp	 SHORT $LN2@rtrim
$LN3@rtrim:

; 1634 : 
; 1635 :     return str;

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR str$[rsp]

; 1636 : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
rtrim	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
p1$ = 0
d$ = 8
p2$ = 16
str$ = 48
dlm$ = 56
ltrim	PROC

; 1592 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1593 :     char* p1;       // (points to first non-dlm)
; 1594 :     char* p2;       // (work for shifting to remove leading dlm's)
; 1595 :     const char* d;  // (iterates through dlm's)
; 1596 : 
; 1597 :     /* Skip leading dlm's to locate first non-dlm character */
; 1598 :     for (p1=str, d=dlm; *p1 && *d; )

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR str$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR p1$[rsp], rax
  00017	48 8b 44 24 38	 mov	 rax, QWORD PTR dlm$[rsp]
  0001c	48 89 44 24 08	 mov	 QWORD PTR d$[rsp], rax
$LN2@ltrim:
  00021	48 8b 04 24	 mov	 rax, QWORD PTR p1$[rsp]
  00025	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00028	85 c0		 test	 eax, eax
  0002a	74 45		 je	 SHORT $LN3@ltrim
  0002c	48 8b 44 24 08	 mov	 rax, QWORD PTR d$[rsp]
  00031	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00034	85 c0		 test	 eax, eax
  00036	74 39		 je	 SHORT $LN3@ltrim

; 1599 :     {
; 1600 :         if (*p1 == *d)      // (is this one of the delimiters?)

  00038	48 8b 04 24	 mov	 rax, QWORD PTR p1$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR d$[rsp]
  00044	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00047	3b c1		 cmp	 eax, ecx
  00049	75 17		 jne	 SHORT $LN8@ltrim

; 1601 :             p1++, d=dlm;    // (yes, get past it and reset scan)

  0004b	48 8b 04 24	 mov	 rax, QWORD PTR p1$[rsp]
  0004f	48 ff c0	 inc	 rax
  00052	48 89 04 24	 mov	 QWORD PTR p1$[rsp], rax
  00056	48 8b 44 24 38	 mov	 rax, QWORD PTR dlm$[rsp]
  0005b	48 89 44 24 08	 mov	 QWORD PTR d$[rsp], rax
  00060	eb 0d		 jmp	 SHORT $LN9@ltrim
$LN8@ltrim:

; 1602 :         else
; 1603 :             d++;            // (no, check next delimiter if any)

  00062	48 8b 44 24 08	 mov	 rax, QWORD PTR d$[rsp]
  00067	48 ff c0	 inc	 rax
  0006a	48 89 44 24 08	 mov	 QWORD PTR d$[rsp], rax
$LN9@ltrim:

; 1604 :     }

  0006f	eb b0		 jmp	 SHORT $LN2@ltrim
$LN3@ltrim:

; 1605 : 
; 1606 :     /* Shift left remaining chars left via p2 */
; 1607 :     for (p2=str; *p1; *p2++ = *p1++);

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR str$[rsp]
  00076	48 89 44 24 10	 mov	 QWORD PTR p2$[rsp], rax
  0007b	eb 26		 jmp	 SHORT $LN7@ltrim
$LN5@ltrim:
  0007d	48 8b 44 24 10	 mov	 rax, QWORD PTR p2$[rsp]
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR p1$[rsp]
  00086	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00089	88 08		 mov	 BYTE PTR [rax], cl
  0008b	48 8b 44 24 10	 mov	 rax, QWORD PTR p2$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 10	 mov	 QWORD PTR p2$[rsp], rax
  00098	48 8b 04 24	 mov	 rax, QWORD PTR p1$[rsp]
  0009c	48 ff c0	 inc	 rax
  0009f	48 89 04 24	 mov	 QWORD PTR p1$[rsp], rax
$LN7@ltrim:
  000a3	48 8b 04 24	 mov	 rax, QWORD PTR p1$[rsp]
  000a7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000aa	85 c0		 test	 eax, eax
  000ac	74 02		 je	 SHORT $LN6@ltrim
  000ae	eb cd		 jmp	 SHORT $LN5@ltrim
$LN6@ltrim:

; 1608 : 
; 1609 :     /* Terminate string */
; 1610 :     *p2 = 0;

  000b0	48 8b 44 24 10	 mov	 rax, QWORD PTR p2$[rsp]
  000b5	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1611 : 
; 1612 :     return str;

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR str$[rsp]

; 1613 : }

  000bd	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c1	c3		 ret	 0
ltrim	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
k$ = 32
p$ = 40
w$ = 48
str$ = 80
delims$ = 88
tkcount	PROC

; 1575 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1576 :     char* w;        // (work copy of passed str)
; 1577 :     char* p;        // (work ptr)
; 1578 :     int   k;        // (number of tokens counted)
; 1579 : 
; 1580 :     /* Make private copy of string, keep tokenizing it until no more
; 1581 :        tokens, counting as we go, then free temporary work string. */
; 1582 :     w = strdup( str );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00019	48 89 44 24 30	 mov	 QWORD PTR w$[rsp], rax

; 1583 :     for (k=0, p=strtok( w, delims ); p; k++, p=strtok( NULL, delims ));

  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00026	48 8b 54 24 58	 mov	 rdx, QWORD PTR delims$[rsp]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR w$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  00036	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  0003b	eb 1c		 jmp	 SHORT $LN4@tkcount
$LN2@tkcount:
  0003d	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00041	ff c0		 inc	 eax
  00043	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  00047	48 8b 54 24 58	 mov	 rdx, QWORD PTR delims$[rsp]
  0004c	33 c9		 xor	 ecx, ecx
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  00054	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN4@tkcount:
  00059	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  0005f	74 02		 je	 SHORT $LN3@tkcount
  00061	eb da		 jmp	 SHORT $LN2@tkcount
$LN3@tkcount:

; 1584 :     free( w );

  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR w$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1585 :     return k;

  0006e	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]

; 1586 : }

  00072	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00076	c3		 ret	 0
tkcount	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
mask$ = 64
line$ = 68
chans$ = 72
chnum$ = 76
curlen$ = 80
tv129 = 88
$T1 = 96
tv138 = 104
tv142 = 112
newlen$ = 120
len$ = 128
onechan$ = 136
allchans$ = 144
chanlist$ = 192
__$ArrayPad$ = 256
buf$ = 288
buflen$ = 296
lpi$ = 304
lpp$ = 312
cctape$ = 320
FormatCCTAPE PROC

; 1467 : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1468 :     size_t len, curlen = 0, newlen;

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR curlen$[rsp], 0

; 1469 :     int line, chnum, chans;
; 1470 :     U16 mask;
; 1471 :     char onechan[8], allchans[48], chanlist[64];
; 1472 : 
; 1473 :     /* Get started */
; 1474 :     snprintf( buf, buflen, "lpi=%d lpp=%d cctape=(", lpi, lpp );

  00036	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR lpp$[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00041	44 8b 8c 24 30
	01 00 00	 mov	 r9d, DWORD PTR lpi$[rsp]
  00049	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159610
  00050	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR buflen$[rsp]
  00058	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00060	e8 00 00 00 00	 call	 w32_snprintf

; 1475 :     curlen = strlen( buf );

  00065	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0006d	e8 00 00 00 00	 call	 strlen
  00072	48 89 44 24 50	 mov	 QWORD PTR curlen$[rsp], rax

; 1476 : 
; 1477 :     /* Format: "cctape=(lll=cc,lll=(cc,cc),...)" */
; 1478 :     for (line=0; line < lpp; line++)

  00077	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR line$[rsp], 0
  0007f	eb 0a		 jmp	 SHORT $LN4@FormatCCTA
$LN2@FormatCCTA:
  00081	8b 44 24 44	 mov	 eax, DWORD PTR line$[rsp]
  00085	ff c0		 inc	 eax
  00087	89 44 24 44	 mov	 DWORD PTR line$[rsp], eax
$LN4@FormatCCTA:
  0008b	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR lpp$[rsp]
  00092	39 44 24 44	 cmp	 DWORD PTR line$[rsp], eax
  00096	0f 8d 1b 02 00
	00		 jge	 $LN3@FormatCCTA

; 1479 :     {
; 1480 :         /* Skip lines with no channels defined */
; 1481 :         if (!cctape[line])

  0009c	48 63 44 24 44	 movsxd	 rax, DWORD PTR line$[rsp]
  000a1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR cctape$[rsp]
  000a9	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000ad	85 c0		 test	 eax, eax
  000af	75 02		 jne	 SHORT $LN8@FormatCCTA

; 1482 :             continue;

  000b1	eb ce		 jmp	 SHORT $LN2@FormatCCTA
$LN8@FormatCCTA:

; 1483 : 
; 1484 :         /* Format channel stop(s) for this line */
; 1485 :         for (chans=0, allchans[0]=0, chnum=1, mask=0x8000;

  000b3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR chans$[rsp], 0
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 00	 imul	 rax, rax, 0
  000c4	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  000c9	48 83 7c 24 60
	30		 cmp	 QWORD PTR $T1[rsp], 48	; 00000030H
  000cf	73 02		 jae	 SHORT $LN15@FormatCCTA
  000d1	eb 05		 jmp	 SHORT $LN16@FormatCCTA
$LN15@FormatCCTA:
  000d3	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@FormatCCTA:
  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000dd	c6 84 04 90 00
	00 00 00	 mov	 BYTE PTR allchans$[rsp+rax], 0
  000e5	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR chnum$[rsp], 1
  000ed	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  000f2	66 89 44 24 40	 mov	 WORD PTR mask$[rsp], ax
  000f7	eb 17		 jmp	 SHORT $LN7@FormatCCTA
$LN5@FormatCCTA:

; 1486 :             chnum <= 12; mask >>= 1, chnum++)

  000f9	0f b7 44 24 40	 movzx	 eax, WORD PTR mask$[rsp]
  000fe	66 d1 e8	 shr	 ax, 1
  00101	66 89 44 24 40	 mov	 WORD PTR mask$[rsp], ax
  00106	8b 44 24 4c	 mov	 eax, DWORD PTR chnum$[rsp]
  0010a	ff c0		 inc	 eax
  0010c	89 44 24 4c	 mov	 DWORD PTR chnum$[rsp], eax
$LN7@FormatCCTA:
  00110	83 7c 24 4c 0c	 cmp	 DWORD PTR chnum$[rsp], 12
  00115	0f 8f 8d 00 00
	00		 jg	 $LN6@FormatCCTA

; 1487 :         {
; 1488 :             if (cctape[ line ] & mask)

  0011b	48 63 44 24 44	 movsxd	 rax, DWORD PTR line$[rsp]
  00120	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR cctape$[rsp]
  00128	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0012c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR mask$[rsp]
  00131	23 c1		 and	 eax, ecx
  00133	85 c0		 test	 eax, eax
  00135	74 6c		 je	 SHORT $LN9@FormatCCTA

; 1489 :             {
; 1490 :                 MSGBUF( onechan, "%d", chnum );

  00137	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR chnum$[rsp]
  0013c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159613
  00143	ba 08 00 00 00	 mov	 edx, 8
  00148	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR onechan$[rsp]
  00150	e8 00 00 00 00	 call	 w32_snprintf

; 1491 :                 if (chans++)

  00155	8b 44 24 48	 mov	 eax, DWORD PTR chans$[rsp]
  00159	89 44 24 58	 mov	 DWORD PTR tv129[rsp], eax
  0015d	8b 44 24 48	 mov	 eax, DWORD PTR chans$[rsp]
  00161	ff c0		 inc	 eax
  00163	89 44 24 48	 mov	 DWORD PTR chans$[rsp], eax
  00167	83 7c 24 58 00	 cmp	 DWORD PTR tv129[rsp], 0
  0016c	74 1a		 je	 SHORT $LN10@FormatCCTA

; 1492 :                     strlcat( allchans, ",", _countof( allchans ));

  0016e	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159615
  0017b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR allchans$[rsp]
  00183	e8 00 00 00 00	 call	 strlcat
$LN10@FormatCCTA:

; 1493 :                 strlcat( allchans, onechan, _countof( allchans ));

  00188	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  0018e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR onechan$[rsp]
  00196	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR allchans$[rsp]
  0019e	e8 00 00 00 00	 call	 strlcat
$LN9@FormatCCTA:

; 1494 :             }
; 1495 :         }

  001a3	e9 51 ff ff ff	 jmp	 $LN5@FormatCCTA
$LN6@FormatCCTA:

; 1496 : 
; 1497 :         /* Surround this line's channels with parens if needed */
; 1498 :         MSGBUF( chanlist, "%d=%s%s%s,",

  001a8	83 7c 24 48 01	 cmp	 DWORD PTR chans$[rsp], 1
  001ad	7e 0e		 jle	 SHORT $LN17@FormatCCTA
  001af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159616
  001b6	48 89 44 24 68	 mov	 QWORD PTR tv138[rsp], rax
  001bb	eb 0c		 jmp	 SHORT $LN18@FormatCCTA
$LN17@FormatCCTA:
  001bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159617
  001c4	48 89 44 24 68	 mov	 QWORD PTR tv138[rsp], rax
$LN18@FormatCCTA:
  001c9	83 7c 24 48 01	 cmp	 DWORD PTR chans$[rsp], 1
  001ce	7e 0e		 jle	 SHORT $LN19@FormatCCTA
  001d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159618
  001d7	48 89 44 24 70	 mov	 QWORD PTR tv142[rsp], rax
  001dc	eb 0c		 jmp	 SHORT $LN20@FormatCCTA
$LN19@FormatCCTA:
  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159619
  001e5	48 89 44 24 70	 mov	 QWORD PTR tv142[rsp], rax
$LN20@FormatCCTA:
  001ea	8b 44 24 44	 mov	 eax, DWORD PTR line$[rsp]
  001ee	ff c0		 inc	 eax
  001f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv138[rsp]
  001f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fa	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR allchans$[rsp]
  00202	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00207	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv142[rsp]
  0020c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00211	44 8b c8	 mov	 r9d, eax
  00214	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159620
  0021b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00220	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR chanlist$[rsp]
  00228	e8 00 00 00 00	 call	 w32_snprintf

; 1499 :             line+1,
; 1500 :             chans > 1 ? "(" : "",
; 1501 :             allchans,
; 1502 :             chans > 1 ? ")" : "" );
; 1503 : 
; 1504 :         len = strlen( chanlist );

  0022d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR chanlist$[rsp]
  00235	e8 00 00 00 00	 call	 strlen
  0023a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1505 : 
; 1506 :         /* Truncate and return if out of buffer space */
; 1507 :         if ((newlen = curlen + len) >= (buflen - 5))

  00242	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0024a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR curlen$[rsp]
  0024f	48 03 c8	 add	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 89 44 24 78	 mov	 QWORD PTR newlen$[rsp], rax
  0025a	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR buflen$[rsp]
  00262	48 83 e8 05	 sub	 rax, 5
  00266	48 39 44 24 78	 cmp	 QWORD PTR newlen$[rsp], rax
  0026b	72 1e		 jb	 SHORT $LN11@FormatCCTA

; 1508 :         {
; 1509 :             strlcat( buf, ", ...", buflen );

  0026d	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buflen$[rsp]
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159622
  0027c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00284	e8 00 00 00 00	 call	 strlcat

; 1510 :             return;

  00289	eb 78		 jmp	 SHORT $LN1@FormatCCTA
$LN11@FormatCCTA:

; 1511 :         }
; 1512 : 
; 1513 :         /* Append formatted channel stop(s) to output */
; 1514 :         strlcat( buf, chanlist, buflen );

  0028b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buflen$[rsp]
  00293	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR chanlist$[rsp]
  0029b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002a3	e8 00 00 00 00	 call	 strlcat

; 1515 :         curlen = newlen;

  002a8	48 8b 44 24 78	 mov	 rax, QWORD PTR newlen$[rsp]
  002ad	48 89 44 24 50	 mov	 QWORD PTR curlen$[rsp], rax

; 1516 :     }

  002b2	e9 ca fd ff ff	 jmp	 $LN2@FormatCCTA
$LN3@FormatCCTA:

; 1517 : 
; 1518 :     /* No channel stops at all? */
; 1519 :     if (buf[ curlen-1 ] == '(')

  002b7	48 8b 44 24 50	 mov	 rax, QWORD PTR curlen$[rsp]
  002bc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002c4	48 03 c8	 add	 rcx, rax
  002c7	48 8b c1	 mov	 rax, rcx
  002ca	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  002ce	83 f8 28	 cmp	 eax, 40			; 00000028H
  002d1	75 19		 jne	 SHORT $LN12@FormatCCTA

; 1520 :         buf[ curlen-1 ] = '0';

  002d3	48 8b 44 24 50	 mov	 rax, QWORD PTR curlen$[rsp]
  002d8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002e0	48 03 c8	 add	 rcx, rax
  002e3	48 8b c1	 mov	 rax, rcx
  002e6	c6 40 ff 30	 mov	 BYTE PTR [rax-1], 48	; 00000030H
  002ea	eb 17		 jmp	 SHORT $LN13@FormatCCTA
$LN12@FormatCCTA:

; 1521 :     else
; 1522 :         /* Change ending comma to closing paren instead */
; 1523 :         buf[ curlen-1 ] = ')';

  002ec	48 8b 44 24 50	 mov	 rax, QWORD PTR curlen$[rsp]
  002f1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002f9	48 03 c8	 add	 rcx, rax
  002fc	48 8b c1	 mov	 rax, rcx
  002ff	c6 40 ff 29	 mov	 BYTE PTR [rax-1], 41	; 00000029H
$LN13@FormatCCTA:
$LN1@FormatCCTA:
$LN14@FormatCCTA:

; 1524 : }

  00303	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030b	48 33 cc	 xor	 rcx, rsp
  0030e	e8 00 00 00 00	 call	 __security_check_cookie
  00313	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0031a	c3		 ret	 0
FormatCCTAPE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
sep$ = 48
line$ = 52
newlen$ = 56
curlen$ = 64
chan$ = 72
__$ArrayPad$ = 88
buf$ = 112
buflen$ = 120
index$ = 128
lpi$ = 136
lpp$ = 144
fcb$ = 152
FormatFCB PROC

; 1532 : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1533 :     int line;
; 1534 :     size_t curlen, newlen;
; 1535 :     char sep, chan[16];
; 1536 : 
; 1537 :     /* Get started */
; 1538 :     snprintf( buf, buflen, "index=%d lpi=%d lpp=%d fcb",

  00027	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR lpp$[rsp]
  0002e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00032	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR lpi$[rsp]
  00039	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003d	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR index$[rsp]
  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159646
  0004c	48 8b 54 24 78	 mov	 rdx, QWORD PTR buflen$[rsp]
  00051	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00056	e8 00 00 00 00	 call	 w32_snprintf

; 1539 :         index, lpi, lpp );
; 1540 :     curlen = strlen( buf );

  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00060	e8 00 00 00 00	 call	 strlen
  00065	48 89 44 24 40	 mov	 QWORD PTR curlen$[rsp], rax

; 1541 :     sep = '=';

  0006a	c6 44 24 30 3d	 mov	 BYTE PTR sep$[rsp], 61	; 0000003dH

; 1542 : 
; 1543 :     /* Format the "fcb=" values... */
; 1544 :     for (line=1; line <= lpp; line++)

  0006f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR line$[rsp], 1
  00077	eb 0a		 jmp	 SHORT $LN4@FormatFCB
$LN2@FormatFCB:
  00079	8b 44 24 34	 mov	 eax, DWORD PTR line$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 34	 mov	 DWORD PTR line$[rsp], eax
$LN4@FormatFCB:
  00083	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR lpp$[rsp]
  0008a	39 44 24 34	 cmp	 DWORD PTR line$[rsp], eax
  0008e	0f 8f b9 00 00
	00		 jg	 $LN3@FormatFCB

; 1545 :     {
; 1546 :         /* Skip lines with no channel stop defined */
; 1547 :         if (!fcb[line])

  00094	48 63 44 24 34	 movsxd	 rax, DWORD PTR line$[rsp]
  00099	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR fcb$[rsp]
  000a1	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  000a5	75 02		 jne	 SHORT $LN5@FormatFCB

; 1548 :             continue;

  000a7	eb d0		 jmp	 SHORT $LN2@FormatFCB
$LN5@FormatFCB:

; 1549 : 
; 1550 :         /* Format channel stop */
; 1551 :         MSGBUF( chan, "%c%d:%d", sep, fcb[line], line );

  000a9	48 63 44 24 34	 movsxd	 rax, DWORD PTR line$[rsp]
  000ae	0f be 4c 24 30	 movsx	 ecx, BYTE PTR sep$[rsp]
  000b3	8b 54 24 34	 mov	 edx, DWORD PTR line$[rsp]
  000b7	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  000bb	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR fcb$[rsp]
  000c3	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000c6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ca	44 8b c9	 mov	 r9d, ecx
  000cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159648
  000d4	ba 10 00 00 00	 mov	 edx, 16
  000d9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR chan$[rsp]
  000de	e8 00 00 00 00	 call	 w32_snprintf

; 1552 :         sep = ',';

  000e3	c6 44 24 30 2c	 mov	 BYTE PTR sep$[rsp], 44	; 0000002cH

; 1553 : 
; 1554 :         /* Truncate and return if out of buffer space */
; 1555 :         if ((newlen = curlen + strlen( chan )) >= (buflen - 5))

  000e8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR chan$[rsp]
  000ed	e8 00 00 00 00	 call	 strlen
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR curlen$[rsp]
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 89 44 24 38	 mov	 QWORD PTR newlen$[rsp], rax
  00102	48 8b 44 24 78	 mov	 rax, QWORD PTR buflen$[rsp]
  00107	48 83 e8 05	 sub	 rax, 5
  0010b	48 39 44 24 38	 cmp	 QWORD PTR newlen$[rsp], rax
  00110	72 18		 jb	 SHORT $LN6@FormatFCB

; 1556 :         {
; 1557 :             strlcat( buf, ", ...", buflen );

  00112	4c 8b 44 24 78	 mov	 r8, QWORD PTR buflen$[rsp]
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159650
  0011e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00123	e8 00 00 00 00	 call	 strlcat

; 1558 :             return;

  00128	eb 43		 jmp	 SHORT $LN1@FormatFCB
$LN6@FormatFCB:

; 1559 :         }
; 1560 : 
; 1561 :         /* Append formatted channel stop to output */
; 1562 :         strlcat( buf, chan, buflen );

  0012a	4c 8b 44 24 78	 mov	 r8, QWORD PTR buflen$[rsp]
  0012f	48 8d 54 24 48	 lea	 rdx, QWORD PTR chan$[rsp]
  00134	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 strlcat

; 1563 :         curlen = newlen;

  0013e	48 8b 44 24 38	 mov	 rax, QWORD PTR newlen$[rsp]
  00143	48 89 44 24 40	 mov	 QWORD PTR curlen$[rsp], rax

; 1564 :     }

  00148	e9 2c ff ff ff	 jmp	 $LN2@FormatFCB
$LN3@FormatFCB:

; 1565 : 
; 1566 :     /* No channel stops at all? */
; 1567 :     if (sep == '=')

  0014d	0f be 44 24 30	 movsx	 eax, BYTE PTR sep$[rsp]
  00152	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00155	75 16		 jne	 SHORT $LN7@FormatFCB

; 1568 :         strlcat( buf, "=0", buflen );

  00157	4c 8b 44 24 78	 mov	 r8, QWORD PTR buflen$[rsp]
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159652
  00163	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00168	e8 00 00 00 00	 call	 strlcat
$LN7@FormatFCB:
$LN1@FormatFCB:

; 1569 : }

  0016d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00172	48 33 cc	 xor	 rcx, rsp
  00175	e8 00 00 00 00	 call	 __security_check_cookie
  0017a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017e	c3		 ret	 0
FormatFCB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
b$ = 8
reverse_bits PROC

; 1449 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 1450 :     /* Reverse the top/bottom nibbles separately,
; 1451 :        then swap the two nibbles with each other.
; 1452 :     */
; 1453 :     return

  00004	0f b6 44 24 08	 movzx	 eax, BYTE PTR b$[rsp]
  00009	83 e0 0f	 and	 eax, 15
  0000c	48 98		 cdqe
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rev_nib_bits_tab
  00015	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00019	c1 e0 04	 shl	 eax, 4
  0001c	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR b$[rsp]
  00021	c1 f9 04	 sar	 ecx, 4
  00024	48 63 c9	 movsxd	 rcx, ecx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rev_nib_bits_tab
  0002e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00032	0b c1		 or	 eax, ecx

; 1454 :     (
; 1455 :         rev_nib_bits_tab[ b & 0x0F ] << 4
; 1456 :         |
; 1457 :         rev_nib_bits_tab[ b >> 4 ]
; 1458 :     );
; 1459 : }

  00034	c3		 ret	 0
reverse_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
exename$ = 48
nameonly$ = 56
strtok_str$ = 64
namedesc$ = 80
path$1 = 336
__$ArrayPad$ = 608
argc$ = 640
argv$ = 648
defpgm$ = 656
desc$ = 664
pgm$ = 672
initialize_utility PROC

; 1334 : {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1335 :     char*  exename;                     /* Executable name with .ext */
; 1336 :     char*  nameonly;                    /* Exename without any .ext  */
; 1337 :     char*  strtok_str;                  /* Work (strtok_r context)   */
; 1338 :     char   namedesc[256];               /* Message build work area   */
; 1339 : 
; 1340 :     setvbuf( stderr, NULL, _IONBF, 0 );

  0002d	b9 02 00 00 00	 mov	 ecx, 2
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00038	45 33 c9	 xor	 r9d, r9d
  0003b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00041	33 d2		 xor	 edx, edx
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 1341 :     setvbuf( stdout, NULL, _IONBF, 0 );

  0004c	b9 01 00 00 00	 mov	 ecx, 1
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00057	45 33 c9	 xor	 r9d, r9d
  0005a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00060	33 d2		 xor	 edx, edx
  00062	48 8b c8	 mov	 rcx, rax
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 1342 : 
; 1343 :     /* If the last argument is "EXTERNALGUI" it means we're running
; 1344 :        under the control of an external GUI. Utilities need to know
; 1345 :        this so they can react differently than in command-line mode. */
; 1346 :     if (argc >= 1 && strncmp( argv[argc-1], "EXTERNALGUI", 11 ) == 0)

  0006b	83 bc 24 80 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00073	7c 66		 jl	 SHORT $LN5@initialize
  00075	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0007c	ff c8		 dec	 eax
  0007e	48 98		 cdqe
  00080	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159561
  0008d	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00095	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0009f	85 c0		 test	 eax, eax
  000a1	75 38		 jne	 SHORT $LN5@initialize

; 1347 :     {
; 1348 :         extgui = 1;   /* Tell utility to send progress msgs to GUI */

  000a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  000aa	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1349 : 
; 1350 :         /* Remove the "EXTERNALGUI" argument from the command-line */
; 1351 :         argv[argc-1] = NULL;

  000b0	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000b7	ff c8		 dec	 eax
  000b9	48 98		 cdqe
  000bb	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000c3	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 1352 :         argc--;

  000cb	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000d2	ff c8		 dec	 eax
  000d4	89 84 24 80 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN5@initialize:

; 1353 :     }
; 1354 : 
; 1355 :     if (argc < 1)

  000db	83 bc 24 80 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000e3	7d 15		 jge	 SHORT $LN6@initialize

; 1356 :         exename = strdup( defpgm );

  000e5	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR defpgm$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000f3	48 89 44 24 30	 mov	 QWORD PTR exename$[rsp], rax
  000f8	eb 65		 jmp	 SHORT $LN7@initialize
$LN6@initialize:

; 1357 :     else
; 1358 :     {
; 1359 :         if (strlen( argv[0] ) == 0)

  000fa	b8 08 00 00 00	 mov	 eax, 8
  000ff	48 6b c0 00	 imul	 rax, rax, 0
  00103	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0010b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0010f	e8 00 00 00 00	 call	 strlen
  00114	48 85 c0	 test	 rax, rax
  00117	75 15		 jne	 SHORT $LN8@initialize

; 1360 :             exename = strdup( defpgm );

  00119	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR defpgm$[rsp]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00127	48 89 44 24 30	 mov	 QWORD PTR exename$[rsp], rax
  0012c	eb 31		 jmp	 SHORT $LN9@initialize
$LN8@initialize:

; 1361 :         else
; 1362 :         {
; 1363 :             char path[ MAX_PATH ];
; 1364 : #if defined( _MSVC_ )
; 1365 :             GetModuleFileName( NULL, path, MAX_PATH );

  0012e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00134	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR path$1[rsp]
  0013c	33 c9		 xor	 ecx, ecx
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA

; 1366 : #else
; 1367 :             STRLCPY( path, argv[0] );
; 1368 : #endif
; 1369 :             exename = strdup( basename( path ));

  00144	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR path$1[rsp]
  0014c	e8 00 00 00 00	 call	 w32_basename
  00151	48 8b c8	 mov	 rcx, rax
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0015a	48 89 44 24 30	 mov	 QWORD PTR exename$[rsp], rax
$LN9@initialize:
$LN7@initialize:

; 1370 :         }
; 1371 :     }
; 1372 : 
; 1373 :     /*
; 1374 :     **  Initialize a bunch of other stuff...
; 1375 :     **
; 1376 :     **  Note that initialization MUST occur in the following order:
; 1377 :     **  SYSBLK first, then hthreads (since it updates SYSBLK), then
; 1378 :     **  locks, etc, since they require hthreads.
; 1379 :     */
; 1380 :     memset( &sysblk, 0, sizeof( SYSBLK ));      // (must be first)

  0015f	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00166	33 c0		 xor	 eax, eax
  00168	b9 00 76 01 00	 mov	 ecx, 95744		; 00017600H
  0016d	f3 aa		 rep stosb

; 1381 :     hthreads_internal_init();                   // (must be second)

  0016f	e8 00 00 00 00	 call	 hthreads_internal_init
$LN4@initialize:

; 1382 :     SET_THREAD_NAME( exename );                 // (then other stuff)

  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0017a	48 8b 54 24 30	 mov	 rdx, QWORD PTR exename$[rsp]
  0017f	8b c8		 mov	 ecx, eax
  00181	e8 00 00 00 00	 call	 w32_set_thread_name
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0018c	48 8b 54 24 30	 mov	 rdx, QWORD PTR exename$[rsp]
  00191	8b c8		 mov	 ecx, eax
  00193	e8 00 00 00 00	 call	 hthread_set_thread_name
  00198	33 c0		 xor	 eax, eax
  0019a	85 c0		 test	 eax, eax
  0019c	75 d6		 jne	 SHORT $LN4@initialize

; 1383 :     sysblk.msglvl = DEFAULT_MLVL;

  0019e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a5	c7 80 80 75 01
	00 00 00 00 c0	 mov	 DWORD PTR [rax+95616], -1073741824 ; c0000000H

; 1384 :     sysblk.sysgroup = DEFAULT_SYSGROUP;

  001af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b6	c6 80 2d 11 00
	00 7f		 mov	 BYTE PTR [rax+4397], 127 ; 0000007fH

; 1385 : 
; 1386 :     initialize_detach_attr( DETACHED );

  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  001ca	48 8b c8	 mov	 rcx, rax
  001cd	e8 00 00 00 00	 call	 hthread_initialize_detach_attr

; 1387 :     initialize_join_attr( JOINABLE );

  001d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d9	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  001df	48 8b c8	 mov	 rcx, rax
  001e2	e8 00 00 00 00	 call	 hthread_initialize_join_attr

; 1388 :     initialize_lock( &sysblk.dasdcache_lock );

  001e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ee	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  001f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159566
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159567
  00202	48 8b c8	 mov	 rcx, rax
  00205	e8 00 00 00 00	 call	 hthread_initialize_lock

; 1389 :     initialize_lock( &sysblk.scrlock );

  0020a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00211	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00217	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159568
  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159569
  00225	48 8b c8	 mov	 rcx, rax
  00228	e8 00 00 00 00	 call	 hthread_initialize_lock

; 1390 :     initialize_condition( &sysblk.scrcond );

  0022d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00234	48 05 10 11 00
	00		 add	 rax, 4368		; 00001110H
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159570
  00241	48 8b c8	 mov	 rcx, rax
  00244	e8 00 00 00 00	 call	 hthread_initialize_condition

; 1391 : 
; 1392 :     set_codepage( NULL );

  00249	33 c9		 xor	 ecx, ecx
  0024b	e8 00 00 00 00	 call	 set_codepage

; 1393 :     init_hostinfo( &hostinfo );

  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hostinfo
  00257	e8 00 00 00 00	 call	 init_hostinfo

; 1394 : 
; 1395 :     /* Seed the pseudo-random number generator */
; 1396 :     init_random();

  0025c	e8 00 00 00 00	 call	 init_random

; 1397 : 
; 1398 :     strtok_str = NULL;

  00261	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR strtok_str$[rsp], 0

; 1399 :     if (!(nameonly = strtok_r( exename, ".", &strtok_str )))

  0026a	4c 8d 44 24 40	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0026f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159572
  00276	48 8b 4c 24 30	 mov	 rcx, QWORD PTR exename$[rsp]
  0027b	e8 00 00 00 00	 call	 strtok_r
  00280	48 89 44 24 38	 mov	 QWORD PTR nameonly$[rsp], rax
  00285	48 83 7c 24 38
	00		 cmp	 QWORD PTR nameonly$[rsp], 0
  0028b	75 0a		 jne	 SHORT $LN10@initialize

; 1400 :         nameonly = exename;

  0028d	48 8b 44 24 30	 mov	 rax, QWORD PTR exename$[rsp]
  00292	48 89 44 24 38	 mov	 QWORD PTR nameonly$[rsp], rax
$LN10@initialize:

; 1401 : 
; 1402 :     /* PROGRAMMING NOTE: we cannot free "exename" until we're
; 1403 :        done using "nameonly" since nameonly now points to it! */
; 1404 : 
; 1405 :     if (pgm)

  00297	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR pgm$[rsp], 0
  002a0	74 16		 je	 SHORT $LN11@initialize

; 1406 :         *pgm = strdup( nameonly );

  002a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR nameonly$[rsp]
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  002ad	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  002b5	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN11@initialize:

; 1407 : 
; 1408 :     /* Format the program identification message */
; 1409 :     MSGBUF( namedesc, "%s - %s", nameonly, desc );

  002b8	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	4c 8b 4c 24 38	 mov	 r9, QWORD PTR nameonly$[rsp]
  002ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159574
  002d1	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  002d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR namedesc$[rsp]
  002db	e8 00 00 00 00	 call	 w32_snprintf

; 1410 : 
; 1411 :     /* Now it's safe to discard exename */
; 1412 :     free( exename );

  002e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR exename$[rsp]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1413 : 
; 1414 :     /* Display version, copyright, and build date */
; 1415 :     init_sysblk_version_str_arrays( namedesc );

  002eb	48 8d 4c 24 50	 lea	 rcx, QWORD PTR namedesc$[rsp]
  002f0	e8 00 00 00 00	 call	 init_sysblk_version_str_arrays

; 1416 :     if (defpgm && strcasecmp(defpgm, "hercifc") == 0)

  002f5	48 83 bc 24 90
	02 00 00 00	 cmp	 QWORD PTR defpgm$[rsp], 0
  002fe	74 33		 je	 SHORT $LN12@initialize
  00300	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159577
  00307	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR defpgm$[rsp]
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00315	85 c0		 test	 eax, eax
  00317	75 1a		 jne	 SHORT $LN12@initialize

; 1417 :         display_version( stderr, 0, NULL );

  00319	b9 02 00 00 00	 mov	 ecx, 2
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00324	45 33 c0	 xor	 r8d, r8d
  00327	33 d2		 xor	 edx, edx
  00329	48 8b c8	 mov	 rcx, rax
  0032c	e8 00 00 00 00	 call	 display_version
  00331	eb 18		 jmp	 SHORT $LN13@initialize
$LN12@initialize:

; 1418 :     else
; 1419 :         display_version( stdout, 0, NULL );

  00333	b9 01 00 00 00	 mov	 ecx, 1
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033e	45 33 c0	 xor	 r8d, r8d
  00341	33 d2		 xor	 edx, edx
  00343	48 8b c8	 mov	 rcx, rax
  00346	e8 00 00 00 00	 call	 display_version
$LN13@initialize:

; 1420 : 
; 1421 :     return argc;

  0034b	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]

; 1422 : }

  00352	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035a	48 33 cc	 xor	 rcx, rsp
  0035d	e8 00 00 00 00	 call	 __security_check_cookie
  00362	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  00369	5f		 pop	 rdi
  0036a	c3		 ret	 0
initialize_utility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
separator$ = 32
p_dst$ = 40
p_src$ = 48
num_len$ = 56
commas$ = 60
src$ = 64
__$ArrayPad$ = 96
dst$ = 128
num$ = 136
fmt_S64	PROC

; 1277 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1278 :     char  src[32];
; 1279 :     char* p_src     = src;

  0001d	48 8d 44 24 40	 lea	 rax, QWORD PTR src$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR p_src$[rsp], rax

; 1280 :     char* p_dst     = dst;

  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dst$[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR p_dst$[rsp], rax

; 1281 : 
; 1282 :     const char separator = ',';     // (FIXME)

  00034	c6 44 24 20 2c	 mov	 BYTE PTR separator$[rsp], 44 ; 0000002cH

; 1283 :     int num_len, commas;
; 1284 : 
; 1285 :     num_len = snprintf( src, sizeof( src ), "%"PRId64, num );

  00039	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR num$[rsp]
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159528
  00048	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0004d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR src$[rsp]
  00052	e8 00 00 00 00	 call	 w32_snprintf
  00057	89 44 24 38	 mov	 DWORD PTR num_len$[rsp], eax

; 1286 : 
; 1287 :     if (*p_src == '-')

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR p_src$[rsp]
  00060	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00063	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00066	75 33		 jne	 SHORT $LN5@fmt_S64

; 1288 :     {
; 1289 :         *p_dst++ = *p_src++;

  00068	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p_src$[rsp]
  00072	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00075	88 08		 mov	 BYTE PTR [rax], cl
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  0007c	48 ff c0	 inc	 rax
  0007f	48 89 44 24 28	 mov	 QWORD PTR p_dst$[rsp], rax
  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR p_src$[rsp]
  00089	48 ff c0	 inc	 rax
  0008c	48 89 44 24 30	 mov	 QWORD PTR p_src$[rsp], rax

; 1290 :         num_len--;

  00091	8b 44 24 38	 mov	 eax, DWORD PTR num_len$[rsp]
  00095	ff c8		 dec	 eax
  00097	89 44 24 38	 mov	 DWORD PTR num_len$[rsp], eax
$LN5@fmt_S64:

; 1291 :     }
; 1292 : 
; 1293 :     for (commas = 2 - num_len % 3;

  0009b	8b 44 24 38	 mov	 eax, DWORD PTR num_len$[rsp]
  0009f	99		 cdq
  000a0	b9 03 00 00 00	 mov	 ecx, 3
  000a5	f7 f9		 idiv	 ecx
  000a7	8b c2		 mov	 eax, edx
  000a9	b9 02 00 00 00	 mov	 ecx, 2
  000ae	2b c8		 sub	 ecx, eax
  000b0	8b c1		 mov	 eax, ecx
  000b2	89 44 24 3c	 mov	 DWORD PTR commas$[rsp], eax
  000b6	eb 14		 jmp	 SHORT $LN4@fmt_S64
$LN2@fmt_S64:

; 1295 :          commas = (commas + 1) % 3)

  000b8	8b 44 24 3c	 mov	 eax, DWORD PTR commas$[rsp]
  000bc	ff c0		 inc	 eax
  000be	99		 cdq
  000bf	b9 03 00 00 00	 mov	 ecx, 3
  000c4	f7 f9		 idiv	 ecx
  000c6	8b c2		 mov	 eax, edx
  000c8	89 44 24 3c	 mov	 DWORD PTR commas$[rsp], eax
$LN4@fmt_S64:

; 1294 :          *p_src;

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR p_src$[rsp]
  000d1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d4	85 c0		 test	 eax, eax
  000d6	74 4b		 je	 SHORT $LN3@fmt_S64

; 1296 :     {
; 1297 :         *p_dst++ = *p_src++;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p_src$[rsp]
  000e2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000e5	88 08		 mov	 BYTE PTR [rax], cl
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  000ec	48 ff c0	 inc	 rax
  000ef	48 89 44 24 28	 mov	 QWORD PTR p_dst$[rsp], rax
  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR p_src$[rsp]
  000f9	48 ff c0	 inc	 rax
  000fc	48 89 44 24 30	 mov	 QWORD PTR p_src$[rsp], rax

; 1298 :         if (commas == 1) {

  00101	83 7c 24 3c 01	 cmp	 DWORD PTR commas$[rsp], 1
  00106	75 19		 jne	 SHORT $LN6@fmt_S64

; 1299 :             *p_dst++ = separator;

  00108	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  0010d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR separator$[rsp]
  00112	88 08		 mov	 BYTE PTR [rax], cl
  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  00119	48 ff c0	 inc	 rax
  0011c	48 89 44 24 28	 mov	 QWORD PTR p_dst$[rsp], rax
$LN6@fmt_S64:

; 1300 :         }
; 1301 :     }

  00121	eb 95		 jmp	 SHORT $LN2@fmt_S64
$LN3@fmt_S64:

; 1302 : 
; 1303 :     *--p_dst = 0;

  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  00128	48 ff c8	 dec	 rax
  0012b	48 89 44 24 28	 mov	 QWORD PTR p_dst$[rsp], rax
  00130	48 8b 44 24 28	 mov	 rax, QWORD PTR p_dst$[rsp]
  00135	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1304 : 
; 1305 :     return (size_t) (p_dst - dst);

  00138	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dst$[rsp]
  00140	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p_dst$[rsp]
  00145	48 2b c8	 sub	 rcx, rax
  00148	48 8b c1	 mov	 rax, rcx

; 1306 : }

  0014b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00150	48 33 cc	 xor	 rcx, rsp
  00153	e8 00 00 00 00	 call	 __security_check_cookie
  00158	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0015c	c3		 ret	 0
fmt_S64	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
memsizeMB$ = 48
buf$ = 56
bufsz$ = 64
fmt_memsize_MB PROC

; 1271 : DLL_EXPORT char* fmt_memsize_MB( const U64 memsizeMB, char* buf, const size_t bufsz ) { return _fmt_memsize( memsizeMB, 2, buf, bufsz ); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR bufsz$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR buf$[rsp]
  0001d	ba 02 00 00 00	 mov	 edx, 2
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR memsizeMB$[rsp]
  00027	e8 00 00 00 00	 call	 _fmt_memsize
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
fmt_memsize_MB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
memsizeKB$ = 48
buf$ = 56
bufsz$ = 64
fmt_memsize_KB PROC

; 1270 : DLL_EXPORT char* fmt_memsize_KB( const U64 memsizeKB, char* buf, const size_t bufsz ) { return _fmt_memsize( memsizeKB, 1, buf, bufsz ); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR bufsz$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR buf$[rsp]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR memsizeKB$[rsp]
  00027	e8 00 00 00 00	 call	 _fmt_memsize
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
fmt_memsize_KB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
memsize$ = 48
buf$ = 56
bufsz$ = 64
fmt_memsize PROC

; 1269 : DLL_EXPORT char* fmt_memsize   ( const U64 memsize,   char* buf, const size_t bufsz ) { return _fmt_memsize( memsize,   0, buf, bufsz ); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR bufsz$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR buf$[rsp]
  0001d	33 d2		 xor	 edx, edx
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR memsize$[rsp]
  00024	e8 00 00 00 00	 call	 _fmt_memsize
  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
fmt_memsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv$ = 32
todsecs$ = 40
pTM$ = 48
pTV$ = 80
buf$ = 88
bufsz$ = 96
FormatTIMEVAL PROC

; 1209 : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1210 :     struct timeval  tv;
; 1211 :     struct tm*      pTM;
; 1212 :     time_t          todsecs;
; 1213 :     if (!buf || bufsz < 2)

  00013	48 83 7c 24 58
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00019	74 07		 je	 SHORT $LN3@FormatTIME
  0001b	83 7c 24 60 02	 cmp	 DWORD PTR bufsz$[rsp], 2
  00020	7d 07		 jge	 SHORT $LN2@FormatTIME
$LN3@FormatTIME:

; 1214 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 ab 00 00 00	 jmp	 $LN1@FormatTIME
$LN2@FormatTIME:

; 1215 :     if (!pTV)

  00029	48 83 7c 24 50
	00		 cmp	 QWORD PTR pTV$[rsp], 0
  0002f	75 16		 jne	 SHORT $LN4@FormatTIME

; 1216 :     {
; 1217 :         gettimeofday( &tv, NULL );

  00031	33 d2		 xor	 edx, edx
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR tv$[rsp]
  00038	e8 00 00 00 00	 call	 gettimeofday

; 1218 :         pTV = &tv;

  0003d	48 8d 44 24 20	 lea	 rax, QWORD PTR tv$[rsp]
  00042	48 89 44 24 50	 mov	 QWORD PTR pTV$[rsp], rax
$LN4@FormatTIME:

; 1219 :     }
; 1220 :     todsecs = pTV->tv_sec;

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR pTV$[rsp]
  0004c	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004f	48 89 44 24 28	 mov	 QWORD PTR todsecs$[rsp], rax

; 1221 :     pTM = localtime( &todsecs );

  00054	48 8d 4c 24 28	 lea	 rcx, QWORD PTR todsecs$[rsp]
  00059	e8 00 00 00 00	 call	 localtime
  0005e	48 89 44 24 30	 mov	 QWORD PTR pTM$[rsp], rax

; 1222 :     strftime( buf, bufsz, "%Y-%m-%d %H:%M:%S", pTM );

  00063	48 63 44 24 60	 movsxd	 rax, DWORD PTR bufsz$[rsp]
  00068	4c 8b 4c 24 30	 mov	 r9, QWORD PTR pTM$[rsp]
  0006d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159471
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 1223 :     if (bufsz > 20)

  00082	83 7c 24 60 14	 cmp	 DWORD PTR bufsz$[rsp], 20
  00087	7e 35		 jle	 SHORT $LN5@FormatTIME

; 1224 :         snprintf( &buf[19], bufsz-19, ".%06d", (int)pTV->tv_usec );

  00089	8b 44 24 60	 mov	 eax, DWORD PTR bufsz$[rsp]
  0008d	83 e8 13	 sub	 eax, 19
  00090	48 98		 cdqe
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 6b c9 13	 imul	 rcx, rcx, 19
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  000a0	48 03 d1	 add	 rdx, rcx
  000a3	48 8b ca	 mov	 rcx, rdx
  000a6	48 8b 54 24 50	 mov	 rdx, QWORD PTR pTV$[rsp]
  000ab	44 8b 4a 04	 mov	 r9d, DWORD PTR [rdx+4]
  000af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159473
  000b6	48 8b d0	 mov	 rdx, rax
  000b9	e8 00 00 00 00	 call	 w32_snprintf
$LN5@FormatTIME:

; 1225 :     buf[ bufsz-1 ] = 0;

  000be	8b 44 24 60	 mov	 eax, DWORD PTR bufsz$[rsp]
  000c2	ff c8		 dec	 eax
  000c4	48 98		 cdqe
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  000cb	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1226 :     return buf;

  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatTIME:

; 1227 : }

  000d4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d8	c3		 ret	 0
FormatTIMEVAL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
p$ = 32
loc$ = 64
trimloc	PROC

; 1165 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1166 :     /*
; 1167 :     ** The __FILE__ macro expands to a path by which the preprocessor
; 1168 :     ** opened the file, not the short name specified in "#include" or
; 1169 :     ** as the input file name argument.  For example, __FILE__ might
; 1170 :     ** expand to "/usr/local/include/myheader.h", not "myheader.h".
; 1171 :     ** The following compensates for this condition by returning just
; 1172 :     ** the base name.
; 1173 :     **
; 1174 :     ** PROGRAMMING NOTE: we cannot use the basename() function here
; 1175 :     ** because:
; 1176 :     **
; 1177 :     **
; 1178 :     **    "The basename() function may modify the string
; 1179 :     **     pointed to by path, and may return a pointer to
; 1180 :     **     internal storage. The returned pointer might be
; 1181 :     **     invalidated or the storage might be overwritten
; 1182 :     **     by a subsequent call to basename()."
; 1183 :     **
; 1184 :     **    "The basename() function need not be thread-safe."
; 1185 :     **
; 1186 :     **
; 1187 :     ** The below implementation avoids both issues by just returning
; 1188 :     ** a pointer indexed into the current string constant.
; 1189 :     */
; 1190 :     char* p = strrchr( loc, '\\' );         /* Windows */

  00009	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR loc$[rsp]
  00013	e8 00 00 00 00	 call	 strrchr
  00018	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1191 :     if (!p) p = strrchr( loc, '/' );        /* non-Windows */

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00023	75 14		 jne	 SHORT $LN2@trimloc
  00025	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR loc$[rsp]
  0002f	e8 00 00 00 00	 call	 strrchr
  00034	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN2@trimloc:

; 1192 :     if (p)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  0003f	74 0d		 je	 SHORT $LN3@trimloc

; 1193 :         loc = p+1;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00046	48 ff c0	 inc	 rax
  00049	48 89 44 24 40	 mov	 QWORD PTR loc$[rsp], rax
$LN3@trimloc:

; 1194 :     return loc;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR loc$[rsp]

; 1195 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
trimloc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
p$ = 32
type$ = 64
ptr$ = 72
hpcfree	PROC

; 1060 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1061 :     /* Retrieve the original ptr that hpcalloc() saved
; 1062 :        immediately preceding the original allocation */
; 1063 :     void* p = *(void**)((uintptr_t)ptr - sizeof(void*));

  0000d	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$[rsp]
  00012	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00016	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1064 : 
; 1065 :     /* Free the original calloc() allocated memory */
; 1066 :     free( p );

  0001b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1067 : 
; 1068 :     /* Indicate guest storage is no longer cleared */
; 1069 :     if (HPC_MAINSTOR == type) sysblk.main_clear = 0;

  00026	0f b6 44 24 40	 movzx	 eax, BYTE PTR type$[rsp]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 1e		 jne	 SHORT $LN2@hpcfree
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00037	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0003d	0f ba f0 0e	 btr	 eax, 14
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00048	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN2@hpcfree:

; 1070 :     if (HPC_XPNDSTOR == type) sysblk.xpnd_clear = 0;

  0004e	0f b6 44 24 40	 movzx	 eax, BYTE PTR type$[rsp]
  00053	83 f8 02	 cmp	 eax, 2
  00056	75 1e		 jne	 SHORT $LN3@hpcfree
  00058	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00065	0f ba f0 0f	 btr	 eax, 15
  00069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00070	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN3@hpcfree:

; 1071 : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
hpcfree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
p$ = 32
pagesize$ = 40
ptr$ = 48
bytes$ = 56
alignmask$ = 64
type$ = 96
size$ = 104
hpcalloc PROC

; 1028 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1029 :     /* PROGRAMMING NOTE: we presume the host page size
; 1030 :        will never be smaller than the guest page size */
; 1031 : 
; 1032 :     void*      ptr        = NULL;       /* (aligned)   */

  0000d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR ptr$[rsp], 0

; 1033 :     void*      p          = NULL;       /* (unaligned) */

  00016	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0

; 1034 :     size_t     bytes      = 0;

  0001f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 1035 :     size_t     pagesize   = HPAGESIZE();

  00028	e8 00 00 00 00	 call	 w32_hpagesize
  0002d	8b c0		 mov	 eax, eax
  0002f	48 89 44 24 28	 mov	 QWORD PTR pagesize$[rsp], rax

; 1036 :     uintptr_t  alignmask  = ~(pagesize-1);

  00034	48 8b 44 24 28	 mov	 rax, QWORD PTR pagesize$[rsp]
  00039	48 ff c8	 dec	 rax
  0003c	48 f7 d0	 not	 rax
  0003f	48 89 44 24 40	 mov	 QWORD PTR alignmask$[rsp], rax

; 1037 : 
; 1038 :     /* Need extra room for pointer and pagesize alignment */
; 1039 :     bytes = size + sizeof(void*) + pagesize - 1;

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pagesize$[rsp]
  0004e	48 8d 44 08 07	 lea	 rax, QWORD PTR [rax+rcx+7]
  00053	48 89 44 24 38	 mov	 QWORD PTR bytes$[rsp], rax

; 1040 : 
; 1041 :     /* Get memory already pre-initialized to binary zeroes */
; 1042 :     if ((p = calloc( bytes, 1 )) != NULL)

  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00068	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0006d	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00073	74 77		 je	 SHORT $LN2@hpcalloc

; 1043 :     {
; 1044 :         /* Round up to the next host pagesize boundary
; 1045 :            being careful there is room for our pointer */
; 1046 :         ptr = (void*)(((uintptr_t) p + sizeof(void*) + pagesize - 1) & alignmask);

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0007a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pagesize$[rsp]
  0007f	48 8d 44 08 07	 lea	 rax, QWORD PTR [rax+rcx+7]
  00084	48 23 44 24 40	 and	 rax, QWORD PTR alignmask$[rsp]
  00089	48 89 44 24 30	 mov	 QWORD PTR ptr$[rsp], rax

; 1047 : 
; 1048 :         /* Save original ptr for hpcfree() just before
; 1049 :            page-aligned ptr we'll be returning to them */
; 1050 :         *((void**)((uintptr_t) ptr - sizeof(void*))) = p;

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00098	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 1051 : 
; 1052 :         /* Indicate the storage has already been cleared */
; 1053 :         if (HPC_MAINSTOR == type) sysblk.main_clear = 1;

  0009c	0f b6 44 24 60	 movzx	 eax, BYTE PTR type$[rsp]
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	75 1e		 jne	 SHORT $LN3@hpcalloc
  000a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ad	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000b3	0f ba e8 0e	 bts	 eax, 14
  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000be	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN3@hpcalloc:

; 1054 :         if (HPC_XPNDSTOR == type) sysblk.xpnd_clear = 1;

  000c4	0f b6 44 24 60	 movzx	 eax, BYTE PTR type$[rsp]
  000c9	83 f8 02	 cmp	 eax, 2
  000cc	75 1e		 jne	 SHORT $LN4@hpcalloc
  000ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d5	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000db	0f ba e8 0f	 bts	 eax, 15
  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e6	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN4@hpcalloc:
$LN2@hpcalloc:

; 1055 :     }
; 1056 :     return ptr;   /* Return page-aligned allocation */

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR ptr$[rsp]

; 1057 : }

  000f1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f5	c3		 ret	 0
hpcalloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
ix$ = 32
b$ = 64
c$ = 72
s$ = 80
hgets	PROC

; 972  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 973  :     size_t ix=0;

  00013	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ix$[rsp], 0
$LN2@hgets:

; 974  :     while(ix<c)

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00021	48 39 44 24 20	 cmp	 QWORD PTR ix$[rsp], rax
  00026	73 7c		 jae	 SHORT $LN3@hgets

; 975  :     {
; 976  :         b[ix]=hgetc(s);

  00028	8b 4c 24 50	 mov	 ecx, DWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 hgetc
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ix$[rsp]
  00036	48 8b 54 24 40	 mov	 rdx, QWORD PTR b$[rsp]
  0003b	48 03 d1	 add	 rdx, rcx
  0003e	48 8b ca	 mov	 rcx, rdx
  00041	88 01		 mov	 BYTE PTR [rcx], al

; 977  :         if ((signed char)b[ix] == EOF)

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR ix$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00056	83 f8 ff	 cmp	 eax, -1
  00059	75 04		 jne	 SHORT $LN4@hgets

; 978  :         {
; 979  :             return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 47		 jmp	 SHORT $LN1@hgets
$LN4@hgets:

; 980  :         }
; 981  :         b[ix+1]=0;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR ix$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00069	48 03 c8	 add	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 982  :         if(b[ix]=='\n')

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR ix$[rsp]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0007d	48 03 c8	 add	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00086	83 f8 0a	 cmp	 eax, 10
  00089	75 07		 jne	 SHORT $LN5@hgets

; 983  :         {
; 984  :             return(b);

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00090	eb 14		 jmp	 SHORT $LN1@hgets
$LN5@hgets:

; 985  :         }
; 986  :         ix++;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR ix$[rsp]
  00097	48 ff c0	 inc	 rax
  0009a	48 89 44 24 20	 mov	 QWORD PTR ix$[rsp], rax

; 987  :     }

  0009f	e9 78 ff ff ff	 jmp	 $LN2@hgets
$LN3@hgets:

; 988  :     return NULL;

  000a4	33 c0		 xor	 eax, eax
$LN1@hgets:

; 989  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
hgets	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
c$ = 32
rc$ = 36
s$ = 64
hgetc	PROC

; 960  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 961  :     char c;
; 962  :     int rc;
; 963  :     rc=recv(s,&c,1,0);

  00008	48 63 44 24 40	 movsxd	 rax, DWORD PTR s$[rsp]
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	41 b8 01 00 00
	00		 mov	 r8d, 1
  00016	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  00024	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 964  :     if(rc<1)

  00028	83 7c 24 24 01	 cmp	 DWORD PTR rc$[rsp], 1
  0002d	7d 07		 jge	 SHORT $LN2@hgetc

; 965  :     {
; 966  :         return EOF;

  0002f	b8 ff ff ff ff	 mov	 eax, -1
  00034	eb 05		 jmp	 SHORT $LN1@hgetc
$LN2@hgetc:

; 967  :     }
; 968  :     return c;

  00036	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
$LN1@hgetc:

; 969  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
hgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
s$ = 48
bfr$ = 56
sz$ = 64
hwrite	PROC

; 992  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 993  :     return send(s,bfr,(int)sz,0); /* (int) cast is for _WIN64 */

  00012	48 63 44 24 30	 movsxd	 rax, DWORD PTR s$[rsp]
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	44 8b 44 24 40	 mov	 r8d, DWORD PTR sz$[rsp]
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR bfr$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send

; 994  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
hwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
rc$ = 32
bfr$ = 40
bsize$ = 48
vl$ = 56
s$ = 80
fmt$ = 88
hprintf	PROC

; 997  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 998  :     char *bfr;
; 999  :     size_t bsize=1024;

  00017	48 c7 44 24 30
	00 04 00 00	 mov	 QWORD PTR bsize$[rsp], 1024 ; 00000400H

; 1000 :     int rc;
; 1001 :     va_list vl;
; 1002 : 
; 1003 :     bfr=malloc(bsize);

  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bsize$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0002b	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax
$LN2@hprintf:

; 1004 :     while(1)

  00030	33 c0		 xor	 eax, eax
  00032	83 f8 01	 cmp	 eax, 1
  00035	74 75		 je	 SHORT $LN3@hprintf

; 1005 :     {
; 1006 :         if(!bfr)

  00037	48 83 7c 24 28
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0003d	75 0a		 jne	 SHORT $LN4@hprintf

; 1007 :         {
; 1008 :             return -1;

  0003f	b8 ff ff ff ff	 mov	 eax, -1
  00044	e9 91 00 00 00	 jmp	 $LN1@hprintf
$LN4@hprintf:

; 1009 :         }
; 1010 :         va_start(vl,fmt);

  00049	48 8d 44 24 60	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0004e	48 89 44 24 38	 mov	 QWORD PTR vl$[rsp], rax

; 1011 :         rc=vsnprintf(bfr,bsize,fmt,vl);

  00053	4c 8b 4c 24 38	 mov	 r9, QWORD PTR vl$[rsp]
  00058	4c 8b 44 24 58	 mov	 r8, QWORD PTR fmt$[rsp]
  0005d	48 8b 54 24 30	 mov	 rdx, QWORD PTR bsize$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  00067	e8 00 00 00 00	 call	 w32_vsnprintf
  0006c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1012 :         va_end(vl);

  00070	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vl$[rsp], 0

; 1013 :         if(rc<(int)bsize)

  00079	8b 44 24 30	 mov	 eax, DWORD PTR bsize$[rsp]
  0007d	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  00081	7d 02		 jge	 SHORT $LN5@hprintf

; 1014 :         {
; 1015 :             break;

  00083	eb 27		 jmp	 SHORT $LN3@hprintf
$LN5@hprintf:

; 1016 :         }
; 1017 :         bsize+=1024;

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR bsize$[rsp]
  0008a	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00090	48 89 44 24 30	 mov	 QWORD PTR bsize$[rsp], rax

; 1018 :         bfr=realloc(bfr,bsize);

  00095	48 8b 54 24 30	 mov	 rdx, QWORD PTR bsize$[rsp]
  0009a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000a5	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax

; 1019 :     }

  000aa	eb 84		 jmp	 SHORT $LN2@hprintf
$LN3@hprintf:

; 1020 :     rc=hwrite(s,bfr,strlen(bfr));

  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  000b1	e8 00 00 00 00	 call	 strlen
  000b6	4c 8b c0	 mov	 r8, rax
  000b9	48 8b 54 24 28	 mov	 rdx, QWORD PTR bfr$[rsp]
  000be	8b 4c 24 50	 mov	 ecx, DWORD PTR s$[rsp]
  000c2	e8 00 00 00 00	 call	 hwrite
  000c7	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1021 :     free(bfr);

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1022 :     return rc;

  000d6	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@hprintf:

; 1023 : }

  000da	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000de	c3		 ret	 0
hprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
now$ = 32
timeout_timespec$ = 40
__$ArrayPad$ = 56
pCOND$ = 80
pLOCK$ = 88
usecs$ = 96
pTV$ = 104
loc$ = 112
timed_wait_condition_relative_usecs_impl PROC

; 679  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 680  :     struct timespec timeout_timespec;
; 681  :     struct timeval  now;
; 682  : 
; 683  :     if (!pTV)

  00027	48 83 7c 24 68
	00		 cmp	 QWORD PTR pTV$[rsp], 0
  0002d	75 16		 jne	 SHORT $LN2@timed_wait

; 684  :     {
; 685  :         pTV = &now;

  0002f	48 8d 44 24 20	 lea	 rax, QWORD PTR now$[rsp]
  00034	48 89 44 24 68	 mov	 QWORD PTR pTV$[rsp], rax

; 686  :         gettimeofday( pTV, NULL );

  00039	33 d2		 xor	 edx, edx
  0003b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pTV$[rsp]
  00040	e8 00 00 00 00	 call	 gettimeofday
$LN2@timed_wait:

; 687  :     }
; 688  : 
; 689  :     timeout_timespec.tv_sec  = pTV->tv_sec  + ( usecs / 1000000 );

  00045	33 d2		 xor	 edx, edx
  00047	8b 44 24 60	 mov	 eax, DWORD PTR usecs$[rsp]
  0004b	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00050	f7 f1		 div	 ecx
  00052	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pTV$[rsp]
  00057	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00059	03 c8		 add	 ecx, eax
  0005b	8b c1		 mov	 eax, ecx
  0005d	8b c0		 mov	 eax, eax
  0005f	48 89 44 24 28	 mov	 QWORD PTR timeout_timespec$[rsp], rax

; 690  :     timeout_timespec.tv_nsec = pTV->tv_usec + ( usecs % 1000000 );

  00064	33 d2		 xor	 edx, edx
  00066	8b 44 24 60	 mov	 eax, DWORD PTR usecs$[rsp]
  0006a	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0006f	f7 f1		 div	 ecx
  00071	8b c2		 mov	 eax, edx
  00073	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pTV$[rsp]
  00078	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0007b	89 44 24 30	 mov	 DWORD PTR timeout_timespec$[rsp+8], eax

; 691  : 
; 692  :     if ( timeout_timespec.tv_nsec >= 1000000 )

  0007f	81 7c 24 30 40
	42 0f 00	 cmp	 DWORD PTR timeout_timespec$[rsp+8], 1000000 ; 000f4240H
  00087	7c 30		 jl	 SHORT $LN3@timed_wait

; 693  :     {
; 694  :         timeout_timespec.tv_sec  += timeout_timespec.tv_nsec / 1000000;

  00089	8b 44 24 30	 mov	 eax, DWORD PTR timeout_timespec$[rsp+8]
  0008d	99		 cdq
  0008e	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00093	f7 f9		 idiv	 ecx
  00095	48 98		 cdqe
  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR timeout_timespec$[rsp]
  0009c	48 03 c8	 add	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	48 89 44 24 28	 mov	 QWORD PTR timeout_timespec$[rsp], rax

; 695  :         timeout_timespec.tv_nsec %=                            1000000;

  000a7	8b 44 24 30	 mov	 eax, DWORD PTR timeout_timespec$[rsp+8]
  000ab	99		 cdq
  000ac	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000b1	f7 f9		 idiv	 ecx
  000b3	8b c2		 mov	 eax, edx
  000b5	89 44 24 30	 mov	 DWORD PTR timeout_timespec$[rsp+8], eax
$LN3@timed_wait:

; 696  :     }
; 697  : 
; 698  :     timeout_timespec.tv_nsec *= 1000;

  000b9	69 44 24 30 e8
	03 00 00	 imul	 eax, DWORD PTR timeout_timespec$[rsp+8], 1000 ; 000003e8H
  000c1	89 44 24 30	 mov	 DWORD PTR timeout_timespec$[rsp+8], eax

; 699  : //  return timed_wait_condition( pCOND, pLOCK, &timeout_timespec );
; 700  :     return hthread_timed_wait_condition( pCOND, pLOCK, &timeout_timespec, loc );

  000c5	4c 8b 4c 24 70	 mov	 r9, QWORD PTR loc$[rsp]
  000ca	4c 8d 44 24 28	 lea	 r8, QWORD PTR timeout_timespec$[rsp]
  000cf	48 8b 54 24 58	 mov	 rdx, QWORD PTR pLOCK$[rsp]
  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCOND$[rsp]
  000d9	e8 00 00 00 00	 call	 hthread_timed_wait_condition

; 701  : }

  000de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e3	48 33 cc	 xor	 rcx, rsp
  000e6	e8 00 00 00 00	 call	 __security_check_cookie
  000eb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ef	c3		 ret	 0
timed_wait_condition_relative_usecs_impl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
usec$1 = 32
tv155 = 36
dif_timeval$ = 64
accum_timeval$ = 72
timeval_add PROC

; 648  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@timeval_ad:

; 649  :     ASSERT ( dif_timeval   -> tv_sec >= 0  &&  dif_timeval   -> tv_usec >= 0 );

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR dif_timeval$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	7c 0b		 jl	 SHORT $LN15@timeval_ad
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR dif_timeval$[rsp]
  0001d	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00021	7d 5b		 jge	 SHORT $LN14@timeval_ad
$LN15@timeval_ad:
$LN7@timeval_ad:
  00023	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159332
  0002a	41 b8 89 02 00
	00		 mov	 r8d, 649		; 00000289H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159333
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159334
  0003e	e8 00 00 00 00	 call	 logmsg
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00049	85 c0		 test	 eax, eax
  0004b	74 20		 je	 SHORT $LN16@timeval_ad
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159336
  00054	41 b8 89 02 00
	00		 mov	 r8d, 649		; 00000289H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159337
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159338
  00068	e8 00 00 00 00	 call	 DebuggerTrace
$LN16@timeval_ad:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 b0		 jne	 SHORT $LN7@timeval_ad
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00079	85 c0		 test	 eax, eax
  0007b	74 01		 je	 SHORT $LN17@timeval_ad
  0007d	cc		 int	 3
$LN17@timeval_ad:
$LN14@timeval_ad:
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 8a		 jne	 SHORT $LN4@timeval_ad
$LN10@timeval_ad:

; 650  :     ASSERT ( accum_timeval -> tv_sec >= 0  &&  accum_timeval -> tv_usec >= 0 );

  00084	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  00089	83 38 00	 cmp	 DWORD PTR [rax], 0
  0008c	7c 0b		 jl	 SHORT $LN19@timeval_ad
  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  00093	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00097	7d 5b		 jge	 SHORT $LN18@timeval_ad
$LN19@timeval_ad:
$LN13@timeval_ad:
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159342
  000a0	41 b8 8a 02 00
	00		 mov	 r8d, 650		; 0000028aH
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159343
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159344
  000b4	e8 00 00 00 00	 call	 logmsg
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000bf	85 c0		 test	 eax, eax
  000c1	74 20		 je	 SHORT $LN20@timeval_ad
  000c3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159346
  000ca	41 b8 8a 02 00
	00		 mov	 r8d, 650		; 0000028aH
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159347
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159348
  000de	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@timeval_ad:
  000e3	33 c0		 xor	 eax, eax
  000e5	85 c0		 test	 eax, eax
  000e7	75 b0		 jne	 SHORT $LN13@timeval_ad
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ef	85 c0		 test	 eax, eax
  000f1	74 01		 je	 SHORT $LN21@timeval_ad
  000f3	cc		 int	 3
$LN21@timeval_ad:
$LN18@timeval_ad:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	75 8a		 jne	 SHORT $LN10@timeval_ad

; 651  : 
; 652  :     accum_timeval->tv_sec  += dif_timeval->tv_sec;

  000fa	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  000ff	8b 00		 mov	 eax, DWORD PTR [rax]
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  00106	03 01		 add	 eax, DWORD PTR [rcx]
  00108	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum_timeval$[rsp]
  0010d	89 01		 mov	 DWORD PTR [rcx], eax

; 653  :     accum_timeval->tv_usec += dif_timeval->tv_usec;

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  00114	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00117	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  0011c	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum_timeval$[rsp]
  00124	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 654  : 
; 655  :     if (accum_timeval->tv_usec >= 1000000)

  00127	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  0012c	81 78 04 40 42
	0f 00		 cmp	 DWORD PTR [rax+4], 1000000 ; 000f4240H
  00133	7c 42		 jl	 SHORT $LN22@timeval_ad

; 656  :     {
; 657  :         int usec = accum_timeval->tv_usec / 1000000;

  00135	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  0013a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0013d	99		 cdq
  0013e	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00143	f7 f9		 idiv	 ecx
  00145	89 44 24 20	 mov	 DWORD PTR usec$1[rsp], eax

; 658  :         accum_timeval->tv_sec  += usec;

  00149	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  0014e	8b 00		 mov	 eax, DWORD PTR [rax]
  00150	03 44 24 20	 add	 eax, DWORD PTR usec$1[rsp]
  00154	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum_timeval$[rsp]
  00159	89 01		 mov	 DWORD PTR [rcx], eax

; 659  :         accum_timeval->tv_usec -= usec * 1000000;

  0015b	69 44 24 20 40
	42 0f 00	 imul	 eax, DWORD PTR usec$1[rsp], 1000000 ; 000f4240H
  00163	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum_timeval$[rsp]
  00168	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0016b	2b c8		 sub	 ecx, eax
  0016d	8b c1		 mov	 eax, ecx
  0016f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR accum_timeval$[rsp]
  00174	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN22@timeval_ad:

; 660  :     }
; 661  : 
; 662  :     return ((accum_timeval->tv_sec < 0 || accum_timeval->tv_usec < 0) ? -1 : 0);

  00177	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  0017c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0017f	7c 15		 jl	 SHORT $LN24@timeval_ad
  00181	48 8b 44 24 48	 mov	 rax, QWORD PTR accum_timeval$[rsp]
  00186	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0018a	7c 0a		 jl	 SHORT $LN24@timeval_ad
  0018c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
  00194	eb 08		 jmp	 SHORT $LN25@timeval_ad
$LN24@timeval_ad:
  00196	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv155[rsp], -1
$LN25@timeval_ad:
  0019e	8b 44 24 24	 mov	 eax, DWORD PTR tv155[rsp]

; 663  : }

  001a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a6	c3		 ret	 0
timeval_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv162 = 32
endtime$ = 40
begtime$ = 48
beg_timeval$ = 80
end_timeval$ = 88
dif_timeval$ = 96
timeval_subtract PROC

; 616  : {

$LN27:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@timeval_su:

; 617  :     struct timeval begtime;
; 618  :     struct timeval endtime;
; 619  :     ASSERT ( beg_timeval -> tv_sec >= 0  &&  beg_timeval -> tv_usec >= 0 );

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR beg_timeval$[rsp]
  00018	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001b	7c 0b		 jl	 SHORT $LN15@timeval_su
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR beg_timeval$[rsp]
  00022	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00026	7d 5b		 jge	 SHORT $LN14@timeval_su
$LN15@timeval_su:
$LN7@timeval_su:
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159292
  0002f	41 b8 6b 02 00
	00		 mov	 r8d, 619		; 0000026bH
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159293
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159294
  00043	e8 00 00 00 00	 call	 logmsg
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0004e	85 c0		 test	 eax, eax
  00050	74 20		 je	 SHORT $LN16@timeval_su
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159296
  00059	41 b8 6b 02 00
	00		 mov	 r8d, 619		; 0000026bH
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159297
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159298
  0006d	e8 00 00 00 00	 call	 DebuggerTrace
$LN16@timeval_su:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 b0		 jne	 SHORT $LN7@timeval_su
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0007e	85 c0		 test	 eax, eax
  00080	74 01		 je	 SHORT $LN17@timeval_su
  00082	cc		 int	 3
$LN17@timeval_su:
$LN14@timeval_su:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 8a		 jne	 SHORT $LN4@timeval_su
$LN10@timeval_su:

; 620  :     ASSERT ( end_timeval -> tv_sec >= 0  &&  end_timeval -> tv_usec >= 0 );

  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR end_timeval$[rsp]
  0008e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00091	7c 0b		 jl	 SHORT $LN19@timeval_su
  00093	48 8b 44 24 58	 mov	 rax, QWORD PTR end_timeval$[rsp]
  00098	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0009c	7d 5b		 jge	 SHORT $LN18@timeval_su
$LN19@timeval_su:
$LN13@timeval_su:
  0009e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159302
  000a5	41 b8 6c 02 00
	00		 mov	 r8d, 620		; 0000026cH
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159303
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159304
  000b9	e8 00 00 00 00	 call	 logmsg
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c4	85 c0		 test	 eax, eax
  000c6	74 20		 je	 SHORT $LN20@timeval_su
  000c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159306
  000cf	41 b8 6c 02 00
	00		 mov	 r8d, 620		; 0000026cH
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159307
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159308
  000e3	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@timeval_su:
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	75 b0		 jne	 SHORT $LN13@timeval_su
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f4	85 c0		 test	 eax, eax
  000f6	74 01		 je	 SHORT $LN21@timeval_su
  000f8	cc		 int	 3
$LN21@timeval_su:
$LN18@timeval_su:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 8a		 jne	 SHORT $LN10@timeval_su

; 621  : 
; 622  :     memcpy(&begtime,beg_timeval,sizeof(struct timeval));

  000ff	48 8b 44 24 50	 mov	 rax, QWORD PTR beg_timeval$[rsp]
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 89 44 24 30	 mov	 QWORD PTR begtime$[rsp], rax

; 623  :     memcpy(&endtime,end_timeval,sizeof(struct timeval));

  0010c	48 8b 44 24 58	 mov	 rax, QWORD PTR end_timeval$[rsp]
  00111	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00114	48 89 44 24 28	 mov	 QWORD PTR endtime$[rsp], rax

; 624  : 
; 625  :     dif_timeval->tv_sec = endtime.tv_sec - begtime.tv_sec;

  00119	8b 44 24 30	 mov	 eax, DWORD PTR begtime$[rsp]
  0011d	8b 4c 24 28	 mov	 ecx, DWORD PTR endtime$[rsp]
  00121	2b c8		 sub	 ecx, eax
  00123	8b c1		 mov	 eax, ecx
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  0012a	89 01		 mov	 DWORD PTR [rcx], eax

; 626  : 
; 627  :     if (endtime.tv_usec >= begtime.tv_usec)

  0012c	8b 44 24 34	 mov	 eax, DWORD PTR begtime$[rsp+4]
  00130	39 44 24 2c	 cmp	 DWORD PTR endtime$[rsp+4], eax
  00134	7c 16		 jl	 SHORT $LN22@timeval_su

; 628  :     {
; 629  :         dif_timeval->tv_usec = endtime.tv_usec - begtime.tv_usec;

  00136	8b 44 24 34	 mov	 eax, DWORD PTR begtime$[rsp+4]
  0013a	8b 4c 24 2c	 mov	 ecx, DWORD PTR endtime$[rsp+4]
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  00147	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 630  :     }

  0014a	eb 25		 jmp	 SHORT $LN23@timeval_su
$LN22@timeval_su:

; 631  :     else
; 632  :     {
; 633  :         dif_timeval->tv_sec--;

  0014c	48 8b 44 24 60	 mov	 rax, QWORD PTR dif_timeval$[rsp]
  00151	8b 00		 mov	 eax, DWORD PTR [rax]
  00153	ff c8		 dec	 eax
  00155	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  0015a	89 01		 mov	 DWORD PTR [rcx], eax

; 634  :         dif_timeval->tv_usec = (endtime.tv_usec + 1000000) - begtime.tv_usec;

  0015c	8b 44 24 2c	 mov	 eax, DWORD PTR endtime$[rsp+4]
  00160	05 40 42 0f 00	 add	 eax, 1000000		; 000f4240H
  00165	2b 44 24 34	 sub	 eax, DWORD PTR begtime$[rsp+4]
  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dif_timeval$[rsp]
  0016e	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN23@timeval_su:

; 635  :     }
; 636  : 
; 637  :     return ((dif_timeval->tv_sec < 0 || dif_timeval->tv_usec < 0) ? -1 : 0);

  00171	48 8b 44 24 60	 mov	 rax, QWORD PTR dif_timeval$[rsp]
  00176	83 38 00	 cmp	 DWORD PTR [rax], 0
  00179	7c 15		 jl	 SHORT $LN25@timeval_su
  0017b	48 8b 44 24 60	 mov	 rax, QWORD PTR dif_timeval$[rsp]
  00180	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00184	7c 0a		 jl	 SHORT $LN25@timeval_su
  00186	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
  0018e	eb 08		 jmp	 SHORT $LN26@timeval_su
$LN25@timeval_su:
  00190	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv162[rsp], -1
$LN26@timeval_su:
  00198	8b 44 24 20	 mov	 eax, DWORD PTR tv162[rsp]

; 638  : }

  0019c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a0	c3		 ret	 0
timeval_subtract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
n$ = 32
d$ = 40
s$ = 48
dlen$ = 56
tv66 = 64
dst$ = 96
src$ = 104
siz$ = 112
strlcat	PROC

; 227  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 228  :  register char *d = dst;

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR dst$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 229  :  register const char *s = src;

  0001d	48 8b 44 24 68	 mov	 rax, QWORD PTR src$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 230  :  register size_t n = siz;

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR siz$[rsp]
  0002c	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN2@strlcat:

; 231  :  size_t dlen;
; 232  : 
; 233  :  /* Find the end of dst and adjust bytes left but don't go past end */
; 234  :  while (n-- != 0 && *d != '\0')

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00036	48 89 44 24 40	 mov	 QWORD PTR tv66[rsp], rax
  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00040	48 ff c8	 dec	 rax
  00043	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
  00048	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv66[rsp], 0
  0004e	74 1b		 je	 SHORT $LN3@strlcat
  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00055	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00058	85 c0		 test	 eax, eax
  0005a	74 0f		 je	 SHORT $LN3@strlcat

; 235  :   d++;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00061	48 ff c0	 inc	 rax
  00064	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
  00069	eb c6		 jmp	 SHORT $LN2@strlcat
$LN3@strlcat:

; 236  :  dlen = d - dst;

  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR dst$[rsp]
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d$[rsp]
  00075	48 2b c8	 sub	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR dlen$[rsp], rax

; 237  :  n = siz - dlen;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR dlen$[rsp]
  00085	48 8b 4c 24 70	 mov	 rcx, QWORD PTR siz$[rsp]
  0008a	48 2b c8	 sub	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 238  : 
; 239  :  if (n == 0)

  00095	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  0009b	75 17		 jne	 SHORT $LN6@strlcat

; 240  :   return(dlen + strlen(s));

  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	e8 00 00 00 00	 call	 strlen
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dlen$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	eb 6f		 jmp	 SHORT $LN1@strlcat
$LN6@strlcat:
$LN4@strlcat:

; 241  :  while (*s != '\0') {

  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000b9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 40		 je	 SHORT $LN5@strlcat

; 242  :   if (n != 1) {

  000c0	48 83 7c 24 20
	01		 cmp	 QWORD PTR n$[rsp], 1
  000c6	74 29		 je	 SHORT $LN7@strlcat

; 243  :    *d++ = *s;

  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000d5	88 08		 mov	 BYTE PTR [rax], cl
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 244  :    n--;

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000e9	48 ff c8	 dec	 rax
  000ec	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN7@strlcat:

; 245  :   }
; 246  :   s++;

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f6	48 ff c0	 inc	 rax
  000f9	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 247  :  }

  000fe	eb b4		 jmp	 SHORT $LN4@strlcat
$LN5@strlcat:

; 248  :  *d = '\0';

  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00105	c6 00 00	 mov	 BYTE PTR [rax], 0

; 249  : 
; 250  :  return(dlen + (s - src)); /* count does not include NUL */

  00108	48 8b 44 24 68	 mov	 rax, QWORD PTR src$[rsp]
  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00112	48 2b c8	 sub	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dlen$[rsp]
  0011d	48 03 c8	 add	 rcx, rax
  00120	48 8b c1	 mov	 rax, rcx
$LN1@strlcat:

; 251  : }

  00123	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00127	c3		 ret	 0
strlcat	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tv71 = 0
tv79 = 4
n$ = 8
s$ = 16
d$ = 24
dst$ = 48
src$ = 56
siz$ = 64
strlcpy	PROC

; 166  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 167  :  register char *d = dst;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR dst$[rsp]
  00018	48 89 44 24 18	 mov	 QWORD PTR d$[rsp], rax

; 168  :  register const char *s = src;

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  00022	48 89 44 24 10	 mov	 QWORD PTR s$[rsp], rax

; 169  :  register size_t n = siz;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR siz$[rsp]
  0002c	48 89 44 24 08	 mov	 QWORD PTR n$[rsp], rax

; 170  : 
; 171  :  /* Copy as many bytes as will fit */
; 172  :  if (n != 0 && --n != 0) {

  00031	48 83 7c 24 08
	00		 cmp	 QWORD PTR n$[rsp], 0
  00037	74 66		 je	 SHORT $LN7@strlcpy
  00039	48 8b 44 24 08	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 ff c8	 dec	 rax
  00041	48 89 44 24 08	 mov	 QWORD PTR n$[rsp], rax
  00046	48 83 7c 24 08
	00		 cmp	 QWORD PTR n$[rsp], 0
  0004c	74 51		 je	 SHORT $LN7@strlcpy
$LN4@strlcpy:

; 173  :   do {
; 174  :    if ((*d++ = *s++) == 0)

  0004e	48 8b 44 24 18	 mov	 rax, QWORD PTR d$[rsp]
  00053	48 8b 4c 24 10	 mov	 rcx, QWORD PTR s$[rsp]
  00058	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0005b	88 08		 mov	 BYTE PTR [rax], cl
  0005d	48 8b 44 24 18	 mov	 rax, QWORD PTR d$[rsp]
  00062	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00065	89 04 24	 mov	 DWORD PTR tv71[rsp], eax
  00068	48 8b 44 24 18	 mov	 rax, QWORD PTR d$[rsp]
  0006d	48 ff c0	 inc	 rax
  00070	48 89 44 24 18	 mov	 QWORD PTR d$[rsp], rax
  00075	48 8b 44 24 10	 mov	 rax, QWORD PTR s$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 44 24 10	 mov	 QWORD PTR s$[rsp], rax
  00082	83 3c 24 00	 cmp	 DWORD PTR tv71[rsp], 0
  00086	75 02		 jne	 SHORT $LN8@strlcpy

; 175  :     break;

  00088	eb 15		 jmp	 SHORT $LN3@strlcpy
$LN8@strlcpy:

; 176  :   } while (--n != 0);

  0008a	48 8b 44 24 08	 mov	 rax, QWORD PTR n$[rsp]
  0008f	48 ff c8	 dec	 rax
  00092	48 89 44 24 08	 mov	 QWORD PTR n$[rsp], rax
  00097	48 83 7c 24 08
	00		 cmp	 QWORD PTR n$[rsp], 0
  0009d	75 af		 jne	 SHORT $LN4@strlcpy
$LN3@strlcpy:
$LN7@strlcpy:

; 177  :  }
; 178  : 
; 179  :  /* Not enough room in dst, add NUL and traverse rest of src */
; 180  :  if (n == 0) {

  0009f	48 83 7c 24 08
	00		 cmp	 QWORD PTR n$[rsp], 0
  000a5	75 32		 jne	 SHORT $LN9@strlcpy

; 181  :   if (siz != 0)

  000a7	48 83 7c 24 40
	00		 cmp	 QWORD PTR siz$[rsp], 0
  000ad	74 08		 je	 SHORT $LN10@strlcpy

; 182  :    *d = '\0';  /* NUL-terminate dst */

  000af	48 8b 44 24 18	 mov	 rax, QWORD PTR d$[rsp]
  000b4	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN10@strlcpy:
$LN5@strlcpy:

; 183  :   while (*s++)

  000b7	48 8b 44 24 10	 mov	 rax, QWORD PTR s$[rsp]
  000bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bf	89 44 24 04	 mov	 DWORD PTR tv79[rsp], eax
  000c3	48 8b 44 24 10	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 ff c0	 inc	 rax
  000cb	48 89 44 24 10	 mov	 QWORD PTR s$[rsp], rax
  000d0	83 7c 24 04 00	 cmp	 DWORD PTR tv79[rsp], 0
  000d5	74 02		 je	 SHORT $LN6@strlcpy

; 184  :    ;

  000d7	eb de		 jmp	 SHORT $LN5@strlcpy
$LN6@strlcpy:
$LN9@strlcpy:

; 185  :  }
; 186  : 
; 187  :  return(s - src - 1); /* count does not include NUL */

  000d9	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  000de	48 8b 4c 24 10	 mov	 rcx, QWORD PTR s$[rsp]
  000e3	48 2b c8	 sub	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 ff c8	 dec	 rax

; 188  : }

  000ec	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f0	c3		 ret	 0
strlcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 80
tok$ = 88
tv73 = 96
list_all_symbols PROC

; 599  : {

$LN9:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 600  :     SYMBOL_TOKEN* tok; int i;
; 601  :     for (i=0; i < symbol_count; i++)

  00004	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0000c	eb 0a		 jmp	 SHORT $LN4@list_all_s
$LN2@list_all_s:
  0000e	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00012	ff c0		 inc	 eax
  00014	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@list_all_s:
  00018	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_count
  0001e	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00022	0f 8d ab 00 00
	00		 jge	 $LN3@list_all_s

; 602  :         if ((tok = symbols[i]) != NULL)

  00028	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00034	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00038	48 89 44 24 58	 mov	 QWORD PTR tok$[rsp], rax
  0003d	48 83 7c 24 58
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00043	0f 84 85 00 00
	00		 je	 $LN5@list_all_s

; 603  :             // "Symbol %-12s %s"
; 604  :             WRMSG( HHC02199, "I", tok->var, tok->val ? tok->val : "" );

  00049	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  0004e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00053	74 10		 je	 SHORT $LN7@list_all_s
  00055	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 44 24 60	 mov	 QWORD PTR tv73[rsp], rax
  00063	eb 0c		 jmp	 SHORT $LN8@list_all_s
$LN7@list_all_s:
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159262
  0006c	48 89 44 24 60	 mov	 QWORD PTR tv73[rsp], rax
$LN8@list_all_s:
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv73[rsp]
  00081	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00086	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  0008b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159263
  0009a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159264
  000a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159265
  000bd	ba 5c 02 00 00	 mov	 edx, 604		; 0000025cH
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159266
  000c9	e8 00 00 00 00	 call	 fwritemsg
$LN5@list_all_s:
  000ce	e9 3b ff ff ff	 jmp	 $LN2@list_all_s
$LN3@list_all_s:

; 605  : }

  000d3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000d7	c3		 ret	 0
list_all_symbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
i$ = 32
tok$ = 40
sym$ = 64
del_symbol PROC

; 345  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 346  :     SYMBOL_TOKEN        *tok;
; 347  :     int i;
; 348  : 
; 349  :     for(i=0;i<symbol_count;i++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@del_symbol
$LN2@del_symbol:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@del_symbol:
  0001d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR symbol_count
  00023	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00027	0f 8d 9b 00 00
	00		 jge	 $LN3@del_symbol

; 350  :     {
; 351  :         tok=symbols[i];

  0002d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00039	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0003d	48 89 44 24 28	 mov	 QWORD PTR tok$[rsp], rax

; 352  :         if(tok==NULL)

  00042	48 83 7c 24 28
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00048	75 02		 jne	 SHORT $LN5@del_symbol

; 353  :         {
; 354  :             continue;

  0004a	eb c7		 jmp	 SHORT $LN2@del_symbol
$LN5@del_symbol:

; 355  :         }
; 356  : #if defined( CASELESS_SYMBOLS )
; 357  :         if(strcasecmp(symbols[i]->var,sym)==0)

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  00058	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0005c	48 8b 54 24 40	 mov	 rdx, QWORD PTR sym$[rsp]
  00061	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0006a	85 c0		 test	 eax, eax
  0006c	75 55		 jne	 SHORT $LN6@del_symbol

; 358  : #else
; 359  :         if(strcmp(symbols[i]->var,sym)==0)
; 360  : #endif
; 361  :         {
; 362  :             if ( tok->val != NULL ) free(tok->val);

  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00073	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00078	74 0f		 je	 SHORT $LN7@del_symbol
  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  0007f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@del_symbol:

; 363  :             if ( tok->var != NULL ) free(tok->var);

  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  0008e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00092	74 0e		 je	 SHORT $LN8@del_symbol
  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR tok$[rsp]
  00099	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@del_symbol:

; 364  :             free(tok);

  000a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tok$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 365  :             symbols[i] = NULL;

  000ad	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR symbols
  000b9	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 366  :             return;

  000c1	eb 05		 jmp	 SHORT $LN1@del_symbol
$LN6@del_symbol:

; 367  :         }
; 368  :     }

  000c3	e9 4b ff ff ff	 jmp	 $LN2@del_symbol
$LN3@del_symbol:
$LN1@del_symbol:

; 369  : 
; 370  :     return;
; 371  : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
del_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tok$ = 32
size$ = 40
sym$ = 64
value$ = 72
set_symbol PROC

; 374  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 375  :     SYMBOL_TOKEN *tok;
; 376  :     size_t size;
; 377  : 
; 378  :     if ( sym == NULL || value == NULL || strlen(sym) == 0 )

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00014	74 17		 je	 SHORT $LN3@set_symbol
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$[rsp], 0
  0001c	74 0f		 je	 SHORT $LN3@set_symbol
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sym$[rsp]
  00023	e8 00 00 00 00	 call	 strlen
  00028	48 85 c0	 test	 rax, rax
  0002b	75 05		 jne	 SHORT $LN2@set_symbol
$LN3@set_symbol:

; 379  :         return;

  0002d	e9 85 00 00 00	 jmp	 $LN1@set_symbol
$LN2@set_symbol:

; 380  : 
; 381  :     tok=get_symbol_token(sym,1);

  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sym$[rsp]
  0003c	e8 00 00 00 00	 call	 get_symbol_token
  00041	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 382  :     if(tok==NULL)

  00046	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0004c	75 02		 jne	 SHORT $LN4@set_symbol

; 383  :     {
; 384  :         return;

  0004e	eb 67		 jmp	 SHORT $LN1@set_symbol
$LN4@set_symbol:

; 385  :     }
; 386  :     if(tok->val!=NULL)

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00055	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0005a	74 0f		 je	 SHORT $LN5@set_symbol

; 387  :     {
; 388  :         free(tok->val);

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00061	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@set_symbol:

; 389  :     }
; 390  :     size = strlen(value)+1;

  0006b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  00070	e8 00 00 00 00	 call	 strlen
  00075	48 ff c0	 inc	 rax
  00078	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 391  :     tok->val=malloc(size);

  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0008d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 392  :     if(tok->val==NULL)

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00096	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0009b	75 02		 jne	 SHORT $LN6@set_symbol

; 393  :     {
; 394  :         return;

  0009d	eb 18		 jmp	 SHORT $LN1@set_symbol
$LN6@set_symbol:

; 395  :     }
; 396  :     strlcpy(tok->val,value,size);

  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  000a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR value$[rsp]
  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000ae	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000b2	e8 00 00 00 00	 call	 strlcpy
$LN1@set_symbol:

; 397  :     return;
; 398  : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
set_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
stmtlen$ = 64
symt$ = 68
c$ = 72
inc_equals$ = 76
inc_colon$ = 80
inc_lbrace$ = 84
inc_dollar$ = 88
i$ = 92
inc_envvar$ = 96
lstarted$ = 104
$T1 = 112
$T2 = 120
$T3 = 128
tv170 = 136
tv201 = 144
buf$ = 160
dflt$ = 1200
__$ArrayPad$ = 2240
text$ = 2272
resolve_symbol_string PROC

; 435  : {

$LN39:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 08
	00 00		 sub	 rsp, 2256		; 000008d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c0
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 436  :     char    buf[MAX_PATH*4];                /* Statement buffer          */
; 437  :     char    dflt[MAX_PATH*4];               /* temp location for default */
; 438  :     int     c;                              /* Character work area       */
; 439  :     int     i = 0;                          /* Position in the input     */

  0001f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 440  :     int     stmtlen = 0;                    /* Statement length          */

  00027	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR stmtlen$[rsp], 0

; 441  :     int     inc_dollar = -1;                /* >=0 Ndx of dollar         */

  0002f	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR inc_dollar$[rsp], -1

; 442  :     int     inc_lbrace = -1;                /* >=0 Ndx of lbrace + 1     */

  00037	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR inc_lbrace$[rsp], -1

; 443  :     int     inc_colon  = -1;                /* >=0 Ndx of colon          */

  0003f	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR inc_colon$[rsp], -1

; 444  :     int     inc_equals = -1;                /* >=0 Ndx of equals         */

  00047	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR inc_equals$[rsp], -1

; 445  :     int     lstarted;                       /* Indicate if non-whitespace*/
; 446  :     char   *inc_envvar;                     /* ->Environment variable    */
; 447  : 
; 448  :     char    symt = 0;                       /* Character work area       */

  0004f	c6 44 24 44 00	 mov	 BYTE PTR symt$[rsp], 0

; 449  : 
; 450  :     if( strstr( text, "$(" ) == NULL && strstr( text, "${" ) == NULL )

  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159219
  0005b	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  00063	e8 00 00 00 00	 call	 strstr
  00068	48 85 c0	 test	 rax, rax
  0006b	75 2c		 jne	 SHORT $LN7@resolve_sy
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159220
  00074	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  0007c	e8 00 00 00 00	 call	 strstr
  00081	48 85 c0	 test	 rax, rax
  00084	75 13		 jne	 SHORT $LN7@resolve_sy

; 451  :     {
; 452  :         /* Malloc anyway - the caller will free() */
; 453  :         return( strdup( text ) );

  00086	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00094	e9 06 04 00 00	 jmp	 $LN1@resolve_sy
$LN7@resolve_sy:

; 454  :     }
; 455  : 
; 456  :     memset(buf, 0, sizeof(buf));

  00099	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  000a1	48 8b f8	 mov	 rdi, rax
  000a4	33 c0		 xor	 eax, eax
  000a6	b9 10 04 00 00	 mov	 ecx, 1040		; 00000410H
  000ab	f3 aa		 rep stosb
$LN2@resolve_sy:

; 457  : 
; 458  :     while(1)

  000ad	33 c0		 xor	 eax, eax
  000af	83 f8 01	 cmp	 eax, 1
  000b2	0f 84 d9 03 00
	00		 je	 $LN3@resolve_sy

; 459  :     {
; 460  :         for (i = 0, stmtlen = 0, lstarted = 0; ;i++)

  000b8	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR stmtlen$[rsp], 0
  000c8	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR lstarted$[rsp], 0
  000d0	eb 0a		 jmp	 SHORT $LN6@resolve_sy
$LN4@resolve_sy:
  000d2	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  000d6	ff c0		 inc	 eax
  000d8	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN6@resolve_sy:

; 461  :         {
; 462  :             c = text[i];

  000dc	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  000e1	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  000e9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ed	89 44 24 48	 mov	 DWORD PTR c$[rsp], eax

; 463  : 
; 464  :             /* Ignore nulls and carriage returns */
; 465  :             if (c == '\0' ) break;

  000f1	83 7c 24 48 00	 cmp	 DWORD PTR c$[rsp], 0
  000f6	75 05		 jne	 SHORT $LN8@resolve_sy
  000f8	e9 8d 03 00 00	 jmp	 $LN5@resolve_sy
$LN8@resolve_sy:

; 466  : 
; 467  :             /* Check if it is a white space and no other character yet */
; 468  :             if(!lstarted && isspace(c)) continue;

  000fd	83 7c 24 68 00	 cmp	 DWORD PTR lstarted$[rsp], 0
  00102	75 10		 jne	 SHORT $LN9@resolve_sy
  00104	8b 4c 24 48	 mov	 ecx, DWORD PTR c$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0010e	85 c0		 test	 eax, eax
  00110	74 02		 je	 SHORT $LN9@resolve_sy
  00112	eb be		 jmp	 SHORT $LN4@resolve_sy
$LN9@resolve_sy:

; 469  :             lstarted=1;

  00114	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR lstarted$[rsp], 1

; 470  : 
; 471  :             /* Check that statement does not overflow buffer */
; 472  :             if (stmtlen >= (int)(sizeof(buf) - 1))

  0011c	81 7c 24 40 0f
	04 00 00	 cmp	 DWORD PTR stmtlen$[rsp], 1039 ; 0000040fH
  00124	7c 59		 jl	 SHORT $LN10@resolve_sy

; 473  :             {
; 474  :                 WRMSG( HHC01418, "E" );

  00126	b9 01 00 00 00	 mov	 ecx, 1
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159224
  00138	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159225
  00144	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00149	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00154	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159226
  0015b	ba da 01 00 00	 mov	 edx, 474		; 000001daH
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159227
  00167	e8 00 00 00 00	 call	 fwritemsg

; 475  :                 return( strdup(text) );

  0016c	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0017a	e9 20 03 00 00	 jmp	 $LN1@resolve_sy
$LN10@resolve_sy:

; 476  :             }
; 477  : 
; 478  :             /* inc_dollar already processed? */
; 479  :             if (inc_dollar >= 0)

  0017f	83 7c 24 58 00	 cmp	 DWORD PTR inc_dollar$[rsp], 0
  00184	0f 8c d1 02 00
	00		 jl	 $LN11@resolve_sy

; 480  :             {
; 481  :                 /* Left brace already processed? */
; 482  :                 if (inc_lbrace >= 0)

  0018a	83 7c 24 54 00	 cmp	 DWORD PTR inc_lbrace$[rsp], 0
  0018f	0f 8c 8c 02 00
	00		 jl	 $LN13@resolve_sy

; 483  :                 {
; 484  :                     /* End of variable spec? */
; 485  :                     if ( c == symt )

  00195	0f be 44 24 44	 movsx	 eax, BYTE PTR symt$[rsp]
  0019a	39 44 24 48	 cmp	 DWORD PTR c$[rsp], eax
  0019e	0f 85 46 02 00
	00		 jne	 $LN15@resolve_sy

; 486  :                     {
; 487  :                         /* Terminate it */
; 488  :                         buf[stmtlen] = '\0';

  001a4	48 63 44 24 40	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  001a9	48 89 44 24 70	 mov	 QWORD PTR $T1[rsp], rax
  001ae	48 81 7c 24 70
	10 04 00 00	 cmp	 QWORD PTR $T1[rsp], 1040 ; 00000410H
  001b7	73 02		 jae	 SHORT $LN33@resolve_sy
  001b9	eb 05		 jmp	 SHORT $LN34@resolve_sy
$LN33@resolve_sy:
  001bb	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@resolve_sy:
  001c0	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]
  001c5	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 489  : 
; 490  :                         /* Terminate var name if we have a inc_colon specifier */
; 491  :                         if (inc_colon >= 0)

  001cd	83 7c 24 50 00	 cmp	 DWORD PTR inc_colon$[rsp], 0
  001d2	7c 29		 jl	 SHORT $LN17@resolve_sy

; 492  :                         {
; 493  :                             buf[inc_colon] = '\0';

  001d4	48 63 44 24 50	 movsxd	 rax, DWORD PTR inc_colon$[rsp]
  001d9	48 89 44 24 78	 mov	 QWORD PTR $T2[rsp], rax
  001de	48 81 7c 24 78
	10 04 00 00	 cmp	 QWORD PTR $T2[rsp], 1040 ; 00000410H
  001e7	73 02		 jae	 SHORT $LN35@resolve_sy
  001e9	eb 05		 jmp	 SHORT $LN36@resolve_sy
$LN35@resolve_sy:
  001eb	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN36@resolve_sy:
  001f0	48 8b 44 24 78	 mov	 rax, QWORD PTR $T2[rsp]
  001f5	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN17@resolve_sy:

; 494  :                         }
; 495  : 
; 496  :                         /* Terminate var name if we have a default value */
; 497  :                         if (inc_equals >= 0)

  001fd	83 7c 24 4c 00	 cmp	 DWORD PTR inc_equals$[rsp], 0
  00202	7c 32		 jl	 SHORT $LN18@resolve_sy

; 498  :                         {
; 499  :                             buf[inc_equals] = '\0';

  00204	48 63 44 24 4c	 movsxd	 rax, DWORD PTR inc_equals$[rsp]
  00209	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  00211	48 81 bc 24 80
	00 00 00 10 04
	00 00		 cmp	 QWORD PTR $T3[rsp], 1040 ; 00000410H
  0021d	73 02		 jae	 SHORT $LN37@resolve_sy
  0021f	eb 05		 jmp	 SHORT $LN38@resolve_sy
$LN37@resolve_sy:
  00221	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN38@resolve_sy:
  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  0022e	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN18@resolve_sy:

; 500  :                         }
; 501  : 
; 502  :                         /* Reset statement index to start of variable */
; 503  :                         stmtlen = inc_dollar;

  00236	8b 44 24 58	 mov	 eax, DWORD PTR inc_dollar$[rsp]
  0023a	89 44 24 40	 mov	 DWORD PTR stmtlen$[rsp], eax

; 504  : 
; 505  :                         /* Get variable value */
; 506  :                         inc_envvar = (char *)get_symbol (&buf[inc_lbrace]);

  0023e	48 63 44 24 54	 movsxd	 rax, DWORD PTR inc_lbrace$[rsp]
  00243	48 8d 84 04 a0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  0024b	48 8b c8	 mov	 rcx, rax
  0024e	e8 00 00 00 00	 call	 get_symbol
  00253	48 89 44 24 60	 mov	 QWORD PTR inc_envvar$[rsp], rax

; 507  : 
; 508  :                         /* Variable unset? */
; 509  :                         if (inc_envvar == NULL || strlen(inc_envvar) == 0 )

  00258	48 83 7c 24 60
	00		 cmp	 QWORD PTR inc_envvar$[rsp], 0
  0025e	74 0f		 je	 SHORT $LN20@resolve_sy
  00260	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inc_envvar$[rsp]
  00265	e8 00 00 00 00	 call	 strlen
  0026a	48 85 c0	 test	 rax, rax
  0026d	75 4e		 jne	 SHORT $LN19@resolve_sy
$LN20@resolve_sy:

; 510  :                         {
; 511  :                             /* Substitute default if specified */
; 512  :                             if (inc_equals >= 0)

  0026f	83 7c 24 4c 00	 cmp	 DWORD PTR inc_equals$[rsp], 0
  00274	7c 47		 jl	 SHORT $LN21@resolve_sy

; 513  :                             {
; 514  :                                 memset(dflt, 0, sizeof(dflt));

  00276	48 8d 84 24 b0
	04 00 00	 lea	 rax, QWORD PTR dflt$[rsp]
  0027e	48 8b f8	 mov	 rdi, rax
  00281	33 c0		 xor	 eax, eax
  00283	b9 10 04 00 00	 mov	 ecx, 1040		; 00000410H
  00288	f3 aa		 rep stosb

; 515  :                                 STRLCPY( dflt, &buf[inc_equals+1] );

  0028a	8b 44 24 4c	 mov	 eax, DWORD PTR inc_equals$[rsp]
  0028e	ff c0		 inc	 eax
  00290	48 98		 cdqe
  00292	48 8d 84 04 a0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  0029a	41 b8 10 04 00
	00		 mov	 r8d, 1040		; 00000410H
  002a0	48 8b d0	 mov	 rdx, rax
  002a3	48 8d 8c 24 b0
	04 00 00	 lea	 rcx, QWORD PTR dflt$[rsp]
  002ab	e8 00 00 00 00	 call	 strlcpy

; 516  :                                 inc_envvar = dflt;

  002b0	48 8d 84 24 b0
	04 00 00	 lea	 rax, QWORD PTR dflt$[rsp]
  002b8	48 89 44 24 60	 mov	 QWORD PTR inc_envvar$[rsp], rax
$LN21@resolve_sy:
$LN19@resolve_sy:

; 517  :                             }
; 518  :                         }
; 519  : 
; 520  :                         /* Have a value? (environment or default) */
; 521  :                         if (inc_envvar != NULL)

  002bd	48 83 7c 24 60
	00		 cmp	 QWORD PTR inc_envvar$[rsp], 0
  002c3	0f 84 c6 00 00
	00		 je	 $LN22@resolve_sy

; 522  :                         {
; 523  :                             /* Check that statement does not overflow buffer */
; 524  :                             if (stmtlen+strlen(inc_envvar) >= sizeof(buf) - 1)

  002c9	48 63 44 24 40	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  002ce	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv170[rsp], rax
  002d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inc_envvar$[rsp]
  002db	e8 00 00 00 00	 call	 strlen
  002e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv170[rsp]
  002e8	48 03 c8	 add	 rcx, rax
  002eb	48 8b c1	 mov	 rax, rcx
  002ee	48 3d 0f 04 00
	00		 cmp	 rax, 1039		; 0000040fH
  002f4	72 59		 jb	 SHORT $LN23@resolve_sy

; 525  :                             {
; 526  :                                 WRMSG( HHC01418, "E" );

  002f6	b9 01 00 00 00	 mov	 ecx, 1
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159241
  00308	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159242
  00314	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00319	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00324	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159243
  0032b	ba 0e 02 00 00	 mov	 edx, 526		; 0000020eH
  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159244
  00337	e8 00 00 00 00	 call	 fwritemsg

; 527  :                                 return( strdup( text ) );

  0033c	48 8b 8c 24 e0
	08 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  00344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0034a	e9 50 01 00 00	 jmp	 $LN1@resolve_sy
$LN23@resolve_sy:

; 528  :                             }
; 529  : 
; 530  :                             /* Copy to buffer and update index */
; 531  :                             stmtlen += snprintf( &buf[stmtlen],

  0034f	48 63 44 24 40	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  00354	b9 10 04 00 00	 mov	 ecx, 1040		; 00000410H
  00359	48 2b c8	 sub	 rcx, rax
  0035c	48 8b c1	 mov	 rax, rcx
  0035f	48 ff c8	 dec	 rax
  00362	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR stmtlen$[rsp]
  00367	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  0036f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR inc_envvar$[rsp]
  00374	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159245
  0037b	48 8b d0	 mov	 rdx, rax
  0037e	e8 00 00 00 00	 call	 w32_snprintf
  00383	8b 4c 24 40	 mov	 ecx, DWORD PTR stmtlen$[rsp]
  00387	03 c8		 add	 ecx, eax
  00389	8b c1		 mov	 eax, ecx
  0038b	89 44 24 40	 mov	 DWORD PTR stmtlen$[rsp], eax
$LN22@resolve_sy:

; 532  :                                                  (sizeof(buf) - stmtlen) - 1,
; 533  :                                                  "%s", inc_envvar );
; 534  :                         }
; 535  :                         memset(&buf[stmtlen], 0, (sizeof(buf) - stmtlen));

  0038f	48 63 44 24 40	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  00394	b9 10 04 00 00	 mov	 ecx, 1040		; 00000410H
  00399	48 2b c8	 sub	 rcx, rax
  0039c	48 8b c1	 mov	 rax, rcx
  0039f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  003a7	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR stmtlen$[rsp]
  003ac	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  003b4	48 8b f9	 mov	 rdi, rcx
  003b7	33 c0		 xor	 eax, eax
  003b9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv201[rsp]
  003c1	f3 aa		 rep stosb

; 536  : 
; 537  :                         /* Reset indexes */
; 538  :                         inc_equals = -1;

  003c3	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR inc_equals$[rsp], -1

; 539  :                         inc_colon = -1;

  003cb	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR inc_colon$[rsp], -1

; 540  :                         inc_lbrace = -1;

  003d3	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR inc_lbrace$[rsp], -1

; 541  :                         inc_dollar = -1;

  003db	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR inc_dollar$[rsp], -1

; 542  :                         continue;

  003e3	e9 ea fc ff ff	 jmp	 $LN4@resolve_sy

; 543  :                     }

  003e8	eb 35		 jmp	 SHORT $LN16@resolve_sy
$LN15@resolve_sy:

; 544  :                     else if (c == ':' && inc_colon < 0 && inc_equals < 0)

  003ea	83 7c 24 48 3a	 cmp	 DWORD PTR c$[rsp], 58	; 0000003aH
  003ef	75 18		 jne	 SHORT $LN24@resolve_sy
  003f1	83 7c 24 50 00	 cmp	 DWORD PTR inc_colon$[rsp], 0
  003f6	7d 11		 jge	 SHORT $LN24@resolve_sy
  003f8	83 7c 24 4c 00	 cmp	 DWORD PTR inc_equals$[rsp], 0
  003fd	7d 0a		 jge	 SHORT $LN24@resolve_sy

; 545  :                     {
; 546  :                         /* Remember possible start of default specifier */
; 547  :                         inc_colon = stmtlen;

  003ff	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00403	89 44 24 50	 mov	 DWORD PTR inc_colon$[rsp], eax

; 548  :                     }

  00407	eb 16		 jmp	 SHORT $LN25@resolve_sy
$LN24@resolve_sy:

; 549  :                     else if (c == '=' && inc_equals < 0)

  00409	83 7c 24 48 3d	 cmp	 DWORD PTR c$[rsp], 61	; 0000003dH
  0040e	75 0f		 jne	 SHORT $LN26@resolve_sy
  00410	83 7c 24 4c 00	 cmp	 DWORD PTR inc_equals$[rsp], 0
  00415	7d 08		 jge	 SHORT $LN26@resolve_sy

; 550  :                     {
; 551  :                         /* Remember possible start of default specifier */
; 552  :                         inc_equals = stmtlen;

  00417	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  0041b	89 44 24 4c	 mov	 DWORD PTR inc_equals$[rsp], eax
$LN26@resolve_sy:
$LN25@resolve_sy:
$LN16@resolve_sy:

; 553  :                     }
; 554  :                 }

  0041f	eb 38		 jmp	 SHORT $LN14@resolve_sy
$LN13@resolve_sy:

; 555  :                 else // (inc_lbrace < 0)
; 556  :                 {
; 557  :                     /* Remember start of variable name */
; 558  : 
; 559  :                     if ( c == '(' )

  00421	83 7c 24 48 28	 cmp	 DWORD PTR c$[rsp], 40	; 00000028H
  00426	75 11		 jne	 SHORT $LN27@resolve_sy

; 560  :                     {
; 561  :                         symt = ')' ;

  00428	c6 44 24 44 29	 mov	 BYTE PTR symt$[rsp], 41	; 00000029H

; 562  :                         inc_lbrace = stmtlen + 1;

  0042d	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00431	ff c0		 inc	 eax
  00433	89 44 24 54	 mov	 DWORD PTR inc_lbrace$[rsp], eax

; 563  :                     }

  00437	eb 20		 jmp	 SHORT $LN28@resolve_sy
$LN27@resolve_sy:

; 564  :                     else if ( c == '{' )

  00439	83 7c 24 48 7b	 cmp	 DWORD PTR c$[rsp], 123	; 0000007bH
  0043e	75 11		 jne	 SHORT $LN29@resolve_sy

; 565  :                     {
; 566  :                         symt = '}' ;

  00440	c6 44 24 44 7d	 mov	 BYTE PTR symt$[rsp], 125 ; 0000007dH

; 567  :                         inc_lbrace = stmtlen + 1;

  00445	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00449	ff c0		 inc	 eax
  0044b	89 44 24 54	 mov	 DWORD PTR inc_lbrace$[rsp], eax

; 568  :                     }

  0044f	eb 08		 jmp	 SHORT $LN30@resolve_sy
$LN29@resolve_sy:

; 569  :                     else
; 570  :                     {
; 571  :                         /* Reset inc_dollar specifier if immediately following
; 572  :                         character is not a left brace */
; 573  :                         inc_dollar = -1;

  00451	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR inc_dollar$[rsp], -1
$LN30@resolve_sy:
$LN28@resolve_sy:
$LN14@resolve_sy:

; 574  :                     }
; 575  :                 }
; 576  :             }

  00459	eb 0f		 jmp	 SHORT $LN12@resolve_sy
$LN11@resolve_sy:

; 577  :             else // (inc_dollar < 0)
; 578  :             {
; 579  :                 /* Enter variable substitution state */
; 580  :                 if (c == '$')

  0045b	83 7c 24 48 24	 cmp	 DWORD PTR c$[rsp], 36	; 00000024H
  00460	75 08		 jne	 SHORT $LN31@resolve_sy

; 581  :                 {
; 582  :                     inc_dollar = stmtlen;

  00462	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00466	89 44 24 58	 mov	 DWORD PTR inc_dollar$[rsp], eax
$LN31@resolve_sy:
$LN12@resolve_sy:

; 583  :                 }
; 584  :             }
; 585  : 
; 586  :             /* Append character to buffer */
; 587  :             buf[stmtlen++] = c;

  0046a	48 63 44 24 40	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  0046f	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR c$[rsp]
  00474	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  0047b	8b 44 24 40	 mov	 eax, DWORD PTR stmtlen$[rsp]
  0047f	ff c0		 inc	 eax
  00481	89 44 24 40	 mov	 DWORD PTR stmtlen$[rsp], eax

; 588  : 
; 589  :         } /* end for(stmtlen) */

  00485	e9 48 fc ff ff	 jmp	 $LN4@resolve_sy
$LN5@resolve_sy:

; 590  : 
; 591  :         break;

  0048a	eb 05		 jmp	 SHORT $LN3@resolve_sy

; 592  :     }

  0048c	e9 1c fc ff ff	 jmp	 $LN2@resolve_sy
$LN3@resolve_sy:

; 593  : 
; 594  :     return (strdup(buf));

  00491	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
$LN1@resolve_sy:
$LN32@resolve_sy:

; 595  : }

  0049f	48 8b 8c 24 c0
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a7	48 33 cc	 xor	 rcx, rsp
  004aa	e8 00 00 00 00	 call	 __security_check_cookie
  004af	48 81 c4 d0 08
	00 00		 add	 rsp, 2256		; 000008d0H
  004b6	5f		 pop	 rdi
  004b7	c3		 ret	 0
resolve_symbol_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscutl.c
_TEXT	SEGMENT
tok$ = 32
val$1 = 40
tv132 = 48
raw_tt$2 = 56
raw_tt$3 = 64
buf$ = 80
__$ArrayPad$ = 32848
sym$ = 32880
get_symbol PROC

; 401  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 68 80 00 00	 mov	 eax, 32872		; 00008068H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 50
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 402  :     SYMBOL_TOKEN* tok;
; 403  :     char buf[ MAX_ENVVAR_LEN ];
; 404  : 
; 405  :     if (CMD( sym, DATE, 4 ))

  00024	41 b8 04 00 00
	00		 mov	 r8d, 4
  0002a	48 8b 94 24 70
	80 00 00	 mov	 rdx, QWORD PTR sym$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159179
  00039	e8 00 00 00 00	 call	 strcaseabbrev
  0003e	85 c0		 test	 eax, eax
  00040	74 51		 je	 SHORT $LN2@get_symbol

; 406  :     {
; 407  :         // Rebuild new value each time date/time symbol is retrieved
; 408  :         time_t  raw_tt;
; 409  :         time( &raw_tt );                // YYYYMMDD

  00042	48 8d 4c 24 38	 lea	 rcx, QWORD PTR raw_tt$2[rsp]
  00047	e8 00 00 00 00	 call	 time

; 410  :         strftime( buf, sizeof( buf ) - 1, "%Y%m%d", localtime( &raw_tt ));

  0004c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR raw_tt$2[rsp]
  00051	e8 00 00 00 00	 call	 localtime
  00056	4c 8b c8	 mov	 r9, rax
  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159180
  00060	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00065	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 411  :         set_symbol( sym = "DATE", buf );

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159181
  00077	48 89 84 24 70
	80 00 00	 mov	 QWORD PTR sym$[rsp], rax
  0007f	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$[rsp]
  00084	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  0008c	e8 00 00 00 00	 call	 set_symbol

; 412  :     }

  00091	eb 6d		 jmp	 SHORT $LN3@get_symbol
$LN2@get_symbol:

; 413  :     else if (CMD( sym, TIME, 4 ))

  00093	41 b8 04 00 00
	00		 mov	 r8d, 4
  00099	48 8b 94 24 70
	80 00 00	 mov	 rdx, QWORD PTR sym$[rsp]
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159183
  000a8	e8 00 00 00 00	 call	 strcaseabbrev
  000ad	85 c0		 test	 eax, eax
  000af	74 4f		 je	 SHORT $LN4@get_symbol

; 414  :     {
; 415  :         // Rebuild new value each time date/time symbol is retrieved
; 416  :         time_t  raw_tt;
; 417  :         time( &raw_tt );                // HHMMSS

  000b1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR raw_tt$3[rsp]
  000b6	e8 00 00 00 00	 call	 time

; 418  :         strftime( buf, sizeof( buf ) - 1, "%H%M%S", localtime( &raw_tt ));

  000bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR raw_tt$3[rsp]
  000c0	e8 00 00 00 00	 call	 localtime
  000c5	4c 8b c8	 mov	 r9, rax
  000c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159184
  000cf	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  000d4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 419  :         set_symbol( sym = "TIME", buf );

  000df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159185
  000e6	48 89 84 24 70
	80 00 00	 mov	 QWORD PTR sym$[rsp], rax
  000ee	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$[rsp]
  000f3	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  000fb	e8 00 00 00 00	 call	 set_symbol
$LN4@get_symbol:
$LN3@get_symbol:

; 420  :     }
; 421  : 
; 422  :     if (!(tok = get_symbol_token( sym, 0 )))

  00100	33 d2		 xor	 edx, edx
  00102	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  0010a	e8 00 00 00 00	 call	 get_symbol_token
  0010f	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax
  00114	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0011a	75 74		 jne	 SHORT $LN5@get_symbol

; 423  :     {
; 424  :         // Add this environment variable to our DEFSYM pool
; 425  :         const char* val = getenv( sym );

  0011c	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  0012a	48 89 44 24 28	 mov	 QWORD PTR val$1[rsp], rax

; 426  :         MSGBUF( buf, "%s", val ? val : "" );

  0012f	48 83 7c 24 28
	00		 cmp	 QWORD PTR val$1[rsp], 0
  00135	74 0c		 je	 SHORT $LN7@get_symbol
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR val$1[rsp]
  0013c	48 89 44 24 30	 mov	 QWORD PTR tv132[rsp], rax
  00141	eb 0c		 jmp	 SHORT $LN8@get_symbol
$LN7@get_symbol:
  00143	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159187
  0014a	48 89 44 24 30	 mov	 QWORD PTR tv132[rsp], rax
$LN8@get_symbol:
  0014f	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv132[rsp]
  00154	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159188
  0015b	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00160	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00165	e8 00 00 00 00	 call	 w32_snprintf

; 427  :         set_symbol( sym, buf );

  0016a	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$[rsp]
  0016f	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  00177	e8 00 00 00 00	 call	 set_symbol

; 428  :         // (now try again; should succeed this time)
; 429  :         tok = get_symbol_token( sym, 0 );

  0017c	33 d2		 xor	 edx, edx
  0017e	48 8b 8c 24 70
	80 00 00	 mov	 rcx, QWORD PTR sym$[rsp]
  00186	e8 00 00 00 00	 call	 get_symbol_token
  0018b	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax
$LN5@get_symbol:

; 430  :     }
; 431  :     return tok->val;

  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00195	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 432  : }

  00199	48 8b 8c 24 50
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a1	48 33 cc	 xor	 rcx, rsp
  001a4	e8 00 00 00 00	 call	 __security_check_cookie
  001a9	48 81 c4 68 80
	00 00		 add	 rsp, 32872		; 00008068H
  001b0	c3		 ret	 0
get_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
tv84 = 32
tv73 = 36
tv93 = 40
a$ = 48
s$ = 56
string$ = 80
abbrev$ = 88
n$ = 96
strcaseabbrev PROC

; 91   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     register const char *s = string;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 93   :     register const char *a = abbrev;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 94   :     if (*a &&
; 95   :         *s &&

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 02 01 00
	00		 je	 $LN5@strcaseabb
  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 f2 00 00
	00		 je	 $LN5@strcaseabb
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00054	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00057	3b c1		 cmp	 eax, ecx
  00059	74 30		 je	 SHORT $LN6@strcaseabb
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00060	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00063	e8 00 00 00 00	 call	 asciitoupper
  00068	0f be c0	 movsx	 eax, al
  0006b	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00077	e8 00 00 00 00	 call	 asciitoupper
  0007c	0f be c0	 movsx	 eax, al
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 ae 00 00
	00		 jne	 $LN5@strcaseabb
$LN6@strcaseabb:
$LN2@strcaseabb:

; 96   :         (*a == *s ||
; 97   :         asciitoupper(*a) == asciitoupper(*s)))
; 98   :     {
; 99   :         for (;;)
; 100  :         {
; 101  :             a++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 102  :             if (!*a)

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 31		 jne	 SHORT $LN7@strcaseabb

; 103  :                 return (((uintptr_t)a - (uintptr_t)abbrev) >= n);

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	48 3b c1	 cmp	 rax, rcx
  000bb	72 0a		 jb	 SHORT $LN12@strcaseabb
  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000c5	eb 08		 jmp	 SHORT $LN13@strcaseabb
$LN12@strcaseabb:
  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN13@strcaseabb:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR tv84[rsp]
  000d3	eb 66		 jmp	 SHORT $LN1@strcaseabb
$LN7@strcaseabb:

; 104  :             s++;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 105  :             if (!*s)

  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN8@strcaseabb

; 106  :                 break;

  000ee	eb 49		 jmp	 SHORT $LN3@strcaseabb
$LN8@strcaseabb:

; 107  :             if (*a == *s)

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000fd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 02		 jne	 SHORT $LN9@strcaseabb

; 108  :                 continue;

  00104	eb 85		 jmp	 SHORT $LN2@strcaseabb
$LN9@strcaseabb:

; 109  :             if (asciitoupper(*a) != asciitoupper(*s))

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010e	e8 00 00 00 00	 call	 asciitoupper
  00113	0f be c0	 movsx	 eax, al
  00116	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00122	e8 00 00 00 00	 call	 asciitoupper
  00127	0f be c0	 movsx	 eax, al
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv93[rsp]
  0012e	3b c8		 cmp	 ecx, eax
  00130	74 02		 je	 SHORT $LN10@strcaseabb

; 110  :                 break;

  00132	eb 05		 jmp	 SHORT $LN3@strcaseabb
$LN10@strcaseabb:

; 111  :         }

  00134	e9 52 ff ff ff	 jmp	 $LN2@strcaseabb
$LN3@strcaseabb:
$LN5@strcaseabb:

; 112  :     }
; 113  :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN1@strcaseabb:

; 114  : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
strcaseabbrev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
