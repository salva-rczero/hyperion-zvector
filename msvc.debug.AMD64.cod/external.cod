; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_perform_external_interrupt
PUBLIC	s370_store_status
PUBLIC	store_status
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s390_perform_external_interrupt
PUBLIC	s390_store_status
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	z900_perform_external_interrupt
PUBLIC	z900_store_status
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_tf_0840:PROC
EXTRN	__imp_tf_0844:PROC
EXTRN	__imp_tf_0845:PROC
EXTRN	__imp_tf_0846:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	s370_store_int_timer_locked:PROC
EXTRN	get_tod_clock:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	s370_store_psw:PROC
EXTRN	s370_load_psw:PROC
EXTRN	s390_load_psw:PROC
EXTRN	s390_store_psw:PROC
EXTRN	z900_load_psw:PROC
EXTRN	z900_store_psw:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	insttrace_all:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_perform_external_interrupt DD imagerel $LN111
	DD	imagerel $LN111+5542
	DD	imagerel $unwind$s370_perform_external_interrupt
$pdata$s370_store_status DD imagerel $LN16
	DD	imagerel $LN16+534
	DD	imagerel $unwind$s370_store_status
$pdata$store_status DD imagerel $LN12
	DD	imagerel $LN12+160
	DD	imagerel $unwind$store_status
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s370_external_interrupt DD imagerel s370_external_interrupt
	DD	imagerel s370_external_interrupt+885
	DD	imagerel $unwind$s370_external_interrupt
$pdata$s390_perform_external_interrupt DD imagerel $LN97
	DD	imagerel $LN97+4902
	DD	imagerel $unwind$s390_perform_external_interrupt
$pdata$s390_store_status DD imagerel $LN16
	DD	imagerel $LN16+534
	DD	imagerel $unwind$s390_store_status
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_external_interrupt DD imagerel s390_external_interrupt
	DD	imagerel s390_external_interrupt+956
	DD	imagerel $unwind$s390_external_interrupt
$pdata$z900_perform_external_interrupt DD imagerel $LN104
	DD	imagerel $LN104+5526
	DD	imagerel $unwind$z900_perform_external_interrupt
$pdata$z900_store_status DD imagerel $LN19
	DD	imagerel $LN19+736
	DD	imagerel $unwind$z900_store_status
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_external_interrupt DD imagerel z900_external_interrupt
	DD	imagerel z900_external_interrupt+1029
	DD	imagerel $unwind$z900_external_interrupt
pdata	ENDS
_DATA	SEGMENT
$SG169561 DB	'external.c:48', 00H
	ORG $+2
$SG169562 DB	'*EXTINT', 00H
$SG169571 DB	'external.c:122', 00H
	ORG $+1
$SG169572 DB	'external.c:131', 00H
	ORG $+1
$SG169679 DB	'I', 00H
	ORG $+6
$SG169680 DB	'HHC00840%s Processor %s%02X: External interrupt: interru'
	DB	'pt key', 0aH, 00H
$SG169681 DB	's370_perform_external_interrupt', 00H
$SG169682 DB	'external.c', 00H
	ORG $+1
$SG169702 DB	'I', 00H
	ORG $+2
$SG169703 DB	'HHC00841%s Processor %s%02X: External interrupt: clock c'
	DB	'omparator', 0aH, 00H
	ORG $+1
$SG169712 DB	'I', 00H
	ORG $+2
$SG169704 DB	's370_perform_external_interrupt', 00H
$SG169705 DB	'external.c', 00H
	ORG $+5
$SG169714 DB	's370_perform_external_interrupt', 00H
$SG169723 DB	'I', 00H
	ORG $+6
$SG169713 DB	'HHC00842%s Processor %s%02X: External interrupt: CPU tim'
	DB	'er=%16.16llX', 0aH, 00H
	ORG $+2
$SG169715 DB	'external.c', 00H
	ORG $+5
$SG169725 DB	's370_perform_external_interrupt', 00H
$SG169733 DB	'I', 00H
	ORG $+6
$SG169724 DB	'HHC00843%s Processor %s%02X: External interrupt: interva'
	DB	'l timer', 0aH, 00H
	ORG $+3
$SG169742 DB	'%8.8X', 00H
	ORG $+2
$SG169743 DB	'I', 00H
	ORG $+2
$SG169726 DB	'external.c', 00H
	ORG $+5
$SG169734 DB	'HHC00844%s Processor %s%02X: %1d:%04X: processing block '
	DB	'I/O interrupt: code %4.4X parm %16.16llX status %2.2X subcode'
	DB	' %2.2X', 0aH, 00H
	ORG $+3
$SG169735 DB	's370_perform_external_interrupt', 00H
$SG169736 DB	'external.c', 00H
	ORG $+1
$SG169755 DB	'I', 00H
	ORG $+2
$SG169744 DB	'HHC00845%s Processor %s%02X: External interrupt: block I'
	DB	'/O %s', 0aH, 00H
	ORG $+1
$SG169745 DB	's370_perform_external_interrupt', 00H
$SG169746 DB	'external.c', 00H
	ORG $+5
$SG169756 DB	'HHC00846%s Processor %s%02X: External interrupt: service'
	DB	' signal %8.8X', 0aH, 00H
	ORG $+1
$SG169757 DB	's370_perform_external_interrupt', 00H
$SG169758 DB	'external.c', 00H
	ORG $+1
$SG179932 DB	'I', 00H
	ORG $+2
$SG179825 DB	'C:\papa\MyGit\hyperion-zvector\external.c:48', 00H
	ORG $+3
$SG179826 DB	'*EXTINT', 00H
$SG179834 DB	'C:\papa\MyGit\hyperion-zvector\external.c:122', 00H
	ORG $+2
$SG179835 DB	'C:\papa\MyGit\hyperion-zvector\external.c:131', 00H
	ORG $+2
$SG179933 DB	'HHC00840%s Processor %s%02X: External interrupt: interru'
	DB	'pt key', 0aH, 00H
$SG179934 DB	's390_perform_external_interrupt', 00H
$SG179935 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG179955 DB	'I', 00H
	ORG $+2
$SG179956 DB	'HHC00841%s Processor %s%02X: External interrupt: clock c'
	DB	'omparator', 0aH, 00H
	ORG $+1
$SG179965 DB	'I', 00H
	ORG $+2
$SG179957 DB	's390_perform_external_interrupt', 00H
$SG179958 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+6
$SG179967 DB	's390_perform_external_interrupt', 00H
$SG179974 DB	'I', 00H
	ORG $+6
$SG179966 DB	'HHC00842%s Processor %s%02X: External interrupt: CPU tim'
	DB	'er=%16.16llX', 0aH, 00H
	ORG $+2
$SG179968 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+6
$SG179976 DB	's390_perform_external_interrupt', 00H
$SG179983 DB	'%8.8X', 00H
	ORG $+2
$SG179975 DB	'HHC00844%s Processor %s%02X: %1d:%04X: processing block '
	DB	'I/O interrupt: code %4.4X parm %16.16llX status %2.2X subcode'
	DB	' %2.2X', 0aH, 00H
	ORG $+3
$SG179977 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG179984 DB	'I', 00H
	ORG $+2
$SG179985 DB	'HHC00845%s Processor %s%02X: External interrupt: block I'
	DB	'/O %s', 0aH, 00H
	ORG $+1
$SG179986 DB	's390_perform_external_interrupt', 00H
$SG179987 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG179996 DB	'I', 00H
	ORG $+2
$SG179997 DB	'HHC00846%s Processor %s%02X: External interrupt: service'
	DB	' signal %8.8X', 0aH, 00H
	ORG $+1
$SG179998 DB	's390_perform_external_interrupt', 00H
$SG179999 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG193071 DB	'I', 00H
	ORG $+2
$SG192952 DB	'C:\papa\MyGit\hyperion-zvector\external.c:48', 00H
	ORG $+3
$SG192953 DB	'*EXTINT', 00H
$SG192962 DB	'C:\papa\MyGit\hyperion-zvector\external.c:109', 00H
	ORG $+2
$SG192963 DB	'*TXF EI', 00H
$SG192964 DB	'C:\papa\MyGit\hyperion-zvector\external.c:111', 00H
	ORG $+2
$SG192966 DB	'C:\papa\MyGit\hyperion-zvector\external.c:122', 00H
	ORG $+2
$SG192967 DB	'C:\papa\MyGit\hyperion-zvector\external.c:131', 00H
	ORG $+2
$SG193073 DB	'z900_perform_external_interrupt', 00H
$SG193094 DB	'I', 00H
	ORG $+6
$SG193072 DB	'HHC00840%s Processor %s%02X: External interrupt: interru'
	DB	'pt key', 0aH, 00H
$SG193074 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+6
$SG193095 DB	'HHC00841%s Processor %s%02X: External interrupt: clock c'
	DB	'omparator', 0aH, 00H
	ORG $+1
$SG193104 DB	'I', 00H
	ORG $+2
$SG193096 DB	'z900_perform_external_interrupt', 00H
$SG193097 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+6
$SG193106 DB	'z900_perform_external_interrupt', 00H
$SG193113 DB	'I', 00H
	ORG $+6
$SG193105 DB	'HHC00842%s Processor %s%02X: External interrupt: CPU tim'
	DB	'er=%16.16llX', 0aH, 00H
	ORG $+2
$SG193107 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+6
$SG193115 DB	'z900_perform_external_interrupt', 00H
$SG193124 DB	'%16.16X', 00H
$SG193114 DB	'HHC00844%s Processor %s%02X: %1d:%04X: processing block '
	DB	'I/O interrupt: code %4.4X parm %16.16llX status %2.2X subcode'
	DB	' %2.2X', 0aH, 00H
	ORG $+3
$SG193116 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG193125 DB	'I', 00H
	ORG $+2
$SG193126 DB	'HHC00845%s Processor %s%02X: External interrupt: block I'
	DB	'/O %s', 0aH, 00H
	ORG $+1
$SG193127 DB	'z900_perform_external_interrupt', 00H
$SG193128 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG193134 DB	'%8.8X', 00H
	ORG $+2
$SG193135 DB	'I', 00H
	ORG $+2
$SG193136 DB	'HHC00845%s Processor %s%02X: External interrupt: block I'
	DB	'/O %s', 0aH, 00H
	ORG $+1
$SG193137 DB	'z900_perform_external_interrupt', 00H
$SG193138 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
	ORG $+2
$SG193147 DB	'I', 00H
	ORG $+2
$SG193149 DB	'z900_perform_external_interrupt', 00H
	ORG $+8
$SG193148 DB	'HHC00846%s Processor %s%02X: External interrupt: service'
	DB	' signal %8.8X', 0aH, 00H
	ORG $+1
$SG193150 DB	'C:\papa\MyGit\hyperion-zvector\external.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_perform_external_interrupt
	DD	017H
	DD	0157dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_perform_external_interrupt
	DD	017H
	DD	0130dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_perform_external_interrupt
	DD	017H
	DD	0158dH
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_perform_external_interrupt DD 031f19H
	DD	02a010dH
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0148H
$unwind$s370_store_status DD 010e01H
	DD	0620eH
$unwind$store_status DD 010e01H
	DD	0620eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s370_external_interrupt DD 010d01H
	DD	0c20dH
$unwind$s390_perform_external_interrupt DD 031f19H
	DD	02a010dH
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$s390_store_status DD 010e01H
	DD	0620eH
$unwind$s390_external_interrupt DD 010d01H
	DD	0c20dH
$unwind$z900_perform_external_interrupt DD 031f19H
	DD	032010dH
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$z900_store_status DD 010e01H
	DD	0620eH
$unwind$z900_external_interrupt DD 010d01H
	DD	0c20dH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
rc$ = 64
psa$ = 72
pfx$ = 80
code$ = 112
regs$ = 120
z900_external_interrupt PROC

; 43   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@z900_exter:

; 44   : RADR    pfx;
; 45   : PSA     *psa;
; 46   : int     rc;
; 47   : 
; 48   :     PTT_SIG("*EXTINT",code,regs->cpuad,regs->psw.IA_L);

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 4e		 je	 SHORT $LN11@z900_exter
  00022	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00039	48 63 54 24 70	 movsxd	 rdx, DWORD PTR code$[rsp]
  0003e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00047	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192952
  00053	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00058	44 8b c9	 mov	 r9d, ecx
  0005b	4c 8b c2	 mov	 r8, rdx
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192953
  00065	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@z900_exter:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 97		 jne	 SHORT $LN4@z900_exter

; 49   : 
; 50   : #if defined(_FEATURE_SIE)
; 51   :     /* Set the main storage reference and change bits */
; 52   :     if(SIE_MODE(regs)
; 53   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 54   :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 55   : #endif
; 56   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 57   :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00081	d1 e8		 shr	 eax, 1
  00083	83 e0 01	 and	 eax, 1
  00086	85 c0		 test	 eax, eax
  00088	74 7b		 je	 SHORT $LN12@z900_exter
  0008a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00096	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009a	83 e0 02	 and	 eax, 2
  0009d	85 c0		 test	 eax, eax
  0009f	75 64		 jne	 SHORT $LN12@z900_exter
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 00	 imul	 rcx, rcx, 0
  000b6	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  000bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c0	85 c0		 test	 eax, eax
  000c2	75 41		 jne	 SHORT $LN12@z900_exter

; 58   : #endif
; 59   :                                                             )
; 60   :     {
; 61   :         /* Point to SIE copy of PSA in state descriptor */
; 62   :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  000c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  000e3	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  000e8	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 63   :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  000ed	b2 06		 mov	 dl, 6
  000ef	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  000fb	e8 00 00 00 00	 call	 z900_or_storage_key

; 64   :     }

  00100	e9 b6 00 00 00	 jmp	 $LN13@z900_exter
$LN12@z900_exter:

; 65   :     else
; 66   : #endif /*defined(_FEATURE_SIE)*/
; 67   :     {
; 68   :         /* Point to PSA in main storage */
; 69   :         pfx = regs->PX;

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0010e	48 89 44 24 50	 mov	 QWORD PTR pfx$[rsp], rax
$LN7@z900_exter:

; 70   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 71   :         SIE_TRANSLATE(&pfx, ACCTYPE_SIE, regs);

  00113	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00118	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011e	d1 e8		 shr	 eax, 1
  00120	83 e0 01	 and	 eax, 1
  00123	85 c0		 test	 eax, eax
  00125	74 68		 je	 SHORT $LN14@z900_exter
  00127	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00132	c1 e8 02	 shr	 eax, 2
  00135	83 e0 01	 and	 eax, 1
  00138	85 c0		 test	 eax, eax
  0013a	75 53		 jne	 SHORT $LN14@z900_exter
  0013c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00148	48 03 44 24 50	 add	 rax, QWORD PTR pfx$[rsp]
  0014d	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00156	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0015b	45 33 c9	 xor	 r9d, r9d
  0015e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0016a	ba fd ff ff ff	 mov	 edx, -3
  0016f	48 8b c8	 mov	 rcx, rax
  00172	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00177	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00183	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0018a	48 89 44 24 50	 mov	 QWORD PTR pfx$[rsp], rax
$LN14@z900_exter:
  0018f	33 c0		 xor	 eax, eax
  00191	85 c0		 test	 eax, eax
  00193	0f 85 7a ff ff
	ff		 jne	 $LN7@z900_exter

; 72   : #endif /*defined(_FEATURE_EXPEDITED_SIE_SUBSET)*/
; 73   :         psa = (void*)(regs->mainstor + pfx);

  00199	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001a5	48 03 44 24 50	 add	 rax, QWORD PTR pfx$[rsp]
  001aa	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 74   :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  001af	b2 06		 mov	 dl, 6
  001b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pfx$[rsp]
  001b6	e8 00 00 00 00	 call	 z900_or_storage_key
$LN13@z900_exter:

; 75   :     }
; 76   : 
; 77   :     /* Store the interrupt code in the PSW */
; 78   :     regs->psw.intcode = code;

  001bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  001c5	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 79   : 
; 80   : 
; 81   :     /* Zero extcpuad field unless extcall or ems signal or blockio */
; 82   :     if(code != EXT_EXTERNAL_CALL_INTERRUPT
; 83   : #if defined(FEATURE_VM_BLOCKIO)
; 84   :     && code != EXT_BLOCKIO_INTERRUPT
; 85   : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 86   :     && code != EXT_EMERGENCY_SIGNAL_INTERRUPT)

  001cc	81 7c 24 70 02
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4610 ; 00001202H
  001d4	74 2f		 je	 SHORT $LN15@z900_exter
  001d6	81 7c 24 70 03
	26 00 00	 cmp	 DWORD PTR code$[rsp], 9731 ; 00002603H
  001de	74 25		 je	 SHORT $LN15@z900_exter
  001e0	81 7c 24 70 01
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4609 ; 00001201H
  001e8	74 1b		 je	 SHORT $LN15@z900_exter

; 87   :         STORE_HW(psa->extcpad,0);

  001ea	33 c9		 xor	 ecx, ecx
  001ec	e8 00 00 00 00	 call	 _byteswap_ushort
  001f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR psa$[rsp]
  001f6	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  001fd	0f b7 d0	 movzx	 edx, ax
  00200	e8 00 00 00 00	 call	 store_hw_noswap
$LN15@z900_exter:

; 88   : 
; 89   : #if defined(FEATURE_BCMODE)
; 90   :     /* For ECMODE, store external interrupt code at PSA+X'86' */
; 91   :     if ( ECMODE(&regs->psw) )
; 92   : #endif /*defined(FEATURE_BCMODE)*/
; 93   :         STORE_HW(psa->extint,code);

  00205	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  0020a	e8 00 00 00 00	 call	 _byteswap_ushort
  0020f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR psa$[rsp]
  00214	48 81 c1 86 00
	00 00		 add	 rcx, 134		; 00000086H
  0021b	0f b7 d0	 movzx	 edx, ax
  0021e	e8 00 00 00 00	 call	 store_hw_noswap

; 94   : 
; 95   :     if ( !SIE_MODE(regs)
; 96   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 97   :                        || SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 98   : #endif
; 99   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 100  :                        || SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00223	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00228	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0022e	d1 e8		 shr	 eax, 1
  00230	83 e0 01	 and	 eax, 1
  00233	85 c0		 test	 eax, eax
  00235	74 3e		 je	 SHORT $LN17@z900_exter
  00237	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0023c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00243	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00247	83 e0 02	 and	 eax, 2
  0024a	85 c0		 test	 eax, eax
  0024c	75 27		 jne	 SHORT $LN17@z900_exter
  0024e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00253	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0025a	b9 01 00 00 00	 mov	 ecx, 1
  0025f	48 6b c9 00	 imul	 rcx, rcx, 0
  00263	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00268	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0026d	85 c0		 test	 eax, eax
  0026f	0f 84 fa 00 00
	00		 je	 $LN16@z900_exter
$LN17@z900_exter:

; 101  : #endif
; 102  :        )
; 103  :     {
; 104  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 105  :         /* Abort any active transaction and then return back to here
; 106  :            to continue with external interrupt processing */
; 107  :         if (regs->txf_tnd)

  00275	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0027a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00281	85 c0		 test	 eax, eax
  00283	0f 84 8c 00 00
	00		 je	 $LN18@z900_exter
$LN10@z900_exter:

; 108  :         {
; 109  :             PTT_TXF( "*TXF EI", 0, 0, regs->txf_tnd );

  00289	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00290	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00293	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00299	48 85 c0	 test	 rax, rax
  0029c	74 3e		 je	 SHORT $LN19@z900_exter
  0029e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002a3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002aa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192962
  002bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c4	45 33 c9	 xor	 r9d, r9d
  002c7	45 33 c0	 xor	 r8d, r8d
  002ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192963
  002d1	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@z900_exter:
  002dc	33 c0		 xor	 eax, eax
  002de	85 c0		 test	 eax, eax
  002e0	75 a7		 jne	 SHORT $LN10@z900_exter

; 110  :             regs->txf_why |= TXF_WHY_EXT_INT;

  002e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002e7	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  002ed	0f ba e8 17	 bts	 eax, 23
  002f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f6	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 111  :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_EXT );

  002fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192964
  00303	41 b8 02 00 00
	00		 mov	 r8d, 2
  00309	33 d2		 xor	 edx, edx
  0030b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00310	e8 00 00 00 00	 call	 z900_abort_transaction
$LN18@z900_exter:

; 112  :         }
; 113  : #endif
; 114  :         /* Store current PSW at PSA+X'18' */
; 115  :         ARCH_DEP(store_psw) (regs, psa->extold);

  00315	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  0031a	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  00320	48 8b d0	 mov	 rdx, rax
  00323	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00328	e8 00 00 00 00	 call	 z900_store_psw

; 116  : 
; 117  :         /* Load new PSW from PSA+X'58' */
; 118  :         rc = ARCH_DEP(load_psw) (regs, psa->extnew);

  0032d	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  00332	48 05 b0 01 00
	00		 add	 rax, 432		; 000001b0H
  00338	48 8b d0	 mov	 rdx, rax
  0033b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00340	e8 00 00 00 00	 call	 z900_load_psw
  00345	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 119  : 
; 120  :         if ( rc )

  00349	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0034e	74 1f		 je	 SHORT $LN20@z900_exter

; 121  :         {
; 122  :             RELEASE_INTLOCK(regs);

  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192966
  00357	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0035c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 123  :             ARCH_DEP(program_interrupt)(regs, rc);

  00361	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  00365	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0036a	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_exter:
$LN16@z900_exter:

; 124  :         }
; 125  :     }
; 126  : 
; 127  : #if defined(FEATURE_INTERVAL_TIMER)
; 128  :     /* Ensure the interval timer is uptodate */
; 129  :     ARCH_DEP( store_int_timer_locked )( regs );
; 130  : #endif
; 131  :     RELEASE_INTLOCK(regs);

  0036f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192967
  00376	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0037b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 132  : 
; 133  : 
; 134  :     if ( SIE_MODE(regs)
; 135  : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 136  :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 137  : #endif
; 138  : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 139  :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00380	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00385	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0038b	d1 e8		 shr	 eax, 1
  0038d	83 e0 01	 and	 eax, 1
  00390	85 c0		 test	 eax, eax
  00392	74 54		 je	 SHORT $LN21@z900_exter
  00394	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00399	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003a0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003a4	83 e0 02	 and	 eax, 2
  003a7	85 c0		 test	 eax, eax
  003a9	75 3d		 jne	 SHORT $LN21@z900_exter
  003ab	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003b0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003b7	b9 01 00 00 00	 mov	 ecx, 1
  003bc	48 6b c9 00	 imul	 rcx, rcx, 0
  003c0	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  003c5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ca	85 c0		 test	 eax, eax
  003cc	75 1a		 jne	 SHORT $LN21@z900_exter

; 140  : #endif
; 141  :        )
; 142  :         longjmp (regs->progjmp, SIE_INTERCEPT_EXT);

  003ce	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003d3	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  003d9	ba f4 ff ff ff	 mov	 edx, -12
  003de	48 8b c8	 mov	 rcx, rax
  003e1	e8 00 00 00 00	 call	 longjmp
  003e6	eb 18		 jmp	 SHORT $LN22@z900_exter
$LN21@z900_exter:

; 143  :     else
; 144  :         longjmp (regs->progjmp, SIE_NO_INTERCEPT);

  003e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ed	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  003f3	ba ff ff ff ff	 mov	 edx, -1
  003f8	48 8b c8	 mov	 rcx, rax
  003fb	e8 00 00 00 00	 call	 longjmp
$LN22@z900_exter:
$LN23@z900_exter:

; 145  : 
; 146  : } /* end function external_interrupt */

  00400	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00404	c3		 ret	 0
z900_external_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
i$ = 32
sspsa$ = 40
ssreg$ = 64
aaddr$ = 72
z900_store_status PROC

; 556  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 557  : int     i;                              /* Array subscript           */
; 558  : PSA     *sspsa;                         /* -> Store status area      */
; 559  : 
; 560  :     /* Set reference and change bits */
; 561  :     ARCH_DEP( or_storage_key )( aaddr, (STORKEY_REF | STORKEY_CHANGE) );

  0000e	b2 06		 mov	 dl, 6
  00010	48 8b 4c 24 48	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00015	e8 00 00 00 00	 call	 z900_or_storage_key

; 562  : 
; 563  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 564  : 
; 565  :     /* The ESAME PSA is two pages in size */
; 566  :     if(!aaddr)

  0001a	48 83 7c 24 48
	00		 cmp	 QWORD PTR aaddr$[rsp], 0
  00020	75 15		 jne	 SHORT $LN14@z900_store

; 567  :         ARCH_DEP( or_storage_key )( aaddr + 4096, (STORKEY_REF | STORKEY_CHANGE) );

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  00027	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0002d	b2 06		 mov	 dl, 6
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 z900_or_storage_key
$LN14@z900_store:

; 568  : 
; 569  :     /* For store status at address, we must adjust the PSA offset */
; 570  :     /* ZZ THIS TEST IS NOT CONCLUSIVE */
; 571  :     if(aaddr != 0 && aaddr != ssreg->PX)

  00037	48 83 7c 24 48
	00		 cmp	 QWORD PTR aaddr$[rsp], 0
  0003d	74 20		 je	 SHORT $LN15@z900_store
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  00044	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00048	48 39 44 24 48	 cmp	 QWORD PTR aaddr$[rsp], rax
  0004d	74 10		 je	 SHORT $LN15@z900_store

; 572  :         aaddr -= 512 + 4096 ;

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  00054	48 2d 00 12 00
	00		 sub	 rax, 4608		; 00001200H
  0005a	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax
$LN15@z900_store:

; 573  : #endif
; 574  : 
; 575  :     aaddr &= 0x7FFFFE00;

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  00064	48 25 00 fe ff
	7f		 and	 rax, 2147483136		; 7ffffe00H
  0006a	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax

; 576  : 
; 577  :     /* Point to the PSA into which status is to be stored */
; 578  :     sspsa = (void*)(ssreg->mainstor + aaddr);

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  00074	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0007b	48 03 44 24 48	 add	 rax, QWORD PTR aaddr$[rsp]
  00080	48 89 44 24 28	 mov	 QWORD PTR sspsa$[rsp], rax

; 579  : 
; 580  :     /* Store CPU timer in bytes 216-223 */
; 581  :     STORE_DW(sspsa->storeptmr, get_cpu_timer(ssreg));

  00085	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0008a	e8 00 00 00 00	 call	 get_cpu_timer
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 _byteswap_uint64
  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  0009c	48 81 c1 28 13
	00 00		 add	 rcx, 4904		; 00001328H
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	e8 00 00 00 00	 call	 store_dw_noswap

; 582  : 
; 583  :     /* Store clock comparator in bytes 224-231 */
; 584  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 585  :     STORE_DW( sspsa->storeclkc, ssreg->clkc );

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  000b0	48 8b 88 48 07
	00 00		 mov	 rcx, QWORD PTR [rax+1864]
  000b7	e8 00 00 00 00	 call	 _byteswap_uint64
  000bc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  000c1	48 81 c1 30 13
	00 00		 add	 rcx, 4912		; 00001330H
  000c8	48 8b d0	 mov	 rdx, rax
  000cb	e8 00 00 00 00	 call	 store_dw_noswap

; 586  : #else
; 587  :     STORE_DW( sspsa->storeclkc, ssreg->clkc << 8 );
; 588  : #endif
; 589  : 
; 590  :     /* Store PSW in bytes 256-263 */
; 591  :     ARCH_DEP(store_psw) (ssreg, sspsa->storepsw);

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  000d5	48 05 00 13 00
	00		 add	 rax, 4864		; 00001300H
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  000e3	e8 00 00 00 00	 call	 z900_store_psw

; 592  : 
; 593  :     /* Store prefix register in bytes 264-267 */
; 594  :     STORE_FW(sspsa->storepfx,ssreg->PX);

  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  000ed	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  000fa	48 81 c1 18 13
	00 00		 add	 rcx, 4888		; 00001318H
  00101	8b d0		 mov	 edx, eax
  00103	e8 00 00 00 00	 call	 store_fw_noswap

; 595  : 
; 596  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 597  :     /* Store Floating Point Control Register */
; 598  :     STORE_FW(sspsa->storefpc,ssreg->fpc);

  00108	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  0010d	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [rax+960]
  00113	e8 00 00 00 00	 call	 _byteswap_ulong
  00118	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  0011d	48 81 c1 1c 13
	00 00		 add	 rcx, 4892		; 0000131cH
  00124	8b d0		 mov	 edx, eax
  00126	e8 00 00 00 00	 call	 store_fw_noswap

; 599  : 
; 600  :     /* Store TOD Programable register */
; 601  :     STORE_FW(sspsa->storetpr,ssreg->todpr);

  0012b	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  00130	8b 88 58 07 00
	00		 mov	 ecx, DWORD PTR [rax+1880]
  00136	e8 00 00 00 00	 call	 _byteswap_ulong
  0013b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  00140	48 81 c1 24 13
	00 00		 add	 rcx, 4900		; 00001324H
  00147	8b d0		 mov	 edx, eax
  00149	e8 00 00 00 00	 call	 store_fw_noswap

; 602  : #endif
; 603  : 
; 604  : #if defined( _900 )
; 605  :     /* Only store the arch mode indicator for a PSA type store status */
; 606  :     if (!aaddr)

  0014e	48 83 7c 24 48
	00		 cmp	 QWORD PTR aaddr$[rsp], 0
  00154	75 0c		 jne	 SHORT $LN16@z900_store

; 607  :   #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 608  :         sspsa->arch = 1;

  00156	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  0015b	c6 80 a3 00 00
	00 01		 mov	 BYTE PTR [rax+163], 1
$LN16@z900_store:

; 609  :   #else
; 610  :         sspsa->arch = 0;
; 611  :   #endif
; 612  : #endif /* defined( _900 ) */
; 613  : 
; 614  :     /* Store access registers in bytes 288-351 */
; 615  :     for (i = 0; i < 16; i++)

  00162	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0016a	eb 0a		 jmp	 SHORT $LN4@z900_store
$LN2@z900_store:
  0016c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00170	ff c0		 inc	 eax
  00172	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_store:
  00176	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  0017b	7d 31		 jge	 SHORT $LN3@z900_store

; 616  :         STORE_FW(sspsa->storear[i],ssreg->AR(i));

  0017d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00182	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00187	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  0018e	e8 00 00 00 00	 call	 _byteswap_ulong
  00193	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00198	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  0019d	48 8d 8c 8a 40
	13 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+4928]
  001a5	8b d0		 mov	 edx, eax
  001a7	e8 00 00 00 00	 call	 store_fw_noswap
  001ac	eb be		 jmp	 SHORT $LN2@z900_store
$LN3@z900_store:

; 617  : 
; 618  :     /* Store floating-point registers in bytes 352-383 */
; 619  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 620  :     for (i = 0; i < 32; i++)

  001ae	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001b6	eb 0a		 jmp	 SHORT $LN7@z900_store
$LN5@z900_store:
  001b8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001bc	ff c0		 inc	 eax
  001be	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_store:
  001c2	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  001c7	7d 31		 jge	 SHORT $LN6@z900_store

; 621  : #else
; 622  :     for (i = 0; i < 8; i++)
; 623  : #endif
; 624  :         STORE_FW(sspsa->storefpr[i],ssreg->fpr[i]);

  001c9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  001d3	8b 8c 81 40 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+832]
  001da	e8 00 00 00 00	 call	 _byteswap_ulong
  001df	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001e4	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  001e9	48 8d 8c 8a 00
	12 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+4608]
  001f1	8b d0		 mov	 edx, eax
  001f3	e8 00 00 00 00	 call	 store_fw_noswap
  001f8	eb be		 jmp	 SHORT $LN5@z900_store
$LN6@z900_store:

; 625  : 
; 626  :     /* Store general-purpose registers in bytes 384-447 */
; 627  :     for (i = 0; i < 16; i++)

  001fa	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00202	eb 0a		 jmp	 SHORT $LN10@z900_store
$LN8@z900_store:
  00204	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00208	ff c0		 inc	 eax
  0020a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_store:
  0020e	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00213	7d 33		 jge	 SHORT $LN9@z900_store

; 628  :         STORE_W(sspsa->storegpr[i],ssreg->GR(i));

  00215	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0021a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0021f	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00227	e8 00 00 00 00	 call	 _byteswap_uint64
  0022c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00231	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00236	48 8d 8c ca 80
	12 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+4736]
  0023e	48 8b d0	 mov	 rdx, rax
  00241	e8 00 00 00 00	 call	 store_dw_noswap
  00246	eb bc		 jmp	 SHORT $LN8@z900_store
$LN9@z900_store:

; 629  : 
; 630  :     /* Store control registers in bytes 448-511 */
; 631  :     for (i = 0; i < 16; i++)

  00248	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00250	eb 0a		 jmp	 SHORT $LN13@z900_store
$LN11@z900_store:
  00252	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00256	ff c0		 inc	 eax
  00258	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_store:
  0025c	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00261	7d 36		 jge	 SHORT $LN12@z900_store

; 632  :         STORE_W(sspsa->storecr[i],ssreg->CR(i));

  00263	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00267	ff c0		 inc	 eax
  00269	48 98		 cdqe
  0026b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00270	48 8b 8c c1 00
	06 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+1536]
  00278	e8 00 00 00 00	 call	 _byteswap_uint64
  0027d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00282	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00287	48 8d 8c ca 80
	13 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+4992]
  0028f	48 8b d0	 mov	 rdx, rax
  00292	e8 00 00 00 00	 call	 store_dw_noswap
  00297	eb b9		 jmp	 SHORT $LN11@z900_store
$LN12@z900_store:

; 633  : 
; 634  :     /* Store Breaking-Event Address Register if BEAR-Enhancement */
; 635  : #if defined( FEATURE_193_BEAR_ENH_FACILITY )
; 636  :     if (FACILITY_ENABLED( 193_BEAR_ENH, ssreg ))

  00299	b8 01 00 00 00	 mov	 eax, 1
  0029e	48 6b c0 18	 imul	 rax, rax, 24
  002a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  002a7	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  002af	83 e0 40	 and	 eax, 64			; 00000040H
  002b2	85 c0		 test	 eax, eax
  002b4	74 25		 je	 SHORT $LN17@z900_store

; 637  :         STORE_DW( sspsa->bear, ssreg->bear );

  002b6	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  002bb	48 8b 88 18 02
	00 00		 mov	 rcx, QWORD PTR [rax+536]
  002c2	e8 00 00 00 00	 call	 _byteswap_uint64
  002c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  002cc	48 81 c1 38 13
	00 00		 add	 rcx, 4920		; 00001338H
  002d3	48 8b d0	 mov	 rdx, rax
  002d6	e8 00 00 00 00	 call	 store_dw_noswap
$LN17@z900_store:

; 638  : #endif
; 639  : 
; 640  : } /* end function store_status */

  002db	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002df	c3		 ret	 0
z900_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
cpuad$ = 128
servcode$ = 132
psa$ = 136
i$1 = 144
i$2 = 148
tv440 = 152
mask$3 = 160
mask$4 = 168
tv82 = 176
tv339 = 180
tv408 = 184
tv454 = 188
tv457 = 192
tv462 = 196
tv466 = 200
tv471 = 204
tv474 = 208
tv537 = 212
tv611 = 216
tv712 = 220
servpadr$ = 224
tv673 = 232
tv84 = 240
tv341 = 248
tv402 = 256
tv410 = 264
tv476 = 272
tv539 = 280
tv613 = 288
tv714 = 296
buf$5 = 304
buf$6 = 344
__$ArrayPad$ = 384
regs$ = 416
z900_perform_external_interrupt PROC

; 165  : {

$LN104:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 166  : PSA    *psa;                            /* -> Prefixed storage area  */
; 167  : U16     cpuad;                          /* Originating CPU address   */
; 168  : #if defined( FEATURE_VM_BLOCKIO )
; 169  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 170  : RADR    servpadr;      /* Address of 64-bit block I/O interrupt */
; 171  : #endif
; 172  : U16     servcode;      /* Service Signal or Block I/O Interrupt code */
; 173  : #endif /* defined( FEATURE_VM_BLOCKIO ) */
; 174  : 
; 175  :     /* External interrupt if console interrupt key was depressed */
; 176  :     if ( OPEN_IC_INTKEY(regs) && !SIE_MODE(regs) )

  0001f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00032	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00035	23 c1		 and	 eax, ecx
  00037	83 e0 40	 and	 eax, 64			; 00000040H
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 e3 01 00
	00		 je	 $LN47@z900_perfo
  00042	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00050	d1 e8		 shr	 eax, 1
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	0f 85 c8 01 00
	00		 jne	 $LN47@z900_perfo

; 177  :     {
; 178  :         if (regs->insttrace && sysblk.traceFILE)

  0005d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0006b	c1 e8 0f	 shr	 eax, 15
  0006e	83 e0 01	 and	 eax, 1
  00071	85 c0		 test	 eax, eax
  00073	74 23		 je	 SHORT $LN48@z900_perfo
  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00084	74 12		 je	 SHORT $LN48@z900_perfo

; 179  :             tf_0840( regs, EXT_INTERRUPT_KEY_INTERRUPT );

  00086	66 ba 40 00	 mov	 dx, 64			; 00000040H
  0008a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
$LN48@z900_perfo:

; 180  : 
; 181  :         // "Processor %s%02X: External interrupt: interrupt key"
; 182  :         WRMSG( HHC00840, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  00098	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000a7	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000ae	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c4	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000d2	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e5	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  000f8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193071
  00104	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193072
  00110	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193073
  00127	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193074
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@z900_perfo:

; 183  : 
; 184  :         /* Reset interrupt key pending */
; 185  :         OFF_IC_INTKEY;

  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00140	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00146	83 e0 40	 and	 eax, 64			; 00000040H
  00149	85 c0		 test	 eax, eax
  0014b	0f 84 b8 00 00
	00		 je	 $LN49@z900_perfo
  00151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00158	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0015e	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00168	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00175	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0017c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00184	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  0018f	eb 10		 jmp	 SHORT $LN7@z900_perfo
$LN5@z900_perfo:
  00191	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  00198	ff c0		 inc	 eax
  0019a	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN7@z900_perfo:
  001a1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR mask$3[rsp], 0
  001aa	74 5d		 je	 SHORT $LN6@z900_perfo
  001ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 37		 je	 SHORT $LN50@z900_perfo
  001bd	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  001c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001cc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d7	83 e0 bf	 and	 eax, -65		; ffffffbfH
  001da	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001e2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001f1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN50@z900_perfo:
  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001fc	48 d1 e8	 shr	 rax, 1
  001ff	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00207	eb 88		 jmp	 SHORT $LN5@z900_perfo
$LN6@z900_perfo:
$LN49@z900_perfo:
  00209	33 c0		 xor	 eax, eax
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 26 ff ff
	ff		 jne	 $LN4@z900_perfo

; 186  : 
; 187  :         /* Generate interrupt key interrupt */
; 188  :         ARCH_DEP(external_interrupt) (EXT_INTERRUPT_KEY_INTERRUPT, regs);

  00213	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0021b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00220	e8 00 00 00 00	 call	 z900_external_interrupt
$LN47@z900_perfo:

; 189  :     }
; 190  : 
; 191  :     /* External interrupt if malfunction alert is pending */
; 192  :     if (OPEN_IC_MALFALT(regs))

  00225	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00235	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00238	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0023b	23 c1		 and	 eax, ecx
  0023d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00242	85 c0		 test	 eax, eax
  00244	0f 84 a8 01 00
	00		 je	 $LN51@z900_perfo

; 193  :     {
; 194  :         /* Find first CPU which generated a malfunction alert */
; 195  :         for (cpuad = 0; regs->malfcpu[cpuad] == 0; cpuad++)

  0024a	33 c0		 xor	 eax, eax
  0024c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00254	eb 13		 jmp	 SHORT $LN10@z900_perfo
$LN8@z900_perfo:
  00256	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0025e	66 ff c0	 inc	 ax
  00261	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN10@z900_perfo:
  00269	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00271	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00281	85 c0		 test	 eax, eax
  00283	75 3e		 jne	 SHORT $LN9@z900_perfo

; 196  :         {
; 197  :             if (cpuad >= sysblk.maxcpu)

  00285	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0028d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00294	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  0029a	7c 25		 jl	 SHORT $LN52@z900_perfo
$LN13@z900_perfo:

; 198  :             {
; 199  :                 OFF_IC_MALFALT(regs);

  0029c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002a7	0f ba f0 0f	 btr	 eax, 15
  002ab	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  002b6	33 c0		 xor	 eax, eax
  002b8	85 c0		 test	 eax, eax
  002ba	75 e0		 jne	 SHORT $LN13@z900_perfo

; 200  :                 return;

  002bc	e9 bc 12 00 00	 jmp	 $LN1@z900_perfo
$LN52@z900_perfo:

; 201  :             }
; 202  :         } /* end for(cpuad) */

  002c1	eb 93		 jmp	 SHORT $LN8@z900_perfo
$LN9@z900_perfo:

; 203  : 
; 204  : // /*debug*/ LOGMSG( "External interrupt: Malfuction Alert from CPU %d\n",
; 205  : // /*debug*/    cpuad );
; 206  : 
; 207  :         /* Reset the indicator for the CPU which was found */
; 208  :         regs->malfcpu[cpuad] = 0;

  002c3	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  002cb	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	c6 84 01 00 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+256], 0

; 209  : 
; 210  :         /* Store originating CPU address at PSA+X'84' */
; 211  :         psa = (void*)(regs->mainstor + regs->PX);

  002db	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002ea	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  002f6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 212  :         STORE_HW(psa->extcpad,cpuad);

  002fe	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00306	e8 00 00 00 00	 call	 _byteswap_ushort
  0030b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00313	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  0031a	0f b7 d0	 movzx	 edx, ax
  0031d	e8 00 00 00 00	 call	 store_hw_noswap
$LN16@z900_perfo:

; 213  : 
; 214  :         /* Reset emergency signal pending flag if there are
; 215  :            no other CPUs which generated emergency signal */
; 216  :         OFF_IC_MALFALT(regs);

  00322	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0032d	0f ba f0 0f	 btr	 eax, 15
  00331	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0033c	33 c0		 xor	 eax, eax
  0033e	85 c0		 test	 eax, eax
  00340	75 e0		 jne	 SHORT $LN16@z900_perfo
$LN17@z900_perfo:

; 217  :         while (++cpuad < sysblk.maxcpu)

  00342	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0034a	66 ff c0	 inc	 ax
  0034d	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00355	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0035d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00364	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  0036a	7d 74		 jge	 SHORT $LN18@z900_perfo

; 218  :         {
; 219  :             if (regs->malfcpu[cpuad])

  0036c	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00374	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00384	85 c0		 test	 eax, eax
  00386	74 53		 je	 SHORT $LN53@z900_perfo
$LN21@z900_perfo:

; 220  :             {
; 221  :                 ON_IC_MALFALT(regs);

  00388	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00390	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00393	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00398	85 c0		 test	 eax, eax
  0039a	74 1d		 je	 SHORT $LN54@z900_perfo
  0039c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003a7	0d 00 80 00 80	 or	 eax, -2147450880	; 80008000H
  003ac	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003b7	eb 1a		 jmp	 SHORT $LN55@z900_perfo
$LN54@z900_perfo:
  003b9	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003c4	0f ba e8 0f	 bts	 eax, 15
  003c8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d0	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN55@z900_perfo:
  003d3	33 c0		 xor	 eax, eax
  003d5	85 c0		 test	 eax, eax
  003d7	75 af		 jne	 SHORT $LN21@z900_perfo

; 222  :                 break;

  003d9	eb 05		 jmp	 SHORT $LN18@z900_perfo
$LN53@z900_perfo:

; 223  :             }
; 224  :         } /* end while */

  003db	e9 62 ff ff ff	 jmp	 $LN17@z900_perfo
$LN18@z900_perfo:

; 225  : 
; 226  :         /* Generate emergency signal interrupt */
; 227  :         ARCH_DEP(external_interrupt) (EXT_MALFUNCTION_ALERT_INTERRUPT, regs);

  003e0	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e8	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  003ed	e8 00 00 00 00	 call	 z900_external_interrupt
$LN51@z900_perfo:

; 228  :     }
; 229  : 
; 230  :     /* External interrupt if emergency signal is pending */
; 231  :     if (OPEN_IC_EMERSIG(regs))

  003f2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fa	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00405	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00408	23 c1		 and	 eax, ecx
  0040a	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0040f	85 c0		 test	 eax, eax
  00411	0f 84 a8 01 00
	00		 je	 $LN56@z900_perfo

; 232  :     {
; 233  :         /* Find first CPU which generated an emergency signal */
; 234  :         for (cpuad = 0; regs->emercpu[cpuad] == 0; cpuad++)

  00417	33 c0		 xor	 eax, eax
  00419	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00421	eb 13		 jmp	 SHORT $LN24@z900_perfo
$LN22@z900_perfo:
  00423	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0042b	66 ff c0	 inc	 ax
  0042e	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN24@z900_perfo:
  00436	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0043e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00446	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  0044e	85 c0		 test	 eax, eax
  00450	75 3e		 jne	 SHORT $LN23@z900_perfo

; 235  :         {
; 236  :             if (cpuad >= sysblk.maxcpu)

  00452	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0045a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00461	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00467	7c 25		 jl	 SHORT $LN57@z900_perfo
$LN27@z900_perfo:

; 237  :             {
; 238  :                 OFF_IC_EMERSIG(regs);

  00469	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00471	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00474	0f ba f0 0e	 btr	 eax, 14
  00478	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00480	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00483	33 c0		 xor	 eax, eax
  00485	85 c0		 test	 eax, eax
  00487	75 e0		 jne	 SHORT $LN27@z900_perfo

; 239  :                 return;

  00489	e9 ef 10 00 00	 jmp	 $LN1@z900_perfo
$LN57@z900_perfo:

; 240  :             }
; 241  :         } /* end for(cpuad) */

  0048e	eb 93		 jmp	 SHORT $LN22@z900_perfo
$LN23@z900_perfo:

; 242  : 
; 243  : // /*debug*/ LOGMSG( "External interrupt: Emergency Signal from CPU %d\n",
; 244  : // /*debug*/    cpuad );
; 245  : 
; 246  :         /* Reset the indicator for the CPU which was found */
; 247  :         regs->emercpu[cpuad] = 0;

  00490	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00498	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a0	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0

; 248  : 
; 249  :         /* Store originating CPU address at PSA+X'84' */
; 250  :         psa = (void*)(regs->mainstor + regs->PX);

  004a8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  004b7	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bf	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  004c3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 251  :         STORE_HW(psa->extcpad,cpuad);

  004cb	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  004d3	e8 00 00 00 00	 call	 _byteswap_ushort
  004d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  004e0	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  004e7	0f b7 d0	 movzx	 edx, ax
  004ea	e8 00 00 00 00	 call	 store_hw_noswap
$LN30@z900_perfo:

; 252  : 
; 253  :         /* Reset emergency signal pending flag if there are
; 254  :            no other CPUs which generated emergency signal */
; 255  :         OFF_IC_EMERSIG(regs);

  004ef	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004fa	0f ba f0 0e	 btr	 eax, 14
  004fe	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00506	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00509	33 c0		 xor	 eax, eax
  0050b	85 c0		 test	 eax, eax
  0050d	75 e0		 jne	 SHORT $LN30@z900_perfo
$LN31@z900_perfo:

; 256  :         while (++cpuad < sysblk.maxcpu)

  0050f	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00517	66 ff c0	 inc	 ax
  0051a	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00522	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0052a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00531	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00537	7d 74		 jge	 SHORT $LN32@z900_perfo

; 257  :         {
; 258  :             if (regs->emercpu[cpuad])

  00539	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00541	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00549	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  00551	85 c0		 test	 eax, eax
  00553	74 53		 je	 SHORT $LN58@z900_perfo
$LN35@z900_perfo:

; 259  :             {
; 260  :                 ON_IC_EMERSIG(regs);

  00555	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00560	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00565	85 c0		 test	 eax, eax
  00567	74 1d		 je	 SHORT $LN59@z900_perfo
  00569	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00574	0d 00 40 00 80	 or	 eax, -2147467264	; 80004000H
  00579	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00581	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00584	eb 1a		 jmp	 SHORT $LN60@z900_perfo
$LN59@z900_perfo:
  00586	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00591	0f ba e8 0e	 bts	 eax, 14
  00595	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN60@z900_perfo:
  005a0	33 c0		 xor	 eax, eax
  005a2	85 c0		 test	 eax, eax
  005a4	75 af		 jne	 SHORT $LN35@z900_perfo

; 261  :                 break;

  005a6	eb 05		 jmp	 SHORT $LN32@z900_perfo
$LN58@z900_perfo:

; 262  :             }
; 263  :         } /* end while */

  005a8	e9 62 ff ff ff	 jmp	 $LN31@z900_perfo
$LN32@z900_perfo:

; 264  : 
; 265  :         /* Generate emergency signal interrupt */
; 266  :         ARCH_DEP(external_interrupt) (EXT_EMERGENCY_SIGNAL_INTERRUPT, regs);

  005ad	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b5	b9 01 12 00 00	 mov	 ecx, 4609		; 00001201H
  005ba	e8 00 00 00 00	 call	 z900_external_interrupt
$LN56@z900_perfo:

; 267  :     }
; 268  : 
; 269  :     /* External interrupt if external call is pending */
; 270  :     if (OPEN_IC_EXTCALL(regs))

  005bf	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c7	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005cf	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  005d2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005d5	23 c1		 and	 eax, ecx
  005d7	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  005dc	85 c0		 test	 eax, eax
  005de	74 7d		 je	 SHORT $LN61@z900_perfo
$LN38@z900_perfo:

; 271  :     {
; 272  : //  /*debug*/ LOGMSG( "External interrupt: External Call from CPU %d\n",
; 273  : //  /*debug*/       regs->extccpu );
; 274  : 
; 275  :         /* Reset external call pending */
; 276  :         OFF_IC_EXTCALL(regs);

  005e0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e8	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005eb	0f ba f0 0d	 btr	 eax, 13
  005ef	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f7	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  005fa	33 c0		 xor	 eax, eax
  005fc	85 c0		 test	 eax, eax
  005fe	75 e0		 jne	 SHORT $LN38@z900_perfo

; 277  : 
; 278  :         /* Store originating CPU address at PSA+X'84' */
; 279  :         psa = (void*)(regs->mainstor + regs->PX);

  00600	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00608	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0060f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00617	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  0061b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 280  :         STORE_HW(psa->extcpad,regs->extccpu);

  00623	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062b	0f b7 48 62	 movzx	 ecx, WORD PTR [rax+98]
  0062f	e8 00 00 00 00	 call	 _byteswap_ushort
  00634	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0063c	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00643	0f b7 d0	 movzx	 edx, ax
  00646	e8 00 00 00 00	 call	 store_hw_noswap

; 281  : 
; 282  :         /* Generate external call interrupt */
; 283  :         ARCH_DEP(external_interrupt) (EXT_EXTERNAL_CALL_INTERRUPT, regs);

  0064b	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00653	b9 02 12 00 00	 mov	 ecx, 4610		; 00001202H
  00658	e8 00 00 00 00	 call	 z900_external_interrupt
$LN61@z900_perfo:

; 284  :     }
; 285  : 
; 286  :     /* External interrupt if TOD clock exceeds clock comparator */
; 287  :     if (1
; 288  :         && get_tod_clock( regs ) > regs->clkc
; 289  :         && OPEN_IC_CLKC( regs )

  0065d	33 c0		 xor	 eax, eax
  0065f	83 f8 01	 cmp	 eax, 1
  00662	0f 84 fa 01 00
	00		 je	 $LN62@z900_perfo
  00668	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00670	e8 00 00 00 00	 call	 get_tod_clock
  00675	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067d	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  00684	0f 86 d8 01 00
	00		 jbe	 $LN62@z900_perfo
  0068a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0069a	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0069d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006a0	23 c1		 and	 eax, ecx
  006a2	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  006a7	85 c0		 test	 eax, eax
  006a9	0f 84 b3 01 00
	00		 je	 $LN62@z900_perfo

; 290  :     )
; 291  :     {
; 292  :         if (1
; 293  :             && CPU_STEPPING_OR_TRACING_ALL
; 294  :             && !TXF_INSTR_TRACING()

  006af	33 c0		 xor	 eax, eax
  006b1	83 f8 01	 cmp	 eax, 1
  006b4	0f 84 96 01 00
	00		 je	 $LN63@z900_perfo
  006ba	b8 08 00 00 00	 mov	 eax, 8
  006bf	48 6b c0 00	 imul	 rax, rax, 0
  006c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006ca	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006d3	75 32		 jne	 SHORT $LN65@z900_perfo
  006d5	b8 08 00 00 00	 mov	 eax, 8
  006da	48 6b c0 01	 imul	 rax, rax, 1
  006de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006e5	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006ee	75 17		 jne	 SHORT $LN65@z900_perfo
  006f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006fd	c1 e8 0a	 shr	 eax, 10
  00700	83 e0 01	 and	 eax, 1
  00703	85 c0		 test	 eax, eax
  00705	75 4e		 jne	 SHORT $LN64@z900_perfo
$LN65@z900_perfo:
  00707	b8 08 00 00 00	 mov	 eax, 8
  0070c	48 6b c0 00	 imul	 rax, rax, 0
  00710	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00717	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00720	0f 85 2a 01 00
	00		 jne	 $LN63@z900_perfo
  00726	b8 08 00 00 00	 mov	 eax, 8
  0072b	48 6b c0 01	 imul	 rax, rax, 1
  0072f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00736	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0073f	0f 85 0b 01 00
	00		 jne	 $LN63@z900_perfo
  00745	e8 00 00 00 00	 call	 insttrace_all
  0074a	0f b6 c0	 movzx	 eax, al
  0074d	85 c0		 test	 eax, eax
  0074f	0f 84 fb 00 00
	00		 je	 $LN63@z900_perfo
$LN64@z900_perfo:
  00755	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0075c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00762	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00767	85 c0		 test	 eax, eax
  00769	0f 85 e1 00 00
	00		 jne	 $LN63@z900_perfo

; 295  :         )
; 296  :         {
; 297  :             if (regs->insttrace && sysblk.traceFILE)

  0076f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00777	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0077d	c1 e8 0f	 shr	 eax, 15
  00780	83 e0 01	 and	 eax, 1
  00783	85 c0		 test	 eax, eax
  00785	74 28		 je	 SHORT $LN66@z900_perfo
  00787	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078e	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00796	74 17		 je	 SHORT $LN66@z900_perfo

; 298  :                 tf_0840( regs, EXT_CLOCK_COMPARATOR_INTERRUPT );

  00798	66 ba 04 10	 mov	 dx, 4100		; 00001004H
  0079c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  007aa	e9 a1 00 00 00	 jmp	 $LN67@z900_perfo
$LN66@z900_perfo:

; 299  :             else
; 300  :                 // "Processor %s%02X: External interrupt: clock comparator"
; 301  :                 WRMSG( HHC00841, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  007af	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b7	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007be	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
  007c5	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cd	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  007d4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007db	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  007e9	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv341[rsp], rax
  007f1	b9 01 00 00 00	 mov	 ecx, 1
  007f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007fc	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv339[rsp]
  00803	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00807	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv341[rsp]
  0080f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00814	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193094
  0081b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00820	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193095
  00827	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0082c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00831	41 b9 03 00 00
	00		 mov	 r9d, 3
  00837	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193096
  0083e	ba 2d 01 00 00	 mov	 edx, 301		; 0000012dH
  00843	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193097
  0084a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN67@z900_perfo:
$LN63@z900_perfo:

; 302  :         }
; 303  :         ARCH_DEP( external_interrupt )( EXT_CLOCK_COMPARATOR_INTERRUPT, regs );

  00850	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00858	b9 04 10 00 00	 mov	 ecx, 4100		; 00001004H
  0085d	e8 00 00 00 00	 call	 z900_external_interrupt
$LN62@z900_perfo:

; 304  :     }
; 305  : 
; 306  :     /* External interrupt if CPU timer is negative */
; 307  :     if (1
; 308  :         && CPU_TIMER( regs ) < 0
; 309  :         && OPEN_IC_PTIMER( regs )

  00862	33 c0		 xor	 eax, eax
  00864	83 f8 01	 cmp	 eax, 1
  00867	0f 84 11 02 00
	00		 je	 $LN68@z900_perfo
  0086d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00875	e8 00 00 00 00	 call	 get_cpu_timer
  0087a	48 85 c0	 test	 rax, rax
  0087d	0f 8d fb 01 00
	00		 jge	 $LN68@z900_perfo
  00883	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0088b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00893	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00896	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00899	23 c1		 and	 eax, ecx
  0089b	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  008a0	85 c0		 test	 eax, eax
  008a2	0f 84 d6 01 00
	00		 je	 $LN68@z900_perfo

; 310  :     )
; 311  :     {
; 312  :         if (1
; 313  :             && CPU_STEPPING_OR_TRACING_ALL
; 314  :             && !TXF_INSTR_TRACING()

  008a8	33 c0		 xor	 eax, eax
  008aa	83 f8 01	 cmp	 eax, 1
  008ad	0f 84 b9 01 00
	00		 je	 $LN69@z900_perfo
  008b3	b8 08 00 00 00	 mov	 eax, 8
  008b8	48 6b c0 00	 imul	 rax, rax, 0
  008bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008c3	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008cc	75 32		 jne	 SHORT $LN71@z900_perfo
  008ce	b8 08 00 00 00	 mov	 eax, 8
  008d3	48 6b c0 01	 imul	 rax, rax, 1
  008d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008de	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008e7	75 17		 jne	 SHORT $LN71@z900_perfo
  008e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008f0	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  008f6	c1 e8 0a	 shr	 eax, 10
  008f9	83 e0 01	 and	 eax, 1
  008fc	85 c0		 test	 eax, eax
  008fe	75 4e		 jne	 SHORT $LN70@z900_perfo
$LN71@z900_perfo:
  00900	b8 08 00 00 00	 mov	 eax, 8
  00905	48 6b c0 00	 imul	 rax, rax, 0
  00909	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00910	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00919	0f 85 4d 01 00
	00		 jne	 $LN69@z900_perfo
  0091f	b8 08 00 00 00	 mov	 eax, 8
  00924	48 6b c0 01	 imul	 rax, rax, 1
  00928	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0092f	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00938	0f 85 2e 01 00
	00		 jne	 $LN69@z900_perfo
  0093e	e8 00 00 00 00	 call	 insttrace_all
  00943	0f b6 c0	 movzx	 eax, al
  00946	85 c0		 test	 eax, eax
  00948	0f 84 1e 01 00
	00		 je	 $LN69@z900_perfo
$LN70@z900_perfo:
  0094e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00955	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0095b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00960	85 c0		 test	 eax, eax
  00962	0f 85 04 01 00
	00		 jne	 $LN69@z900_perfo

; 315  :         )
; 316  :         {
; 317  :             if (regs->insttrace && sysblk.traceFILE)

  00968	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00970	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00976	c1 e8 0f	 shr	 eax, 15
  00979	83 e0 01	 and	 eax, 1
  0097c	85 c0		 test	 eax, eax
  0097e	74 28		 je	 SHORT $LN72@z900_perfo
  00980	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00987	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0098f	74 17		 je	 SHORT $LN72@z900_perfo

; 318  :                 tf_0840( regs, EXT_CPU_TIMER_INTERRUPT );

  00991	66 ba 05 10	 mov	 dx, 4101		; 00001005H
  00995	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  009a3	e9 c4 00 00 00	 jmp	 $LN73@z900_perfo
$LN72@z900_perfo:

; 319  :             else
; 320  :                 // "Processor %s%02X: External interrupt: CPU timer=%16.16"PRIX64
; 321  :                 WRMSG( HHC00842, "I", PTYPSTR( regs->cpuad ), regs->cpuad, CPU_TIMER( regs ));

  009a8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b0	e8 00 00 00 00	 call	 get_cpu_timer
  009b5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv402[rsp], rax
  009bd	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c5	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  009cc	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv408[rsp], ecx
  009d3	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009db	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  009e2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  009e9	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  009f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  009f8	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv410[rsp], rax
  00a00	b9 01 00 00 00	 mov	 ecx, 1
  00a05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a0b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv402[rsp]
  00a13	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a18	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv408[rsp]
  00a1f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a23	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv410[rsp]
  00a2b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193104
  00a37	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193105
  00a43	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a48	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a53	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193106
  00a5a	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00a5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193107
  00a66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN73@z900_perfo:
$LN69@z900_perfo:

; 322  :         }
; 323  :         ARCH_DEP( external_interrupt )( EXT_CPU_TIMER_INTERRUPT, regs );

  00a6c	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a74	b9 05 10 00 00	 mov	 ecx, 4101		; 00001005H
  00a79	e8 00 00 00 00	 call	 z900_external_interrupt
$LN68@z900_perfo:

; 324  :     }
; 325  : 
; 326  :     /* External interrupt if interval timer interrupt is pending */
; 327  : #if defined(FEATURE_INTERVAL_TIMER)
; 328  :     if (OPEN_IC_ITIMER(regs)
; 329  : #if defined(_FEATURE_SIE)
; 330  :         && !(SIE_STATE_BIT_ON(regs, M, ITMOF))
; 331  : #endif
; 332  :         )
; 333  :     {
; 334  :         if (1
; 335  :             && CPU_STEPPING_OR_TRACING_ALL
; 336  :             && !TXF_INSTR_TRACING()
; 337  :         )
; 338  :         {
; 339  :             if (regs->insttrace && sysblk.traceFILE)
; 340  :                 tf_0840( regs, EXT_INTERVAL_TIMER_INTERRUPT );
; 341  :             else
; 342  :                 // "Processor %s%02X: External interrupt: interval timer"
; 343  :                 WRMSG( HHC00843, "I", PTYPSTR( regs->cpuad ), regs->cpuad );
; 344  :         }
; 345  :         OFF_IC_ITIMER(regs);
; 346  :         ARCH_DEP(external_interrupt) (EXT_INTERVAL_TIMER_INTERRUPT, regs);
; 347  :     }
; 348  : 
; 349  : #if defined(FEATURE_ECPSVM)
; 350  :     if ( OPEN_IC_ECPSVTIMER(regs) )
; 351  :     {
; 352  :         OFF_IC_ECPSVTIMER(regs);
; 353  :         ARCH_DEP(external_interrupt) (EXT_VINTERVAL_TIMER_INTERRUPT,regs);
; 354  :     }
; 355  : #endif /*FEATURE_ECPSVM*/
; 356  : #endif /*FEATURE_INTERVAL_TIMER*/
; 357  : 
; 358  :     /* External interrupt if service signal is pending */
; 359  :     if ( OPEN_IC_SERVSIG(regs) && !SIE_MODE(regs) )

  00a7e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a86	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8e	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00a91	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00a94	23 c1		 and	 eax, ecx
  00a96	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a9b	85 c0		 test	 eax, eax
  00a9d	0f 84 da 0a 00
	00		 je	 $LN74@z900_perfo
  00aa3	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00ab1	d1 e8		 shr	 eax, 1
  00ab3	83 e0 01	 and	 eax, 1
  00ab6	85 c0		 test	 eax, eax
  00ab8	0f 85 bf 0a 00
	00		 jne	 $LN74@z900_perfo

; 360  :     {
; 361  : 
; 362  : #if defined(FEATURE_VM_BLOCKIO)
; 363  : 
; 364  :         /* Note: Both Block I/O and Service Signal are enabled by the */
; 365  :         /* the same CR0 bit.  Hence they are handled in the same code */
; 366  :         switch(sysblk.servcode)

  00abe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ac5	0f b7 80 68 12
	00 00		 movzx	 eax, WORD PTR [rax+4712]
  00acc	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv440[rsp], eax
  00ad3	81 bc 24 98 00
	00 00 01 24 00
	00		 cmp	 DWORD PTR tv440[rsp], 9217 ; 00002401H
  00ade	0f 84 e0 06 00
	00		 je	 $LN91@z900_perfo
  00ae4	81 bc 24 98 00
	00 00 03 26 00
	00		 cmp	 DWORD PTR tv440[rsp], 9731 ; 00002603H
  00aef	74 05		 je	 SHORT $LN75@z900_perfo
  00af1	e9 ce 06 00 00	 jmp	 $LN92@z900_perfo
$LN75@z900_perfo:

; 367  :         {
; 368  :         case EXT_BLOCKIO_INTERRUPT:  /* VM Block I/O Interrupt */
; 369  : 
; 370  :             if (sysblk.biodev->ccwtrace)

  00af6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00afd	48 8b 80 78 12
	00 00		 mov	 rax, QWORD PTR [rax+4728]
  00b04	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b0a	c1 e8 0f	 shr	 eax, 15
  00b0d	83 e0 01	 and	 eax, 1
  00b10	85 c0		 test	 eax, eax
  00b12	0f 84 a3 01 00
	00		 je	 $LN76@z900_perfo

; 371  :             {
; 372  :                 if (regs->insttrace && sysblk.traceFILE)

  00b18	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b20	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b26	c1 e8 0f	 shr	 eax, 15
  00b29	83 e0 01	 and	 eax, 1
  00b2c	85 c0		 test	 eax, eax
  00b2e	74 24		 je	 SHORT $LN77@z900_perfo
  00b30	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b37	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b3f	74 13		 je	 SHORT $LN77@z900_perfo

; 373  :                     tf_0844( regs );

  00b41	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0844
  00b4f	e9 67 01 00 00	 jmp	 $LN78@z900_perfo
$LN77@z900_perfo:

; 374  :                 else
; 375  :                     // "Processor %s%02X: %1d:%04X: processing block I/O interrupt:
; 376  :                     //     code %4.4X parm %16.16"PRIX64" status %2.2X subcode %2.2X"
; 377  :                     WRMSG( HHC00844, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  00b54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b5b	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00b62	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv454[rsp], eax
  00b69	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b70	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  00b77	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv457[rsp], ecx
  00b7e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b85	0f b7 92 68 12
	00 00		 movzx	 edx, WORD PTR [rdx+4712]
  00b8c	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv462[rsp], edx
  00b93	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00b9a	4d 8b 80 78 12
	00 00		 mov	 r8, QWORD PTR [r8+4728]
  00ba1	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  00ba6	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv466[rsp], r8d
  00bae	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  00bb5	4d 8b 89 78 12
	00 00		 mov	 r9, QWORD PTR [r9+4728]
  00bbc	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  00bc1	41 d1 f9	 sar	 r9d, 1
  00bc4	44 89 8c 24 cc
	00 00 00	 mov	 DWORD PTR tv471[rsp], r9d
  00bcc	4c 8b 94 24 a0
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  00bd4	45 0f b7 92 3c
	08 00 00	 movzx	 r10d, WORD PTR [r10+2108]
  00bdc	44 89 94 24 d0
	00 00 00	 mov	 DWORD PTR tv474[rsp], r10d
  00be4	4c 8b 9c 24 a0
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00bec	45 0f b7 9b 3c
	08 00 00	 movzx	 r11d, WORD PTR [r11+2108]
  00bf4	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR __imp_sysblk
  00bfb	42 0f b6 8c 1b
	48 0b 00 00	 movzx	 ecx, BYTE PTR [rbx+r11+2888]
  00c04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00c0a	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv476[rsp], rax
  00c12	b9 01 00 00 00	 mov	 ecx, 1
  00c17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c1d	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv454[rsp]
  00c24	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00c28	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv457[rsp]
  00c2f	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00c33	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c3a	48 8b 89 70 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4720]
  00c41	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00c46	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv462[rsp]
  00c4d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00c51	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv466[rsp]
  00c58	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00c5c	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv471[rsp]
  00c63	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00c67	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv474[rsp]
  00c6e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c72	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv476[rsp]
  00c7a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c7f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193113
  00c86	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193114
  00c92	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c97	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c9c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ca2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193115
  00ca9	ba 80 01 00 00	 mov	 edx, 384		; 00000180H
  00cae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193116
  00cb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN78@z900_perfo:
$LN76@z900_perfo:

; 378  :                         SSID_TO_LCSS(sysblk.biodev->ssid),
; 379  :                         sysblk.biodev->devnum,
; 380  :                         sysblk.servcode,
; 381  :                         sysblk.bioparm,
; 382  :                         sysblk.biostat,
; 383  :                         sysblk.biosubcd
; 384  :                     );
; 385  :             }
; 386  : 
; 387  :             servcode = EXT_BLOCKIO_INTERRUPT;

  00cbb	b8 03 26 00 00	 mov	 eax, 9731		; 00002603H
  00cc0	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 388  : 
; 389  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 390  : /* Real address used to store the 64-bit interrupt parameter */
; 391  : #define VM_BLOCKIO_INT_PARM   0x11B8
; 392  :             if (sysblk.biosubcd == 0x07)

  00cc8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ccf	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00cd6	83 f8 07	 cmp	 eax, 7
  00cd9	0f 85 55 02 00
	00		 jne	 $LN79@z900_perfo

; 393  :             {
; 394  :                 /* 8-byte interrupt parm */
; 395  :                 if (1
; 396  :                     && CPU_STEPPING_OR_TRACING_ALL
; 397  :                     && !TXF_INSTR_TRACING()

  00cdf	33 c0		 xor	 eax, eax
  00ce1	83 f8 01	 cmp	 eax, 1
  00ce4	0f 84 c7 01 00
	00		 je	 $LN81@z900_perfo
  00cea	b8 08 00 00 00	 mov	 eax, 8
  00cef	48 6b c0 00	 imul	 rax, rax, 0
  00cf3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00cfa	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00d03	75 32		 jne	 SHORT $LN83@z900_perfo
  00d05	b8 08 00 00 00	 mov	 eax, 8
  00d0a	48 6b c0 01	 imul	 rax, rax, 1
  00d0e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d15	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00d1e	75 17		 jne	 SHORT $LN83@z900_perfo
  00d20	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d27	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00d2d	c1 e8 0a	 shr	 eax, 10
  00d30	83 e0 01	 and	 eax, 1
  00d33	85 c0		 test	 eax, eax
  00d35	75 4e		 jne	 SHORT $LN82@z900_perfo
$LN83@z900_perfo:
  00d37	b8 08 00 00 00	 mov	 eax, 8
  00d3c	48 6b c0 00	 imul	 rax, rax, 0
  00d40	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d47	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00d50	0f 85 5b 01 00
	00		 jne	 $LN81@z900_perfo
  00d56	b8 08 00 00 00	 mov	 eax, 8
  00d5b	48 6b c0 01	 imul	 rax, rax, 1
  00d5f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d66	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00d6f	0f 85 3c 01 00
	00		 jne	 $LN81@z900_perfo
  00d75	e8 00 00 00 00	 call	 insttrace_all
  00d7a	0f b6 c0	 movzx	 eax, al
  00d7d	85 c0		 test	 eax, eax
  00d7f	0f 84 2c 01 00
	00		 je	 $LN81@z900_perfo
$LN82@z900_perfo:
  00d85	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d8c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00d92	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00d97	85 c0		 test	 eax, eax
  00d99	0f 85 12 01 00
	00		 jne	 $LN81@z900_perfo

; 398  :                 )
; 399  :                 {
; 400  :                     if (regs->insttrace && sysblk.traceFILE)

  00d9f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00da7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00dad	c1 e8 0f	 shr	 eax, 15
  00db0	83 e0 01	 and	 eax, 1
  00db3	85 c0		 test	 eax, eax
  00db5	74 24		 je	 SHORT $LN84@z900_perfo
  00db7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dbe	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00dc6	74 13		 je	 SHORT $LN84@z900_perfo

; 401  :                         tf_0845( regs );

  00dc8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dd0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0845
  00dd6	e9 d6 00 00 00	 jmp	 $LN85@z900_perfo
$LN84@z900_perfo:

; 402  :                     else
; 403  :                     {
; 404  :                         char buf[40];
; 405  :                         MSGBUF( buf, "%16.16X", (unsigned) sysblk.bioparm );

  00ddb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00de2	44 8b 88 70 12
	00 00		 mov	 r9d, DWORD PTR [rax+4720]
  00de9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193124
  00df0	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00df5	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00dfd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 406  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 407  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  00e03	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e0b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00e12	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv537[rsp], eax
  00e19	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e21	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00e28	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e2f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00e37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e3d	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv539[rsp], rax
  00e45	b9 01 00 00 00	 mov	 ecx, 1
  00e4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e50	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00e58	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e5d	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv537[rsp]
  00e64	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e68	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv539[rsp]
  00e70	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193125
  00e7c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193126
  00e88	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e8d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e92	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e98	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193127
  00e9f	ba 97 01 00 00	 mov	 edx, 407		; 00000197H
  00ea4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193128
  00eab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN85@z900_perfo:
$LN81@z900_perfo:

; 408  :                     }
; 409  :                 }
; 410  : 
; 411  :                 /* Set the main storage reference and change bits   */
; 412  :                 /* for 64-bit interruption parameter.               */
; 413  :                 /* Note: This is handled for the first 4K page in   */
; 414  :                 /* ARCH_DEP(external_interrupt), but not for the    */
; 415  :                 /* the second 4K page used for the 64-bit interrupt */
; 416  :                 /* parameter.                                       */
; 417  : 
; 418  :                 /* Point to 2nd page of PSA in main storage */
; 419  :                 servpadr=APPLY_PREFIXING(VM_BLOCKIO_INT_PARM,regs->PX);

  00eb1	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00eb9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00ebd	48 35 b8 11 00
	00		 xor	 rax, 4536		; 000011b8H
  00ec3	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR servpadr$[rsp], rax

; 420  : 
; 421  :                 ARCH_DEP( or_storage_key )( servpadr, (STORKEY_REF | STORKEY_CHANGE) );

  00ecb	b2 06		 mov	 dl, 6
  00ecd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR servpadr$[rsp]
  00ed5	e8 00 00 00 00	 call	 z900_or_storage_key

; 422  : #if 0
; 423  :                 /* Store the 64-bit interrupt parameter */
; 424  :                 LOGMSG( "Saving 64-bit Block I/O interrupt parm at "
; 425  :                     "%16.16X: %16.16X\n",
; 426  :                     servpadr,
; 427  :                     sysblk.bioparm
; 428  :                 );
; 429  : #endif
; 430  :                 STORE_DW(regs->mainstor + servpadr,sysblk.bioparm);

  00eda	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ee1	48 8b 88 70 12
	00 00		 mov	 rcx, QWORD PTR [rax+4720]
  00ee8	e8 00 00 00 00	 call	 _byteswap_uint64
  00eed	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ef5	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00efc	48 03 8c 24 e0
	00 00 00	 add	 rcx, QWORD PTR servpadr$[rsp]
  00f04	48 8b d0	 mov	 rdx, rax
  00f07	e8 00 00 00 00	 call	 store_dw_noswap

; 431  :                 psa = (void*)(regs->mainstor + regs->PX);

  00f0c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f14	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00f1b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f23	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00f27	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 432  :             }

  00f2f	e9 1d 02 00 00	 jmp	 $LN80@z900_perfo
$LN79@z900_perfo:

; 433  :             else
; 434  : #endif  /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 435  :             {
; 436  :                 /* 4-byte interrupt parm */
; 437  :                 if (1
; 438  :                     && CPU_STEPPING_OR_TRACING_ALL
; 439  :                     && !TXF_INSTR_TRACING()

  00f34	33 c0		 xor	 eax, eax
  00f36	83 f8 01	 cmp	 eax, 1
  00f39	0f 84 c7 01 00
	00		 je	 $LN86@z900_perfo
  00f3f	b8 08 00 00 00	 mov	 eax, 8
  00f44	48 6b c0 00	 imul	 rax, rax, 0
  00f48	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f4f	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00f58	75 32		 jne	 SHORT $LN88@z900_perfo
  00f5a	b8 08 00 00 00	 mov	 eax, 8
  00f5f	48 6b c0 01	 imul	 rax, rax, 1
  00f63	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f6a	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00f73	75 17		 jne	 SHORT $LN88@z900_perfo
  00f75	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f7c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00f82	c1 e8 0a	 shr	 eax, 10
  00f85	83 e0 01	 and	 eax, 1
  00f88	85 c0		 test	 eax, eax
  00f8a	75 4e		 jne	 SHORT $LN87@z900_perfo
$LN88@z900_perfo:
  00f8c	b8 08 00 00 00	 mov	 eax, 8
  00f91	48 6b c0 00	 imul	 rax, rax, 0
  00f95	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f9c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00fa5	0f 85 5b 01 00
	00		 jne	 $LN86@z900_perfo
  00fab	b8 08 00 00 00	 mov	 eax, 8
  00fb0	48 6b c0 01	 imul	 rax, rax, 1
  00fb4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fbb	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00fc4	0f 85 3c 01 00
	00		 jne	 $LN86@z900_perfo
  00fca	e8 00 00 00 00	 call	 insttrace_all
  00fcf	0f b6 c0	 movzx	 eax, al
  00fd2	85 c0		 test	 eax, eax
  00fd4	0f 84 2c 01 00
	00		 je	 $LN86@z900_perfo
$LN87@z900_perfo:
  00fda	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fe1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00fe7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00fec	85 c0		 test	 eax, eax
  00fee	0f 85 12 01 00
	00		 jne	 $LN86@z900_perfo

; 440  :                 )
; 441  :                 {
; 442  :                     if (regs->insttrace && sysblk.traceFILE)

  00ff4	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ffc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01002	c1 e8 0f	 shr	 eax, 15
  01005	83 e0 01	 and	 eax, 1
  01008	85 c0		 test	 eax, eax
  0100a	74 24		 je	 SHORT $LN89@z900_perfo
  0100c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01013	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0101b	74 13		 je	 SHORT $LN89@z900_perfo

; 443  :                         tf_0845( regs );

  0101d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0845
  0102b	e9 d6 00 00 00	 jmp	 $LN90@z900_perfo
$LN89@z900_perfo:

; 444  :                     else
; 445  :                     {
; 446  :                         char buf[40];
; 447  :                         MSGBUF( buf, "%8.8X", (U32) sysblk.bioparm );

  01030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01037	44 8b 88 70 12
	00 00		 mov	 r9d, DWORD PTR [rax+4720]
  0103e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193134
  01045	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0104a	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR buf$6[rsp]
  01052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 448  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 449  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  01058	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01060	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01067	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv611[rsp], eax
  0106e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01076	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0107d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01084	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0108c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01092	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv613[rsp], rax
  0109a	b9 01 00 00 00	 mov	 ecx, 1
  0109f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010a5	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR buf$6[rsp]
  010ad	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010b2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv611[rsp]
  010b9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010bd	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv613[rsp]
  010c5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193135
  010d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193136
  010dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  010ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193137
  010f4	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  010f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193138
  01100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN90@z900_perfo:
$LN86@z900_perfo:

; 450  :                     }
; 451  :                 }
; 452  : 
; 453  :                 /* Store Block I/O parameter at PSA+X'80' */
; 454  :                 psa = (void*)(regs->mainstor + regs->PX);

  01106	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0110e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01115	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0111d	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  01121	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 455  :                 STORE_FW(psa->extparm,(U32)sysblk.bioparm);

  01129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01130	8b 88 70 12 00
	00		 mov	 ecx, DWORD PTR [rax+4720]
  01136	e8 00 00 00 00	 call	 _byteswap_ulong
  0113b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01143	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  0114a	8b d0		 mov	 edx, eax
  0114c	e8 00 00 00 00	 call	 store_fw_noswap
$LN80@z900_perfo:

; 456  :             }
; 457  : 
; 458  :             /* Store sub-interruption code and status at PSA+X'84' */
; 459  :             STORE_HW(psa->extcpad,(sysblk.biosubcd<<8)|sysblk.biostat);

  01151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01158	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  0115f	c1 e0 08	 shl	 eax, 8
  01162	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01169	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  01170	0b c1		 or	 eax, ecx
  01172	0f b7 c8	 movzx	 ecx, ax
  01175	e8 00 00 00 00	 call	 _byteswap_ushort
  0117a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01182	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  01189	0f b7 d0	 movzx	 edx, ax
  0118c	e8 00 00 00 00	 call	 store_hw_noswap

; 460  : 
; 461  :             /* Reset interruption data */
; 462  :             sysblk.bioparm  = 0;

  01191	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01198	48 c7 80 70 12
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4720], 0

; 463  :             sysblk.biosubcd = 0;

  011a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011aa	c6 80 6a 12 00
	00 00		 mov	 BYTE PTR [rax+4714], 0

; 464  :             sysblk.biostat  = 0;

  011b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011b8	c6 80 6b 12 00
	00 00		 mov	 BYTE PTR [rax+4715], 0

; 465  : 
; 466  :             break;

  011bf	e9 a3 02 00 00	 jmp	 $LN39@z900_perfo
$LN91@z900_perfo:
$LN92@z900_perfo:

; 467  : 
; 468  :         case EXT_SERVICE_SIGNAL_INTERRUPT: /* Service Signal */
; 469  :         default:
; 470  :             servcode = EXT_SERVICE_SIGNAL_INTERRUPT;

  011c4	b8 01 24 00 00	 mov	 eax, 9217		; 00002401H
  011c9	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 471  : 
; 472  :             /* Apply prefixing if the parameter is a storage address */
; 473  :             if ( (sysblk.servparm & SERVSIG_ADDR) )

  011d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011d8	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  011de	83 e0 f8	 and	 eax, -8			; fffffff8H
  011e1	85 c0		 test	 eax, eax
  011e3	0f 84 85 00 00
	00		 je	 $LN93@z900_perfo

; 474  :                 sysblk.servparm =

  011e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011f0	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  011f6	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  011fc	48 85 c0	 test	 rax, rax
  011ff	74 38		 je	 SHORT $LN102@z900_perfo
  01201	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01208	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  0120e	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  01214	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0121c	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  01220	74 17		 je	 SHORT $LN102@z900_perfo
  01222	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01229	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  0122f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv673[rsp], rax
  01237	eb 21		 jmp	 SHORT $LN103@z900_perfo
$LN102@z900_perfo:
  01239	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01240	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01246	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0124e	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  01252	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv673[rsp], rax
$LN103@z900_perfo:
  0125a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01261	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv673[rsp]
  01268	89 88 90 12 00
	00		 mov	 DWORD PTR [rax+4752], ecx
$LN93@z900_perfo:

; 475  :                      APPLY_PREFIXING (sysblk.servparm, regs->PX);
; 476  : 
; 477  :             if (1
; 478  :                 && CPU_STEPPING_OR_TRACING_ALL
; 479  :                 && !TXF_INSTR_TRACING()

  0126e	33 c0		 xor	 eax, eax
  01270	83 f8 01	 cmp	 eax, 1
  01273	0f 84 a3 01 00
	00		 je	 $LN94@z900_perfo
  01279	b8 08 00 00 00	 mov	 eax, 8
  0127e	48 6b c0 00	 imul	 rax, rax, 0
  01282	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01289	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  01292	75 32		 jne	 SHORT $LN96@z900_perfo
  01294	b8 08 00 00 00	 mov	 eax, 8
  01299	48 6b c0 01	 imul	 rax, rax, 1
  0129d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012a4	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  012ad	75 17		 jne	 SHORT $LN96@z900_perfo
  012af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012b6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  012bc	c1 e8 0a	 shr	 eax, 10
  012bf	83 e0 01	 and	 eax, 1
  012c2	85 c0		 test	 eax, eax
  012c4	75 4e		 jne	 SHORT $LN95@z900_perfo
$LN96@z900_perfo:
  012c6	b8 08 00 00 00	 mov	 eax, 8
  012cb	48 6b c0 00	 imul	 rax, rax, 0
  012cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012d6	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  012df	0f 85 37 01 00
	00		 jne	 $LN94@z900_perfo
  012e5	b8 08 00 00 00	 mov	 eax, 8
  012ea	48 6b c0 01	 imul	 rax, rax, 1
  012ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012f5	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  012fe	0f 85 18 01 00
	00		 jne	 $LN94@z900_perfo
  01304	e8 00 00 00 00	 call	 insttrace_all
  01309	0f b6 c0	 movzx	 eax, al
  0130c	85 c0		 test	 eax, eax
  0130e	0f 84 08 01 00
	00		 je	 $LN94@z900_perfo
$LN95@z900_perfo:
  01314	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0131b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01321	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01326	85 c0		 test	 eax, eax
  01328	0f 85 ee 00 00
	00		 jne	 $LN94@z900_perfo

; 480  :             )
; 481  :             {
; 482  :                 if (regs->insttrace && sysblk.traceFILE)

  0132e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01336	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0133c	c1 e8 0f	 shr	 eax, 15
  0133f	83 e0 01	 and	 eax, 1
  01342	85 c0		 test	 eax, eax
  01344	74 24		 je	 SHORT $LN97@z900_perfo
  01346	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0134d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01355	74 13		 je	 SHORT $LN97@z900_perfo

; 483  :                     tf_0846( regs );

  01357	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0135f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0846
  01365	e9 b2 00 00 00	 jmp	 $LN98@z900_perfo
$LN97@z900_perfo:

; 484  :                 else
; 485  :                     // "Processor %s%02X: External interrupt: service signal %8.8X"
; 486  :                     WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );

  0136a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01372	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01379	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv712[rsp], eax
  01380	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01388	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0138f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01396	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0139e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  013a4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv714[rsp], rax
  013ac	b9 01 00 00 00	 mov	 ecx, 1
  013b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013be	8b 89 90 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4752]
  013c4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  013c8	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv712[rsp]
  013cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013d3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv714[rsp]
  013db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  013e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193147
  013e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193148
  013f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  01403	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193149
  0140a	ba e6 01 00 00	 mov	 edx, 486		; 000001e6H
  0140f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193150
  01416	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN98@z900_perfo:
$LN94@z900_perfo:

; 487  :             }
; 488  : 
; 489  :             /* Store service signal parameter at PSA+X'80' */
; 490  :             psa = (void*)(regs->mainstor + regs->PX);

  0141c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01424	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0142b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01433	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  01437	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 491  :             STORE_FW(psa->extparm,sysblk.servparm);

  0143f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01446	8b 88 90 12 00
	00		 mov	 ecx, DWORD PTR [rax+4752]
  0144c	e8 00 00 00 00	 call	 _byteswap_ulong
  01451	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01459	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  01460	8b d0		 mov	 edx, eax
  01462	e8 00 00 00 00	 call	 store_fw_noswap
$LN39@z900_perfo:

; 492  : 
; 493  :         }  /* end switch(sysblk.servcode) */
; 494  :         /* Reset service parameter */
; 495  :         sysblk.servparm = 0;

  01467	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0146e	c7 80 90 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4752], 0

; 496  : 
; 497  :         /* Reset service code */
; 498  :         sysblk.servcode = 0;

  01478	33 c0		 xor	 eax, eax
  0147a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01481	66 89 81 68 12
	00 00		 mov	 WORD PTR [rcx+4712], ax
$LN43@z900_perfo:

; 499  : 
; 500  :         /* Reset service signal pending */
; 501  :         OFF_IC_SERVSIG;

  01488	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0148f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01495	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0149a	85 c0		 test	 eax, eax
  0149c	0f 84 ba 00 00
	00		 je	 $LN99@z900_perfo
  014a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014a9	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  014af	0f ba f0 09	 btr	 eax, 9
  014b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  014ba	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  014c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014c7	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  014ce	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  014d6	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$2[rsp], 0
  014e1	eb 10		 jmp	 SHORT $LN46@z900_perfo
$LN44@z900_perfo:
  014e3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  014ea	ff c0		 inc	 eax
  014ec	89 84 24 94 00
	00 00		 mov	 DWORD PTR i$2[rsp], eax
$LN46@z900_perfo:
  014f3	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR mask$4[rsp], 0
  014fc	74 5e		 je	 SHORT $LN45@z900_perfo
  014fe	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  01506	48 83 e0 01	 and	 rax, 1
  0150a	48 85 c0	 test	 rax, rax
  0150d	74 38		 je	 SHORT $LN100@z900_perfo
  0150f	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR i$2[rsp]
  01517	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0151e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01526	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01529	0f ba f0 09	 btr	 eax, 9
  0152d	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR i$2[rsp]
  01535	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0153c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  01544	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN100@z900_perfo:
  01547	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  0154f	48 d1 e8	 shr	 rax, 1
  01552	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  0155a	eb 87		 jmp	 SHORT $LN44@z900_perfo
$LN45@z900_perfo:
$LN99@z900_perfo:
  0155c	33 c0		 xor	 eax, eax
  0155e	85 c0		 test	 eax, eax
  01560	0f 85 22 ff ff
	ff		 jne	 $LN43@z900_perfo

; 502  : 
; 503  :         /* Generate service signal interrupt */
; 504  :         ARCH_DEP(external_interrupt) (servcode, regs);

  01566	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR servcode$[rsp]
  0156e	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01576	8b c8		 mov	 ecx, eax
  01578	e8 00 00 00 00	 call	 z900_external_interrupt
$LN74@z900_perfo:
$LN1@z900_perfo:

; 505  : 
; 506  : #else /* defined(FEATURE_VM_BLOCKIO) */
; 507  : 
; 508  :         /* Apply prefixing if the parameter is a storage address */
; 509  :         if (sysblk.servparm & SERVSIG_ADDR)
; 510  :             sysblk.servparm = APPLY_PREFIXING( sysblk.servparm, regs->PX );
; 511  : 
; 512  :         if (1
; 513  :             && CPU_STEPPING_OR_TRACING_ALL
; 514  :             && !TXF_INSTR_TRACING()
; 515  :         )
; 516  :         {
; 517  :             if (regs->insttrace && sysblk.traceFILE)
; 518  :                 tf_0846( regs );
; 519  :             else
; 520  :                 // "Processor %s%02X: External interrupt: service signal %8.8X"
; 521  :                 WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );
; 522  :         }
; 523  : 
; 524  :         /* Store service signal parameter at PSA+X'80' */
; 525  :         psa = (void*)(regs->mainstor + regs->PX);
; 526  :         STORE_FW(psa->extparm,sysblk.servparm);
; 527  : 
; 528  :         /* Reset service parameter */
; 529  :         sysblk.servparm = 0;
; 530  : 
; 531  :         /* Reset service signal pending */
; 532  :         OFF_IC_SERVSIG;
; 533  : 
; 534  :         /* Generate service signal interrupt */
; 535  :         ARCH_DEP(external_interrupt) (EXT_SERVICE_SIGNAL_INTERRUPT, regs);
; 536  : 
; 537  : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 538  : 
; 539  :     }  /* end OPEN_IC_SERVSIG(regs) */
; 540  : 
; 541  : } /* end function perform_external_interrupt */

  0157d	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01585	48 33 cc	 xor	 rcx, rsp
  01588	e8 00 00 00 00	 call	 __security_check_cookie
  0158d	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  01594	5b		 pop	 rbx
  01595	c3		 ret	 0
z900_perform_external_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
rc$ = 64
pfx$ = 72
psa$ = 80
tv169 = 88
code$ = 112
regs$ = 120
s390_external_interrupt PROC

; 43   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@s390_exter:

; 44   : RADR    pfx;
; 45   : PSA     *psa;
; 46   : int     rc;
; 47   : 
; 48   :     PTT_SIG("*EXTINT",code,regs->cpuad,regs->psw.IA_L);

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 4e		 je	 SHORT $LN8@s390_exter
  00022	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00039	48 63 54 24 70	 movsxd	 rdx, DWORD PTR code$[rsp]
  0003e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00047	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179825
  00053	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00058	44 8b c9	 mov	 r9d, ecx
  0005b	4c 8b c2	 mov	 r8, rdx
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179826
  00065	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN8@s390_exter:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 97		 jne	 SHORT $LN4@s390_exter

; 49   : 
; 50   : #if defined(_FEATURE_SIE)
; 51   :     /* Set the main storage reference and change bits */
; 52   :     if(SIE_MODE(regs)
; 53   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 54   :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 55   : #endif
; 56   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 57   :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00081	d1 e8		 shr	 eax, 1
  00083	83 e0 01	 and	 eax, 1
  00086	85 c0		 test	 eax, eax
  00088	74 7b		 je	 SHORT $LN9@s390_exter
  0008a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00096	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009a	83 e0 02	 and	 eax, 2
  0009d	85 c0		 test	 eax, eax
  0009f	75 64		 jne	 SHORT $LN9@s390_exter
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 00	 imul	 rcx, rcx, 0
  000b6	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  000bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c0	85 c0		 test	 eax, eax
  000c2	75 41		 jne	 SHORT $LN9@s390_exter

; 58   : #endif
; 59   :                                                             )
; 60   :     {
; 61   :         /* Point to SIE copy of PSA in state descriptor */
; 62   :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  000c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  000e3	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  000e8	48 89 44 24 50	 mov	 QWORD PTR psa$[rsp], rax

; 63   :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  000ed	b2 06		 mov	 dl, 6
  000ef	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  000fb	e8 00 00 00 00	 call	 s390_or_storage_key

; 64   :     }

  00100	e9 15 01 00 00	 jmp	 $LN10@s390_exter
$LN9@s390_exter:

; 65   :     else
; 66   : #endif /*defined(_FEATURE_SIE)*/
; 67   :     {
; 68   :         /* Point to PSA in main storage */
; 69   :         pfx = regs->PX;

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0010d	48 89 44 24 48	 mov	 QWORD PTR pfx$[rsp], rax
$LN7@s390_exter:

; 70   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 71   :         SIE_TRANSLATE(&pfx, ACCTYPE_SIE, regs);

  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011d	d1 e8		 shr	 eax, 1
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	0f 84 c4 00 00
	00		 je	 $LN11@s390_exter
  0012a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00135	c1 e8 02	 shr	 eax, 2
  00138	83 e0 01	 and	 eax, 1
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 ab 00 00
	00		 jne	 $LN11@s390_exter
  00143	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00148	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014f	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00153	75 41		 jne	 SHORT $LN19@s390_exter
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00161	48 03 44 24 48	 add	 rax, QWORD PTR pfx$[rsp]
  00166	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0016f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00174	45 33 c9	 xor	 r9d, r9d
  00177	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00183	ba fd ff ff ff	 mov	 edx, -3
  00188	8b c8		 mov	 ecx, eax
  0018a	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0018f	48 89 44 24 58	 mov	 QWORD PTR tv169[rsp], rax
  00194	eb 40		 jmp	 SHORT $LN20@s390_exter
$LN19@s390_exter:
  00196	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  001a2	48 03 44 24 48	 add	 rax, QWORD PTR pfx$[rsp]
  001a7	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  001b0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001b5	45 33 c9	 xor	 r9d, r9d
  001b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  001c4	ba fd ff ff ff	 mov	 edx, -3
  001c9	48 8b c8	 mov	 rcx, rax
  001cc	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d1	48 89 44 24 58	 mov	 QWORD PTR tv169[rsp], rax
$LN20@s390_exter:
  001d6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001db	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001e2	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  001e9	48 89 44 24 48	 mov	 QWORD PTR pfx$[rsp], rax
$LN11@s390_exter:
  001ee	33 c0		 xor	 eax, eax
  001f0	85 c0		 test	 eax, eax
  001f2	0f 85 1a ff ff
	ff		 jne	 $LN7@s390_exter

; 72   : #endif /*defined(_FEATURE_EXPEDITED_SIE_SUBSET)*/
; 73   :         psa = (void*)(regs->mainstor + pfx);

  001f8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00204	48 03 44 24 48	 add	 rax, QWORD PTR pfx$[rsp]
  00209	48 89 44 24 50	 mov	 QWORD PTR psa$[rsp], rax

; 74   :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  0020e	b2 06		 mov	 dl, 6
  00210	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pfx$[rsp]
  00215	e8 00 00 00 00	 call	 s390_or_storage_key
$LN10@s390_exter:

; 75   :     }
; 76   : 
; 77   :     /* Store the interrupt code in the PSW */
; 78   :     regs->psw.intcode = code;

  0021a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0021f	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  00224	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 79   : 
; 80   : 
; 81   :     /* Zero extcpuad field unless extcall or ems signal or blockio */
; 82   :     if(code != EXT_EXTERNAL_CALL_INTERRUPT
; 83   : #if defined(FEATURE_VM_BLOCKIO)
; 84   :     && code != EXT_BLOCKIO_INTERRUPT
; 85   : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 86   :     && code != EXT_EMERGENCY_SIGNAL_INTERRUPT)

  0022b	81 7c 24 70 02
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4610 ; 00001202H
  00233	74 2f		 je	 SHORT $LN12@s390_exter
  00235	81 7c 24 70 03
	26 00 00	 cmp	 DWORD PTR code$[rsp], 9731 ; 00002603H
  0023d	74 25		 je	 SHORT $LN12@s390_exter
  0023f	81 7c 24 70 01
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4609 ; 00001201H
  00247	74 1b		 je	 SHORT $LN12@s390_exter

; 87   :         STORE_HW(psa->extcpad,0);

  00249	33 c9		 xor	 ecx, ecx
  0024b	e8 00 00 00 00	 call	 _byteswap_ushort
  00250	48 8b 4c 24 50	 mov	 rcx, QWORD PTR psa$[rsp]
  00255	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  0025c	0f b7 d0	 movzx	 edx, ax
  0025f	e8 00 00 00 00	 call	 store_hw_noswap
$LN12@s390_exter:

; 88   : 
; 89   : #if defined(FEATURE_BCMODE)
; 90   :     /* For ECMODE, store external interrupt code at PSA+X'86' */
; 91   :     if ( ECMODE(&regs->psw) )
; 92   : #endif /*defined(FEATURE_BCMODE)*/
; 93   :         STORE_HW(psa->extint,code);

  00264	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  00269	e8 00 00 00 00	 call	 _byteswap_ushort
  0026e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR psa$[rsp]
  00273	48 81 c1 86 00
	00 00		 add	 rcx, 134		; 00000086H
  0027a	0f b7 d0	 movzx	 edx, ax
  0027d	e8 00 00 00 00	 call	 store_hw_noswap

; 94   : 
; 95   :     if ( !SIE_MODE(regs)
; 96   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 97   :                        || SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 98   : #endif
; 99   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 100  :                        || SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00282	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00287	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0028d	d1 e8		 shr	 eax, 1
  0028f	83 e0 01	 and	 eax, 1
  00292	85 c0		 test	 eax, eax
  00294	74 3a		 je	 SHORT $LN14@s390_exter
  00296	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0029b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  002a2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002a6	83 e0 02	 and	 eax, 2
  002a9	85 c0		 test	 eax, eax
  002ab	75 23		 jne	 SHORT $LN14@s390_exter
  002ad	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  002b9	b9 01 00 00 00	 mov	 ecx, 1
  002be	48 6b c9 00	 imul	 rcx, rcx, 0
  002c2	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  002c7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002cc	85 c0		 test	 eax, eax
  002ce	74 56		 je	 SHORT $LN13@s390_exter
$LN14@s390_exter:

; 101  : #endif
; 102  :        )
; 103  :     {
; 104  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 105  :         /* Abort any active transaction and then return back to here
; 106  :            to continue with external interrupt processing */
; 107  :         if (regs->txf_tnd)
; 108  :         {
; 109  :             PTT_TXF( "*TXF EI", 0, 0, regs->txf_tnd );
; 110  :             regs->txf_why |= TXF_WHY_EXT_INT;
; 111  :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_EXT );
; 112  :         }
; 113  : #endif
; 114  :         /* Store current PSW at PSA+X'18' */
; 115  :         ARCH_DEP(store_psw) (regs, psa->extold);

  002d0	48 8b 44 24 50	 mov	 rax, QWORD PTR psa$[rsp]
  002d5	48 83 c0 18	 add	 rax, 24
  002d9	48 8b d0	 mov	 rdx, rax
  002dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002e1	e8 00 00 00 00	 call	 s390_store_psw

; 116  : 
; 117  :         /* Load new PSW from PSA+X'58' */
; 118  :         rc = ARCH_DEP(load_psw) (regs, psa->extnew);

  002e6	48 8b 44 24 50	 mov	 rax, QWORD PTR psa$[rsp]
  002eb	48 83 c0 58	 add	 rax, 88			; 00000058H
  002ef	48 8b d0	 mov	 rdx, rax
  002f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	e8 00 00 00 00	 call	 s390_load_psw
  002fc	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 119  : 
; 120  :         if ( rc )

  00300	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00305	74 1f		 je	 SHORT $LN15@s390_exter

; 121  :         {
; 122  :             RELEASE_INTLOCK(regs);

  00307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179834
  0030e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00313	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 123  :             ARCH_DEP(program_interrupt)(regs, rc);

  00318	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0031c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 s390_program_interrupt
$LN15@s390_exter:
$LN13@s390_exter:

; 124  :         }
; 125  :     }
; 126  : 
; 127  : #if defined(FEATURE_INTERVAL_TIMER)
; 128  :     /* Ensure the interval timer is uptodate */
; 129  :     ARCH_DEP( store_int_timer_locked )( regs );
; 130  : #endif
; 131  :     RELEASE_INTLOCK(regs);

  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179835
  0032d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00332	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 132  : 
; 133  : 
; 134  :     if ( SIE_MODE(regs)
; 135  : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 136  :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 137  : #endif
; 138  : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 139  :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00337	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0033c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00342	d1 e8		 shr	 eax, 1
  00344	83 e0 01	 and	 eax, 1
  00347	85 c0		 test	 eax, eax
  00349	74 54		 je	 SHORT $LN16@s390_exter
  0034b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00350	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00357	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0035b	83 e0 02	 and	 eax, 2
  0035e	85 c0		 test	 eax, eax
  00360	75 3d		 jne	 SHORT $LN16@s390_exter
  00362	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00367	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0036e	b9 01 00 00 00	 mov	 ecx, 1
  00373	48 6b c9 00	 imul	 rcx, rcx, 0
  00377	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0037c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00381	85 c0		 test	 eax, eax
  00383	75 1a		 jne	 SHORT $LN16@s390_exter

; 140  : #endif
; 141  :        )
; 142  :         longjmp (regs->progjmp, SIE_INTERCEPT_EXT);

  00385	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0038a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00390	ba f4 ff ff ff	 mov	 edx, -12
  00395	48 8b c8	 mov	 rcx, rax
  00398	e8 00 00 00 00	 call	 longjmp
  0039d	eb 18		 jmp	 SHORT $LN17@s390_exter
$LN16@s390_exter:

; 143  :     else
; 144  :         longjmp (regs->progjmp, SIE_NO_INTERCEPT);

  0039f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003a4	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  003aa	ba ff ff ff ff	 mov	 edx, -1
  003af	48 8b c8	 mov	 rcx, rax
  003b2	e8 00 00 00 00	 call	 longjmp
$LN17@s390_exter:
$LN18@s390_exter:

; 145  : 
; 146  : } /* end function external_interrupt */

  003b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003bb	c3		 ret	 0
s390_external_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
i$ = 32
sspsa$ = 40
ssreg$ = 64
aaddr$ = 72
s390_store_status PROC

; 556  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 557  : int     i;                              /* Array subscript           */
; 558  : PSA     *sspsa;                         /* -> Store status area      */
; 559  : 
; 560  :     /* Set reference and change bits */
; 561  :     ARCH_DEP( or_storage_key )( aaddr, (STORKEY_REF | STORKEY_CHANGE) );

  0000e	b2 06		 mov	 dl, 6
  00010	48 8b 4c 24 48	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00015	e8 00 00 00 00	 call	 s390_or_storage_key

; 562  : 
; 563  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 564  : 
; 565  :     /* The ESAME PSA is two pages in size */
; 566  :     if(!aaddr)
; 567  :         ARCH_DEP( or_storage_key )( aaddr + 4096, (STORKEY_REF | STORKEY_CHANGE) );
; 568  : 
; 569  :     /* For store status at address, we must adjust the PSA offset */
; 570  :     /* ZZ THIS TEST IS NOT CONCLUSIVE */
; 571  :     if(aaddr != 0 && aaddr != ssreg->PX)
; 572  :         aaddr -= 512 + 4096 ;
; 573  : #endif
; 574  : 
; 575  :     aaddr &= 0x7FFFFE00;

  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  0001f	48 25 00 fe ff
	7f		 and	 rax, 2147483136		; 7ffffe00H
  00025	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax

; 576  : 
; 577  :     /* Point to the PSA into which status is to be stored */
; 578  :     sspsa = (void*)(ssreg->mainstor + aaddr);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  0002f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00036	48 03 44 24 48	 add	 rax, QWORD PTR aaddr$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR sspsa$[rsp], rax

; 579  : 
; 580  :     /* Store CPU timer in bytes 216-223 */
; 581  :     STORE_DW(sspsa->storeptmr, get_cpu_timer(ssreg));

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00045	e8 00 00 00 00	 call	 get_cpu_timer
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 _byteswap_uint64
  00052	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  00057	48 81 c1 d8 00
	00 00		 add	 rcx, 216		; 000000d8H
  0005e	48 8b d0	 mov	 rdx, rax
  00061	e8 00 00 00 00	 call	 store_dw_noswap

; 582  : 
; 583  :     /* Store clock comparator in bytes 224-231 */
; 584  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 585  :     STORE_DW( sspsa->storeclkc, ssreg->clkc );
; 586  : #else
; 587  :     STORE_DW( sspsa->storeclkc, ssreg->clkc << 8 );

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  0006b	48 8b 80 48 07
	00 00		 mov	 rax, QWORD PTR [rax+1864]
  00072	48 c1 e0 08	 shl	 rax, 8
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 _byteswap_uint64
  0007e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  00083	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  0008a	48 8b d0	 mov	 rdx, rax
  0008d	e8 00 00 00 00	 call	 store_dw_noswap

; 588  : #endif
; 589  : 
; 590  :     /* Store PSW in bytes 256-263 */
; 591  :     ARCH_DEP(store_psw) (ssreg, sspsa->storepsw);

  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  00097	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0009d	48 8b d0	 mov	 rdx, rax
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  000a5	e8 00 00 00 00	 call	 s390_store_psw

; 592  : 
; 593  :     /* Store prefix register in bytes 264-267 */
; 594  :     STORE_FW(sspsa->storepfx,ssreg->PX);

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  000af	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000b2	e8 00 00 00 00	 call	 _byteswap_ulong
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  000bc	48 81 c1 08 01
	00 00		 add	 rcx, 264		; 00000108H
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 595  : 
; 596  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 597  :     /* Store Floating Point Control Register */
; 598  :     STORE_FW(sspsa->storefpc,ssreg->fpc);
; 599  : 
; 600  :     /* Store TOD Programable register */
; 601  :     STORE_FW(sspsa->storetpr,ssreg->todpr);
; 602  : #endif
; 603  : 
; 604  : #if defined( _900 )
; 605  :     /* Only store the arch mode indicator for a PSA type store status */
; 606  :     if (!aaddr)

  000ca	48 83 7c 24 48
	00		 cmp	 QWORD PTR aaddr$[rsp], 0
  000d0	75 0c		 jne	 SHORT $LN14@s390_store

; 607  :   #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 608  :         sspsa->arch = 1;
; 609  :   #else
; 610  :         sspsa->arch = 0;

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  000d7	c6 80 a3 00 00
	00 00		 mov	 BYTE PTR [rax+163], 0
$LN14@s390_store:

; 611  :   #endif
; 612  : #endif /* defined( _900 ) */
; 613  : 
; 614  :     /* Store access registers in bytes 288-351 */
; 615  :     for (i = 0; i < 16; i++)

  000de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e6	eb 0a		 jmp	 SHORT $LN4@s390_store
$LN2@s390_store:
  000e8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ec	ff c0		 inc	 eax
  000ee	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_store:
  000f2	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  000f7	7d 31		 jge	 SHORT $LN3@s390_store

; 616  :         STORE_FW(sspsa->storear[i],ssreg->AR(i));

  000f9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00103	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  0010a	e8 00 00 00 00	 call	 _byteswap_ulong
  0010f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00114	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00119	48 8d 8c 8a 20
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+288]
  00121	8b d0		 mov	 edx, eax
  00123	e8 00 00 00 00	 call	 store_fw_noswap
  00128	eb be		 jmp	 SHORT $LN2@s390_store
$LN3@s390_store:

; 617  : 
; 618  :     /* Store floating-point registers in bytes 352-383 */
; 619  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 620  :     for (i = 0; i < 32; i++)
; 621  : #else
; 622  :     for (i = 0; i < 8; i++)

  0012a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00132	eb 0a		 jmp	 SHORT $LN7@s390_store
$LN5@s390_store:
  00134	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00138	ff c0		 inc	 eax
  0013a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_store:
  0013e	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00143	7d 31		 jge	 SHORT $LN6@s390_store

; 623  : #endif
; 624  :         STORE_FW(sspsa->storefpr[i],ssreg->fpr[i]);

  00145	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0014f	8b 8c 81 40 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+832]
  00156	e8 00 00 00 00	 call	 _byteswap_ulong
  0015b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00160	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00165	48 8d 8c 8a 60
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+352]
  0016d	8b d0		 mov	 edx, eax
  0016f	e8 00 00 00 00	 call	 store_fw_noswap
  00174	eb be		 jmp	 SHORT $LN5@s390_store
$LN6@s390_store:

; 625  : 
; 626  :     /* Store general-purpose registers in bytes 384-447 */
; 627  :     for (i = 0; i < 16; i++)

  00176	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0017e	eb 0a		 jmp	 SHORT $LN10@s390_store
$LN8@s390_store:
  00180	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00184	ff c0		 inc	 eax
  00186	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_store:
  0018a	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  0018f	7d 31		 jge	 SHORT $LN9@s390_store

; 628  :         STORE_W(sspsa->storegpr[i],ssreg->GR(i));

  00191	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0019b	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001a2	e8 00 00 00 00	 call	 _byteswap_ulong
  001a7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ac	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  001b1	48 8d 8c 8a 80
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+384]
  001b9	8b d0		 mov	 edx, eax
  001bb	e8 00 00 00 00	 call	 store_fw_noswap
  001c0	eb be		 jmp	 SHORT $LN8@s390_store
$LN9@s390_store:

; 629  : 
; 630  :     /* Store control registers in bytes 448-511 */
; 631  :     for (i = 0; i < 16; i++)

  001c2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ca	eb 0a		 jmp	 SHORT $LN13@s390_store
$LN11@s390_store:
  001cc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@s390_store:
  001d6	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001db	7d 34		 jge	 SHORT $LN12@s390_store

; 632  :         STORE_W(sspsa->storecr[i],ssreg->CR(i));

  001dd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e1	ff c0		 inc	 eax
  001e3	48 98		 cdqe
  001e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  001ea	8b 8c c1 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+1536]
  001f1	e8 00 00 00 00	 call	 _byteswap_ulong
  001f6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fb	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00200	48 8d 8c 8a c0
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+448]
  00208	8b d0		 mov	 edx, eax
  0020a	e8 00 00 00 00	 call	 store_fw_noswap
  0020f	eb bb		 jmp	 SHORT $LN11@s390_store
$LN12@s390_store:

; 633  : 
; 634  :     /* Store Breaking-Event Address Register if BEAR-Enhancement */
; 635  : #if defined( FEATURE_193_BEAR_ENH_FACILITY )
; 636  :     if (FACILITY_ENABLED( 193_BEAR_ENH, ssreg ))
; 637  :         STORE_DW( sspsa->bear, ssreg->bear );
; 638  : #endif
; 639  : 
; 640  : } /* end function store_status */

  00211	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00215	c3		 ret	 0
s390_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
cpuad$ = 128
servcode$ = 132
psa$ = 136
i$1 = 144
i$2 = 148
tv443 = 152
tv599 = 156
mask$3 = 160
mask$4 = 168
tv82 = 176
tv342 = 180
tv411 = 184
tv457 = 188
tv460 = 192
tv465 = 196
tv469 = 200
tv474 = 204
tv477 = 208
tv537 = 212
tv637 = 216
tv84 = 224
tv344 = 232
tv405 = 240
tv413 = 248
tv479 = 256
tv539 = 264
tv639 = 272
buf$5 = 280
__$ArrayPad$ = 320
regs$ = 352
s390_perform_external_interrupt PROC

; 165  : {

$LN97:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 166  : PSA    *psa;                            /* -> Prefixed storage area  */
; 167  : U16     cpuad;                          /* Originating CPU address   */
; 168  : #if defined( FEATURE_VM_BLOCKIO )
; 169  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 170  : RADR    servpadr;      /* Address of 64-bit block I/O interrupt */
; 171  : #endif
; 172  : U16     servcode;      /* Service Signal or Block I/O Interrupt code */
; 173  : #endif /* defined( FEATURE_VM_BLOCKIO ) */
; 174  : 
; 175  :     /* External interrupt if console interrupt key was depressed */
; 176  :     if ( OPEN_IC_INTKEY(regs) && !SIE_MODE(regs) )

  0001f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00032	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00035	23 c1		 and	 eax, ecx
  00037	83 e0 40	 and	 eax, 64			; 00000040H
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 e3 01 00
	00		 je	 $LN47@s390_perfo
  00042	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00050	d1 e8		 shr	 eax, 1
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	0f 85 c8 01 00
	00		 jne	 $LN47@s390_perfo

; 177  :     {
; 178  :         if (regs->insttrace && sysblk.traceFILE)

  0005d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0006b	c1 e8 0f	 shr	 eax, 15
  0006e	83 e0 01	 and	 eax, 1
  00071	85 c0		 test	 eax, eax
  00073	74 23		 je	 SHORT $LN48@s390_perfo
  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00084	74 12		 je	 SHORT $LN48@s390_perfo

; 179  :             tf_0840( regs, EXT_INTERRUPT_KEY_INTERRUPT );

  00086	66 ba 40 00	 mov	 dx, 64			; 00000040H
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
$LN48@s390_perfo:

; 180  : 
; 181  :         // "Processor %s%02X: External interrupt: interrupt key"
; 182  :         WRMSG( HHC00840, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  00098	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000a7	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000ae	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c4	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000d2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e5	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  000f8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179932
  00104	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179933
  00110	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179934
  00127	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179935
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@s390_perfo:

; 183  : 
; 184  :         /* Reset interrupt key pending */
; 185  :         OFF_IC_INTKEY;

  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00140	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00146	83 e0 40	 and	 eax, 64			; 00000040H
  00149	85 c0		 test	 eax, eax
  0014b	0f 84 b8 00 00
	00		 je	 $LN49@s390_perfo
  00151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00158	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0015e	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00168	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00175	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0017c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00184	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  0018f	eb 10		 jmp	 SHORT $LN7@s390_perfo
$LN5@s390_perfo:
  00191	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  00198	ff c0		 inc	 eax
  0019a	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN7@s390_perfo:
  001a1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR mask$3[rsp], 0
  001aa	74 5d		 je	 SHORT $LN6@s390_perfo
  001ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 37		 je	 SHORT $LN50@s390_perfo
  001bd	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  001c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001cc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d7	83 e0 bf	 and	 eax, -65		; ffffffbfH
  001da	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001e2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001f1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN50@s390_perfo:
  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001fc	48 d1 e8	 shr	 rax, 1
  001ff	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00207	eb 88		 jmp	 SHORT $LN5@s390_perfo
$LN6@s390_perfo:
$LN49@s390_perfo:
  00209	33 c0		 xor	 eax, eax
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 26 ff ff
	ff		 jne	 $LN4@s390_perfo

; 186  : 
; 187  :         /* Generate interrupt key interrupt */
; 188  :         ARCH_DEP(external_interrupt) (EXT_INTERRUPT_KEY_INTERRUPT, regs);

  00213	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0021b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00220	e8 00 00 00 00	 call	 s390_external_interrupt
$LN47@s390_perfo:

; 189  :     }
; 190  : 
; 191  :     /* External interrupt if malfunction alert is pending */
; 192  :     if (OPEN_IC_MALFALT(regs))

  00225	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00235	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00238	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0023b	23 c1		 and	 eax, ecx
  0023d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00242	85 c0		 test	 eax, eax
  00244	0f 84 a7 01 00
	00		 je	 $LN51@s390_perfo

; 193  :     {
; 194  :         /* Find first CPU which generated a malfunction alert */
; 195  :         for (cpuad = 0; regs->malfcpu[cpuad] == 0; cpuad++)

  0024a	33 c0		 xor	 eax, eax
  0024c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00254	eb 13		 jmp	 SHORT $LN10@s390_perfo
$LN8@s390_perfo:
  00256	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0025e	66 ff c0	 inc	 ax
  00261	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN10@s390_perfo:
  00269	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00271	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00281	85 c0		 test	 eax, eax
  00283	75 3e		 jne	 SHORT $LN9@s390_perfo

; 196  :         {
; 197  :             if (cpuad >= sysblk.maxcpu)

  00285	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0028d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00294	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  0029a	7c 25		 jl	 SHORT $LN52@s390_perfo
$LN13@s390_perfo:

; 198  :             {
; 199  :                 OFF_IC_MALFALT(regs);

  0029c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002a7	0f ba f0 0f	 btr	 eax, 15
  002ab	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  002b6	33 c0		 xor	 eax, eax
  002b8	85 c0		 test	 eax, eax
  002ba	75 e0		 jne	 SHORT $LN13@s390_perfo

; 200  :                 return;

  002bc	e9 4c 10 00 00	 jmp	 $LN1@s390_perfo
$LN52@s390_perfo:

; 201  :             }
; 202  :         } /* end for(cpuad) */

  002c1	eb 93		 jmp	 SHORT $LN8@s390_perfo
$LN9@s390_perfo:

; 203  : 
; 204  : // /*debug*/ LOGMSG( "External interrupt: Malfuction Alert from CPU %d\n",
; 205  : // /*debug*/    cpuad );
; 206  : 
; 207  :         /* Reset the indicator for the CPU which was found */
; 208  :         regs->malfcpu[cpuad] = 0;

  002c3	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  002cb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	c6 84 01 00 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+256], 0

; 209  : 
; 210  :         /* Store originating CPU address at PSA+X'84' */
; 211  :         psa = (void*)(regs->mainstor + regs->PX);

  002db	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002e6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  002f5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 212  :         STORE_HW(psa->extcpad,cpuad);

  002fd	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00305	e8 00 00 00 00	 call	 _byteswap_ushort
  0030a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00312	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00319	0f b7 d0	 movzx	 edx, ax
  0031c	e8 00 00 00 00	 call	 store_hw_noswap
$LN16@s390_perfo:

; 213  : 
; 214  :         /* Reset emergency signal pending flag if there are
; 215  :            no other CPUs which generated emergency signal */
; 216  :         OFF_IC_MALFALT(regs);

  00321	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00329	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0032c	0f ba f0 0f	 btr	 eax, 15
  00330	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0033b	33 c0		 xor	 eax, eax
  0033d	85 c0		 test	 eax, eax
  0033f	75 e0		 jne	 SHORT $LN16@s390_perfo
$LN17@s390_perfo:

; 217  :         while (++cpuad < sysblk.maxcpu)

  00341	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00349	66 ff c0	 inc	 ax
  0034c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00354	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0035c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00363	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00369	7d 74		 jge	 SHORT $LN18@s390_perfo

; 218  :         {
; 219  :             if (regs->malfcpu[cpuad])

  0036b	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00373	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037b	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00383	85 c0		 test	 eax, eax
  00385	74 53		 je	 SHORT $LN53@s390_perfo
$LN21@s390_perfo:

; 220  :             {
; 221  :                 ON_IC_MALFALT(regs);

  00387	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00392	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00397	85 c0		 test	 eax, eax
  00399	74 1d		 je	 SHORT $LN54@s390_perfo
  0039b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a3	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003a6	0d 00 80 00 80	 or	 eax, -2147450880	; 80008000H
  003ab	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003b6	eb 1a		 jmp	 SHORT $LN55@s390_perfo
$LN54@s390_perfo:
  003b8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003c3	0f ba e8 0f	 bts	 eax, 15
  003c7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cf	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN55@s390_perfo:
  003d2	33 c0		 xor	 eax, eax
  003d4	85 c0		 test	 eax, eax
  003d6	75 af		 jne	 SHORT $LN21@s390_perfo

; 222  :                 break;

  003d8	eb 05		 jmp	 SHORT $LN18@s390_perfo
$LN53@s390_perfo:

; 223  :             }
; 224  :         } /* end while */

  003da	e9 62 ff ff ff	 jmp	 $LN17@s390_perfo
$LN18@s390_perfo:

; 225  : 
; 226  :         /* Generate emergency signal interrupt */
; 227  :         ARCH_DEP(external_interrupt) (EXT_MALFUNCTION_ALERT_INTERRUPT, regs);

  003df	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e7	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  003ec	e8 00 00 00 00	 call	 s390_external_interrupt
$LN51@s390_perfo:

; 228  :     }
; 229  : 
; 230  :     /* External interrupt if emergency signal is pending */
; 231  :     if (OPEN_IC_EMERSIG(regs))

  003f1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00401	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00404	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00407	23 c1		 and	 eax, ecx
  00409	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0040e	85 c0		 test	 eax, eax
  00410	0f 84 a7 01 00
	00		 je	 $LN56@s390_perfo

; 232  :     {
; 233  :         /* Find first CPU which generated an emergency signal */
; 234  :         for (cpuad = 0; regs->emercpu[cpuad] == 0; cpuad++)

  00416	33 c0		 xor	 eax, eax
  00418	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00420	eb 13		 jmp	 SHORT $LN24@s390_perfo
$LN22@s390_perfo:
  00422	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0042a	66 ff c0	 inc	 ax
  0042d	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN24@s390_perfo:
  00435	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0043d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  0044d	85 c0		 test	 eax, eax
  0044f	75 3e		 jne	 SHORT $LN23@s390_perfo

; 235  :         {
; 236  :             if (cpuad >= sysblk.maxcpu)

  00451	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00459	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00460	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00466	7c 25		 jl	 SHORT $LN57@s390_perfo
$LN27@s390_perfo:

; 237  :             {
; 238  :                 OFF_IC_EMERSIG(regs);

  00468	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00470	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00473	0f ba f0 0e	 btr	 eax, 14
  00477	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00482	33 c0		 xor	 eax, eax
  00484	85 c0		 test	 eax, eax
  00486	75 e0		 jne	 SHORT $LN27@s390_perfo

; 239  :                 return;

  00488	e9 80 0e 00 00	 jmp	 $LN1@s390_perfo
$LN57@s390_perfo:

; 240  :             }
; 241  :         } /* end for(cpuad) */

  0048d	eb 93		 jmp	 SHORT $LN22@s390_perfo
$LN23@s390_perfo:

; 242  : 
; 243  : // /*debug*/ LOGMSG( "External interrupt: Emergency Signal from CPU %d\n",
; 244  : // /*debug*/    cpuad );
; 245  : 
; 246  :         /* Reset the indicator for the CPU which was found */
; 247  :         regs->emercpu[cpuad] = 0;

  0048f	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00497	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049f	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0

; 248  : 
; 249  :         /* Store originating CPU address at PSA+X'84' */
; 250  :         psa = (void*)(regs->mainstor + regs->PX);

  004a7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004af	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004b2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ba	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  004c1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 251  :         STORE_HW(psa->extcpad,cpuad);

  004c9	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  004d1	e8 00 00 00 00	 call	 _byteswap_ushort
  004d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  004de	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  004e5	0f b7 d0	 movzx	 edx, ax
  004e8	e8 00 00 00 00	 call	 store_hw_noswap
$LN30@s390_perfo:

; 252  : 
; 253  :         /* Reset emergency signal pending flag if there are
; 254  :            no other CPUs which generated emergency signal */
; 255  :         OFF_IC_EMERSIG(regs);

  004ed	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004f8	0f ba f0 0e	 btr	 eax, 14
  004fc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00504	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00507	33 c0		 xor	 eax, eax
  00509	85 c0		 test	 eax, eax
  0050b	75 e0		 jne	 SHORT $LN30@s390_perfo
$LN31@s390_perfo:

; 256  :         while (++cpuad < sysblk.maxcpu)

  0050d	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00515	66 ff c0	 inc	 ax
  00518	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00520	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00528	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052f	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00535	7d 74		 jge	 SHORT $LN32@s390_perfo

; 257  :         {
; 258  :             if (regs->emercpu[cpuad])

  00537	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0053f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00547	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  0054f	85 c0		 test	 eax, eax
  00551	74 53		 je	 SHORT $LN58@s390_perfo
$LN35@s390_perfo:

; 259  :             {
; 260  :                 ON_IC_EMERSIG(regs);

  00553	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0055e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00563	85 c0		 test	 eax, eax
  00565	74 1d		 je	 SHORT $LN59@s390_perfo
  00567	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00572	0d 00 40 00 80	 or	 eax, -2147467264	; 80004000H
  00577	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00582	eb 1a		 jmp	 SHORT $LN60@s390_perfo
$LN59@s390_perfo:
  00584	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0058f	0f ba e8 0e	 bts	 eax, 14
  00593	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN60@s390_perfo:
  0059e	33 c0		 xor	 eax, eax
  005a0	85 c0		 test	 eax, eax
  005a2	75 af		 jne	 SHORT $LN35@s390_perfo

; 261  :                 break;

  005a4	eb 05		 jmp	 SHORT $LN32@s390_perfo
$LN58@s390_perfo:

; 262  :             }
; 263  :         } /* end while */

  005a6	e9 62 ff ff ff	 jmp	 $LN31@s390_perfo
$LN32@s390_perfo:

; 264  : 
; 265  :         /* Generate emergency signal interrupt */
; 266  :         ARCH_DEP(external_interrupt) (EXT_EMERGENCY_SIGNAL_INTERRUPT, regs);

  005ab	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b3	b9 01 12 00 00	 mov	 ecx, 4609		; 00001201H
  005b8	e8 00 00 00 00	 call	 s390_external_interrupt
$LN56@s390_perfo:

; 267  :     }
; 268  : 
; 269  :     /* External interrupt if external call is pending */
; 270  :     if (OPEN_IC_EXTCALL(regs))

  005bd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005cd	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  005d0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005d3	23 c1		 and	 eax, ecx
  005d5	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  005da	85 c0		 test	 eax, eax
  005dc	74 7c		 je	 SHORT $LN61@s390_perfo
$LN38@s390_perfo:

; 271  :     {
; 272  : //  /*debug*/ LOGMSG( "External interrupt: External Call from CPU %d\n",
; 273  : //  /*debug*/       regs->extccpu );
; 274  : 
; 275  :         /* Reset external call pending */
; 276  :         OFF_IC_EXTCALL(regs);

  005de	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005e9	0f ba f0 0d	 btr	 eax, 13
  005ed	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f5	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  005f8	33 c0		 xor	 eax, eax
  005fa	85 c0		 test	 eax, eax
  005fc	75 e0		 jne	 SHORT $LN38@s390_perfo

; 277  : 
; 278  :         /* Store originating CPU address at PSA+X'84' */
; 279  :         psa = (void*)(regs->mainstor + regs->PX);

  005fe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00606	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00609	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00611	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00618	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 280  :         STORE_HW(psa->extcpad,regs->extccpu);

  00620	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00628	0f b7 48 62	 movzx	 ecx, WORD PTR [rax+98]
  0062c	e8 00 00 00 00	 call	 _byteswap_ushort
  00631	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00639	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00640	0f b7 d0	 movzx	 edx, ax
  00643	e8 00 00 00 00	 call	 store_hw_noswap

; 281  : 
; 282  :         /* Generate external call interrupt */
; 283  :         ARCH_DEP(external_interrupt) (EXT_EXTERNAL_CALL_INTERRUPT, regs);

  00648	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00650	b9 02 12 00 00	 mov	 ecx, 4610		; 00001202H
  00655	e8 00 00 00 00	 call	 s390_external_interrupt
$LN61@s390_perfo:

; 284  :     }
; 285  : 
; 286  :     /* External interrupt if TOD clock exceeds clock comparator */
; 287  :     if (1
; 288  :         && get_tod_clock( regs ) > regs->clkc
; 289  :         && OPEN_IC_CLKC( regs )

  0065a	33 c0		 xor	 eax, eax
  0065c	83 f8 01	 cmp	 eax, 1
  0065f	0f 84 fa 01 00
	00		 je	 $LN62@s390_perfo
  00665	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066d	e8 00 00 00 00	 call	 get_tod_clock
  00672	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067a	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  00681	0f 86 d8 01 00
	00		 jbe	 $LN62@s390_perfo
  00687	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00697	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0069a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0069d	23 c1		 and	 eax, ecx
  0069f	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  006a4	85 c0		 test	 eax, eax
  006a6	0f 84 b3 01 00
	00		 je	 $LN62@s390_perfo

; 290  :     )
; 291  :     {
; 292  :         if (1
; 293  :             && CPU_STEPPING_OR_TRACING_ALL
; 294  :             && !TXF_INSTR_TRACING()

  006ac	33 c0		 xor	 eax, eax
  006ae	83 f8 01	 cmp	 eax, 1
  006b1	0f 84 96 01 00
	00		 je	 $LN63@s390_perfo
  006b7	b8 08 00 00 00	 mov	 eax, 8
  006bc	48 6b c0 00	 imul	 rax, rax, 0
  006c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006c7	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006d0	75 32		 jne	 SHORT $LN65@s390_perfo
  006d2	b8 08 00 00 00	 mov	 eax, 8
  006d7	48 6b c0 01	 imul	 rax, rax, 1
  006db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006e2	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006eb	75 17		 jne	 SHORT $LN65@s390_perfo
  006ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f4	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006fa	c1 e8 0a	 shr	 eax, 10
  006fd	83 e0 01	 and	 eax, 1
  00700	85 c0		 test	 eax, eax
  00702	75 4e		 jne	 SHORT $LN64@s390_perfo
$LN65@s390_perfo:
  00704	b8 08 00 00 00	 mov	 eax, 8
  00709	48 6b c0 00	 imul	 rax, rax, 0
  0070d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00714	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0071d	0f 85 2a 01 00
	00		 jne	 $LN63@s390_perfo
  00723	b8 08 00 00 00	 mov	 eax, 8
  00728	48 6b c0 01	 imul	 rax, rax, 1
  0072c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00733	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0073c	0f 85 0b 01 00
	00		 jne	 $LN63@s390_perfo
  00742	e8 00 00 00 00	 call	 insttrace_all
  00747	0f b6 c0	 movzx	 eax, al
  0074a	85 c0		 test	 eax, eax
  0074c	0f 84 fb 00 00
	00		 je	 $LN63@s390_perfo
$LN64@s390_perfo:
  00752	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00759	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0075f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00764	85 c0		 test	 eax, eax
  00766	0f 85 e1 00 00
	00		 jne	 $LN63@s390_perfo

; 295  :         )
; 296  :         {
; 297  :             if (regs->insttrace && sysblk.traceFILE)

  0076c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00774	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0077a	c1 e8 0f	 shr	 eax, 15
  0077d	83 e0 01	 and	 eax, 1
  00780	85 c0		 test	 eax, eax
  00782	74 28		 je	 SHORT $LN66@s390_perfo
  00784	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00793	74 17		 je	 SHORT $LN66@s390_perfo

; 298  :                 tf_0840( regs, EXT_CLOCK_COMPARATOR_INTERRUPT );

  00795	66 ba 04 10	 mov	 dx, 4100		; 00001004H
  00799	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  007a7	e9 a1 00 00 00	 jmp	 $LN67@s390_perfo
$LN66@s390_perfo:

; 299  :             else
; 300  :                 // "Processor %s%02X: External interrupt: clock comparator"
; 301  :                 WRMSG( HHC00841, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  007ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b4	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007bb	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv342[rsp], eax
  007c2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ca	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  007d1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d8	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  007e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  007e6	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv344[rsp], rax
  007ee	b9 01 00 00 00	 mov	 ecx, 1
  007f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f9	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv342[rsp]
  00800	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00804	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv344[rsp]
  0080c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00811	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179955
  00818	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179956
  00824	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00829	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00834	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179957
  0083b	ba 2d 01 00 00	 mov	 edx, 301		; 0000012dH
  00840	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179958
  00847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN67@s390_perfo:
$LN63@s390_perfo:

; 302  :         }
; 303  :         ARCH_DEP( external_interrupt )( EXT_CLOCK_COMPARATOR_INTERRUPT, regs );

  0084d	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00855	b9 04 10 00 00	 mov	 ecx, 4100		; 00001004H
  0085a	e8 00 00 00 00	 call	 s390_external_interrupt
$LN62@s390_perfo:

; 304  :     }
; 305  : 
; 306  :     /* External interrupt if CPU timer is negative */
; 307  :     if (1
; 308  :         && CPU_TIMER( regs ) < 0
; 309  :         && OPEN_IC_PTIMER( regs )

  0085f	33 c0		 xor	 eax, eax
  00861	83 f8 01	 cmp	 eax, 1
  00864	0f 84 11 02 00
	00		 je	 $LN68@s390_perfo
  0086a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00872	e8 00 00 00 00	 call	 get_cpu_timer
  00877	48 85 c0	 test	 rax, rax
  0087a	0f 8d fb 01 00
	00		 jge	 $LN68@s390_perfo
  00880	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00888	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00890	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00893	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00896	23 c1		 and	 eax, ecx
  00898	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0089d	85 c0		 test	 eax, eax
  0089f	0f 84 d6 01 00
	00		 je	 $LN68@s390_perfo

; 310  :     )
; 311  :     {
; 312  :         if (1
; 313  :             && CPU_STEPPING_OR_TRACING_ALL
; 314  :             && !TXF_INSTR_TRACING()

  008a5	33 c0		 xor	 eax, eax
  008a7	83 f8 01	 cmp	 eax, 1
  008aa	0f 84 b9 01 00
	00		 je	 $LN69@s390_perfo
  008b0	b8 08 00 00 00	 mov	 eax, 8
  008b5	48 6b c0 00	 imul	 rax, rax, 0
  008b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008c0	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008c9	75 32		 jne	 SHORT $LN71@s390_perfo
  008cb	b8 08 00 00 00	 mov	 eax, 8
  008d0	48 6b c0 01	 imul	 rax, rax, 1
  008d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008db	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008e4	75 17		 jne	 SHORT $LN71@s390_perfo
  008e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ed	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  008f3	c1 e8 0a	 shr	 eax, 10
  008f6	83 e0 01	 and	 eax, 1
  008f9	85 c0		 test	 eax, eax
  008fb	75 4e		 jne	 SHORT $LN70@s390_perfo
$LN71@s390_perfo:
  008fd	b8 08 00 00 00	 mov	 eax, 8
  00902	48 6b c0 00	 imul	 rax, rax, 0
  00906	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0090d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00916	0f 85 4d 01 00
	00		 jne	 $LN69@s390_perfo
  0091c	b8 08 00 00 00	 mov	 eax, 8
  00921	48 6b c0 01	 imul	 rax, rax, 1
  00925	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0092c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00935	0f 85 2e 01 00
	00		 jne	 $LN69@s390_perfo
  0093b	e8 00 00 00 00	 call	 insttrace_all
  00940	0f b6 c0	 movzx	 eax, al
  00943	85 c0		 test	 eax, eax
  00945	0f 84 1e 01 00
	00		 je	 $LN69@s390_perfo
$LN70@s390_perfo:
  0094b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00952	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00958	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0095d	85 c0		 test	 eax, eax
  0095f	0f 85 04 01 00
	00		 jne	 $LN69@s390_perfo

; 315  :         )
; 316  :         {
; 317  :             if (regs->insttrace && sysblk.traceFILE)

  00965	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0096d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00973	c1 e8 0f	 shr	 eax, 15
  00976	83 e0 01	 and	 eax, 1
  00979	85 c0		 test	 eax, eax
  0097b	74 28		 je	 SHORT $LN72@s390_perfo
  0097d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00984	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0098c	74 17		 je	 SHORT $LN72@s390_perfo

; 318  :                 tf_0840( regs, EXT_CPU_TIMER_INTERRUPT );

  0098e	66 ba 05 10	 mov	 dx, 4101		; 00001005H
  00992	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  009a0	e9 c4 00 00 00	 jmp	 $LN73@s390_perfo
$LN72@s390_perfo:

; 319  :             else
; 320  :                 // "Processor %s%02X: External interrupt: CPU timer=%16.16"PRIX64
; 321  :                 WRMSG( HHC00842, "I", PTYPSTR( regs->cpuad ), regs->cpuad, CPU_TIMER( regs ));

  009a5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ad	e8 00 00 00 00	 call	 get_cpu_timer
  009b2	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv405[rsp], rax
  009ba	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c2	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  009c9	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv411[rsp], ecx
  009d0	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009d8	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  009df	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  009e6	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  009ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  009f5	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv413[rsp], rax
  009fd	b9 01 00 00 00	 mov	 ecx, 1
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a08	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv405[rsp]
  00a10	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a15	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv411[rsp]
  00a1c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a20	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv413[rsp]
  00a28	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179965
  00a34	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179966
  00a40	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a45	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a50	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179967
  00a57	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179968
  00a63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN73@s390_perfo:
$LN69@s390_perfo:

; 322  :         }
; 323  :         ARCH_DEP( external_interrupt )( EXT_CPU_TIMER_INTERRUPT, regs );

  00a69	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a71	b9 05 10 00 00	 mov	 ecx, 4101		; 00001005H
  00a76	e8 00 00 00 00	 call	 s390_external_interrupt
$LN68@s390_perfo:

; 324  :     }
; 325  : 
; 326  :     /* External interrupt if interval timer interrupt is pending */
; 327  : #if defined(FEATURE_INTERVAL_TIMER)
; 328  :     if (OPEN_IC_ITIMER(regs)
; 329  : #if defined(_FEATURE_SIE)
; 330  :         && !(SIE_STATE_BIT_ON(regs, M, ITMOF))
; 331  : #endif
; 332  :         )
; 333  :     {
; 334  :         if (1
; 335  :             && CPU_STEPPING_OR_TRACING_ALL
; 336  :             && !TXF_INSTR_TRACING()
; 337  :         )
; 338  :         {
; 339  :             if (regs->insttrace && sysblk.traceFILE)
; 340  :                 tf_0840( regs, EXT_INTERVAL_TIMER_INTERRUPT );
; 341  :             else
; 342  :                 // "Processor %s%02X: External interrupt: interval timer"
; 343  :                 WRMSG( HHC00843, "I", PTYPSTR( regs->cpuad ), regs->cpuad );
; 344  :         }
; 345  :         OFF_IC_ITIMER(regs);
; 346  :         ARCH_DEP(external_interrupt) (EXT_INTERVAL_TIMER_INTERRUPT, regs);
; 347  :     }
; 348  : 
; 349  : #if defined(FEATURE_ECPSVM)
; 350  :     if ( OPEN_IC_ECPSVTIMER(regs) )
; 351  :     {
; 352  :         OFF_IC_ECPSVTIMER(regs);
; 353  :         ARCH_DEP(external_interrupt) (EXT_VINTERVAL_TIMER_INTERRUPT,regs);
; 354  :     }
; 355  : #endif /*FEATURE_ECPSVM*/
; 356  : #endif /*FEATURE_INTERVAL_TIMER*/
; 357  : 
; 358  :     /* External interrupt if service signal is pending */
; 359  :     if ( OPEN_IC_SERVSIG(regs) && !SIE_MODE(regs) )

  00a7b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a83	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00a8e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00a91	23 c1		 and	 eax, ecx
  00a93	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a98	85 c0		 test	 eax, eax
  00a9a	0f 84 6d 08 00
	00		 je	 $LN74@s390_perfo
  00aa0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00aae	d1 e8		 shr	 eax, 1
  00ab0	83 e0 01	 and	 eax, 1
  00ab3	85 c0		 test	 eax, eax
  00ab5	0f 85 52 08 00
	00		 jne	 $LN74@s390_perfo

; 360  :     {
; 361  : 
; 362  : #if defined(FEATURE_VM_BLOCKIO)
; 363  : 
; 364  :         /* Note: Both Block I/O and Service Signal are enabled by the */
; 365  :         /* the same CR0 bit.  Hence they are handled in the same code */
; 366  :         switch(sysblk.servcode)

  00abb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ac2	0f b7 80 68 12
	00 00		 movzx	 eax, WORD PTR [rax+4712]
  00ac9	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv443[rsp], eax
  00ad0	81 bc 24 98 00
	00 00 01 24 00
	00		 cmp	 DWORD PTR tv443[rsp], 9217 ; 00002401H
  00adb	0f 84 73 04 00
	00		 je	 $LN84@s390_perfo
  00ae1	81 bc 24 98 00
	00 00 03 26 00
	00		 cmp	 DWORD PTR tv443[rsp], 9731 ; 00002603H
  00aec	74 05		 je	 SHORT $LN75@s390_perfo
  00aee	e9 61 04 00 00	 jmp	 $LN85@s390_perfo
$LN75@s390_perfo:

; 367  :         {
; 368  :         case EXT_BLOCKIO_INTERRUPT:  /* VM Block I/O Interrupt */
; 369  : 
; 370  :             if (sysblk.biodev->ccwtrace)

  00af3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00afa	48 8b 80 78 12
	00 00		 mov	 rax, QWORD PTR [rax+4728]
  00b01	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b07	c1 e8 0f	 shr	 eax, 15
  00b0a	83 e0 01	 and	 eax, 1
  00b0d	85 c0		 test	 eax, eax
  00b0f	0f 84 a3 01 00
	00		 je	 $LN76@s390_perfo

; 371  :             {
; 372  :                 if (regs->insttrace && sysblk.traceFILE)

  00b15	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b1d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b23	c1 e8 0f	 shr	 eax, 15
  00b26	83 e0 01	 and	 eax, 1
  00b29	85 c0		 test	 eax, eax
  00b2b	74 24		 je	 SHORT $LN77@s390_perfo
  00b2d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b34	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b3c	74 13		 je	 SHORT $LN77@s390_perfo

; 373  :                     tf_0844( regs );

  00b3e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0844
  00b4c	e9 67 01 00 00	 jmp	 $LN78@s390_perfo
$LN77@s390_perfo:

; 374  :                 else
; 375  :                     // "Processor %s%02X: %1d:%04X: processing block I/O interrupt:
; 376  :                     //     code %4.4X parm %16.16"PRIX64" status %2.2X subcode %2.2X"
; 377  :                     WRMSG( HHC00844, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  00b51	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b58	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00b5f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv457[rsp], eax
  00b66	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b6d	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  00b74	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv460[rsp], ecx
  00b7b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b82	0f b7 92 68 12
	00 00		 movzx	 edx, WORD PTR [rdx+4712]
  00b89	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv465[rsp], edx
  00b90	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00b97	4d 8b 80 78 12
	00 00		 mov	 r8, QWORD PTR [r8+4728]
  00b9e	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  00ba3	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv469[rsp], r8d
  00bab	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  00bb2	4d 8b 89 78 12
	00 00		 mov	 r9, QWORD PTR [r9+4728]
  00bb9	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  00bbe	41 d1 f9	 sar	 r9d, 1
  00bc1	44 89 8c 24 cc
	00 00 00	 mov	 DWORD PTR tv474[rsp], r9d
  00bc9	4c 8b 94 24 60
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  00bd1	45 0f b7 92 3c
	08 00 00	 movzx	 r10d, WORD PTR [r10+2108]
  00bd9	44 89 94 24 d0
	00 00 00	 mov	 DWORD PTR tv477[rsp], r10d
  00be1	4c 8b 9c 24 60
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00be9	45 0f b7 9b 3c
	08 00 00	 movzx	 r11d, WORD PTR [r11+2108]
  00bf1	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR __imp_sysblk
  00bf8	42 0f b6 8c 1b
	48 0b 00 00	 movzx	 ecx, BYTE PTR [rbx+r11+2888]
  00c01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00c07	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv479[rsp], rax
  00c0f	b9 01 00 00 00	 mov	 ecx, 1
  00c14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c1a	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv457[rsp]
  00c21	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00c25	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv460[rsp]
  00c2c	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00c30	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c37	48 8b 89 70 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4720]
  00c3e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00c43	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv465[rsp]
  00c4a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00c4e	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv469[rsp]
  00c55	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00c59	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv474[rsp]
  00c60	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00c64	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv477[rsp]
  00c6b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c6f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv479[rsp]
  00c77	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179974
  00c83	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179975
  00c8f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c94	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c99	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c9f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179976
  00ca6	ba 80 01 00 00	 mov	 edx, 384		; 00000180H
  00cab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179977
  00cb2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN78@s390_perfo:
$LN76@s390_perfo:

; 378  :                         SSID_TO_LCSS(sysblk.biodev->ssid),
; 379  :                         sysblk.biodev->devnum,
; 380  :                         sysblk.servcode,
; 381  :                         sysblk.bioparm,
; 382  :                         sysblk.biostat,
; 383  :                         sysblk.biosubcd
; 384  :                     );
; 385  :             }
; 386  : 
; 387  :             servcode = EXT_BLOCKIO_INTERRUPT;

  00cb8	b8 03 26 00 00	 mov	 eax, 9731		; 00002603H
  00cbd	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 388  : 
; 389  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 390  : /* Real address used to store the 64-bit interrupt parameter */
; 391  : #define VM_BLOCKIO_INT_PARM   0x11B8
; 392  :             if (sysblk.biosubcd == 0x07)
; 393  :             {
; 394  :                 /* 8-byte interrupt parm */
; 395  :                 if (1
; 396  :                     && CPU_STEPPING_OR_TRACING_ALL
; 397  :                     && !TXF_INSTR_TRACING()
; 398  :                 )
; 399  :                 {
; 400  :                     if (regs->insttrace && sysblk.traceFILE)
; 401  :                         tf_0845( regs );
; 402  :                     else
; 403  :                     {
; 404  :                         char buf[40];
; 405  :                         MSGBUF( buf, "%16.16X", (unsigned) sysblk.bioparm );
; 406  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 407  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );
; 408  :                     }
; 409  :                 }
; 410  : 
; 411  :                 /* Set the main storage reference and change bits   */
; 412  :                 /* for 64-bit interruption parameter.               */
; 413  :                 /* Note: This is handled for the first 4K page in   */
; 414  :                 /* ARCH_DEP(external_interrupt), but not for the    */
; 415  :                 /* the second 4K page used for the 64-bit interrupt */
; 416  :                 /* parameter.                                       */
; 417  : 
; 418  :                 /* Point to 2nd page of PSA in main storage */
; 419  :                 servpadr=APPLY_PREFIXING(VM_BLOCKIO_INT_PARM,regs->PX);
; 420  : 
; 421  :                 ARCH_DEP( or_storage_key )( servpadr, (STORKEY_REF | STORKEY_CHANGE) );
; 422  : #if 0
; 423  :                 /* Store the 64-bit interrupt parameter */
; 424  :                 LOGMSG( "Saving 64-bit Block I/O interrupt parm at "
; 425  :                     "%16.16X: %16.16X\n",
; 426  :                     servpadr,
; 427  :                     sysblk.bioparm
; 428  :                 );
; 429  : #endif
; 430  :                 STORE_DW(regs->mainstor + servpadr,sysblk.bioparm);
; 431  :                 psa = (void*)(regs->mainstor + regs->PX);
; 432  :             }
; 433  :             else
; 434  : #endif  /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 435  :             {
; 436  :                 /* 4-byte interrupt parm */
; 437  :                 if (1
; 438  :                     && CPU_STEPPING_OR_TRACING_ALL
; 439  :                     && !TXF_INSTR_TRACING()

  00cc5	33 c0		 xor	 eax, eax
  00cc7	83 f8 01	 cmp	 eax, 1
  00cca	0f 84 c7 01 00
	00		 je	 $LN79@s390_perfo
  00cd0	b8 08 00 00 00	 mov	 eax, 8
  00cd5	48 6b c0 00	 imul	 rax, rax, 0
  00cd9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ce0	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00ce9	75 32		 jne	 SHORT $LN81@s390_perfo
  00ceb	b8 08 00 00 00	 mov	 eax, 8
  00cf0	48 6b c0 01	 imul	 rax, rax, 1
  00cf4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00cfb	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00d04	75 17		 jne	 SHORT $LN81@s390_perfo
  00d06	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d0d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00d13	c1 e8 0a	 shr	 eax, 10
  00d16	83 e0 01	 and	 eax, 1
  00d19	85 c0		 test	 eax, eax
  00d1b	75 4e		 jne	 SHORT $LN80@s390_perfo
$LN81@s390_perfo:
  00d1d	b8 08 00 00 00	 mov	 eax, 8
  00d22	48 6b c0 00	 imul	 rax, rax, 0
  00d26	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d2d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00d36	0f 85 5b 01 00
	00		 jne	 $LN79@s390_perfo
  00d3c	b8 08 00 00 00	 mov	 eax, 8
  00d41	48 6b c0 01	 imul	 rax, rax, 1
  00d45	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d4c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00d55	0f 85 3c 01 00
	00		 jne	 $LN79@s390_perfo
  00d5b	e8 00 00 00 00	 call	 insttrace_all
  00d60	0f b6 c0	 movzx	 eax, al
  00d63	85 c0		 test	 eax, eax
  00d65	0f 84 2c 01 00
	00		 je	 $LN79@s390_perfo
$LN80@s390_perfo:
  00d6b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d72	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00d78	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00d7d	85 c0		 test	 eax, eax
  00d7f	0f 85 12 01 00
	00		 jne	 $LN79@s390_perfo

; 440  :                 )
; 441  :                 {
; 442  :                     if (regs->insttrace && sysblk.traceFILE)

  00d85	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d8d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00d93	c1 e8 0f	 shr	 eax, 15
  00d96	83 e0 01	 and	 eax, 1
  00d99	85 c0		 test	 eax, eax
  00d9b	74 24		 je	 SHORT $LN82@s390_perfo
  00d9d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00da4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00dac	74 13		 je	 SHORT $LN82@s390_perfo

; 443  :                         tf_0845( regs );

  00dae	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00db6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0845
  00dbc	e9 d6 00 00 00	 jmp	 $LN83@s390_perfo
$LN82@s390_perfo:

; 444  :                     else
; 445  :                     {
; 446  :                         char buf[40];
; 447  :                         MSGBUF( buf, "%8.8X", (U32) sysblk.bioparm );

  00dc1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dc8	44 8b 88 70 12
	00 00		 mov	 r9d, DWORD PTR [rax+4720]
  00dcf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179983
  00dd6	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00ddb	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00de3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 448  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 449  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  00de9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df1	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00df8	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv537[rsp], eax
  00dff	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e07	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00e0e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e15	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00e1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e23	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv539[rsp], rax
  00e2b	b9 01 00 00 00	 mov	 ecx, 1
  00e30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e36	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00e3e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e43	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv537[rsp]
  00e4a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e4e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv539[rsp]
  00e56	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179984
  00e62	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179985
  00e6e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e73	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e78	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e7e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179986
  00e85	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  00e8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179987
  00e91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN83@s390_perfo:
$LN79@s390_perfo:

; 450  :                     }
; 451  :                 }
; 452  : 
; 453  :                 /* Store Block I/O parameter at PSA+X'80' */
; 454  :                 psa = (void*)(regs->mainstor + regs->PX);

  00e97	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e9f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00ea2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eaa	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00eb1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 455  :                 STORE_FW(psa->extparm,(U32)sysblk.bioparm);

  00eb9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ec0	8b 88 70 12 00
	00		 mov	 ecx, DWORD PTR [rax+4720]
  00ec6	e8 00 00 00 00	 call	 _byteswap_ulong
  00ecb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00ed3	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  00eda	8b d0		 mov	 edx, eax
  00edc	e8 00 00 00 00	 call	 store_fw_noswap

; 456  :             }
; 457  : 
; 458  :             /* Store sub-interruption code and status at PSA+X'84' */
; 459  :             STORE_HW(psa->extcpad,(sysblk.biosubcd<<8)|sysblk.biostat);

  00ee1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ee8	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00eef	c1 e0 08	 shl	 eax, 8
  00ef2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ef9	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  00f00	0b c1		 or	 eax, ecx
  00f02	0f b7 c8	 movzx	 ecx, ax
  00f05	e8 00 00 00 00	 call	 _byteswap_ushort
  00f0a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00f12	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00f19	0f b7 d0	 movzx	 edx, ax
  00f1c	e8 00 00 00 00	 call	 store_hw_noswap

; 460  : 
; 461  :             /* Reset interruption data */
; 462  :             sysblk.bioparm  = 0;

  00f21	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f28	48 c7 80 70 12
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4720], 0

; 463  :             sysblk.biosubcd = 0;

  00f33	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f3a	c6 80 6a 12 00
	00 00		 mov	 BYTE PTR [rax+4714], 0

; 464  :             sysblk.biostat  = 0;

  00f41	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f48	c6 80 6b 12 00
	00 00		 mov	 BYTE PTR [rax+4715], 0

; 465  : 
; 466  :             break;

  00f4f	e9 a3 02 00 00	 jmp	 $LN39@s390_perfo
$LN84@s390_perfo:
$LN85@s390_perfo:

; 467  : 
; 468  :         case EXT_SERVICE_SIGNAL_INTERRUPT: /* Service Signal */
; 469  :         default:
; 470  :             servcode = EXT_SERVICE_SIGNAL_INTERRUPT;

  00f54	b8 01 24 00 00	 mov	 eax, 9217		; 00002401H
  00f59	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 471  : 
; 472  :             /* Apply prefixing if the parameter is a storage address */
; 473  :             if ( (sysblk.servparm & SERVSIG_ADDR) )

  00f61	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f68	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00f6e	83 e0 f8	 and	 eax, -8			; fffffff8H
  00f71	85 c0		 test	 eax, eax
  00f73	0f 84 86 00 00
	00		 je	 $LN86@s390_perfo

; 474  :                 sysblk.servparm =

  00f79	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f80	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00f86	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00f8c	48 85 c0	 test	 rax, rax
  00f8f	74 39		 je	 SHORT $LN95@s390_perfo
  00f91	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f98	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00f9e	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00fa4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fac	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00faf	48 3b c1	 cmp	 rax, rcx
  00fb2	74 16		 je	 SHORT $LN95@s390_perfo
  00fb4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fbb	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00fc1	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv599[rsp], eax
  00fc8	eb 21		 jmp	 SHORT $LN96@s390_perfo
$LN95@s390_perfo:
  00fca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fd1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd9	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00fdc	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00fe2	33 c1		 xor	 eax, ecx
  00fe4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv599[rsp], eax
$LN96@s390_perfo:
  00feb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ff2	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv599[rsp]
  00ff9	89 88 90 12 00
	00		 mov	 DWORD PTR [rax+4752], ecx
$LN86@s390_perfo:

; 475  :                      APPLY_PREFIXING (sysblk.servparm, regs->PX);
; 476  : 
; 477  :             if (1
; 478  :                 && CPU_STEPPING_OR_TRACING_ALL
; 479  :                 && !TXF_INSTR_TRACING()

  00fff	33 c0		 xor	 eax, eax
  01001	83 f8 01	 cmp	 eax, 1
  01004	0f 84 a3 01 00
	00		 je	 $LN87@s390_perfo
  0100a	b8 08 00 00 00	 mov	 eax, 8
  0100f	48 6b c0 00	 imul	 rax, rax, 0
  01013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0101a	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  01023	75 32		 jne	 SHORT $LN89@s390_perfo
  01025	b8 08 00 00 00	 mov	 eax, 8
  0102a	48 6b c0 01	 imul	 rax, rax, 1
  0102e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01035	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0103e	75 17		 jne	 SHORT $LN89@s390_perfo
  01040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01047	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0104d	c1 e8 0a	 shr	 eax, 10
  01050	83 e0 01	 and	 eax, 1
  01053	85 c0		 test	 eax, eax
  01055	75 4e		 jne	 SHORT $LN88@s390_perfo
$LN89@s390_perfo:
  01057	b8 08 00 00 00	 mov	 eax, 8
  0105c	48 6b c0 00	 imul	 rax, rax, 0
  01060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01067	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  01070	0f 85 37 01 00
	00		 jne	 $LN87@s390_perfo
  01076	b8 08 00 00 00	 mov	 eax, 8
  0107b	48 6b c0 01	 imul	 rax, rax, 1
  0107f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01086	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0108f	0f 85 18 01 00
	00		 jne	 $LN87@s390_perfo
  01095	e8 00 00 00 00	 call	 insttrace_all
  0109a	0f b6 c0	 movzx	 eax, al
  0109d	85 c0		 test	 eax, eax
  0109f	0f 84 08 01 00
	00		 je	 $LN87@s390_perfo
$LN88@s390_perfo:
  010a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010ac	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010b2	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  010b7	85 c0		 test	 eax, eax
  010b9	0f 85 ee 00 00
	00		 jne	 $LN87@s390_perfo

; 480  :             )
; 481  :             {
; 482  :                 if (regs->insttrace && sysblk.traceFILE)

  010bf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010c7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  010cd	c1 e8 0f	 shr	 eax, 15
  010d0	83 e0 01	 and	 eax, 1
  010d3	85 c0		 test	 eax, eax
  010d5	74 24		 je	 SHORT $LN90@s390_perfo
  010d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010de	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  010e6	74 13		 je	 SHORT $LN90@s390_perfo

; 483  :                     tf_0846( regs );

  010e8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0846
  010f6	e9 b2 00 00 00	 jmp	 $LN91@s390_perfo
$LN90@s390_perfo:

; 484  :                 else
; 485  :                     // "Processor %s%02X: External interrupt: service signal %8.8X"
; 486  :                     WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );

  010fb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01103	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0110a	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv637[rsp], eax
  01111	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01119	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01120	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01127	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0112f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01135	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv639[rsp], rax
  0113d	b9 01 00 00 00	 mov	 ecx, 1
  01142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0114f	8b 89 90 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4752]
  01155	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01159	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv637[rsp]
  01160	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01164	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv639[rsp]
  0116c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179996
  01178	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0117d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179997
  01184	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01189	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0118e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01194	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179998
  0119b	ba e6 01 00 00	 mov	 edx, 486		; 000001e6H
  011a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179999
  011a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN91@s390_perfo:
$LN87@s390_perfo:

; 487  :             }
; 488  : 
; 489  :             /* Store service signal parameter at PSA+X'80' */
; 490  :             psa = (void*)(regs->mainstor + regs->PX);

  011ad	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  011b8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011c0	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  011c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 491  :             STORE_FW(psa->extparm,sysblk.servparm);

  011cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011d6	8b 88 90 12 00
	00		 mov	 ecx, DWORD PTR [rax+4752]
  011dc	e8 00 00 00 00	 call	 _byteswap_ulong
  011e1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  011e9	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  011f0	8b d0		 mov	 edx, eax
  011f2	e8 00 00 00 00	 call	 store_fw_noswap
$LN39@s390_perfo:

; 492  : 
; 493  :         }  /* end switch(sysblk.servcode) */
; 494  :         /* Reset service parameter */
; 495  :         sysblk.servparm = 0;

  011f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011fe	c7 80 90 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4752], 0

; 496  : 
; 497  :         /* Reset service code */
; 498  :         sysblk.servcode = 0;

  01208	33 c0		 xor	 eax, eax
  0120a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01211	66 89 81 68 12
	00 00		 mov	 WORD PTR [rcx+4712], ax
$LN43@s390_perfo:

; 499  : 
; 500  :         /* Reset service signal pending */
; 501  :         OFF_IC_SERVSIG;

  01218	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0121f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01225	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0122a	85 c0		 test	 eax, eax
  0122c	0f 84 ba 00 00
	00		 je	 $LN92@s390_perfo
  01232	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01239	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0123f	0f ba f0 09	 btr	 eax, 9
  01243	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0124a	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  01250	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01257	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0125e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  01266	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$2[rsp], 0
  01271	eb 10		 jmp	 SHORT $LN46@s390_perfo
$LN44@s390_perfo:
  01273	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  0127a	ff c0		 inc	 eax
  0127c	89 84 24 94 00
	00 00		 mov	 DWORD PTR i$2[rsp], eax
$LN46@s390_perfo:
  01283	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR mask$4[rsp], 0
  0128c	74 5e		 je	 SHORT $LN45@s390_perfo
  0128e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  01296	48 83 e0 01	 and	 rax, 1
  0129a	48 85 c0	 test	 rax, rax
  0129d	74 38		 je	 SHORT $LN93@s390_perfo
  0129f	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR i$2[rsp]
  012a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012ae	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  012b6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  012b9	0f ba f0 09	 btr	 eax, 9
  012bd	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR i$2[rsp]
  012c5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  012cc	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  012d4	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN93@s390_perfo:
  012d7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  012df	48 d1 e8	 shr	 rax, 1
  012e2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  012ea	eb 87		 jmp	 SHORT $LN44@s390_perfo
$LN45@s390_perfo:
$LN92@s390_perfo:
  012ec	33 c0		 xor	 eax, eax
  012ee	85 c0		 test	 eax, eax
  012f0	0f 85 22 ff ff
	ff		 jne	 $LN43@s390_perfo

; 502  : 
; 503  :         /* Generate service signal interrupt */
; 504  :         ARCH_DEP(external_interrupt) (servcode, regs);

  012f6	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR servcode$[rsp]
  012fe	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01306	8b c8		 mov	 ecx, eax
  01308	e8 00 00 00 00	 call	 s390_external_interrupt
$LN74@s390_perfo:
$LN1@s390_perfo:

; 505  : 
; 506  : #else /* defined(FEATURE_VM_BLOCKIO) */
; 507  : 
; 508  :         /* Apply prefixing if the parameter is a storage address */
; 509  :         if (sysblk.servparm & SERVSIG_ADDR)
; 510  :             sysblk.servparm = APPLY_PREFIXING( sysblk.servparm, regs->PX );
; 511  : 
; 512  :         if (1
; 513  :             && CPU_STEPPING_OR_TRACING_ALL
; 514  :             && !TXF_INSTR_TRACING()
; 515  :         )
; 516  :         {
; 517  :             if (regs->insttrace && sysblk.traceFILE)
; 518  :                 tf_0846( regs );
; 519  :             else
; 520  :                 // "Processor %s%02X: External interrupt: service signal %8.8X"
; 521  :                 WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );
; 522  :         }
; 523  : 
; 524  :         /* Store service signal parameter at PSA+X'80' */
; 525  :         psa = (void*)(regs->mainstor + regs->PX);
; 526  :         STORE_FW(psa->extparm,sysblk.servparm);
; 527  : 
; 528  :         /* Reset service parameter */
; 529  :         sysblk.servparm = 0;
; 530  : 
; 531  :         /* Reset service signal pending */
; 532  :         OFF_IC_SERVSIG;
; 533  : 
; 534  :         /* Generate service signal interrupt */
; 535  :         ARCH_DEP(external_interrupt) (EXT_SERVICE_SIGNAL_INTERRUPT, regs);
; 536  : 
; 537  : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 538  : 
; 539  :     }  /* end OPEN_IC_SERVSIG(regs) */
; 540  : 
; 541  : } /* end function perform_external_interrupt */

  0130d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01315	48 33 cc	 xor	 rcx, rsp
  01318	e8 00 00 00 00	 call	 __security_check_cookie
  0131d	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  01324	5b		 pop	 rbx
  01325	c3		 ret	 0
s390_perform_external_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
rc$ = 64
psa$ = 72
pfx$ = 80
code$ = 112
regs$ = 120
s370_external_interrupt PROC

; 43   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@s370_exter:

; 44   : RADR    pfx;
; 45   : PSA     *psa;
; 46   : int     rc;
; 47   : 
; 48   :     PTT_SIG("*EXTINT",code,regs->cpuad,regs->psw.IA_L);

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 4e		 je	 SHORT $LN8@s370_exter
  00022	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00039	48 63 54 24 70	 movsxd	 rdx, DWORD PTR code$[rsp]
  0003e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00047	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169561
  00053	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00058	44 8b c9	 mov	 r9d, ecx
  0005b	4c 8b c2	 mov	 r8, rdx
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169562
  00065	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN8@s370_exter:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 97		 jne	 SHORT $LN4@s370_exter

; 49   : 
; 50   : #if defined(_FEATURE_SIE)
; 51   :     /* Set the main storage reference and change bits */
; 52   :     if(SIE_MODE(regs)
; 53   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 54   :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 55   : #endif
; 56   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 57   :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00081	d1 e8		 shr	 eax, 1
  00083	83 e0 01	 and	 eax, 1
  00086	85 c0		 test	 eax, eax
  00088	74 7b		 je	 SHORT $LN9@s370_exter
  0008a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00096	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009a	83 e0 02	 and	 eax, 2
  0009d	85 c0		 test	 eax, eax
  0009f	75 64		 jne	 SHORT $LN9@s370_exter
  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 00	 imul	 rcx, rcx, 0
  000b6	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  000bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000c0	85 c0		 test	 eax, eax
  000c2	75 41		 jne	 SHORT $LN9@s370_exter

; 58   : #endif
; 59   :                                                             )
; 60   :     {
; 61   :         /* Point to SIE copy of PSA in state descriptor */
; 62   :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  000c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  000e3	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  000e8	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 63   :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  000ed	b2 06		 mov	 dl, 6
  000ef	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  000fb	e8 00 00 00 00	 call	 s370_or_storage_key

; 64   :     }

  00100	e9 b4 00 00 00	 jmp	 $LN10@s370_exter
$LN9@s370_exter:

; 65   :     else
; 66   : #endif /*defined(_FEATURE_SIE)*/
; 67   :     {
; 68   :         /* Point to PSA in main storage */
; 69   :         pfx = regs->PX;

  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0010d	48 89 44 24 50	 mov	 QWORD PTR pfx$[rsp], rax
$LN7@s370_exter:

; 70   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 71   :         SIE_TRANSLATE(&pfx, ACCTYPE_SIE, regs);

  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011d	d1 e8		 shr	 eax, 1
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	74 67		 je	 SHORT $LN11@s370_exter
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00131	c1 e8 02	 shr	 eax, 2
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	75 52		 jne	 SHORT $LN11@s370_exter
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00147	48 03 44 24 50	 add	 rax, QWORD PTR pfx$[rsp]
  0014c	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00155	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0015a	45 33 c9	 xor	 r9d, r9d
  0015d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00169	ba fd ff ff ff	 mov	 edx, -3
  0016e	8b c8		 mov	 ecx, eax
  00170	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00175	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00181	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00188	48 89 44 24 50	 mov	 QWORD PTR pfx$[rsp], rax
$LN11@s370_exter:
  0018d	33 c0		 xor	 eax, eax
  0018f	85 c0		 test	 eax, eax
  00191	0f 85 7b ff ff
	ff		 jne	 $LN7@s370_exter

; 72   : #endif /*defined(_FEATURE_EXPEDITED_SIE_SUBSET)*/
; 73   :         psa = (void*)(regs->mainstor + pfx);

  00197	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001a3	48 03 44 24 50	 add	 rax, QWORD PTR pfx$[rsp]
  001a8	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 74   :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  001ad	b2 06		 mov	 dl, 6
  001af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pfx$[rsp]
  001b4	e8 00 00 00 00	 call	 s370_or_storage_key
$LN10@s370_exter:

; 75   :     }
; 76   : 
; 77   :     /* Store the interrupt code in the PSW */
; 78   :     regs->psw.intcode = code;

  001b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  001c3	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 79   : 
; 80   : 
; 81   :     /* Zero extcpuad field unless extcall or ems signal or blockio */
; 82   :     if(code != EXT_EXTERNAL_CALL_INTERRUPT
; 83   : #if defined(FEATURE_VM_BLOCKIO)
; 84   :     && code != EXT_BLOCKIO_INTERRUPT
; 85   : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 86   :     && code != EXT_EMERGENCY_SIGNAL_INTERRUPT)

  001ca	81 7c 24 70 02
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4610 ; 00001202H
  001d2	74 2f		 je	 SHORT $LN12@s370_exter
  001d4	81 7c 24 70 03
	26 00 00	 cmp	 DWORD PTR code$[rsp], 9731 ; 00002603H
  001dc	74 25		 je	 SHORT $LN12@s370_exter
  001de	81 7c 24 70 01
	12 00 00	 cmp	 DWORD PTR code$[rsp], 4609 ; 00001201H
  001e6	74 1b		 je	 SHORT $LN12@s370_exter

; 87   :         STORE_HW(psa->extcpad,0);

  001e8	33 c9		 xor	 ecx, ecx
  001ea	e8 00 00 00 00	 call	 _byteswap_ushort
  001ef	48 8b 4c 24 48	 mov	 rcx, QWORD PTR psa$[rsp]
  001f4	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  001fb	0f b7 d0	 movzx	 edx, ax
  001fe	e8 00 00 00 00	 call	 store_hw_noswap
$LN12@s370_exter:

; 88   : 
; 89   : #if defined(FEATURE_BCMODE)
; 90   :     /* For ECMODE, store external interrupt code at PSA+X'86' */
; 91   :     if ( ECMODE(&regs->psw) )

  00203	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00208	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0020c	83 e0 08	 and	 eax, 8
  0020f	85 c0		 test	 eax, eax
  00211	74 1e		 je	 SHORT $LN13@s370_exter

; 92   : #endif /*defined(FEATURE_BCMODE)*/
; 93   :         STORE_HW(psa->extint,code);

  00213	0f b7 4c 24 70	 movzx	 ecx, WORD PTR code$[rsp]
  00218	e8 00 00 00 00	 call	 _byteswap_ushort
  0021d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR psa$[rsp]
  00222	48 81 c1 86 00
	00 00		 add	 rcx, 134		; 00000086H
  00229	0f b7 d0	 movzx	 edx, ax
  0022c	e8 00 00 00 00	 call	 store_hw_noswap
$LN13@s370_exter:

; 94   : 
; 95   :     if ( !SIE_MODE(regs)
; 96   : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 97   :                        || SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 98   : #endif
; 99   : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 100  :                        || SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0023c	d1 e8		 shr	 eax, 1
  0023e	83 e0 01	 and	 eax, 1
  00241	85 c0		 test	 eax, eax
  00243	74 3a		 je	 SHORT $LN15@s370_exter
  00245	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00251	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00255	83 e0 02	 and	 eax, 2
  00258	85 c0		 test	 eax, eax
  0025a	75 23		 jne	 SHORT $LN15@s370_exter
  0025c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00261	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00268	b9 01 00 00 00	 mov	 ecx, 1
  0026d	48 6b c9 00	 imul	 rcx, rcx, 0
  00271	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00276	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0027b	85 c0		 test	 eax, eax
  0027d	74 56		 je	 SHORT $LN14@s370_exter
$LN15@s370_exter:

; 101  : #endif
; 102  :        )
; 103  :     {
; 104  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 105  :         /* Abort any active transaction and then return back to here
; 106  :            to continue with external interrupt processing */
; 107  :         if (regs->txf_tnd)
; 108  :         {
; 109  :             PTT_TXF( "*TXF EI", 0, 0, regs->txf_tnd );
; 110  :             regs->txf_why |= TXF_WHY_EXT_INT;
; 111  :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_EXT );
; 112  :         }
; 113  : #endif
; 114  :         /* Store current PSW at PSA+X'18' */
; 115  :         ARCH_DEP(store_psw) (regs, psa->extold);

  0027f	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  00284	48 83 c0 18	 add	 rax, 24
  00288	48 8b d0	 mov	 rdx, rax
  0028b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00290	e8 00 00 00 00	 call	 s370_store_psw

; 116  : 
; 117  :         /* Load new PSW from PSA+X'58' */
; 118  :         rc = ARCH_DEP(load_psw) (regs, psa->extnew);

  00295	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  0029a	48 83 c0 58	 add	 rax, 88			; 00000058H
  0029e	48 8b d0	 mov	 rdx, rax
  002a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a6	e8 00 00 00 00	 call	 s370_load_psw
  002ab	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 119  : 
; 120  :         if ( rc )

  002af	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  002b4	74 1f		 je	 SHORT $LN16@s370_exter

; 121  :         {
; 122  :             RELEASE_INTLOCK(regs);

  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169571
  002bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c2	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 123  :             ARCH_DEP(program_interrupt)(regs, rc);

  002c7	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  002cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d0	e8 00 00 00 00	 call	 s370_program_interrupt
$LN16@s370_exter:
$LN14@s370_exter:

; 124  :         }
; 125  :     }
; 126  : 
; 127  : #if defined(FEATURE_INTERVAL_TIMER)
; 128  :     /* Ensure the interval timer is uptodate */
; 129  :     ARCH_DEP( store_int_timer_locked )( regs );

  002d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002da	e8 00 00 00 00	 call	 s370_store_int_timer_locked

; 130  : #endif
; 131  :     RELEASE_INTLOCK(regs);

  002df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169572
  002e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 132  : 
; 133  : 
; 134  :     if ( SIE_MODE(regs)
; 135  : #if defined(_FEATURE_EXPEDITED_SIE_SUBSET)
; 136  :                        && !SIE_FEAT_BIT_ON(regs, S, EXP_TIMER)
; 137  : #endif
; 138  : #if defined(_FEATURE_EXTERNAL_INTERRUPT_ASSIST)
; 139  :                        && !SIE_FEAT_BIT_ON(regs, EC0, EXTA)

  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002fb	d1 e8		 shr	 eax, 1
  002fd	83 e0 01	 and	 eax, 1
  00300	85 c0		 test	 eax, eax
  00302	74 54		 je	 SHORT $LN17@s370_exter
  00304	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00309	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00310	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00314	83 e0 02	 and	 eax, 2
  00317	85 c0		 test	 eax, eax
  00319	75 3d		 jne	 SHORT $LN17@s370_exter
  0031b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00320	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00327	b9 01 00 00 00	 mov	 ecx, 1
  0032c	48 6b c9 00	 imul	 rcx, rcx, 0
  00330	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00335	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0033a	85 c0		 test	 eax, eax
  0033c	75 1a		 jne	 SHORT $LN17@s370_exter

; 140  : #endif
; 141  :        )
; 142  :         longjmp (regs->progjmp, SIE_INTERCEPT_EXT);

  0033e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00343	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00349	ba f4 ff ff ff	 mov	 edx, -12
  0034e	48 8b c8	 mov	 rcx, rax
  00351	e8 00 00 00 00	 call	 longjmp
  00356	eb 18		 jmp	 SHORT $LN18@s370_exter
$LN17@s370_exter:

; 143  :     else
; 144  :         longjmp (regs->progjmp, SIE_NO_INTERCEPT);

  00358	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0035d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00363	ba ff ff ff ff	 mov	 edx, -1
  00368	48 8b c8	 mov	 rcx, rax
  0036b	e8 00 00 00 00	 call	 longjmp
$LN18@s370_exter:
$LN19@s370_exter:

; 145  : 
; 146  : } /* end function external_interrupt */

  00370	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00374	c3		 ret	 0
s370_external_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
ssreg$ = 64
aaddr$ = 72
store_status PROC

; 658  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 659  :     switch(ssreg->arch_mode) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  00013	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  0001f	74 10		 je	 SHORT $LN7@store_stat
  00021	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00026	74 2a		 je	 SHORT $LN8@store_stat
  00028	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002d	74 44		 je	 SHORT $LN9@store_stat
  0002f	eb 53		 jmp	 SHORT $LN10@store_stat
$LN7@store_stat:

; 660  : #if defined(_370)
; 661  :         case ARCH_370_IDX:
; 662  :             aaddr &= 0x7FFFFFFF;

  00031	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  00036	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  0003c	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax

; 663  :             s370_store_status (ssreg, aaddr);

  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR aaddr$[rsp]
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0004b	e8 00 00 00 00	 call	 s370_store_status

; 664  :             break;

  00050	eb 49		 jmp	 SHORT $LN2@store_stat
$LN8@store_stat:

; 665  : #endif
; 666  : #if defined(_390)
; 667  :         case ARCH_390_IDX:
; 668  :             aaddr &= 0x7FFFFFFF;

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  00057	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  0005d	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax

; 669  :             s390_store_status (ssreg, aaddr);

  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR aaddr$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0006c	e8 00 00 00 00	 call	 s390_store_status

; 670  :             break;

  00071	eb 28		 jmp	 SHORT $LN2@store_stat
$LN9@store_stat:

; 671  : #endif
; 672  : #if defined(_900)
; 673  :         case ARCH_900_IDX:
; 674  :             z900_store_status (ssreg, aaddr);

  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR aaddr$[rsp]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0007d	e8 00 00 00 00	 call	 z900_store_status

; 675  :             break;

  00082	eb 17		 jmp	 SHORT $LN2@store_stat
$LN10@store_stat:
$LN6@store_stat:

; 676  : #endif
; 677  :         default: CRASH();

  00084	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00092	c6 00 00	 mov	 BYTE PTR [rax], 0
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 e9		 jne	 SHORT $LN6@store_stat
$LN2@store_stat:

; 678  :     }
; 679  : }

  0009b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009f	c3		 ret	 0
store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
i$ = 32
sspsa$ = 40
ssreg$ = 64
aaddr$ = 72
s370_store_status PROC

; 556  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 557  : int     i;                              /* Array subscript           */
; 558  : PSA     *sspsa;                         /* -> Store status area      */
; 559  : 
; 560  :     /* Set reference and change bits */
; 561  :     ARCH_DEP( or_storage_key )( aaddr, (STORKEY_REF | STORKEY_CHANGE) );

  0000e	b2 06		 mov	 dl, 6
  00010	48 8b 4c 24 48	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00015	e8 00 00 00 00	 call	 s370_or_storage_key

; 562  : 
; 563  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 564  : 
; 565  :     /* The ESAME PSA is two pages in size */
; 566  :     if(!aaddr)
; 567  :         ARCH_DEP( or_storage_key )( aaddr + 4096, (STORKEY_REF | STORKEY_CHANGE) );
; 568  : 
; 569  :     /* For store status at address, we must adjust the PSA offset */
; 570  :     /* ZZ THIS TEST IS NOT CONCLUSIVE */
; 571  :     if(aaddr != 0 && aaddr != ssreg->PX)
; 572  :         aaddr -= 512 + 4096 ;
; 573  : #endif
; 574  : 
; 575  :     aaddr &= 0x7FFFFE00;

  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR aaddr$[rsp]
  0001f	48 25 00 fe ff
	7f		 and	 rax, 2147483136		; 7ffffe00H
  00025	48 89 44 24 48	 mov	 QWORD PTR aaddr$[rsp], rax

; 576  : 
; 577  :     /* Point to the PSA into which status is to be stored */
; 578  :     sspsa = (void*)(ssreg->mainstor + aaddr);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  0002f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00036	48 03 44 24 48	 add	 rax, QWORD PTR aaddr$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR sspsa$[rsp], rax

; 579  : 
; 580  :     /* Store CPU timer in bytes 216-223 */
; 581  :     STORE_DW(sspsa->storeptmr, get_cpu_timer(ssreg));

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00045	e8 00 00 00 00	 call	 get_cpu_timer
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 _byteswap_uint64
  00052	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  00057	48 81 c1 d8 00
	00 00		 add	 rcx, 216		; 000000d8H
  0005e	48 8b d0	 mov	 rdx, rax
  00061	e8 00 00 00 00	 call	 store_dw_noswap

; 582  : 
; 583  :     /* Store clock comparator in bytes 224-231 */
; 584  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 585  :     STORE_DW( sspsa->storeclkc, ssreg->clkc );
; 586  : #else
; 587  :     STORE_DW( sspsa->storeclkc, ssreg->clkc << 8 );

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  0006b	48 8b 80 48 07
	00 00		 mov	 rax, QWORD PTR [rax+1864]
  00072	48 c1 e0 08	 shl	 rax, 8
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 _byteswap_uint64
  0007e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  00083	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  0008a	48 8b d0	 mov	 rdx, rax
  0008d	e8 00 00 00 00	 call	 store_dw_noswap

; 588  : #endif
; 589  : 
; 590  :     /* Store PSW in bytes 256-263 */
; 591  :     ARCH_DEP(store_psw) (ssreg, sspsa->storepsw);

  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  00097	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0009d	48 8b d0	 mov	 rdx, rax
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  000a5	e8 00 00 00 00	 call	 s370_store_psw

; 592  : 
; 593  :     /* Store prefix register in bytes 264-267 */
; 594  :     STORE_FW(sspsa->storepfx,ssreg->PX);

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR ssreg$[rsp]
  000af	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000b2	e8 00 00 00 00	 call	 _byteswap_ulong
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sspsa$[rsp]
  000bc	48 81 c1 08 01
	00 00		 add	 rcx, 264		; 00000108H
  000c3	8b d0		 mov	 edx, eax
  000c5	e8 00 00 00 00	 call	 store_fw_noswap

; 595  : 
; 596  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 597  :     /* Store Floating Point Control Register */
; 598  :     STORE_FW(sspsa->storefpc,ssreg->fpc);
; 599  : 
; 600  :     /* Store TOD Programable register */
; 601  :     STORE_FW(sspsa->storetpr,ssreg->todpr);
; 602  : #endif
; 603  : 
; 604  : #if defined( _900 )
; 605  :     /* Only store the arch mode indicator for a PSA type store status */
; 606  :     if (!aaddr)

  000ca	48 83 7c 24 48
	00		 cmp	 QWORD PTR aaddr$[rsp], 0
  000d0	75 0c		 jne	 SHORT $LN14@s370_store

; 607  :   #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 608  :         sspsa->arch = 1;
; 609  :   #else
; 610  :         sspsa->arch = 0;

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR sspsa$[rsp]
  000d7	c6 80 a3 00 00
	00 00		 mov	 BYTE PTR [rax+163], 0
$LN14@s370_store:

; 611  :   #endif
; 612  : #endif /* defined( _900 ) */
; 613  : 
; 614  :     /* Store access registers in bytes 288-351 */
; 615  :     for (i = 0; i < 16; i++)

  000de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e6	eb 0a		 jmp	 SHORT $LN4@s370_store
$LN2@s370_store:
  000e8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ec	ff c0		 inc	 eax
  000ee	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_store:
  000f2	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  000f7	7d 31		 jge	 SHORT $LN3@s370_store

; 616  :         STORE_FW(sspsa->storear[i],ssreg->AR(i));

  000f9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  00103	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  0010a	e8 00 00 00 00	 call	 _byteswap_ulong
  0010f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00114	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00119	48 8d 8c 8a 20
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+288]
  00121	8b d0		 mov	 edx, eax
  00123	e8 00 00 00 00	 call	 store_fw_noswap
  00128	eb be		 jmp	 SHORT $LN2@s370_store
$LN3@s370_store:

; 617  : 
; 618  :     /* Store floating-point registers in bytes 352-383 */
; 619  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 620  :     for (i = 0; i < 32; i++)
; 621  : #else
; 622  :     for (i = 0; i < 8; i++)

  0012a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00132	eb 0a		 jmp	 SHORT $LN7@s370_store
$LN5@s370_store:
  00134	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00138	ff c0		 inc	 eax
  0013a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_store:
  0013e	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00143	7d 31		 jge	 SHORT $LN6@s370_store

; 623  : #endif
; 624  :         STORE_FW(sspsa->storefpr[i],ssreg->fpr[i]);

  00145	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0014f	8b 8c 81 40 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+832]
  00156	e8 00 00 00 00	 call	 _byteswap_ulong
  0015b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00160	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00165	48 8d 8c 8a 60
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+352]
  0016d	8b d0		 mov	 edx, eax
  0016f	e8 00 00 00 00	 call	 store_fw_noswap
  00174	eb be		 jmp	 SHORT $LN5@s370_store
$LN6@s370_store:

; 625  : 
; 626  :     /* Store general-purpose registers in bytes 384-447 */
; 627  :     for (i = 0; i < 16; i++)

  00176	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0017e	eb 0a		 jmp	 SHORT $LN10@s370_store
$LN8@s370_store:
  00180	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00184	ff c0		 inc	 eax
  00186	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_store:
  0018a	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  0018f	7d 31		 jge	 SHORT $LN9@s370_store

; 628  :         STORE_W(sspsa->storegpr[i],ssreg->GR(i));

  00191	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  0019b	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001a2	e8 00 00 00 00	 call	 _byteswap_ulong
  001a7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ac	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  001b1	48 8d 8c 8a 80
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+384]
  001b9	8b d0		 mov	 edx, eax
  001bb	e8 00 00 00 00	 call	 store_fw_noswap
  001c0	eb be		 jmp	 SHORT $LN8@s370_store
$LN9@s370_store:

; 629  : 
; 630  :     /* Store control registers in bytes 448-511 */
; 631  :     for (i = 0; i < 16; i++)

  001c2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ca	eb 0a		 jmp	 SHORT $LN13@s370_store
$LN11@s370_store:
  001cc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_store:
  001d6	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001db	7d 34		 jge	 SHORT $LN12@s370_store

; 632  :         STORE_W(sspsa->storecr[i],ssreg->CR(i));

  001dd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e1	ff c0		 inc	 eax
  001e3	48 98		 cdqe
  001e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ssreg$[rsp]
  001ea	8b 8c c1 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+1536]
  001f1	e8 00 00 00 00	 call	 _byteswap_ulong
  001f6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fb	48 8b 54 24 28	 mov	 rdx, QWORD PTR sspsa$[rsp]
  00200	48 8d 8c 8a c0
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+448]
  00208	8b d0		 mov	 edx, eax
  0020a	e8 00 00 00 00	 call	 store_fw_noswap
  0020f	eb bb		 jmp	 SHORT $LN11@s370_store
$LN12@s370_store:

; 633  : 
; 634  :     /* Store Breaking-Event Address Register if BEAR-Enhancement */
; 635  : #if defined( FEATURE_193_BEAR_ENH_FACILITY )
; 636  :     if (FACILITY_ENABLED( 193_BEAR_ENH, ssreg ))
; 637  :         STORE_DW( sspsa->bear, ssreg->bear );
; 638  : #endif
; 639  : 
; 640  : } /* end function store_status */

  00211	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00215	c3		 ret	 0
s370_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\external.c
_TEXT	SEGMENT
cpuad$ = 128
servcode$ = 132
psa$ = 136
i$1 = 144
i$2 = 148
tv529 = 152
tv685 = 156
mask$3 = 160
mask$4 = 168
tv82 = 176
tv342 = 180
tv411 = 184
tv482 = 188
tv543 = 192
tv546 = 196
tv551 = 200
tv555 = 204
tv560 = 208
tv563 = 212
tv623 = 216
tv723 = 220
tv84 = 224
tv344 = 232
tv405 = 240
tv413 = 248
tv484 = 256
tv565 = 264
tv625 = 272
tv725 = 280
buf$5 = 288
__$ArrayPad$ = 328
regs$ = 352
s370_perform_external_interrupt PROC

; 165  : {

$LN111:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 166  : PSA    *psa;                            /* -> Prefixed storage area  */
; 167  : U16     cpuad;                          /* Originating CPU address   */
; 168  : #if defined( FEATURE_VM_BLOCKIO )
; 169  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 170  : RADR    servpadr;      /* Address of 64-bit block I/O interrupt */
; 171  : #endif
; 172  : U16     servcode;      /* Service Signal or Block I/O Interrupt code */
; 173  : #endif /* defined( FEATURE_VM_BLOCKIO ) */
; 174  : 
; 175  :     /* External interrupt if console interrupt key was depressed */
; 176  :     if ( OPEN_IC_INTKEY(regs) && !SIE_MODE(regs) )

  0001f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00032	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00035	23 c1		 and	 eax, ecx
  00037	83 e0 40	 and	 eax, 64			; 00000040H
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 e3 01 00
	00		 je	 $LN53@s370_perfo
  00042	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00050	d1 e8		 shr	 eax, 1
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	0f 85 c8 01 00
	00		 jne	 $LN53@s370_perfo

; 177  :     {
; 178  :         if (regs->insttrace && sysblk.traceFILE)

  0005d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0006b	c1 e8 0f	 shr	 eax, 15
  0006e	83 e0 01	 and	 eax, 1
  00071	85 c0		 test	 eax, eax
  00073	74 23		 je	 SHORT $LN54@s370_perfo
  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00084	74 12		 je	 SHORT $LN54@s370_perfo

; 179  :             tf_0840( regs, EXT_INTERRUPT_KEY_INTERRUPT );

  00086	66 ba 40 00	 mov	 dx, 64			; 00000040H
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
$LN54@s370_perfo:

; 180  : 
; 181  :         // "Processor %s%02X: External interrupt: interrupt key"
; 182  :         WRMSG( HHC00840, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  00098	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000a7	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000ae	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c4	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000d2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e5	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  000f8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  00104	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  00110	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169681
  00127	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@s370_perfo:

; 183  : 
; 184  :         /* Reset interrupt key pending */
; 185  :         OFF_IC_INTKEY;

  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00140	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00146	83 e0 40	 and	 eax, 64			; 00000040H
  00149	85 c0		 test	 eax, eax
  0014b	0f 84 b8 00 00
	00		 je	 $LN55@s370_perfo
  00151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00158	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0015e	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00168	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00175	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0017c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00184	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  0018f	eb 10		 jmp	 SHORT $LN7@s370_perfo
$LN5@s370_perfo:
  00191	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  00198	ff c0		 inc	 eax
  0019a	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN7@s370_perfo:
  001a1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR mask$3[rsp], 0
  001aa	74 5d		 je	 SHORT $LN6@s370_perfo
  001ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 37		 je	 SHORT $LN56@s370_perfo
  001bd	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  001c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001cc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d7	83 e0 bf	 and	 eax, -65		; ffffffbfH
  001da	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001e2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001f1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN56@s370_perfo:
  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  001fc	48 d1 e8	 shr	 rax, 1
  001ff	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00207	eb 88		 jmp	 SHORT $LN5@s370_perfo
$LN6@s370_perfo:
$LN55@s370_perfo:
  00209	33 c0		 xor	 eax, eax
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 26 ff ff
	ff		 jne	 $LN4@s370_perfo

; 186  : 
; 187  :         /* Generate interrupt key interrupt */
; 188  :         ARCH_DEP(external_interrupt) (EXT_INTERRUPT_KEY_INTERRUPT, regs);

  00213	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0021b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00220	e8 00 00 00 00	 call	 s370_external_interrupt
$LN53@s370_perfo:

; 189  :     }
; 190  : 
; 191  :     /* External interrupt if malfunction alert is pending */
; 192  :     if (OPEN_IC_MALFALT(regs))

  00225	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00235	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00238	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0023b	23 c1		 and	 eax, ecx
  0023d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00242	85 c0		 test	 eax, eax
  00244	0f 84 a7 01 00
	00		 je	 $LN57@s370_perfo

; 193  :     {
; 194  :         /* Find first CPU which generated a malfunction alert */
; 195  :         for (cpuad = 0; regs->malfcpu[cpuad] == 0; cpuad++)

  0024a	33 c0		 xor	 eax, eax
  0024c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00254	eb 13		 jmp	 SHORT $LN10@s370_perfo
$LN8@s370_perfo:
  00256	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0025e	66 ff c0	 inc	 ax
  00261	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN10@s370_perfo:
  00269	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00271	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00281	85 c0		 test	 eax, eax
  00283	75 3e		 jne	 SHORT $LN9@s370_perfo

; 196  :         {
; 197  :             if (cpuad >= sysblk.maxcpu)

  00285	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0028d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00294	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  0029a	7c 25		 jl	 SHORT $LN58@s370_perfo
$LN13@s370_perfo:

; 198  :             {
; 199  :                 OFF_IC_MALFALT(regs);

  0029c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002a7	0f ba f0 0f	 btr	 eax, 15
  002ab	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  002b6	33 c0		 xor	 eax, eax
  002b8	85 c0		 test	 eax, eax
  002ba	75 e0		 jne	 SHORT $LN13@s370_perfo

; 200  :                 return;

  002bc	e9 cc 12 00 00	 jmp	 $LN1@s370_perfo
$LN58@s370_perfo:

; 201  :             }
; 202  :         } /* end for(cpuad) */

  002c1	eb 93		 jmp	 SHORT $LN8@s370_perfo
$LN9@s370_perfo:

; 203  : 
; 204  : // /*debug*/ LOGMSG( "External interrupt: Malfuction Alert from CPU %d\n",
; 205  : // /*debug*/    cpuad );
; 206  : 
; 207  :         /* Reset the indicator for the CPU which was found */
; 208  :         regs->malfcpu[cpuad] = 0;

  002c3	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  002cb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	c6 84 01 00 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+256], 0

; 209  : 
; 210  :         /* Store originating CPU address at PSA+X'84' */
; 211  :         psa = (void*)(regs->mainstor + regs->PX);

  002db	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002e6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  002f5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 212  :         STORE_HW(psa->extcpad,cpuad);

  002fd	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00305	e8 00 00 00 00	 call	 _byteswap_ushort
  0030a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00312	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00319	0f b7 d0	 movzx	 edx, ax
  0031c	e8 00 00 00 00	 call	 store_hw_noswap
$LN16@s370_perfo:

; 213  : 
; 214  :         /* Reset emergency signal pending flag if there are
; 215  :            no other CPUs which generated emergency signal */
; 216  :         OFF_IC_MALFALT(regs);

  00321	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00329	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0032c	0f ba f0 0f	 btr	 eax, 15
  00330	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0033b	33 c0		 xor	 eax, eax
  0033d	85 c0		 test	 eax, eax
  0033f	75 e0		 jne	 SHORT $LN16@s370_perfo
$LN17@s370_perfo:

; 217  :         while (++cpuad < sysblk.maxcpu)

  00341	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00349	66 ff c0	 inc	 ax
  0034c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00354	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0035c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00363	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00369	7d 74		 jge	 SHORT $LN18@s370_perfo

; 218  :         {
; 219  :             if (regs->malfcpu[cpuad])

  0036b	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00373	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037b	0f b6 84 01 00
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+256]
  00383	85 c0		 test	 eax, eax
  00385	74 53		 je	 SHORT $LN59@s370_perfo
$LN21@s370_perfo:

; 220  :             {
; 221  :                 ON_IC_MALFALT(regs);

  00387	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00392	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00397	85 c0		 test	 eax, eax
  00399	74 1d		 je	 SHORT $LN60@s370_perfo
  0039b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a3	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003a6	0d 00 80 00 80	 or	 eax, -2147450880	; 80008000H
  003ab	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003b6	eb 1a		 jmp	 SHORT $LN61@s370_perfo
$LN60@s370_perfo:
  003b8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003c3	0f ba e8 0f	 bts	 eax, 15
  003c7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cf	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN61@s370_perfo:
  003d2	33 c0		 xor	 eax, eax
  003d4	85 c0		 test	 eax, eax
  003d6	75 af		 jne	 SHORT $LN21@s370_perfo

; 222  :                 break;

  003d8	eb 05		 jmp	 SHORT $LN18@s370_perfo
$LN59@s370_perfo:

; 223  :             }
; 224  :         } /* end while */

  003da	e9 62 ff ff ff	 jmp	 $LN17@s370_perfo
$LN18@s370_perfo:

; 225  : 
; 226  :         /* Generate emergency signal interrupt */
; 227  :         ARCH_DEP(external_interrupt) (EXT_MALFUNCTION_ALERT_INTERRUPT, regs);

  003df	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e7	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  003ec	e8 00 00 00 00	 call	 s370_external_interrupt
$LN57@s370_perfo:

; 228  :     }
; 229  : 
; 230  :     /* External interrupt if emergency signal is pending */
; 231  :     if (OPEN_IC_EMERSIG(regs))

  003f1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00401	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00404	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00407	23 c1		 and	 eax, ecx
  00409	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0040e	85 c0		 test	 eax, eax
  00410	0f 84 a7 01 00
	00		 je	 $LN62@s370_perfo

; 232  :     {
; 233  :         /* Find first CPU which generated an emergency signal */
; 234  :         for (cpuad = 0; regs->emercpu[cpuad] == 0; cpuad++)

  00416	33 c0		 xor	 eax, eax
  00418	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00420	eb 13		 jmp	 SHORT $LN24@s370_perfo
$LN22@s370_perfo:
  00422	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0042a	66 ff c0	 inc	 ax
  0042d	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
$LN24@s370_perfo:
  00435	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0043d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  0044d	85 c0		 test	 eax, eax
  0044f	75 3e		 jne	 SHORT $LN23@s370_perfo

; 235  :         {
; 236  :             if (cpuad >= sysblk.maxcpu)

  00451	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00459	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00460	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00466	7c 25		 jl	 SHORT $LN63@s370_perfo
$LN27@s370_perfo:

; 237  :             {
; 238  :                 OFF_IC_EMERSIG(regs);

  00468	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00470	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00473	0f ba f0 0e	 btr	 eax, 14
  00477	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00482	33 c0		 xor	 eax, eax
  00484	85 c0		 test	 eax, eax
  00486	75 e0		 jne	 SHORT $LN27@s370_perfo

; 239  :                 return;

  00488	e9 00 11 00 00	 jmp	 $LN1@s370_perfo
$LN63@s370_perfo:

; 240  :             }
; 241  :         } /* end for(cpuad) */

  0048d	eb 93		 jmp	 SHORT $LN22@s370_perfo
$LN23@s370_perfo:

; 242  : 
; 243  : // /*debug*/ LOGMSG( "External interrupt: Emergency Signal from CPU %d\n",
; 244  : // /*debug*/    cpuad );
; 245  : 
; 246  :         /* Reset the indicator for the CPU which was found */
; 247  :         regs->emercpu[cpuad] = 0;

  0048f	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00497	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049f	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0

; 248  : 
; 249  :         /* Store originating CPU address at PSA+X'84' */
; 250  :         psa = (void*)(regs->mainstor + regs->PX);

  004a7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004af	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004b2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ba	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  004c1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 251  :         STORE_HW(psa->extcpad,cpuad);

  004c9	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR cpuad$[rsp]
  004d1	e8 00 00 00 00	 call	 _byteswap_ushort
  004d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  004de	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  004e5	0f b7 d0	 movzx	 edx, ax
  004e8	e8 00 00 00 00	 call	 store_hw_noswap
$LN30@s370_perfo:

; 252  : 
; 253  :         /* Reset emergency signal pending flag if there are
; 254  :            no other CPUs which generated emergency signal */
; 255  :         OFF_IC_EMERSIG(regs);

  004ed	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004f8	0f ba f0 0e	 btr	 eax, 14
  004fc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00504	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00507	33 c0		 xor	 eax, eax
  00509	85 c0		 test	 eax, eax
  0050b	75 e0		 jne	 SHORT $LN30@s370_perfo
$LN31@s370_perfo:

; 256  :         while (++cpuad < sysblk.maxcpu)

  0050d	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00515	66 ff c0	 inc	 ax
  00518	66 89 84 24 80
	00 00 00	 mov	 WORD PTR cpuad$[rsp], ax
  00520	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  00528	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052f	3b 81 00 01 00
	00		 cmp	 eax, DWORD PTR [rcx+256]
  00535	7d 74		 jge	 SHORT $LN32@s370_perfo

; 257  :         {
; 258  :             if (regs->emercpu[cpuad])

  00537	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR cpuad$[rsp]
  0053f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00547	0f b6 84 01 80
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+384]
  0054f	85 c0		 test	 eax, eax
  00551	74 53		 je	 SHORT $LN64@s370_perfo
$LN35@s370_perfo:

; 259  :             {
; 260  :                 ON_IC_EMERSIG(regs);

  00553	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0055e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00563	85 c0		 test	 eax, eax
  00565	74 1d		 je	 SHORT $LN65@s370_perfo
  00567	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00572	0d 00 40 00 80	 or	 eax, -2147467264	; 80004000H
  00577	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00582	eb 1a		 jmp	 SHORT $LN66@s370_perfo
$LN65@s370_perfo:
  00584	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0058f	0f ba e8 0e	 bts	 eax, 14
  00593	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN66@s370_perfo:
  0059e	33 c0		 xor	 eax, eax
  005a0	85 c0		 test	 eax, eax
  005a2	75 af		 jne	 SHORT $LN35@s370_perfo

; 261  :                 break;

  005a4	eb 05		 jmp	 SHORT $LN32@s370_perfo
$LN64@s370_perfo:

; 262  :             }
; 263  :         } /* end while */

  005a6	e9 62 ff ff ff	 jmp	 $LN31@s370_perfo
$LN32@s370_perfo:

; 264  : 
; 265  :         /* Generate emergency signal interrupt */
; 266  :         ARCH_DEP(external_interrupt) (EXT_EMERGENCY_SIGNAL_INTERRUPT, regs);

  005ab	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b3	b9 01 12 00 00	 mov	 ecx, 4609		; 00001201H
  005b8	e8 00 00 00 00	 call	 s370_external_interrupt
$LN62@s370_perfo:

; 267  :     }
; 268  : 
; 269  :     /* External interrupt if external call is pending */
; 270  :     if (OPEN_IC_EXTCALL(regs))

  005bd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005cd	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  005d0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005d3	23 c1		 and	 eax, ecx
  005d5	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  005da	85 c0		 test	 eax, eax
  005dc	74 7c		 je	 SHORT $LN67@s370_perfo
$LN38@s370_perfo:

; 271  :     {
; 272  : //  /*debug*/ LOGMSG( "External interrupt: External Call from CPU %d\n",
; 273  : //  /*debug*/       regs->extccpu );
; 274  : 
; 275  :         /* Reset external call pending */
; 276  :         OFF_IC_EXTCALL(regs);

  005de	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005e9	0f ba f0 0d	 btr	 eax, 13
  005ed	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f5	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  005f8	33 c0		 xor	 eax, eax
  005fa	85 c0		 test	 eax, eax
  005fc	75 e0		 jne	 SHORT $LN38@s370_perfo

; 277  : 
; 278  :         /* Store originating CPU address at PSA+X'84' */
; 279  :         psa = (void*)(regs->mainstor + regs->PX);

  005fe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00606	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00609	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00611	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00618	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 280  :         STORE_HW(psa->extcpad,regs->extccpu);

  00620	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00628	0f b7 48 62	 movzx	 ecx, WORD PTR [rax+98]
  0062c	e8 00 00 00 00	 call	 _byteswap_ushort
  00631	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  00639	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  00640	0f b7 d0	 movzx	 edx, ax
  00643	e8 00 00 00 00	 call	 store_hw_noswap

; 281  : 
; 282  :         /* Generate external call interrupt */
; 283  :         ARCH_DEP(external_interrupt) (EXT_EXTERNAL_CALL_INTERRUPT, regs);

  00648	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00650	b9 02 12 00 00	 mov	 ecx, 4610		; 00001202H
  00655	e8 00 00 00 00	 call	 s370_external_interrupt
$LN67@s370_perfo:

; 284  :     }
; 285  : 
; 286  :     /* External interrupt if TOD clock exceeds clock comparator */
; 287  :     if (1
; 288  :         && get_tod_clock( regs ) > regs->clkc
; 289  :         && OPEN_IC_CLKC( regs )

  0065a	33 c0		 xor	 eax, eax
  0065c	83 f8 01	 cmp	 eax, 1
  0065f	0f 84 fa 01 00
	00		 je	 $LN68@s370_perfo
  00665	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066d	e8 00 00 00 00	 call	 get_tod_clock
  00672	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067a	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  00681	0f 86 d8 01 00
	00		 jbe	 $LN68@s370_perfo
  00687	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00697	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0069a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0069d	23 c1		 and	 eax, ecx
  0069f	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  006a4	85 c0		 test	 eax, eax
  006a6	0f 84 b3 01 00
	00		 je	 $LN68@s370_perfo

; 290  :     )
; 291  :     {
; 292  :         if (1
; 293  :             && CPU_STEPPING_OR_TRACING_ALL
; 294  :             && !TXF_INSTR_TRACING()

  006ac	33 c0		 xor	 eax, eax
  006ae	83 f8 01	 cmp	 eax, 1
  006b1	0f 84 96 01 00
	00		 je	 $LN69@s370_perfo
  006b7	b8 08 00 00 00	 mov	 eax, 8
  006bc	48 6b c0 00	 imul	 rax, rax, 0
  006c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006c7	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006d0	75 32		 jne	 SHORT $LN71@s370_perfo
  006d2	b8 08 00 00 00	 mov	 eax, 8
  006d7	48 6b c0 01	 imul	 rax, rax, 1
  006db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006e2	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  006eb	75 17		 jne	 SHORT $LN71@s370_perfo
  006ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f4	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006fa	c1 e8 0a	 shr	 eax, 10
  006fd	83 e0 01	 and	 eax, 1
  00700	85 c0		 test	 eax, eax
  00702	75 4e		 jne	 SHORT $LN70@s370_perfo
$LN71@s370_perfo:
  00704	b8 08 00 00 00	 mov	 eax, 8
  00709	48 6b c0 00	 imul	 rax, rax, 0
  0070d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00714	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0071d	0f 85 2a 01 00
	00		 jne	 $LN69@s370_perfo
  00723	b8 08 00 00 00	 mov	 eax, 8
  00728	48 6b c0 01	 imul	 rax, rax, 1
  0072c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00733	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0073c	0f 85 0b 01 00
	00		 jne	 $LN69@s370_perfo
  00742	e8 00 00 00 00	 call	 insttrace_all
  00747	0f b6 c0	 movzx	 eax, al
  0074a	85 c0		 test	 eax, eax
  0074c	0f 84 fb 00 00
	00		 je	 $LN69@s370_perfo
$LN70@s370_perfo:
  00752	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00759	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0075f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00764	85 c0		 test	 eax, eax
  00766	0f 85 e1 00 00
	00		 jne	 $LN69@s370_perfo

; 295  :         )
; 296  :         {
; 297  :             if (regs->insttrace && sysblk.traceFILE)

  0076c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00774	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0077a	c1 e8 0f	 shr	 eax, 15
  0077d	83 e0 01	 and	 eax, 1
  00780	85 c0		 test	 eax, eax
  00782	74 28		 je	 SHORT $LN72@s370_perfo
  00784	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00793	74 17		 je	 SHORT $LN72@s370_perfo

; 298  :                 tf_0840( regs, EXT_CLOCK_COMPARATOR_INTERRUPT );

  00795	66 ba 04 10	 mov	 dx, 4100		; 00001004H
  00799	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  007a7	e9 a1 00 00 00	 jmp	 $LN73@s370_perfo
$LN72@s370_perfo:

; 299  :             else
; 300  :                 // "Processor %s%02X: External interrupt: clock comparator"
; 301  :                 WRMSG( HHC00841, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  007ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b4	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007bb	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv342[rsp], eax
  007c2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ca	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  007d1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d8	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  007e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  007e6	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv344[rsp], rax
  007ee	b9 01 00 00 00	 mov	 ecx, 1
  007f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f9	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv342[rsp]
  00800	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00804	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv344[rsp]
  0080c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00811	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169702
  00818	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169703
  00824	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00829	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00834	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169704
  0083b	ba 2d 01 00 00	 mov	 edx, 301		; 0000012dH
  00840	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169705
  00847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN73@s370_perfo:
$LN69@s370_perfo:

; 302  :         }
; 303  :         ARCH_DEP( external_interrupt )( EXT_CLOCK_COMPARATOR_INTERRUPT, regs );

  0084d	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00855	b9 04 10 00 00	 mov	 ecx, 4100		; 00001004H
  0085a	e8 00 00 00 00	 call	 s370_external_interrupt
$LN68@s370_perfo:

; 304  :     }
; 305  : 
; 306  :     /* External interrupt if CPU timer is negative */
; 307  :     if (1
; 308  :         && CPU_TIMER( regs ) < 0
; 309  :         && OPEN_IC_PTIMER( regs )

  0085f	33 c0		 xor	 eax, eax
  00861	83 f8 01	 cmp	 eax, 1
  00864	0f 84 11 02 00
	00		 je	 $LN74@s370_perfo
  0086a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00872	e8 00 00 00 00	 call	 get_cpu_timer
  00877	48 85 c0	 test	 rax, rax
  0087a	0f 8d fb 01 00
	00		 jge	 $LN74@s370_perfo
  00880	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00888	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00890	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00893	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00896	23 c1		 and	 eax, ecx
  00898	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0089d	85 c0		 test	 eax, eax
  0089f	0f 84 d6 01 00
	00		 je	 $LN74@s370_perfo

; 310  :     )
; 311  :     {
; 312  :         if (1
; 313  :             && CPU_STEPPING_OR_TRACING_ALL
; 314  :             && !TXF_INSTR_TRACING()

  008a5	33 c0		 xor	 eax, eax
  008a7	83 f8 01	 cmp	 eax, 1
  008aa	0f 84 b9 01 00
	00		 je	 $LN75@s370_perfo
  008b0	b8 08 00 00 00	 mov	 eax, 8
  008b5	48 6b c0 00	 imul	 rax, rax, 0
  008b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008c0	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008c9	75 32		 jne	 SHORT $LN77@s370_perfo
  008cb	b8 08 00 00 00	 mov	 eax, 8
  008d0	48 6b c0 01	 imul	 rax, rax, 1
  008d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008db	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  008e4	75 17		 jne	 SHORT $LN77@s370_perfo
  008e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ed	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  008f3	c1 e8 0a	 shr	 eax, 10
  008f6	83 e0 01	 and	 eax, 1
  008f9	85 c0		 test	 eax, eax
  008fb	75 4e		 jne	 SHORT $LN76@s370_perfo
$LN77@s370_perfo:
  008fd	b8 08 00 00 00	 mov	 eax, 8
  00902	48 6b c0 00	 imul	 rax, rax, 0
  00906	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0090d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00916	0f 85 4d 01 00
	00		 jne	 $LN75@s370_perfo
  0091c	b8 08 00 00 00	 mov	 eax, 8
  00921	48 6b c0 01	 imul	 rax, rax, 1
  00925	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0092c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00935	0f 85 2e 01 00
	00		 jne	 $LN75@s370_perfo
  0093b	e8 00 00 00 00	 call	 insttrace_all
  00940	0f b6 c0	 movzx	 eax, al
  00943	85 c0		 test	 eax, eax
  00945	0f 84 1e 01 00
	00		 je	 $LN75@s370_perfo
$LN76@s370_perfo:
  0094b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00952	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00958	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0095d	85 c0		 test	 eax, eax
  0095f	0f 85 04 01 00
	00		 jne	 $LN75@s370_perfo

; 315  :         )
; 316  :         {
; 317  :             if (regs->insttrace && sysblk.traceFILE)

  00965	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0096d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00973	c1 e8 0f	 shr	 eax, 15
  00976	83 e0 01	 and	 eax, 1
  00979	85 c0		 test	 eax, eax
  0097b	74 28		 je	 SHORT $LN78@s370_perfo
  0097d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00984	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0098c	74 17		 je	 SHORT $LN78@s370_perfo

; 318  :                 tf_0840( regs, EXT_CPU_TIMER_INTERRUPT );

  0098e	66 ba 05 10	 mov	 dx, 4101		; 00001005H
  00992	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  009a0	e9 c4 00 00 00	 jmp	 $LN79@s370_perfo
$LN78@s370_perfo:

; 319  :             else
; 320  :                 // "Processor %s%02X: External interrupt: CPU timer=%16.16"PRIX64
; 321  :                 WRMSG( HHC00842, "I", PTYPSTR( regs->cpuad ), regs->cpuad, CPU_TIMER( regs ));

  009a5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ad	e8 00 00 00 00	 call	 get_cpu_timer
  009b2	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv405[rsp], rax
  009ba	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c2	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  009c9	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv411[rsp], ecx
  009d0	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009d8	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  009df	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  009e6	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  009ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  009f5	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv413[rsp], rax
  009fd	b9 01 00 00 00	 mov	 ecx, 1
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a08	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv405[rsp]
  00a10	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a15	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv411[rsp]
  00a1c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a20	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv413[rsp]
  00a28	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  00a34	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169713
  00a40	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a45	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a50	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169714
  00a57	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169715
  00a63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN79@s370_perfo:
$LN75@s370_perfo:

; 322  :         }
; 323  :         ARCH_DEP( external_interrupt )( EXT_CPU_TIMER_INTERRUPT, regs );

  00a69	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a71	b9 05 10 00 00	 mov	 ecx, 4101		; 00001005H
  00a76	e8 00 00 00 00	 call	 s370_external_interrupt
$LN74@s370_perfo:

; 324  :     }
; 325  : 
; 326  :     /* External interrupt if interval timer interrupt is pending */
; 327  : #if defined(FEATURE_INTERVAL_TIMER)
; 328  :     if (OPEN_IC_ITIMER(regs)
; 329  : #if defined(_FEATURE_SIE)
; 330  :         && !(SIE_STATE_BIT_ON(regs, M, ITMOF))

  00a7b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a83	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00a8e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00a91	23 c1		 and	 eax, ecx
  00a93	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a98	85 c0		 test	 eax, eax
  00a9a	0f 84 08 02 00
	00		 je	 $LN80@s370_perfo
  00aa0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00aae	d1 e8		 shr	 eax, 1
  00ab0	83 e0 01	 and	 eax, 1
  00ab3	85 c0		 test	 eax, eax
  00ab5	74 1e		 je	 SHORT $LN81@s370_perfo
  00ab7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abf	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ac6	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00aca	83 e0 04	 and	 eax, 4
  00acd	85 c0		 test	 eax, eax
  00acf	0f 85 d3 01 00
	00		 jne	 $LN80@s370_perfo
$LN81@s370_perfo:

; 331  : #endif
; 332  :         )
; 333  :     {
; 334  :         if (1
; 335  :             && CPU_STEPPING_OR_TRACING_ALL
; 336  :             && !TXF_INSTR_TRACING()

  00ad5	33 c0		 xor	 eax, eax
  00ad7	83 f8 01	 cmp	 eax, 1
  00ada	0f 84 96 01 00
	00		 je	 $LN82@s370_perfo
  00ae0	b8 08 00 00 00	 mov	 eax, 8
  00ae5	48 6b c0 00	 imul	 rax, rax, 0
  00ae9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00af0	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00af9	75 32		 jne	 SHORT $LN84@s370_perfo
  00afb	b8 08 00 00 00	 mov	 eax, 8
  00b00	48 6b c0 01	 imul	 rax, rax, 1
  00b04	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b0b	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00b14	75 17		 jne	 SHORT $LN84@s370_perfo
  00b16	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b1d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00b23	c1 e8 0a	 shr	 eax, 10
  00b26	83 e0 01	 and	 eax, 1
  00b29	85 c0		 test	 eax, eax
  00b2b	75 4e		 jne	 SHORT $LN83@s370_perfo
$LN84@s370_perfo:
  00b2d	b8 08 00 00 00	 mov	 eax, 8
  00b32	48 6b c0 00	 imul	 rax, rax, 0
  00b36	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b3d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00b46	0f 85 2a 01 00
	00		 jne	 $LN82@s370_perfo
  00b4c	b8 08 00 00 00	 mov	 eax, 8
  00b51	48 6b c0 01	 imul	 rax, rax, 1
  00b55	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b5c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00b65	0f 85 0b 01 00
	00		 jne	 $LN82@s370_perfo
  00b6b	e8 00 00 00 00	 call	 insttrace_all
  00b70	0f b6 c0	 movzx	 eax, al
  00b73	85 c0		 test	 eax, eax
  00b75	0f 84 fb 00 00
	00		 je	 $LN82@s370_perfo
$LN83@s370_perfo:
  00b7b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b82	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b88	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00b8d	85 c0		 test	 eax, eax
  00b8f	0f 85 e1 00 00
	00		 jne	 $LN82@s370_perfo

; 337  :         )
; 338  :         {
; 339  :             if (regs->insttrace && sysblk.traceFILE)

  00b95	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b9d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00ba3	c1 e8 0f	 shr	 eax, 15
  00ba6	83 e0 01	 and	 eax, 1
  00ba9	85 c0		 test	 eax, eax
  00bab	74 28		 je	 SHORT $LN85@s370_perfo
  00bad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bb4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00bbc	74 17		 je	 SHORT $LN85@s370_perfo

; 340  :                 tf_0840( regs, EXT_INTERVAL_TIMER_INTERRUPT );

  00bbe	66 ba 80 00	 mov	 dx, 128			; 00000080H
  00bc2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0840
  00bd0	e9 a1 00 00 00	 jmp	 $LN86@s370_perfo
$LN85@s370_perfo:

; 341  :             else
; 342  :                 // "Processor %s%02X: External interrupt: interval timer"
; 343  :                 WRMSG( HHC00843, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  00bd5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bdd	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00be4	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv482[rsp], eax
  00beb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00bfa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00c01	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00c09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00c0f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv484[rsp], rax
  00c17	b9 01 00 00 00	 mov	 ecx, 1
  00c1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c22	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv482[rsp]
  00c29	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c2d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv484[rsp]
  00c35	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169723
  00c41	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  00c4d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c52	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c57	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c5d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169725
  00c64	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  00c69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169726
  00c70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN86@s370_perfo:
$LN82@s370_perfo:
$LN41@s370_perfo:

; 344  :         }
; 345  :         OFF_IC_ITIMER(regs);

  00c76	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c7e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00c81	0f ba f0 07	 btr	 eax, 7
  00c85	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c8d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00c90	33 c0		 xor	 eax, eax
  00c92	85 c0		 test	 eax, eax
  00c94	75 e0		 jne	 SHORT $LN41@s370_perfo

; 346  :         ARCH_DEP(external_interrupt) (EXT_INTERVAL_TIMER_INTERRUPT, regs);

  00c96	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c9e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00ca3	e8 00 00 00 00	 call	 s370_external_interrupt
$LN80@s370_perfo:

; 347  :     }
; 348  : 
; 349  : #if defined(FEATURE_ECPSVM)
; 350  :     if ( OPEN_IC_ECPSVTIMER(regs) )

  00ca8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cb0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cb8	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00cbb	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00cbe	23 c1		 and	 eax, ecx
  00cc0	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00cc5	85 c0		 test	 eax, eax
  00cc7	74 32		 je	 SHORT $LN87@s370_perfo
$LN44@s370_perfo:

; 351  :     {
; 352  :         OFF_IC_ECPSVTIMER(regs);

  00cc9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cd1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00cd4	0f ba f0 08	 btr	 eax, 8
  00cd8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce0	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00ce3	33 c0		 xor	 eax, eax
  00ce5	85 c0		 test	 eax, eax
  00ce7	75 e0		 jne	 SHORT $LN44@s370_perfo

; 353  :         ARCH_DEP(external_interrupt) (EXT_VINTERVAL_TIMER_INTERRUPT,regs);

  00ce9	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cf1	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00cf6	e8 00 00 00 00	 call	 s370_external_interrupt
$LN87@s370_perfo:

; 354  :     }
; 355  : #endif /*FEATURE_ECPSVM*/
; 356  : #endif /*FEATURE_INTERVAL_TIMER*/
; 357  : 
; 358  :     /* External interrupt if service signal is pending */
; 359  :     if ( OPEN_IC_SERVSIG(regs) && !SIE_MODE(regs) )

  00cfb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d03	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d0b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00d0e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00d11	23 c1		 and	 eax, ecx
  00d13	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d18	85 c0		 test	 eax, eax
  00d1a	0f 84 6d 08 00
	00		 je	 $LN88@s370_perfo
  00d20	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d28	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d2e	d1 e8		 shr	 eax, 1
  00d30	83 e0 01	 and	 eax, 1
  00d33	85 c0		 test	 eax, eax
  00d35	0f 85 52 08 00
	00		 jne	 $LN88@s370_perfo

; 360  :     {
; 361  : 
; 362  : #if defined(FEATURE_VM_BLOCKIO)
; 363  : 
; 364  :         /* Note: Both Block I/O and Service Signal are enabled by the */
; 365  :         /* the same CR0 bit.  Hence they are handled in the same code */
; 366  :         switch(sysblk.servcode)

  00d3b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d42	0f b7 80 68 12
	00 00		 movzx	 eax, WORD PTR [rax+4712]
  00d49	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv529[rsp], eax
  00d50	81 bc 24 98 00
	00 00 01 24 00
	00		 cmp	 DWORD PTR tv529[rsp], 9217 ; 00002401H
  00d5b	0f 84 73 04 00
	00		 je	 $LN98@s370_perfo
  00d61	81 bc 24 98 00
	00 00 03 26 00
	00		 cmp	 DWORD PTR tv529[rsp], 9731 ; 00002603H
  00d6c	74 05		 je	 SHORT $LN89@s370_perfo
  00d6e	e9 61 04 00 00	 jmp	 $LN99@s370_perfo
$LN89@s370_perfo:

; 367  :         {
; 368  :         case EXT_BLOCKIO_INTERRUPT:  /* VM Block I/O Interrupt */
; 369  : 
; 370  :             if (sysblk.biodev->ccwtrace)

  00d73	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d7a	48 8b 80 78 12
	00 00		 mov	 rax, QWORD PTR [rax+4728]
  00d81	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d87	c1 e8 0f	 shr	 eax, 15
  00d8a	83 e0 01	 and	 eax, 1
  00d8d	85 c0		 test	 eax, eax
  00d8f	0f 84 a3 01 00
	00		 je	 $LN90@s370_perfo

; 371  :             {
; 372  :                 if (regs->insttrace && sysblk.traceFILE)

  00d95	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d9d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00da3	c1 e8 0f	 shr	 eax, 15
  00da6	83 e0 01	 and	 eax, 1
  00da9	85 c0		 test	 eax, eax
  00dab	74 24		 je	 SHORT $LN91@s370_perfo
  00dad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00db4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00dbc	74 13		 je	 SHORT $LN91@s370_perfo

; 373  :                     tf_0844( regs );

  00dbe	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0844
  00dcc	e9 67 01 00 00	 jmp	 $LN92@s370_perfo
$LN91@s370_perfo:

; 374  :                 else
; 375  :                     // "Processor %s%02X: %1d:%04X: processing block I/O interrupt:
; 376  :                     //     code %4.4X parm %16.16"PRIX64" status %2.2X subcode %2.2X"
; 377  :                     WRMSG( HHC00844, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  00dd1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dd8	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  00ddf	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv543[rsp], eax
  00de6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ded	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  00df4	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv546[rsp], ecx
  00dfb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e02	0f b7 92 68 12
	00 00		 movzx	 edx, WORD PTR [rdx+4712]
  00e09	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv551[rsp], edx
  00e10	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00e17	4d 8b 80 78 12
	00 00		 mov	 r8, QWORD PTR [r8+4728]
  00e1e	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  00e23	44 89 84 24 cc
	00 00 00	 mov	 DWORD PTR tv555[rsp], r8d
  00e2b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  00e32	4d 8b 89 78 12
	00 00		 mov	 r9, QWORD PTR [r9+4728]
  00e39	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  00e3e	41 d1 f9	 sar	 r9d, 1
  00e41	44 89 8c 24 d0
	00 00 00	 mov	 DWORD PTR tv560[rsp], r9d
  00e49	4c 8b 94 24 60
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  00e51	45 0f b7 92 3c
	08 00 00	 movzx	 r10d, WORD PTR [r10+2108]
  00e59	44 89 94 24 d4
	00 00 00	 mov	 DWORD PTR tv563[rsp], r10d
  00e61	4c 8b 9c 24 60
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00e69	45 0f b7 9b 3c
	08 00 00	 movzx	 r11d, WORD PTR [r11+2108]
  00e71	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR __imp_sysblk
  00e78	42 0f b6 8c 1b
	48 0b 00 00	 movzx	 ecx, BYTE PTR [rbx+r11+2888]
  00e81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e87	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv565[rsp], rax
  00e8f	b9 01 00 00 00	 mov	 ecx, 1
  00e94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e9a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv543[rsp]
  00ea1	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00ea5	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv546[rsp]
  00eac	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00eb0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00eb7	48 8b 89 70 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4720]
  00ebe	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00ec3	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv551[rsp]
  00eca	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00ece	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv555[rsp]
  00ed5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00ed9	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv560[rsp]
  00ee0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00ee4	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv563[rsp]
  00eeb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00eef	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv565[rsp]
  00ef7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00efc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169733
  00f03	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169734
  00f0f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f14	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f19	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f1f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169735
  00f26	ba 80 01 00 00	 mov	 edx, 384		; 00000180H
  00f2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169736
  00f32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN92@s370_perfo:
$LN90@s370_perfo:

; 378  :                         SSID_TO_LCSS(sysblk.biodev->ssid),
; 379  :                         sysblk.biodev->devnum,
; 380  :                         sysblk.servcode,
; 381  :                         sysblk.bioparm,
; 382  :                         sysblk.biostat,
; 383  :                         sysblk.biosubcd
; 384  :                     );
; 385  :             }
; 386  : 
; 387  :             servcode = EXT_BLOCKIO_INTERRUPT;

  00f38	b8 03 26 00 00	 mov	 eax, 9731		; 00002603H
  00f3d	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 388  : 
; 389  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 390  : /* Real address used to store the 64-bit interrupt parameter */
; 391  : #define VM_BLOCKIO_INT_PARM   0x11B8
; 392  :             if (sysblk.biosubcd == 0x07)
; 393  :             {
; 394  :                 /* 8-byte interrupt parm */
; 395  :                 if (1
; 396  :                     && CPU_STEPPING_OR_TRACING_ALL
; 397  :                     && !TXF_INSTR_TRACING()
; 398  :                 )
; 399  :                 {
; 400  :                     if (regs->insttrace && sysblk.traceFILE)
; 401  :                         tf_0845( regs );
; 402  :                     else
; 403  :                     {
; 404  :                         char buf[40];
; 405  :                         MSGBUF( buf, "%16.16X", (unsigned) sysblk.bioparm );
; 406  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 407  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );
; 408  :                     }
; 409  :                 }
; 410  : 
; 411  :                 /* Set the main storage reference and change bits   */
; 412  :                 /* for 64-bit interruption parameter.               */
; 413  :                 /* Note: This is handled for the first 4K page in   */
; 414  :                 /* ARCH_DEP(external_interrupt), but not for the    */
; 415  :                 /* the second 4K page used for the 64-bit interrupt */
; 416  :                 /* parameter.                                       */
; 417  : 
; 418  :                 /* Point to 2nd page of PSA in main storage */
; 419  :                 servpadr=APPLY_PREFIXING(VM_BLOCKIO_INT_PARM,regs->PX);
; 420  : 
; 421  :                 ARCH_DEP( or_storage_key )( servpadr, (STORKEY_REF | STORKEY_CHANGE) );
; 422  : #if 0
; 423  :                 /* Store the 64-bit interrupt parameter */
; 424  :                 LOGMSG( "Saving 64-bit Block I/O interrupt parm at "
; 425  :                     "%16.16X: %16.16X\n",
; 426  :                     servpadr,
; 427  :                     sysblk.bioparm
; 428  :                 );
; 429  : #endif
; 430  :                 STORE_DW(regs->mainstor + servpadr,sysblk.bioparm);
; 431  :                 psa = (void*)(regs->mainstor + regs->PX);
; 432  :             }
; 433  :             else
; 434  : #endif  /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 435  :             {
; 436  :                 /* 4-byte interrupt parm */
; 437  :                 if (1
; 438  :                     && CPU_STEPPING_OR_TRACING_ALL
; 439  :                     && !TXF_INSTR_TRACING()

  00f45	33 c0		 xor	 eax, eax
  00f47	83 f8 01	 cmp	 eax, 1
  00f4a	0f 84 c7 01 00
	00		 je	 $LN93@s370_perfo
  00f50	b8 08 00 00 00	 mov	 eax, 8
  00f55	48 6b c0 00	 imul	 rax, rax, 0
  00f59	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f60	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00f69	75 32		 jne	 SHORT $LN95@s370_perfo
  00f6b	b8 08 00 00 00	 mov	 eax, 8
  00f70	48 6b c0 01	 imul	 rax, rax, 1
  00f74	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f7b	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00f84	75 17		 jne	 SHORT $LN95@s370_perfo
  00f86	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f8d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00f93	c1 e8 0a	 shr	 eax, 10
  00f96	83 e0 01	 and	 eax, 1
  00f99	85 c0		 test	 eax, eax
  00f9b	75 4e		 jne	 SHORT $LN94@s370_perfo
$LN95@s370_perfo:
  00f9d	b8 08 00 00 00	 mov	 eax, 8
  00fa2	48 6b c0 00	 imul	 rax, rax, 0
  00fa6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fad	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00fb6	0f 85 5b 01 00
	00		 jne	 $LN93@s370_perfo
  00fbc	b8 08 00 00 00	 mov	 eax, 8
  00fc1	48 6b c0 01	 imul	 rax, rax, 1
  00fc5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fcc	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00fd5	0f 85 3c 01 00
	00		 jne	 $LN93@s370_perfo
  00fdb	e8 00 00 00 00	 call	 insttrace_all
  00fe0	0f b6 c0	 movzx	 eax, al
  00fe3	85 c0		 test	 eax, eax
  00fe5	0f 84 2c 01 00
	00		 je	 $LN93@s370_perfo
$LN94@s370_perfo:
  00feb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ff2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00ff8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00ffd	85 c0		 test	 eax, eax
  00fff	0f 85 12 01 00
	00		 jne	 $LN93@s370_perfo

; 440  :                 )
; 441  :                 {
; 442  :                     if (regs->insttrace && sysblk.traceFILE)

  01005	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0100d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01013	c1 e8 0f	 shr	 eax, 15
  01016	83 e0 01	 and	 eax, 1
  01019	85 c0		 test	 eax, eax
  0101b	74 24		 je	 SHORT $LN96@s370_perfo
  0101d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01024	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0102c	74 13		 je	 SHORT $LN96@s370_perfo

; 443  :                         tf_0845( regs );

  0102e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0845
  0103c	e9 d6 00 00 00	 jmp	 $LN97@s370_perfo
$LN96@s370_perfo:

; 444  :                     else
; 445  :                     {
; 446  :                         char buf[40];
; 447  :                         MSGBUF( buf, "%8.8X", (U32) sysblk.bioparm );

  01041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01048	44 8b 88 70 12
	00 00		 mov	 r9d, DWORD PTR [rax+4720]
  0104f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169742
  01056	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0105b	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  01063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 448  :                         // "Processor %s%02X: External interrupt: block I/O %s"
; 449  :                         WRMSG( HHC00845,"I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  01069	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01071	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01078	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv623[rsp], eax
  0107f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01087	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0108e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01095	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0109d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  010a3	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv625[rsp], rax
  010ab	b9 01 00 00 00	 mov	 ecx, 1
  010b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010b6	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  010be	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010c3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv623[rsp]
  010ca	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010ce	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv625[rsp]
  010d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169743
  010e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169744
  010ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  010fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169745
  01105	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  0110a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169746
  01111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN97@s370_perfo:
$LN93@s370_perfo:

; 450  :                     }
; 451  :                 }
; 452  : 
; 453  :                 /* Store Block I/O parameter at PSA+X'80' */
; 454  :                 psa = (void*)(regs->mainstor + regs->PX);

  01117	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0111f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01122	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0112a	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  01131	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 455  :                 STORE_FW(psa->extparm,(U32)sysblk.bioparm);

  01139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01140	8b 88 70 12 00
	00		 mov	 ecx, DWORD PTR [rax+4720]
  01146	e8 00 00 00 00	 call	 _byteswap_ulong
  0114b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01153	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  0115a	8b d0		 mov	 edx, eax
  0115c	e8 00 00 00 00	 call	 store_fw_noswap

; 456  :             }
; 457  : 
; 458  :             /* Store sub-interruption code and status at PSA+X'84' */
; 459  :             STORE_HW(psa->extcpad,(sysblk.biosubcd<<8)|sysblk.biostat);

  01161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01168	0f b6 80 6a 12
	00 00		 movzx	 eax, BYTE PTR [rax+4714]
  0116f	c1 e0 08	 shl	 eax, 8
  01172	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01179	0f b6 89 6b 12
	00 00		 movzx	 ecx, BYTE PTR [rcx+4715]
  01180	0b c1		 or	 eax, ecx
  01182	0f b7 c8	 movzx	 ecx, ax
  01185	e8 00 00 00 00	 call	 _byteswap_ushort
  0118a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01192	48 81 c1 84 00
	00 00		 add	 rcx, 132		; 00000084H
  01199	0f b7 d0	 movzx	 edx, ax
  0119c	e8 00 00 00 00	 call	 store_hw_noswap

; 460  : 
; 461  :             /* Reset interruption data */
; 462  :             sysblk.bioparm  = 0;

  011a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011a8	48 c7 80 70 12
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4720], 0

; 463  :             sysblk.biosubcd = 0;

  011b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011ba	c6 80 6a 12 00
	00 00		 mov	 BYTE PTR [rax+4714], 0

; 464  :             sysblk.biostat  = 0;

  011c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011c8	c6 80 6b 12 00
	00 00		 mov	 BYTE PTR [rax+4715], 0

; 465  : 
; 466  :             break;

  011cf	e9 a3 02 00 00	 jmp	 $LN45@s370_perfo
$LN98@s370_perfo:
$LN99@s370_perfo:

; 467  : 
; 468  :         case EXT_SERVICE_SIGNAL_INTERRUPT: /* Service Signal */
; 469  :         default:
; 470  :             servcode = EXT_SERVICE_SIGNAL_INTERRUPT;

  011d4	b8 01 24 00 00	 mov	 eax, 9217		; 00002401H
  011d9	66 89 84 24 84
	00 00 00	 mov	 WORD PTR servcode$[rsp], ax

; 471  : 
; 472  :             /* Apply prefixing if the parameter is a storage address */
; 473  :             if ( (sysblk.servparm & SERVSIG_ADDR) )

  011e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011e8	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  011ee	83 e0 f8	 and	 eax, -8			; fffffff8H
  011f1	85 c0		 test	 eax, eax
  011f3	0f 84 86 00 00
	00		 je	 $LN100@s370_perfo

; 474  :                 sysblk.servparm =

  011f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01200	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01206	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0120c	48 85 c0	 test	 rax, rax
  0120f	74 39		 je	 SHORT $LN109@s370_perfo
  01211	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01218	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  0121e	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01224	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0122c	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0122f	48 3b c1	 cmp	 rax, rcx
  01232	74 16		 je	 SHORT $LN109@s370_perfo
  01234	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0123b	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01241	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv685[rsp], eax
  01248	eb 21		 jmp	 SHORT $LN110@s370_perfo
$LN109@s370_perfo:
  0124a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01251	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01259	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0125c	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01262	33 c1		 xor	 eax, ecx
  01264	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv685[rsp], eax
$LN110@s370_perfo:
  0126b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01272	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv685[rsp]
  01279	89 88 90 12 00
	00		 mov	 DWORD PTR [rax+4752], ecx
$LN100@s370_perfo:

; 475  :                      APPLY_PREFIXING (sysblk.servparm, regs->PX);
; 476  : 
; 477  :             if (1
; 478  :                 && CPU_STEPPING_OR_TRACING_ALL
; 479  :                 && !TXF_INSTR_TRACING()

  0127f	33 c0		 xor	 eax, eax
  01281	83 f8 01	 cmp	 eax, 1
  01284	0f 84 a3 01 00
	00		 je	 $LN101@s370_perfo
  0128a	b8 08 00 00 00	 mov	 eax, 8
  0128f	48 6b c0 00	 imul	 rax, rax, 0
  01293	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0129a	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  012a3	75 32		 jne	 SHORT $LN103@s370_perfo
  012a5	b8 08 00 00 00	 mov	 eax, 8
  012aa	48 6b c0 01	 imul	 rax, rax, 1
  012ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012b5	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  012be	75 17		 jne	 SHORT $LN103@s370_perfo
  012c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012c7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  012cd	c1 e8 0a	 shr	 eax, 10
  012d0	83 e0 01	 and	 eax, 1
  012d3	85 c0		 test	 eax, eax
  012d5	75 4e		 jne	 SHORT $LN102@s370_perfo
$LN103@s370_perfo:
  012d7	b8 08 00 00 00	 mov	 eax, 8
  012dc	48 6b c0 00	 imul	 rax, rax, 0
  012e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012e7	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  012f0	0f 85 37 01 00
	00		 jne	 $LN101@s370_perfo
  012f6	b8 08 00 00 00	 mov	 eax, 8
  012fb	48 6b c0 01	 imul	 rax, rax, 1
  012ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01306	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0130f	0f 85 18 01 00
	00		 jne	 $LN101@s370_perfo
  01315	e8 00 00 00 00	 call	 insttrace_all
  0131a	0f b6 c0	 movzx	 eax, al
  0131d	85 c0		 test	 eax, eax
  0131f	0f 84 08 01 00
	00		 je	 $LN101@s370_perfo
$LN102@s370_perfo:
  01325	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0132c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01332	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01337	85 c0		 test	 eax, eax
  01339	0f 85 ee 00 00
	00		 jne	 $LN101@s370_perfo

; 480  :             )
; 481  :             {
; 482  :                 if (regs->insttrace && sysblk.traceFILE)

  0133f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01347	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0134d	c1 e8 0f	 shr	 eax, 15
  01350	83 e0 01	 and	 eax, 1
  01353	85 c0		 test	 eax, eax
  01355	74 24		 je	 SHORT $LN104@s370_perfo
  01357	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0135e	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01366	74 13		 je	 SHORT $LN104@s370_perfo

; 483  :                     tf_0846( regs );

  01368	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0846
  01376	e9 b2 00 00 00	 jmp	 $LN105@s370_perfo
$LN104@s370_perfo:

; 484  :                 else
; 485  :                     // "Processor %s%02X: External interrupt: service signal %8.8X"
; 486  :                     WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );

  0137b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01383	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0138a	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv723[rsp], eax
  01391	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01399	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  013a0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  013a7	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  013af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  013b5	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv725[rsp], rax
  013bd	b9 01 00 00 00	 mov	 ecx, 1
  013c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013cf	8b 89 90 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4752]
  013d5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  013d9	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv723[rsp]
  013e0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013e4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv725[rsp]
  013ec	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  013f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  013f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169756
  01404	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01409	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0140e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01414	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169757
  0141b	ba e6 01 00 00	 mov	 edx, 486		; 000001e6H
  01420	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169758
  01427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN105@s370_perfo:
$LN101@s370_perfo:

; 487  :             }
; 488  : 
; 489  :             /* Store service signal parameter at PSA+X'80' */
; 490  :             psa = (void*)(regs->mainstor + regs->PX);

  0142d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01435	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01438	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01440	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  01447	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 491  :             STORE_FW(psa->extparm,sysblk.servparm);

  0144f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01456	8b 88 90 12 00
	00		 mov	 ecx, DWORD PTR [rax+4752]
  0145c	e8 00 00 00 00	 call	 _byteswap_ulong
  01461	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01469	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  01470	8b d0		 mov	 edx, eax
  01472	e8 00 00 00 00	 call	 store_fw_noswap
$LN45@s370_perfo:

; 492  : 
; 493  :         }  /* end switch(sysblk.servcode) */
; 494  :         /* Reset service parameter */
; 495  :         sysblk.servparm = 0;

  01477	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0147e	c7 80 90 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4752], 0

; 496  : 
; 497  :         /* Reset service code */
; 498  :         sysblk.servcode = 0;

  01488	33 c0		 xor	 eax, eax
  0148a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01491	66 89 81 68 12
	00 00		 mov	 WORD PTR [rcx+4712], ax
$LN49@s370_perfo:

; 499  : 
; 500  :         /* Reset service signal pending */
; 501  :         OFF_IC_SERVSIG;

  01498	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0149f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  014a5	25 00 02 00 00	 and	 eax, 512		; 00000200H
  014aa	85 c0		 test	 eax, eax
  014ac	0f 84 ba 00 00
	00		 je	 $LN106@s370_perfo
  014b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014b9	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  014bf	0f ba f0 09	 btr	 eax, 9
  014c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  014ca	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  014d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014d7	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  014de	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  014e6	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$2[rsp], 0
  014f1	eb 10		 jmp	 SHORT $LN52@s370_perfo
$LN50@s370_perfo:
  014f3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  014fa	ff c0		 inc	 eax
  014fc	89 84 24 94 00
	00 00		 mov	 DWORD PTR i$2[rsp], eax
$LN52@s370_perfo:
  01503	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR mask$4[rsp], 0
  0150c	74 5e		 je	 SHORT $LN51@s370_perfo
  0150e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  01516	48 83 e0 01	 and	 rax, 1
  0151a	48 85 c0	 test	 rax, rax
  0151d	74 38		 je	 SHORT $LN107@s370_perfo
  0151f	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR i$2[rsp]
  01527	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0152e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01536	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01539	0f ba f0 09	 btr	 eax, 9
  0153d	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR i$2[rsp]
  01545	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0154c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  01554	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN107@s370_perfo:
  01557	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mask$4[rsp]
  0155f	48 d1 e8	 shr	 rax, 1
  01562	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mask$4[rsp], rax
  0156a	eb 87		 jmp	 SHORT $LN50@s370_perfo
$LN51@s370_perfo:
$LN106@s370_perfo:
  0156c	33 c0		 xor	 eax, eax
  0156e	85 c0		 test	 eax, eax
  01570	0f 85 22 ff ff
	ff		 jne	 $LN49@s370_perfo

; 502  : 
; 503  :         /* Generate service signal interrupt */
; 504  :         ARCH_DEP(external_interrupt) (servcode, regs);

  01576	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR servcode$[rsp]
  0157e	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01586	8b c8		 mov	 ecx, eax
  01588	e8 00 00 00 00	 call	 s370_external_interrupt
$LN88@s370_perfo:
$LN1@s370_perfo:

; 505  : 
; 506  : #else /* defined(FEATURE_VM_BLOCKIO) */
; 507  : 
; 508  :         /* Apply prefixing if the parameter is a storage address */
; 509  :         if (sysblk.servparm & SERVSIG_ADDR)
; 510  :             sysblk.servparm = APPLY_PREFIXING( sysblk.servparm, regs->PX );
; 511  : 
; 512  :         if (1
; 513  :             && CPU_STEPPING_OR_TRACING_ALL
; 514  :             && !TXF_INSTR_TRACING()
; 515  :         )
; 516  :         {
; 517  :             if (regs->insttrace && sysblk.traceFILE)
; 518  :                 tf_0846( regs );
; 519  :             else
; 520  :                 // "Processor %s%02X: External interrupt: service signal %8.8X"
; 521  :                 WRMSG( HHC00846,"I", PTYPSTR( regs->cpuad ), regs->cpuad, sysblk.servparm );
; 522  :         }
; 523  : 
; 524  :         /* Store service signal parameter at PSA+X'80' */
; 525  :         psa = (void*)(regs->mainstor + regs->PX);
; 526  :         STORE_FW(psa->extparm,sysblk.servparm);
; 527  : 
; 528  :         /* Reset service parameter */
; 529  :         sysblk.servparm = 0;
; 530  : 
; 531  :         /* Reset service signal pending */
; 532  :         OFF_IC_SERVSIG;
; 533  : 
; 534  :         /* Generate service signal interrupt */
; 535  :         ARCH_DEP(external_interrupt) (EXT_SERVICE_SIGNAL_INTERRUPT, regs);
; 536  : 
; 537  : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 538  : 
; 539  :     }  /* end OPEN_IC_SERVSIG(regs) */
; 540  : 
; 541  : } /* end function perform_external_interrupt */

  0158d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01595	48 33 cc	 xor	 rcx, rsp
  01598	e8 00 00 00 00	 call	 __security_check_cookie
  0159d	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  015a4	5b		 pop	 rbx
  015a5	c3		 ret	 0
s370_perform_external_interrupt ENDP
_TEXT	ENDS
END
