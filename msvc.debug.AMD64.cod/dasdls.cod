; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG159732 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG159720 DB	'Jan', 00H
$SG159721 DB	'Feb', 00H
$SG159722 DB	'Mar', 00H
$SG159723 DB	'Apr', 00H
$SG159724 DB	'May', 00H
$SG159725 DB	'Jun', 00H
$SG159726 DB	'Jul', 00H
$SG159727 DB	'Aug', 00H
$SG159728 DB	'Sep', 00H
$SG159729 DB	'Oct', 00H
$SG159730 DB	'Nov', 00H
$SG159731 DB	'Dec', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	pdate
PUBLIC	pdatex
PUBLIC	pbyte
PUBLIC	phword
PUBLIC	hword
PUBLIC	extent_size
PUBLIC	extents_array
PUBLIC	chainf3
PUBLIC	ordday_to_calday
PUBLIC	end_of_track
PUBLIC	list_contents
PUBLIC	do_ls_cif
PUBLIC	do_ls
PUBLIC	main
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4059000000000000
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_qsort:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_read_track:PROC
EXTRN	__imp_read_block:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_set_verbose_util:PROC
EXTRN	__imp_valid_dsname:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
	ALIGN	8

cif	DQ	01H DUP (?)
yroffs	DD	01H DUP (?)
runflgs	DD	01H DUP (?)
lsegstab DQ	01H DUP (?)
linestab DQ	01H DUP (?)
numsegs	DD	01H DUP (?)
numlines DD	01H DUP (?)
segbuf	DB	0100H DUP (?)
linebuf	DB	0100H DUP (?)
$SG159885 DB	01H DUP (?)
	ALIGN	4

$SG159890 DB	01H DUP (?)
	ALIGN	4

$SG159899 DB	01H DUP (?)
	ALIGN	4

$SG159943 DB	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$pdate DD	imagerel $LN7
	DD	imagerel $LN7+243
	DD	imagerel $unwind$pdate
$pdata$pdatex DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$pdatex
$pdata$pbyte DD	imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$pbyte
$pdata$phword DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$phword
$pdata$extent_size DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$extent_size
$pdata$extents_array DD imagerel $LN8
	DD	imagerel $LN8+260
	DD	imagerel $unwind$extents_array
$pdata$chainf3 DD imagerel $LN14
	DD	imagerel $LN14+648
	DD	imagerel $unwind$chainf3
$pdata$ordday_to_calday DD imagerel $LN13
	DD	imagerel $LN13+322
	DD	imagerel $unwind$ordday_to_calday
$pdata$end_of_track DD imagerel $LN5
	DD	imagerel $LN5+245
	DD	imagerel $unwind$end_of_track
$pdata$list_contents DD imagerel $LN79
	DD	imagerel $LN79+3466
	DD	imagerel $unwind$list_contents
$pdata$do_ls_cif DD imagerel $LN7
	DD	imagerel $LN7+588
	DD	imagerel $unwind$do_ls_cif
$pdata$do_ls DD	imagerel $LN6
	DD	imagerel $LN6+222
	DD	imagerel $unwind$do_ls
$pdata$prtseg DD imagerel prtseg
	DD	imagerel prtseg+149
	DD	imagerel $unwind$prtseg
$pdata$prtline DD imagerel prtline
	DD	imagerel prtline+149
	DD	imagerel $unwind$prtline
$pdata$print_line_from_segs DD imagerel print_line_from_segs
	DD	imagerel print_line_from_segs+209
	DD	imagerel $unwind$print_line_from_segs
$pdata$sort_linestab DD imagerel sort_linestab
	DD	imagerel sort_linestab+40
	DD	imagerel $unwind$sort_linestab
$pdata$main DD	imagerel $LN27
	DD	imagerel $LN27+936
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
_DATA	SEGMENT
dsnlen	DD	02cH
$SG159677 DB	'%s', 00H
	ORG $+9
?mths@?1??pdate@@9@9 DQ FLAT:$SG159720			; `pdate'::`2'::mths
	DQ	FLAT:$SG159721
	DQ	FLAT:$SG159722
	DQ	FLAT:$SG159723
	DQ	FLAT:$SG159724
	DQ	FLAT:$SG159725
	DQ	FLAT:$SG159726
	DQ	FLAT:$SG159727
	DQ	FLAT:$SG159728
	DQ	FLAT:$SG159729
	DQ	FLAT:$SG159730
	DQ	FLAT:$SG159731
	DQ	FLAT:$SG159732
$SG159737 DB	' *********', 00H
	ORG $+1
$SG159780 DB	'E', 00H
	ORG $+2
$SG159738 DB	' %4.4d%s%2.2d', 00H
	ORG $+2
$SG159739 DB	' %2.2d%s%3.3d', 00H
	ORG $+2
$SG159745 DB	' ---------', 00H
	ORG $+1
$SG159746 DB	' -----', 00H
	ORG $+1
$SG159750 DB	' %3d', 00H
	ORG $+3
$SG159754 DB	' %5d', 00H
	ORG $+3
$SG159878 DB	' CREDT', 00H
	ORG $+1
$SG159903 DB	'%s', 00H
	ORG $+1
$SG159779 DB	'Extents_array DSXTENT', 00H
	ORG $+2
$SG159781 DB	'HHC02471%s %s record not found', 0aH, 00H
$SG159782 DB	'extents_array', 00H
	ORG $+2
$SG159783 DB	'dasdls.c', 00H
	ORG $+3
$SG159879 DB	'Dsname', 00H
	ORG $+1
$SG159904 DB	'%*s', 00H
$SG159872 DB	'ETRK=%d', 0aH, 00H
	ORG $+3
$SG159880 DB	'%*s%s', 00H
	ORG $+2
$SG159884 DB	' REFDT', 00H
	ORG $+1
$SG159908 DB	'??', 00H
	ORG $+1
$SG159873 DB	0aH, 'VOLSER:  %-6s    "%s"', 0aH, 0aH, 00H
	ORG $+3
$SG159889 DB	' EXPDT', 00H
	ORG $+1
$SG159912 DB	'VS', 00H
	ORG $+1
$SG159874 DB	'list_contents', 00H
	ORG $+2
$SG159875 DB	'dasdls.c', 00H
	ORG $+3
$SG159915 DB	'PS', 00H
	ORG $+1
$SG159877 DB	'  Created ', 00H
	ORG $+1
$SG159917 DB	'DA', 00H
	ORG $+1
$SG159881 DB	'list_contents', 00H
	ORG $+2
$SG159882 DB	'dasdls.c', 00H
	ORG $+3
$SG159919 DB	'PO', 00H
	ORG $+1
$SG159883 DB	' Last Ref.', 00H
	ORG $+1
$SG159921 DB	'  ', 00H
	ORG $+1
$SG159886 DB	'list_contents', 00H
	ORG $+2
$SG159887 DB	'dasdls.c', 00H
	ORG $+3
$SG159923 DB	'U', 00H
	ORG $+2
$SG159888 DB	' Exp. Date', 00H
	ORG $+1
$SG159924 DB	' ', 00H
	ORG $+2
$SG159891 DB	'list_contents', 00H
	ORG $+2
$SG159892 DB	'dasdls.c', 00H
	ORG $+3
$SG159925 DB	' %s%s', 00H
	ORG $+2
$SG159927 DB	'F', 00H
	ORG $+2
$SG159893 DB	' ORG RECFM LRECL BLKSZ Key  Trks%%Use#Ext 2ndry_alloc', 0aH
	DB	00H
	ORG $+1
$SG159894 DB	'list_contents', 00H
	ORG $+2
$SG159895 DB	'dasdls.c', 00H
	ORG $+3
$SG159929 DB	'V', 00H
	ORG $+2
$SG159897 DB	'CTRK=%d', 0aH, 00H
	ORG $+3
$SG159931 DB	'U', 00H
	ORG $+2
$SG159933 DB	'B', 00H
	ORG $+2
$SG159935 DB	'S', 00H
	ORG $+2
$SG159937 DB	'A', 00H
	ORG $+2
$SG159939 DB	'M', 00H
	ORG $+2
$SG159941 DB	'?', 00H
	ORG $+2
$SG159945 DB	'T', 00H
	ORG $+2
$SG159946 DB	' %-5s', 00H
	ORG $+2
$SG159949 DB	' %5d', 00H
	ORG $+3
$SG159950 DB	'      ', 00H
	ORG $+1
$SG159951 DB	' %5d', 00H
	ORG $+3
$SG159954 DB	'    ', 00H
	ORG $+3
$SG159955 DB	' %3.0f', 00H
	ORG $+1
$SG159958 DB	'ABSTR', 00H
	ORG $+2
$SG159959 DB	' %-11s', 00H
	ORG $+1
$SG159960 DB	'CYL', 00H
$SG159962 DB	'BLK', 00H
$SG159964 DB	'TRK', 00H
$SG159967 DB	0aH, 00H
	ORG $+2
$SG159966 DB	' %3s%8d', 00H
$SG159971 DB	'%s', 00H
	ORG $+1
$SG159990 DB	'E', 00H
	ORG $+2
$SG159972 DB	'list_contents', 00H
	ORG $+2
$SG159973 DB	'dasdls.c', 00H
	ORG $+3
$SG159989 DB	'VOL1', 00H
	ORG $+3
$SG159997 DB	'E', 00H
	ORG $+2
$SG159991 DB	'HHC02471%s %s record not found', 0aH, 00H
$SG159992 DB	'do_ls_cif', 00H
	ORG $+2
$SG160009 DB	0aH, 00H
	ORG $+2
$SG159993 DB	'dasdls.c', 00H
	ORG $+3
$SG160010 DB	'do_ls', 00H
	ORG $+2
$SG160029 DB	'dasdls', 00H
	ORG $+1
$SG160031 DB	'I', 00H
	ORG $+2
$SG159996 DB	'Format 4 DSCB', 00H
	ORG $+2
$SG159998 DB	'HHC02471%s %s record not found', 0aH, 00H
$SG159999 DB	'do_ls_cif', 00H
	ORG $+2
$SG160038 DB	'-caldt', 00H
	ORG $+1
$SG160055 DB	'sf=', 00H
$SG160000 DB	'dasdls.c', 00H
	ORG $+3
$SG160036 DB	'-info', 00H
	ORG $+2
$SG160040 DB	'-expdt', 00H
	ORG $+5
$SG160011 DB	'dasdls.c', 00H
	ORG $+7
$SG160028 DB	'List DASD image file contents', 00H
	ORG $+2
$SG160033 DB	'main', 00H
	ORG $+3
$SG160032 DB	'HHC02463%s Usage: %s [-option [-option ... ]] ckdfile [s'
	DB	'f=sfile]  [...]', 0aH, 'HHC02463I   ckdfile:      input dasd '
	DB	'image file', 0aH, 'HHC02463I   sfile:        optional dasd im'
	DB	'age shadow file', 0aH, 'HHC02463I options:', 0aH, 'HHC02463I '
	DB	'  -hdr          show column headers', 0aH, 'HHC02463I   -dsnl'
	DB	'[=n]     restrict dsname width', 0aH, 'HHC02463I   -info     '
	DB	'    show F1 info', 0aH, 'HHC02463I   -caldt        calendar d'
	DB	'ate format', 0aH, 'HHC02463I   -refdt        show last-refere'
	DB	'nce date', 0aH, 'HHC02463I   -expdt        show expiry date', 0aH
	DB	'HHC02463I   -yroffs[=n]   year offset', 0aH, 'HHC02463I Note:'
	DB	0aH, 'HHC02463I   Multiple images can be processed in the same'
	DB	' run,', 0aH, 'HHC02463I   but options must be specified ahead'
	DB	' of each image.', 0aH, 00H
	ORG $+5
$SG160034 DB	'dasdls.c', 00H
	ORG $+3
$SG160042 DB	'-refdt', 00H
	ORG $+1
$SG160044 DB	'-hdr', 00H
	ORG $+3
$SG160046 DB	'-dsnl=', 00H
	ORG $+1
$SG160048 DB	'-dsnl', 00H
	ORG $+6
$SG160050 DB	'-yroffs=', 00H
	ORG $+7
$SG160052 DB	'-yroffs', 00H
$SG160057 DB	'dasdls', 00H
	ORG $+1
$SG160058 DB	0aH, 'End of %s; rc=%d', 0aH, 00H
	ORG $+1
$SG160059 DB	'main', 00H
	ORG $+7
$SG160060 DB	'dasdls.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:print_line_from_segs
	DD	013H
	DD	0b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:do_ls_cif
	DD	016H
	DD	0237H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:list_contents
	DD	021H
	DD	0d71H
voltbl	ENDS
xdata	SEGMENT
$unwind$pdate DD 010d01H
	DD	0820dH
$unwind$pdatex DD 010d01H
	DD	0620dH
$unwind$pbyte DD 010901H
	DD	04209H
$unwind$phword DD 010901H
	DD	04209H
$unwind$extent_size DD 010d01H
	DD	0620dH
$unwind$extents_array DD 011701H
	DD	0a217H
$unwind$chainf3 DD 011301H
	DD	0c213H
$unwind$ordday_to_calday DD 011601H
	DD	04216H
$unwind$end_of_track DD 010901H
	DD	02209H
$unwind$list_contents DD 032919H
	DD	0280117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$do_ls_cif DD 021b19H
	DD	011010cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$do_ls DD 010e01H
	DD	0620eH
$unwind$prtseg DD 011801H
	DD	06218H
$unwind$prtline DD 011801H
	DD	06218H
$unwind$print_line_from_segs DD 031b19H
	DD	0280109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$sort_linestab DD 010e01H
	DD	0420eH
$unwind$main DD	010d01H
	DD	0c20dH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
rc$ = 64
fn$ = 72
sfn$ = 80
pgm$ = 88
argc$ = 112
argv$ = 120
main	PROC

; 652  : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 653  : char           *pgm;            /* less any extension (.ext)         */
; 654  : int             rc = 0;

  0000d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 655  : char           *fn, *sfn;
; 656  : 
; 657  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00015	48 8d 44 24 58	 lea	 rax, QWORD PTR pgm$[rsp]
  0001a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160028
  00026	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160029
  0002d	48 8b 54 24 78	 mov	 rdx, QWORD PTR argv$[rsp]
  00032	8b 4c 24 70	 mov	 ecx, DWORD PTR argc$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  0003c	89 44 24 70	 mov	 DWORD PTR argc$[rsp], eax

; 658  : 
; 659  :     if (argc < 2)

  00040	83 7c 24 70 02	 cmp	 DWORD PTR argc$[rsp], 2
  00045	7d 5c		 jge	 SHORT $LN4@main

; 660  :     {
; 661  :         // "Usage: %s [-option [-option ... ]] ckdfile [sf=shadow-file-name]%s"
; 662  :         WRMSG( HHC02463, "I", pgm );

  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pgm$[rsp]
  00057	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160031
  00063	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160032
  0006f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00074	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00079	41 b9 03 00 00
	00		 mov	 r9d, 3
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160033
  00086	ba 96 02 00 00	 mov	 edx, 662		; 00000296H
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160034
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 663  :         exit(2);

  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN4@main:

; 664  :     }
; 665  : 
; 666  :     /*
; 667  :      * If your version of Hercules doesn't have support in its
; 668  :      * dasdutil.c for turning off verbose messages, then remove
; 669  :      * the following line but you'll have to live with chatty
; 670  :      * progress output on stdout.
; 671  :      */
; 672  :     set_verbose_util(0);                    /* (don't be chatty) */

  000a3	33 c9		 xor	 ecx, ecx
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_verbose_util
$LN26@main:
$LN25@main:
$LN24@main:
$LN23@main:
$LN22@main:
$LN21@main:
$LN20@main:
$LN19@main:
$LN18@main:
$LN2@main:

; 673  : 
; 674  :     while (*++argv)

  000ab	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  000b0	48 83 c0 08	 add	 rax, 8
  000b4	48 89 44 24 78	 mov	 QWORD PTR argv$[rsp], rax
  000b9	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  000be	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000c2	0f 84 88 02 00
	00		 je	 $LN3@main

; 675  :     {
; 676  :         fn = *argv;

  000c8	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  000cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d0	48 89 44 24 48	 mov	 QWORD PTR fn$[rsp], rax

; 677  : 
; 678  :         if (strcmp( fn, "-info" ) == 0)     /* show F1 info */

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160036
  000dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  000e1	e8 00 00 00 00	 call	 strcmp
  000e6	85 c0		 test	 eax, eax
  000e8	75 11		 jne	 SHORT $LN5@main

; 679  :         {
; 680  :             runflgs |= rf_info;

  000ea	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  000f0	83 c8 10	 or	 eax, 16
  000f3	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 681  :             continue;

  000f9	eb b0		 jmp	 SHORT $LN2@main
$LN5@main:

; 682  :         }
; 683  :         if (strcmp( fn, "-caldt" ) == 0)    /* calendar date format */

  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160038
  00102	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  00107	e8 00 00 00 00	 call	 strcmp
  0010c	85 c0		 test	 eax, eax
  0010e	75 11		 jne	 SHORT $LN6@main

; 684  :         {
; 685  :             runflgs |= (rf_caldate | rf_info);

  00110	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00116	83 c8 11	 or	 eax, 17
  00119	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 686  :             continue;

  0011f	eb 8a		 jmp	 SHORT $LN18@main
$LN6@main:

; 687  :         }
; 688  :         if (strcmp( fn, "-expdt" ) == 0)    /* show expiry date */

  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160040
  00128	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  0012d	e8 00 00 00 00	 call	 strcmp
  00132	85 c0		 test	 eax, eax
  00134	75 14		 jne	 SHORT $LN7@main

; 689  :         {
; 690  :             runflgs |= (rf_expdate | rf_info);

  00136	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0013c	83 c8 12	 or	 eax, 18
  0013f	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 691  :             continue;

  00145	e9 61 ff ff ff	 jmp	 $LN19@main
$LN7@main:

; 692  :         }
; 693  :         if (strcmp( fn, "-refdt" ) == 0)    /* show last-reference date */

  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160042
  00151	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  00156	e8 00 00 00 00	 call	 strcmp
  0015b	85 c0		 test	 eax, eax
  0015d	75 14		 jne	 SHORT $LN8@main

; 694  :         {
; 695  :             runflgs |= (rf_refdate | rf_info);

  0015f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00165	83 c8 14	 or	 eax, 20
  00168	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 696  :             continue;

  0016e	e9 38 ff ff ff	 jmp	 $LN20@main
$LN8@main:

; 697  :         }
; 698  :         if (strcmp( fn, "-hdr" ) == 0)      /* show column headers */

  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160044
  0017a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  0017f	e8 00 00 00 00	 call	 strcmp
  00184	85 c0		 test	 eax, eax
  00186	75 14		 jne	 SHORT $LN9@main

; 699  :         {
; 700  :             runflgs |= (rf_header | rf_info);

  00188	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0018e	83 c8 18	 or	 eax, 24
  00191	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 701  :             continue;

  00197	e9 0f ff ff ff	 jmp	 $LN21@main
$LN9@main:

; 702  :         }
; 703  :         if (1
; 704  :             && strlen( *argv )   >    6
; 705  :             && !memcmp( fn, "-dsnl=", 6 ))  /* restrict dsname width (custom) */

  0019c	33 c0		 xor	 eax, eax
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	74 5a		 je	 SHORT $LN10@main
  001a3	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  001a8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ab	e8 00 00 00 00	 call	 strlen
  001b0	48 83 f8 06	 cmp	 rax, 6
  001b4	76 47		 jbe	 SHORT $LN10@main
  001b6	41 b8 06 00 00
	00		 mov	 r8d, 6
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160046
  001c3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  001c8	e8 00 00 00 00	 call	 memcmp
  001cd	85 c0		 test	 eax, eax
  001cf	75 2c		 jne	 SHORT $LN10@main

; 706  :         {
; 707  :             runflgs |= rf_info;

  001d1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  001d7	83 c8 10	 or	 eax, 16
  001da	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 708  :             dsnlen = atoi( fn + 6 );

  001e0	48 8b 44 24 48	 mov	 rax, QWORD PTR fn$[rsp]
  001e5	48 83 c0 06	 add	 rax, 6
  001e9	48 8b c8	 mov	 rcx, rax
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  001f2	89 05 00 00 00
	00		 mov	 DWORD PTR dsnlen, eax

; 709  :             continue;

  001f8	e9 ae fe ff ff	 jmp	 $LN22@main
$LN10@main:

; 710  :         }
; 711  :         if (strcmp( fn, "-dsnl" ) == 0)     /* restrict dsname width (default) */

  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160048
  00204	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  00209	e8 00 00 00 00	 call	 strcmp
  0020e	85 c0		 test	 eax, eax
  00210	75 1e		 jne	 SHORT $LN11@main

; 712  :         {
; 713  :             runflgs |= rf_info;

  00212	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00218	83 c8 10	 or	 eax, 16
  0021b	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 714  :             dsnlen = 26;

  00221	c7 05 00 00 00
	00 1a 00 00 00	 mov	 DWORD PTR dsnlen, 26

; 715  :             continue;

  0022b	e9 7b fe ff ff	 jmp	 $LN23@main
$LN11@main:

; 716  :         }
; 717  :         if (1
; 718  :             && strlen( *argv )   >      8
; 719  :             && !memcmp( fn, "-yroffs=", 8 ))/* year offset (custom) */

  00230	33 c0		 xor	 eax, eax
  00232	83 f8 01	 cmp	 eax, 1
  00235	74 5a		 je	 SHORT $LN12@main
  00237	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  0023c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0023f	e8 00 00 00 00	 call	 strlen
  00244	48 83 f8 08	 cmp	 rax, 8
  00248	76 47		 jbe	 SHORT $LN12@main
  0024a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160050
  00257	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  0025c	e8 00 00 00 00	 call	 memcmp
  00261	85 c0		 test	 eax, eax
  00263	75 2c		 jne	 SHORT $LN12@main

; 720  :         {
; 721  :             runflgs |= rf_info;

  00265	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0026b	83 c8 10	 or	 eax, 16
  0026e	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 722  :             yroffs = atoi( fn + 8 );

  00274	48 8b 44 24 48	 mov	 rax, QWORD PTR fn$[rsp]
  00279	48 83 c0 08	 add	 rax, 8
  0027d	48 8b c8	 mov	 rcx, rax
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00286	89 05 00 00 00
	00		 mov	 DWORD PTR yroffs, eax

; 723  :             continue;

  0028c	e9 1a fe ff ff	 jmp	 $LN24@main
$LN12@main:

; 724  :         }
; 725  :         if (strcmp( fn, "-yroffs" ) == 0)   /* year offset (default) */

  00291	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160052
  00298	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  0029d	e8 00 00 00 00	 call	 strcmp
  002a2	85 c0		 test	 eax, eax
  002a4	75 1e		 jne	 SHORT $LN13@main

; 726  :         {
; 727  :             runflgs |= rf_info;

  002a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  002ac	83 c8 10	 or	 eax, 16
  002af	89 05 00 00 00
	00		 mov	 DWORD PTR runflgs, eax

; 728  :             yroffs = 28;

  002b5	c7 05 00 00 00
	00 1c 00 00 00	 mov	 DWORD PTR yroffs, 28

; 729  :             continue;

  002bf	e9 e7 fd ff ff	 jmp	 $LN25@main
$LN13@main:

; 730  :         }
; 731  : 
; 732  :         /* Check for shadow file */
; 733  :         if (1
; 734  :             &&         *(argv+1)
; 735  :             && strlen( *(argv+1) )   >   3
; 736  :             && memcmp( *(argv+1), "sf=", 3 ) == 0

  002c4	33 c0		 xor	 eax, eax
  002c6	83 f8 01	 cmp	 eax, 1
  002c9	74 5c		 je	 SHORT $LN14@main
  002cb	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  002d0	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  002d5	74 50		 je	 SHORT $LN14@main
  002d7	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  002dc	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002e0	e8 00 00 00 00	 call	 strlen
  002e5	48 83 f8 03	 cmp	 rax, 3
  002e9	76 3c		 jbe	 SHORT $LN14@main
  002eb	41 b8 03 00 00
	00		 mov	 r8d, 3
  002f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160055
  002f8	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  002fd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00301	e8 00 00 00 00	 call	 memcmp
  00306	85 c0		 test	 eax, eax
  00308	75 1d		 jne	 SHORT $LN14@main

; 737  :         )
; 738  :              sfn = *++argv;

  0030a	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  0030f	48 83 c0 08	 add	 rax, 8
  00313	48 89 44 24 78	 mov	 QWORD PTR argv$[rsp], rax
  00318	48 8b 44 24 78	 mov	 rax, QWORD PTR argv$[rsp]
  0031d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00320	48 89 44 24 50	 mov	 QWORD PTR sfn$[rsp], rax
  00325	eb 09		 jmp	 SHORT $LN15@main
$LN14@main:

; 739  :         else sfn = NULL;

  00327	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR sfn$[rsp], 0
$LN15@main:

; 740  : 
; 741  :         if (do_ls( fn, sfn ))

  00330	48 8b 54 24 50	 mov	 rdx, QWORD PTR sfn$[rsp]
  00335	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fn$[rsp]
  0033a	e8 00 00 00 00	 call	 do_ls
  0033f	85 c0		 test	 eax, eax
  00341	74 08		 je	 SHORT $LN16@main

; 742  :             rc = 1;

  00343	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN16@main:

; 743  :     }

  0034b	e9 5b fd ff ff	 jmp	 $LN26@main
$LN3@main:

; 744  : 
; 745  :     LOGMSG("\nEnd of %s; rc=%d\n", UTILITY_NAME, rc );

  00350	b9 01 00 00 00	 mov	 ecx, 1
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0035b	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  0035f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160057
  0036a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160058
  00376	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00380	41 b9 03 00 00
	00		 mov	 r9d, 3
  00386	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160059
  0038d	ba e9 02 00 00	 mov	 edx, 745		; 000002e9H
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160060
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 746  :     return rc;

  0039f	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN17@main:

; 747  : }

  003a3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003a7	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
a$ = 48
b$ = 56
sort_linestab PROC

; 113  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 114  :     return strcmp( *(const char**)a, *(const char**)b );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00013	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001e	e8 00 00 00 00	 call	 strcmp

; 115  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
sort_linestab ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
i$ = 32
buffer$ = 48
__$ArrayPad$ = 304
print_line_from_segs PROC

; 95   : {

  00000	40 57		 push	 rdi
  00002	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 96   :     int  i;
; 97   :     char buffer[256] = {0};

  0001b	48 8d 44 24 30	 lea	 rax, QWORD PTR buffer$[rsp]
  00020	48 8b f8	 mov	 rdi, rax
  00023	33 c0		 xor	 eax, eax
  00025	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002a	f3 aa		 rep stosb

; 98   : 
; 99   :     for (i=0; i < numsegs; ++i)

  0002c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00034	eb 0a		 jmp	 SHORT $LN4@print_line
$LN2@print_line:
  00036	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003a	ff c0		 inc	 eax
  0003c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@print_line:
  00040	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsegs
  00046	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0004a	7d 39		 jge	 SHORT $LN3@print_line

; 100  :     {
; 101  :         STRLCAT( buffer, lsegstab[i] );

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00051	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lsegstab
  0005e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 102  :         free( lsegstab[i] );

  0006d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lsegstab
  00079	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 103  :     }

  00083	eb b1		 jmp	 SHORT $LN2@print_line
$LN3@print_line:

; 104  : 
; 105  :     free( lsegstab );

  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lsegstab
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 106  :     lsegstab = NULL;

  00092	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR lsegstab, 0

; 107  :     numsegs = 0;

  0009d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR numsegs, 0

; 108  : 
; 109  :     prtline( "%s", buffer );

  000a7	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159677
  000b3	e8 00 00 00 00	 call	 prtline

; 110  : }

  000b8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c0	48 33 cc	 xor	 rcx, rsp
  000c3	e8 00 00 00 00	 call	 __security_check_cookie
  000c8	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
print_line_from_segs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
vl$ = 32
fmt$ = 64
prtline	PROC

; 84   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 85   :     va_list   vl;
; 86   :     va_start( vl, fmt );

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 87   : 
; 88   :     vsnprintf( linebuf, sizeof( linebuf ), fmt, vl );

  00022	4c 8b 4c 24 20	 mov	 r9, QWORD PTR vl$[rsp]
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR fmt$[rsp]
  0002c	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:linebuf
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf

; 89   : 
; 90   :     linestab = realloc( linestab, (numlines + 1) * sizeof( char* ));

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numlines
  00044	ff c0		 inc	 eax
  00046	48 98		 cdqe
  00048	48 c1 e0 03	 shl	 rax, 3
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR linestab
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR linestab, rax

; 91   :     linestab[ numlines++ ] = strdup( linebuf );

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:linebuf
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00070	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR numlines
  00077	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR linestab
  0007e	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numlines
  00088	ff c0		 inc	 eax
  0008a	89 05 00 00 00
	00		 mov	 DWORD PTR numlines, eax

; 92   : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
prtline	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
vl$ = 32
fmt$ = 64
prtseg	PROC

; 73   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 74   :     va_list   vl;
; 75   :     va_start( vl, fmt );

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 76   : 
; 77   :     vsnprintf( segbuf, sizeof( segbuf ), fmt, vl );

  00022	4c 8b 4c 24 20	 mov	 r9, QWORD PTR vl$[rsp]
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR fmt$[rsp]
  0002c	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:segbuf
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf

; 78   : 
; 79   :     lsegstab = realloc( lsegstab, (numsegs + 1) * sizeof( char* ));

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsegs
  00044	ff c0		 inc	 eax
  00046	48 98		 cdqe
  00048	48 c1 e0 03	 shl	 rax, 3
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lsegstab
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR lsegstab, rax

; 80   :     lsegstab[ numsegs++ ] = strdup( segbuf );

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:segbuf
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00070	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR numsegs
  00077	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR lsegstab
  0007e	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsegs
  00088	ff c0		 inc	 eax
  0008a	89 05 00 00 00
	00		 mov	 DWORD PTR numsegs, eax

; 81   : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
prtseg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
file$ = 64
sfile$ = 72
do_ls	PROC

; 626  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 627  :     LOGMSG("\n");

  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160009
  00020	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160010
  00037	ba 73 02 00 00	 mov	 edx, 627		; 00000273H
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160011
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 628  : 
; 629  :     if (!(cif = open_ckd_image( file, sfile, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL )))

  00049	45 33 c9	 xor	 r9d, r9d
  0004c	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00052	48 8b 54 24 48	 mov	 rdx, QWORD PTR sfile$[rsp]
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR cif, rax
  00069	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR cif, 0
  00071	75 07		 jne	 SHORT $LN2@do_ls

; 630  :         return -1;

  00073	b8 ff ff ff ff	 mov	 eax, -1
  00078	eb 5f		 jmp	 SHORT $LN1@do_ls
$LN2@do_ls:

; 631  : 
; 632  :     if (do_ls_cif( cif ) != 0)

  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  00081	e8 00 00 00 00	 call	 do_ls_cif
  00086	85 c0		 test	 eax, eax
  00088	74 1f		 je	 SHORT $LN3@do_ls

; 633  :     {
; 634  :         close_ckd_image( cif );

  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 635  :         cif = NULL;

  00097	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR cif, 0

; 636  :         return -1;

  000a2	b8 ff ff ff ff	 mov	 eax, -1
  000a7	eb 30		 jmp	 SHORT $LN1@do_ls
$LN3@do_ls:

; 637  :     }
; 638  : 
; 639  :     if (close_ckd_image( cif ) != 0)

  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image
  000b6	85 c0		 test	 eax, eax
  000b8	74 12		 je	 SHORT $LN4@do_ls

; 640  :     {
; 641  :         cif = NULL;

  000ba	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR cif, 0

; 642  :         return -1;

  000c5	b8 ff ff ff ff	 mov	 eax, -1
  000ca	eb 0d		 jmp	 SHORT $LN1@do_ls
$LN4@do_ls:

; 643  :     }
; 644  : 
; 645  :     cif = NULL;

  000cc	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR cif, 0

; 646  :     return 0;

  000d7	33 c0		 xor	 eax, eax
$LN1@do_ls:

; 647  : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
do_ls	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
rec$ = 64
head$ = 65
rc$ = 68
klen$ = 72
vol1data$ = 80
rlen$ = 88
cyl$ = 92
f4dscb$ = 96
volser$ = 104
__$ArrayPad$ = 112
cif$ = 144
do_ls_cif PROC

; 575  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 576  :     int rc;
; 577  : 
; 578  :     U32 cyl;
; 579  :     U8  head;
; 580  :     U8  rec;
; 581  : 
; 582  :     U16 rlen;
; 583  :     U8  klen;
; 584  : 
; 585  :     unsigned char *vol1data;
; 586  :     FORMAT4_DSCB  *f4dscb;
; 587  : 
; 588  :     char volser[7];
; 589  : 
; 590  :     rc = read_block( cif, 0, 0, 3, 0, 0, &vol1data, &rlen );

  0001b	48 8d 44 24 58	 lea	 rax, QWORD PTR rlen$[rsp]
  00020	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00025	48 8d 44 24 50	 lea	 rax, QWORD PTR vol1data$[rsp]
  0002a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0002f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00038	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00041	41 b1 03	 mov	 r9b, 3
  00044	45 33 c0	 xor	 r8d, r8d
  00047	33 d2		 xor	 edx, edx
  00049	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00057	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 591  : 
; 592  :     if (rc < 0)

  0005b	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  00060	7d 0a		 jge	 SHORT $LN2@do_ls_cif

; 593  :         return -1;

  00062	b8 ff ff ff ff	 mov	 eax, -1
  00067	e9 cb 01 00 00	 jmp	 $LN1@do_ls_cif
$LN2@do_ls_cif:

; 594  : 
; 595  :     if (rc > 0)

  0006c	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  00071	7e 5d		 jle	 SHORT $LN3@do_ls_cif

; 596  :     {
; 597  :         // "%s record not found"
; 598  :         FWRMSG( stderr, HHC02471, "E", "VOL1" );

  00073	b9 02 00 00 00	 mov	 ecx, 2
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159989
  00085	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159990
  00091	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159991
  0009d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159992
  000b4	ba 56 02 00 00	 mov	 edx, 598		; 00000256H
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159993
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 599  :         return -1;

  000c6	b8 ff ff ff ff	 mov	 eax, -1
  000cb	e9 67 01 00 00	 jmp	 $LN1@do_ls_cif
$LN3@do_ls_cif:

; 600  :     }
; 601  : 
; 602  :     make_asciiz( volser, sizeof( volser ), vol1data + 4, 6 );

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR vol1data$[rsp]
  000d5	48 83 c0 04	 add	 rax, 4
  000d9	41 b9 06 00 00
	00		 mov	 r9d, 6
  000df	4c 8b c0	 mov	 r8, rax
  000e2	ba 07 00 00 00	 mov	 edx, 7
  000e7	48 8d 4c 24 68	 lea	 rcx, QWORD PTR volser$[rsp]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 603  : 
; 604  :     cyl  = (vol1data[11] << 8) | vol1data[12];

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	48 6b c0 0b	 imul	 rax, rax, 11
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vol1data$[rsp]
  00100	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00104	c1 e0 08	 shl	 eax, 8
  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	48 6b c9 0c	 imul	 rcx, rcx, 12
  00110	48 8b 54 24 50	 mov	 rdx, QWORD PTR vol1data$[rsp]
  00115	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00119	0b c1		 or	 eax, ecx
  0011b	89 44 24 5c	 mov	 DWORD PTR cyl$[rsp], eax

; 605  :     head = (vol1data[13] << 8) | vol1data[14];

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	48 6b c0 0d	 imul	 rax, rax, 13
  00128	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vol1data$[rsp]
  0012d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00131	c1 e0 08	 shl	 eax, 8
  00134	b9 01 00 00 00	 mov	 ecx, 1
  00139	48 6b c9 0e	 imul	 rcx, rcx, 14
  0013d	48 8b 54 24 50	 mov	 rdx, QWORD PTR vol1data$[rsp]
  00142	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00146	0b c1		 or	 eax, ecx
  00148	88 44 24 41	 mov	 BYTE PTR head$[rsp], al

; 606  :     rec  =  vol1data[15];

  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	48 6b c0 0f	 imul	 rax, rax, 15
  00155	48 8b 4c 24 50	 mov	 rcx, QWORD PTR vol1data$[rsp]
  0015a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015e	88 44 24 40	 mov	 BYTE PTR rec$[rsp], al

; 607  : 
; 608  :     rc = read_block( cif, cyl, head, rec, (void *)&f4dscb, &klen, 0, 0 );

  00162	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0016b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00174	48 8d 44 24 48	 lea	 rax, QWORD PTR klen$[rsp]
  00179	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017e	48 8d 44 24 60	 lea	 rax, QWORD PTR f4dscb$[rsp]
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR rec$[rsp]
  0018e	44 0f b6 44 24
	41		 movzx	 r8d, BYTE PTR head$[rsp]
  00194	8b 54 24 5c	 mov	 edx, DWORD PTR cyl$[rsp]
  00198	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  001a6	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 609  : 
; 610  :     if (rc < 0)

  001aa	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  001af	7d 07		 jge	 SHORT $LN4@do_ls_cif

; 611  :         return -1;

  001b1	b8 ff ff ff ff	 mov	 eax, -1
  001b6	eb 7f		 jmp	 SHORT $LN1@do_ls_cif
$LN4@do_ls_cif:

; 612  : 
; 613  :     if (rc > 0)

  001b8	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  001bd	7e 5a		 jle	 SHORT $LN5@do_ls_cif

; 614  :     {
; 615  :         // "%s record not found"
; 616  :         FWRMSG( stderr, HHC02471, "E", "Format 4 DSCB" );

  001bf	b9 02 00 00 00	 mov	 ecx, 2
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159996
  001d1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159997
  001dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159998
  001e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159999
  00200	ba 68 02 00 00	 mov	 edx, 616		; 00000268H
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160000
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 617  :         return -1;

  00212	b8 ff ff ff ff	 mov	 eax, -1
  00217	eb 1e		 jmp	 SHORT $LN1@do_ls_cif
$LN5@do_ls_cif:

; 618  :     }
; 619  : 
; 620  :     return list_contents( cif, volser, &f4dscb->ds4vtoce );

  00219	48 8b 44 24 60	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0021e	48 83 c0 69	 add	 rax, 105		; 00000069H
  00222	4c 8b c0	 mov	 r8, rax
  00225	48 8d 54 24 68	 lea	 rdx, QWORD PTR volser$[rsp]
  0022a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00232	e8 00 00 00 00	 call	 list_contents
$LN1@do_ls_cif:

; 621  : }

  00237	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023c	48 33 cc	 xor	 rcx, rsp
  0023f	e8 00 00 00 00	 call	 __security_check_cookie
  00244	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0024b	c3		 ret	 0
do_ls_cif ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
f1dscb$1 = 80
tmpstr$2 = 88
cext$ = 96
chead$ = 100
ccyl$ = 104
i$3 = 108
tv334 = 112
space$4 = 116
tv407 = 120
ecyl$ = 124
ptr$5 = 128
tv384 = 136
lrecl$6 = 140
numext$7 = 144
tv497 = 148
kl$8 = 152
ehead$ = 156
value$9 = 160
dl$10 = 168
tv164 = 172
tv188 = 176
tv242 = 180
rc$11 = 184
rechdr$12 = 192
tv185 = 200
tv201 = 208
tv203 = 216
tv215 = 224
tv217 = 232
tv345 = 240
tv540 = 248
txtrecfm$13 = 256
dsname$14 = 264
__$ArrayPad$ = 312
cif$ = 336
volser$ = 344
extent$ = 352
list_contents PROC

; 321  : {

$LN79:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 322  :     u_int cext  = 0;

  00029	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR cext$[rsp], 0

; 323  :     u_int ccyl  = (extent[cext].xtbcyl[0] << 8) | extent[cext].xtbcyl[1];

  00031	8b 44 24 60	 mov	 eax, DWORD PTR cext$[rsp]
  00035	48 6b c0 0a	 imul	 rax, rax, 10
  00039	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00041	48 03 c8	 add	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 6b c9 00	 imul	 rcx, rcx, 0
  00050	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  00055	c1 e0 08	 shl	 eax, 8
  00058	8b 4c 24 60	 mov	 ecx, DWORD PTR cext$[rsp]
  0005c	48 6b c9 0a	 imul	 rcx, rcx, 10
  00060	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00068	48 03 d1	 add	 rdx, rcx
  0006b	48 8b ca	 mov	 rcx, rdx
  0006e	ba 01 00 00 00	 mov	 edx, 1
  00073	48 6b d2 01	 imul	 rdx, rdx, 1
  00077	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  0007c	0b c1		 or	 eax, ecx
  0007e	89 44 24 68	 mov	 DWORD PTR ccyl$[rsp], eax

; 324  :     u_int chead = (extent[cext].xtbtrk[0] << 8) | extent[cext].xtbtrk[1];

  00082	8b 44 24 60	 mov	 eax, DWORD PTR cext$[rsp]
  00086	48 6b c0 0a	 imul	 rax, rax, 10
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00092	48 03 c8	 add	 rcx, rax
  00095	48 8b c1	 mov	 rax, rcx
  00098	b9 01 00 00 00	 mov	 ecx, 1
  0009d	48 6b c9 00	 imul	 rcx, rcx, 0
  000a1	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  000a6	c1 e0 08	 shl	 eax, 8
  000a9	8b 4c 24 60	 mov	 ecx, DWORD PTR cext$[rsp]
  000ad	48 6b c9 0a	 imul	 rcx, rcx, 10
  000b1	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  000b9	48 03 d1	 add	 rdx, rcx
  000bc	48 8b ca	 mov	 rcx, rdx
  000bf	ba 01 00 00 00	 mov	 edx, 1
  000c4	48 6b d2 01	 imul	 rdx, rdx, 1
  000c8	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  000cd	0b c1		 or	 eax, ecx
  000cf	89 44 24 64	 mov	 DWORD PTR chead$[rsp], eax

; 325  :     u_int ecyl  = (extent[cext].xtecyl[0] << 8) | extent[cext].xtecyl[1];

  000d3	8b 44 24 60	 mov	 eax, DWORD PTR cext$[rsp]
  000d7	48 6b c0 0a	 imul	 rax, rax, 10
  000db	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	b9 01 00 00 00	 mov	 ecx, 1
  000ee	48 6b c9 00	 imul	 rcx, rcx, 0
  000f2	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  000f7	c1 e0 08	 shl	 eax, 8
  000fa	8b 4c 24 60	 mov	 ecx, DWORD PTR cext$[rsp]
  000fe	48 6b c9 0a	 imul	 rcx, rcx, 10
  00102	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0010a	48 03 d1	 add	 rdx, rcx
  0010d	48 8b ca	 mov	 rcx, rdx
  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	48 6b d2 01	 imul	 rdx, rdx, 1
  00119	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  0011e	0b c1		 or	 eax, ecx
  00120	89 44 24 7c	 mov	 DWORD PTR ecyl$[rsp], eax

; 326  :     u_int ehead = (extent[cext].xtetrk[0] << 8) | extent[cext].xtetrk[1];

  00124	8b 44 24 60	 mov	 eax, DWORD PTR cext$[rsp]
  00128	48 6b c0 0a	 imul	 rax, rax, 10
  0012c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00134	48 03 c8	 add	 rcx, rax
  00137	48 8b c1	 mov	 rax, rcx
  0013a	b9 01 00 00 00	 mov	 ecx, 1
  0013f	48 6b c9 00	 imul	 rcx, rcx, 0
  00143	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  00148	c1 e0 08	 shl	 eax, 8
  0014b	8b 4c 24 60	 mov	 ecx, DWORD PTR cext$[rsp]
  0014f	48 6b c9 0a	 imul	 rcx, rcx, 10
  00153	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0015b	48 03 d1	 add	 rdx, rcx
  0015e	48 8b ca	 mov	 rcx, rdx
  00161	ba 01 00 00 00	 mov	 edx, 1
  00166	48 6b d2 01	 imul	 rdx, rdx, 1
  0016a	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  0016f	0b c1		 or	 eax, ecx
  00171	89 84 24 9c 00
	00 00		 mov	 DWORD PTR ehead$[rsp], eax
$LN4@list_conte:

; 327  : 
; 328  :     EXTGUIMSG( "ETRK=%d\n", (ecyl * cif->heads) + ehead );

  00178	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0017f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00182	74 45		 je	 SHORT $LN24@list_conte
  00184	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0018c	8b 4c 24 7c	 mov	 ecx, DWORD PTR ecyl$[rsp]
  00190	0f af 48 24	 imul	 ecx, DWORD PTR [rax+36]
  00194	8b c1		 mov	 eax, ecx
  00196	03 84 24 9c 00
	00 00		 add	 eax, DWORD PTR ehead$[rsp]
  0019d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  001a4	b9 02 00 00 00	 mov	 ecx, 2
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001af	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  001b6	44 8b c1	 mov	 r8d, ecx
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159872
  001c0	48 8b c8	 mov	 rcx, rax
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN24@list_conte:
  001c9	33 c0		 xor	 eax, eax
  001cb	85 c0		 test	 eax, eax
  001cd	75 a9		 jne	 SHORT $LN4@list_conte

; 329  : 
; 330  :     LOGMSG( "\nVOLSER:  %-6s    \"%s\"\n\n", volser, cif->fname );

  001cf	b9 01 00 00 00	 mov	 ecx, 1
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001da	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001e2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ea	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  001f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159873
  001fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00203	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00208	41 b9 03 00 00
	00		 mov	 r9d, 3
  0020e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159874
  00215	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159875
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 331  : 
; 332  :     if (runflgs & rf_header)

  00227	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0022d	83 e0 08	 and	 eax, 8
  00230	85 c0		 test	 eax, eax
  00232	0f 84 04 02 00
	00		 je	 $LN25@list_conte

; 333  :     {
; 334  :         /* display column headers allowing for optional columns */
; 335  : 
; 336  :         LOGMSG("%*s%s", -dsnlen, "Dsname",

  00238	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0023e	83 e0 01	 and	 eax, 1
  00241	85 c0		 test	 eax, eax
  00243	74 11		 je	 SHORT $LN66@list_conte
  00245	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159877
  0024c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  00254	eb 0f		 jmp	 SHORT $LN67@list_conte
$LN66@list_conte:
  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159878
  0025d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
$LN67@list_conte:
  00265	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR dsnlen
  0026b	f7 d8		 neg	 eax
  0026d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  00274	b9 01 00 00 00	 mov	 ecx, 1
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  00287	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159879
  00293	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00298	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  0029f	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159880
  002aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159881
  002c1	ba 51 01 00 00	 mov	 edx, 337		; 00000151H
  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159882
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 337  :                                        runflgs & rf_caldate ? "  Created " : " CREDT");
; 338  :         LOGMSG(runflgs & rf_refdate ? (runflgs & rf_caldate ? " Last Ref." : " REFDT") : "");

  002d3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  002d9	83 e0 04	 and	 eax, 4
  002dc	85 c0		 test	 eax, eax
  002de	74 3f		 je	 SHORT $LN70@list_conte
  002e0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  002e6	83 e0 01	 and	 eax, 1
  002e9	85 c0		 test	 eax, eax
  002eb	74 11		 je	 SHORT $LN68@list_conte
  002ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159883
  002f4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  002fc	eb 0f		 jmp	 SHORT $LN69@list_conte
$LN68@list_conte:
  002fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159884
  00305	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
$LN69@list_conte:
  0030d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv201[rsp]
  00315	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
  0031d	eb 0f		 jmp	 SHORT $LN71@list_conte
$LN70@list_conte:
  0031f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159885
  00326	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
$LN71@list_conte:
  0032e	b9 01 00 00 00	 mov	 ecx, 1
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00339	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv203[rsp]
  00341	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00346	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00351	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159886
  00358	ba 52 01 00 00	 mov	 edx, 338		; 00000152H
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159887
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 339  :         LOGMSG(runflgs & rf_expdate ? (runflgs & rf_caldate ? " Exp. Date" : " EXPDT") : "");

  0036a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00370	83 e0 02	 and	 eax, 2
  00373	85 c0		 test	 eax, eax
  00375	74 3f		 je	 SHORT $LN74@list_conte
  00377	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0037d	83 e0 01	 and	 eax, 1
  00380	85 c0		 test	 eax, eax
  00382	74 11		 je	 SHORT $LN72@list_conte
  00384	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159888
  0038b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  00393	eb 0f		 jmp	 SHORT $LN73@list_conte
$LN72@list_conte:
  00395	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159889
  0039c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN73@list_conte:
  003a4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  003ac	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  003b4	eb 0f		 jmp	 SHORT $LN75@list_conte
$LN74@list_conte:
  003b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159890
  003bd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
$LN75@list_conte:
  003c5	b9 01 00 00 00	 mov	 ecx, 1
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv217[rsp]
  003d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159891
  003ef	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159892
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 340  : 
; 341  :         LOGMSG(" ORG RECFM LRECL BLKSZ Key  Trks%%Use#Ext 2ndry_alloc\n");

  00401	b9 01 00 00 00	 mov	 ecx, 1
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159893
  00413	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00418	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00423	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159894
  0042a	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  0042f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159895
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@list_conte:
$LN78@list_conte:
$LN7@list_conte:

; 342  :     }
; 343  : 
; 344  :     do {
; 345  :         BYTE *ptr;
; 346  :         int rc = read_track( cif, ccyl, chead );

  0043c	44 0f b6 44 24
	64		 movzx	 r8d, BYTE PTR chead$[rsp]
  00442	8b 54 24 68	 mov	 edx, DWORD PTR ccyl$[rsp]
  00446	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00454	89 84 24 b8 00
	00 00		 mov	 DWORD PTR rc$11[rsp], eax
$LN10@list_conte:

; 347  : 
; 348  :         EXTGUIMSG( "CTRK=%d\n", (ccyl * cif->heads) + chead );

  0045b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00462	83 38 00	 cmp	 DWORD PTR [rax], 0
  00465	74 42		 je	 SHORT $LN26@list_conte
  00467	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0046f	8b 4c 24 68	 mov	 ecx, DWORD PTR ccyl$[rsp]
  00473	0f af 48 24	 imul	 ecx, DWORD PTR [rax+36]
  00477	8b c1		 mov	 eax, ecx
  00479	03 44 24 64	 add	 eax, DWORD PTR chead$[rsp]
  0047d	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv242[rsp], eax
  00484	b9 02 00 00 00	 mov	 ecx, 2
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0048f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv242[rsp]
  00496	44 8b c1	 mov	 r8d, ecx
  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159897
  004a0	48 8b c8	 mov	 rcx, rax
  004a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN26@list_conte:
  004a9	33 c0		 xor	 eax, eax
  004ab	85 c0		 test	 eax, eax
  004ad	75 ac		 jne	 SHORT $LN10@list_conte

; 349  : 
; 350  :         if (rc < 0)

  004af	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR rc$11[rsp], 0
  004b7	7d 0a		 jge	 SHORT $LN27@list_conte

; 351  :             return -1;

  004b9	b8 ff ff ff ff	 mov	 eax, -1
  004be	e9 ae 08 00 00	 jmp	 $LN1@list_conte
$LN27@list_conte:

; 352  : 
; 353  :         ptr = cif->trkbuf + CKD_TRKHDR_SIZE;

  004c3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  004cb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004cf	48 83 c0 05	 add	 rax, 5
  004d3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ptr$5[rsp], rax
$LN11@list_conte:

; 354  : 
; 355  :         while (!end_of_track( ptr ))

  004db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ptr$5[rsp]
  004e3	e8 00 00 00 00	 call	 end_of_track
  004e8	85 c0		 test	 eax, eax
  004ea	0f 85 3b 07 00
	00		 jne	 $LN12@list_conte

; 356  :         {
; 357  : 
; 358  :             CKD_RECHDR *rechdr = (CKD_RECHDR*)ptr;

  004f0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ptr$5[rsp]
  004f8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR rechdr$12[rsp], rax

; 359  : 
; 360  :             int kl = rechdr->klen;

  00500	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR rechdr$12[rsp]
  00508	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0050c	89 84 24 98 00
	00 00		 mov	 DWORD PTR kl$8[rsp], eax

; 361  :             int dl = (rechdr->dlen[0] << 8) | rechdr->dlen[1];

  00513	b8 01 00 00 00	 mov	 eax, 1
  00518	48 6b c0 00	 imul	 rax, rax, 0
  0051c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$12[rsp]
  00524	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  00529	c1 e0 08	 shl	 eax, 8
  0052c	b9 01 00 00 00	 mov	 ecx, 1
  00531	48 6b c9 01	 imul	 rcx, rcx, 1
  00535	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR rechdr$12[rsp]
  0053d	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00542	0b c1		 or	 eax, ecx
  00544	89 84 24 a8 00
	00 00		 mov	 DWORD PTR dl$10[rsp], eax

; 362  : 
; 363  :             FORMAT1_DSCB *f1dscb = (FORMAT1_DSCB*) (ptr + CKD_RECHDR_SIZE);

  0054b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ptr$5[rsp]
  00553	48 83 c0 08	 add	 rax, 8
  00557	48 89 44 24 50	 mov	 QWORD PTR f1dscb$1[rsp], rax

; 364  : 
; 365  : //*debug*/   LOGMSG("F1DSCB\n");
; 366  : //*debug*/   data_dump(f1dscb, sizeof(FORMAT1_DSCB));
; 367  : 
; 368  :             char dsname[ sizeof( f1dscb->ds1dsnam ) + 1 ];
; 369  :             char txtrecfm[5] = "";                    /* recfm text */

  0055c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159899
  00563	88 84 24 00 01
	00 00		 mov	 BYTE PTR txtrecfm$13[rsp], al
  0056a	48 8d 84 24 01
	01 00 00	 lea	 rax, QWORD PTR txtrecfm$13[rsp+1]
  00572	48 8b f8	 mov	 rdi, rax
  00575	33 c0		 xor	 eax, eax
  00577	b9 04 00 00 00	 mov	 ecx, 4
  0057c	f3 aa		 rep stosb

; 370  :             char *tmpstr;
; 371  : 
; 372  :             int lrecl;
; 373  :             int numext;
; 374  :             int space;
; 375  : 
; 376  :             double value;
; 377  : 
; 378  :             make_asciiz( dsname, sizeof( dsname ), ptr + CKD_RECHDR_SIZE, kl );

  0057e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ptr$5[rsp]
  00586	48 83 c0 08	 add	 rax, 8
  0058a	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR kl$8[rsp]
  00592	4c 8b c0	 mov	 r8, rax
  00595	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  0059a	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR dsname$14[rsp]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 379  : 
; 380  :             if (valid_dsname( dsname ))

  005a8	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR dsname$14[rsp]
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_valid_dsname
  005b6	85 c0		 test	 eax, eax
  005b8	0f 84 43 06 00
	00		 je	 $LN28@list_conte

; 381  :             {
; 382  :                 if (runflgs == 0 && dsnlen == DEFAULT_DSNLEN)

  005be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR runflgs, 0
  005c5	75 22		 jne	 SHORT $LN29@list_conte
  005c7	83 3d 00 00 00
	00 2c		 cmp	 DWORD PTR dsnlen, 44	; 0000002cH
  005ce	75 19		 jne	 SHORT $LN29@list_conte

; 383  :                 {
; 384  :                     prtseg("%s", dsname);

  005d0	48 8d 94 24 08
	01 00 00	 lea	 rdx, QWORD PTR dsname$14[rsp]
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159903
  005df	e8 00 00 00 00	 call	 prtseg

; 385  :                 }

  005e4	e9 07 06 00 00	 jmp	 $LN30@list_conte
$LN29@list_conte:

; 386  :                 else
; 387  :                 {
; 388  :                     prtseg("%*s", -dsnlen, dsname);

  005e9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR dsnlen
  005ef	f7 d8		 neg	 eax
  005f1	4c 8d 84 24 08
	01 00 00	 lea	 r8, QWORD PTR dsname$14[rsp]
  005f9	8b d0		 mov	 edx, eax
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159904
  00602	e8 00 00 00 00	 call	 prtseg

; 389  : 
; 390  :                     if (runflgs & rf_info)

  00607	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  0060d	83 e0 10	 and	 eax, 16
  00610	85 c0		 test	 eax, eax
  00612	0f 84 d8 05 00
	00		 je	 $LN31@list_conte

; 391  :                     {
; 392  :                         /* CREDT */
; 393  : 
; 394  :                         pdate( f1dscb->ds1credt, runflgs );

  00618	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  0061d	48 83 c0 35	 add	 rax, 53			; 00000035H
  00621	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR runflgs
  00627	48 8b c8	 mov	 rcx, rax
  0062a	e8 00 00 00 00	 call	 pdate

; 395  : 
; 396  :                         /* REFDT */
; 397  : 
; 398  :     #define ds1refdt    resv2
; 399  : 
; 400  :                         if (runflgs & rf_refdate)

  0062f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00635	83 e0 04	 and	 eax, 4
  00638	85 c0		 test	 eax, eax
  0063a	74 17		 je	 SHORT $LN32@list_conte

; 401  :                             pdatex( f1dscb->ds1refdt, runflgs );

  0063c	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  00641	48 83 c0 4b	 add	 rax, 75			; 0000004bH
  00645	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR runflgs
  0064b	48 8b c8	 mov	 rcx, rax
  0064e	e8 00 00 00 00	 call	 pdatex
$LN32@list_conte:

; 402  : 
; 403  :                         /* EXPDT */
; 404  : 
; 405  :                         if (runflgs & rf_expdate)

  00653	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR runflgs
  00659	83 e0 02	 and	 eax, 2
  0065c	85 c0		 test	 eax, eax
  0065e	74 17		 je	 SHORT $LN33@list_conte

; 406  :                             pdatex( f1dscb->ds1expdt, runflgs );

  00660	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  00665	48 83 c0 38	 add	 rax, 56			; 00000038H
  00669	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR runflgs
  0066f	48 8b c8	 mov	 rcx, rax
  00672	e8 00 00 00 00	 call	 pdatex
$LN33@list_conte:

; 407  : 
; 408  :                         /* DSORG */
; 409  : 
; 410  :                         tmpstr = "??";

  00677	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159908
  0067e	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax

; 411  : 
; 412  :                         if (f1dscb->ds1dsorg[0] == 0 ||

  00683	b8 01 00 00 00	 mov	 eax, 1
  00688	48 6b c0 00	 imul	 rax, rax, 0
  0068c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00691	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  00696	85 c0		 test	 eax, eax
  00698	74 18		 je	 SHORT $LN35@list_conte
  0069a	b8 01 00 00 00	 mov	 eax, 1
  0069f	48 6b c0 00	 imul	 rax, rax, 0
  006a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  006a8	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  006ad	83 f8 01	 cmp	 eax, 1
  006b0	75 24		 jne	 SHORT $LN34@list_conte
$LN35@list_conte:

; 413  :                             f1dscb->ds1dsorg[0] == DSORG_U)
; 414  :                         {
; 415  :                             if (f1dscb->ds1dsorg[1] == DSORG_AM)

  006b2	b8 01 00 00 00	 mov	 eax, 1
  006b7	48 6b c0 01	 imul	 rax, rax, 1
  006bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  006c0	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  006c5	83 f8 08	 cmp	 eax, 8
  006c8	75 0c		 jne	 SHORT $LN36@list_conte

; 416  :                                 tmpstr = "VS";

  006ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159912
  006d1	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
$LN36@list_conte:
$LN34@list_conte:

; 417  :                         }
; 418  : 
; 419  :                         if (f1dscb->ds1dsorg[1] == 0)

  006d6	b8 01 00 00 00	 mov	 eax, 1
  006db	48 6b c0 01	 imul	 rax, rax, 1
  006df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  006e4	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  006e9	85 c0		 test	 eax, eax
  006eb	75 6e		 jne	 SHORT $LN37@list_conte

; 420  :                         {
; 421  :                             switch (f1dscb->ds1dsorg[0] & (DSORG_PS | DSORG_DA | DSORG_PO))

  006ed	b8 01 00 00 00	 mov	 eax, 1
  006f2	48 6b c0 00	 imul	 rax, rax, 0
  006f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  006fb	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  00700	83 e0 62	 and	 eax, 98			; 00000062H
  00703	89 44 24 70	 mov	 DWORD PTR tv334[rsp], eax
  00707	83 7c 24 70 00	 cmp	 DWORD PTR tv334[rsp], 0
  0070c	74 41		 je	 SHORT $LN41@list_conte
  0070e	83 7c 24 70 02	 cmp	 DWORD PTR tv334[rsp], 2
  00713	74 2c		 je	 SHORT $LN40@list_conte
  00715	83 7c 24 70 20	 cmp	 DWORD PTR tv334[rsp], 32 ; 00000020H
  0071a	74 17		 je	 SHORT $LN39@list_conte
  0071c	83 7c 24 70 40	 cmp	 DWORD PTR tv334[rsp], 64 ; 00000040H
  00721	74 02		 je	 SHORT $LN38@list_conte
  00723	eb 36		 jmp	 SHORT $LN42@list_conte
$LN38@list_conte:

; 422  :                             {
; 423  :                                 case DSORG_PS: tmpstr = "PS"; break;

  00725	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159915
  0072c	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  00731	eb 28		 jmp	 SHORT $LN13@list_conte
$LN39@list_conte:

; 424  :                                 case DSORG_DA: tmpstr = "DA"; break;

  00733	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159917
  0073a	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  0073f	eb 1a		 jmp	 SHORT $LN13@list_conte
$LN40@list_conte:

; 425  :                                 case DSORG_PO: tmpstr = "PO"; break;

  00741	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159919
  00748	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  0074d	eb 0c		 jmp	 SHORT $LN13@list_conte
$LN41@list_conte:

; 426  :                                 case 0:        tmpstr = "  "; break; /* none of the above */

  0074f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159921
  00756	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
$LN42@list_conte:
$LN13@list_conte:
$LN37@list_conte:

; 427  :                                 default: /* don't change? */  break; /* multiple bits set */
; 428  :                             }
; 429  :                         }
; 430  :                         prtseg(" %s%s", tmpstr, f1dscb->ds1dsorg[0] & DSORG_U ? "U" : " ");

  0075b	b8 01 00 00 00	 mov	 eax, 1
  00760	48 6b c0 00	 imul	 rax, rax, 0
  00764	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00769	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  0076e	83 e0 01	 and	 eax, 1
  00771	85 c0		 test	 eax, eax
  00773	74 11		 je	 SHORT $LN76@list_conte
  00775	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159923
  0077c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv345[rsp], rax
  00784	eb 0f		 jmp	 SHORT $LN77@list_conte
$LN76@list_conte:
  00786	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159924
  0078d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv345[rsp], rax
$LN77@list_conte:
  00795	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR tv345[rsp]
  0079d	48 8b 54 24 58	 mov	 rdx, QWORD PTR tmpstr$2[rsp]
  007a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159925
  007a9	e8 00 00 00 00	 call	 prtseg

; 431  : 
; 432  :                         /* RECFM */
; 433  : 
; 434  :                         switch (f1dscb->ds1recfm & RECFM_FORMAT)

  007ae	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  007b3	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  007b7	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  007bc	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv384[rsp], eax
  007c3	83 bc 24 88 00
	00 00 40	 cmp	 DWORD PTR tv384[rsp], 64 ; 00000040H
  007cb	74 1d		 je	 SHORT $LN44@list_conte
  007cd	81 bc 24 88 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR tv384[rsp], 128 ; 00000080H
  007d8	74 02		 je	 SHORT $LN43@list_conte
  007da	eb 1c		 jmp	 SHORT $LN45@list_conte
$LN43@list_conte:

; 435  :                         {
; 436  :                             case RECFM_FORMAT_F: tmpstr = "F"; break;

  007dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159927
  007e3	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  007e8	eb 1a		 jmp	 SHORT $LN15@list_conte
$LN44@list_conte:

; 437  :                             case RECFM_FORMAT_V: tmpstr = "V"; break;

  007ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159929
  007f1	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  007f6	eb 0c		 jmp	 SHORT $LN15@list_conte
$LN45@list_conte:

; 438  :                             default:             tmpstr = "U"; break;

  007f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159931
  007ff	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
$LN15@list_conte:

; 439  :                         }
; 440  :                         STRLCPY( txtrecfm, tmpstr );

  00804	41 b8 05 00 00
	00		 mov	 r8d, 5
  0080a	48 8b 54 24 58	 mov	 rdx, QWORD PTR tmpstr$2[rsp]
  0080f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txtrecfm$13[rsp]
  00817	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 441  : 
; 442  :                         if (f1dscb->ds1recfm & RECFM_BLOCKED)  STRLCAT( txtrecfm, "B" );

  0081d	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  00822	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  00826	83 e0 10	 and	 eax, 16
  00829	85 c0		 test	 eax, eax
  0082b	74 1b		 je	 SHORT $LN46@list_conte
  0082d	41 b8 05 00 00
	00		 mov	 r8d, 5
  00833	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159933
  0083a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txtrecfm$13[rsp]
  00842	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN46@list_conte:

; 443  :                         if (f1dscb->ds1recfm & RECFM_SPANNED)  STRLCAT( txtrecfm, "S" );

  00848	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  0084d	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  00851	83 e0 08	 and	 eax, 8
  00854	85 c0		 test	 eax, eax
  00856	74 1b		 je	 SHORT $LN47@list_conte
  00858	41 b8 05 00 00
	00		 mov	 r8d, 5
  0085e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159935
  00865	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txtrecfm$13[rsp]
  0086d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN47@list_conte:

; 444  : 
; 445  :                         switch (f1dscb->ds1recfm & RECFM_CTLCHAR)

  00873	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  00878	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  0087c	83 e0 06	 and	 eax, 6
  0087f	89 44 24 78	 mov	 DWORD PTR tv407[rsp], eax
  00883	83 7c 24 78 02	 cmp	 DWORD PTR tv407[rsp], 2
  00888	74 1e		 je	 SHORT $LN49@list_conte
  0088a	83 7c 24 78 04	 cmp	 DWORD PTR tv407[rsp], 4
  0088f	74 09		 je	 SHORT $LN48@list_conte
  00891	83 7c 24 78 06	 cmp	 DWORD PTR tv407[rsp], 6
  00896	74 1e		 je	 SHORT $LN50@list_conte
  00898	eb 2a		 jmp	 SHORT $LN51@list_conte
$LN48@list_conte:

; 446  :                         {
; 447  :                             case RECFM_CTLCHAR_A:                   tmpstr = "A"; break;

  0089a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159937
  008a1	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  008a6	eb 28		 jmp	 SHORT $LN17@list_conte
$LN49@list_conte:

; 448  :                             case RECFM_CTLCHAR_M:                   tmpstr = "M"; break;

  008a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159939
  008af	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  008b4	eb 1a		 jmp	 SHORT $LN17@list_conte
$LN50@list_conte:

; 449  :                             case RECFM_CTLCHAR_A | RECFM_CTLCHAR_M: tmpstr = "?"; break; /* both ?! */

  008b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159941
  008bd	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  008c2	eb 0c		 jmp	 SHORT $LN17@list_conte
$LN51@list_conte:

; 450  :                             default:                                tmpstr = "";  break; /* neither */

  008c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159943
  008cb	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
$LN17@list_conte:

; 451  :                         }
; 452  :                         STRLCAT( txtrecfm, tmpstr );

  008d0	41 b8 05 00 00
	00		 mov	 r8d, 5
  008d6	48 8b 54 24 58	 mov	 rdx, QWORD PTR tmpstr$2[rsp]
  008db	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txtrecfm$13[rsp]
  008e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 453  : 
; 454  :                         if (f1dscb->ds1recfm & RECFM_TRKOFLOW)  STRLCAT( txtrecfm, "T" );

  008e9	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  008ee	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  008f2	83 e0 20	 and	 eax, 32			; 00000020H
  008f5	85 c0		 test	 eax, eax
  008f7	74 1b		 je	 SHORT $LN52@list_conte
  008f9	41 b8 05 00 00
	00		 mov	 r8d, 5
  008ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159945
  00906	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txtrecfm$13[rsp]
  0090e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN52@list_conte:

; 455  : 
; 456  :                         prtseg(" %-5s", txtrecfm);

  00914	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR txtrecfm$13[rsp]
  0091c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159946
  00923	e8 00 00 00 00	 call	 prtseg

; 457  : 
; 458  :                         /* LRECL */
; 459  : 
; 460  :                         lrecl = (f1dscb->ds1lrecl[0] << 8) | f1dscb->ds1lrecl[1];

  00928	b8 01 00 00 00	 mov	 eax, 1
  0092d	48 6b c0 00	 imul	 rax, rax, 0
  00931	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00936	0f b6 44 01 58	 movzx	 eax, BYTE PTR [rcx+rax+88]
  0093b	c1 e0 08	 shl	 eax, 8
  0093e	b9 01 00 00 00	 mov	 ecx, 1
  00943	48 6b c9 01	 imul	 rcx, rcx, 1
  00947	48 8b 54 24 50	 mov	 rdx, QWORD PTR f1dscb$1[rsp]
  0094c	0f b6 4c 0a 58	 movzx	 ecx, BYTE PTR [rdx+rcx+88]
  00951	0b c1		 or	 eax, ecx
  00953	89 84 24 8c 00
	00 00		 mov	 DWORD PTR lrecl$6[rsp], eax

; 461  : 
; 462  :                         if (lrecl) prtseg(" %5d", lrecl);

  0095a	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR lrecl$6[rsp], 0
  00962	74 15		 je	 SHORT $LN53@list_conte
  00964	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR lrecl$6[rsp]
  0096b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159949
  00972	e8 00 00 00 00	 call	 prtseg
  00977	eb 0c		 jmp	 SHORT $LN54@list_conte
$LN53@list_conte:

; 463  :                         else       prtseg("      ");

  00979	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159950
  00980	e8 00 00 00 00	 call	 prtseg
$LN54@list_conte:

; 464  : 
; 465  :                         /* BLKSZ, KEYLN */
; 466  : 
; 467  :                         phword( f1dscb->ds1blkl );     /* BLKSZ */

  00985	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  0098a	48 83 c0 56	 add	 rax, 86			; 00000056H
  0098e	48 8b c8	 mov	 rcx, rax
  00991	e8 00 00 00 00	 call	 phword

; 468  :                         pbyte( &f1dscb->ds1keyl );     /* KEYLN */

  00996	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  0099b	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  0099f	48 8b c8	 mov	 rcx, rax
  009a2	e8 00 00 00 00	 call	 pbyte

; 469  : 
; 470  :                         /* space allocated */
; 471  : 
; 472  :                         numext = f1dscb->ds1noepv;

  009a7	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  009ac	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  009b0	89 84 24 90 00
	00 00		 mov	 DWORD PTR numext$7[rsp], eax

; 473  :     //*debug*/           LOGMSG("NUMEXT = %5d", numext);
; 474  : 
; 475  :                         space = extents_array( &f1dscb->ds1ext1, 3, &numext, cif->heads );

  009b7	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  009bc	48 83 c0 69	 add	 rax, 105		; 00000069H
  009c0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  009c8	44 8b 49 24	 mov	 r9d, DWORD PTR [rcx+36]
  009cc	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR numext$7[rsp]
  009d4	ba 03 00 00 00	 mov	 edx, 3
  009d9	48 8b c8	 mov	 rcx, rax
  009dc	e8 00 00 00 00	 call	 extents_array
  009e1	89 44 24 74	 mov	 DWORD PTR space$4[rsp], eax

; 476  :     //*debug*/           LOGMSG("SPACE nach extents_array = %d", space);
; 477  : 
; 478  :                         chainf3( &space, &f1dscb->ds1ptrds[0], &numext );

  009e5	b8 01 00 00 00	 mov	 eax, 1
  009ea	48 6b c0 00	 imul	 rax, rax, 0
  009ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  009f3	48 8d 84 01 87
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+135]
  009fb	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR numext$7[rsp]
  00a03	48 8b d0	 mov	 rdx, rax
  00a06	48 8d 4c 24 74	 lea	 rcx, QWORD PTR space$4[rsp]
  00a0b	e8 00 00 00 00	 call	 chainf3

; 479  :     //*debug*/           LOGMSG("SPACE nach chainf3 = %d", space);
; 480  : 
; 481  :                         prtseg(" %5d", space);

  00a10	8b 54 24 74	 mov	 edx, DWORD PTR space$4[rsp]
  00a14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159951
  00a1b	e8 00 00 00 00	 call	 prtseg

; 482  : 
; 483  :                         /* % of allocated spaced used */
; 484  : 
; 485  :                         /* fraction of last track used = 1 - ds1trbal / trkzize */
; 486  :                         value = 1.0 - (double)hword( &f1dscb->ds1trbal[0] ) / (cif->trksz);

  00a20	b8 01 00 00 00	 mov	 eax, 1
  00a25	48 6b c0 00	 imul	 rax, rax, 0
  00a29	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00a2e	48 8d 44 01 65	 lea	 rax, QWORD PTR [rcx+rax+101]
  00a33	48 8b c8	 mov	 rcx, rax
  00a36	e8 00 00 00 00	 call	 hword
  00a3b	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00a3f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00a47	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00a4a	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  00a4f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00a53	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00a5b	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00a5f	0f 28 c1	 movaps	 xmm0, xmm1
  00a62	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR value$9[rsp], xmm0

; 487  : 
; 488  :                         /* add in the number of full tracks used */
; 489  :                         value += hword( &f1dscb->ds1lstar[0] );

  00a6b	b8 01 00 00 00	 mov	 eax, 1
  00a70	48 6b c0 00	 imul	 rax, rax, 0
  00a74	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00a79	48 8d 44 01 62	 lea	 rax, QWORD PTR [rcx+rax+98]
  00a7e	48 8b c8	 mov	 rcx, rax
  00a81	e8 00 00 00 00	 call	 hword
  00a86	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00a8a	f2 0f 10 8c 24
	a0 00 00 00	 movsd	 xmm1, QWORD PTR value$9[rsp]
  00a93	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00a97	0f 28 c1	 movaps	 xmm0, xmm1
  00a9a	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR value$9[rsp], xmm0

; 490  : 
; 491  :                         if (!space)

  00aa3	83 7c 24 74 00	 cmp	 DWORD PTR space$4[rsp], 0
  00aa8	75 0e		 jne	 SHORT $LN55@list_conte

; 492  :                             prtseg("    ");

  00aaa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159954
  00ab1	e8 00 00 00 00	 call	 prtseg
  00ab6	eb 3e		 jmp	 SHORT $LN56@list_conte
$LN55@list_conte:

; 493  :                         else
; 494  :                         {
; 495  :                             value = value * 100 / space; /* % space used */

  00ab8	f2 0f 10 84 24
	a0 00 00 00	 movsd	 xmm0, QWORD PTR value$9[rsp]
  00ac1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00ac9	f2 0f 2a 4c 24
	74		 cvtsi2sd xmm1, DWORD PTR space$4[rsp]
  00acf	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00ad3	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR value$9[rsp], xmm0

; 496  :                             prtseg(" %3.0f", value);

  00adc	f2 0f 10 8c 24
	a0 00 00 00	 movsd	 xmm1, QWORD PTR value$9[rsp]
  00ae5	66 48 0f 7e ca	 movq	 rdx, xmm1
  00aea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159955
  00af1	e8 00 00 00 00	 call	 prtseg
$LN56@list_conte:

; 497  :                         }
; 498  : 
; 499  :                         /* Number of extents */
; 500  : 
; 501  :                         pbyte( &f1dscb->ds1noepv );  /* #EXT */

  00af6	48 8b 44 24 50	 mov	 rax, QWORD PTR f1dscb$1[rsp]
  00afb	48 83 c0 3b	 add	 rax, 59			; 0000003bH
  00aff	48 8b c8	 mov	 rcx, rax
  00b02	e8 00 00 00 00	 call	 pbyte

; 502  : 
; 503  :                         /* SCALO */
; 504  : 
; 505  :                         if (DS1SCALO_UNITS_ABSTR
; 506  :                             == (f1dscb->ds1scalo[0] & DS1SCALO_UNITS))

  00b07	b8 01 00 00 00	 mov	 eax, 1
  00b0c	48 6b c0 00	 imul	 rax, rax, 0
  00b10	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00b15	0f b6 44 01 5e	 movzx	 eax, BYTE PTR [rcx+rax+94]
  00b1a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00b1f	85 c0		 test	 eax, eax
  00b21	75 18		 jne	 SHORT $LN57@list_conte

; 507  :                         {
; 508  :                             prtseg(" %-11s", "ABSTR");

  00b23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159958
  00b2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159959
  00b31	e8 00 00 00 00	 call	 prtseg

; 509  :                         }

  00b36	e9 b5 00 00 00	 jmp	 $LN58@list_conte
$LN57@list_conte:

; 510  :                         else
; 511  :                         {
; 512  :                             tmpstr = "CYL";

  00b3b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159960
  00b42	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax

; 513  : 
; 514  :                             switch (f1dscb->ds1scalo[0] & DS1SCALO_UNITS)

  00b47	b8 01 00 00 00	 mov	 eax, 1
  00b4c	48 6b c0 00	 imul	 rax, rax, 0
  00b50	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00b55	0f b6 44 01 5e	 movzx	 eax, BYTE PTR [rcx+rax+94]
  00b5a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00b5f	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv497[rsp], eax
  00b66	83 bc 24 94 00
	00 00 40	 cmp	 DWORD PTR tv497[rsp], 64 ; 00000040H
  00b6e	74 0f		 je	 SHORT $LN59@list_conte
  00b70	81 bc 24 94 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR tv497[rsp], 128 ; 00000080H
  00b7b	74 10		 je	 SHORT $LN60@list_conte
  00b7d	eb 1a		 jmp	 SHORT $LN19@list_conte
$LN59@list_conte:

; 515  :                             {
; 516  :                                 case DS1SCALO_UNITS_BLK: tmpstr = "BLK"; break;

  00b7f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159962
  00b86	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
  00b8b	eb 0c		 jmp	 SHORT $LN19@list_conte
$LN60@list_conte:

; 517  :                                 case DS1SCALO_UNITS_TRK: tmpstr = "TRK"; break;

  00b8d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159964
  00b94	48 89 44 24 58	 mov	 QWORD PTR tmpstr$2[rsp], rax
$LN19@list_conte:

; 518  :                                 case DS1SCALO_UNITS_CYL:                 break;
; 519  :                             }
; 520  :                             prtseg(" %3s%8d", tmpstr,

  00b99	b8 01 00 00 00	 mov	 eax, 1
  00b9e	48 6b c0 01	 imul	 rax, rax, 1
  00ba2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f1dscb$1[rsp]
  00ba7	0f b6 44 01 5e	 movzx	 eax, BYTE PTR [rcx+rax+94]
  00bac	c1 e0 08	 shl	 eax, 8
  00baf	b9 01 00 00 00	 mov	 ecx, 1
  00bb4	48 6b c9 02	 imul	 rcx, rcx, 2
  00bb8	48 8b 54 24 50	 mov	 rdx, QWORD PTR f1dscb$1[rsp]
  00bbd	0f b6 4c 0a 5e	 movzx	 ecx, BYTE PTR [rdx+rcx+94]
  00bc2	03 c1		 add	 eax, ecx
  00bc4	c1 e0 08	 shl	 eax, 8
  00bc7	b9 01 00 00 00	 mov	 ecx, 1
  00bcc	48 6b c9 03	 imul	 rcx, rcx, 3
  00bd0	48 8b 54 24 50	 mov	 rdx, QWORD PTR f1dscb$1[rsp]
  00bd5	0f b6 4c 0a 5e	 movzx	 ecx, BYTE PTR [rdx+rcx+94]
  00bda	03 c1		 add	 eax, ecx
  00bdc	44 8b c0	 mov	 r8d, eax
  00bdf	48 8b 54 24 58	 mov	 rdx, QWORD PTR tmpstr$2[rsp]
  00be4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159966
  00beb	e8 00 00 00 00	 call	 prtseg
$LN58@list_conte:
$LN31@list_conte:
$LN30@list_conte:

; 521  :                                 (((f1dscb->ds1scalo[1]  << 8) +
; 522  :                                    f1dscb->ds1scalo[2]) << 8) +
; 523  :                                    f1dscb->ds1scalo[3]);
; 524  :                         }
; 525  : 
; 526  :                     } /* end if (runflgs & rf_info) */
; 527  :                 }
; 528  : 
; 529  :                 prtseg("\n");

  00bf0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159967
  00bf7	e8 00 00 00 00	 call	 prtseg

; 530  :                 print_line_from_segs();

  00bfc	e8 00 00 00 00	 call	 print_line_from_segs
$LN28@list_conte:

; 531  : 
; 532  :             } /* end if (valid_dsname( dsname )) */
; 533  : 
; 534  :             ptr += CKD_RECHDR_SIZE + kl + dl;

  00c01	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR kl$8[rsp]
  00c09	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR dl$10[rsp]
  00c11	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR ptr$5[rsp]
  00c19	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00c1e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ptr$5[rsp], rax

; 535  : 
; 536  :         } /* end while (!end_of_track( ptr )) */

  00c26	e9 b0 f8 ff ff	 jmp	 $LN11@list_conte
$LN12@list_conte:

; 537  : 
; 538  :         chead++;

  00c2b	8b 44 24 64	 mov	 eax, DWORD PTR chead$[rsp]
  00c2f	ff c0		 inc	 eax
  00c31	89 44 24 64	 mov	 DWORD PTR chead$[rsp], eax

; 539  : 
; 540  :         if (chead >= cif->heads)

  00c35	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00c3d	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00c40	39 44 24 64	 cmp	 DWORD PTR chead$[rsp], eax
  00c44	72 12		 jb	 SHORT $LN62@list_conte

; 541  :         {
; 542  :             ccyl++;

  00c46	8b 44 24 68	 mov	 eax, DWORD PTR ccyl$[rsp]
  00c4a	ff c0		 inc	 eax
  00c4c	89 44 24 68	 mov	 DWORD PTR ccyl$[rsp], eax

; 543  :             chead = 0;

  00c50	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR chead$[rsp], 0
$LN62@list_conte:

; 544  :         }
; 545  : 
; 546  :     } while (ccyl < ecyl || (ccyl == ecyl && chead <= ehead));

  00c58	8b 44 24 7c	 mov	 eax, DWORD PTR ecyl$[rsp]
  00c5c	39 44 24 68	 cmp	 DWORD PTR ccyl$[rsp], eax
  00c60	0f 82 d6 f7 ff
	ff		 jb	 $LN7@list_conte
  00c66	8b 44 24 7c	 mov	 eax, DWORD PTR ecyl$[rsp]
  00c6a	39 44 24 68	 cmp	 DWORD PTR ccyl$[rsp], eax
  00c6e	75 11		 jne	 SHORT $LN63@list_conte
  00c70	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR ehead$[rsp]
  00c77	39 44 24 64	 cmp	 DWORD PTR chead$[rsp], eax
  00c7b	0f 86 bb f7 ff
	ff		 jbe	 $LN78@list_conte
$LN63@list_conte:

; 547  : 
; 548  :     /* If we "printed" any lines... */
; 549  :     if (numlines)

  00c81	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numlines, 0
  00c88	0f 84 e1 00 00
	00		 je	 $LN64@list_conte

; 550  :     {
; 551  :         int i;
; 552  : 
; 553  :         /* Sort them into ascending sequence by dsname */
; 554  :         qsort( linestab, numlines, sizeof( linestab ), sort_linestab );

  00c8e	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numlines
  00c95	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:sort_linestab
  00c9c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00ca2	48 8b d0	 mov	 rdx, rax
  00ca5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR linestab
  00cac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 555  : 
; 556  :         /* NOW actually print them all for real */
; 557  :         for (i=0; i < numlines; ++i)

  00cb2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00cba	eb 0a		 jmp	 SHORT $LN23@list_conte
$LN21@list_conte:
  00cbc	8b 44 24 6c	 mov	 eax, DWORD PTR i$3[rsp]
  00cc0	ff c0		 inc	 eax
  00cc2	89 44 24 6c	 mov	 DWORD PTR i$3[rsp], eax
$LN23@list_conte:
  00cc6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numlines
  00ccc	39 44 24 6c	 cmp	 DWORD PTR i$3[rsp], eax
  00cd0	7d 7b		 jge	 SHORT $LN22@list_conte

; 558  :         {
; 559  :             LOGMSG( "%s", linestab[i] );

  00cd2	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$3[rsp]
  00cd7	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv540[rsp], rax
  00cdf	b9 01 00 00 00	 mov	 ecx, 1
  00ce4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR linestab
  00cf1	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR tv540[rsp]
  00cf9	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00cfd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159971
  00d09	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d0e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d13	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d19	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159972
  00d20	ba 2f 02 00 00	 mov	 edx, 559		; 0000022fH
  00d25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159973
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 560  :             free( (linestab[i]) );

  00d32	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$3[rsp]
  00d37	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR linestab
  00d3e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00d42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 561  :         }

  00d48	e9 6f ff ff ff	 jmp	 $LN21@list_conte
$LN22@list_conte:

; 562  : 
; 563  :         free( linestab );

  00d4d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR linestab
  00d54	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 564  :         linestab = NULL;

  00d5a	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR linestab, 0

; 565  :         numlines = 0;

  00d65	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR numlines, 0
$LN64@list_conte:

; 566  :     }
; 567  : 
; 568  :     return 0;

  00d6f	33 c0		 xor	 eax, eax
$LN1@list_conte:

; 569  : }

  00d71	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d79	48 33 cc	 xor	 rcx, rsp
  00d7c	e8 00 00 00 00	 call	 __security_check_cookie
  00d81	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  00d88	5f		 pop	 rdi
  00d89	c3		 ret	 0
list_contents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
tv128 = 0
p$ = 32
end_of_track PROC

; 120  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 121  :     return p[0] == 0xff && p[1] == 0xff && p[2] == 0xff && p[3] == 0xff

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00020	0f 85 c0 00 00
	00		 jne	 $LN3@end_of_tra
  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	48 6b c0 01	 imul	 rax, rax, 1
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0003d	0f 85 a3 00 00
	00		 jne	 $LN3@end_of_tra
  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 02	 imul	 rax, rax, 2
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0005a	0f 85 86 00 00
	00		 jne	 $LN3@end_of_tra
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	48 6b c0 03	 imul	 rax, rax, 3
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0006e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00072	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00077	75 6d		 jne	 SHORT $LN3@end_of_tra
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 04	 imul	 rax, rax, 4
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00090	75 54		 jne	 SHORT $LN3@end_of_tra
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	48 6b c0 05	 imul	 rax, rax, 5
  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000a0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a4	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000a9	75 3b		 jne	 SHORT $LN3@end_of_tra
  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 06	 imul	 rax, rax, 6
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c2	75 22		 jne	 SHORT $LN3@end_of_tra
  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	48 6b c0 07	 imul	 rax, rax, 7
  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000db	75 09		 jne	 SHORT $LN3@end_of_tra
  000dd	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv128[rsp], 1
  000e4	eb 07		 jmp	 SHORT $LN4@end_of_tra
$LN3@end_of_tra:
  000e6	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv128[rsp], 0
$LN4@end_of_tra:
  000ed	8b 04 24	 mov	 eax, DWORD PTR tv128[rsp]

; 122  :         && p[4] == 0xff && p[5] == 0xff && p[6] == 0xff && p[7] == 0xff;
; 123  : }

  000f0	48 83 c4 18	 add	 rsp, 24
  000f4	c3		 ret	 0
end_of_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
m$ = 0
d$ = 4
offset$ = 8
tv70 = 12
leap$ = 16
year$ = 48
ordinalday$ = 56
month$ = 64
day$ = 72
ordday_to_calday PROC

; 132  : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 133  :   int d, m, offset;
; 134  :   int leap = (((year % 4) == 0) &&

  00016	8b 44 24 30	 mov	 eax, DWORD PTR year$[rsp]
  0001a	99		 cdq
  0001b	83 e2 03	 and	 edx, 3
  0001e	03 c2		 add	 eax, edx
  00020	83 e0 03	 and	 eax, 3
  00023	2b c2		 sub	 eax, edx
  00025	85 c0		 test	 eax, eax
  00027	75 2e		 jne	 SHORT $LN11@ordday_to_
  00029	8b 44 24 30	 mov	 eax, DWORD PTR year$[rsp]
  0002d	99		 cdq
  0002e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00033	f7 f9		 idiv	 ecx
  00035	8b c2		 mov	 eax, edx
  00037	85 c0		 test	 eax, eax
  00039	75 12		 jne	 SHORT $LN10@ordday_to_
  0003b	8b 44 24 30	 mov	 eax, DWORD PTR year$[rsp]
  0003f	99		 cdq
  00040	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  00045	f7 f9		 idiv	 ecx
  00047	8b c2		 mov	 eax, edx
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN11@ordday_to_
$LN10@ordday_to_:
  0004d	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN12@ordday_to_
$LN11@ordday_to_:
  00057	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN12@ordday_to_:
  0005f	8b 44 24 0c	 mov	 eax, DWORD PTR tv70[rsp]
  00063	89 44 24 10	 mov	 DWORD PTR leap$[rsp], eax

; 135  :              (((year % 100) != 0) || ((year % 400) == 0)) ? 1 : 0);
; 136  : 
; 137  :   /* offset the months so that March is month 0 to deal
; 138  :      with the anomalies of February (short month, leap day) */
; 139  : 
; 140  :   if ((ordinalday <= 0) || (ordinalday > (365 + leap)))

  00067	83 7c 24 38 00	 cmp	 DWORD PTR ordinalday$[rsp], 0
  0006c	7e 0f		 jle	 SHORT $LN5@ordday_to_
  0006e	8b 44 24 10	 mov	 eax, DWORD PTR leap$[rsp]
  00072	05 6d 01 00 00	 add	 eax, 365		; 0000016dH
  00077	39 44 24 38	 cmp	 DWORD PTR ordinalday$[rsp], eax
  0007b	7e 0a		 jle	 SHORT $LN4@ordday_to_
$LN5@ordday_to_:

; 141  :       return -1;

  0007d	b8 ff ff ff ff	 mov	 eax, -1
  00082	e9 b6 00 00 00	 jmp	 $LN1@ordday_to_
$LN4@ordday_to_:

; 142  : 
; 143  :   offset = JAN_FEB_DAYS + leap;     /* 31 (Jan) + {28, 29} (Feb) */

  00087	8b 44 24 10	 mov	 eax, DWORD PTR leap$[rsp]
  0008b	83 c0 3b	 add	 eax, 59			; 0000003bH
  0008e	89 44 24 08	 mov	 DWORD PTR offset$[rsp], eax

; 144  : 
; 145  :   if (ordinalday <= offset)

  00092	8b 44 24 08	 mov	 eax, DWORD PTR offset$[rsp]
  00096	39 44 24 38	 cmp	 DWORD PTR ordinalday$[rsp], eax
  0009a	7f 08		 jg	 SHORT $LN6@ordday_to_

; 146  :       offset = - (365 - JAN_FEB_DAYS);

  0009c	c7 44 24 08 ce
	fe ff ff	 mov	 DWORD PTR offset$[rsp], -306 ; fffffffffffffeceH
$LN6@ordday_to_:

; 147  : 
; 148  :   d = ordinalday - 1 - offset;      /* ordinal day to index day and offset to 1 March */

  000a4	8b 44 24 38	 mov	 eax, DWORD PTR ordinalday$[rsp]
  000a8	ff c8		 dec	 eax
  000aa	2b 44 24 08	 sub	 eax, DWORD PTR offset$[rsp]
  000ae	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 149  : 
; 150  :   /* the months from March follow 5-month cycles of 31, 30, 31, 30, 31 days each month */
; 151  : 
; 152  :   m = d / 153;                      /* which 5-month cycle? */

  000b2	8b 44 24 04	 mov	 eax, DWORD PTR d$[rsp]
  000b6	99		 cdq
  000b7	b9 99 00 00 00	 mov	 ecx, 153		; 00000099H
  000bc	f7 f9		 idiv	 ecx
  000be	89 04 24	 mov	 DWORD PTR m$[rsp], eax

; 153  :   d -= (153 * m);                   /* day within 5-month cycle */

  000c1	69 04 24 99 00
	00 00		 imul	 eax, DWORD PTR m$[rsp], 153 ; 00000099H
  000c8	8b 4c 24 04	 mov	 ecx, DWORD PTR d$[rsp]
  000cc	2b c8		 sub	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 154  :   m *= 5;                           /* month that starts the 5-month cycle */

  000d4	6b 04 24 05	 imul	 eax, DWORD PTR m$[rsp], 5
  000d8	89 04 24	 mov	 DWORD PTR m$[rsp], eax
$LN2@ordday_to_:

; 155  : 
; 156  :   /* day of month = ((d mod (31 + 30)) mod 31 */
; 157  : 
; 158  :   while (d >= 61)                   /* body is executed 0, 1, or 2 times */

  000db	83 7c 24 04 3d	 cmp	 DWORD PTR d$[rsp], 61	; 0000003dH
  000e0	7c 16		 jl	 SHORT $LN3@ordday_to_

; 159  :   {
; 160  :       d -= 61;

  000e2	8b 44 24 04	 mov	 eax, DWORD PTR d$[rsp]
  000e6	83 e8 3d	 sub	 eax, 61			; 0000003dH
  000e9	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 161  :       m += 2;

  000ed	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  000f0	83 c0 02	 add	 eax, 2
  000f3	89 04 24	 mov	 DWORD PTR m$[rsp], eax

; 162  :   }

  000f6	eb e3		 jmp	 SHORT $LN2@ordday_to_
$LN3@ordday_to_:

; 163  : 
; 164  :   if (d >= 31)

  000f8	83 7c 24 04 1f	 cmp	 DWORD PTR d$[rsp], 31
  000fd	7c 13		 jl	 SHORT $LN7@ordday_to_

; 165  :   {
; 166  :       d -= 31;

  000ff	8b 44 24 04	 mov	 eax, DWORD PTR d$[rsp]
  00103	83 e8 1f	 sub	 eax, 31
  00106	89 44 24 04	 mov	 DWORD PTR d$[rsp], eax

; 167  :       m += 1;

  0010a	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  0010d	ff c0		 inc	 eax
  0010f	89 04 24	 mov	 DWORD PTR m$[rsp], eax
$LN7@ordday_to_:

; 168  :   }
; 169  : 
; 170  :   *day = d + 1;                     /* ordinal day of month */

  00112	8b 44 24 04	 mov	 eax, DWORD PTR d$[rsp]
  00116	ff c0		 inc	 eax
  00118	48 8b 4c 24 48	 mov	 rcx, QWORD PTR day$[rsp]
  0011d	89 01		 mov	 DWORD PTR [rcx], eax

; 171  : 
; 172  :   /* convert back to January start of year and ordinal month */
; 173  : 
; 174  :   if (m >= 10)

  0011f	83 3c 24 0a	 cmp	 DWORD PTR m$[rsp], 10
  00123	7c 09		 jl	 SHORT $LN8@ordday_to_

; 175  :       m -= 12;

  00125	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  00128	83 e8 0c	 sub	 eax, 12
  0012b	89 04 24	 mov	 DWORD PTR m$[rsp], eax
$LN8@ordday_to_:

; 176  : 
; 177  :   *month = m + 2;                   /* NB _index_ month, not ordinal month */

  0012e	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  00131	83 c0 02	 add	 eax, 2
  00134	48 8b 4c 24 40	 mov	 rcx, QWORD PTR month$[rsp]
  00139	89 01		 mov	 DWORD PTR [rcx], eax

; 178  :   return 0;

  0013b	33 c0		 xor	 eax, eax
$LN1@ordday_to_:

; 179  : }

  0013d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00141	c3		 ret	 0
ordday_to_calday ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
tv140 = 64
rc$ = 68
tv93 = 72
f3dscb$ = 80
tv90 = 88
size$ = 112
ptr$ = 120
count$ = 128
chainf3	PROC

; 264  : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 265  :     FORMAT3_DSCB *f3dscb = NULL;

  00013	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR f3dscb$[rsp], 0

; 266  :     int rc = 0; /* prime for success */

  0001c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN2@chainf3:

; 267  : 
; 268  :     while (*count > 0 && (ptr[0] || ptr[1] || ptr[2] || ptr[3] || ptr[4]))

  00024	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR count$[rsp]
  0002c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002f	0f 8e 4a 02 00
	00		 jle	 $LN3@chainf3
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	85 c0		 test	 eax, eax
  00049	75 5c		 jne	 SHORT $LN6@chainf3
  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	48 6b c0 01	 imul	 rax, rax, 1
  00054	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  00059	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005d	85 c0		 test	 eax, eax
  0005f	75 46		 jne	 SHORT $LN6@chainf3
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	48 6b c0 02	 imul	 rax, rax, 2
  0006a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  0006f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00073	85 c0		 test	 eax, eax
  00075	75 30		 jne	 SHORT $LN6@chainf3
  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	48 6b c0 03	 imul	 rax, rax, 3
  00080	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  00085	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00089	85 c0		 test	 eax, eax
  0008b	75 1a		 jne	 SHORT $LN6@chainf3
  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	48 6b c0 04	 imul	 rax, rax, 4
  00096	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  0009b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009f	85 c0		 test	 eax, eax
  000a1	0f 84 d8 01 00
	00		 je	 $LN3@chainf3
$LN6@chainf3:

; 269  :     {
; 270  : //*debug*/fprintf(stderr, "*** %d %.2x%.2x %.2x%.2x %.2x\n",
; 271  : //*debug*/        *count, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4]);
; 272  : 
; 273  :         if (read_block( cif, hword( &ptr[0] ), hword( &ptr[2] ), ptr[4],
; 274  :                         (BYTE**) &f3dscb, NULL, NULL, NULL ) == 0)

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	48 6b c0 04	 imul	 rax, rax, 4
  000b0	48 89 44 24 58	 mov	 QWORD PTR tv90[rsp], rax
  000b5	b9 01 00 00 00	 mov	 ecx, 1
  000ba	48 6b c9 02	 imul	 rcx, rcx, 2
  000be	48 8b 54 24 78	 mov	 rdx, QWORD PTR ptr$[rsp]
  000c3	48 03 d1	 add	 rdx, rcx
  000c6	48 8b ca	 mov	 rcx, rdx
  000c9	e8 00 00 00 00	 call	 hword
  000ce	89 44 24 48	 mov	 DWORD PTR tv93[rsp], eax
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	48 6b c9 00	 imul	 rcx, rcx, 0
  000db	48 8b 54 24 78	 mov	 rdx, QWORD PTR ptr$[rsp]
  000e0	48 03 d1	 add	 rdx, rcx
  000e3	48 8b ca	 mov	 rcx, rdx
  000e6	e8 00 00 00 00	 call	 hword
  000eb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000fd	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00106	48 8d 4c 24 50	 lea	 rcx, QWORD PTR f3dscb$[rsp]
  0010b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00110	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ptr$[rsp]
  00115	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv90[rsp]
  0011a	44 0f b6 0c 11	 movzx	 r9d, BYTE PTR [rcx+rdx]
  0011f	8b 4c 24 48	 mov	 ecx, DWORD PTR tv93[rsp]
  00123	44 0f b6 c1	 movzx	 r8d, cl
  00127	8b d0		 mov	 edx, eax
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00136	85 c0		 test	 eax, eax
  00138	0f 85 32 01 00
	00		 jne	 $LN7@chainf3

; 275  :         {
; 276  :             switch (f3dscb->ds3fmtid)

  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR f3dscb$[rsp]
  00143	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00147	88 44 24 40	 mov	 BYTE PTR tv140[rsp], al
  0014b	80 7c 24 40 f2	 cmp	 BYTE PTR tv140[rsp], 242 ; 000000f2H
  00150	0f 84 fa 00 00
	00		 je	 $LN12@chainf3
  00156	80 7c 24 40 f3	 cmp	 BYTE PTR tv140[rsp], 243 ; 000000f3H
  0015b	74 05		 je	 SHORT $LN8@chainf3
  0015d	e9 0e 01 00 00	 jmp	 $LN4@chainf3
$LN8@chainf3:

; 277  :             {
; 278  :                 case 0xf3:
; 279  :                 {
; 280  :                     if (0
; 281  :                         || f3dscb->ds3keyid[0] != 0x03
; 282  :                         || f3dscb->ds3keyid[1] != 0x03
; 283  :                         || f3dscb->ds3keyid[2] != 0x03
; 284  :                         || f3dscb->ds3keyid[3] != 0x03

  00162	33 c0		 xor	 eax, eax
  00164	85 c0		 test	 eax, eax
  00166	75 5c		 jne	 SHORT $LN11@chainf3
  00168	b8 01 00 00 00	 mov	 eax, 1
  0016d	48 6b c0 00	 imul	 rax, rax, 0
  00171	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  00176	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017a	83 f8 03	 cmp	 eax, 3
  0017d	75 45		 jne	 SHORT $LN11@chainf3
  0017f	b8 01 00 00 00	 mov	 eax, 1
  00184	48 6b c0 01	 imul	 rax, rax, 1
  00188	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  0018d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00191	83 f8 03	 cmp	 eax, 3
  00194	75 2e		 jne	 SHORT $LN11@chainf3
  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	48 6b c0 02	 imul	 rax, rax, 2
  0019f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  001a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a8	83 f8 03	 cmp	 eax, 3
  001ab	75 17		 jne	 SHORT $LN11@chainf3
  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	48 6b c0 03	 imul	 rax, rax, 3
  001b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  001bb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001bf	83 f8 03	 cmp	 eax, 3
  001c2	74 0a		 je	 SHORT $LN9@chainf3
$LN11@chainf3:

; 285  :                     )
; 286  :                     {
; 287  :                         break;  /* Error: break out of switch */

  001c4	e9 a7 00 00 00	 jmp	 $LN4@chainf3

; 288  :                     }

  001c9	e9 82 00 00 00	 jmp	 $LN10@chainf3
$LN9@chainf3:

; 289  :                     else
; 290  :                     {
; 291  :                         *size += extents_array( &f3dscb->ds3extnt[0], 4, count, cif->heads );

  001ce	b8 0a 00 00 00	 mov	 eax, 10
  001d3	48 6b c0 00	 imul	 rax, rax, 0
  001d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  001dc	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  001e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  001e8	44 8b 49 24	 mov	 r9d, DWORD PTR [rcx+36]
  001ec	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR count$[rsp]
  001f4	ba 04 00 00 00	 mov	 edx, 4
  001f9	48 8b c8	 mov	 rcx, rax
  001fc	e8 00 00 00 00	 call	 extents_array
  00201	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  00206	03 01		 add	 eax, DWORD PTR [rcx]
  00208	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  0020d	89 01		 mov	 DWORD PTR [rcx], eax

; 292  :                         *size += extents_array( &f3dscb->ds3adext[0], 9, count, cif->heads );

  0020f	b8 0a 00 00 00	 mov	 eax, 10
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  0021d	48 8d 44 01 2d	 lea	 rax, QWORD PTR [rcx+rax+45]
  00222	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cif
  00229	44 8b 49 24	 mov	 r9d, DWORD PTR [rcx+36]
  0022d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR count$[rsp]
  00235	ba 09 00 00 00	 mov	 edx, 9
  0023a	48 8b c8	 mov	 rcx, rax
  0023d	e8 00 00 00 00	 call	 extents_array
  00242	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  00247	03 01		 add	 eax, DWORD PTR [rcx]
  00249	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  0024e	89 01		 mov	 DWORD PTR [rcx], eax
$LN10@chainf3:
$LN12@chainf3:

; 293  :                     }
; 294  :                 }
; 295  :                 /* Fall through to below 0xf2 case */
; 296  :                 /* GCC hint */
; 297  :                 /* FALLTHRU */
; 298  :                 case 0xf2:
; 299  :                 {
; 300  :                     /* Note: same offset for both F2 and F3 DSCBs */
; 301  :                     ptr = &f3dscb->ds3ptrds[0];

  00250	b8 01 00 00 00	 mov	 eax, 1
  00255	48 6b c0 00	 imul	 rax, rax, 0
  00259	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  0025e	48 8d 84 01 87
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+135]
  00266	48 89 44 24 78	 mov	 QWORD PTR ptr$[rsp], rax

; 302  :                     continue;   /* continue while loop */

  0026b	e9 b4 fd ff ff	 jmp	 $LN2@chainf3
$LN4@chainf3:
$LN7@chainf3:

; 303  :                 }
; 304  :             }
; 305  :         }
; 306  : 
; 307  :         /* Error */
; 308  :         rc = -1;

  00270	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 309  : //*debug*/fprintf(stderr, "*** DSCB id=0x%.2x\n", f3dscb->ds3fmtid);
; 310  :         break;

  00278	eb 05		 jmp	 SHORT $LN3@chainf3

; 311  : 
; 312  :     } /* end of while loop */

  0027a	e9 a5 fd ff ff	 jmp	 $LN2@chainf3
$LN3@chainf3:

; 313  : 
; 314  :     return rc;

  0027f	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 315  : }

  00283	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00287	c3		 ret	 0
chainf3	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
i$ = 64
size$ = 68
extents$ = 96
max$ = 104
count$ = 112
heads$ = 120
extents_array PROC

; 241  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 242  :     int i;
; 243  :     int size = 0;

  00017	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 244  : 
; 245  :     for (i=0; *count > 0 && i < max; i++)

  0001f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00027	eb 0a		 jmp	 SHORT $LN4@extents_ar
$LN2@extents_ar:
  00029	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@extents_ar:
  00033	48 8b 44 24 70	 mov	 rax, QWORD PTR count$[rsp]
  00038	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003b	0f 8e ba 00 00
	00		 jle	 $LN3@extents_ar
  00041	8b 44 24 68	 mov	 eax, DWORD PTR max$[rsp]
  00045	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00049	0f 8d ac 00 00
	00		 jge	 $LN3@extents_ar

; 246  :     {
; 247  :         if (extents[i].xttype)

  0004f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	48 6b c0 0a	 imul	 rax, rax, 10
  00058	48 8b 4c 24 60	 mov	 rcx, QWORD PTR extents$[rsp]
  0005d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00061	85 c0		 test	 eax, eax
  00063	74 3e		 je	 SHORT $LN5@extents_ar

; 248  :         {
; 249  :             size += extent_size( &extents[i], heads );

  00065	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0006a	48 6b c0 0a	 imul	 rax, rax, 10
  0006e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR extents$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	8b 54 24 78	 mov	 edx, DWORD PTR heads$[rsp]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 extent_size
  00085	8b 4c 24 44	 mov	 ecx, DWORD PTR size$[rsp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 44 24 44	 mov	 DWORD PTR size$[rsp], eax

; 250  :             *count -= 1;

  00091	48 8b 44 24 70	 mov	 rax, QWORD PTR count$[rsp]
  00096	8b 00		 mov	 eax, DWORD PTR [rax]
  00098	ff c8		 dec	 eax
  0009a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR count$[rsp]
  0009f	89 01		 mov	 DWORD PTR [rcx], eax

; 251  :         }

  000a1	eb 53		 jmp	 SHORT $LN6@extents_ar
$LN5@extents_ar:

; 252  :         else
; 253  :         {
; 254  :           // "%s record not found"
; 255  :           FWRMSG( stderr, HHC02471, "E", "Extents_array DSXTENT" );

  000a3	b9 02 00 00 00	 mov	 ecx, 2
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159779
  000b5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159780
  000c1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159781
  000cd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159782
  000e4	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159783
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@extents_ar:

; 256  :         }
; 257  :     }

  000f6	e9 2e ff ff ff	 jmp	 $LN2@extents_ar
$LN3@extents_ar:

; 258  :     return size;

  000fb	8b 44 24 44	 mov	 eax, DWORD PTR size$[rsp]

; 259  : }

  000ff	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00103	c3		 ret	 0
extents_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
tv64 = 32
tv72 = 36
tv71 = 40
ext$ = 64
heads$ = 72
extent_size PROC

; 235  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 236  :     return heads * ( hword( ext->xtecyl ) - hword( ext->xtbcyl ) ) +

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR ext$[rsp]
  00012	48 83 c0 06	 add	 rax, 6
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 hword
  0001e	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ext$[rsp]
  00027	48 83 c1 02	 add	 rcx, 2
  0002b	e8 00 00 00 00	 call	 hword
  00030	8b 4c 24 20	 mov	 ecx, DWORD PTR tv64[rsp]
  00034	2b c8		 sub	 ecx, eax
  00036	8b c1		 mov	 eax, ecx
  00038	8b 4c 24 48	 mov	 ecx, DWORD PTR heads$[rsp]
  0003c	0f af c8	 imul	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx
  00041	89 44 24 28	 mov	 DWORD PTR tv71[rsp], eax
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ext$[rsp]
  0004a	48 83 c1 08	 add	 rcx, 8
  0004e	e8 00 00 00 00	 call	 hword
  00053	89 44 24 24	 mov	 DWORD PTR tv72[rsp], eax
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ext$[rsp]
  0005c	48 83 c1 04	 add	 rcx, 4
  00060	e8 00 00 00 00	 call	 hword
  00065	8b 4c 24 24	 mov	 ecx, DWORD PTR tv72[rsp]
  00069	2b c8		 sub	 ecx, eax
  0006b	8b c1		 mov	 eax, ecx
  0006d	8b 4c 24 28	 mov	 ecx, DWORD PTR tv71[rsp]
  00071	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]

; 237  :                    ( hword( ext->xtetrk ) - hword( ext->xtbtrk ) ) + 1;
; 238  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
extent_size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
value$ = 8
hword	PROC

; 230  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 231  :     return (value[0] << 8) + value[1];

  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR value$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	c1 e0 08	 shl	 eax, 8
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 6b c9 01	 imul	 rcx, rcx, 1
  00023	48 8b 54 24 08	 mov	 rdx, QWORD PTR value$[rsp]
  00028	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002c	03 c1		 add	 eax, ecx

; 232  : }

  0002e	c3		 ret	 0
hword	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
value$ = 48
phword	PROC

; 222  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 223  :     prtseg(" %5d", (value[0] << 8) | value[1]);

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR value$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	c1 e0 08	 shl	 eax, 8
  0001e	b9 01 00 00 00	 mov	 ecx, 1
  00023	48 6b c9 01	 imul	 rcx, rcx, 1
  00027	48 8b 54 24 30	 mov	 rdx, QWORD PTR value$[rsp]
  0002c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00030	0b c1		 or	 eax, ecx
  00032	8b d0		 mov	 edx, eax
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159754
  0003b	e8 00 00 00 00	 call	 prtseg

; 224  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
phword	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
value$ = 48
pbyte	PROC

; 217  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 218  :     prtseg(" %3d", value[0]);

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR value$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	8b d0		 mov	 edx, eax
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159750
  00024	e8 00 00 00 00	 call	 prtseg

; 219  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
pbyte	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
tv78 = 32
tv75 = 40
value$ = 64
runflgs$ = 72
pdatex	PROC

; 210  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 211  :     (value[0] | value[1] ? pdate( value, runflgs )

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 00	 imul	 rax, rax, 0
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value$[rsp]
  0001b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	48 6b c9 01	 imul	 rcx, rcx, 1
  00028	48 8b 54 24 40	 mov	 rdx, QWORD PTR value$[rsp]
  0002d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00031	0b c1		 or	 eax, ecx
  00033	85 c0		 test	 eax, eax
  00035	74 18		 je	 SHORT $LN5@pdatex
  00037	8b 54 24 48	 mov	 edx, DWORD PTR runflgs$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value$[rsp]
  00040	e8 00 00 00 00	 call	 pdate
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0004d	eb 37		 jmp	 SHORT $LN6@pdatex
$LN5@pdatex:
  0004f	8b 44 24 48	 mov	 eax, DWORD PTR runflgs$[rsp]
  00053	83 e0 01	 and	 eax, 1
  00056	85 c0		 test	 eax, eax
  00058	74 0e		 je	 SHORT $LN3@pdatex
  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159745
  00061	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
  00066	eb 0c		 jmp	 SHORT $LN4@pdatex
$LN3@pdatex:
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159746
  0006f	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
$LN4@pdatex:
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv75[rsp]
  00079	e8 00 00 00 00	 call	 prtseg
  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN6@pdatex:

; 212  :                          : prtseg( runflgs & rf_caldate ? " ---------"
; 213  :                                                         : " -----" ));
; 214  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
pdatex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdls.c
_TEXT	SEGMENT
y$ = 32
d$ = 36
m$ = 40
fmt$ = 48
value$ = 80
runflgs$ = 88
pdate	PROC

; 185  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 186  :     char *fmt;
; 187  :     static char *mths[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
; 188  :                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" };
; 189  :     int y = value[0] + yroffs;

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 00	 imul	 rax, rax, 0
  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0001b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001f	03 05 00 00 00
	00		 add	 eax, DWORD PTR yroffs
  00025	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 190  :     int m = 12;           /* 0..11 = Jan..Dec, 12 indexes empty string */

  00029	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR m$[rsp], 12

; 191  :     int d = (value[1] << 8) | value[2];

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	48 6b c0 01	 imul	 rax, rax, 1
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 e0 08	 shl	 eax, 8
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	48 6b c9 02	 imul	 rcx, rcx, 2
  0004f	48 8b 54 24 50	 mov	 rdx, QWORD PTR value$[rsp]
  00054	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00058	0b c1		 or	 eax, ecx
  0005a	89 44 24 24	 mov	 DWORD PTR d$[rsp], eax

; 192  : 
; 193  :     if (runflgs & rf_caldate)

  0005e	8b 44 24 58	 mov	 eax, DWORD PTR runflgs$[rsp]
  00062	83 e0 01	 and	 eax, 1
  00065	85 c0		 test	 eax, eax
  00067	74 44		 je	 SHORT $LN2@pdate

; 194  :     {
; 195  :         /* calendar date (yyyymmmdd) */
; 196  :         if (ordday_to_calday( y += 1900, d, &m, &d ))

  00069	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  0006d	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00072	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax
  00076	4c 8d 4c 24 24	 lea	 r9, QWORD PTR d$[rsp]
  0007b	4c 8d 44 24 28	 lea	 r8, QWORD PTR m$[rsp]
  00080	8b 54 24 24	 mov	 edx, DWORD PTR d$[rsp]
  00084	8b 4c 24 20	 mov	 ecx, DWORD PTR y$[rsp]
  00088	e8 00 00 00 00	 call	 ordday_to_calday
  0008d	85 c0		 test	 eax, eax
  0008f	74 0e		 je	 SHORT $LN4@pdate

; 197  :             fmt = " *********"; /* (ordday_to_calday failed!) */

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159737
  00098	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax
  0009d	eb 0c		 jmp	 SHORT $LN5@pdate
$LN4@pdate:

; 198  :         else
; 199  :             fmt = " %4.4d%s%2.2d";

  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159738
  000a6	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax
$LN5@pdate:

; 200  :     }

  000ab	eb 1e		 jmp	 SHORT $LN3@pdate
$LN2@pdate:

; 201  :     else /* ordinal day (yyddd) */
; 202  :     {
; 203  :         y %= 100;

  000ad	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  000b1	99		 cdq
  000b2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000b7	f7 f9		 idiv	 ecx
  000b9	8b c2		 mov	 eax, edx
  000bb	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 204  :         fmt = " %2.2d%s%3.3d";

  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159739
  000c6	48 89 44 24 30	 mov	 QWORD PTR fmt$[rsp], rax
$LN3@pdate:

; 205  :     }
; 206  :     prtseg( fmt, y, mths[m], d );

  000cb	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$[rsp]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mths@?1??pdate@@9@9
  000d7	44 8b 4c 24 24	 mov	 r9d, DWORD PTR d$[rsp]
  000dc	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  000e0	8b 54 24 20	 mov	 edx, DWORD PTR y$[rsp]
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fmt$[rsp]
  000e9	e8 00 00 00 00	 call	 prtseg

; 207  : }

  000ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f2	c3		 ret	 0
pdate	ENDP
_TEXT	ENDS
END
