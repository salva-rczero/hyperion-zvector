; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	s390_scpinfo_ifm
PUBLIC	s390_scpinfo_cfg
PUBLIC	s390_scpinfo_cfg11
PUBLIC	s390_scpinfo_cpf
PUBLIC	z900_scpinfo_ifm
PUBLIC	z900_scpinfo_cfg
PUBLIC	z900_scpinfo_cfg11
PUBLIC	z900_scpinfo_cpf
_DATA	SEGMENT
s390_scpinfo_ifm DB 0c4H
	DB	04H
	DB	08H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
s390_scpinfo_cfg DB 02dH
	DB	00H
	DB	03H
	DB	0dfH
	DB	0f9H
	DB	00H
s390_scpinfo_cfg11 DB 01H
z900_scpinfo_cfg11 DB 05H
s390_scpinfo_cpf DB 0deH
	DB	067H
	DB	04H
	DB	0c1H
	DB	080H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+4
z900_scpinfo_ifm DB 0c4H
	DB	04H
	DB	08H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
z900_scpinfo_cfg DB 02cH
	DB	00H
	DB	03H
	DB	0dfH
	DB	0f9H
	DB	08H
	ORG $+2
z900_scpinfo_cpf DB 05eH
	DB	067H
	DB	04H
	DB	0c1H
	DB	080H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+4
$SG178944 DB	'0123456789:;<=>?', 00H
	ORG $+15
$SG178945 DB	'@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw'
	DB	'xyz{|}~', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
s390_sclp_recv_mask DD 042b00030H
s390_sclp_send_mask DD 083900039H
z900_sclp_recv_mask DD 042b00030H
z900_sclp_send_mask DD 083900039H
?const1_template@?1??sclp_opcmd_event@@9@9 DB 013H	; `sclp_opcmd_event'::`2'::const1_template
	DB	010H
	DB	00H
	DB	025H
	DB	013H
	DB	011H
	DB	0eH
	DB	081H
	DB	03H
	DB	01H
	DB	00H
	DB	03H
	DB	02H
	DB	00H
	DB	06H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0eH
	DB	082H
	DB	03H
	DB	01H
	DB	00H
	DB	03H
	DB	02H
	DB	00H
	DB	06H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
	DB	090H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0cH
	DB	015H
	DB	049H
	DB	08H
	DB	01H
	DB	03H
	DB	01H
	DB	00H
	DB	03H
	DB	02H
	DB	00H
?const4_template@?1??sclp_opcmd_event@@9@9 DB 031H	; `sclp_opcmd_event'::`2'::const4_template
?const3_template@?1??sclp_opcmd_event@@9@9 DB 013H	; `sclp_opcmd_event'::`2'::const3_template
	DB	020H
?const5_template@?1??sclp_opcmd_event@@9@9 DB 030H	; `sclp_opcmd_event'::`2'::const5_template
	ORG $+1
?const2_template@?1??sclp_opcmd_event@@9@9 DB 012H	; `sclp_opcmd_event'::`2'::const2_template
	DB	012H
	DB	00H
	DB	012H
	DB	015H
	DB	04dH
	DB	0eH
	DB	06H
	DB	06H
	DB	010H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	06H
	DB	060H
	DB	0d6H
	DB	0c3H
	DB	0c6H
	DB	0c1H
	DB	00H
	DB	04H
	DB	080H
	DB	070H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	scp_command
PUBLIC	can_signal_quiesce
PUBLIC	can_send_command
PUBLIC	signal_quiesce
PUBLIC	sclp_attention
PUBLIC	sclp_reset
PUBLIC	sclp_sysg_attention
PUBLIC	servc_hsuspend
PUBLIC	servc_hresume
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s390_service_call
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	z900_service_call
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_check
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp__errno:PROC
EXTRN	memchr:PROC
EXTRN	memmove:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_strpbrk:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	configure_cpu:PROC
EXTRN	deconfigure_cpu:PROC
EXTRN	losc_check:PROC
EXTRN	get_loadparm:PROC
EXTRN	set_sysname:PROC
EXTRN	set_systype:PROC
EXTRN	set_sysplex:PROC
EXTRN	get_mpfactors:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	s390_checkstop_all_cpus:PROC
EXTRN	s390_sclp_scedio_request:PROC
EXTRN	s390_sclp_scedio_event:PROC
EXTRN	s390_sclp_hwl_request:PROC
EXTRN	s390_sclp_hwl_event:PROC
EXTRN	s390_sclp_sdias_request:PROC
EXTRN	s390_sclp_sdias_event:PROC
EXTRN	z900_checkstop_all_cpus:PROC
EXTRN	z900_sclp_scedio_request:PROC
EXTRN	z900_sclp_scedio_event:PROC
EXTRN	z900_sclp_hwl_request:PROC
EXTRN	z900_sclp_hwl_event:PROC
EXTRN	z900_sclp_sdias_request:PROC
EXTRN	z900_sclp_sdias_event:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_sclp_unknown_command:QWORD
EXTRN	__imp_debug_sclp_unknown_event:QWORD
EXTRN	__imp_debug_sclp_unknown_event_mask:QWORD
EXTRN	__imp_debug_sclp_event_data:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?once@?1??gh534_fix@@9@9 DB 01H DUP (?)			; `gh534_fix'::`2'::once
	ALIGN	4

?ignore@?1??gh534_fix@@9@9 DB 01H DUP (?)		; `gh534_fix'::`2'::ignore
	ALIGN	4

?ESC@?1??gh534_fix@@9@9 DB 01H DUP (?)			; `gh534_fix'::`2'::ESC
	ALIGN	4

?prmlen@?1??gh534_fix@@9@9 DD 01H DUP (?)		; `gh534_fix'::`2'::prmlen
?subsub@?1??gh534_fix@@9@9 DB 03H DUP (?)		; `gh534_fix'::`2'::subsub
	ALIGN	4

servc_cp_recv_mask DD 01H DUP (?)
servc_cp_send_mask DD 01H DUP (?)
servc_attn_pending DD 01H DUP (?)
servc_scpcmdstr DB 07cH DUP (?)
servc_signal_quiesce_count DW 01H DUP (?)
	ALIGN	4

servc_signal_quiesce_unit DB 01H DUP (?)
	ALIGN	4

servc_sysg_cmdcode DB 01H DUP (?)
	ALIGN	4

$SG179079 DB	01H DUP (?)
	ALIGN	4

?s390x_linux_detected@?CE@??s390_service_call@@9@9 DB 01H DUP (?) ; `s390_service_call'::`36'::s390x_linux_detected
	ALIGN	4

?is_s390x_linux@?CE@??s390_service_call@@9@9 DB 01H DUP (?) ; `s390_service_call'::`36'::is_s390x_linux
	ALIGN	4

?s390x_linux_detected@?CG@??z900_service_call@@9@9 DB 01H DUP (?) ; `z900_service_call'::`38'::s390x_linux_detected
	ALIGN	4

?is_s390x_linux@?CG@??z900_service_call@@9@9 DB 01H DUP (?) ; `z900_service_call'::`38'::is_s390x_linux
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$scp_command DD imagerel $LN13
	DD	imagerel $LN13+665
	DD	imagerel $unwind$scp_command
$pdata$signal_quiesce DD imagerel $LN4
	DD	imagerel $LN4+183
	DD	imagerel $unwind$signal_quiesce
$pdata$sclp_attention DD imagerel $LN15
	DD	imagerel $LN15+444
	DD	imagerel $unwind$sclp_attention
$pdata$sclp_sysg_attention DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$sclp_sysg_attention
$pdata$servc_hsuspend DD imagerel $LN31
	DD	imagerel $LN31+358
	DD	imagerel $unwind$servc_hsuspend
$pdata$servc_hresume DD imagerel $LN59
	DD	imagerel $LN59+636
	DD	imagerel $unwind$servc_hresume
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$sr_write_hdr DD imagerel sr_write_hdr
	DD	imagerel sr_write_hdr+199
	DD	imagerel $unwind$sr_write_hdr
$pdata$sr_write_value DD imagerel sr_write_value
	DD	imagerel sr_write_value+378
	DD	imagerel $unwind$sr_write_value
$pdata$sr_write_string DD imagerel sr_write_string
	DD	imagerel sr_write_string+190
	DD	imagerel $unwind$sr_write_string
$pdata$sr_read_hdr DD imagerel sr_read_hdr
	DD	imagerel sr_read_hdr+221
	DD	imagerel $unwind$sr_read_hdr
$pdata$sr_read_value DD imagerel sr_read_value
	DD	imagerel sr_read_value+588
	DD	imagerel $unwind$sr_read_value
$pdata$sr_read_string DD imagerel sr_read_string
	DD	imagerel sr_read_string+143
	DD	imagerel $unwind$sr_read_string
$pdata$sr_read_skip DD imagerel sr_read_skip
	DD	imagerel sr_read_skip+248
	DD	imagerel $unwind$sr_read_skip
$pdata$sr_write_error_ DD imagerel sr_write_error_
	DD	imagerel sr_write_error_+121
	DD	imagerel $unwind$sr_write_error_
$pdata$sr_read_error_ DD imagerel sr_read_error_
	DD	imagerel sr_read_error_+121
	DD	imagerel $unwind$sr_read_error_
$pdata$sr_value_error_ DD imagerel sr_value_error_
	DD	imagerel sr_value_error_+80
	DD	imagerel $unwind$sr_value_error_
$pdata$sr_string_error_ DD imagerel sr_string_error_
	DD	imagerel sr_string_error_+80
	DD	imagerel $unwind$sr_string_error_
$pdata$gh534_fix DD imagerel gh534_fix
	DD	imagerel gh534_fix+1228
	DD	imagerel $unwind$gh534_fix
$pdata$sclp_attn_thread DD imagerel sclp_attn_thread
	DD	imagerel sclp_attn_thread+136
	DD	imagerel $unwind$sclp_attn_thread
$pdata$sclp_attn_async DD imagerel sclp_attn_async
	DD	imagerel sclp_attn_async+250
	DD	imagerel $unwind$sclp_attn_async
$pdata$sclp_attn_pending DD imagerel sclp_attn_pending
	DD	imagerel sclp_attn_pending+96
	DD	imagerel $unwind$sclp_attn_pending
$pdata$sclp_opcmd_event DD imagerel sclp_opcmd_event
	DD	imagerel sclp_opcmd_event+622
	DD	imagerel $unwind$sclp_opcmd_event
$pdata$sclp_cpident DD imagerel sclp_cpident
	DD	imagerel sclp_cpident+1023
	DD	imagerel $unwind$sclp_cpident
$pdata$sclp_sigq_event DD imagerel sclp_sigq_event
	DD	imagerel sclp_sigq_event+312
	DD	imagerel $unwind$sclp_sigq_event
$pdata$sclp_sysg_write DD imagerel sclp_sysg_write
	DD	imagerel sclp_sysg_write+655
	DD	imagerel $unwind$sclp_sysg_write
$pdata$sclp_sysg_poll DD imagerel sclp_sysg_poll
	DD	imagerel sclp_sysg_poll+845
	DD	imagerel $unwind$sclp_sysg_poll
$pdata$s390_service_call DD imagerel $LN176
	DD	imagerel $LN176+8403
	DD	imagerel $unwind$s390_service_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_service_call DD imagerel $LN180
	DD	imagerel $LN180+8547
	DD	imagerel $unwind$z900_service_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$z900_per3_zero_check
pdata	ENDS
_DATA	SEGMENT
$SG178685 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG178687 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG178702 DB	'SR: sr_write_string: key=0x%8.8x', 0aH, 00H
	ORG $+2
$SG178879 DB	'E', 00H
	ORG $+2
$SG178704 DB	'SR: sr_write_string: key=0x%8.8x', 0aH, 00H
	ORG $+6
$SG178751 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG178753 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG178773 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG178775 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG178790 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG178792 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG178805 DB	'SR: sr_read_string:                len=0x%8.8x', 0aH, 00H
$SG178807 DB	'SR: sr_read_string:                len=0x%8.8x', 0aH, 00H
$SG178860 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+7
$SG178870 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG178884 DB	'read()', 00H
	ORG $+5
$SG178862 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+3
$SG178885 DB	'E', 00H
	ORG $+2
$SG178872 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG178896 DB	'E', 00H
	ORG $+2
$SG178878 DB	'write()', 00H
$SG178880 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG178901 DB	'E', 00H
	ORG $+2
$SG178881 DB	'sr_write_error_', 00H
$SG178882 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG178948 DB	0aH, 00H
	ORG $+2
$SG178886 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG178966 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG178967 DB	'%s', 0aH, 00H
$SG178887 DB	'sr_read_error_', 00H
	ORG $+1
$SG178888 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG179036 DB	'E', 00H
	ORG $+2
$SG178897 DB	'HHC02020%s SR: value error, incorrect length', 0aH, 00H
	ORG $+2
$SG178898 DB	'sr_value_error_', 00H
$SG178899 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG179061 DB	'E', 00H
	ORG $+2
$SG178902 DB	'HHC02021%s SR: string error, incorrect length', 0aH, 00H
	ORG $+1
$SG178903 DB	'sr_string_error_', 00H
	ORG $+3
$SG179067 DB	'E', 00H
	ORG $+2
$SG178904 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG179072 DB	'E', 00H
	ORG $+2
?parms@?1??gh534_fix@@9@9 DQ FLAT:$SG178944		; `gh534_fix'::`2'::parms
?final@?1??gh534_fix@@9@9 DQ FLAT:$SG178945		; `gh534_fix'::`2'::final
$SG178949 DB	'gh534_fix', 00H
	ORG $+2
$SG179080 DB	'I', 00H
	ORG $+2
$SG178950 DB	'service.c', 00H
	ORG $+2
$SG179158 DB	'I', 00H
	ORG $+2
$SG178962 DB	'        ', 00H
	ORG $+3
$SG179178 DB	'E', 00H
	ORG $+2
$SG178968 DB	'gh534_fix', 00H
	ORG $+2
$SG179242 DB	'*SERVC', 00H
	ORG $+1
$SG189742 DB	'W', 00H
	ORG $+2
$SG178969 DB	'service.c', 00H
	ORG $+2
$SG179248 DB	'*SERVC', 00H
	ORG $+1
$SG189780 DB	'W', 00H
	ORG $+2
$SG179002 DB	'service.c:308', 00H
	ORG $+2
$SG179018 DB	'service.c:318', 00H
	ORG $+2
$SG179019 DB	'service.c:327', 00H
	ORG $+2
$SG179020 DB	'service.c:331', 00H
	ORG $+2
$SG179021 DB	'service.c:337', 00H
	ORG $+2
$SG179033 DB	'service.c:357', 00H
	ORG $+2
$SG179034 DB	'attn_thread', 00H
$SG189789 DB	'%s', 0aH, 00H
$SG179037 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG179300 DB	'*SERVC', 00H
	ORG $+1
$SG189828 DB	'I', 00H
	ORG $+2
$SG179038 DB	'sclp_attn_async', 00H
$SG179039 DB	'service.c', 00H
	ORG $+2
$SG179304 DB	'*SERVC', 00H
	ORG $+1
$SG189833 DB	'I', 00H
	ORG $+2
$SG179060 DB	'priority commands', 00H
	ORG $+2
$SG189800 DB	'*SERVC', 00H
	ORG $+1
$SG203018 DB	'W', 00H
	ORG $+2
$SG179062 DB	'HHC00002%s SCLP console not receiving %s', 0aH, 00H
	ORG $+2
$SG189813 DB	'*SERVC', 00H
	ORG $+1
$SG203056 DB	'W', 00H
	ORG $+2
$SG179063 DB	'scp_command', 00H
$SG203065 DB	'%s', 0aH, 00H
$SG179064 DB	'service.c', 00H
	ORG $+2
$SG189827 DB	'active', 00H
	ORG $+1
$SG203104 DB	'I', 00H
	ORG $+2
$SG179066 DB	'operator commands', 00H
	ORG $+2
$SG189849 DB	'*SERVC', 00H
	ORG $+1
$SG203109 DB	'I', 00H
	ORG $+2
$SG179068 DB	'HHC00002%s SCLP console not receiving %s', 0aH, 00H
	ORG $+2
$SG203076 DB	'*SERVC', 00H
	ORG $+5
$SG179069 DB	'scp_command', 00H
	ORG $+4
$SG179070 DB	'service.c', 00H
	ORG $+6
$SG179073 DB	'HHC00003%s Empty SCP command issued', 0aH, 00H
	ORG $+3
$SG179074 DB	'scp_command', 00H
	ORG $+4
$SG179075 DB	'service.c', 00H
	ORG $+6
$SG179077 DB	'(suppressed)', 00H
	ORG $+3
$SG179078 DB	'priority ', 00H
	ORG $+6
$SG179081 DB	'HHC00160%s SCP %scommand: %s', 0aH, 00H
	ORG $+2
$SG179082 DB	'scp_command', 00H
	ORG $+4
$SG179083 DB	'service.c', 00H
	ORG $+6
$SG179084 DB	'service.c:434', 00H
	ORG $+2
$SG179085 DB	'service.c:443', 00H
	ORG $+2
$SG179162 DB	'%llX', 00H
	ORG $+3
$SG179159 DB	'HHC00004%s Control program identification: type %s, name'
	DB	' %s, sysplex %s, level %llX', 0aH, 00H
	ORG $+3
$SG179160 DB	'sclp_cpident', 00H
	ORG $+3
$SG179161 DB	'service.c', 00H
	ORG $+6
$SG179163 DB	'SYSTYPE', 00H
$SG179164 DB	'SYSNAME', 00H
$SG179165 DB	'SYSPLEX', 00H
$SG179166 DB	'SYSLEVEL', 00H
	ORG $+7
$SG179177 DB	'quiesce signals', 00H
$SG179179 DB	'HHC00002%s SCLP console not receiving %s', 0aH, 00H
	ORG $+6
$SG179180 DB	'signal_quiesce', 00H
	ORG $+1
$SG179181 DB	'service.c', 00H
	ORG $+6
$SG179182 DB	'service.c:686', 00H
	ORG $+2
$SG179183 DB	'service.c:694', 00H
	ORG $+2
$SG179241 DB	'service.c:786', 00H
	ORG $+2
$SG179247 DB	'service.c:829', 00H
	ORG $+2
$SG179299 DB	'service.c:904', 00H
	ORG $+2
$SG179303 DB	'service.c:915', 00H
	ORG $+2
$SG179309 DB	'service.c:971', 00H
	ORG $+2
$SG179310 DB	'service.c:975', 00H
	ORG $+2
$SG189722 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1477', 00H
	ORG $+2
$SG189723 DB	'SERVC', 00H
	ORG $+2
$SG189734 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1536', 00H
	ORG $+2
$SG189736 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1542', 00H
	ORG $+2
$SG189744 DB	's390_service_call', 00H
	ORG $+6
$SG189743 DB	'HHC00005%s The configuration has been placed into a syst'
	DB	'em check-stop state because of an incompatible service call', 0aH
	DB	00H
	ORG $+3
$SG189745 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189749 DB	's390_service_call', 00H
	ORG $+6
$SG189750 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189751 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189753 DB	's390_service_call', 00H
	ORG $+6
$SG189754 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189755 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189762 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1752', 00H
	ORG $+2
$SG189782 DB	's390_service_call', 00H
	ORG $+6
$SG189781 DB	'HHC00159%s Overly long %d byte SCP message truncated to '
	DB	'%d bytes', 0aH, 00H
	ORG $+6
$SG189783 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189790 DB	's390_service_call', 00H
	ORG $+6
$SG189791 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189799 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2049', 00H
	ORG $+2
$SG189812 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2146', 00H
	ORG $+2
$SG189829 DB	'HHC00006%s SCLP console interface %s', 0aH, 00H
	ORG $+2
$SG189830 DB	's390_service_call', 00H
	ORG $+6
$SG189831 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189832 DB	'inactive', 00H
	ORG $+7
$SG189834 DB	'HHC00006%s SCLP console interface %s', 0aH, 00H
	ORG $+2
$SG189835 DB	's390_service_call', 00H
	ORG $+6
$SG189836 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG189848 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2407', 00H
	ORG $+2
$SG189856 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2433', 00H
	ORG $+2
$SG202994 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1472', 00H
	ORG $+2
$SG202998 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1477', 00H
	ORG $+2
$SG202999 DB	'SERVC', 00H
	ORG $+2
$SG203010 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1536', 00H
	ORG $+2
$SG203012 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1542', 00H
	ORG $+2
$SG203020 DB	'z900_service_call', 00H
	ORG $+6
$SG203019 DB	'HHC00005%s The configuration has been placed into a syst'
	DB	'em check-stop state because of an incompatible service call', 0aH
	DB	00H
	ORG $+3
$SG203021 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203025 DB	'z900_service_call', 00H
	ORG $+6
$SG203026 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203027 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG203029 DB	'z900_service_call', 00H
	ORG $+6
$SG203030 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203031 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG203038 DB	'C:\papa\MyGit\hyperion-zvector\service.c:1752', 00H
	ORG $+2
$SG203058 DB	'z900_service_call', 00H
	ORG $+6
$SG203057 DB	'HHC00159%s Overly long %d byte SCP message truncated to '
	DB	'%d bytes', 0aH, 00H
	ORG $+6
$SG203059 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203066 DB	'z900_service_call', 00H
	ORG $+6
$SG203067 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203075 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2049', 00H
	ORG $+2
$SG203088 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2146', 00H
	ORG $+2
$SG203089 DB	'*SERVC', 00H
	ORG $+1
$SG203103 DB	'active', 00H
	ORG $+1
$SG203105 DB	'HHC00006%s SCLP console interface %s', 0aH, 00H
	ORG $+2
$SG203106 DB	'z900_service_call', 00H
	ORG $+6
$SG203107 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203108 DB	'inactive', 00H
	ORG $+7
$SG203110 DB	'HHC00006%s SCLP console interface %s', 0aH, 00H
	ORG $+2
$SG203111 DB	'z900_service_call', 00H
	ORG $+6
$SG203112 DB	'C:\papa\MyGit\hyperion-zvector\service.c', 00H
	ORG $+7
$SG203124 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2407', 00H
	ORG $+2
$SG203125 DB	'*SERVC', 00H
	ORG $+1
$SG203132 DB	'C:\papa\MyGit\hyperion-zvector\service.c:2433', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_service_call
	DD	023H
	DD	0210dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_service_call
	DD	023H
	DD	0207bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sclp_cpident
	DD	016H
	DD	03e7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gh534_fix
	DD	020H
	DD	04b4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_skip
	DD	01aH
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_value
	DD	021H
	DD	023aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_hdr
	DD	01dH
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_value
	DD	021H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_hdr
	DD	01cH
	DD	0b5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$scp_command DD 011701H
	DD	0e217H
$unwind$signal_quiesce DD 010d01H
	DD	0820dH
$unwind$sclp_attention DD 010901H
	DD	06209H
$unwind$sclp_sysg_attention DD 010401H
	DD	04204H
$unwind$servc_hsuspend DD 010901H
	DD	04209H
$unwind$servc_hresume DD 010901H
	DD	08209H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$sr_write_hdr DD 012119H
	DD	06212H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_write_value DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$sr_write_string DD 011201H
	DD	06212H
$unwind$sr_read_hdr DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_read_value DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sr_read_string DD 011301H
	DD	04213H
$unwind$sr_read_skip DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$sr_write_error_ DD 010401H
	DD	0c204H
$unwind$sr_read_error_ DD 010401H
	DD	0c204H
$unwind$sr_value_error_ DD 010401H
	DD	08204H
$unwind$sr_string_error_ DD 010401H
	DD	08204H
$unwind$gh534_fix DD 022819H
	DD	02110116H
	DD	imagerel __GSHandlerCheck
	DD	01070H
$unwind$sclp_attn_thread DD 010901H
	DD	06209H
$unwind$sclp_attn_async DD 010901H
	DD	0c209H
$unwind$sclp_attn_pending DD 010901H
	DD	02209H
$unwind$sclp_opcmd_event DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$sclp_cpident DD 021e19H
	DD	02d010cH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$sclp_sigq_event DD 020a01H
	DD	07006720aH
$unwind$sclp_sysg_write DD 020c01H
	DD	015010cH
$unwind$sclp_sysg_poll DD 030d01H
	DD	014010dH
	DD	07006H
$unwind$s390_service_call DD 042b19H
	DD	02390119H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	011b0H
$unwind$z900_service_call DD 042b19H
	DD	023b0119H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	011c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check
_TEXT	SEGMENT
tv78 = 32
regs$ = 64
r1$ = 72
z900_per3_zero_check PROC				; COMDAT

; 629  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 19		 je	 SHORT $LN4@z900_per3_
  0001f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00031	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00036	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00038	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00049	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
$LN5@z900_per3_:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00054	75 0a		 jne	 SHORT $LN2@z900_per3_

; 632  :         ARCH_DEP( per3_zero )( regs );

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 633  : #else
; 634  :     UNREFERENCED( regs );
; 635  :     UNREFERENCED( r1 );
; 636  : #endif
; 637  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
z900_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
i$ = 80
sccb$ = 88
sccblen$ = 96
sccb_absolute_addr$ = 100
offset$ = 104
sccbscp$ = 112
tv254 = 120
masklen$ = 124
obj_len$ = 128
event_msglen$ = 132
mcd_len$ = 136
evd_len$ = 140
i$1 = 144
sccb_real_addr$ = 148
chpbyte$ = 152
r2$ = 156
sclp_command$ = 160
evd_hdr$ = 168
r1$ = 176
tv669 = 180
xstblkinc$ = 184
evd_mask$ = 192
sccbcpu$ = 200
obj_type$ = 208
chpbit$ = 212
xstincnum$ = 216
dev$ = 224
sccbchp$ = 232
tv793 = 240
incsizemb$ = 244
i$2 = 248
realinc$ = 252
trunc_len$3 = 256
obj_hdr$ = 264
sccb_last_byte$4 = 272
evd_msg$ = 280
mask$5 = 288
old_cp_recv_mask$ = 296
tv1661 = 300
old_cp_send_mask$ = 304
sccb_first_byte$6 = 312
tv191 = 320
sccbcsi$ = 328
mcd_bk$ = 336
mto_bk$ = 344
$T7 = 352
tv860 = 360
tv985 = 368
sccbxmap$ = 376
tv1226 = 384
tv326 = 392
sccbmpf$ = 400
tv1051 = 408
tv1055 = 416
tv1151 = 424
xstmap$ = 432
tv1174 = 440
message$ = 448
__$ArrayPad$ = 4544
inst$ = 4592
regs$ = 4600
z900_service_call PROC

; 1408 : {

$LN180:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 d8 11 00 00	 mov	 eax, 4568		; 000011d8H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 c0
	11 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1409 : U32             r1, r2;                 /* Values of R fields        */
; 1410 : U32             sclp_command;           /* SCLP command code         */
; 1411 : U32             sccb_real_addr;         /* SCCB real address         */
; 1412 : int             i;                      /* Array subscripts          */
; 1413 : U32             realinc;                /* Storage size in increments*/
; 1414 : U32             incsizemb;              /* Increment size in MB      */
; 1415 : U32             sccb_absolute_addr;     /* Absolute address of SCCB  */
; 1416 : U16             sccblen;                /* Length of SCCB            */
; 1417 : SCCB_HEADER*    sccb;                   /* -> SCCB header            */
; 1418 : SCCB_SCP_INFO*  sccbscp;                /* -> SCCB SCP information   */
; 1419 : SCCB_CPU_INFO*  sccbcpu;                /* -> SCCB CPU information   */
; 1420 : 
; 1421 : #if defined( FEATURE_MPF_INFO )
; 1422 : SCCB_MPF_INFO*  sccbmpf;                /* -> SCCB MPF information   */
; 1423 : #endif
; 1424 : 
; 1425 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1426 : SCCB_CHP_INFO*  sccbchp;                /* -> SCCB channel path info */
; 1427 : #else
; 1428 : SCCB_CHSET_INFO* sccbchp;               /* -> SCCB channel path info */
; 1429 : #endif
; 1430 : 
; 1431 : SCCB_CSI_INFO*  sccbcsi;                /* -> SCCB channel subsys inf*/
; 1432 : U16             offset;                 /* Offset from start of SCCB */
; 1433 : 
; 1434 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1435 : DEVBLK*         dev;                    /* Used to find CHPIDs       */
; 1436 : U32             chpbyte;                /* Offset to byte for CHPID  */
; 1437 : U32             chpbit;                 /* Bit number for CHPID      */
; 1438 : #endif
; 1439 : 
; 1440 : #if defined( FEATURE_SYSTEM_CONSOLE )
; 1441 : SCCB_EVT_MASK*  evd_mask;               /* Event mask                */
; 1442 : SCCB_EVD_HDR*   evd_hdr;                /* Event header              */
; 1443 : U16             evd_len;                /* Length of event data      */
; 1444 : SCCB_MCD_BK*    mcd_bk;                 /* Message Control Data      */
; 1445 : U16             mcd_len;                /* Length of MCD             */
; 1446 : SCCB_OBJ_HDR*   obj_hdr;                /* Object Header             */
; 1447 : U16             obj_len;                /* Length of Object          */
; 1448 : U16             obj_type;               /* Object type               */
; 1449 : SCCB_MTO_BK*    mto_bk;                 /* Message Text Object       */
; 1450 : BYTE*           evd_msg;                /* Message Text pointer      */
; 1451 : int             event_msglen;           /* Message Text length       */
; 1452 : BYTE            message[MAX_EVENT_MSG_LEN];/* Maximum event data buffer
; 1453 :                                            length plus one for \0    */
; 1454 : U32             masklen;                /* Length of event mask      */
; 1455 : U32             old_cp_recv_mask;       /* Masks before write event  */
; 1456 : U32             old_cp_send_mask;       /*              mask command */
; 1457 : #endif /* defined( FEATURE_SYSTEM_CONSOLE ) */
; 1458 : 
; 1459 : #if defined( FEATURE_EXPANDED_STORAGE )
; 1460 : SCCB_XST_MAP*   sccbxmap;               /* Xstore usability map      */
; 1461 : U32             xstincnum;              /* Number of expanded storage
; 1462 :                                                          increments  */
; 1463 : U32             xstblkinc;              /* Number of expanded storage
; 1464 :                                                blocks per increment  */
; 1465 : BYTE*           xstmap;                 /* Xstore bitmap, zero means
; 1466 :                                                            available */
; 1467 : #endif /* defined( FEATURE_EXPANDED_STORAGE ) */
; 1468 : 
; 1469 :     RRE( inst, regs, r1, r2 );

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 f0
	11 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 84 24 f8 00
	00 00		 mov	 DWORD PTR i$2[rsp], eax
  00047	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 84 24 9c 00
	00 00		 mov	 DWORD PTR r2$[rsp], eax
  00058	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  0005f	c1 f8 04	 sar	 eax, 4
  00062	83 e0 0f	 and	 eax, 15
  00065	89 84 24 b0 00
	00 00		 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_servi:
  0006c	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN61@z900_servi
  0008f	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN61@z900_servi:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@z900_servi

; 1470 : 
; 1471 :     PER_ZEROADDR_CHECK( regs, r2 );

  000a4	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR r2$[rsp]
  000ab	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	e8 00 00 00 00	 call	 z900_per3_zero_check
$LN7@z900_servi:

; 1472 :     TXF_INSTR_CHECK( regs );

  000b8	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c7	85 c0		 test	 eax, eax
  000c9	74 3f		 je	 SHORT $LN62@z900_servi
  000cb	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d9	0f ba e8 0c	 bts	 eax, 12
  000dd	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000eb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG202994
  000f2	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000f8	ba 02 00 00 00	 mov	 edx, 2
  000fd	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	e8 00 00 00 00	 call	 z900_abort_transaction
$LN62@z900_servi:
  0010a	33 c0		 xor	 eax, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 a8		 jne	 SHORT $LN7@z900_servi

; 1473 :     PRIV_CHECK( regs );

  00110	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0011c	83 e0 01	 and	 eax, 1
  0011f	85 c0		 test	 eax, eax
  00121	74 1b		 je	 SHORT $LN63@z900_servi
  00123	ba 02 00 00 00	 mov	 edx, 2
  00128	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN63@z900_servi:
$LN10@z900_servi:

; 1474 : 
; 1475 :     SIE_INTERCEPT( regs );

  0013e	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00146	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014c	d1 e8		 shr	 eax, 1
  0014e	83 e0 01	 and	 eax, 1
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN64@z900_servi
  00155	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00163	ba fc ff ff ff	 mov	 edx, -4
  00168	48 8b c8	 mov	 rcx, rax
  0016b	e8 00 00 00 00	 call	 longjmp
$LN64@z900_servi:
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 c8		 jne	 SHORT $LN10@z900_servi
$LN13@z900_servi:

; 1476 : 
; 1477 :     PTT_INF("SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  00176	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00180	48 83 e0 08	 and	 rax, 8
  00184	48 85 c0	 test	 rax, rax
  00187	74 6d		 je	 SHORT $LN65@z900_servi
  00189	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00197	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0019e	48 8b 94 24 f8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a6	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001ad	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  001b4	4c 8b 84 24 f8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bc	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001c4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG202998
  001d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001de	44 8b c9	 mov	 r9d, ecx
  001e1	44 8b c2	 mov	 r8d, edx
  001e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202999
  001eb	b9 08 00 00 00	 mov	 ecx, 8
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN65@z900_servi:
  001f6	33 c0		 xor	 eax, eax
  001f8	85 c0		 test	 eax, eax
  001fa	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_servi

; 1478 : 
; 1479 :     /* R1 is SCLP command word */
; 1480 :     sclp_command = regs->GR_L(r1);

  00200	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00207	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00216	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sclp_command$[rsp], eax

; 1481 : 
; 1482 :     /* R2 is real address of service call control block */
; 1483 :     sccb_real_addr = regs->GR_L(r2);

  0021d	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00224	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00233	89 84 24 94 00
	00 00		 mov	 DWORD PTR sccb_real_addr$[rsp], eax

; 1484 : 
; 1485 :     /* Program check if SCCB is not on a doubleword boundary */
; 1486 :     if (sccb_real_addr & 0x00000007)

  0023a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00241	83 e0 07	 and	 eax, 7
  00244	85 c0		 test	 eax, eax
  00246	74 12		 je	 SHORT $LN66@z900_servi

; 1487 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00248	ba 06 00 00 00	 mov	 edx, 6
  0024d	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	e8 00 00 00 00	 call	 z900_program_interrupt
$LN66@z900_servi:

; 1488 : 
; 1489 :     /* Program check if SCCB falls outside of main storage */
; 1490 :     if (sccb_real_addr > (regs->mainlim - sizeof( SCCB_HEADER )))

  0025a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00261	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00269	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00270	48 83 e9 08	 sub	 rcx, 8
  00274	48 3b c1	 cmp	 rax, rcx
  00277	76 12		 jbe	 SHORT $LN67@z900_servi

; 1491 :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  00279	ba 05 00 00 00	 mov	 edx, 5
  0027e	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00286	e8 00 00 00 00	 call	 z900_program_interrupt
$LN67@z900_servi:

; 1492 : 
; 1493 :     /* Obtain the absolute address of the SCCB */
; 1494 :     sccb_absolute_addr = APPLY_PREFIXING( sccb_real_addr, regs->PX );

  0028b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00292	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00298	48 85 c0	 test	 rax, rax
  0029b	74 2c		 je	 SHORT $LN163@z900_servi
  0029d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  002a4	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  002aa	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b2	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  002b6	74 11		 je	 SHORT $LN163@z900_servi
  002b8	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  002bf	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv191[rsp], rax
  002c7	eb 1b		 jmp	 SHORT $LN164@z900_servi
$LN163@z900_servi:
  002c9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  002d0	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d8	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  002dc	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv191[rsp], rax
$LN164@z900_servi:
  002e4	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv191[rsp]
  002eb	89 44 24 64	 mov	 DWORD PTR sccb_absolute_addr$[rsp], eax

; 1495 : 
; 1496 :     /* Specification Exception if SCCB not below 2GB */
; 1497 :     if (sccb_absolute_addr >= (0x80000000 - sizeof( SCCB_HEADER )))

  002ef	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  002f3	48 3d f8 ff ff
	7f		 cmp	 rax, 2147483640		; 7ffffff8H
  002f9	72 12		 jb	 SHORT $LN68@z900_servi

; 1498 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  002fb	ba 06 00 00 00	 mov	 edx, 6
  00300	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	e8 00 00 00 00	 call	 z900_program_interrupt
$LN68@z900_servi:

; 1499 : 
; 1500 :     /* Point to service call control block */
; 1501 :     sccb = (SCCB_HEADER*)(regs->mainstor + sccb_absolute_addr);

  0030d	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00311	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00320	48 89 44 24 58	 mov	 QWORD PTR sccb$[rsp], rax

; 1502 : 
; 1503 :     /* Load SCCB length from header */
; 1504 :     FETCH_HW( sccblen, sccb->length  );

  00325	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0032a	48 8b c8	 mov	 rcx, rax
  0032d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00332	0f b7 c8	 movzx	 ecx, ax
  00335	e8 00 00 00 00	 call	 _byteswap_ushort
  0033a	66 89 44 24 60	 mov	 WORD PTR sccblen$[rsp], ax

; 1505 : 
; 1506 :     /* Set the main storage reference bit */
; 1507 :     ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_REF );

  0033f	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00343	b2 04		 mov	 dl, 4
  00345	8b c8		 mov	 ecx, eax
  00347	e8 00 00 00 00	 call	 z900_or_storage_key

; 1508 : 
; 1509 :     /* Specification Exception if SCCB size less than 8 */
; 1510 :     if (sccblen < sizeof( SCCB_HEADER ))

  0034c	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00351	48 83 f8 08	 cmp	 rax, 8
  00355	73 12		 jae	 SHORT $LN69@z900_servi

; 1511 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00357	ba 06 00 00 00	 mov	 edx, 6
  0035c	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00364	e8 00 00 00 00	 call	 z900_program_interrupt
$LN69@z900_servi:

; 1512 : 
; 1513 :     /* Program check if SCCB falls outside of main storage,
; 1514 :        isn't below 2GB or overlaps low core or prefix area. */
; 1515 :     {
; 1516 :         U64 sccb_first_byte = (U64) sccb_absolute_addr;

  00369	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  0036d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR sccb_first_byte$6[rsp], rax

; 1517 :         U64 sccb_last_byte  = (U64) sccb_absolute_addr + sccblen - 1;

  00375	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00379	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  0037e	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00383	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR sccb_last_byte$4[rsp], rax

; 1518 : 
; 1519 :         if (0
; 1520 :             || sccb_first_byte < PSA_SIZE
; 1521 :             || sccb_last_byte > 0x80000000
; 1522 :             || (sccb_first_byte >= regs->PX && sccb_first_byte < (regs->PX + PSA_SIZE))
; 1523 :             || (sccb_last_byte  >= regs->PX && sccb_last_byte  < (regs->PX + PSA_SIZE))

  0038b	33 c0		 xor	 eax, eax
  0038d	85 c0		 test	 eax, eax
  0038f	0f 85 81 00 00
	00		 jne	 $LN71@z900_servi
  00395	48 81 bc 24 38
	01 00 00 00 20
	00 00		 cmp	 QWORD PTR sccb_first_byte$6[rsp], 8192 ; 00002000H
  003a1	72 73		 jb	 SHORT $LN71@z900_servi
  003a3	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  003a8	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  003b0	77 64		 ja	 SHORT $LN71@z900_servi
  003b2	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ba	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  003be	48 39 84 24 38
	01 00 00	 cmp	 QWORD PTR sccb_first_byte$6[rsp], rax
  003c6	72 1c		 jb	 SHORT $LN72@z900_servi
  003c8	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d0	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  003d4	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  003da	48 39 84 24 38
	01 00 00	 cmp	 QWORD PTR sccb_first_byte$6[rsp], rax
  003e2	72 32		 jb	 SHORT $LN71@z900_servi
$LN72@z900_servi:
  003e4	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ec	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  003f0	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  003f8	72 2e		 jb	 SHORT $LN70@z900_servi
  003fa	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00402	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00406	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  0040c	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  00414	73 12		 jae	 SHORT $LN70@z900_servi
$LN71@z900_servi:

; 1524 :         )
; 1525 :             ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00416	ba 06 00 00 00	 mov	 edx, 6
  0041b	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00423	e8 00 00 00 00	 call	 z900_program_interrupt
$LN70@z900_servi:

; 1526 : 
; 1527 :         if (sccb_last_byte > regs->mainlim)

  00428	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00430	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00437	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  0043f	76 12		 jbe	 SHORT $LN73@z900_servi

; 1528 :             ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  00441	ba 05 00 00 00	 mov	 edx, 5
  00446	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN73@z900_servi:

; 1529 :     }
; 1530 : 
; 1531 :     /* Obtain lock if immediate response is not requested */
; 1532 :     if (!(sccb->flag & SCCB_FLAG_SYNC)
; 1533 :         || (sclp_command & SCLP_COMMAND_CLASS) == 0x01)

  00453	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00458	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0045c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00461	85 c0		 test	 eax, eax
  00463	74 11		 je	 SHORT $LN75@z900_servi
  00465	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  0046c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00471	83 f8 01	 cmp	 eax, 1
  00474	75 63		 jne	 SHORT $LN74@z900_servi
$LN75@z900_servi:

; 1534 :     {
; 1535 :         /* Obtain the interrupt lock */
; 1536 :         OBTAIN_INTLOCK( regs );

  00476	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203010
  0047d	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1537 : 
; 1538 :         /* If a service signal is pending then return condition
; 1539 :            code 2 to indicate that service processor is busy */
; 1540 :         if (IS_IC_SERVSIG && (sysblk.servparm & SERVSIG_ADDR))

  0048a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00491	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00497	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0049c	85 c0		 test	 eax, eax
  0049e	74 39		 je	 SHORT $LN76@z900_servi
  004a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004a7	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  004ad	83 e0 f8	 and	 eax, -8			; fffffff8H
  004b0	85 c0		 test	 eax, eax
  004b2	74 25		 je	 SHORT $LN76@z900_servi

; 1541 :         {
; 1542 :             RELEASE_INTLOCK( regs );

  004b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203012
  004bb	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c3	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1543 :             regs->psw.cc = 2;

  004c8	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d0	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 1544 :             return;

  004d4	e9 34 1c 00 00	 jmp	 $LN1@z900_servi
$LN76@z900_servi:
$LN74@z900_servi:

; 1545 :         }
; 1546 :     }
; 1547 : 
; 1548 :     /* Test SCLP command word */
; 1549 :     switch (sclp_command & SCLP_COMMAND_MASK)

  004d9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  004e0	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  004e5	89 44 24 78	 mov	 DWORD PTR tv254[rsp], eax
  004e9	81 7c 24 78 01
	00 1c 00	 cmp	 DWORD PTR tv254[rsp], 1835009 ; 001c0001H
  004f1	77 55		 ja	 SHORT $LN177@z900_servi
  004f3	81 7c 24 78 01
	00 1c 00	 cmp	 DWORD PTR tv254[rsp], 1835009 ; 001c0001H
  004fb	0f 84 97 09 00
	00		 je	 $LN98@z900_servi
  00501	81 7c 24 78 01
	00 02 00	 cmp	 DWORD PTR tv254[rsp], 131073 ; 00020001H
  00509	0f 84 a2 00 00
	00		 je	 $LN80@z900_servi
  0050f	81 7c 24 78 01
	00 03 00	 cmp	 DWORD PTR tv254[rsp], 196609 ; 00030001H
  00517	0f 84 31 07 00
	00		 je	 $LN92@z900_servi
  0051d	81 7c 24 78 01
	00 10 00	 cmp	 DWORD PTR tv254[rsp], 1048577 ; 00100001H
  00525	0f 84 aa 18 00
	00		 je	 $LN152@z900_servi
  0052b	81 7c 24 78 01
	00 11 00	 cmp	 DWORD PTR tv254[rsp], 1114113 ; 00110001H
  00533	0f 84 3f 18 00
	00		 je	 $LN150@z900_servi
  00539	81 7c 24 78 01
	00 12 00	 cmp	 DWORD PTR tv254[rsp], 1179649 ; 00120001H
  00541	74 42		 je	 SHORT $LN77@z900_servi
  00543	e9 ea 18 00 00	 jmp	 $LN154@z900_servi
$LN177@z900_servi:
  00548	81 7c 24 78 01
	00 25 00	 cmp	 DWORD PTR tv254[rsp], 2424833 ; 00250001H
  00550	0f 84 ba 16 00
	00		 je	 $LN145@z900_servi
  00556	81 7c 24 78 05
	00 76 00	 cmp	 DWORD PTR tv254[rsp], 7733253 ; 00760005H
  0055e	0f 84 ed 09 00
	00		 je	 $LN101@z900_servi
  00564	81 7c 24 78 05
	00 77 00	 cmp	 DWORD PTR tv254[rsp], 7798789 ; 00770005H
  0056c	0f 84 00 10 00
	00		 je	 $LN122@z900_servi
  00572	81 7c 24 78 05
	00 78 00	 cmp	 DWORD PTR tv254[rsp], 7864325 ; 00780005H
  0057a	0f 84 90 12 00
	00		 je	 $LN135@z900_servi
  00580	e9 ad 18 00 00	 jmp	 $LN154@z900_servi
$LN77@z900_servi:

; 1550 :     {
; 1551 :     case SCLP_READ_IFL_INFO:
; 1552 : 
; 1553 :         /* READ_IFL_INFO is only valid for processor type IFL */
; 1554 :         if (sysblk.ptyp[ regs->cpuad ] != SCCB_PTYP_IFL)

  00585	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058d	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00594	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0059b	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  005a3	83 f8 03	 cmp	 eax, 3
  005a6	74 07		 je	 SHORT $LN78@z900_servi

; 1555 :             goto invalidcmd;

  005a8	e9 85 18 00 00	 jmp	 $invalidcmd$181
  005ad	eb 02		 jmp	 SHORT $LN79@z900_servi
$LN78@z900_servi:

; 1556 :         else
; 1557 :             goto read_scpinfo;

  005af	eb 6e		 jmp	 SHORT $read_scpinfo$182
$LN79@z900_servi:
$LN80@z900_servi:

; 1558 : 
; 1559 :     case SCLP_READ_SCP_INFO:
; 1560 : 
; 1561 :         /* READ_SCP_INFO is only valid for processor type CP */
; 1562 :         if (sysblk.ptyp[ regs->cpuad ] != SCCB_PTYP_CP)

  005b1	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b9	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  005c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005c7	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  005cf	85 c0		 test	 eax, eax
  005d1	74 4c		 je	 SHORT $LN81@z900_servi

; 1563 :         {
; 1564 :             // "The configuration has been placed into a system check-
; 1565 :             //  stop state because of an incompatible service call"
; 1566 :             WRMSG( HHC00005, "W" );

  005d3	b9 01 00 00 00	 mov	 ecx, 1
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203018
  005e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203019
  005f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00601	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG203020
  00608	ba 1e 06 00 00	 mov	 edx, 1566		; 0000061eH
  0060d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203021
  00614	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1567 :             goto docheckstop;

  0061a	e9 f3 05 00 00	 jmp	 $docheckstop$183
$LN81@z900_servi:
$read_scpinfo$182:

; 1568 :             /*
; 1569 :              * Replace the following 2 lines with
; 1570 :              * goto invalidcmd
; 1571 :              * if this behavior is not satisfactory
; 1572 :              * ISW 20081221
; 1573 :              */
; 1574 :         }
; 1575 : 
; 1576 :     read_scpinfo:
; 1577 : 
; 1578 :         /* Set the main storage change bit */
; 1579 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  0061f	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00623	b2 02		 mov	 dl, 2
  00625	8b c8		 mov	 ecx, eax
  00627	e8 00 00 00 00	 call	 z900_or_storage_key

; 1580 : 
; 1581 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1582 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  0062c	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00630	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00636	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  0063b	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  0063f	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00643	8b c9		 mov	 ecx, ecx
  00645	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  0064c	48 3b c1	 cmp	 rax, rcx
  0064f	74 17		 je	 SHORT $LN82@z900_servi

; 1583 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1584 :         {
; 1585 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00651	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00656	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1586 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  0065a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0065f	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1587 :             break;

  00663	e9 b2 18 00 00	 jmp	 $LN14@z900_servi
$LN82@z900_servi:

; 1588 :         }
; 1589 : 
; 1590 :         /* Set response code X'0300' if SCCB length
; 1591 :            is insufficient to contain SCP info */
; 1592 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_SCP_INFO )

  00668	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  0066d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00674	48 63 89 00 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+256]
  0067b	48 6b c9 10	 imul	 rcx, rcx, 16
  0067f	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  00686	48 3b c1	 cmp	 rax, rcx
  00689	73 17		 jae	 SHORT $LN83@z900_servi

; 1593 :                 + (sizeof( SCCB_CPU_INFO ) * sysblk.maxcpu))
; 1594 :         {
; 1595 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  0068b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00690	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1596 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00694	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00699	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1597 :             break;

  0069d	e9 78 18 00 00	 jmp	 $LN14@z900_servi
$LN83@z900_servi:

; 1598 :         }
; 1599 : 
; 1600 :         /* Point to SCCB data area following SCCB header */
; 1601 :         sccbscp = (SCCB_SCP_INFO*)(sccb+1);

  006a2	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  006a7	48 83 c0 08	 add	 rax, 8
  006ab	48 89 44 24 70	 mov	 QWORD PTR sccbscp$[rsp], rax

; 1602 :         memset( sccbscp, 0, sizeof( SCCB_SCP_INFO ));

  006b0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR sccbscp$[rsp]
  006b5	33 c0		 xor	 eax, eax
  006b7	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  006bc	f3 aa		 rep stosb
$LN18@z900_servi:

; 1603 : 
; 1604 :         /* Set main storage size in SCCB...
; 1605 :          *
; 1606 :          * PROGRAMMING NOTE: Hercules can support main storage sizes
; 1607 :          * up to slightly less than 16 EB (16384 PB = 16777216 TB),
; 1608 :          * even if the host operating system cannot.
; 1609 :          *
; 1610 :          * The guest architecural limit however is constrained by the
; 1611 :          * width of the realinum and realiszm SCCB fields (number of
; 1612 :          * increments and increment size in MB) which are only 16 bits
; 1613 :          * and 8 bits wide respectively. Thus the guest's maximum
; 1614 :          * storage size is architecturally limited to slightly less
; 1615 :          * than 16 TB (65535 increments * 255 MB increment size).
; 1616 :          *
; 1617 :          * This means if our main storage size is >= 64GB we must set
; 1618 :          * the increment size to a value which ensures the resulting
; 1619 :          * number of increments remains <= 65535.
; 1620 :          */
; 1621 : 
; 1622 :         ASSERT( sysblk.mainsize <= MAX_SCP_STORSIZE );

  006be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006c5	48 b9 00 00 10
	f0 ef 0f 00 00	 mov	 rcx, 17523199180800	; 00000feff0100000H
  006cf	48 39 88 90 00
	00 00		 cmp	 QWORD PTR [rax+144], rcx
  006d6	76 5c		 jbe	 SHORT $LN84@z900_servi
$LN21@z900_servi:
  006d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG203025
  006df	41 b8 56 06 00
	00		 mov	 r8d, 1622		; 00000656H
  006e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203026
  006ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203027
  006f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006ff	85 c0		 test	 eax, eax
  00701	74 20		 je	 SHORT $LN85@z900_servi
  00703	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG203029
  0070a	41 b8 56 06 00
	00		 mov	 r8d, 1622		; 00000656H
  00710	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203030
  00717	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203031
  0071e	e8 00 00 00 00	 call	 DebuggerTrace
$LN85@z900_servi:
  00723	33 c0		 xor	 eax, eax
  00725	85 c0		 test	 eax, eax
  00727	75 af		 jne	 SHORT $LN21@z900_servi
  00729	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0072f	85 c0		 test	 eax, eax
  00731	74 01		 je	 SHORT $LN86@z900_servi
  00733	cc		 int	 3
$LN86@z900_servi:
$LN84@z900_servi:
  00734	33 c0		 xor	 eax, eax
  00736	85 c0		 test	 eax, eax
  00738	75 84		 jne	 SHORT $LN18@z900_servi

; 1623 :         incsizemb = (sysblk.mainsize + (MAX_1MINCR_STORSIZE - 1)) / MAX_1MINCR_STORSIZE;

  0073a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00741	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00748	48 b9 ff ff ef
	ff 0f 00 00 00	 mov	 rcx, 68718428159	; 0000000fffefffffH
  00752	48 03 c1	 add	 rax, rcx
  00755	33 d2		 xor	 edx, edx
  00757	48 b9 00 00 f0
	ff 0f 00 00 00	 mov	 rcx, 68718428160	; 0000000ffff00000H
  00761	48 f7 f1	 div	 rcx
  00764	89 84 24 f4 00
	00 00		 mov	 DWORD PTR incsizemb$[rsp], eax

; 1624 :         realinc = sysblk.mainsize / (incsizemb << SHIFT_MEGABYTE);

  0076b	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR incsizemb$[rsp]
  00772	c1 e0 14	 shl	 eax, 20
  00775	8b c0		 mov	 eax, eax
  00777	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv326[rsp], rax
  0077f	33 d2		 xor	 edx, edx
  00781	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00788	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  0078f	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv326[rsp]
  00797	48 f7 f1	 div	 rcx
  0079a	89 84 24 fc 00
	00 00		 mov	 DWORD PTR realinc$[rsp], eax

; 1625 : 
; 1626 :         STORE_HW( sccbscp->realinum, realinc );

  007a1	0f b7 8c 24 fc
	00 00 00	 movzx	 ecx, WORD PTR realinc$[rsp]
  007a9	e8 00 00 00 00	 call	 _byteswap_ushort
  007ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  007b3	0f b7 d0	 movzx	 edx, ax
  007b6	e8 00 00 00 00	 call	 store_hw_noswap

; 1627 :         sccbscp->realiszm = (incsizemb & 0xFF);

  007bb	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR incsizemb$[rsp]
  007c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  007cc	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 1628 :         sccbscp->realbszk = 4;

  007cf	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  007d4	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 1629 :         STORE_HW( sccbscp->realiint, 1 );

  007d8	66 b9 01 00	 mov	 cx, 1
  007dc	e8 00 00 00 00	 call	 _byteswap_ushort
  007e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  007e6	48 83 c1 04	 add	 rcx, 4
  007ea	0f b7 d0	 movzx	 edx, ax
  007ed	e8 00 00 00 00	 call	 store_hw_noswap

; 1630 : 
; 1631 : #if defined( _900 ) || defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1632 :         /* SIE supports the full address range */
; 1633 :         sccbscp->maxvm = 0;

  007f2	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  007f7	c6 40 5b 00	 mov	 BYTE PTR [rax+91], 0

; 1634 :         /* realiszm is valid */
; 1635 :         STORE_FW( sccbscp->grzm, 0 );

  007fb	33 c9		 xor	 ecx, ecx
  007fd	e8 00 00 00 00	 call	 _byteswap_ulong
  00802	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00807	48 83 c1 5c	 add	 rcx, 92			; 0000005cH
  0080b	8b d0		 mov	 edx, eax
  0080d	e8 00 00 00 00	 call	 store_fw_noswap

; 1636 :         /* Number of storage increments installed in esame mode */
; 1637 :         STORE_DW( sccbscp->grnmx, realinc );

  00812	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR realinc$[rsp]
  00819	8b c8		 mov	 ecx, eax
  0081b	e8 00 00 00 00	 call	 _byteswap_uint64
  00820	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00825	48 83 c1 60	 add	 rcx, 96			; 00000060H
  00829	48 8b d0	 mov	 rdx, rax
  0082c	e8 00 00 00 00	 call	 store_dw_noswap

; 1638 : #endif
; 1639 : 
; 1640 : #if defined( FEATURE_EXPANDED_STORAGE )
; 1641 :         /* Set expanded storage size in SCCB */
; 1642 :         xstincnum = sysblk.xpndsize /

  00831	33 d2		 xor	 edx, edx
  00833	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0083a	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00840	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00845	f7 f1		 div	 ecx
  00847	89 84 24 d8 00
	00 00		 mov	 DWORD PTR xstincnum$[rsp], eax

; 1643 :                     (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);
; 1644 :         STORE_FW( sccbscp->xpndinum, xstincnum );

  0084e	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR xstincnum$[rsp]
  00855	e8 00 00 00 00	 call	 _byteswap_ulong
  0085a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0085f	48 83 c1 18	 add	 rcx, 24
  00863	8b d0		 mov	 edx, eax
  00865	e8 00 00 00 00	 call	 store_fw_noswap

; 1645 :         xstblkinc = XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT;

  0086a	c7 84 24 b8 00
	00 00 00 01 00
	00		 mov	 DWORD PTR xstblkinc$[rsp], 256 ; 00000100H

; 1646 :         STORE_FW( sccbscp->xpndsz4K, xstblkinc );

  00875	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR xstblkinc$[rsp]
  0087c	e8 00 00 00 00	 call	 _byteswap_ulong
  00881	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00886	48 83 c1 1c	 add	 rcx, 28
  0088a	8b d0		 mov	 edx, eax
  0088c	e8 00 00 00 00	 call	 store_fw_noswap

; 1647 : #endif
; 1648 : 
; 1649 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1650 :         /* Set the Vector section size in the SCCB */
; 1651 :         STORE_HW( sccbscp->vectssiz, VECTOR_SECTION_SIZE );
; 1652 :         /* Set the Vector partial sum number in the SCCB */
; 1653 :         STORE_HW( sccbscp->vectpsum, VECTOR_PARTIAL_SUM_NUMBER );
; 1654 : #endif
; 1655 :         /* Set CPU array count and offset in SCCB */
; 1656 :         STORE_HW( sccbscp->numcpu, sysblk.maxcpu );

  00891	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00898	0f b7 88 00 01
	00 00		 movzx	 ecx, WORD PTR [rax+256]
  0089f	e8 00 00 00 00	 call	 _byteswap_ushort
  008a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  008a9	48 83 c1 08	 add	 rcx, 8
  008ad	0f b7 d0	 movzx	 edx, ax
  008b0	e8 00 00 00 00	 call	 store_hw_noswap

; 1657 :         offset = sizeof( SCCB_HEADER ) + sizeof( SCCB_SCP_INFO );

  008b5	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  008ba	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1658 :         STORE_HW( sccbscp->offcpu, offset );

  008bf	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  008c4	e8 00 00 00 00	 call	 _byteswap_ushort
  008c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  008ce	48 83 c1 0a	 add	 rcx, 10
  008d2	0f b7 d0	 movzx	 edx, ax
  008d5	e8 00 00 00 00	 call	 store_hw_noswap

; 1659 : 
; 1660 : #if defined( FEATURE_MPF_INFO )
; 1661 :         /* Set MPF array count and offset in SCCB */
; 1662 :         STORE_HW( sccbscp->nummpf, sysblk.maxcpu-1 );

  008da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008e1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008e7	ff c8		 dec	 eax
  008e9	0f b7 c8	 movzx	 ecx, ax
  008ec	e8 00 00 00 00	 call	 _byteswap_ushort
  008f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  008f6	48 83 c1 40	 add	 rcx, 64			; 00000040H
  008fa	0f b7 d0	 movzx	 edx, ax
  008fd	e8 00 00 00 00	 call	 store_hw_noswap

; 1663 : #endif
; 1664 :         offset += (U16)sizeof( SCCB_CPU_INFO ) * sysblk.maxcpu;

  00902	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00909	6b 80 00 01 00
	00 10		 imul	 eax, DWORD PTR [rax+256], 16
  00910	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  00915	03 c8		 add	 ecx, eax
  00917	8b c1		 mov	 eax, ecx
  00919	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1665 :         STORE_HW( sccbscp->offmpf, offset );

  0091e	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  00923	e8 00 00 00 00	 call	 _byteswap_ushort
  00928	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0092d	48 83 c1 42	 add	 rcx, 66			; 00000042H
  00931	0f b7 d0	 movzx	 edx, ax
  00934	e8 00 00 00 00	 call	 store_hw_noswap

; 1666 : 
; 1667 :         /* Set HSA array count and offset in SCCB */
; 1668 :         STORE_HW( sccbscp->numhsa, 0 );

  00939	33 c9		 xor	 ecx, ecx
  0093b	e8 00 00 00 00	 call	 _byteswap_ushort
  00940	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00945	48 83 c1 0c	 add	 rcx, 12
  00949	0f b7 d0	 movzx	 edx, ax
  0094c	e8 00 00 00 00	 call	 store_hw_noswap

; 1669 : 
; 1670 : #if defined( FEATURE_MPF_INFO )
; 1671 :         offset += (U16)sizeof( SCCB_MPF_INFO ) * sysblk.maxcpu-1;

  00951	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00958	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0095e	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  00963	8d 44 41 ff	 lea	 eax, DWORD PTR [rcx+rax*2-1]
  00967	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1672 : #endif
; 1673 :         STORE_HW( sccbscp->offhsa, offset );

  0096c	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  00971	e8 00 00 00 00	 call	 _byteswap_ushort
  00976	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0097b	48 83 c1 0e	 add	 rcx, 14
  0097f	0f b7 d0	 movzx	 edx, ax
  00982	e8 00 00 00 00	 call	 store_hw_noswap

; 1674 : 
; 1675 :         /* Build the MPF information array after the CPU info */
; 1676 :         /* Move IPL load parameter to SCCB */
; 1677 :         get_loadparm( sccbscp->loadparm );

  00987	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  0098c	48 83 c0 10	 add	 rax, 16
  00990	48 8b c8	 mov	 rcx, rax
  00993	e8 00 00 00 00	 call	 get_loadparm

; 1678 : 
; 1679 :         /* Set installed features bit mask in SCCB */
; 1680 :         memcpy( sccbscp->ifm, ARCH_DEP( scpinfo_ifm ), sizeof( sccbscp->ifm ));

  00998	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  0099d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR z900_scpinfo_ifm
  009a4	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1681 : 
; 1682 :         memcpy( sccbscp->cfg, ARCH_DEP( scpinfo_cfg ), sizeof( sccbscp->cfg ));

  009a8	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  009ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_scpinfo_cfg
  009b4	48 8d 78 48	 lea	 rdi, QWORD PTR [rax+72]
  009b8	48 8b f1	 mov	 rsi, rcx
  009bb	b9 06 00 00 00	 mov	 ecx, 6
  009c0	f3 a4		 rep movsb

; 1683 :         /* sccbscp->cfg11 = ARCH_DEP( scpinfo_cfg11 ); */
; 1684 : 
; 1685 :         /* Turn off bits for facilities that aren't enabled */
; 1686 :         if (!FACILITY_ENABLED( 016_EXT_TRANSL_2, regs ))

  009c2	b8 01 00 00 00	 mov	 eax, 1
  009c7	48 6b c0 02	 imul	 rax, rax, 2
  009cb	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009d3	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  009db	25 80 00 00 00	 and	 eax, 128		; 00000080H
  009e0	85 c0		 test	 eax, eax
  009e2	75 28		 jne	 SHORT $LN87@z900_servi

; 1687 :             sccbscp->cfg[4] &= ~SCCB_CFG4_EXTENDED_TRANSLATION_FACILITY2;

  009e4	b8 01 00 00 00	 mov	 eax, 1
  009e9	48 6b c0 04	 imul	 rax, rax, 4
  009ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  009f2	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  009f7	83 e0 ef	 and	 eax, -17
  009fa	b9 01 00 00 00	 mov	 ecx, 1
  009ff	48 6b c9 04	 imul	 rcx, rcx, 4
  00a03	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00a08	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN87@z900_servi:

; 1688 : 
; 1689 :         if (!FACILITY_ENABLED( 009_SENSE_RUN_STATUS, regs ))

  00a0c	b8 01 00 00 00	 mov	 eax, 1
  00a11	48 6b c0 01	 imul	 rax, rax, 1
  00a15	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a1d	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00a25	83 e0 40	 and	 eax, 64			; 00000040H
  00a28	85 c0		 test	 eax, eax
  00a2a	75 28		 jne	 SHORT $LN88@z900_servi

; 1690 :             sccbscp->cfg[5] &= ~SCCB_CFG5_SENSE_RUNNING_STATUS;

  00a2c	b8 01 00 00 00	 mov	 eax, 1
  00a31	48 6b c0 05	 imul	 rax, rax, 5
  00a35	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00a3a	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00a3f	83 e0 f7	 and	 eax, -9
  00a42	b9 01 00 00 00	 mov	 ecx, 1
  00a47	48 6b c9 05	 imul	 rcx, rcx, 5
  00a4b	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00a50	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN88@z900_servi:

; 1691 : 
; 1692 :         /* Turn on additioal bits for facilities that ARE enabled */
; 1693 :         if (0
; 1694 : #if defined( _FEATURE_HYPERVISOR )
; 1695 :             || FACILITY_ENABLED( HERC_LOGICAL_PARTITION, regs )
; 1696 : #endif
; 1697 : #if defined( _FEATURE_EMULATE_VM )
; 1698 :             || FACILITY_ENABLED( HERC_VIRTUAL_MACHINE, regs )

  00a54	33 c0		 xor	 eax, eax
  00a56	85 c0		 test	 eax, eax
  00a58	75 40		 jne	 SHORT $LN90@z900_servi
  00a5a	b8 01 00 00 00	 mov	 eax, 1
  00a5f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00a63	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00a73	83 e0 08	 and	 eax, 8
  00a76	85 c0		 test	 eax, eax
  00a78	75 20		 jne	 SHORT $LN90@z900_servi
  00a7a	b8 01 00 00 00	 mov	 eax, 1
  00a7f	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00a83	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00a93	83 e0 01	 and	 eax, 1
  00a96	85 c0		 test	 eax, eax
  00a98	74 29		 je	 SHORT $LN89@z900_servi
$LN90@z900_servi:

; 1699 : #endif
; 1700 :         )
; 1701 :             sccbscp->cfg[0] |= SCCB_CFG0_LOGICALLY_PARTITIONED;

  00a9a	b8 01 00 00 00	 mov	 eax, 1
  00a9f	48 6b c0 00	 imul	 rax, rax, 0
  00aa3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00aa8	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00aad	0f ba e8 07	 bts	 eax, 7
  00ab1	b9 01 00 00 00	 mov	 ecx, 1
  00ab6	48 6b c9 00	 imul	 rcx, rcx, 0
  00aba	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00abf	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN89@z900_servi:

; 1702 : 
; 1703 : #if defined( _900 ) || defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1704 :         if (FACILITY_ENABLED( 001_ZARCH_INSTALLED, regs ))

  00ac3	b8 01 00 00 00	 mov	 eax, 1
  00ac8	48 6b c0 00	 imul	 rax, rax, 0
  00acc	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ad4	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00adc	83 e0 40	 and	 eax, 64			; 00000040H
  00adf	85 c0		 test	 eax, eax
  00ae1	74 28		 je	 SHORT $LN91@z900_servi

; 1705 :             sccbscp->cfg[5] |= SCCB_CFG5_ESAME;

  00ae3	b8 01 00 00 00	 mov	 eax, 1
  00ae8	48 6b c0 05	 imul	 rax, rax, 5
  00aec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00af1	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00af6	83 c8 01	 or	 eax, 1
  00af9	b9 01 00 00 00	 mov	 ecx, 1
  00afe	48 6b c9 05	 imul	 rcx, rcx, 5
  00b02	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00b07	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN91@z900_servi:

; 1706 : #endif
; 1707 : 
; 1708 :         /* Build the CPU information array after the SCP info */
; 1709 :         sccbcpu = (SCCB_CPU_INFO*)(sccbscp+1);

  00b0b	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00b10	48 83 c0 78	 add	 rax, 120		; 00000078H
  00b14	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR sccbcpu$[rsp], rax

; 1710 : 
; 1711 :         for (i=0; i < sysblk.maxcpu; i++, sccbcpu++)

  00b1c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00b24	eb 1e		 jmp	 SHORT $LN24@z900_servi
$LN22@z900_servi:
  00b26	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00b2a	ff c0		 inc	 eax
  00b2c	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
  00b30	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b38	48 83 c0 10	 add	 rax, 16
  00b3c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR sccbcpu$[rsp], rax
$LN24@z900_servi:
  00b44	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b4b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00b51	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00b55	7d 6d		 jge	 SHORT $LN23@z900_servi

; 1712 :         {
; 1713 :             memset( sccbcpu, 0, sizeof( SCCB_CPU_INFO ));

  00b57	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR sccbcpu$[rsp]
  00b5f	33 c0		 xor	 eax, eax
  00b61	b9 10 00 00 00	 mov	 ecx, 16
  00b66	f3 aa		 rep stosb

; 1714 :             sccbcpu->cpa = i;

  00b68	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b70	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR i$[rsp]
  00b75	88 08		 mov	 BYTE PTR [rax], cl

; 1715 :             sccbcpu->tod = 0;

  00b77	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b7f	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 1716 :             memcpy( sccbcpu->cpf, ARCH_DEP( scpinfo_cpf ), sizeof( sccbcpu->cpf ));

  00b83	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_scpinfo_cpf
  00b92	48 8d 78 02	 lea	 rdi, QWORD PTR [rax+2]
  00b96	48 8b f1	 mov	 rsi, rcx
  00b99	b9 0c 00 00 00	 mov	 ecx, 12
  00b9e	f3 a4		 rep movsb

; 1717 :             sccbcpu->ptyp = sysblk.ptyp[i];

  00ba0	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00ba5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR sccbcpu$[rsp]
  00bad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00bb4	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  00bbc	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 1718 : 
; 1719 : #if defined( FEATURE_CRYPTO )
; 1720 : //          sccbcpu->ksid = SCCB_KSID_CRYPTO_UNIT_ID;
; 1721 : #endif
; 1722 : 
; 1723 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1724 : 
; 1725 :             if (IS_CPU_ONLINE(i) && sysblk.regs[i]->vf->online)
; 1726 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_INSTALLED;
; 1727 :             if (IS_CPU_ONLINE(i) && sysblk.regs[i]->vf->online)
; 1728 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_CONNECTED;
; 1729 :             if (!IS_CPU_ONLINE(i))
; 1730 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_STANDBY_STATE;
; 1731 : #endif
; 1732 :         }

  00bbf	e9 62 ff ff ff	 jmp	 $LN22@z900_servi
$LN23@z900_servi:

; 1733 : 
; 1734 : #if defined( FEATURE_MPF_INFO )
; 1735 : 
; 1736 :         /* Define machine capacity */
; 1737 :         STORE_FW( sccbscp->rcci, 10000 );

  00bc4	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00bc9	e8 00 00 00 00	 call	 _byteswap_ulong
  00bce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00bd3	48 83 c1 4e	 add	 rcx, 78			; 0000004eH
  00bd7	8b d0		 mov	 edx, eax
  00bd9	e8 00 00 00 00	 call	 store_fw_noswap

; 1738 : 
; 1739 :         /* Fill in the MP Factors array */
; 1740 :         sccbmpf = (SCCB_MPF_INFO*)(sccbcpu);

  00bde	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00be6	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR sccbmpf$[rsp], rax

; 1741 :         get_mpfactors((BYTE*)sccbmpf);

  00bee	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR sccbmpf$[rsp]
  00bf6	e8 00 00 00 00	 call	 get_mpfactors

; 1742 : #endif
; 1743 : 
; 1744 :         /* Set response code X'0010' in SCCB header */
; 1745 :         sccb->reas = SCCB_REAS_NONE;

  00bfb	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c00	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1746 :         sccb->resp = SCCB_RESP_INFO;

  00c04	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c09	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1747 :         break;

  00c0d	e9 08 13 00 00	 jmp	 $LN14@z900_servi
$docheckstop$183:

; 1748 : 
; 1749 : docheckstop:
; 1750 : 
; 1751 :         ARCH_DEP( checkstop_all_cpus )( regs );

  00c12	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c1a	e8 00 00 00 00	 call	 z900_checkstop_all_cpus

; 1752 :         RELEASE_INTLOCK( regs );

  00c1f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203038
  00c26	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c2e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1753 :         longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  00c33	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c3b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00c41	ba ff ff ff ff	 mov	 edx, -1
  00c46	48 8b c8	 mov	 rcx, rax
  00c49	e8 00 00 00 00	 call	 longjmp
$LN92@z900_servi:

; 1754 :         UNREACHABLE_CODE( return );
; 1755 : 
; 1756 :     case SCLP_READ_CHP_INFO:
; 1757 : 
; 1758 :         /* Set the main storage change bit */
; 1759 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00c4e	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00c52	b2 02		 mov	 dl, 2
  00c54	8b c8		 mov	 ecx, eax
  00c56	e8 00 00 00 00	 call	 z900_or_storage_key

; 1760 : 
; 1761 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1762 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00c5b	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00c5f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00c65	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00c6a	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00c6e	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00c72	8b c9		 mov	 ecx, ecx
  00c74	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00c7b	48 3b c1	 cmp	 rax, rcx
  00c7e	74 17		 je	 SHORT $LN93@z900_servi

; 1763 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1764 :         {
; 1765 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00c80	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c85	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1766 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00c89	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c8e	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1767 :             break;

  00c92	e9 83 12 00 00	 jmp	 $LN14@z900_servi
$LN93@z900_servi:

; 1768 :         }
; 1769 : 
; 1770 :         /* Set response code X'0300' if SCCB length
; 1771 :            is insufficient to contain channel path info */
; 1772 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_CHP_INFO ))

  00c97	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00c9c	48 83 f8 68	 cmp	 rax, 104		; 00000068H
  00ca0	73 17		 jae	 SHORT $LN94@z900_servi

; 1773 :         {
; 1774 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  00ca2	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00ca7	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1775 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00cab	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00cb0	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1776 :             break;

  00cb4	e9 61 12 00 00	 jmp	 $LN14@z900_servi
$LN94@z900_servi:

; 1777 :         }
; 1778 : 
; 1779 : #if defined( FEATURE_S370_CHANNEL )
; 1780 : 
; 1781 :         /* Point to SCCB data area following SCCB header */
; 1782 :         sccbchp = (SCCB_CHSET_INFO*)(sccb+1);
; 1783 :         memset( sccbchp, 0, sizeof( SCCB_CHSET_INFO ));
; 1784 : #else
; 1785 :         /* Point to SCCB data area following SCCB header */
; 1786 :         sccbchp = (SCCB_CHP_INFO*)(sccb+1);

  00cb9	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00cbe	48 83 c0 08	 add	 rax, 8
  00cc2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR sccbchp$[rsp], rax

; 1787 :         memset( sccbchp, 0, sizeof( SCCB_CHP_INFO ));

  00cca	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR sccbchp$[rsp]
  00cd2	33 c0		 xor	 eax, eax
  00cd4	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00cd9	f3 aa		 rep stosb

; 1788 : #endif
; 1789 : 
; 1790 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1791 : 
; 1792 :         /* Identify CHPIDs installed, standby, and online */
; 1793 :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00cdb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ce2	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00ce9	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  00cf1	eb 14		 jmp	 SHORT $LN27@z900_servi
$LN25@z900_servi:
  00cf3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cfb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00cff	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN27@z900_servi:
  00d07	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d10	0f 84 6b 01 00
	00		 je	 $LN26@z900_servi

; 1794 :         {
; 1795 :             for (i=0; i < 8; i++)

  00d16	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00d1e	eb 0a		 jmp	 SHORT $LN30@z900_servi
$LN28@z900_servi:
  00d20	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00d24	ff c0		 inc	 eax
  00d26	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN30@z900_servi:
  00d2a	83 7c 24 50 08	 cmp	 DWORD PTR i$[rsp], 8
  00d2f	0f 8d 47 01 00
	00		 jge	 $LN29@z900_servi

; 1796 :             {
; 1797 :                 chpbyte = dev->pmcw.chpid[i] / 8;

  00d35	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00d3a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d42	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00d4a	99		 cdq
  00d4b	83 e2 07	 and	 edx, 7
  00d4e	03 c2		 add	 eax, edx
  00d50	c1 f8 03	 sar	 eax, 3
  00d53	89 84 24 98 00
	00 00		 mov	 DWORD PTR chpbyte$[rsp], eax

; 1798 :                 chpbit  = dev->pmcw.chpid[i] % 8;

  00d5a	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00d5f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d67	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00d6f	99		 cdq
  00d70	83 e2 07	 and	 edx, 7
  00d73	03 c2		 add	 eax, edx
  00d75	83 e0 07	 and	 eax, 7
  00d78	2b c2		 sub	 eax, edx
  00d7a	89 84 24 d4 00
	00 00		 mov	 DWORD PTR chpbit$[rsp], eax

; 1799 : 
; 1800 :                 if ( ((0x80 >> i) & dev->pmcw.pim))

  00d81	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00d85	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00d8a	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv1661[rsp], ecx
  00d91	0f b6 c8	 movzx	 ecx, al
  00d94	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv1661[rsp]
  00d9b	d3 f8		 sar	 eax, cl
  00d9d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00da5	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  00dac	23 c1		 and	 eax, ecx
  00dae	85 c0		 test	 eax, eax
  00db0	0f 84 c1 00 00
	00		 je	 $LN95@z900_servi

; 1801 :                 {
; 1802 :                     sccbchp->installed  [ chpbyte ] |= 0x80 >> chpbit;

  00db6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00dbd	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00dc4	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00dc9	d3 fa		 sar	 edx, cl
  00dcb	8b ca		 mov	 ecx, edx
  00dcd	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00dd5	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00dd9	0b c1		 or	 eax, ecx
  00ddb	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00de2	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00dea	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1803 : 
; 1804 :                     if (dev->pmcw.flag5 & PMCW5_V)

  00ded	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00df5	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00dfc	83 e0 01	 and	 eax, 1
  00dff	85 c0		 test	 eax, eax
  00e01	74 3b		 je	 SHORT $LN96@z900_servi

; 1805 :                         sccbchp->online [ chpbyte ] |= 0x80 >> chpbit;

  00e03	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00e0a	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00e11	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00e16	d3 fa		 sar	 edx, cl
  00e18	8b ca		 mov	 ecx, edx
  00e1a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00e22	0f b6 44 02 40	 movzx	 eax, BYTE PTR [rdx+rax+64]
  00e27	0b c1		 or	 eax, ecx
  00e29	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00e30	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00e38	88 44 0a 40	 mov	 BYTE PTR [rdx+rcx+64], al
  00e3c	eb 39		 jmp	 SHORT $LN97@z900_servi
$LN96@z900_servi:

; 1806 :                     else
; 1807 :                         sccbchp->standby[ chpbyte ] |= 0x80 >> chpbit;

  00e3e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00e45	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00e4c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00e51	d3 fa		 sar	 edx, cl
  00e53	8b ca		 mov	 ecx, edx
  00e55	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00e5d	0f b6 44 02 20	 movzx	 eax, BYTE PTR [rdx+rax+32]
  00e62	0b c1		 or	 eax, ecx
  00e64	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00e6b	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00e73	88 44 0a 20	 mov	 BYTE PTR [rdx+rcx+32], al
$LN97@z900_servi:
$LN95@z900_servi:

; 1808 :                 }
; 1809 :             }

  00e77	e9 a4 fe ff ff	 jmp	 $LN28@z900_servi
$LN29@z900_servi:

; 1810 :         }

  00e7c	e9 72 fe ff ff	 jmp	 $LN25@z900_servi
$LN26@z900_servi:

; 1811 : #endif
; 1812 : 
; 1813 : #if defined( FEATURE_S370_CHANNEL )
; 1814 : 
; 1815 :         /* For S/370, initialize identifiers for channel set 0A */
; 1816 :         for (i=0; i < 16; i++)
; 1817 :         {
; 1818 :             sccbchp->chanset0a[ 2*i + 0 ] = 0x80;
; 1819 :             sccbchp->chanset0a[ 2*i + 1 ] = i;
; 1820 :         }
; 1821 : 
; 1822 :         /* Set the channel set configuration byte */
; 1823 :         sccbchp->csconfig = 0xC0;
; 1824 : 
; 1825 : #endif
; 1826 : 
; 1827 :         /* Set response code X'0010' in SCCB header */
; 1828 :         sccb->reas = SCCB_REAS_NONE;

  00e81	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e86	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1829 :         sccb->resp = SCCB_RESP_INFO;

  00e8a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e8f	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1830 :         break;

  00e93	e9 82 10 00 00	 jmp	 $LN14@z900_servi
$LN98@z900_servi:

; 1831 : 
; 1832 :     case SCLP_READ_CSI_INFO:
; 1833 : 
; 1834 :         /* Set the main storage change bit */
; 1835 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00e98	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00e9c	b2 02		 mov	 dl, 2
  00e9e	8b c8		 mov	 ecx, eax
  00ea0	e8 00 00 00 00	 call	 z900_or_storage_key

; 1836 : 
; 1837 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1838 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00ea5	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00ea9	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00eaf	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00eb4	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00eb8	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00ebc	8b c9		 mov	 ecx, ecx
  00ebe	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00ec5	48 3b c1	 cmp	 rax, rcx
  00ec8	74 17		 je	 SHORT $LN99@z900_servi

; 1839 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1840 :         {
; 1841 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00eca	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00ecf	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1842 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00ed3	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00ed8	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1843 :             break;

  00edc	e9 39 10 00 00	 jmp	 $LN14@z900_servi
$LN99@z900_servi:

; 1844 :         }
; 1845 : 
; 1846 :         /* Set response code X'0300' if SCCB length
; 1847 :            is insufficient to contain channel path info */
; 1848 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_CSI_INFO ))

  00ee1	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00ee6	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00eea	73 17		 jae	 SHORT $LN100@z900_servi

; 1849 :         {
; 1850 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  00eec	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00ef1	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1851 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00ef5	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00efa	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1852 :             break;

  00efe	e9 17 10 00 00	 jmp	 $LN14@z900_servi
$LN100@z900_servi:

; 1853 :         }
; 1854 : 
; 1855 :         /* Point to SCCB data area following SCCB header */
; 1856 :         sccbcsi = (SCCB_CSI_INFO*)(sccb+1);

  00f03	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f08	48 83 c0 08	 add	 rax, 8
  00f0c	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR sccbcsi$[rsp], rax

; 1857 :         memset( sccbcsi, 0, sizeof( SCCB_CSI_INFO ));

  00f14	48 8b bc 24 48
	01 00 00	 mov	 rdi, QWORD PTR sccbcsi$[rsp]
  00f1c	33 c0		 xor	 eax, eax
  00f1e	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00f23	f3 aa		 rep stosb

; 1858 : 
; 1859 :         sccbcsi->csif[0] =

  00f25	b8 01 00 00 00	 mov	 eax, 1
  00f2a	48 6b c0 00	 imul	 rax, rax, 0
  00f2e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR sccbcsi$[rsp]
  00f36	c6 04 01 03	 mov	 BYTE PTR [rcx+rax], 3

; 1860 :             0
; 1861 : #if defined( FEATURE_CANCEL_IO_FACILITY )
; 1862 :             | SCCB_CSI0_CANCEL_IO_REQUEST_FACILITY
; 1863 : #endif
; 1864 :             | SCCB_CSI0_CONCURRENT_SENSE_FACILITY
; 1865 :             ;
; 1866 : 
; 1867 :         /* Set response code X'0010' in SCCB header */
; 1868 :         sccb->reas = SCCB_REAS_NONE;

  00f3a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f3f	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1869 :         sccb->resp = SCCB_RESP_INFO;

  00f43	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f48	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1870 :         break;

  00f4c	e9 c9 0f 00 00	 jmp	 $LN14@z900_servi
$LN101@z900_servi:

; 1871 : 
; 1872 : #if defined( FEATURE_SYSTEM_CONSOLE )
; 1873 : 
; 1874 :     case SCLP_WRITE_EVENT_DATA:
; 1875 : 
; 1876 :         /* Set the main storage change bit */
; 1877 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00f51	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00f55	b2 02		 mov	 dl, 2
  00f57	8b c8		 mov	 ecx, eax
  00f59	e8 00 00 00 00	 call	 z900_or_storage_key

; 1878 : 
; 1879 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1880 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00f5e	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00f62	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00f68	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00f6d	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00f71	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00f75	8b c9		 mov	 ecx, ecx
  00f77	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00f7e	48 3b c1	 cmp	 rax, rcx
  00f81	74 17		 je	 SHORT $LN102@z900_servi

; 1881 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1882 :         {
; 1883 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00f83	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f88	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1884 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00f8c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f91	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1885 :             break;

  00f95	e9 80 0f 00 00	 jmp	 $LN14@z900_servi
$LN102@z900_servi:

; 1886 :         }
; 1887 : 
; 1888 :         /* Point to SCCB data area following SCCB header */
; 1889 :         evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  00f9a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f9f	48 83 c0 08	 add	 rax, 8
  00fa3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 1890 :         FETCH_HW( evd_len, evd_hdr->totlen );

  00fab	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00fb3	48 8b c8	 mov	 rcx, rax
  00fb6	e8 00 00 00 00	 call	 fetch_hw_noswap
  00fbb	0f b7 c8	 movzx	 ecx, ax
  00fbe	e8 00 00 00 00	 call	 _byteswap_ushort
  00fc3	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR evd_len$[rsp], ax

; 1891 : 
; 1892 :         switch (evd_hdr->type)

  00fcb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00fd3	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00fd7	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv669[rsp], eax
  00fde	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv669[rsp]
  00fe5	83 e8 02	 sub	 eax, 2
  00fe8	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv669[rsp], eax
  00fef	83 bc 24 b4 00
	00 00 1a	 cmp	 DWORD PTR tv669[rsp], 26
  00ff7	0f 87 89 04 00
	00		 ja	 $LN119@z900_servi
  00ffd	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv669[rsp]
  01005	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0100c	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN178@z900_servi[rcx+rax]
  01014	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN179@z900_servi[rcx+rax*4]
  0101b	48 03 c1	 add	 rax, rcx
  0101e	ff e0		 jmp	 rax
$LN103@z900_servi:
$LN104@z900_servi:
$LN33@z900_servi:

; 1893 :         {
; 1894 :         case SCCB_EVD_TYPE_MSG:
; 1895 :         case SCCB_EVD_TYPE_PRIOR:
; 1896 : 
; 1897 :             while (sccblen > sizeof( SCCB_HEADER ))

  01020	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  01025	48 83 f8 08	 cmp	 rax, 8
  01029	0f 86 f5 03 00
	00		 jbe	 $LN34@z900_servi

; 1898 :             {
; 1899 :                 FETCH_HW( evd_len, evd_hdr->totlen );

  0102f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  01037	48 8b c8	 mov	 rcx, rax
  0103a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0103f	0f b7 c8	 movzx	 ecx, ax
  01042	e8 00 00 00 00	 call	 _byteswap_ushort
  01047	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR evd_len$[rsp], ax

; 1900 : 
; 1901 :                 /* Point to the Message Control Data Block */
; 1902 :                 mcd_bk = (SCCB_MCD_BK*)(evd_hdr+1);

  0104f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  01057	48 83 c0 06	 add	 rax, 6
  0105b	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR mcd_bk$[rsp], rax

; 1903 :                 FETCH_HW( mcd_len, mcd_bk->length );

  01063	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR mcd_bk$[rsp]
  0106b	48 8b c8	 mov	 rcx, rax
  0106e	e8 00 00 00 00	 call	 fetch_hw_noswap
  01073	0f b7 c8	 movzx	 ecx, ax
  01076	e8 00 00 00 00	 call	 _byteswap_ushort
  0107b	66 89 84 24 88
	00 00 00	 mov	 WORD PTR mcd_len$[rsp], ax

; 1904 : 
; 1905 :                 obj_hdr = (SCCB_OBJ_HDR*)(mcd_bk+1);

  01083	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR mcd_bk$[rsp]
  0108b	48 83 c0 0c	 add	 rax, 12
  0108f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR obj_hdr$[rsp], rax
$LN35@z900_servi:

; 1906 : 
; 1907 :                 while (mcd_len > sizeof( SCCB_MCD_BK ))

  01097	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR mcd_len$[rsp]
  0109f	48 83 f8 0c	 cmp	 rax, 12
  010a3	0f 86 27 03 00
	00		 jbe	 $LN36@z900_servi

; 1908 :                 {
; 1909 :                     FETCH_HW( obj_len, obj_hdr->length );

  010a9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  010b1	48 8b c8	 mov	 rcx, rax
  010b4	e8 00 00 00 00	 call	 fetch_hw_noswap
  010b9	0f b7 c8	 movzx	 ecx, ax
  010bc	e8 00 00 00 00	 call	 _byteswap_ushort
  010c1	66 89 84 24 80
	00 00 00	 mov	 WORD PTR obj_len$[rsp], ax

; 1910 : 
; 1911 :                     if (obj_len == 0)

  010c9	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  010d1	85 c0		 test	 eax, eax
  010d3	75 17		 jne	 SHORT $LN105@z900_servi

; 1912 :                     {
; 1913 :                         sccb->reas = SCCB_REAS_BUFF_LEN_ERR;

  010d5	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  010da	c6 40 06 72	 mov	 BYTE PTR [rax+6], 114	; 00000072H

; 1914 :                         sccb->resp = SCCB_RESP_BUFF_LEN_ERR;

  010de	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  010e3	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 1915 :                         break;

  010e7	e9 e4 02 00 00	 jmp	 $LN36@z900_servi
$LN105@z900_servi:

; 1916 :                     }
; 1917 : 
; 1918 :                     FETCH_HW( obj_type, obj_hdr->type );

  010ec	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  010f4	48 83 c0 02	 add	 rax, 2
  010f8	48 8b c8	 mov	 rcx, rax
  010fb	e8 00 00 00 00	 call	 fetch_hw_noswap
  01100	0f b7 c8	 movzx	 ecx, ax
  01103	e8 00 00 00 00	 call	 _byteswap_ushort
  01108	66 89 84 24 d0
	00 00 00	 mov	 WORD PTR obj_type$[rsp], ax

; 1919 : 
; 1920 :                     if (obj_type == SCCB_OBJ_TYPE_MESSAGE)

  01110	0f b7 84 24 d0
	00 00 00	 movzx	 eax, WORD PTR obj_type$[rsp]
  01118	83 f8 04	 cmp	 eax, 4
  0111b	0f 85 70 02 00
	00		 jne	 $LN106@z900_servi

; 1921 :                     {
; 1922 :                         mto_bk = (SCCB_MTO_BK*)(obj_hdr+1);

  01121	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  01129	48 83 c0 04	 add	 rax, 4
  0112d	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR mto_bk$[rsp], rax

; 1923 :                         evd_msg = (BYTE*)(mto_bk+1);

  01135	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR mto_bk$[rsp]
  0113d	48 83 c0 06	 add	 rax, 6
  01141	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR evd_msg$[rsp], rax

; 1924 :                         event_msglen = obj_len -

  01149	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  01151	48 83 e8 0a	 sub	 rax, 10
  01155	89 84 24 84 00
	00 00		 mov	 DWORD PTR event_msglen$[rsp], eax

; 1925 :                                 (sizeof( SCCB_OBJ_HDR ) + sizeof( SCCB_MTO_BK ));
; 1926 : 
; 1927 :                         if (event_msglen < 0)

  0115c	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR event_msglen$[rsp], 0
  01164	7d 17		 jge	 SHORT $LN107@z900_servi

; 1928 :                         {
; 1929 :                             sccb->reas = SCCB_REAS_BUFF_LEN_ERR;

  01166	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0116b	c6 40 06 72	 mov	 BYTE PTR [rax+6], 114	; 00000072H

; 1930 :                             sccb->resp = SCCB_RESP_BUFF_LEN_ERR;

  0116f	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01174	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 1931 :                             break;

  01178	e9 53 02 00 00	 jmp	 $LN36@z900_servi
$LN107@z900_servi:

; 1932 :                         }
; 1933 : 
; 1934 :                         /* Make sure we don't overflow our buffer! */
; 1935 :                         if (event_msglen >= (int) sizeof( message ) - 1)

  0117d	81 bc 24 84 00
	00 00 f8 0f 00
	00		 cmp	 DWORD PTR event_msglen$[rsp], 4088 ; 00000ff8H
  01188	7c 76		 jl	 SHORT $LN108@z900_servi

; 1936 :                         {
; 1937 :                             int trunc_len = (int) sizeof( message ) - 1;

  0118a	c7 84 24 00 01
	00 00 f8 0f 00
	00		 mov	 DWORD PTR trunc_len$3[rsp], 4088 ; 00000ff8H

; 1938 :                             // "Overly long %d byte SCP message truncated to %d bytes"
; 1939 :                             WRMSG( HHC00159, "W", event_msglen, trunc_len );

  01195	b9 01 00 00 00	 mov	 ecx, 1
  0119a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011a0	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR trunc_len$3[rsp]
  011a7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011ab	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR event_msglen$[rsp]
  011b2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  011b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203056
  011bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203057
  011c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  011d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG203058
  011e0	ba 93 07 00 00	 mov	 edx, 1939		; 00000793H
  011e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203059
  011ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1940 :                             event_msglen = trunc_len;

  011f2	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR trunc_len$3[rsp]
  011f9	89 84 24 84 00
	00 00		 mov	 DWORD PTR event_msglen$[rsp], eax
$LN108@z900_servi:

; 1941 :                         }
; 1942 : 
; 1943 :                         /* Print line unless it is a response prompt */
; 1944 :                         if (!(mto_bk->ltflag[0] & SCCB_MTO_LTFLG0_PROMPT))

  01200	b8 01 00 00 00	 mov	 eax, 1
  01205	48 6b c0 00	 imul	 rax, rax, 0
  01209	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR mto_bk$[rsp]
  01211	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01215	83 e0 08	 and	 eax, 8
  01218	85 c0		 test	 eax, eax
  0121a	0f 85 71 01 00
	00		 jne	 $LN109@z900_servi

; 1945 :                         {
; 1946 :                             static bool s390x_linux_detected = false;
; 1947 :                             static bool is_s390x_linux = false;
; 1948 : 
; 1949 : #if 0 // debug: save raw EBCDIC message for test program
; 1950 : static bool once = false;
; 1951 : static FILE* efile;
; 1952 : U16 u16_len = (U16) event_msglen;
; 1953 : U16 big_endian_u16_len = CSWAP16( u16_len );
; 1954 : if (!once)
; 1955 : {
; 1956 :     once = true;
; 1957 :     efile = fopen( "e_msgs.dat", "wb" );
; 1958 : }
; 1959 : fwrite( &big_endian_u16_len, 1, 2, efile );
; 1960 : fwrite( evd_msg, 1, u16_len, efile );
; 1961 : fflush( efile );
; 1962 : #endif // debug: save raw EBCDIC message for test program
; 1963 : 
; 1964 :                             /* Try to auto-detect if this is s390x Linux */
; 1965 :                             if (!s390x_linux_detected)

  01220	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?s390x_linux_detected@?CG@??z900_service_call@@9@9
  01227	85 c0		 test	 eax, eax
  01229	75 3a		 jne	 SHORT $LN110@z900_servi

; 1966 :                             {
; 1967 :                                 /* Look for EBCDIC 'ESC' character */
; 1968 :                                 if (event_msglen && memchr( evd_msg, 0x4A, event_msglen ))

  0122b	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR event_msglen$[rsp], 0
  01233	74 30		 je	 SHORT $LN111@z900_servi
  01235	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR event_msglen$[rsp]
  0123d	4c 8b c0	 mov	 r8, rax
  01240	ba 4a 00 00 00	 mov	 edx, 74			; 0000004aH
  01245	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  0124d	e8 00 00 00 00	 call	 memchr
  01252	48 85 c0	 test	 rax, rax
  01255	74 0e		 je	 SHORT $LN111@z900_servi

; 1969 :                                 {
; 1970 :                                     s390x_linux_detected = true;

  01257	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s390x_linux_detected@?CG@??z900_service_call@@9@9, 1

; 1971 :                                     is_s390x_linux = true;

  0125e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?is_s390x_linux@?CG@??z900_service_call@@9@9, 1
$LN111@z900_servi:
$LN110@z900_servi:

; 1972 :                                 }
; 1973 :                             }
; 1974 : 
; 1975 :                             /* If this is s390x Linux... */
; 1976 :                             if (is_s390x_linux)

  01265	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?is_s390x_linux@?CG@??z900_service_call@@9@9
  0126c	85 c0		 test	 eax, eax
  0126e	74 19		 je	 SHORT $LN112@z900_servi

; 1977 :                             {
; 1978 :                                 /* Try to remove terminal escape sequences.
; 1979 :                                    Note: also does LOGMSG as appropriate. */
; 1980 :                                 gh534_fix( event_msglen, evd_msg );

  01270	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR evd_msg$[rsp]
  01278	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR event_msglen$[rsp]
  0127f	e8 00 00 00 00	 call	 gh534_fix

; 1981 :                             }

  01284	e9 08 01 00 00	 jmp	 $LN113@z900_servi
$LN112@z900_servi:

; 1982 :                             else /* Normal processing: show message as-is */
; 1983 :                             {
; 1984 :                                 for (i=0; i < event_msglen; i++)

  01289	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01291	eb 0a		 jmp	 SHORT $LN39@z900_servi
$LN37@z900_servi:
  01293	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01297	ff c0		 inc	 eax
  01299	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN39@z900_servi:
  0129d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR event_msglen$[rsp]
  012a4	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  012a8	7d 6d		 jge	 SHORT $LN38@z900_servi

; 1985 :                                 {
; 1986 :                                     message[i] = isprint( guest_to_host( evd_msg[i] )) ?

  012aa	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  012af	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  012b7	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  012bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  012c1	0f b6 c0	 movzx	 eax, al
  012c4	8b c8		 mov	 ecx, eax
  012c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  012cc	85 c0		 test	 eax, eax
  012ce	74 23		 je	 SHORT $LN165@z900_servi
  012d0	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  012d5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  012dd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  012e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  012e7	0f b6 c0	 movzx	 eax, al
  012ea	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv793[rsp], eax
  012f1	eb 0b		 jmp	 SHORT $LN166@z900_servi
$LN165@z900_servi:
  012f3	c7 84 24 f0 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv793[rsp], 32 ; 00000020H
$LN166@z900_servi:
  012fe	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  01303	0f b6 8c 24 f0
	00 00 00	 movzx	 ecx, BYTE PTR tv793[rsp]
  0130b	88 8c 04 c0 01
	00 00		 mov	 BYTE PTR message$[rsp+rax], cl

; 1987 :                                         guest_to_host( evd_msg[i] ) : ' ';
; 1988 :                                 }

  01312	e9 7c ff ff ff	 jmp	 $LN37@z900_servi
$LN38@z900_servi:

; 1989 :                                 message[i] = '\0';

  01317	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0131c	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR $T7[rsp], rax
  01324	48 81 bc 24 60
	01 00 00 f9 0f
	00 00		 cmp	 QWORD PTR $T7[rsp], 4089 ; 00000ff9H
  01330	73 02		 jae	 SHORT $LN167@z900_servi
  01332	eb 05		 jmp	 SHORT $LN168@z900_servi
$LN167@z900_servi:
  01334	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN168@z900_servi:
  01339	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  01341	c6 84 04 c0 01
	00 00 00	 mov	 BYTE PTR message$[rsp+rax], 0

; 1990 :                                 LOGMSG("%s\n",message);

  01349	b9 01 00 00 00	 mov	 ecx, 1
  0134e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01354	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  0135c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203065
  01368	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0136d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01372	41 b9 03 00 00
	00		 mov	 r9d, 3
  01378	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG203066
  0137f	ba c6 07 00 00	 mov	 edx, 1990		; 000007c6H
  01384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203067
  0138b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN113@z900_servi:
$LN109@z900_servi:
$LN106@z900_servi:

; 1991 :                             }
; 1992 :                         }
; 1993 :                     }
; 1994 : 
; 1995 :                     mcd_len -= obj_len;

  01391	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  01399	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR mcd_len$[rsp]
  013a1	2b c8		 sub	 ecx, eax
  013a3	8b c1		 mov	 eax, ecx
  013a5	66 89 84 24 88
	00 00 00	 mov	 WORD PTR mcd_len$[rsp], ax

; 1996 :                     obj_hdr=(SCCB_OBJ_HDR *)((BYTE*)obj_hdr + obj_len);

  013ad	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  013b5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR obj_hdr$[rsp]
  013bd	48 03 c8	 add	 rcx, rax
  013c0	48 8b c1	 mov	 rax, rcx
  013c3	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR obj_hdr$[rsp], rax

; 1997 :                 }

  013cb	e9 c7 fc ff ff	 jmp	 $LN35@z900_servi
$LN36@z900_servi:

; 1998 : 
; 1999 :                 /* Indicate Event Processed */
; 2000 :                 evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  013d0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  013d8	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  013dc	0f ba e8 07	 bts	 eax, 7
  013e0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  013e8	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 2001 : 
; 2002 :                 sccblen -= evd_len;

  013eb	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR evd_len$[rsp]
  013f3	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  013f8	2b c8		 sub	 ecx, eax
  013fa	8b c1		 mov	 eax, ecx
  013fc	66 89 44 24 60	 mov	 WORD PTR sccblen$[rsp], ax

; 2003 :                 evd_hdr = (SCCB_EVD_HDR *)((BYTE*)evd_hdr + evd_len);

  01401	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR evd_len$[rsp]
  01409	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  01411	48 03 c8	 add	 rcx, rax
  01414	48 8b c1	 mov	 rax, rcx
  01417	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 2004 :             }

  0141f	e9 fc fb ff ff	 jmp	 $LN33@z900_servi
$LN34@z900_servi:

; 2005 : 
; 2006 :             /* Set response code X'0020' in SCCB header */
; 2007 :             sccb->reas = SCCB_REAS_NONE;

  01424	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01429	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2008 :             sccb->resp = SCCB_RESP_COMPLETE;

  0142d	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01432	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2009 :             break;

  01436	e9 32 01 00 00	 jmp	 $LN31@z900_servi
$LN114@z900_servi:

; 2010 : 
; 2011 :         case SCCB_EVD_TYPE_CPIDENT:
; 2012 :             sclp_cpident(sccb);

  0143b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01440	e8 00 00 00 00	 call	 sclp_cpident

; 2013 :             break;

  01445	e9 23 01 00 00	 jmp	 $LN31@z900_servi
$LN115@z900_servi:

; 2014 : 
; 2015 : #if defined( FEATURE_SCEDIO )
; 2016 : 
; 2017 :         case SCCB_EVD_TYPE_SCEDIO:
; 2018 :             ARCH_DEP( sclp_scedio_request )( sccb );

  0144a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0144f	e8 00 00 00 00	 call	 z900_sclp_scedio_request

; 2019 :             break;

  01454	e9 14 01 00 00	 jmp	 $LN31@z900_servi
$LN116@z900_servi:

; 2020 : #endif
; 2021 : 
; 2022 : #if defined( _FEATURE_HARDWARE_LOADER )
; 2023 : 
; 2024 :         case SCCB_EVD_TYPE_HWL:
; 2025 :             ARCH_DEP( sclp_hwl_request )( sccb );

  01459	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0145e	e8 00 00 00 00	 call	 z900_sclp_hwl_request

; 2026 :             break;

  01463	e9 05 01 00 00	 jmp	 $LN31@z900_servi
$LN117@z900_servi:

; 2027 : 
; 2028 :         case SCCB_EVD_TYPE_SDIAS:
; 2029 :             ARCH_DEP( sclp_sdias_request )( sccb );

  01468	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0146d	e8 00 00 00 00	 call	 z900_sclp_sdias_request

; 2030 :             break;

  01472	e9 f6 00 00 00	 jmp	 $LN31@z900_servi
$LN118@z900_servi:

; 2031 : #endif
; 2032 : 
; 2033 : #if defined( FEATURE_INTEGRATED_3270_CONSOLE )
; 2034 : 
; 2035 :         case SCCB_EVD_TYPE_SYSG:
; 2036 :             sclp_sysg_write( sccb );

  01477	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0147c	e8 00 00 00 00	 call	 sclp_sysg_write

; 2037 :             break;

  01481	e9 e7 00 00 00	 jmp	 $LN31@z900_servi
$LN119@z900_servi:
$LN42@z900_servi:

; 2038 : #endif
; 2039 : 
; 2040 : #if defined( FEATURE_INTEGRATED_ASCII_CONSOLE )
; 2041 : 
; 2042 :         case SCCB_EVD_TYPE_VT220:
; 2043 :             sclp_sysa_write( sccb );
; 2044 :             break;
; 2045 : #endif
; 2046 : 
; 2047 :         default:
; 2048 : 
; 2049 :             PTT_ERR("*SERVC", regs->GR_L(r1), regs->GR_L(r2), evd_hdr->type );

  01486	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0148d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01490	48 83 e0 10	 and	 rax, 16
  01494	48 85 c0	 test	 rax, rax
  01497	74 6a		 je	 SHORT $LN120@z900_servi
  01499	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  014a1	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  014a5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  014ac	48 8b 94 24 f8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  014b4	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  014bb	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  014c2	48 8b bc 24 f8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  014ca	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  014d1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  014da	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  014df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG203075
  014e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014eb	44 8b c9	 mov	 r9d, ecx
  014ee	44 8b c2	 mov	 r8d, edx
  014f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203076
  014f8	b9 10 00 00 00	 mov	 ecx, 16
  014fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN120@z900_servi:
  01503	33 c0		 xor	 eax, eax
  01505	85 c0		 test	 eax, eax
  01507	0f 85 79 ff ff
	ff		 jne	 $LN42@z900_servi

; 2050 : 
; 2051 :             if (HDC3( debug_sclp_unknown_event, evd_hdr, sccb, regs ))

  0150d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event
  01514	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01518	74 28		 je	 SHORT $LN169@z900_servi
  0151a	4c 8b 84 24 f8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01522	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  01527	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  0152f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event
  01536	ff 10		 call	 QWORD PTR [rax]
  01538	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv860[rsp], rax
  01540	eb 0c		 jmp	 SHORT $LN170@z900_servi
$LN169@z900_servi:
  01542	48 c7 84 24 68
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv860[rsp], 0
$LN170@z900_servi:
  0154e	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR tv860[rsp], 0
  01557	74 02		 je	 SHORT $LN121@z900_servi

; 2052 :                 break;

  01559	eb 12		 jmp	 SHORT $LN31@z900_servi
$LN121@z900_servi:

; 2053 : 
; 2054 :             /* Set response code X'73F0' in SCCB header */
; 2055 :             sccb->reas = SCCB_REAS_SYNTAX_ERROR;

  0155b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01560	c6 40 06 73	 mov	 BYTE PTR [rax+6], 115	; 00000073H

; 2056 :             sccb->resp = SCCB_RESP_SYNTAX_ERROR;

  01564	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01569	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN31@z900_servi:

; 2057 :             break;
; 2058 :         }
; 2059 :         break;

  0156d	e9 a8 09 00 00	 jmp	 $LN14@z900_servi
$LN122@z900_servi:

; 2060 : 
; 2061 :     case SCLP_READ_EVENT_DATA:
; 2062 : 
; 2063 :         /* Set the main storage change bit */
; 2064 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  01572	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01576	b2 02		 mov	 dl, 2
  01578	8b c8		 mov	 ecx, eax
  0157a	e8 00 00 00 00	 call	 z900_or_storage_key

; 2065 : 
; 2066 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2067 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  0157f	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01583	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01589	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  0158e	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  01592	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  01596	8b c9		 mov	 ecx, ecx
  01598	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  0159f	48 3b c1	 cmp	 rax, rcx
  015a2	74 17		 je	 SHORT $LN123@z900_servi

; 2068 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2069 :         {
; 2070 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  015a4	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  015a9	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2071 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  015ad	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  015b2	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2072 :             break;

  015b6	e9 5f 09 00 00	 jmp	 $LN14@z900_servi
$LN123@z900_servi:

; 2073 :         }
; 2074 : 
; 2075 :         /* Point to SCCB data area following SCCB header */
; 2076 :         evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  015bb	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  015c0	48 83 c0 08	 add	 rax, 8
  015c4	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 2077 : 
; 2078 :         if (SCLP_RECV_ENABLED(               PRIOR ) &&

  015cc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  015d2	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  015d7	85 c0		 test	 eax, eax
  015d9	74 20		 je	 SHORT $LN124@z900_servi
  015db	66 b9 09 00	 mov	 cx, 9
  015df	e8 00 00 00 00	 call	 sclp_attn_pending
  015e4	85 c0		 test	 eax, eax
  015e6	74 13		 je	 SHORT $LN124@z900_servi

; 2079 :             sclp_attn_pending( SCCB_EVD_TYPE_PRIOR ))
; 2080 :         {
; 2081 :             sclp_opcmd_event(sccb, SCCB_EVD_TYPE_PRIOR);

  015e8	66 ba 09 00	 mov	 dx, 9
  015ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  015f1	e8 00 00 00 00	 call	 sclp_opcmd_event

; 2082 :             break;

  015f6	e9 1f 09 00 00	 jmp	 $LN14@z900_servi
$LN124@z900_servi:

; 2083 :         }
; 2084 : 
; 2085 :         if (SCLP_RECV_ENABLED(               OPCMD ) &&

  015fb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01601	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01606	85 c0		 test	 eax, eax
  01608	74 20		 je	 SHORT $LN125@z900_servi
  0160a	66 b9 01 00	 mov	 cx, 1
  0160e	e8 00 00 00 00	 call	 sclp_attn_pending
  01613	85 c0		 test	 eax, eax
  01615	74 13		 je	 SHORT $LN125@z900_servi

; 2086 :             sclp_attn_pending( SCCB_EVD_TYPE_OPCMD ))
; 2087 :         {
; 2088 :             sclp_opcmd_event(sccb, SCCB_EVD_TYPE_OPCMD);

  01617	66 ba 01 00	 mov	 dx, 1
  0161b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01620	e8 00 00 00 00	 call	 sclp_opcmd_event

; 2089 :             break;

  01625	e9 f0 08 00 00	 jmp	 $LN14@z900_servi
$LN125@z900_servi:

; 2090 :         }
; 2091 : 
; 2092 : #if defined( FEATURE_SCEDIO )
; 2093 : 
; 2094 :         if (SCLP_RECV_ENABLED(               SCEDIO ) &&

  0162a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01630	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  01635	85 c0		 test	 eax, eax
  01637	74 1c		 je	 SHORT $LN126@z900_servi
  01639	66 b9 07 00	 mov	 cx, 7
  0163d	e8 00 00 00 00	 call	 sclp_attn_pending
  01642	85 c0		 test	 eax, eax
  01644	74 0f		 je	 SHORT $LN126@z900_servi

; 2095 :             sclp_attn_pending( SCCB_EVD_TYPE_SCEDIO ))
; 2096 :         {
; 2097 :             ARCH_DEP( sclp_scedio_event )( sccb );

  01646	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0164b	e8 00 00 00 00	 call	 z900_sclp_scedio_event

; 2098 :             break;

  01650	e9 c5 08 00 00	 jmp	 $LN14@z900_servi
$LN126@z900_servi:

; 2099 :         }
; 2100 : #endif
; 2101 : 
; 2102 : #if defined( _FEATURE_HARDWARE_LOADER )
; 2103 : 
; 2104 :         if (SCLP_RECV_ENABLED(               HWL ) &&

  01655	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  0165b	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  01660	85 c0		 test	 eax, eax
  01662	74 1c		 je	 SHORT $LN127@z900_servi
  01664	66 b9 0c 00	 mov	 cx, 12
  01668	e8 00 00 00 00	 call	 sclp_attn_pending
  0166d	85 c0		 test	 eax, eax
  0166f	74 0f		 je	 SHORT $LN127@z900_servi

; 2105 :             sclp_attn_pending( SCCB_EVD_TYPE_HWL ))
; 2106 :         {
; 2107 :             ARCH_DEP( sclp_hwl_event )( sccb );

  01671	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01676	e8 00 00 00 00	 call	 z900_sclp_hwl_event

; 2108 :             break;

  0167b	e9 9a 08 00 00	 jmp	 $LN14@z900_servi
$LN127@z900_servi:

; 2109 :         }
; 2110 : 
; 2111 :         if (SCLP_RECV_ENABLED(               SDIAS ) &&

  01680	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01686	83 e0 10	 and	 eax, 16
  01689	85 c0		 test	 eax, eax
  0168b	74 1c		 je	 SHORT $LN128@z900_servi
  0168d	66 b9 1c 00	 mov	 cx, 28
  01691	e8 00 00 00 00	 call	 sclp_attn_pending
  01696	85 c0		 test	 eax, eax
  01698	74 0f		 je	 SHORT $LN128@z900_servi

; 2112 :             sclp_attn_pending( SCCB_EVD_TYPE_SDIAS ))
; 2113 :         {
; 2114 :             ARCH_DEP( sclp_sdias_event )( sccb );

  0169a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  0169f	e8 00 00 00 00	 call	 z900_sclp_sdias_event

; 2115 :             break;

  016a4	e9 71 08 00 00	 jmp	 $LN14@z900_servi
$LN128@z900_servi:

; 2116 :         }
; 2117 : #endif
; 2118 : 
; 2119 : #if defined( FEATURE_INTEGRATED_3270_CONSOLE )
; 2120 : 
; 2121 :         if (SCLP_RECV_ENABLED(               SYSG ) &&

  016a9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  016af	83 e0 20	 and	 eax, 32			; 00000020H
  016b2	85 c0		 test	 eax, eax
  016b4	74 1c		 je	 SHORT $LN129@z900_servi
  016b6	66 b9 1b 00	 mov	 cx, 27
  016ba	e8 00 00 00 00	 call	 sclp_attn_pending
  016bf	85 c0		 test	 eax, eax
  016c1	74 0f		 je	 SHORT $LN129@z900_servi

; 2122 :             sclp_attn_pending( SCCB_EVD_TYPE_SYSG ))
; 2123 :         {
; 2124 :             sclp_sysg_poll( sccb );

  016c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  016c8	e8 00 00 00 00	 call	 sclp_sysg_poll

; 2125 :             break;

  016cd	e9 48 08 00 00	 jmp	 $LN14@z900_servi
$LN129@z900_servi:

; 2126 :         }
; 2127 : #endif
; 2128 : 
; 2129 : #if defined( FEATURE_INTEGRATED_ASCII_CONSOLE )
; 2130 : 
; 2131 :         if (SCLP_RECV_ENABLED(               VT220 ) &&
; 2132 :             sclp_attn_pending( SCCB_EVD_TYPE_VT220 ))
; 2133 :         {
; 2134 :             sclp_sysa_poll( sccb );
; 2135 :             break;
; 2136 :         }
; 2137 : #endif
; 2138 : 
; 2139 :         if (SCLP_RECV_ENABLED(               SIGQ ) &&

  016d2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  016d8	83 e0 08	 and	 eax, 8
  016db	85 c0		 test	 eax, eax
  016dd	74 1c		 je	 SHORT $LN130@z900_servi
  016df	66 b9 1d 00	 mov	 cx, 29
  016e3	e8 00 00 00 00	 call	 sclp_attn_pending
  016e8	85 c0		 test	 eax, eax
  016ea	74 0f		 je	 SHORT $LN130@z900_servi

; 2140 :             sclp_attn_pending( SCCB_EVD_TYPE_SIGQ ))
; 2141 :         {
; 2142 :             sclp_sigq_event( sccb );

  016ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  016f1	e8 00 00 00 00	 call	 sclp_sigq_event

; 2143 :             break;

  016f6	e9 1f 08 00 00	 jmp	 $LN14@z900_servi
$LN130@z900_servi:
$LN45@z900_servi:

; 2144 :         }
; 2145 : 
; 2146 :         PTT_ERR("*SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  016fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01702	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01705	48 83 e0 10	 and	 rax, 16
  01709	48 85 c0	 test	 rax, rax
  0170c	74 6c		 je	 SHORT $LN131@z900_servi
  0170e	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01716	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0171c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  01723	48 8b 94 24 f8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0172b	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  01732	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  01739	48 8b bc 24 f8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01741	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  01748	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01751	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01756	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG203088
  0175d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01762	44 8b c9	 mov	 r9d, ecx
  01765	44 8b c2	 mov	 r8d, edx
  01768	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203089
  0176f	b9 10 00 00 00	 mov	 ecx, 16
  01774	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN131@z900_servi:
  0177a	33 c0		 xor	 eax, eax
  0177c	85 c0		 test	 eax, eax
  0177e	0f 85 77 ff ff
	ff		 jne	 $LN45@z900_servi

; 2147 : 
; 2148 :         if (HDC3( debug_sclp_event_data, evd_hdr, sccb, regs ))

  01784	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_event_data
  0178b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0178f	74 28		 je	 SHORT $LN171@z900_servi
  01791	4c 8b 84 24 f8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01799	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  0179e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  017a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_event_data
  017ad	ff 10		 call	 QWORD PTR [rax]
  017af	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv985[rsp], rax
  017b7	eb 0c		 jmp	 SHORT $LN172@z900_servi
$LN171@z900_servi:
  017b9	48 c7 84 24 70
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv985[rsp], 0
$LN172@z900_servi:
  017c5	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR tv985[rsp], 0
  017ce	74 05		 je	 SHORT $LN132@z900_servi

; 2149 :             break;

  017d0	e9 45 07 00 00	 jmp	 $LN14@z900_servi
$LN132@z900_servi:

; 2150 : 
; 2151 :         /* Set response code X'62F0' if events are pending but suppressed */
; 2152 :         if (sclp_attn_pending( 0 ))

  017d5	33 c9		 xor	 ecx, ecx
  017d7	e8 00 00 00 00	 call	 sclp_attn_pending
  017dc	85 c0		 test	 eax, eax
  017de	74 19		 je	 SHORT $LN133@z900_servi

; 2153 :         {
; 2154 :             sccb->reas = SCCB_REAS_EVENTS_SUP;

  017e0	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017e5	c6 40 06 62	 mov	 BYTE PTR [rax+6], 98	; 00000062H

; 2155 :             sccb->resp = SCCB_RESP_EVENTS_SUP;

  017e9	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017ee	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2156 :             break;

  017f2	e9 23 07 00 00	 jmp	 $LN14@z900_servi

; 2157 :         }

  017f7	eb 12		 jmp	 SHORT $LN134@z900_servi
$LN133@z900_servi:

; 2158 :         else
; 2159 :         {
; 2160 :             /* Set response code X'60F0' if no outstanding events */
; 2161 :             sccb->reas = SCCB_REAS_NO_EVENTS;

  017f9	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017fe	c6 40 06 60	 mov	 BYTE PTR [rax+6], 96	; 00000060H

; 2162 :             sccb->resp = SCCB_RESP_NO_EVENTS;

  01802	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01807	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN134@z900_servi:

; 2163 :         }
; 2164 :         break;

  0180b	e9 0a 07 00 00	 jmp	 $LN14@z900_servi
$LN135@z900_servi:

; 2165 : 
; 2166 :     case SCLP_WRITE_EVENT_MASK:
; 2167 : 
; 2168 :         /* Set the main storage change bit */
; 2169 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  01810	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01814	b2 02		 mov	 dl, 2
  01816	8b c8		 mov	 ecx, eax
  01818	e8 00 00 00 00	 call	 z900_or_storage_key

; 2170 : 
; 2171 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2172 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  0181d	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01821	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01827	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  0182c	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  01830	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  01834	8b c9		 mov	 ecx, ecx
  01836	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  0183d	48 3b c1	 cmp	 rax, rcx
  01840	74 17		 je	 SHORT $LN136@z900_servi

; 2173 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2174 :         {
; 2175 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  01842	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01847	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2176 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  0184b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01850	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2177 :             break;

  01854	e9 c1 06 00 00	 jmp	 $LN14@z900_servi
$LN136@z900_servi:

; 2178 :         }
; 2179 : 
; 2180 :         /* Point to SCCB data area following SCCB header */
; 2181 :         evd_mask = (SCCB_EVT_MASK*)(sccb+1);

  01859	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0185e	48 83 c0 08	 add	 rax, 8
  01862	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR evd_mask$[rsp], rax

; 2182 : 
; 2183 :         /* Get length of single mask field */
; 2184 :         FETCH_HW( masklen, evd_mask->length );

  0186a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR evd_mask$[rsp]
  01872	48 83 c0 02	 add	 rax, 2
  01876	48 8b c8	 mov	 rcx, rax
  01879	e8 00 00 00 00	 call	 fetch_hw_noswap
  0187e	0f b7 c8	 movzx	 ecx, ax
  01881	e8 00 00 00 00	 call	 _byteswap_ushort
  01886	0f b7 c0	 movzx	 eax, ax
  01889	89 44 24 7c	 mov	 DWORD PTR masklen$[rsp], eax

; 2185 : 
; 2186 :         /* Save old mask settings in order to suppress superflous messages */
; 2187 :         old_cp_recv_mask = servc_cp_recv_mask & ARCH_DEP( sclp_send_mask ) & SCCB_EVENT_CONS_RECV_MASK;

  0188d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_send_mask
  01893	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  01899	23 c8		 and	 ecx, eax
  0189b	8b c1		 mov	 eax, ecx
  0189d	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  018a2	89 84 24 28 01
	00 00		 mov	 DWORD PTR old_cp_recv_mask$[rsp], eax

; 2188 :         old_cp_send_mask = servc_cp_send_mask & ARCH_DEP( sclp_recv_mask ) & SCCB_EVENT_CONS_SEND_MASK;

  018a9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_recv_mask
  018af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  018b5	23 c8		 and	 ecx, eax
  018b7	8b c1		 mov	 eax, ecx
  018b9	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  018be	89 84 24 30 01
	00 00		 mov	 DWORD PTR old_cp_send_mask$[rsp], eax

; 2189 : 
; 2190 :         for (i=0; i < 4; i++)

  018c5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  018cd	eb 0a		 jmp	 SHORT $LN48@z900_servi
$LN46@z900_servi:
  018cf	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  018d3	ff c0		 inc	 eax
  018d5	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN48@z900_servi:
  018d9	83 7c 24 50 04	 cmp	 DWORD PTR i$[rsp], 4
  018de	0f 8d 84 00 00
	00		 jge	 $LN47@z900_servi

; 2191 :         {
; 2192 :             servc_cp_recv_mask <<= 8;

  018e4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  018ea	c1 e0 08	 shl	 eax, 8
  018ed	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_recv_mask, eax

; 2193 :             servc_cp_send_mask <<= 8;

  018f3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_send_mask
  018f9	c1 e0 08	 shl	 eax, 8
  018fc	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_send_mask, eax

; 2194 : 
; 2195 :             if ((U32)i < masklen)

  01902	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  01906	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  0190a	73 57		 jae	 SHORT $LN137@z900_servi

; 2196 :             {
; 2197 :                 servc_cp_recv_mask |= evd_mask->masks[ i+(0*masklen) ];

  0190c	6b 44 24 7c 00	 imul	 eax, DWORD PTR masklen$[rsp], 0
  01911	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01915	03 c8		 add	 ecx, eax
  01917	8b c1		 mov	 eax, ecx
  01919	8b c0		 mov	 eax, eax
  0191b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  01923	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  01928	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  0192e	0b c8		 or	 ecx, eax
  01930	8b c1		 mov	 eax, ecx
  01932	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_recv_mask, eax

; 2198 :                 servc_cp_send_mask |= evd_mask->masks[ i+(1*masklen) ];

  01938	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  0193c	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01940	03 c8		 add	 ecx, eax
  01942	8b c1		 mov	 eax, ecx
  01944	8b c0		 mov	 eax, eax
  01946	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  0194e	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  01953	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01959	0b c8		 or	 ecx, eax
  0195b	8b c1		 mov	 eax, ecx
  0195d	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_send_mask, eax
$LN137@z900_servi:

; 2199 :             }
; 2200 :         }

  01963	e9 67 ff ff ff	 jmp	 $LN46@z900_servi
$LN47@z900_servi:

; 2201 : 
; 2202 :         if (0
; 2203 :             || (servc_cp_recv_mask & ~ARCH_DEP( sclp_recv_mask ))
; 2204 :             || (servc_cp_send_mask & ~ARCH_DEP( sclp_send_mask ))

  01968	33 c0		 xor	 eax, eax
  0196a	85 c0		 test	 eax, eax
  0196c	75 2c		 jne	 SHORT $LN139@z900_servi
  0196e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_recv_mask
  01974	f7 d0		 not	 eax
  01976	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  0197c	23 c8		 and	 ecx, eax
  0197e	8b c1		 mov	 eax, ecx
  01980	85 c0		 test	 eax, eax
  01982	75 16		 jne	 SHORT $LN139@z900_servi
  01984	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_send_mask
  0198a	f7 d0		 not	 eax
  0198c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01992	23 c8		 and	 ecx, eax
  01994	8b c1		 mov	 eax, ecx
  01996	85 c0		 test	 eax, eax
  01998	74 41		 je	 SHORT $LN138@z900_servi
$LN139@z900_servi:

; 2205 :         )
; 2206 :         {
; 2207 :             HDC3( debug_sclp_unknown_event_mask, evd_mask, sccb, regs );

  0199a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event_mask
  019a1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  019a5	74 28		 je	 SHORT $LN173@z900_servi
  019a7	4c 8b 84 24 f8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  019af	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  019b4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  019bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event_mask
  019c3	ff 10		 call	 QWORD PTR [rax]
  019c5	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv1051[rsp], rax
  019cd	eb 0c		 jmp	 SHORT $LN174@z900_servi
$LN173@z900_servi:
  019cf	48 c7 84 24 98
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv1051[rsp], 0
$LN174@z900_servi:
$LN138@z900_servi:

; 2208 :         }
; 2209 : 
; 2210 :         /* Write the events that we support back */
; 2211 :         memset( &evd_mask->masks[ 2*masklen ], 0, 2 * masklen );

  019db	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  019df	03 c0		 add	 eax, eax
  019e1	8b c0		 mov	 eax, eax
  019e3	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv1055[rsp], rax
  019eb	8b 4c 24 7c	 mov	 ecx, DWORD PTR masklen$[rsp]
  019ef	03 c9		 add	 ecx, ecx
  019f1	8b c9		 mov	 ecx, ecx
  019f3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  019fb	48 8d 4c 0a 04	 lea	 rcx, QWORD PTR [rdx+rcx+4]
  01a00	48 8b f9	 mov	 rdi, rcx
  01a03	33 c0		 xor	 eax, eax
  01a05	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv1055[rsp]
  01a0d	f3 aa		 rep stosb

; 2212 : 
; 2213 :         for (i=0; (i < 4) && ((U32)i < masklen); i++)

  01a0f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01a17	eb 0a		 jmp	 SHORT $LN51@z900_servi
$LN49@z900_servi:
  01a19	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01a1d	ff c0		 inc	 eax
  01a1f	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN51@z900_servi:
  01a23	83 7c 24 50 04	 cmp	 DWORD PTR i$[rsp], 4
  01a28	0f 8d b9 00 00
	00		 jge	 $LN50@z900_servi
  01a2e	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  01a32	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01a36	0f 83 ab 00 00
	00		 jae	 $LN50@z900_servi

; 2214 :         {
; 2215 :             evd_mask->masks[ i+(2*masklen) ] |= (ARCH_DEP( sclp_recv_mask ) >> ((3-i)*8)) & 0xFF;

  01a3c	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01a40	8b 4c 24 7c	 mov	 ecx, DWORD PTR masklen$[rsp]
  01a44	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  01a47	8b c0		 mov	 eax, eax
  01a49	b9 03 00 00 00	 mov	 ecx, 3
  01a4e	2b 4c 24 50	 sub	 ecx, DWORD PTR i$[rsp]
  01a52	c1 e1 03	 shl	 ecx, 3
  01a55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR z900_sclp_recv_mask
  01a5b	d3 ea		 shr	 edx, cl
  01a5d	8b ca		 mov	 ecx, edx
  01a5f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01a65	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01a6d	0f b6 44 02 04	 movzx	 eax, BYTE PTR [rdx+rax+4]
  01a72	0b c1		 or	 eax, ecx
  01a74	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01a78	8b 54 24 7c	 mov	 edx, DWORD PTR masklen$[rsp]
  01a7c	8d 0c 51	 lea	 ecx, DWORD PTR [rcx+rdx*2]
  01a7f	8b c9		 mov	 ecx, ecx
  01a81	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01a89	88 44 0a 04	 mov	 BYTE PTR [rdx+rcx+4], al

; 2216 :             evd_mask->masks[ i+(3*masklen) ] |= (ARCH_DEP( sclp_send_mask ) >> ((3-i)*8)) & 0xFF;

  01a8d	6b 44 24 7c 03	 imul	 eax, DWORD PTR masklen$[rsp], 3
  01a92	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01a96	03 c8		 add	 ecx, eax
  01a98	8b c1		 mov	 eax, ecx
  01a9a	8b c0		 mov	 eax, eax
  01a9c	b9 03 00 00 00	 mov	 ecx, 3
  01aa1	2b 4c 24 50	 sub	 ecx, DWORD PTR i$[rsp]
  01aa5	c1 e1 03	 shl	 ecx, 3
  01aa8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR z900_sclp_send_mask
  01aae	d3 ea		 shr	 edx, cl
  01ab0	8b ca		 mov	 ecx, edx
  01ab2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01ab8	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01ac0	0f b6 44 02 04	 movzx	 eax, BYTE PTR [rdx+rax+4]
  01ac5	0b c1		 or	 eax, ecx
  01ac7	6b 4c 24 7c 03	 imul	 ecx, DWORD PTR masklen$[rsp], 3
  01acc	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  01ad0	03 d1		 add	 edx, ecx
  01ad2	8b ca		 mov	 ecx, edx
  01ad4	8b c9		 mov	 ecx, ecx
  01ad6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01ade	88 44 0a 04	 mov	 BYTE PTR [rdx+rcx+4], al

; 2217 :         }

  01ae2	e9 32 ff ff ff	 jmp	 $LN49@z900_servi
$LN50@z900_servi:

; 2218 : 
; 2219 :         /* Issue message only when supported mask has changed */
; 2220 :         if (0
; 2221 :             || (servc_cp_recv_mask & ARCH_DEP( sclp_send_mask ) & SCCB_EVENT_CONS_RECV_MASK) != old_cp_recv_mask
; 2222 :             || (servc_cp_send_mask & ARCH_DEP( sclp_recv_mask ) & SCCB_EVENT_CONS_SEND_MASK) != old_cp_send_mask

  01ae7	33 c0		 xor	 eax, eax
  01ae9	85 c0		 test	 eax, eax
  01aeb	75 40		 jne	 SHORT $LN141@z900_servi
  01aed	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_send_mask
  01af3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  01af9	23 c8		 and	 ecx, eax
  01afb	8b c1		 mov	 eax, ecx
  01afd	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  01b02	3b 84 24 28 01
	00 00		 cmp	 eax, DWORD PTR old_cp_recv_mask$[rsp]
  01b09	75 22		 jne	 SHORT $LN141@z900_servi
  01b0b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR z900_sclp_recv_mask
  01b11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01b17	23 c8		 and	 ecx, eax
  01b19	8b c1		 mov	 eax, ecx
  01b1b	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  01b20	3b 84 24 30 01
	00 00		 cmp	 eax, DWORD PTR old_cp_send_mask$[rsp]
  01b27	0f 84 cc 00 00
	00		 je	 $LN140@z900_servi
$LN141@z900_servi:

; 2223 :         )
; 2224 :         {
; 2225 :             if (0
; 2226 :                 || (servc_cp_recv_mask & SCCB_EVENT_CONS_RECV_MASK) != 0
; 2227 :                 || (servc_cp_send_mask & SCCB_EVENT_CONS_SEND_MASK) != 0

  01b2d	33 c0		 xor	 eax, eax
  01b2f	85 c0		 test	 eax, eax
  01b31	75 1e		 jne	 SHORT $LN144@z900_servi
  01b33	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01b39	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  01b3e	85 c0		 test	 eax, eax
  01b40	75 0f		 jne	 SHORT $LN144@z900_servi
  01b42	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_send_mask
  01b48	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  01b4d	85 c0		 test	 eax, eax
  01b4f	74 55		 je	 SHORT $LN142@z900_servi
$LN144@z900_servi:

; 2228 :             )
; 2229 :                 // "SCLP console interface %s"
; 2230 :                 WRMSG( HHC00006, "I", "active" );

  01b51	b9 01 00 00 00	 mov	 ecx, 1
  01b56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203103
  01b63	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203104
  01b6f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203105
  01b7b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b80	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b85	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b8b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG203106
  01b92	ba b6 08 00 00	 mov	 edx, 2230		; 000008b6H
  01b97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203107
  01b9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01ba4	eb 53		 jmp	 SHORT $LN143@z900_servi
$LN142@z900_servi:

; 2231 :             else
; 2232 :                 // "SCLP console interface %s"
; 2233 :                 WRMSG( HHC00006, "I", "inactive" );

  01ba6	b9 01 00 00 00	 mov	 ecx, 1
  01bab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01bb1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203108
  01bb8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01bbd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203109
  01bc4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203110
  01bd0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bd5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bda	41 b9 03 00 00
	00		 mov	 r9d, 3
  01be0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG203111
  01be7	ba b9 08 00 00	 mov	 edx, 2233		; 000008b9H
  01bec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG203112
  01bf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN143@z900_servi:
$LN140@z900_servi:

; 2234 :         }
; 2235 : 
; 2236 :         /* Set response code X'0020' in SCCB header */
; 2237 :         sccb->reas = SCCB_REAS_NONE;

  01bf9	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01bfe	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2238 :         sccb->resp = SCCB_RESP_COMPLETE;

  01c02	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c07	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2239 :         break;

  01c0b	e9 0a 03 00 00	 jmp	 $LN14@z900_servi
$LN145@z900_servi:

; 2240 : 
; 2241 : #endif /* defined( FEATURE_SYSTEM_CONSOLE ) */
; 2242 : 
; 2243 : #if defined( FEATURE_EXPANDED_STORAGE )
; 2244 : 
; 2245 :    case SCLP_READ_XST_MAP:
; 2246 : 
; 2247 :         /* Set the main storage change bit */
; 2248 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  01c10	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01c14	b2 02		 mov	 dl, 2
  01c16	8b c8		 mov	 ecx, eax
  01c18	e8 00 00 00 00	 call	 z900_or_storage_key

; 2249 : 
; 2250 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2251 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  01c1d	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01c21	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01c27	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  01c2c	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  01c30	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  01c34	8b c9		 mov	 ecx, ecx
  01c36	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  01c3d	48 3b c1	 cmp	 rax, rcx
  01c40	74 17		 je	 SHORT $LN146@z900_servi

; 2252 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2253 :         {
; 2254 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  01c42	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c47	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2255 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  01c4b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c50	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2256 :             break;

  01c54	e9 c1 02 00 00	 jmp	 $LN14@z900_servi
$LN146@z900_servi:

; 2257 :         }
; 2258 : 
; 2259 :         /* Calculate number of blocks per increment */
; 2260 :         xstblkinc = XSTORE_INCREMENT_SIZE / XSTORE_PAGESIZE;

  01c59	c7 84 24 b8 00
	00 00 00 01 00
	00		 mov	 DWORD PTR xstblkinc$[rsp], 256 ; 00000100H

; 2261 : 
; 2262 :         /* Set response code X'0300' if SCCB length
; 2263 :            is insufficient to contain xstore info */
; 2264 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_XST_MAP )

  01c64	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  01c69	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1151[rsp], rax
  01c71	33 d2		 xor	 edx, edx
  01c73	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR xstblkinc$[rsp]
  01c7a	b9 08 00 00 00	 mov	 ecx, 8
  01c7f	f7 f1		 div	 ecx
  01c81	8b c0		 mov	 eax, eax
  01c83	48 83 c0 10	 add	 rax, 16
  01c87	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv1151[rsp]
  01c8f	48 3b c8	 cmp	 rcx, rax
  01c92	73 17		 jae	 SHORT $LN147@z900_servi

; 2265 :                 + xstblkinc/8)
; 2266 :         {
; 2267 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  01c94	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c99	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2268 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  01c9d	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01ca2	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2269 :             break;

  01ca6	e9 6f 02 00 00	 jmp	 $LN14@z900_servi
$LN147@z900_servi:

; 2270 :         }
; 2271 : 
; 2272 :         /* Point to SCCB data area following SCCB header */
; 2273 :         sccbxmap = (SCCB_XST_MAP*)(sccb+1);

  01cab	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01cb0	48 83 c0 08	 add	 rax, 8
  01cb4	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR sccbxmap$[rsp], rax

; 2274 : 
; 2275 :         /* Verify expanded storage increment number */
; 2276 :         xstincnum = sysblk.xpndsize /

  01cbc	33 d2		 xor	 edx, edx
  01cbe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01cc5	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  01ccb	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  01cd0	f7 f1		 div	 ecx
  01cd2	89 84 24 d8 00
	00 00		 mov	 DWORD PTR xstincnum$[rsp], eax

; 2277 :                     (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);
; 2278 :         FETCH_FW( i, sccbxmap->incnum );

  01cd9	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR sccbxmap$[rsp]
  01ce1	48 8b c8	 mov	 rcx, rax
  01ce4	e8 00 00 00 00	 call	 fetch_fw_noswap
  01ce9	8b c8		 mov	 ecx, eax
  01ceb	e8 00 00 00 00	 call	 _byteswap_ulong
  01cf0	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2279 : 
; 2280 :         if (i < 1 || (U32)i > xstincnum)

  01cf4	83 7c 24 50 01	 cmp	 DWORD PTR i$[rsp], 1
  01cf9	7c 0d		 jl	 SHORT $LN149@z900_servi
  01cfb	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR xstincnum$[rsp]
  01d02	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01d06	76 17		 jbe	 SHORT $LN148@z900_servi
$LN149@z900_servi:

; 2281 :         {
; 2282 :             sccb->reas = SCCB_REAS_INVALID_RSC;

  01d08	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d0d	c6 40 06 09	 mov	 BYTE PTR [rax+6], 9

; 2283 :             sccb->resp = SCCB_RESP_REJECT;

  01d11	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d16	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2284 :             break;

  01d1a	e9 fb 01 00 00	 jmp	 $LN14@z900_servi
$LN148@z900_servi:

; 2285 :         }
; 2286 : 
; 2287 :         /* Point to bitmap */
; 2288 :         xstmap = (BYTE*)(sccbxmap+1);

  01d1f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR sccbxmap$[rsp]
  01d27	48 83 c0 08	 add	 rax, 8
  01d2b	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR xstmap$[rsp], rax

; 2289 : 
; 2290 :         /* Set all blocks available */
; 2291 :         memset( xstmap, 0, xstblkinc/8);

  01d33	33 d2		 xor	 edx, edx
  01d35	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR xstblkinc$[rsp]
  01d3c	b9 08 00 00 00	 mov	 ecx, 8
  01d41	f7 f1		 div	 ecx
  01d43	8b c0		 mov	 eax, eax
  01d45	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1174[rsp], rax
  01d4d	48 8b bc 24 b0
	01 00 00	 mov	 rdi, QWORD PTR xstmap$[rsp]
  01d55	33 c0		 xor	 eax, eax
  01d57	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv1174[rsp]
  01d5f	f3 aa		 rep stosb

; 2292 : 
; 2293 :         /* Set response code X'0010' in SCCB header */
; 2294 :         sccb->reas = SCCB_REAS_NONE;

  01d61	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d66	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2295 :         sccb->resp = SCCB_RESP_INFO;

  01d6a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d6f	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 2296 :         break;

  01d73	e9 a2 01 00 00	 jmp	 $LN14@z900_servi
$LN150@z900_servi:

; 2297 : 
; 2298 : #endif /* defined( FEATURE_EXPANDED_STORAGE ) */
; 2299 : 
; 2300 : #if defined( FEATURE_CPU_RECONFIG )
; 2301 : 
; 2302 :     case SCLP_CONFIGURE_CPU:
; 2303 : 
; 2304 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;

  01d78	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01d7f	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01d84	c1 e8 08	 shr	 eax, 8
  01d87	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2305 : 
; 2306 :         /* Return invalid resource in parm if target does not exist */
; 2307 :         if (i >= sysblk.maxcpu)

  01d8b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d92	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01d98	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01d9c	7c 17		 jl	 SHORT $LN151@z900_servi

; 2308 :         {
; 2309 :             sccb->reas = SCCB_REAS_INVALID_RSCP;

  01d9e	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01da3	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2310 :             sccb->resp = SCCB_RESP_REJECT;

  01da7	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01dac	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2311 :             break;

  01db0	e9 65 01 00 00	 jmp	 $LN14@z900_servi
$LN151@z900_servi:

; 2312 :         }
; 2313 : 
; 2314 :         /* Add cpu to the configuration */
; 2315 :         configure_cpu(i);

  01db5	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01db9	e8 00 00 00 00	 call	 configure_cpu

; 2316 : 
; 2317 :         /* Set response code X'0020' in SCCB header */
; 2318 :         sccb->reas = SCCB_REAS_NONE;

  01dbe	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01dc3	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2319 :         sccb->resp = SCCB_RESP_COMPLETE;

  01dc7	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01dcc	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2320 :         break;

  01dd0	e9 45 01 00 00	 jmp	 $LN14@z900_servi
$LN152@z900_servi:

; 2321 : 
; 2322 :     case SCLP_DECONFIGURE_CPU:
; 2323 : 
; 2324 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;

  01dd5	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01ddc	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01de1	c1 e8 08	 shr	 eax, 8
  01de4	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2325 : 
; 2326 :         /* Return invalid resource in parm if target does not exist */
; 2327 :         if (i >= sysblk.maxcpu)

  01de8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01def	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01df5	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01df9	7c 17		 jl	 SHORT $LN153@z900_servi

; 2328 :         {
; 2329 :             sccb->reas = SCCB_REAS_INVALID_RSCP;

  01dfb	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e00	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2330 :             sccb->resp = SCCB_RESP_REJECT;

  01e04	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e09	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2331 :             break;

  01e0d	e9 08 01 00 00	 jmp	 $LN14@z900_servi
$LN153@z900_servi:

; 2332 :         }
; 2333 : 
; 2334 :         /* Take cpu out of the configuration */
; 2335 :         deconfigure_cpu(i);

  01e12	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01e16	e8 00 00 00 00	 call	 deconfigure_cpu

; 2336 : 
; 2337 :         /* Set response code X'0020' in SCCB header */
; 2338 :         sccb->reas = SCCB_REAS_NONE;

  01e1b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e20	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2339 :         sccb->resp = SCCB_RESP_COMPLETE;

  01e24	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e29	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2340 :         break;

  01e2d	e9 e8 00 00 00	 jmp	 $LN14@z900_servi
$LN154@z900_servi:
$invalidcmd$181:
$LN54@z900_servi:

; 2341 : 
; 2342 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 2343 : 
; 2344 :     case SCLP_DISCONNECT_VF:
; 2345 : 
; 2346 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;
; 2347 : 
; 2348 :         /* Return invalid resource in parm if target does not exist */
; 2349 :         if (i >= sysblk.maxcpu || !IS_CPU_ONLINE(i))
; 2350 :         {
; 2351 :             sccb->reas = SCCB_REAS_INVALID_RSCP;
; 2352 :             sccb->resp = SCCB_RESP_REJECT;
; 2353 :             break;
; 2354 :         }
; 2355 : 
; 2356 :         if (sysblk.regs[i]->vf->online)
; 2357 :             // "Processor %s%02X: vector facility configured %s"
; 2358 :             WRMSG( HHC00821, "I", PTYPSTR(i), i, "offline" );
; 2359 : 
; 2360 :         /* Take the VF out of the configuration */
; 2361 :         sysblk.regs[i]->vf->online = 0;
; 2362 : 
; 2363 :         /* Set response code X'0020' in SCCB header */
; 2364 :         sccb->reas = SCCB_REAS_NONE;
; 2365 :         sccb->resp = SCCB_RESP_COMPLETE;
; 2366 :         break;
; 2367 : 
; 2368 :     case SCLP_CONNECT_VF:
; 2369 : 
; 2370 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;
; 2371 : 
; 2372 :         /* Return invalid resource in parm if target does not exist */
; 2373 :         if (i >= sysblk.maxcpu)
; 2374 :         {
; 2375 :             sccb->reas = SCCB_REAS_INVALID_RSCP;
; 2376 :             sccb->resp = SCCB_RESP_REJECT;
; 2377 :             break;
; 2378 :         }
; 2379 : 
; 2380 :         /* Return improper state if associated cpu is offline */
; 2381 :         if (!IS_CPU_ONLINE(i))
; 2382 :         {
; 2383 :             sccb->reas = SCCB_REAS_IMPROPER_RSC;
; 2384 :             sccb->resp = SCCB_RESP_REJECT;
; 2385 :             break;
; 2386 :         }
; 2387 : 
; 2388 :         if (!sysblk.regs[i]->vf->online)
; 2389 :             // "Processor %s%02X: vector facility configured %s"
; 2390 :             WRMSG( HHC00821, "I", PTYPSTR(i), i, "online" );
; 2391 : 
; 2392 :         /* Mark the VF online to the CPU */
; 2393 :         sysblk.regs[i]->vf->online = 1;
; 2394 : 
; 2395 :         /* Set response code X'0020' in SCCB header */
; 2396 :         sccb->reas = SCCB_REAS_NONE;
; 2397 :         sccb->resp = SCCB_RESP_COMPLETE;
; 2398 :         break;
; 2399 : 
; 2400 : #endif /* defined( FEATURE_S370_S390_VECTOR_FACILITY ) */
; 2401 : 
; 2402 : #endif /* defined( FEATURE_CPU_RECONFIG ) */
; 2403 : 
; 2404 :     default:
; 2405 :     invalidcmd:
; 2406 : 
; 2407 :         PTT( PTT_CL_INF | PTT_CL_ERR, "*SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  01e32	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01e39	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e3c	48 83 e0 18	 and	 rax, 24
  01e40	48 85 c0	 test	 rax, rax
  01e43	74 6c		 je	 SHORT $LN155@z900_servi
  01e45	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e4d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  01e53	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  01e5a	48 8b 94 24 f8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01e62	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  01e69	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  01e70	48 8b bc 24 f8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01e78	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  01e7f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01e88	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01e8d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG203124
  01e94	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e99	44 8b c9	 mov	 r9d, ecx
  01e9c	44 8b c2	 mov	 r8d, edx
  01e9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203125
  01ea6	b9 18 00 00 00	 mov	 ecx, 24
  01eab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN155@z900_servi:
  01eb1	33 c0		 xor	 eax, eax
  01eb3	85 c0		 test	 eax, eax
  01eb5	0f 85 77 ff ff
	ff		 jne	 $LN54@z900_servi

; 2408 : 
; 2409 :         if (HDC3( debug_sclp_unknown_command, sclp_command, sccb, regs ))

  01ebb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_command
  01ec2	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01ec6	74 27		 je	 SHORT $LN175@z900_servi
  01ec8	4c 8b 84 24 f8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01ed0	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  01ed5	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sclp_command$[rsp]
  01edc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_command
  01ee3	ff 10		 call	 QWORD PTR [rax]
  01ee5	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv1226[rsp], rax
  01eed	eb 0c		 jmp	 SHORT $LN176@z900_servi
$LN175@z900_servi:
  01eef	48 c7 84 24 80
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv1226[rsp], 0
$LN176@z900_servi:
  01efb	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR tv1226[rsp], 0
  01f04	74 02		 je	 SHORT $LN156@z900_servi

; 2410 :             break;

  01f06	eb 12		 jmp	 SHORT $LN14@z900_servi
$LN156@z900_servi:

; 2411 : 
; 2412 :         /* Set response code X'01F0' for invalid SCLP command */
; 2413 :         sccb->reas = SCCB_REAS_INVALID_CMD;

  01f08	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01f0d	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2414 :         sccb->resp = SCCB_RESP_REJECT;

  01f11	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01f16	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN14@z900_servi:

; 2415 :         break;
; 2416 : 
; 2417 :     } /* end switch (sclp_command) */
; 2418 : 
; 2419 :     /* If immediate response is requested, return condition code 1 */
; 2420 :     if ((sccb->flag & SCCB_FLAG_SYNC)
; 2421 :         && (sclp_command & SCLP_COMMAND_CLASS) != 0x01)

  01f1a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01f1f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01f23	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01f28	85 c0		 test	 eax, eax
  01f2a	74 22		 je	 SHORT $LN157@z900_servi
  01f2c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01f33	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01f38	83 f8 01	 cmp	 eax, 1
  01f3b	74 11		 je	 SHORT $LN157@z900_servi

; 2422 :     {
; 2423 :         regs->psw.cc = 1;

  01f3d	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f45	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2424 :         return;

  01f49	e9 bf 01 00 00	 jmp	 $LN1@z900_servi
$LN157@z900_servi:

; 2425 :     }
; 2426 : 
; 2427 :     /* Set service signal external interrupt pending */
; 2428 :     sysblk.servparm &= ~SERVSIG_ADDR;

  01f4e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f55	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01f5b	83 e0 07	 and	 eax, 7
  01f5e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01f65	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax

; 2429 :     sysblk.servparm |= sccb_absolute_addr;

  01f6b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f72	8b 4c 24 64	 mov	 ecx, DWORD PTR sccb_absolute_addr$[rsp]
  01f76	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01f7c	0b c1		 or	 eax, ecx
  01f7e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01f85	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax
$LN57@z900_servi:

; 2430 :     ON_IC_SERVSIG;

  01f8b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f92	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01f98	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01f9d	85 c0		 test	 eax, eax
  01f9f	0f 85 23 01 00
	00		 jne	 $LN158@z900_servi
  01fa5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01fac	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01fb2	0f ba e8 09	 bts	 eax, 9
  01fb6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01fbd	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  01fc3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01fca	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  01fd1	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR mask$5[rsp], rax
  01fd9	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  01fe4	eb 10		 jmp	 SHORT $LN60@z900_servi
$LN58@z900_servi:
  01fe6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  01fed	ff c0		 inc	 eax
  01fef	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN60@z900_servi:
  01ff6	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR mask$5[rsp], 0
  01fff	0f 84 c3 00 00
	00		 je	 $LN59@z900_servi
  02005	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR mask$5[rsp]
  0200d	48 83 e0 01	 and	 rax, 1
  02011	48 85 c0	 test	 rax, rax
  02014	0f 84 96 00 00
	00		 je	 $LN159@z900_servi
  0201a	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  02022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02029	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  02031	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02034	25 00 02 00 00	 and	 eax, 512		; 00000200H
  02039	85 c0		 test	 eax, eax
  0203b	74 3b		 je	 SHORT $LN160@z900_servi
  0203d	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  02045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0204c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  02054	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02057	0d 00 02 00 80	 or	 eax, -2147483136	; 80000200H
  0205c	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  02064	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0206b	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  02073	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  02076	eb 38		 jmp	 SHORT $LN161@z900_servi
$LN160@z900_servi:
  02078	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  02080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02087	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0208f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02092	0f ba e8 09	 bts	 eax, 9
  02096	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0209e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  020a5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  020ad	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN161@z900_servi:
$LN159@z900_servi:
  020b0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR mask$5[rsp]
  020b8	48 d1 e8	 shr	 rax, 1
  020bb	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR mask$5[rsp], rax
  020c3	e9 1e ff ff ff	 jmp	 $LN58@z900_servi
$LN59@z900_servi:
$LN158@z900_servi:
  020c8	33 c0		 xor	 eax, eax
  020ca	85 c0		 test	 eax, eax
  020cc	0f 85 b9 fe ff
	ff		 jne	 $LN57@z900_servi

; 2431 : 
; 2432 :     /* Release the interrupt lock */
; 2433 :     RELEASE_INTLOCK( regs );

  020d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG203132
  020d9	48 8b 8c 24 f8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020e1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2434 : 
; 2435 :     /* Set condition code 0 */
; 2436 :     regs->psw.cc = 0;

  020e6	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020ee	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2437 : 
; 2438 :     RETURN_INTCHECK( regs );

  020f2	48 8b 84 24 f8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020fa	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  02100	ba ff ff ff ff	 mov	 edx, -1
  02105	48 8b c8	 mov	 rcx, rax
  02108	e8 00 00 00 00	 call	 longjmp
$LN1@z900_servi:
$LN162@z900_servi:

; 2439 : } /* end function service_call */

  0210d	48 8b 8c 24 c0
	11 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02115	48 33 cc	 xor	 rcx, rsp
  02118	e8 00 00 00 00	 call	 __security_check_cookie
  0211d	48 81 c4 d8 11
	00 00		 add	 rsp, 4568		; 000011d8H
  02124	5f		 pop	 rdi
  02125	5e		 pop	 rsi
  02126	c3		 ret	 0
  02127	90		 npad	 1
$LN179@z900_servi:
  02128	00 00 00 00	 DD	 $LN103@z900_servi
  0212c	00 00 00 00	 DD	 $LN115@z900_servi
  02130	00 00 00 00	 DD	 $LN104@z900_servi
  02134	00 00 00 00	 DD	 $LN114@z900_servi
  02138	00 00 00 00	 DD	 $LN116@z900_servi
  0213c	00 00 00 00	 DD	 $LN118@z900_servi
  02140	00 00 00 00	 DD	 $LN117@z900_servi
  02144	00 00 00 00	 DD	 $LN119@z900_servi
$LN178@z900_servi:
  02148	00		 DB	 0
  02149	07		 DB	 7
  0214a	07		 DB	 7
  0214b	07		 DB	 7
  0214c	07		 DB	 7
  0214d	01		 DB	 1
  0214e	07		 DB	 7
  0214f	02		 DB	 2
  02150	07		 DB	 7
  02151	03		 DB	 3
  02152	04		 DB	 4
  02153	07		 DB	 7
  02154	07		 DB	 7
  02155	07		 DB	 7
  02156	07		 DB	 7
  02157	07		 DB	 7
  02158	07		 DB	 7
  02159	07		 DB	 7
  0215a	07		 DB	 7
  0215b	07		 DB	 7
  0215c	07		 DB	 7
  0215d	07		 DB	 7
  0215e	07		 DB	 7
  0215f	07		 DB	 7
  02160	07		 DB	 7
  02161	05		 DB	 5
  02162	06		 DB	 6
z900_service_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
i$ = 80
sccb$ = 88
sccblen$ = 96
sccb_absolute_addr$ = 100
offset$ = 104
sccbscp$ = 112
tv243 = 120
masklen$ = 124
obj_len$ = 128
event_msglen$ = 132
mcd_len$ = 136
evd_len$ = 140
i$1 = 144
sccb_real_addr$ = 148
chpbyte$ = 152
sclp_command$ = 156
evd_hdr$ = 160
r2$ = 168
r1$ = 172
tv650 = 176
xstblkinc$ = 180
evd_mask$ = 184
sccbcpu$ = 192
obj_type$ = 200
chpbit$ = 204
xstincnum$ = 208
sccbchp$ = 216
dev$ = 224
tv774 = 232
tv177 = 236
i$2 = 240
incsizemb$ = 244
realinc$ = 248
trunc_len$3 = 252
obj_hdr$ = 256
sccb_last_byte$4 = 264
evd_msg$ = 272
mask$5 = 280
tv1631 = 288
old_cp_send_mask$ = 292
old_cp_recv_mask$ = 296
sccb_first_byte$6 = 304
sccbcsi$ = 312
mcd_bk$ = 320
mto_bk$ = 328
$T7 = 336
tv841 = 344
tv964 = 352
sccbxmap$ = 360
tv1201 = 368
tv313 = 376
sccbmpf$ = 384
tv1028 = 392
tv1032 = 400
tv1126 = 408
xstmap$ = 416
tv1149 = 424
message$ = 432
__$ArrayPad$ = 4528
inst$ = 4576
regs$ = 4584
s390_service_call PROC

; 1408 : {

$LN176:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 c8 11 00 00	 mov	 eax, 4552		; 000011c8H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 b0
	11 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1409 : U32             r1, r2;                 /* Values of R fields        */
; 1410 : U32             sclp_command;           /* SCLP command code         */
; 1411 : U32             sccb_real_addr;         /* SCCB real address         */
; 1412 : int             i;                      /* Array subscripts          */
; 1413 : U32             realinc;                /* Storage size in increments*/
; 1414 : U32             incsizemb;              /* Increment size in MB      */
; 1415 : U32             sccb_absolute_addr;     /* Absolute address of SCCB  */
; 1416 : U16             sccblen;                /* Length of SCCB            */
; 1417 : SCCB_HEADER*    sccb;                   /* -> SCCB header            */
; 1418 : SCCB_SCP_INFO*  sccbscp;                /* -> SCCB SCP information   */
; 1419 : SCCB_CPU_INFO*  sccbcpu;                /* -> SCCB CPU information   */
; 1420 : 
; 1421 : #if defined( FEATURE_MPF_INFO )
; 1422 : SCCB_MPF_INFO*  sccbmpf;                /* -> SCCB MPF information   */
; 1423 : #endif
; 1424 : 
; 1425 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1426 : SCCB_CHP_INFO*  sccbchp;                /* -> SCCB channel path info */
; 1427 : #else
; 1428 : SCCB_CHSET_INFO* sccbchp;               /* -> SCCB channel path info */
; 1429 : #endif
; 1430 : 
; 1431 : SCCB_CSI_INFO*  sccbcsi;                /* -> SCCB channel subsys inf*/
; 1432 : U16             offset;                 /* Offset from start of SCCB */
; 1433 : 
; 1434 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1435 : DEVBLK*         dev;                    /* Used to find CHPIDs       */
; 1436 : U32             chpbyte;                /* Offset to byte for CHPID  */
; 1437 : U32             chpbit;                 /* Bit number for CHPID      */
; 1438 : #endif
; 1439 : 
; 1440 : #if defined( FEATURE_SYSTEM_CONSOLE )
; 1441 : SCCB_EVT_MASK*  evd_mask;               /* Event mask                */
; 1442 : SCCB_EVD_HDR*   evd_hdr;                /* Event header              */
; 1443 : U16             evd_len;                /* Length of event data      */
; 1444 : SCCB_MCD_BK*    mcd_bk;                 /* Message Control Data      */
; 1445 : U16             mcd_len;                /* Length of MCD             */
; 1446 : SCCB_OBJ_HDR*   obj_hdr;                /* Object Header             */
; 1447 : U16             obj_len;                /* Length of Object          */
; 1448 : U16             obj_type;               /* Object type               */
; 1449 : SCCB_MTO_BK*    mto_bk;                 /* Message Text Object       */
; 1450 : BYTE*           evd_msg;                /* Message Text pointer      */
; 1451 : int             event_msglen;           /* Message Text length       */
; 1452 : BYTE            message[MAX_EVENT_MSG_LEN];/* Maximum event data buffer
; 1453 :                                            length plus one for \0    */
; 1454 : U32             masklen;                /* Length of event mask      */
; 1455 : U32             old_cp_recv_mask;       /* Masks before write event  */
; 1456 : U32             old_cp_send_mask;       /*              mask command */
; 1457 : #endif /* defined( FEATURE_SYSTEM_CONSOLE ) */
; 1458 : 
; 1459 : #if defined( FEATURE_EXPANDED_STORAGE )
; 1460 : SCCB_XST_MAP*   sccbxmap;               /* Xstore usability map      */
; 1461 : U32             xstincnum;              /* Number of expanded storage
; 1462 :                                                          increments  */
; 1463 : U32             xstblkinc;              /* Number of expanded storage
; 1464 :                                                blocks per increment  */
; 1465 : BYTE*           xstmap;                 /* Xstore bitmap, zero means
; 1466 :                                                            available */
; 1467 : #endif /* defined( FEATURE_EXPANDED_STORAGE ) */
; 1468 : 
; 1469 :     RRE( inst, regs, r1, r2 );

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 e0
	11 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 84 24 f0 00
	00 00		 mov	 DWORD PTR i$2[rsp], eax
  00047	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 84 24 a8 00
	00 00		 mov	 DWORD PTR r2$[rsp], eax
  00058	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  0005f	c1 f8 04	 sar	 eax, 4
  00062	83 e0 0f	 and	 eax, 15
  00065	89 84 24 ac 00
	00 00		 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_servi:
  0006c	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00088	33 c0		 xor	 eax, eax
  0008a	83 f8 04	 cmp	 eax, 4
  0008d	74 0f		 je	 SHORT $LN58@s390_servi
  0008f	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN58@s390_servi:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 c8		 jne	 SHORT $LN4@s390_servi

; 1470 : 
; 1471 :     PER_ZEROADDR_CHECK( regs, r2 );
; 1472 :     TXF_INSTR_CHECK( regs );
; 1473 :     PRIV_CHECK( regs );

  000a4	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b0	83 e0 01	 and	 eax, 1
  000b3	85 c0		 test	 eax, eax
  000b5	74 1b		 je	 SHORT $LN59@s390_servi
  000b7	ba 02 00 00 00	 mov	 edx, 2
  000bc	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN59@s390_servi:
$LN7@s390_servi:

; 1474 : 
; 1475 :     SIE_INTERCEPT( regs );

  000d2	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e0	d1 e8		 shr	 eax, 1
  000e2	83 e0 01	 and	 eax, 1
  000e5	85 c0		 test	 eax, eax
  000e7	74 1b		 je	 SHORT $LN60@s390_servi
  000e9	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000f7	ba fc ff ff ff	 mov	 edx, -4
  000fc	48 8b c8	 mov	 rcx, rax
  000ff	e8 00 00 00 00	 call	 longjmp
$LN60@s390_servi:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 c8		 jne	 SHORT $LN7@s390_servi
$LN10@s390_servi:

; 1476 : 
; 1477 :     PTT_INF("SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  0010a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00111	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00114	48 83 e0 08	 and	 rax, 8
  00118	48 85 c0	 test	 rax, rax
  0011b	74 6d		 je	 SHORT $LN61@s390_servi
  0011d	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00125	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0012b	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00132	48 8b 94 24 e8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013a	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00141	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  00148	4c 8b 84 24 e8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00150	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00158	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00161	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00166	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189722
  0016d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00172	44 8b c9	 mov	 r9d, ecx
  00175	44 8b c2	 mov	 r8d, edx
  00178	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189723
  0017f	b9 08 00 00 00	 mov	 ecx, 8
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN61@s390_servi:
  0018a	33 c0		 xor	 eax, eax
  0018c	85 c0		 test	 eax, eax
  0018e	0f 85 76 ff ff
	ff		 jne	 $LN10@s390_servi

; 1478 : 
; 1479 :     /* R1 is SCLP command word */
; 1480 :     sclp_command = regs->GR_L(r1);

  00194	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0019b	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001aa	89 84 24 9c 00
	00 00		 mov	 DWORD PTR sclp_command$[rsp], eax

; 1481 : 
; 1482 :     /* R2 is real address of service call control block */
; 1483 :     sccb_real_addr = regs->GR_L(r2);

  001b1	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001b8	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001c7	89 84 24 94 00
	00 00		 mov	 DWORD PTR sccb_real_addr$[rsp], eax

; 1484 : 
; 1485 :     /* Program check if SCCB is not on a doubleword boundary */
; 1486 :     if (sccb_real_addr & 0x00000007)

  001ce	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  001d5	83 e0 07	 and	 eax, 7
  001d8	85 c0		 test	 eax, eax
  001da	74 12		 je	 SHORT $LN62@s390_servi

; 1487 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	e8 00 00 00 00	 call	 s390_program_interrupt
$LN62@s390_servi:

; 1488 : 
; 1489 :     /* Program check if SCCB falls outside of main storage */
; 1490 :     if (sccb_real_addr > (regs->mainlim - sizeof( SCCB_HEADER )))

  001ee	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  001f5	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fd	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00204	48 83 e9 08	 sub	 rcx, 8
  00208	48 3b c1	 cmp	 rax, rcx
  0020b	76 12		 jbe	 SHORT $LN63@s390_servi

; 1491 :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  0020d	ba 05 00 00 00	 mov	 edx, 5
  00212	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021a	e8 00 00 00 00	 call	 s390_program_interrupt
$LN63@s390_servi:

; 1492 : 
; 1493 :     /* Obtain the absolute address of the SCCB */
; 1494 :     sccb_absolute_addr = APPLY_PREFIXING( sccb_real_addr, regs->PX );

  0021f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00226	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0022c	48 85 c0	 test	 rax, rax
  0022f	74 2d		 je	 SHORT $LN159@s390_servi
  00231	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00238	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0023e	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00249	48 3b c1	 cmp	 rax, rcx
  0024c	74 10		 je	 SHORT $LN159@s390_servi
  0024e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR sccb_real_addr$[rsp]
  00255	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv177[rsp], eax
  0025c	eb 1d		 jmp	 SHORT $LN160@s390_servi
$LN159@s390_servi:
  0025e	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00266	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00269	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR sccb_real_addr$[rsp]
  00270	33 c8		 xor	 ecx, eax
  00272	8b c1		 mov	 eax, ecx
  00274	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv177[rsp], eax
$LN160@s390_servi:
  0027b	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv177[rsp]
  00282	89 44 24 64	 mov	 DWORD PTR sccb_absolute_addr$[rsp], eax

; 1495 : 
; 1496 :     /* Specification Exception if SCCB not below 2GB */
; 1497 :     if (sccb_absolute_addr >= (0x80000000 - sizeof( SCCB_HEADER )))

  00286	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  0028a	48 3d f8 ff ff
	7f		 cmp	 rax, 2147483640		; 7ffffff8H
  00290	72 12		 jb	 SHORT $LN64@s390_servi

; 1498 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00292	ba 06 00 00 00	 mov	 edx, 6
  00297	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN64@s390_servi:

; 1499 : 
; 1500 :     /* Point to service call control block */
; 1501 :     sccb = (SCCB_HEADER*)(regs->mainstor + sccb_absolute_addr);

  002a4	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  002a8	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b0	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  002b7	48 89 44 24 58	 mov	 QWORD PTR sccb$[rsp], rax

; 1502 : 
; 1503 :     /* Load SCCB length from header */
; 1504 :     FETCH_HW( sccblen, sccb->length  );

  002bc	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  002c1	48 8b c8	 mov	 rcx, rax
  002c4	e8 00 00 00 00	 call	 fetch_hw_noswap
  002c9	0f b7 c8	 movzx	 ecx, ax
  002cc	e8 00 00 00 00	 call	 _byteswap_ushort
  002d1	66 89 44 24 60	 mov	 WORD PTR sccblen$[rsp], ax

; 1505 : 
; 1506 :     /* Set the main storage reference bit */
; 1507 :     ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_REF );

  002d6	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  002da	b2 04		 mov	 dl, 4
  002dc	8b c8		 mov	 ecx, eax
  002de	e8 00 00 00 00	 call	 s390_or_storage_key

; 1508 : 
; 1509 :     /* Specification Exception if SCCB size less than 8 */
; 1510 :     if (sccblen < sizeof( SCCB_HEADER ))

  002e3	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  002e8	48 83 f8 08	 cmp	 rax, 8
  002ec	73 12		 jae	 SHORT $LN65@s390_servi

; 1511 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  002ee	ba 06 00 00 00	 mov	 edx, 6
  002f3	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	e8 00 00 00 00	 call	 s390_program_interrupt
$LN65@s390_servi:

; 1512 : 
; 1513 :     /* Program check if SCCB falls outside of main storage,
; 1514 :        isn't below 2GB or overlaps low core or prefix area. */
; 1515 :     {
; 1516 :         U64 sccb_first_byte = (U64) sccb_absolute_addr;

  00300	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00304	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR sccb_first_byte$6[rsp], rax

; 1517 :         U64 sccb_last_byte  = (U64) sccb_absolute_addr + sccblen - 1;

  0030c	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00310	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00315	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  0031a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR sccb_last_byte$4[rsp], rax

; 1518 : 
; 1519 :         if (0
; 1520 :             || sccb_first_byte < PSA_SIZE
; 1521 :             || sccb_last_byte > 0x80000000
; 1522 :             || (sccb_first_byte >= regs->PX && sccb_first_byte < (regs->PX + PSA_SIZE))
; 1523 :             || (sccb_last_byte  >= regs->PX && sccb_last_byte  < (regs->PX + PSA_SIZE))

  00322	33 c0		 xor	 eax, eax
  00324	85 c0		 test	 eax, eax
  00326	75 7f		 jne	 SHORT $LN67@s390_servi
  00328	48 81 bc 24 30
	01 00 00 00 10
	00 00		 cmp	 QWORD PTR sccb_first_byte$6[rsp], 4096 ; 00001000H
  00334	72 71		 jb	 SHORT $LN67@s390_servi
  00336	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0033b	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  00343	77 62		 ja	 SHORT $LN67@s390_servi
  00345	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00350	48 39 84 24 30
	01 00 00	 cmp	 QWORD PTR sccb_first_byte$6[rsp], rax
  00358	72 1c		 jb	 SHORT $LN68@s390_servi
  0035a	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00362	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00365	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0036a	8b c0		 mov	 eax, eax
  0036c	48 39 84 24 30
	01 00 00	 cmp	 QWORD PTR sccb_first_byte$6[rsp], rax
  00374	72 31		 jb	 SHORT $LN67@s390_servi
$LN68@s390_servi:
  00376	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00381	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  00389	72 2e		 jb	 SHORT $LN66@s390_servi
  0038b	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00393	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00396	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0039b	8b c0		 mov	 eax, eax
  0039d	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  003a5	73 12		 jae	 SHORT $LN66@s390_servi
$LN67@s390_servi:

; 1524 :         )
; 1525 :             ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  003a7	ba 06 00 00 00	 mov	 edx, 6
  003ac	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	e8 00 00 00 00	 call	 s390_program_interrupt
$LN66@s390_servi:

; 1526 : 
; 1527 :         if (sccb_last_byte > regs->mainlim)

  003b9	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c1	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  003c8	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR sccb_last_byte$4[rsp], rax
  003d0	76 12		 jbe	 SHORT $LN69@s390_servi

; 1528 :             ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  003d2	ba 05 00 00 00	 mov	 edx, 5
  003d7	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	e8 00 00 00 00	 call	 s390_program_interrupt
$LN69@s390_servi:

; 1529 :     }
; 1530 : 
; 1531 :     /* Obtain lock if immediate response is not requested */
; 1532 :     if (!(sccb->flag & SCCB_FLAG_SYNC)
; 1533 :         || (sclp_command & SCLP_COMMAND_CLASS) == 0x01)

  003e4	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  003e9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003ed	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003f2	85 c0		 test	 eax, eax
  003f4	74 11		 je	 SHORT $LN71@s390_servi
  003f6	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  003fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00402	83 f8 01	 cmp	 eax, 1
  00405	75 63		 jne	 SHORT $LN70@s390_servi
$LN71@s390_servi:

; 1534 :     {
; 1535 :         /* Obtain the interrupt lock */
; 1536 :         OBTAIN_INTLOCK( regs );

  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189734
  0040e	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00416	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1537 : 
; 1538 :         /* If a service signal is pending then return condition
; 1539 :            code 2 to indicate that service processor is busy */
; 1540 :         if (IS_IC_SERVSIG && (sysblk.servparm & SERVSIG_ADDR))

  0041b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00422	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00428	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0042d	85 c0		 test	 eax, eax
  0042f	74 39		 je	 SHORT $LN72@s390_servi
  00431	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00438	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  0043e	83 e0 f8	 and	 eax, -8			; fffffff8H
  00441	85 c0		 test	 eax, eax
  00443	74 25		 je	 SHORT $LN72@s390_servi

; 1541 :         {
; 1542 :             RELEASE_INTLOCK( regs );

  00445	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189736
  0044c	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00454	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1543 :             regs->psw.cc = 2;

  00459	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00461	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 1544 :             return;

  00465	e9 11 1c 00 00	 jmp	 $LN1@s390_servi
$LN72@s390_servi:
$LN70@s390_servi:

; 1545 :         }
; 1546 :     }
; 1547 : 
; 1548 :     /* Test SCLP command word */
; 1549 :     switch (sclp_command & SCLP_COMMAND_MASK)

  0046a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  00471	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  00476	89 44 24 78	 mov	 DWORD PTR tv243[rsp], eax
  0047a	81 7c 24 78 01
	00 1c 00	 cmp	 DWORD PTR tv243[rsp], 1835009 ; 001c0001H
  00482	77 55		 ja	 SHORT $LN173@s390_servi
  00484	81 7c 24 78 01
	00 1c 00	 cmp	 DWORD PTR tv243[rsp], 1835009 ; 001c0001H
  0048c	0f 84 8d 09 00
	00		 je	 $LN94@s390_servi
  00492	81 7c 24 78 01
	00 02 00	 cmp	 DWORD PTR tv243[rsp], 131073 ; 00020001H
  0049a	0f 84 a2 00 00
	00		 je	 $LN76@s390_servi
  004a0	81 7c 24 78 01
	00 03 00	 cmp	 DWORD PTR tv243[rsp], 196609 ; 00030001H
  004a8	0f 84 2c 07 00
	00		 je	 $LN88@s390_servi
  004ae	81 7c 24 78 01
	00 10 00	 cmp	 DWORD PTR tv243[rsp], 1048577 ; 00100001H
  004b6	0f 84 87 18 00
	00		 je	 $LN148@s390_servi
  004bc	81 7c 24 78 01
	00 11 00	 cmp	 DWORD PTR tv243[rsp], 1114113 ; 00110001H
  004c4	0f 84 1c 18 00
	00		 je	 $LN146@s390_servi
  004ca	81 7c 24 78 01
	00 12 00	 cmp	 DWORD PTR tv243[rsp], 1179649 ; 00120001H
  004d2	74 42		 je	 SHORT $LN73@s390_servi
  004d4	e9 c7 18 00 00	 jmp	 $LN150@s390_servi
$LN173@s390_servi:
  004d9	81 7c 24 78 01
	00 25 00	 cmp	 DWORD PTR tv243[rsp], 2424833 ; 00250001H
  004e1	0f 84 9c 16 00
	00		 je	 $LN141@s390_servi
  004e7	81 7c 24 78 05
	00 76 00	 cmp	 DWORD PTR tv243[rsp], 7733253 ; 00760005H
  004ef	0f 84 de 09 00
	00		 je	 $LN97@s390_servi
  004f5	81 7c 24 78 05
	00 77 00	 cmp	 DWORD PTR tv243[rsp], 7798789 ; 00770005H
  004fd	0f 84 ec 0f 00
	00		 je	 $LN118@s390_servi
  00503	81 7c 24 78 05
	00 78 00	 cmp	 DWORD PTR tv243[rsp], 7864325 ; 00780005H
  0050b	0f 84 77 12 00
	00		 je	 $LN131@s390_servi
  00511	e9 8a 18 00 00	 jmp	 $LN150@s390_servi
$LN73@s390_servi:

; 1550 :     {
; 1551 :     case SCLP_READ_IFL_INFO:
; 1552 : 
; 1553 :         /* READ_IFL_INFO is only valid for processor type IFL */
; 1554 :         if (sysblk.ptyp[ regs->cpuad ] != SCCB_PTYP_IFL)

  00516	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00525	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052c	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00534	83 f8 03	 cmp	 eax, 3
  00537	74 07		 je	 SHORT $LN74@s390_servi

; 1555 :             goto invalidcmd;

  00539	e9 62 18 00 00	 jmp	 $invalidcmd$177
  0053e	eb 02		 jmp	 SHORT $LN75@s390_servi
$LN74@s390_servi:

; 1556 :         else
; 1557 :             goto read_scpinfo;

  00540	eb 6e		 jmp	 SHORT $read_scpinfo$178
$LN75@s390_servi:
$LN76@s390_servi:

; 1558 : 
; 1559 :     case SCLP_READ_SCP_INFO:
; 1560 : 
; 1561 :         /* READ_SCP_INFO is only valid for processor type CP */
; 1562 :         if (sysblk.ptyp[ regs->cpuad ] != SCCB_PTYP_CP)

  00542	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00551	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00558	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  00560	85 c0		 test	 eax, eax
  00562	74 4c		 je	 SHORT $LN77@s390_servi

; 1563 :         {
; 1564 :             // "The configuration has been placed into a system check-
; 1565 :             //  stop state because of an incompatible service call"
; 1566 :             WRMSG( HHC00005, "W" );

  00564	b9 01 00 00 00	 mov	 ecx, 1
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0056f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189742
  00576	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0057b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189743
  00582	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00587	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0058c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00592	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189744
  00599	ba 1e 06 00 00	 mov	 edx, 1566		; 0000061eH
  0059e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189745
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1567 :             goto docheckstop;

  005ab	e9 ee 05 00 00	 jmp	 $docheckstop$179
$LN77@s390_servi:
$read_scpinfo$178:

; 1568 :             /*
; 1569 :              * Replace the following 2 lines with
; 1570 :              * goto invalidcmd
; 1571 :              * if this behavior is not satisfactory
; 1572 :              * ISW 20081221
; 1573 :              */
; 1574 :         }
; 1575 : 
; 1576 :     read_scpinfo:
; 1577 : 
; 1578 :         /* Set the main storage change bit */
; 1579 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  005b0	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  005b4	b2 02		 mov	 dl, 2
  005b6	8b c8		 mov	 ecx, eax
  005b8	e8 00 00 00 00	 call	 s390_or_storage_key

; 1580 : 
; 1581 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1582 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  005bd	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  005c1	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  005c6	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  005cb	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  005cf	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  005d3	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  005d9	3b c1		 cmp	 eax, ecx
  005db	74 17		 je	 SHORT $LN78@s390_servi

; 1583 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1584 :         {
; 1585 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  005dd	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  005e2	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1586 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  005e6	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  005eb	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1587 :             break;

  005ef	e9 94 18 00 00	 jmp	 $LN11@s390_servi
$LN78@s390_servi:

; 1588 :         }
; 1589 : 
; 1590 :         /* Set response code X'0300' if SCCB length
; 1591 :            is insufficient to contain SCP info */
; 1592 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_SCP_INFO )

  005f4	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  005f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00600	48 63 89 00 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+256]
  00607	48 6b c9 10	 imul	 rcx, rcx, 16
  0060b	48 81 c1 80 00
	00 00		 add	 rcx, 128		; 00000080H
  00612	48 3b c1	 cmp	 rax, rcx
  00615	73 17		 jae	 SHORT $LN79@s390_servi

; 1593 :                 + (sizeof( SCCB_CPU_INFO ) * sysblk.maxcpu))
; 1594 :         {
; 1595 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  00617	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0061c	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1596 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00620	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00625	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1597 :             break;

  00629	e9 5a 18 00 00	 jmp	 $LN11@s390_servi
$LN79@s390_servi:

; 1598 :         }
; 1599 : 
; 1600 :         /* Point to SCCB data area following SCCB header */
; 1601 :         sccbscp = (SCCB_SCP_INFO*)(sccb+1);

  0062e	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00633	48 83 c0 08	 add	 rax, 8
  00637	48 89 44 24 70	 mov	 QWORD PTR sccbscp$[rsp], rax

; 1602 :         memset( sccbscp, 0, sizeof( SCCB_SCP_INFO ));

  0063c	48 8b 7c 24 70	 mov	 rdi, QWORD PTR sccbscp$[rsp]
  00641	33 c0		 xor	 eax, eax
  00643	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00648	f3 aa		 rep stosb
$LN15@s390_servi:

; 1603 : 
; 1604 :         /* Set main storage size in SCCB...
; 1605 :          *
; 1606 :          * PROGRAMMING NOTE: Hercules can support main storage sizes
; 1607 :          * up to slightly less than 16 EB (16384 PB = 16777216 TB),
; 1608 :          * even if the host operating system cannot.
; 1609 :          *
; 1610 :          * The guest architecural limit however is constrained by the
; 1611 :          * width of the realinum and realiszm SCCB fields (number of
; 1612 :          * increments and increment size in MB) which are only 16 bits
; 1613 :          * and 8 bits wide respectively. Thus the guest's maximum
; 1614 :          * storage size is architecturally limited to slightly less
; 1615 :          * than 16 TB (65535 increments * 255 MB increment size).
; 1616 :          *
; 1617 :          * This means if our main storage size is >= 64GB we must set
; 1618 :          * the increment size to a value which ensures the resulting
; 1619 :          * number of increments remains <= 65535.
; 1620 :          */
; 1621 : 
; 1622 :         ASSERT( sysblk.mainsize <= MAX_SCP_STORSIZE );

  0064a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00651	48 b9 00 00 10
	f0 ef 0f 00 00	 mov	 rcx, 17523199180800	; 00000feff0100000H
  0065b	48 39 88 90 00
	00 00		 cmp	 QWORD PTR [rax+144], rcx
  00662	76 5c		 jbe	 SHORT $LN80@s390_servi
$LN18@s390_servi:
  00664	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189749
  0066b	41 b8 56 06 00
	00		 mov	 r8d, 1622		; 00000656H
  00671	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189750
  00678	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189751
  0067f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0068b	85 c0		 test	 eax, eax
  0068d	74 20		 je	 SHORT $LN81@s390_servi
  0068f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189753
  00696	41 b8 56 06 00
	00		 mov	 r8d, 1622		; 00000656H
  0069c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189754
  006a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189755
  006aa	e8 00 00 00 00	 call	 DebuggerTrace
$LN81@s390_servi:
  006af	33 c0		 xor	 eax, eax
  006b1	85 c0		 test	 eax, eax
  006b3	75 af		 jne	 SHORT $LN18@s390_servi
  006b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006bb	85 c0		 test	 eax, eax
  006bd	74 01		 je	 SHORT $LN82@s390_servi
  006bf	cc		 int	 3
$LN82@s390_servi:
$LN80@s390_servi:
  006c0	33 c0		 xor	 eax, eax
  006c2	85 c0		 test	 eax, eax
  006c4	75 84		 jne	 SHORT $LN15@s390_servi

; 1623 :         incsizemb = (sysblk.mainsize + (MAX_1MINCR_STORSIZE - 1)) / MAX_1MINCR_STORSIZE;

  006c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006cd	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006d4	48 b9 ff ff ef
	ff 0f 00 00 00	 mov	 rcx, 68718428159	; 0000000fffefffffH
  006de	48 03 c1	 add	 rax, rcx
  006e1	33 d2		 xor	 edx, edx
  006e3	48 b9 00 00 f0
	ff 0f 00 00 00	 mov	 rcx, 68718428160	; 0000000ffff00000H
  006ed	48 f7 f1	 div	 rcx
  006f0	89 84 24 f4 00
	00 00		 mov	 DWORD PTR incsizemb$[rsp], eax

; 1624 :         realinc = sysblk.mainsize / (incsizemb << SHIFT_MEGABYTE);

  006f7	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR incsizemb$[rsp]
  006fe	c1 e0 14	 shl	 eax, 20
  00701	8b c0		 mov	 eax, eax
  00703	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv313[rsp], rax
  0070b	33 d2		 xor	 edx, edx
  0070d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00714	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  0071b	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv313[rsp]
  00723	48 f7 f1	 div	 rcx
  00726	89 84 24 f8 00
	00 00		 mov	 DWORD PTR realinc$[rsp], eax

; 1625 : 
; 1626 :         STORE_HW( sccbscp->realinum, realinc );

  0072d	0f b7 8c 24 f8
	00 00 00	 movzx	 ecx, WORD PTR realinc$[rsp]
  00735	e8 00 00 00 00	 call	 _byteswap_ushort
  0073a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0073f	0f b7 d0	 movzx	 edx, ax
  00742	e8 00 00 00 00	 call	 store_hw_noswap

; 1627 :         sccbscp->realiszm = (incsizemb & 0xFF);

  00747	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR incsizemb$[rsp]
  0074e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00753	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00758	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 1628 :         sccbscp->realbszk = 4;

  0075b	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00760	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 1629 :         STORE_HW( sccbscp->realiint, 1 );

  00764	66 b9 01 00	 mov	 cx, 1
  00768	e8 00 00 00 00	 call	 _byteswap_ushort
  0076d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00772	48 83 c1 04	 add	 rcx, 4
  00776	0f b7 d0	 movzx	 edx, ax
  00779	e8 00 00 00 00	 call	 store_hw_noswap

; 1630 : 
; 1631 : #if defined( _900 ) || defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1632 :         /* SIE supports the full address range */
; 1633 :         sccbscp->maxvm = 0;

  0077e	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00783	c6 40 5b 00	 mov	 BYTE PTR [rax+91], 0

; 1634 :         /* realiszm is valid */
; 1635 :         STORE_FW( sccbscp->grzm, 0 );

  00787	33 c9		 xor	 ecx, ecx
  00789	e8 00 00 00 00	 call	 _byteswap_ulong
  0078e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00793	48 83 c1 5c	 add	 rcx, 92			; 0000005cH
  00797	8b d0		 mov	 edx, eax
  00799	e8 00 00 00 00	 call	 store_fw_noswap

; 1636 :         /* Number of storage increments installed in esame mode */
; 1637 :         STORE_DW( sccbscp->grnmx, realinc );

  0079e	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR realinc$[rsp]
  007a5	8b c8		 mov	 ecx, eax
  007a7	e8 00 00 00 00	 call	 _byteswap_uint64
  007ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  007b1	48 83 c1 60	 add	 rcx, 96			; 00000060H
  007b5	48 8b d0	 mov	 rdx, rax
  007b8	e8 00 00 00 00	 call	 store_dw_noswap

; 1638 : #endif
; 1639 : 
; 1640 : #if defined( FEATURE_EXPANDED_STORAGE )
; 1641 :         /* Set expanded storage size in SCCB */
; 1642 :         xstincnum = sysblk.xpndsize /

  007bd	33 d2		 xor	 edx, edx
  007bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007c6	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  007cc	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  007d1	f7 f1		 div	 ecx
  007d3	89 84 24 d0 00
	00 00		 mov	 DWORD PTR xstincnum$[rsp], eax

; 1643 :                     (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);
; 1644 :         STORE_FW( sccbscp->xpndinum, xstincnum );

  007da	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR xstincnum$[rsp]
  007e1	e8 00 00 00 00	 call	 _byteswap_ulong
  007e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  007eb	48 83 c1 18	 add	 rcx, 24
  007ef	8b d0		 mov	 edx, eax
  007f1	e8 00 00 00 00	 call	 store_fw_noswap

; 1645 :         xstblkinc = XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT;

  007f6	c7 84 24 b4 00
	00 00 00 01 00
	00		 mov	 DWORD PTR xstblkinc$[rsp], 256 ; 00000100H

; 1646 :         STORE_FW( sccbscp->xpndsz4K, xstblkinc );

  00801	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR xstblkinc$[rsp]
  00808	e8 00 00 00 00	 call	 _byteswap_ulong
  0080d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00812	48 83 c1 1c	 add	 rcx, 28
  00816	8b d0		 mov	 edx, eax
  00818	e8 00 00 00 00	 call	 store_fw_noswap

; 1647 : #endif
; 1648 : 
; 1649 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1650 :         /* Set the Vector section size in the SCCB */
; 1651 :         STORE_HW( sccbscp->vectssiz, VECTOR_SECTION_SIZE );
; 1652 :         /* Set the Vector partial sum number in the SCCB */
; 1653 :         STORE_HW( sccbscp->vectpsum, VECTOR_PARTIAL_SUM_NUMBER );
; 1654 : #endif
; 1655 :         /* Set CPU array count and offset in SCCB */
; 1656 :         STORE_HW( sccbscp->numcpu, sysblk.maxcpu );

  0081d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00824	0f b7 88 00 01
	00 00		 movzx	 ecx, WORD PTR [rax+256]
  0082b	e8 00 00 00 00	 call	 _byteswap_ushort
  00830	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00835	48 83 c1 08	 add	 rcx, 8
  00839	0f b7 d0	 movzx	 edx, ax
  0083c	e8 00 00 00 00	 call	 store_hw_noswap

; 1657 :         offset = sizeof( SCCB_HEADER ) + sizeof( SCCB_SCP_INFO );

  00841	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00846	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1658 :         STORE_HW( sccbscp->offcpu, offset );

  0084b	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  00850	e8 00 00 00 00	 call	 _byteswap_ushort
  00855	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0085a	48 83 c1 0a	 add	 rcx, 10
  0085e	0f b7 d0	 movzx	 edx, ax
  00861	e8 00 00 00 00	 call	 store_hw_noswap

; 1659 : 
; 1660 : #if defined( FEATURE_MPF_INFO )
; 1661 :         /* Set MPF array count and offset in SCCB */
; 1662 :         STORE_HW( sccbscp->nummpf, sysblk.maxcpu-1 );

  00866	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0086d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00873	ff c8		 dec	 eax
  00875	0f b7 c8	 movzx	 ecx, ax
  00878	e8 00 00 00 00	 call	 _byteswap_ushort
  0087d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00882	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00886	0f b7 d0	 movzx	 edx, ax
  00889	e8 00 00 00 00	 call	 store_hw_noswap

; 1663 : #endif
; 1664 :         offset += (U16)sizeof( SCCB_CPU_INFO ) * sysblk.maxcpu;

  0088e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00895	6b 80 00 01 00
	00 10		 imul	 eax, DWORD PTR [rax+256], 16
  0089c	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  008a1	03 c8		 add	 ecx, eax
  008a3	8b c1		 mov	 eax, ecx
  008a5	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1665 :         STORE_HW( sccbscp->offmpf, offset );

  008aa	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  008af	e8 00 00 00 00	 call	 _byteswap_ushort
  008b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  008b9	48 83 c1 42	 add	 rcx, 66			; 00000042H
  008bd	0f b7 d0	 movzx	 edx, ax
  008c0	e8 00 00 00 00	 call	 store_hw_noswap

; 1666 : 
; 1667 :         /* Set HSA array count and offset in SCCB */
; 1668 :         STORE_HW( sccbscp->numhsa, 0 );

  008c5	33 c9		 xor	 ecx, ecx
  008c7	e8 00 00 00 00	 call	 _byteswap_ushort
  008cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  008d1	48 83 c1 0c	 add	 rcx, 12
  008d5	0f b7 d0	 movzx	 edx, ax
  008d8	e8 00 00 00 00	 call	 store_hw_noswap

; 1669 : 
; 1670 : #if defined( FEATURE_MPF_INFO )
; 1671 :         offset += (U16)sizeof( SCCB_MPF_INFO ) * sysblk.maxcpu-1;

  008dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008e4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008ea	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  008ef	8d 44 41 ff	 lea	 eax, DWORD PTR [rcx+rax*2-1]
  008f3	66 89 44 24 68	 mov	 WORD PTR offset$[rsp], ax

; 1672 : #endif
; 1673 :         STORE_HW( sccbscp->offhsa, offset );

  008f8	0f b7 4c 24 68	 movzx	 ecx, WORD PTR offset$[rsp]
  008fd	e8 00 00 00 00	 call	 _byteswap_ushort
  00902	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00907	48 83 c1 0e	 add	 rcx, 14
  0090b	0f b7 d0	 movzx	 edx, ax
  0090e	e8 00 00 00 00	 call	 store_hw_noswap

; 1674 : 
; 1675 :         /* Build the MPF information array after the CPU info */
; 1676 :         /* Move IPL load parameter to SCCB */
; 1677 :         get_loadparm( sccbscp->loadparm );

  00913	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00918	48 83 c0 10	 add	 rax, 16
  0091c	48 8b c8	 mov	 rcx, rax
  0091f	e8 00 00 00 00	 call	 get_loadparm

; 1678 : 
; 1679 :         /* Set installed features bit mask in SCCB */
; 1680 :         memcpy( sccbscp->ifm, ARCH_DEP( scpinfo_ifm ), sizeof( sccbscp->ifm ));

  00924	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00929	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR s390_scpinfo_ifm
  00930	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1681 : 
; 1682 :         memcpy( sccbscp->cfg, ARCH_DEP( scpinfo_cfg ), sizeof( sccbscp->cfg ));

  00934	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00939	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_scpinfo_cfg
  00940	48 8d 78 48	 lea	 rdi, QWORD PTR [rax+72]
  00944	48 8b f1	 mov	 rsi, rcx
  00947	b9 06 00 00 00	 mov	 ecx, 6
  0094c	f3 a4		 rep movsb

; 1683 :         /* sccbscp->cfg11 = ARCH_DEP( scpinfo_cfg11 ); */
; 1684 : 
; 1685 :         /* Turn off bits for facilities that aren't enabled */
; 1686 :         if (!FACILITY_ENABLED( 016_EXT_TRANSL_2, regs ))

  0094e	b8 01 00 00 00	 mov	 eax, 1
  00953	48 6b c0 02	 imul	 rax, rax, 2
  00957	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0095f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00967	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0096c	85 c0		 test	 eax, eax
  0096e	75 28		 jne	 SHORT $LN83@s390_servi

; 1687 :             sccbscp->cfg[4] &= ~SCCB_CFG4_EXTENDED_TRANSLATION_FACILITY2;

  00970	b8 01 00 00 00	 mov	 eax, 1
  00975	48 6b c0 04	 imul	 rax, rax, 4
  00979	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  0097e	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00983	83 e0 ef	 and	 eax, -17
  00986	b9 01 00 00 00	 mov	 ecx, 1
  0098b	48 6b c9 04	 imul	 rcx, rcx, 4
  0098f	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00994	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN83@s390_servi:

; 1688 : 
; 1689 :         if (!FACILITY_ENABLED( 009_SENSE_RUN_STATUS, regs ))

  00998	b8 01 00 00 00	 mov	 eax, 1
  0099d	48 6b c0 01	 imul	 rax, rax, 1
  009a1	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a9	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  009b1	83 e0 40	 and	 eax, 64			; 00000040H
  009b4	85 c0		 test	 eax, eax
  009b6	75 28		 jne	 SHORT $LN84@s390_servi

; 1690 :             sccbscp->cfg[5] &= ~SCCB_CFG5_SENSE_RUNNING_STATUS;

  009b8	b8 01 00 00 00	 mov	 eax, 1
  009bd	48 6b c0 05	 imul	 rax, rax, 5
  009c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  009c6	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  009cb	83 e0 f7	 and	 eax, -9
  009ce	b9 01 00 00 00	 mov	 ecx, 1
  009d3	48 6b c9 05	 imul	 rcx, rcx, 5
  009d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  009dc	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN84@s390_servi:

; 1691 : 
; 1692 :         /* Turn on additioal bits for facilities that ARE enabled */
; 1693 :         if (0
; 1694 : #if defined( _FEATURE_HYPERVISOR )
; 1695 :             || FACILITY_ENABLED( HERC_LOGICAL_PARTITION, regs )
; 1696 : #endif
; 1697 : #if defined( _FEATURE_EMULATE_VM )
; 1698 :             || FACILITY_ENABLED( HERC_VIRTUAL_MACHINE, regs )

  009e0	33 c0		 xor	 eax, eax
  009e2	85 c0		 test	 eax, eax
  009e4	75 40		 jne	 SHORT $LN86@s390_servi
  009e6	b8 01 00 00 00	 mov	 eax, 1
  009eb	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  009ef	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f7	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  009ff	83 e0 08	 and	 eax, 8
  00a02	85 c0		 test	 eax, eax
  00a04	75 20		 jne	 SHORT $LN86@s390_servi
  00a06	b8 01 00 00 00	 mov	 eax, 1
  00a0b	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00a0f	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a17	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00a1f	83 e0 01	 and	 eax, 1
  00a22	85 c0		 test	 eax, eax
  00a24	74 29		 je	 SHORT $LN85@s390_servi
$LN86@s390_servi:

; 1699 : #endif
; 1700 :         )
; 1701 :             sccbscp->cfg[0] |= SCCB_CFG0_LOGICALLY_PARTITIONED;

  00a26	b8 01 00 00 00	 mov	 eax, 1
  00a2b	48 6b c0 00	 imul	 rax, rax, 0
  00a2f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00a34	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00a39	0f ba e8 07	 bts	 eax, 7
  00a3d	b9 01 00 00 00	 mov	 ecx, 1
  00a42	48 6b c9 00	 imul	 rcx, rcx, 0
  00a46	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00a4b	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN85@s390_servi:

; 1702 : 
; 1703 : #if defined( _900 ) || defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1704 :         if (FACILITY_ENABLED( 001_ZARCH_INSTALLED, regs ))

  00a4f	b8 01 00 00 00	 mov	 eax, 1
  00a54	48 6b c0 00	 imul	 rax, rax, 0
  00a58	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a60	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00a68	83 e0 40	 and	 eax, 64			; 00000040H
  00a6b	85 c0		 test	 eax, eax
  00a6d	74 28		 je	 SHORT $LN87@s390_servi

; 1705 :             sccbscp->cfg[5] |= SCCB_CFG5_ESAME;

  00a6f	b8 01 00 00 00	 mov	 eax, 1
  00a74	48 6b c0 05	 imul	 rax, rax, 5
  00a78	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00a7d	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00a82	83 c8 01	 or	 eax, 1
  00a85	b9 01 00 00 00	 mov	 ecx, 1
  00a8a	48 6b c9 05	 imul	 rcx, rcx, 5
  00a8e	48 8b 54 24 70	 mov	 rdx, QWORD PTR sccbscp$[rsp]
  00a93	88 44 0a 48	 mov	 BYTE PTR [rdx+rcx+72], al
$LN87@s390_servi:

; 1706 : #endif
; 1707 : 
; 1708 :         /* Build the CPU information array after the SCP info */
; 1709 :         sccbcpu = (SCCB_CPU_INFO*)(sccbscp+1);

  00a97	48 8b 44 24 70	 mov	 rax, QWORD PTR sccbscp$[rsp]
  00a9c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00aa0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR sccbcpu$[rsp], rax

; 1710 : 
; 1711 :         for (i=0; i < sysblk.maxcpu; i++, sccbcpu++)

  00aa8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00ab0	eb 1e		 jmp	 SHORT $LN21@s390_servi
$LN19@s390_servi:
  00ab2	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00ab6	ff c0		 inc	 eax
  00ab8	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
  00abc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00ac4	48 83 c0 10	 add	 rax, 16
  00ac8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR sccbcpu$[rsp], rax
$LN21@s390_servi:
  00ad0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ad7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00add	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00ae1	7d 6d		 jge	 SHORT $LN20@s390_servi

; 1712 :         {
; 1713 :             memset( sccbcpu, 0, sizeof( SCCB_CPU_INFO ));

  00ae3	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR sccbcpu$[rsp]
  00aeb	33 c0		 xor	 eax, eax
  00aed	b9 10 00 00 00	 mov	 ecx, 16
  00af2	f3 aa		 rep stosb

; 1714 :             sccbcpu->cpa = i;

  00af4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00afc	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR i$[rsp]
  00b01	88 08		 mov	 BYTE PTR [rax], cl

; 1715 :             sccbcpu->tod = 0;

  00b03	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b0b	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 1716 :             memcpy( sccbcpu->cpf, ARCH_DEP( scpinfo_cpf ), sizeof( sccbcpu->cpf ));

  00b0f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_scpinfo_cpf
  00b1e	48 8d 78 02	 lea	 rdi, QWORD PTR [rax+2]
  00b22	48 8b f1	 mov	 rsi, rcx
  00b25	b9 0c 00 00 00	 mov	 ecx, 12
  00b2a	f3 a4		 rep movsb

; 1717 :             sccbcpu->ptyp = sysblk.ptyp[i];

  00b2c	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00b31	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sccbcpu$[rsp]
  00b39	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b40	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  00b48	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 1718 : 
; 1719 : #if defined( FEATURE_CRYPTO )
; 1720 : //          sccbcpu->ksid = SCCB_KSID_CRYPTO_UNIT_ID;
; 1721 : #endif
; 1722 : 
; 1723 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1724 : 
; 1725 :             if (IS_CPU_ONLINE(i) && sysblk.regs[i]->vf->online)
; 1726 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_INSTALLED;
; 1727 :             if (IS_CPU_ONLINE(i) && sysblk.regs[i]->vf->online)
; 1728 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_CONNECTED;
; 1729 :             if (!IS_CPU_ONLINE(i))
; 1730 :                 sccbcpu->cpf[2] |= SCCB_CPF2_VECTOR_FEATURE_STANDBY_STATE;
; 1731 : #endif
; 1732 :         }

  00b4b	e9 62 ff ff ff	 jmp	 $LN19@s390_servi
$LN20@s390_servi:

; 1733 : 
; 1734 : #if defined( FEATURE_MPF_INFO )
; 1735 : 
; 1736 :         /* Define machine capacity */
; 1737 :         STORE_FW( sccbscp->rcci, 10000 );

  00b50	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00b55	e8 00 00 00 00	 call	 _byteswap_ulong
  00b5a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccbscp$[rsp]
  00b5f	48 83 c1 4e	 add	 rcx, 78			; 0000004eH
  00b63	8b d0		 mov	 edx, eax
  00b65	e8 00 00 00 00	 call	 store_fw_noswap

; 1738 : 
; 1739 :         /* Fill in the MP Factors array */
; 1740 :         sccbmpf = (SCCB_MPF_INFO*)(sccbcpu);

  00b6a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sccbcpu$[rsp]
  00b72	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR sccbmpf$[rsp], rax

; 1741 :         get_mpfactors((BYTE*)sccbmpf);

  00b7a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR sccbmpf$[rsp]
  00b82	e8 00 00 00 00	 call	 get_mpfactors

; 1742 : #endif
; 1743 : 
; 1744 :         /* Set response code X'0010' in SCCB header */
; 1745 :         sccb->reas = SCCB_REAS_NONE;

  00b87	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00b8c	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1746 :         sccb->resp = SCCB_RESP_INFO;

  00b90	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00b95	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1747 :         break;

  00b99	e9 ea 12 00 00	 jmp	 $LN11@s390_servi
$docheckstop$179:

; 1748 : 
; 1749 : docheckstop:
; 1750 : 
; 1751 :         ARCH_DEP( checkstop_all_cpus )( regs );

  00b9e	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba6	e8 00 00 00 00	 call	 s390_checkstop_all_cpus

; 1752 :         RELEASE_INTLOCK( regs );

  00bab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189762
  00bb2	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bba	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1753 :         longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  00bbf	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc7	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00bcd	ba ff ff ff ff	 mov	 edx, -1
  00bd2	48 8b c8	 mov	 rcx, rax
  00bd5	e8 00 00 00 00	 call	 longjmp
$LN88@s390_servi:

; 1754 :         UNREACHABLE_CODE( return );
; 1755 : 
; 1756 :     case SCLP_READ_CHP_INFO:
; 1757 : 
; 1758 :         /* Set the main storage change bit */
; 1759 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00bda	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00bde	b2 02		 mov	 dl, 2
  00be0	8b c8		 mov	 ecx, eax
  00be2	e8 00 00 00 00	 call	 s390_or_storage_key

; 1760 : 
; 1761 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1762 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00be7	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00beb	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00bf0	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00bf5	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00bf9	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00bfd	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00c03	3b c1		 cmp	 eax, ecx
  00c05	74 17		 je	 SHORT $LN89@s390_servi

; 1763 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1764 :         {
; 1765 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00c07	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c0c	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1766 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00c10	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c15	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1767 :             break;

  00c19	e9 6a 12 00 00	 jmp	 $LN11@s390_servi
$LN89@s390_servi:

; 1768 :         }
; 1769 : 
; 1770 :         /* Set response code X'0300' if SCCB length
; 1771 :            is insufficient to contain channel path info */
; 1772 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_CHP_INFO ))

  00c1e	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00c23	48 83 f8 68	 cmp	 rax, 104		; 00000068H
  00c27	73 17		 jae	 SHORT $LN90@s390_servi

; 1773 :         {
; 1774 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  00c29	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c2e	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1775 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00c32	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c37	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1776 :             break;

  00c3b	e9 48 12 00 00	 jmp	 $LN11@s390_servi
$LN90@s390_servi:

; 1777 :         }
; 1778 : 
; 1779 : #if defined( FEATURE_S370_CHANNEL )
; 1780 : 
; 1781 :         /* Point to SCCB data area following SCCB header */
; 1782 :         sccbchp = (SCCB_CHSET_INFO*)(sccb+1);
; 1783 :         memset( sccbchp, 0, sizeof( SCCB_CHSET_INFO ));
; 1784 : #else
; 1785 :         /* Point to SCCB data area following SCCB header */
; 1786 :         sccbchp = (SCCB_CHP_INFO*)(sccb+1);

  00c40	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00c45	48 83 c0 08	 add	 rax, 8
  00c49	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR sccbchp$[rsp], rax

; 1787 :         memset( sccbchp, 0, sizeof( SCCB_CHP_INFO ));

  00c51	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR sccbchp$[rsp]
  00c59	33 c0		 xor	 eax, eax
  00c5b	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00c60	f3 aa		 rep stosb

; 1788 : #endif
; 1789 : 
; 1790 : #if defined( FEATURE_CHANNEL_SUBSYSTEM )
; 1791 : 
; 1792 :         /* Identify CHPIDs installed, standby, and online */
; 1793 :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00c62	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c69	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00c70	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  00c78	eb 14		 jmp	 SHORT $LN24@s390_servi
$LN22@s390_servi:
  00c7a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c82	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00c86	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN24@s390_servi:
  00c8e	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c97	0f 84 6b 01 00
	00		 je	 $LN23@s390_servi

; 1794 :         {
; 1795 :             for (i=0; i < 8; i++)

  00c9d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00ca5	eb 0a		 jmp	 SHORT $LN27@s390_servi
$LN25@s390_servi:
  00ca7	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00cab	ff c0		 inc	 eax
  00cad	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN27@s390_servi:
  00cb1	83 7c 24 50 08	 cmp	 DWORD PTR i$[rsp], 8
  00cb6	0f 8d 47 01 00
	00		 jge	 $LN26@s390_servi

; 1796 :             {
; 1797 :                 chpbyte = dev->pmcw.chpid[i] / 8;

  00cbc	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00cc1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cc9	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00cd1	99		 cdq
  00cd2	83 e2 07	 and	 edx, 7
  00cd5	03 c2		 add	 eax, edx
  00cd7	c1 f8 03	 sar	 eax, 3
  00cda	89 84 24 98 00
	00 00		 mov	 DWORD PTR chpbyte$[rsp], eax

; 1798 :                 chpbit  = dev->pmcw.chpid[i] % 8;

  00ce1	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00ce6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cee	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00cf6	99		 cdq
  00cf7	83 e2 07	 and	 edx, 7
  00cfa	03 c2		 add	 eax, edx
  00cfc	83 e0 07	 and	 eax, 7
  00cff	2b c2		 sub	 eax, edx
  00d01	89 84 24 cc 00
	00 00		 mov	 DWORD PTR chpbit$[rsp], eax

; 1799 : 
; 1800 :                 if ( ((0x80 >> i) & dev->pmcw.pim))

  00d08	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00d0c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00d11	89 8c 24 20 01
	00 00		 mov	 DWORD PTR tv1631[rsp], ecx
  00d18	0f b6 c8	 movzx	 ecx, al
  00d1b	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv1631[rsp]
  00d22	d3 f8		 sar	 eax, cl
  00d24	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d2c	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  00d33	23 c1		 and	 eax, ecx
  00d35	85 c0		 test	 eax, eax
  00d37	0f 84 c1 00 00
	00		 je	 $LN91@s390_servi

; 1801 :                 {
; 1802 :                     sccbchp->installed  [ chpbyte ] |= 0x80 >> chpbit;

  00d3d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00d44	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00d4b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00d50	d3 fa		 sar	 edx, cl
  00d52	8b ca		 mov	 ecx, edx
  00d54	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00d5c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00d60	0b c1		 or	 eax, ecx
  00d62	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00d69	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00d71	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1803 : 
; 1804 :                     if (dev->pmcw.flag5 & PMCW5_V)

  00d74	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d7c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00d83	83 e0 01	 and	 eax, 1
  00d86	85 c0		 test	 eax, eax
  00d88	74 3b		 je	 SHORT $LN92@s390_servi

; 1805 :                         sccbchp->online [ chpbyte ] |= 0x80 >> chpbit;

  00d8a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00d91	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00d98	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00d9d	d3 fa		 sar	 edx, cl
  00d9f	8b ca		 mov	 ecx, edx
  00da1	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00da9	0f b6 44 02 40	 movzx	 eax, BYTE PTR [rdx+rax+64]
  00dae	0b c1		 or	 eax, ecx
  00db0	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00db7	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00dbf	88 44 0a 40	 mov	 BYTE PTR [rdx+rcx+64], al
  00dc3	eb 39		 jmp	 SHORT $LN93@s390_servi
$LN92@s390_servi:

; 1806 :                     else
; 1807 :                         sccbchp->standby[ chpbyte ] |= 0x80 >> chpbit;

  00dc5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR chpbyte$[rsp]
  00dcc	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR chpbit$[rsp]
  00dd3	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00dd8	d3 fa		 sar	 edx, cl
  00dda	8b ca		 mov	 ecx, edx
  00ddc	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00de4	0f b6 44 02 20	 movzx	 eax, BYTE PTR [rdx+rax+32]
  00de9	0b c1		 or	 eax, ecx
  00deb	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR chpbyte$[rsp]
  00df2	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR sccbchp$[rsp]
  00dfa	88 44 0a 20	 mov	 BYTE PTR [rdx+rcx+32], al
$LN93@s390_servi:
$LN91@s390_servi:

; 1808 :                 }
; 1809 :             }

  00dfe	e9 a4 fe ff ff	 jmp	 $LN25@s390_servi
$LN26@s390_servi:

; 1810 :         }

  00e03	e9 72 fe ff ff	 jmp	 $LN22@s390_servi
$LN23@s390_servi:

; 1811 : #endif
; 1812 : 
; 1813 : #if defined( FEATURE_S370_CHANNEL )
; 1814 : 
; 1815 :         /* For S/370, initialize identifiers for channel set 0A */
; 1816 :         for (i=0; i < 16; i++)
; 1817 :         {
; 1818 :             sccbchp->chanset0a[ 2*i + 0 ] = 0x80;
; 1819 :             sccbchp->chanset0a[ 2*i + 1 ] = i;
; 1820 :         }
; 1821 : 
; 1822 :         /* Set the channel set configuration byte */
; 1823 :         sccbchp->csconfig = 0xC0;
; 1824 : 
; 1825 : #endif
; 1826 : 
; 1827 :         /* Set response code X'0010' in SCCB header */
; 1828 :         sccb->reas = SCCB_REAS_NONE;

  00e08	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e0d	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1829 :         sccb->resp = SCCB_RESP_INFO;

  00e11	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e16	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1830 :         break;

  00e1a	e9 69 10 00 00	 jmp	 $LN11@s390_servi
$LN94@s390_servi:

; 1831 : 
; 1832 :     case SCLP_READ_CSI_INFO:
; 1833 : 
; 1834 :         /* Set the main storage change bit */
; 1835 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00e1f	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00e23	b2 02		 mov	 dl, 2
  00e25	8b c8		 mov	 ecx, eax
  00e27	e8 00 00 00 00	 call	 s390_or_storage_key

; 1836 : 
; 1837 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1838 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00e2c	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00e30	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00e35	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00e3a	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00e3e	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00e42	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00e48	3b c1		 cmp	 eax, ecx
  00e4a	74 17		 je	 SHORT $LN95@s390_servi

; 1839 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1840 :         {
; 1841 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00e4c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e51	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1842 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00e55	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e5a	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1843 :             break;

  00e5e	e9 25 10 00 00	 jmp	 $LN11@s390_servi
$LN95@s390_servi:

; 1844 :         }
; 1845 : 
; 1846 :         /* Set response code X'0300' if SCCB length
; 1847 :            is insufficient to contain channel path info */
; 1848 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_CSI_INFO ))

  00e63	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00e68	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00e6c	73 17		 jae	 SHORT $LN96@s390_servi

; 1849 :         {
; 1850 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  00e6e	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e73	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 1851 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00e77	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e7c	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1852 :             break;

  00e80	e9 03 10 00 00	 jmp	 $LN11@s390_servi
$LN96@s390_servi:

; 1853 :         }
; 1854 : 
; 1855 :         /* Point to SCCB data area following SCCB header */
; 1856 :         sccbcsi = (SCCB_CSI_INFO*)(sccb+1);

  00e85	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00e8a	48 83 c0 08	 add	 rax, 8
  00e8e	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR sccbcsi$[rsp], rax

; 1857 :         memset( sccbcsi, 0, sizeof( SCCB_CSI_INFO ));

  00e96	48 8b bc 24 38
	01 00 00	 mov	 rdi, QWORD PTR sccbcsi$[rsp]
  00e9e	33 c0		 xor	 eax, eax
  00ea0	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00ea5	f3 aa		 rep stosb

; 1858 : 
; 1859 :         sccbcsi->csif[0] =

  00ea7	b8 01 00 00 00	 mov	 eax, 1
  00eac	48 6b c0 00	 imul	 rax, rax, 0
  00eb0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR sccbcsi$[rsp]
  00eb8	c6 04 01 03	 mov	 BYTE PTR [rcx+rax], 3

; 1860 :             0
; 1861 : #if defined( FEATURE_CANCEL_IO_FACILITY )
; 1862 :             | SCCB_CSI0_CANCEL_IO_REQUEST_FACILITY
; 1863 : #endif
; 1864 :             | SCCB_CSI0_CONCURRENT_SENSE_FACILITY
; 1865 :             ;
; 1866 : 
; 1867 :         /* Set response code X'0010' in SCCB header */
; 1868 :         sccb->reas = SCCB_REAS_NONE;

  00ebc	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00ec1	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 1869 :         sccb->resp = SCCB_RESP_INFO;

  00ec5	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00eca	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 1870 :         break;

  00ece	e9 b5 0f 00 00	 jmp	 $LN11@s390_servi
$LN97@s390_servi:

; 1871 : 
; 1872 : #if defined( FEATURE_SYSTEM_CONSOLE )
; 1873 : 
; 1874 :     case SCLP_WRITE_EVENT_DATA:
; 1875 : 
; 1876 :         /* Set the main storage change bit */
; 1877 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  00ed3	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00ed7	b2 02		 mov	 dl, 2
  00ed9	8b c8		 mov	 ecx, eax
  00edb	e8 00 00 00 00	 call	 s390_or_storage_key

; 1878 : 
; 1879 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 1880 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  00ee0	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  00ee4	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00ee9	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  00eee	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  00ef2	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  00ef6	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00efc	3b c1		 cmp	 eax, ecx
  00efe	74 17		 je	 SHORT $LN98@s390_servi

; 1881 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 1882 :         {
; 1883 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  00f00	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f05	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 1884 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  00f09	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f0e	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 1885 :             break;

  00f12	e9 71 0f 00 00	 jmp	 $LN11@s390_servi
$LN98@s390_servi:

; 1886 :         }
; 1887 : 
; 1888 :         /* Point to SCCB data area following SCCB header */
; 1889 :         evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  00f17	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  00f1c	48 83 c0 08	 add	 rax, 8
  00f20	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 1890 :         FETCH_HW( evd_len, evd_hdr->totlen );

  00f28	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00f30	48 8b c8	 mov	 rcx, rax
  00f33	e8 00 00 00 00	 call	 fetch_hw_noswap
  00f38	0f b7 c8	 movzx	 ecx, ax
  00f3b	e8 00 00 00 00	 call	 _byteswap_ushort
  00f40	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR evd_len$[rsp], ax

; 1891 : 
; 1892 :         switch (evd_hdr->type)

  00f48	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00f50	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00f54	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv650[rsp], eax
  00f5b	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv650[rsp]
  00f62	83 e8 02	 sub	 eax, 2
  00f65	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv650[rsp], eax
  00f6c	83 bc 24 b0 00
	00 00 1a	 cmp	 DWORD PTR tv650[rsp], 26
  00f74	0f 87 89 04 00
	00		 ja	 $LN115@s390_servi
  00f7a	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv650[rsp]
  00f82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00f89	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN174@s390_servi[rcx+rax]
  00f91	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN175@s390_servi[rcx+rax*4]
  00f98	48 03 c1	 add	 rax, rcx
  00f9b	ff e0		 jmp	 rax
$LN99@s390_servi:
$LN100@s390_servi:
$LN30@s390_servi:

; 1893 :         {
; 1894 :         case SCCB_EVD_TYPE_MSG:
; 1895 :         case SCCB_EVD_TYPE_PRIOR:
; 1896 : 
; 1897 :             while (sccblen > sizeof( SCCB_HEADER ))

  00f9d	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  00fa2	48 83 f8 08	 cmp	 rax, 8
  00fa6	0f 86 f5 03 00
	00		 jbe	 $LN31@s390_servi

; 1898 :             {
; 1899 :                 FETCH_HW( evd_len, evd_hdr->totlen );

  00fac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00fb4	48 8b c8	 mov	 rcx, rax
  00fb7	e8 00 00 00 00	 call	 fetch_hw_noswap
  00fbc	0f b7 c8	 movzx	 ecx, ax
  00fbf	e8 00 00 00 00	 call	 _byteswap_ushort
  00fc4	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR evd_len$[rsp], ax

; 1900 : 
; 1901 :                 /* Point to the Message Control Data Block */
; 1902 :                 mcd_bk = (SCCB_MCD_BK*)(evd_hdr+1);

  00fcc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00fd4	48 83 c0 06	 add	 rax, 6
  00fd8	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR mcd_bk$[rsp], rax

; 1903 :                 FETCH_HW( mcd_len, mcd_bk->length );

  00fe0	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mcd_bk$[rsp]
  00fe8	48 8b c8	 mov	 rcx, rax
  00feb	e8 00 00 00 00	 call	 fetch_hw_noswap
  00ff0	0f b7 c8	 movzx	 ecx, ax
  00ff3	e8 00 00 00 00	 call	 _byteswap_ushort
  00ff8	66 89 84 24 88
	00 00 00	 mov	 WORD PTR mcd_len$[rsp], ax

; 1904 : 
; 1905 :                 obj_hdr = (SCCB_OBJ_HDR*)(mcd_bk+1);

  01000	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mcd_bk$[rsp]
  01008	48 83 c0 0c	 add	 rax, 12
  0100c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR obj_hdr$[rsp], rax
$LN32@s390_servi:

; 1906 : 
; 1907 :                 while (mcd_len > sizeof( SCCB_MCD_BK ))

  01014	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR mcd_len$[rsp]
  0101c	48 83 f8 0c	 cmp	 rax, 12
  01020	0f 86 27 03 00
	00		 jbe	 $LN33@s390_servi

; 1908 :                 {
; 1909 :                     FETCH_HW( obj_len, obj_hdr->length );

  01026	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  0102e	48 8b c8	 mov	 rcx, rax
  01031	e8 00 00 00 00	 call	 fetch_hw_noswap
  01036	0f b7 c8	 movzx	 ecx, ax
  01039	e8 00 00 00 00	 call	 _byteswap_ushort
  0103e	66 89 84 24 80
	00 00 00	 mov	 WORD PTR obj_len$[rsp], ax

; 1910 : 
; 1911 :                     if (obj_len == 0)

  01046	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  0104e	85 c0		 test	 eax, eax
  01050	75 17		 jne	 SHORT $LN101@s390_servi

; 1912 :                     {
; 1913 :                         sccb->reas = SCCB_REAS_BUFF_LEN_ERR;

  01052	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01057	c6 40 06 72	 mov	 BYTE PTR [rax+6], 114	; 00000072H

; 1914 :                         sccb->resp = SCCB_RESP_BUFF_LEN_ERR;

  0105b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01060	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 1915 :                         break;

  01064	e9 e4 02 00 00	 jmp	 $LN33@s390_servi
$LN101@s390_servi:

; 1916 :                     }
; 1917 : 
; 1918 :                     FETCH_HW( obj_type, obj_hdr->type );

  01069	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  01071	48 83 c0 02	 add	 rax, 2
  01075	48 8b c8	 mov	 rcx, rax
  01078	e8 00 00 00 00	 call	 fetch_hw_noswap
  0107d	0f b7 c8	 movzx	 ecx, ax
  01080	e8 00 00 00 00	 call	 _byteswap_ushort
  01085	66 89 84 24 c8
	00 00 00	 mov	 WORD PTR obj_type$[rsp], ax

; 1919 : 
; 1920 :                     if (obj_type == SCCB_OBJ_TYPE_MESSAGE)

  0108d	0f b7 84 24 c8
	00 00 00	 movzx	 eax, WORD PTR obj_type$[rsp]
  01095	83 f8 04	 cmp	 eax, 4
  01098	0f 85 70 02 00
	00		 jne	 $LN102@s390_servi

; 1921 :                     {
; 1922 :                         mto_bk = (SCCB_MTO_BK*)(obj_hdr+1);

  0109e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR obj_hdr$[rsp]
  010a6	48 83 c0 04	 add	 rax, 4
  010aa	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR mto_bk$[rsp], rax

; 1923 :                         evd_msg = (BYTE*)(mto_bk+1);

  010b2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR mto_bk$[rsp]
  010ba	48 83 c0 06	 add	 rax, 6
  010be	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR evd_msg$[rsp], rax

; 1924 :                         event_msglen = obj_len -

  010c6	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  010ce	48 83 e8 0a	 sub	 rax, 10
  010d2	89 84 24 84 00
	00 00		 mov	 DWORD PTR event_msglen$[rsp], eax

; 1925 :                                 (sizeof( SCCB_OBJ_HDR ) + sizeof( SCCB_MTO_BK ));
; 1926 : 
; 1927 :                         if (event_msglen < 0)

  010d9	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR event_msglen$[rsp], 0
  010e1	7d 17		 jge	 SHORT $LN103@s390_servi

; 1928 :                         {
; 1929 :                             sccb->reas = SCCB_REAS_BUFF_LEN_ERR;

  010e3	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  010e8	c6 40 06 72	 mov	 BYTE PTR [rax+6], 114	; 00000072H

; 1930 :                             sccb->resp = SCCB_RESP_BUFF_LEN_ERR;

  010ec	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  010f1	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 1931 :                             break;

  010f5	e9 53 02 00 00	 jmp	 $LN33@s390_servi
$LN103@s390_servi:

; 1932 :                         }
; 1933 : 
; 1934 :                         /* Make sure we don't overflow our buffer! */
; 1935 :                         if (event_msglen >= (int) sizeof( message ) - 1)

  010fa	81 bc 24 84 00
	00 00 f8 0f 00
	00		 cmp	 DWORD PTR event_msglen$[rsp], 4088 ; 00000ff8H
  01105	7c 76		 jl	 SHORT $LN104@s390_servi

; 1936 :                         {
; 1937 :                             int trunc_len = (int) sizeof( message ) - 1;

  01107	c7 84 24 fc 00
	00 00 f8 0f 00
	00		 mov	 DWORD PTR trunc_len$3[rsp], 4088 ; 00000ff8H

; 1938 :                             // "Overly long %d byte SCP message truncated to %d bytes"
; 1939 :                             WRMSG( HHC00159, "W", event_msglen, trunc_len );

  01112	b9 01 00 00 00	 mov	 ecx, 1
  01117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0111d	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR trunc_len$3[rsp]
  01124	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01128	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR event_msglen$[rsp]
  0112f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189780
  0113a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0113f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189781
  01146	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0114b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01150	41 b9 03 00 00
	00		 mov	 r9d, 3
  01156	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189782
  0115d	ba 93 07 00 00	 mov	 edx, 1939		; 00000793H
  01162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189783
  01169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1940 :                             event_msglen = trunc_len;

  0116f	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR trunc_len$3[rsp]
  01176	89 84 24 84 00
	00 00		 mov	 DWORD PTR event_msglen$[rsp], eax
$LN104@s390_servi:

; 1941 :                         }
; 1942 : 
; 1943 :                         /* Print line unless it is a response prompt */
; 1944 :                         if (!(mto_bk->ltflag[0] & SCCB_MTO_LTFLG0_PROMPT))

  0117d	b8 01 00 00 00	 mov	 eax, 1
  01182	48 6b c0 00	 imul	 rax, rax, 0
  01186	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR mto_bk$[rsp]
  0118e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01192	83 e0 08	 and	 eax, 8
  01195	85 c0		 test	 eax, eax
  01197	0f 85 71 01 00
	00		 jne	 $LN105@s390_servi

; 1945 :                         {
; 1946 :                             static bool s390x_linux_detected = false;
; 1947 :                             static bool is_s390x_linux = false;
; 1948 : 
; 1949 : #if 0 // debug: save raw EBCDIC message for test program
; 1950 : static bool once = false;
; 1951 : static FILE* efile;
; 1952 : U16 u16_len = (U16) event_msglen;
; 1953 : U16 big_endian_u16_len = CSWAP16( u16_len );
; 1954 : if (!once)
; 1955 : {
; 1956 :     once = true;
; 1957 :     efile = fopen( "e_msgs.dat", "wb" );
; 1958 : }
; 1959 : fwrite( &big_endian_u16_len, 1, 2, efile );
; 1960 : fwrite( evd_msg, 1, u16_len, efile );
; 1961 : fflush( efile );
; 1962 : #endif // debug: save raw EBCDIC message for test program
; 1963 : 
; 1964 :                             /* Try to auto-detect if this is s390x Linux */
; 1965 :                             if (!s390x_linux_detected)

  0119d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?s390x_linux_detected@?CE@??s390_service_call@@9@9
  011a4	85 c0		 test	 eax, eax
  011a6	75 3a		 jne	 SHORT $LN106@s390_servi

; 1966 :                             {
; 1967 :                                 /* Look for EBCDIC 'ESC' character */
; 1968 :                                 if (event_msglen && memchr( evd_msg, 0x4A, event_msglen ))

  011a8	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR event_msglen$[rsp], 0
  011b0	74 30		 je	 SHORT $LN107@s390_servi
  011b2	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR event_msglen$[rsp]
  011ba	4c 8b c0	 mov	 r8, rax
  011bd	ba 4a 00 00 00	 mov	 edx, 74			; 0000004aH
  011c2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  011ca	e8 00 00 00 00	 call	 memchr
  011cf	48 85 c0	 test	 rax, rax
  011d2	74 0e		 je	 SHORT $LN107@s390_servi

; 1969 :                                 {
; 1970 :                                     s390x_linux_detected = true;

  011d4	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s390x_linux_detected@?CE@??s390_service_call@@9@9, 1

; 1971 :                                     is_s390x_linux = true;

  011db	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?is_s390x_linux@?CE@??s390_service_call@@9@9, 1
$LN107@s390_servi:
$LN106@s390_servi:

; 1972 :                                 }
; 1973 :                             }
; 1974 : 
; 1975 :                             /* If this is s390x Linux... */
; 1976 :                             if (is_s390x_linux)

  011e2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?is_s390x_linux@?CE@??s390_service_call@@9@9
  011e9	85 c0		 test	 eax, eax
  011eb	74 19		 je	 SHORT $LN108@s390_servi

; 1977 :                             {
; 1978 :                                 /* Try to remove terminal escape sequences.
; 1979 :                                    Note: also does LOGMSG as appropriate. */
; 1980 :                                 gh534_fix( event_msglen, evd_msg );

  011ed	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR evd_msg$[rsp]
  011f5	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR event_msglen$[rsp]
  011fc	e8 00 00 00 00	 call	 gh534_fix

; 1981 :                             }

  01201	e9 08 01 00 00	 jmp	 $LN109@s390_servi
$LN108@s390_servi:

; 1982 :                             else /* Normal processing: show message as-is */
; 1983 :                             {
; 1984 :                                 for (i=0; i < event_msglen; i++)

  01206	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0120e	eb 0a		 jmp	 SHORT $LN36@s390_servi
$LN34@s390_servi:
  01210	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01214	ff c0		 inc	 eax
  01216	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN36@s390_servi:
  0121a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR event_msglen$[rsp]
  01221	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01225	7d 6d		 jge	 SHORT $LN35@s390_servi

; 1985 :                                 {
; 1986 :                                     message[i] = isprint( guest_to_host( evd_msg[i] )) ?

  01227	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0122c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  01234	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  01238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0123e	0f b6 c0	 movzx	 eax, al
  01241	8b c8		 mov	 ecx, eax
  01243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  01249	85 c0		 test	 eax, eax
  0124b	74 23		 je	 SHORT $LN161@s390_servi
  0124d	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  01252	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR evd_msg$[rsp]
  0125a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0125e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  01264	0f b6 c0	 movzx	 eax, al
  01267	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv774[rsp], eax
  0126e	eb 0b		 jmp	 SHORT $LN162@s390_servi
$LN161@s390_servi:
  01270	c7 84 24 e8 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv774[rsp], 32 ; 00000020H
$LN162@s390_servi:
  0127b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  01280	0f b6 8c 24 e8
	00 00 00	 movzx	 ecx, BYTE PTR tv774[rsp]
  01288	88 8c 04 b0 01
	00 00		 mov	 BYTE PTR message$[rsp+rax], cl

; 1987 :                                         guest_to_host( evd_msg[i] ) : ' ';
; 1988 :                                 }

  0128f	e9 7c ff ff ff	 jmp	 $LN34@s390_servi
$LN35@s390_servi:

; 1989 :                                 message[i] = '\0';

  01294	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  01299	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR $T7[rsp], rax
  012a1	48 81 bc 24 50
	01 00 00 f9 0f
	00 00		 cmp	 QWORD PTR $T7[rsp], 4089 ; 00000ff9H
  012ad	73 02		 jae	 SHORT $LN163@s390_servi
  012af	eb 05		 jmp	 SHORT $LN164@s390_servi
$LN163@s390_servi:
  012b1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN164@s390_servi:
  012b6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  012be	c6 84 04 b0 01
	00 00 00	 mov	 BYTE PTR message$[rsp+rax], 0

; 1990 :                                 LOGMSG("%s\n",message);

  012c6	b9 01 00 00 00	 mov	 ecx, 1
  012cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012d1	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  012d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189789
  012e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  012f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189790
  012fc	ba c6 07 00 00	 mov	 edx, 1990		; 000007c6H
  01301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189791
  01308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN109@s390_servi:
$LN105@s390_servi:
$LN102@s390_servi:

; 1991 :                             }
; 1992 :                         }
; 1993 :                     }
; 1994 : 
; 1995 :                     mcd_len -= obj_len;

  0130e	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  01316	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR mcd_len$[rsp]
  0131e	2b c8		 sub	 ecx, eax
  01320	8b c1		 mov	 eax, ecx
  01322	66 89 84 24 88
	00 00 00	 mov	 WORD PTR mcd_len$[rsp], ax

; 1996 :                     obj_hdr=(SCCB_OBJ_HDR *)((BYTE*)obj_hdr + obj_len);

  0132a	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR obj_len$[rsp]
  01332	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR obj_hdr$[rsp]
  0133a	48 03 c8	 add	 rcx, rax
  0133d	48 8b c1	 mov	 rax, rcx
  01340	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR obj_hdr$[rsp], rax

; 1997 :                 }

  01348	e9 c7 fc ff ff	 jmp	 $LN32@s390_servi
$LN33@s390_servi:

; 1998 : 
; 1999 :                 /* Indicate Event Processed */
; 2000 :                 evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  0134d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  01355	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01359	0f ba e8 07	 bts	 eax, 7
  0135d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  01365	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 2001 : 
; 2002 :                 sccblen -= evd_len;

  01368	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR evd_len$[rsp]
  01370	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  01375	2b c8		 sub	 ecx, eax
  01377	8b c1		 mov	 eax, ecx
  01379	66 89 44 24 60	 mov	 WORD PTR sccblen$[rsp], ax

; 2003 :                 evd_hdr = (SCCB_EVD_HDR *)((BYTE*)evd_hdr + evd_len);

  0137e	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR evd_len$[rsp]
  01386	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  0138e	48 03 c8	 add	 rcx, rax
  01391	48 8b c1	 mov	 rax, rcx
  01394	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 2004 :             }

  0139c	e9 fc fb ff ff	 jmp	 $LN30@s390_servi
$LN31@s390_servi:

; 2005 : 
; 2006 :             /* Set response code X'0020' in SCCB header */
; 2007 :             sccb->reas = SCCB_REAS_NONE;

  013a1	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  013a6	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2008 :             sccb->resp = SCCB_RESP_COMPLETE;

  013aa	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  013af	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2009 :             break;

  013b3	e9 32 01 00 00	 jmp	 $LN28@s390_servi
$LN110@s390_servi:

; 2010 : 
; 2011 :         case SCCB_EVD_TYPE_CPIDENT:
; 2012 :             sclp_cpident(sccb);

  013b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  013bd	e8 00 00 00 00	 call	 sclp_cpident

; 2013 :             break;

  013c2	e9 23 01 00 00	 jmp	 $LN28@s390_servi
$LN111@s390_servi:

; 2014 : 
; 2015 : #if defined( FEATURE_SCEDIO )
; 2016 : 
; 2017 :         case SCCB_EVD_TYPE_SCEDIO:
; 2018 :             ARCH_DEP( sclp_scedio_request )( sccb );

  013c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  013cc	e8 00 00 00 00	 call	 s390_sclp_scedio_request

; 2019 :             break;

  013d1	e9 14 01 00 00	 jmp	 $LN28@s390_servi
$LN112@s390_servi:

; 2020 : #endif
; 2021 : 
; 2022 : #if defined( _FEATURE_HARDWARE_LOADER )
; 2023 : 
; 2024 :         case SCCB_EVD_TYPE_HWL:
; 2025 :             ARCH_DEP( sclp_hwl_request )( sccb );

  013d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  013db	e8 00 00 00 00	 call	 s390_sclp_hwl_request

; 2026 :             break;

  013e0	e9 05 01 00 00	 jmp	 $LN28@s390_servi
$LN113@s390_servi:

; 2027 : 
; 2028 :         case SCCB_EVD_TYPE_SDIAS:
; 2029 :             ARCH_DEP( sclp_sdias_request )( sccb );

  013e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  013ea	e8 00 00 00 00	 call	 s390_sclp_sdias_request

; 2030 :             break;

  013ef	e9 f6 00 00 00	 jmp	 $LN28@s390_servi
$LN114@s390_servi:

; 2031 : #endif
; 2032 : 
; 2033 : #if defined( FEATURE_INTEGRATED_3270_CONSOLE )
; 2034 : 
; 2035 :         case SCCB_EVD_TYPE_SYSG:
; 2036 :             sclp_sysg_write( sccb );

  013f4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  013f9	e8 00 00 00 00	 call	 sclp_sysg_write

; 2037 :             break;

  013fe	e9 e7 00 00 00	 jmp	 $LN28@s390_servi
$LN115@s390_servi:
$LN39@s390_servi:

; 2038 : #endif
; 2039 : 
; 2040 : #if defined( FEATURE_INTEGRATED_ASCII_CONSOLE )
; 2041 : 
; 2042 :         case SCCB_EVD_TYPE_VT220:
; 2043 :             sclp_sysa_write( sccb );
; 2044 :             break;
; 2045 : #endif
; 2046 : 
; 2047 :         default:
; 2048 : 
; 2049 :             PTT_ERR("*SERVC", regs->GR_L(r1), regs->GR_L(r2), evd_hdr->type );

  01403	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0140a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0140d	48 83 e0 10	 and	 rax, 16
  01411	48 85 c0	 test	 rax, rax
  01414	74 6a		 je	 SHORT $LN116@s390_servi
  01416	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0141e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01422	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  01429	48 8b 94 24 e8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01431	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  01438	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  0143f	48 8b bc 24 e8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01447	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  0144e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01457	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0145c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189799
  01463	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01468	44 8b c9	 mov	 r9d, ecx
  0146b	44 8b c2	 mov	 r8d, edx
  0146e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189800
  01475	b9 10 00 00 00	 mov	 ecx, 16
  0147a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN116@s390_servi:
  01480	33 c0		 xor	 eax, eax
  01482	85 c0		 test	 eax, eax
  01484	0f 85 79 ff ff
	ff		 jne	 $LN39@s390_servi

; 2050 : 
; 2051 :             if (HDC3( debug_sclp_unknown_event, evd_hdr, sccb, regs ))

  0148a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event
  01491	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01495	74 28		 je	 SHORT $LN165@s390_servi
  01497	4c 8b 84 24 e8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0149f	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  014a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  014ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event
  014b3	ff 10		 call	 QWORD PTR [rax]
  014b5	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv841[rsp], rax
  014bd	eb 0c		 jmp	 SHORT $LN166@s390_servi
$LN165@s390_servi:
  014bf	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv841[rsp], 0
$LN166@s390_servi:
  014cb	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR tv841[rsp], 0
  014d4	74 02		 je	 SHORT $LN117@s390_servi

; 2052 :                 break;

  014d6	eb 12		 jmp	 SHORT $LN28@s390_servi
$LN117@s390_servi:

; 2053 : 
; 2054 :             /* Set response code X'73F0' in SCCB header */
; 2055 :             sccb->reas = SCCB_REAS_SYNTAX_ERROR;

  014d8	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  014dd	c6 40 06 73	 mov	 BYTE PTR [rax+6], 115	; 00000073H

; 2056 :             sccb->resp = SCCB_RESP_SYNTAX_ERROR;

  014e1	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  014e6	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN28@s390_servi:

; 2057 :             break;
; 2058 :         }
; 2059 :         break;

  014ea	e9 99 09 00 00	 jmp	 $LN11@s390_servi
$LN118@s390_servi:

; 2060 : 
; 2061 :     case SCLP_READ_EVENT_DATA:
; 2062 : 
; 2063 :         /* Set the main storage change bit */
; 2064 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  014ef	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  014f3	b2 02		 mov	 dl, 2
  014f5	8b c8		 mov	 ecx, eax
  014f7	e8 00 00 00 00	 call	 s390_or_storage_key

; 2065 : 
; 2066 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2067 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  014fc	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01500	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  01505	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  0150a	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  0150e	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  01512	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  01518	3b c1		 cmp	 eax, ecx
  0151a	74 17		 je	 SHORT $LN119@s390_servi

; 2068 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2069 :         {
; 2070 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  0151c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01521	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2071 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  01525	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0152a	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2072 :             break;

  0152e	e9 55 09 00 00	 jmp	 $LN11@s390_servi
$LN119@s390_servi:

; 2073 :         }
; 2074 : 
; 2075 :         /* Point to SCCB data area following SCCB header */
; 2076 :         evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  01533	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01538	48 83 c0 08	 add	 rax, 8
  0153c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 2077 : 
; 2078 :         if (SCLP_RECV_ENABLED(               PRIOR ) &&

  01544	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  0154a	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0154f	85 c0		 test	 eax, eax
  01551	74 20		 je	 SHORT $LN120@s390_servi
  01553	66 b9 09 00	 mov	 cx, 9
  01557	e8 00 00 00 00	 call	 sclp_attn_pending
  0155c	85 c0		 test	 eax, eax
  0155e	74 13		 je	 SHORT $LN120@s390_servi

; 2079 :             sclp_attn_pending( SCCB_EVD_TYPE_PRIOR ))
; 2080 :         {
; 2081 :             sclp_opcmd_event(sccb, SCCB_EVD_TYPE_PRIOR);

  01560	66 ba 09 00	 mov	 dx, 9
  01564	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01569	e8 00 00 00 00	 call	 sclp_opcmd_event

; 2082 :             break;

  0156e	e9 15 09 00 00	 jmp	 $LN11@s390_servi
$LN120@s390_servi:

; 2083 :         }
; 2084 : 
; 2085 :         if (SCLP_RECV_ENABLED(               OPCMD ) &&

  01573	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01579	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0157e	85 c0		 test	 eax, eax
  01580	74 20		 je	 SHORT $LN121@s390_servi
  01582	66 b9 01 00	 mov	 cx, 1
  01586	e8 00 00 00 00	 call	 sclp_attn_pending
  0158b	85 c0		 test	 eax, eax
  0158d	74 13		 je	 SHORT $LN121@s390_servi

; 2086 :             sclp_attn_pending( SCCB_EVD_TYPE_OPCMD ))
; 2087 :         {
; 2088 :             sclp_opcmd_event(sccb, SCCB_EVD_TYPE_OPCMD);

  0158f	66 ba 01 00	 mov	 dx, 1
  01593	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01598	e8 00 00 00 00	 call	 sclp_opcmd_event

; 2089 :             break;

  0159d	e9 e6 08 00 00	 jmp	 $LN11@s390_servi
$LN121@s390_servi:

; 2090 :         }
; 2091 : 
; 2092 : #if defined( FEATURE_SCEDIO )
; 2093 : 
; 2094 :         if (SCLP_RECV_ENABLED(               SCEDIO ) &&

  015a2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  015a8	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  015ad	85 c0		 test	 eax, eax
  015af	74 1c		 je	 SHORT $LN122@s390_servi
  015b1	66 b9 07 00	 mov	 cx, 7
  015b5	e8 00 00 00 00	 call	 sclp_attn_pending
  015ba	85 c0		 test	 eax, eax
  015bc	74 0f		 je	 SHORT $LN122@s390_servi

; 2095 :             sclp_attn_pending( SCCB_EVD_TYPE_SCEDIO ))
; 2096 :         {
; 2097 :             ARCH_DEP( sclp_scedio_event )( sccb );

  015be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  015c3	e8 00 00 00 00	 call	 s390_sclp_scedio_event

; 2098 :             break;

  015c8	e9 bb 08 00 00	 jmp	 $LN11@s390_servi
$LN122@s390_servi:

; 2099 :         }
; 2100 : #endif
; 2101 : 
; 2102 : #if defined( _FEATURE_HARDWARE_LOADER )
; 2103 : 
; 2104 :         if (SCLP_RECV_ENABLED(               HWL ) &&

  015cd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  015d3	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  015d8	85 c0		 test	 eax, eax
  015da	74 1c		 je	 SHORT $LN123@s390_servi
  015dc	66 b9 0c 00	 mov	 cx, 12
  015e0	e8 00 00 00 00	 call	 sclp_attn_pending
  015e5	85 c0		 test	 eax, eax
  015e7	74 0f		 je	 SHORT $LN123@s390_servi

; 2105 :             sclp_attn_pending( SCCB_EVD_TYPE_HWL ))
; 2106 :         {
; 2107 :             ARCH_DEP( sclp_hwl_event )( sccb );

  015e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  015ee	e8 00 00 00 00	 call	 s390_sclp_hwl_event

; 2108 :             break;

  015f3	e9 90 08 00 00	 jmp	 $LN11@s390_servi
$LN123@s390_servi:

; 2109 :         }
; 2110 : 
; 2111 :         if (SCLP_RECV_ENABLED(               SDIAS ) &&

  015f8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  015fe	83 e0 10	 and	 eax, 16
  01601	85 c0		 test	 eax, eax
  01603	74 1c		 je	 SHORT $LN124@s390_servi
  01605	66 b9 1c 00	 mov	 cx, 28
  01609	e8 00 00 00 00	 call	 sclp_attn_pending
  0160e	85 c0		 test	 eax, eax
  01610	74 0f		 je	 SHORT $LN124@s390_servi

; 2112 :             sclp_attn_pending( SCCB_EVD_TYPE_SDIAS ))
; 2113 :         {
; 2114 :             ARCH_DEP( sclp_sdias_event )( sccb );

  01612	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01617	e8 00 00 00 00	 call	 s390_sclp_sdias_event

; 2115 :             break;

  0161c	e9 67 08 00 00	 jmp	 $LN11@s390_servi
$LN124@s390_servi:

; 2116 :         }
; 2117 : #endif
; 2118 : 
; 2119 : #if defined( FEATURE_INTEGRATED_3270_CONSOLE )
; 2120 : 
; 2121 :         if (SCLP_RECV_ENABLED(               SYSG ) &&

  01621	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01627	83 e0 20	 and	 eax, 32			; 00000020H
  0162a	85 c0		 test	 eax, eax
  0162c	74 1c		 je	 SHORT $LN125@s390_servi
  0162e	66 b9 1b 00	 mov	 cx, 27
  01632	e8 00 00 00 00	 call	 sclp_attn_pending
  01637	85 c0		 test	 eax, eax
  01639	74 0f		 je	 SHORT $LN125@s390_servi

; 2122 :             sclp_attn_pending( SCCB_EVD_TYPE_SYSG ))
; 2123 :         {
; 2124 :             sclp_sysg_poll( sccb );

  0163b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01640	e8 00 00 00 00	 call	 sclp_sysg_poll

; 2125 :             break;

  01645	e9 3e 08 00 00	 jmp	 $LN11@s390_servi
$LN125@s390_servi:

; 2126 :         }
; 2127 : #endif
; 2128 : 
; 2129 : #if defined( FEATURE_INTEGRATED_ASCII_CONSOLE )
; 2130 : 
; 2131 :         if (SCLP_RECV_ENABLED(               VT220 ) &&
; 2132 :             sclp_attn_pending( SCCB_EVD_TYPE_VT220 ))
; 2133 :         {
; 2134 :             sclp_sysa_poll( sccb );
; 2135 :             break;
; 2136 :         }
; 2137 : #endif
; 2138 : 
; 2139 :         if (SCLP_RECV_ENABLED(               SIGQ ) &&

  0164a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01650	83 e0 08	 and	 eax, 8
  01653	85 c0		 test	 eax, eax
  01655	74 1c		 je	 SHORT $LN126@s390_servi
  01657	66 b9 1d 00	 mov	 cx, 29
  0165b	e8 00 00 00 00	 call	 sclp_attn_pending
  01660	85 c0		 test	 eax, eax
  01662	74 0f		 je	 SHORT $LN126@s390_servi

; 2140 :             sclp_attn_pending( SCCB_EVD_TYPE_SIGQ ))
; 2141 :         {
; 2142 :             sclp_sigq_event( sccb );

  01664	48 8b 4c 24 58	 mov	 rcx, QWORD PTR sccb$[rsp]
  01669	e8 00 00 00 00	 call	 sclp_sigq_event

; 2143 :             break;

  0166e	e9 15 08 00 00	 jmp	 $LN11@s390_servi
$LN126@s390_servi:
$LN42@s390_servi:

; 2144 :         }
; 2145 : 
; 2146 :         PTT_ERR("*SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  01673	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0167a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0167d	48 83 e0 10	 and	 rax, 16
  01681	48 85 c0	 test	 rax, rax
  01684	74 6c		 je	 SHORT $LN127@s390_servi
  01686	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0168e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  01694	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0169b	48 8b 94 24 e8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  016a3	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  016aa	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  016b1	48 8b bc 24 e8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  016b9	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  016c0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016c9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  016ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189812
  016d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016da	44 8b c9	 mov	 r9d, ecx
  016dd	44 8b c2	 mov	 r8d, edx
  016e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189813
  016e7	b9 10 00 00 00	 mov	 ecx, 16
  016ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN127@s390_servi:
  016f2	33 c0		 xor	 eax, eax
  016f4	85 c0		 test	 eax, eax
  016f6	0f 85 77 ff ff
	ff		 jne	 $LN42@s390_servi

; 2147 : 
; 2148 :         if (HDC3( debug_sclp_event_data, evd_hdr, sccb, regs ))

  016fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_event_data
  01703	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01707	74 28		 je	 SHORT $LN167@s390_servi
  01709	4c 8b 84 24 e8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01711	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  01716	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  0171e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_event_data
  01725	ff 10		 call	 QWORD PTR [rax]
  01727	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv964[rsp], rax
  0172f	eb 0c		 jmp	 SHORT $LN168@s390_servi
$LN167@s390_servi:
  01731	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv964[rsp], 0
$LN168@s390_servi:
  0173d	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR tv964[rsp], 0
  01746	74 05		 je	 SHORT $LN128@s390_servi

; 2149 :             break;

  01748	e9 3b 07 00 00	 jmp	 $LN11@s390_servi
$LN128@s390_servi:

; 2150 : 
; 2151 :         /* Set response code X'62F0' if events are pending but suppressed */
; 2152 :         if (sclp_attn_pending( 0 ))

  0174d	33 c9		 xor	 ecx, ecx
  0174f	e8 00 00 00 00	 call	 sclp_attn_pending
  01754	85 c0		 test	 eax, eax
  01756	74 19		 je	 SHORT $LN129@s390_servi

; 2153 :         {
; 2154 :             sccb->reas = SCCB_REAS_EVENTS_SUP;

  01758	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0175d	c6 40 06 62	 mov	 BYTE PTR [rax+6], 98	; 00000062H

; 2155 :             sccb->resp = SCCB_RESP_EVENTS_SUP;

  01761	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01766	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2156 :             break;

  0176a	e9 19 07 00 00	 jmp	 $LN11@s390_servi

; 2157 :         }

  0176f	eb 12		 jmp	 SHORT $LN130@s390_servi
$LN129@s390_servi:

; 2158 :         else
; 2159 :         {
; 2160 :             /* Set response code X'60F0' if no outstanding events */
; 2161 :             sccb->reas = SCCB_REAS_NO_EVENTS;

  01771	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01776	c6 40 06 60	 mov	 BYTE PTR [rax+6], 96	; 00000060H

; 2162 :             sccb->resp = SCCB_RESP_NO_EVENTS;

  0177a	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  0177f	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN130@s390_servi:

; 2163 :         }
; 2164 :         break;

  01783	e9 00 07 00 00	 jmp	 $LN11@s390_servi
$LN131@s390_servi:

; 2165 : 
; 2166 :     case SCLP_WRITE_EVENT_MASK:
; 2167 : 
; 2168 :         /* Set the main storage change bit */
; 2169 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  01788	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  0178c	b2 02		 mov	 dl, 2
  0178e	8b c8		 mov	 ecx, eax
  01790	e8 00 00 00 00	 call	 s390_or_storage_key

; 2170 : 
; 2171 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2172 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  01795	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01799	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0179e	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  017a3	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  017a7	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  017ab	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  017b1	3b c1		 cmp	 eax, ecx
  017b3	74 17		 je	 SHORT $LN132@s390_servi

; 2173 :            ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2174 :         {
; 2175 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  017b5	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017ba	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2176 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  017be	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017c3	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2177 :             break;

  017c7	e9 bc 06 00 00	 jmp	 $LN11@s390_servi
$LN132@s390_servi:

; 2178 :         }
; 2179 : 
; 2180 :         /* Point to SCCB data area following SCCB header */
; 2181 :         evd_mask = (SCCB_EVT_MASK*)(sccb+1);

  017cc	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  017d1	48 83 c0 08	 add	 rax, 8
  017d5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR evd_mask$[rsp], rax

; 2182 : 
; 2183 :         /* Get length of single mask field */
; 2184 :         FETCH_HW( masklen, evd_mask->length );

  017dd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR evd_mask$[rsp]
  017e5	48 83 c0 02	 add	 rax, 2
  017e9	48 8b c8	 mov	 rcx, rax
  017ec	e8 00 00 00 00	 call	 fetch_hw_noswap
  017f1	0f b7 c8	 movzx	 ecx, ax
  017f4	e8 00 00 00 00	 call	 _byteswap_ushort
  017f9	0f b7 c0	 movzx	 eax, ax
  017fc	89 44 24 7c	 mov	 DWORD PTR masklen$[rsp], eax

; 2185 : 
; 2186 :         /* Save old mask settings in order to suppress superflous messages */
; 2187 :         old_cp_recv_mask = servc_cp_recv_mask & ARCH_DEP( sclp_send_mask ) & SCCB_EVENT_CONS_RECV_MASK;

  01800	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_send_mask
  01806	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  0180c	23 c8		 and	 ecx, eax
  0180e	8b c1		 mov	 eax, ecx
  01810	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  01815	89 84 24 28 01
	00 00		 mov	 DWORD PTR old_cp_recv_mask$[rsp], eax

; 2188 :         old_cp_send_mask = servc_cp_send_mask & ARCH_DEP( sclp_recv_mask ) & SCCB_EVENT_CONS_SEND_MASK;

  0181c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_recv_mask
  01822	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01828	23 c8		 and	 ecx, eax
  0182a	8b c1		 mov	 eax, ecx
  0182c	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  01831	89 84 24 24 01
	00 00		 mov	 DWORD PTR old_cp_send_mask$[rsp], eax

; 2189 : 
; 2190 :         for (i=0; i < 4; i++)

  01838	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01840	eb 0a		 jmp	 SHORT $LN45@s390_servi
$LN43@s390_servi:
  01842	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01846	ff c0		 inc	 eax
  01848	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN45@s390_servi:
  0184c	83 7c 24 50 04	 cmp	 DWORD PTR i$[rsp], 4
  01851	0f 8d 84 00 00
	00		 jge	 $LN44@s390_servi

; 2191 :         {
; 2192 :             servc_cp_recv_mask <<= 8;

  01857	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  0185d	c1 e0 08	 shl	 eax, 8
  01860	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_recv_mask, eax

; 2193 :             servc_cp_send_mask <<= 8;

  01866	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_send_mask
  0186c	c1 e0 08	 shl	 eax, 8
  0186f	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_send_mask, eax

; 2194 : 
; 2195 :             if ((U32)i < masklen)

  01875	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  01879	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  0187d	73 57		 jae	 SHORT $LN133@s390_servi

; 2196 :             {
; 2197 :                 servc_cp_recv_mask |= evd_mask->masks[ i+(0*masklen) ];

  0187f	6b 44 24 7c 00	 imul	 eax, DWORD PTR masklen$[rsp], 0
  01884	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01888	03 c8		 add	 ecx, eax
  0188a	8b c1		 mov	 eax, ecx
  0188c	8b c0		 mov	 eax, eax
  0188e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  01896	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  0189b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  018a1	0b c8		 or	 ecx, eax
  018a3	8b c1		 mov	 eax, ecx
  018a5	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_recv_mask, eax

; 2198 :                 servc_cp_send_mask |= evd_mask->masks[ i+(1*masklen) ];

  018ab	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  018af	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  018b3	03 c8		 add	 ecx, eax
  018b5	8b c1		 mov	 eax, ecx
  018b7	8b c0		 mov	 eax, eax
  018b9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  018c1	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  018c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  018cc	0b c8		 or	 ecx, eax
  018ce	8b c1		 mov	 eax, ecx
  018d0	89 05 00 00 00
	00		 mov	 DWORD PTR servc_cp_send_mask, eax
$LN133@s390_servi:

; 2199 :             }
; 2200 :         }

  018d6	e9 67 ff ff ff	 jmp	 $LN43@s390_servi
$LN44@s390_servi:

; 2201 : 
; 2202 :         if (0
; 2203 :             || (servc_cp_recv_mask & ~ARCH_DEP( sclp_recv_mask ))
; 2204 :             || (servc_cp_send_mask & ~ARCH_DEP( sclp_send_mask ))

  018db	33 c0		 xor	 eax, eax
  018dd	85 c0		 test	 eax, eax
  018df	75 2c		 jne	 SHORT $LN135@s390_servi
  018e1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_recv_mask
  018e7	f7 d0		 not	 eax
  018e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  018ef	23 c8		 and	 ecx, eax
  018f1	8b c1		 mov	 eax, ecx
  018f3	85 c0		 test	 eax, eax
  018f5	75 16		 jne	 SHORT $LN135@s390_servi
  018f7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_send_mask
  018fd	f7 d0		 not	 eax
  018ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01905	23 c8		 and	 ecx, eax
  01907	8b c1		 mov	 eax, ecx
  01909	85 c0		 test	 eax, eax
  0190b	74 41		 je	 SHORT $LN134@s390_servi
$LN135@s390_servi:

; 2205 :         )
; 2206 :         {
; 2207 :             HDC3( debug_sclp_unknown_event_mask, evd_mask, sccb, regs );

  0190d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event_mask
  01914	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01918	74 28		 je	 SHORT $LN169@s390_servi
  0191a	4c 8b 84 24 e8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01922	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  01927	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR evd_mask$[rsp]
  0192f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_event_mask
  01936	ff 10		 call	 QWORD PTR [rax]
  01938	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv1028[rsp], rax
  01940	eb 0c		 jmp	 SHORT $LN170@s390_servi
$LN169@s390_servi:
  01942	48 c7 84 24 88
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv1028[rsp], 0
$LN170@s390_servi:
$LN134@s390_servi:

; 2208 :         }
; 2209 : 
; 2210 :         /* Write the events that we support back */
; 2211 :         memset( &evd_mask->masks[ 2*masklen ], 0, 2 * masklen );

  0194e	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  01952	03 c0		 add	 eax, eax
  01954	8b c0		 mov	 eax, eax
  01956	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv1032[rsp], rax
  0195e	8b 4c 24 7c	 mov	 ecx, DWORD PTR masklen$[rsp]
  01962	03 c9		 add	 ecx, ecx
  01964	8b c9		 mov	 ecx, ecx
  01966	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  0196e	48 8d 4c 0a 04	 lea	 rcx, QWORD PTR [rdx+rcx+4]
  01973	48 8b f9	 mov	 rdi, rcx
  01976	33 c0		 xor	 eax, eax
  01978	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv1032[rsp]
  01980	f3 aa		 rep stosb

; 2212 : 
; 2213 :         for (i=0; (i < 4) && ((U32)i < masklen); i++)

  01982	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0198a	eb 0a		 jmp	 SHORT $LN48@s390_servi
$LN46@s390_servi:
  0198c	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  01990	ff c0		 inc	 eax
  01992	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN48@s390_servi:
  01996	83 7c 24 50 04	 cmp	 DWORD PTR i$[rsp], 4
  0199b	0f 8d b9 00 00
	00		 jge	 $LN47@s390_servi
  019a1	8b 44 24 7c	 mov	 eax, DWORD PTR masklen$[rsp]
  019a5	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  019a9	0f 83 ab 00 00
	00		 jae	 $LN47@s390_servi

; 2214 :         {
; 2215 :             evd_mask->masks[ i+(2*masklen) ] |= (ARCH_DEP( sclp_recv_mask ) >> ((3-i)*8)) & 0xFF;

  019af	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  019b3	8b 4c 24 7c	 mov	 ecx, DWORD PTR masklen$[rsp]
  019b7	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  019ba	8b c0		 mov	 eax, eax
  019bc	b9 03 00 00 00	 mov	 ecx, 3
  019c1	2b 4c 24 50	 sub	 ecx, DWORD PTR i$[rsp]
  019c5	c1 e1 03	 shl	 ecx, 3
  019c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR s390_sclp_recv_mask
  019ce	d3 ea		 shr	 edx, cl
  019d0	8b ca		 mov	 ecx, edx
  019d2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  019d8	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  019e0	0f b6 44 02 04	 movzx	 eax, BYTE PTR [rdx+rax+4]
  019e5	0b c1		 or	 eax, ecx
  019e7	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  019eb	8b 54 24 7c	 mov	 edx, DWORD PTR masklen$[rsp]
  019ef	8d 0c 51	 lea	 ecx, DWORD PTR [rcx+rdx*2]
  019f2	8b c9		 mov	 ecx, ecx
  019f4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  019fc	88 44 0a 04	 mov	 BYTE PTR [rdx+rcx+4], al

; 2216 :             evd_mask->masks[ i+(3*masklen) ] |= (ARCH_DEP( sclp_send_mask ) >> ((3-i)*8)) & 0xFF;

  01a00	6b 44 24 7c 03	 imul	 eax, DWORD PTR masklen$[rsp], 3
  01a05	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01a09	03 c8		 add	 ecx, eax
  01a0b	8b c1		 mov	 eax, ecx
  01a0d	8b c0		 mov	 eax, eax
  01a0f	b9 03 00 00 00	 mov	 ecx, 3
  01a14	2b 4c 24 50	 sub	 ecx, DWORD PTR i$[rsp]
  01a18	c1 e1 03	 shl	 ecx, 3
  01a1b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR s390_sclp_send_mask
  01a21	d3 ea		 shr	 edx, cl
  01a23	8b ca		 mov	 ecx, edx
  01a25	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01a2b	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01a33	0f b6 44 02 04	 movzx	 eax, BYTE PTR [rdx+rax+4]
  01a38	0b c1		 or	 eax, ecx
  01a3a	6b 4c 24 7c 03	 imul	 ecx, DWORD PTR masklen$[rsp], 3
  01a3f	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  01a43	03 d1		 add	 edx, ecx
  01a45	8b ca		 mov	 ecx, edx
  01a47	8b c9		 mov	 ecx, ecx
  01a49	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR evd_mask$[rsp]
  01a51	88 44 0a 04	 mov	 BYTE PTR [rdx+rcx+4], al

; 2217 :         }

  01a55	e9 32 ff ff ff	 jmp	 $LN46@s390_servi
$LN47@s390_servi:

; 2218 : 
; 2219 :         /* Issue message only when supported mask has changed */
; 2220 :         if (0
; 2221 :             || (servc_cp_recv_mask & ARCH_DEP( sclp_send_mask ) & SCCB_EVENT_CONS_RECV_MASK) != old_cp_recv_mask
; 2222 :             || (servc_cp_send_mask & ARCH_DEP( sclp_recv_mask ) & SCCB_EVENT_CONS_SEND_MASK) != old_cp_send_mask

  01a5a	33 c0		 xor	 eax, eax
  01a5c	85 c0		 test	 eax, eax
  01a5e	75 40		 jne	 SHORT $LN137@s390_servi
  01a60	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_send_mask
  01a66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_recv_mask
  01a6c	23 c8		 and	 ecx, eax
  01a6e	8b c1		 mov	 eax, ecx
  01a70	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  01a75	3b 84 24 28 01
	00 00		 cmp	 eax, DWORD PTR old_cp_recv_mask$[rsp]
  01a7c	75 22		 jne	 SHORT $LN137@s390_servi
  01a7e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR s390_sclp_recv_mask
  01a84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_cp_send_mask
  01a8a	23 c8		 and	 ecx, eax
  01a8c	8b c1		 mov	 eax, ecx
  01a8e	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  01a93	3b 84 24 24 01
	00 00		 cmp	 eax, DWORD PTR old_cp_send_mask$[rsp]
  01a9a	0f 84 cc 00 00
	00		 je	 $LN136@s390_servi
$LN137@s390_servi:

; 2223 :         )
; 2224 :         {
; 2225 :             if (0
; 2226 :                 || (servc_cp_recv_mask & SCCB_EVENT_CONS_RECV_MASK) != 0
; 2227 :                 || (servc_cp_send_mask & SCCB_EVENT_CONS_SEND_MASK) != 0

  01aa0	33 c0		 xor	 eax, eax
  01aa2	85 c0		 test	 eax, eax
  01aa4	75 1e		 jne	 SHORT $LN140@s390_servi
  01aa6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  01aac	25 00 00 80 40	 and	 eax, 1082130432		; 40800000H
  01ab1	85 c0		 test	 eax, eax
  01ab3	75 0f		 jne	 SHORT $LN140@s390_servi
  01ab5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_send_mask
  01abb	25 01 00 80 80	 and	 eax, -2139095039	; 80800001H
  01ac0	85 c0		 test	 eax, eax
  01ac2	74 55		 je	 SHORT $LN138@s390_servi
$LN140@s390_servi:

; 2228 :             )
; 2229 :                 // "SCLP console interface %s"
; 2230 :                 WRMSG( HHC00006, "I", "active" );

  01ac4	b9 01 00 00 00	 mov	 ecx, 1
  01ac9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01acf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189827
  01ad6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01adb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189828
  01ae2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ae7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189829
  01aee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01af3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01af8	41 b9 03 00 00
	00		 mov	 r9d, 3
  01afe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189830
  01b05	ba b6 08 00 00	 mov	 edx, 2230		; 000008b6H
  01b0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189831
  01b11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01b17	eb 53		 jmp	 SHORT $LN139@s390_servi
$LN138@s390_servi:

; 2231 :             else
; 2232 :                 // "SCLP console interface %s"
; 2233 :                 WRMSG( HHC00006, "I", "inactive" );

  01b19	b9 01 00 00 00	 mov	 ecx, 1
  01b1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189832
  01b2b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189833
  01b37	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189834
  01b43	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b48	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b4d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b53	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189835
  01b5a	ba b9 08 00 00	 mov	 edx, 2233		; 000008b9H
  01b5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189836
  01b66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN139@s390_servi:
$LN136@s390_servi:

; 2234 :         }
; 2235 : 
; 2236 :         /* Set response code X'0020' in SCCB header */
; 2237 :         sccb->reas = SCCB_REAS_NONE;

  01b6c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01b71	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2238 :         sccb->resp = SCCB_RESP_COMPLETE;

  01b75	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01b7a	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2239 :         break;

  01b7e	e9 05 03 00 00	 jmp	 $LN11@s390_servi
$LN141@s390_servi:

; 2240 : 
; 2241 : #endif /* defined( FEATURE_SYSTEM_CONSOLE ) */
; 2242 : 
; 2243 : #if defined( FEATURE_EXPANDED_STORAGE )
; 2244 : 
; 2245 :    case SCLP_READ_XST_MAP:
; 2246 : 
; 2247 :         /* Set the main storage change bit */
; 2248 :         ARCH_DEP( or_storage_key )( sccb_absolute_addr, STORKEY_CHANGE );

  01b83	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01b87	b2 02		 mov	 dl, 2
  01b89	8b c8		 mov	 ecx, eax
  01b8b	e8 00 00 00 00	 call	 s390_or_storage_key

; 2249 : 
; 2250 :         /* Set response code X'0100' if SCCB crosses a page boundary */
; 2251 :         if ((sccb_absolute_addr & STORAGE_KEY_PAGEMASK) !=

  01b90	8b 44 24 64	 mov	 eax, DWORD PTR sccb_absolute_addr$[rsp]
  01b94	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  01b99	0f b7 4c 24 60	 movzx	 ecx, WORD PTR sccblen$[rsp]
  01b9e	8b 54 24 64	 mov	 edx, DWORD PTR sccb_absolute_addr$[rsp]
  01ba2	8d 4c 0a ff	 lea	 ecx, DWORD PTR [rdx+rcx-1]
  01ba6	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  01bac	3b c1		 cmp	 eax, ecx
  01bae	74 17		 je	 SHORT $LN142@s390_servi

; 2252 :             ((sccb_absolute_addr + sccblen - 1) & STORAGE_KEY_PAGEMASK))
; 2253 :         {
; 2254 :             sccb->reas = SCCB_REAS_NOT_PGBNDRY;

  01bb0	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01bb5	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2255 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  01bb9	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01bbe	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2256 :             break;

  01bc2	e9 c1 02 00 00	 jmp	 $LN11@s390_servi
$LN142@s390_servi:

; 2257 :         }
; 2258 : 
; 2259 :         /* Calculate number of blocks per increment */
; 2260 :         xstblkinc = XSTORE_INCREMENT_SIZE / XSTORE_PAGESIZE;

  01bc7	c7 84 24 b4 00
	00 00 00 01 00
	00		 mov	 DWORD PTR xstblkinc$[rsp], 256 ; 00000100H

; 2261 : 
; 2262 :         /* Set response code X'0300' if SCCB length
; 2263 :            is insufficient to contain xstore info */
; 2264 :         if ( sccblen < sizeof( SCCB_HEADER ) + sizeof( SCCB_XST_MAP )

  01bd2	0f b7 44 24 60	 movzx	 eax, WORD PTR sccblen$[rsp]
  01bd7	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv1126[rsp], rax
  01bdf	33 d2		 xor	 edx, edx
  01be1	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR xstblkinc$[rsp]
  01be8	b9 08 00 00 00	 mov	 ecx, 8
  01bed	f7 f1		 div	 ecx
  01bef	8b c0		 mov	 eax, eax
  01bf1	48 83 c0 10	 add	 rax, 16
  01bf5	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv1126[rsp]
  01bfd	48 3b c8	 cmp	 rcx, rax
  01c00	73 17		 jae	 SHORT $LN143@s390_servi

; 2265 :                 + xstblkinc/8)
; 2266 :         {
; 2267 :             sccb->reas = SCCB_REAS_TOO_SHORT;

  01c02	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c07	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2268 :             sccb->resp = SCCB_RESP_BLOCK_ERROR;

  01c0b	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c10	c6 40 07 00	 mov	 BYTE PTR [rax+7], 0

; 2269 :             break;

  01c14	e9 6f 02 00 00	 jmp	 $LN11@s390_servi
$LN143@s390_servi:

; 2270 :         }
; 2271 : 
; 2272 :         /* Point to SCCB data area following SCCB header */
; 2273 :         sccbxmap = (SCCB_XST_MAP*)(sccb+1);

  01c19	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c1e	48 83 c0 08	 add	 rax, 8
  01c22	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR sccbxmap$[rsp], rax

; 2274 : 
; 2275 :         /* Verify expanded storage increment number */
; 2276 :         xstincnum = sysblk.xpndsize /

  01c2a	33 d2		 xor	 edx, edx
  01c2c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01c33	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  01c39	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  01c3e	f7 f1		 div	 ecx
  01c40	89 84 24 d0 00
	00 00		 mov	 DWORD PTR xstincnum$[rsp], eax

; 2277 :                     (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);
; 2278 :         FETCH_FW( i, sccbxmap->incnum );

  01c47	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR sccbxmap$[rsp]
  01c4f	48 8b c8	 mov	 rcx, rax
  01c52	e8 00 00 00 00	 call	 fetch_fw_noswap
  01c57	8b c8		 mov	 ecx, eax
  01c59	e8 00 00 00 00	 call	 _byteswap_ulong
  01c5e	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2279 : 
; 2280 :         if (i < 1 || (U32)i > xstincnum)

  01c62	83 7c 24 50 01	 cmp	 DWORD PTR i$[rsp], 1
  01c67	7c 0d		 jl	 SHORT $LN145@s390_servi
  01c69	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR xstincnum$[rsp]
  01c70	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01c74	76 17		 jbe	 SHORT $LN144@s390_servi
$LN145@s390_servi:

; 2281 :         {
; 2282 :             sccb->reas = SCCB_REAS_INVALID_RSC;

  01c76	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c7b	c6 40 06 09	 mov	 BYTE PTR [rax+6], 9

; 2283 :             sccb->resp = SCCB_RESP_REJECT;

  01c7f	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01c84	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2284 :             break;

  01c88	e9 fb 01 00 00	 jmp	 $LN11@s390_servi
$LN144@s390_servi:

; 2285 :         }
; 2286 : 
; 2287 :         /* Point to bitmap */
; 2288 :         xstmap = (BYTE*)(sccbxmap+1);

  01c8d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR sccbxmap$[rsp]
  01c95	48 83 c0 08	 add	 rax, 8
  01c99	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR xstmap$[rsp], rax

; 2289 : 
; 2290 :         /* Set all blocks available */
; 2291 :         memset( xstmap, 0, xstblkinc/8);

  01ca1	33 d2		 xor	 edx, edx
  01ca3	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR xstblkinc$[rsp]
  01caa	b9 08 00 00 00	 mov	 ecx, 8
  01caf	f7 f1		 div	 ecx
  01cb1	8b c0		 mov	 eax, eax
  01cb3	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1149[rsp], rax
  01cbb	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR xstmap$[rsp]
  01cc3	33 c0		 xor	 eax, eax
  01cc5	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv1149[rsp]
  01ccd	f3 aa		 rep stosb

; 2292 : 
; 2293 :         /* Set response code X'0010' in SCCB header */
; 2294 :         sccb->reas = SCCB_REAS_NONE;

  01ccf	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01cd4	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2295 :         sccb->resp = SCCB_RESP_INFO;

  01cd8	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01cdd	c6 40 07 10	 mov	 BYTE PTR [rax+7], 16

; 2296 :         break;

  01ce1	e9 a2 01 00 00	 jmp	 $LN11@s390_servi
$LN146@s390_servi:

; 2297 : 
; 2298 : #endif /* defined( FEATURE_EXPANDED_STORAGE ) */
; 2299 : 
; 2300 : #if defined( FEATURE_CPU_RECONFIG )
; 2301 : 
; 2302 :     case SCLP_CONFIGURE_CPU:
; 2303 : 
; 2304 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;

  01ce6	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01ced	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01cf2	c1 e8 08	 shr	 eax, 8
  01cf5	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2305 : 
; 2306 :         /* Return invalid resource in parm if target does not exist */
; 2307 :         if (i >= sysblk.maxcpu)

  01cf9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d00	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01d06	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01d0a	7c 17		 jl	 SHORT $LN147@s390_servi

; 2308 :         {
; 2309 :             sccb->reas = SCCB_REAS_INVALID_RSCP;

  01d0c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d11	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2310 :             sccb->resp = SCCB_RESP_REJECT;

  01d15	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d1a	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2311 :             break;

  01d1e	e9 65 01 00 00	 jmp	 $LN11@s390_servi
$LN147@s390_servi:

; 2312 :         }
; 2313 : 
; 2314 :         /* Add cpu to the configuration */
; 2315 :         configure_cpu(i);

  01d23	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01d27	e8 00 00 00 00	 call	 configure_cpu

; 2316 : 
; 2317 :         /* Set response code X'0020' in SCCB header */
; 2318 :         sccb->reas = SCCB_REAS_NONE;

  01d2c	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d31	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2319 :         sccb->resp = SCCB_RESP_COMPLETE;

  01d35	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d3a	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2320 :         break;

  01d3e	e9 45 01 00 00	 jmp	 $LN11@s390_servi
$LN148@s390_servi:

; 2321 : 
; 2322 :     case SCLP_DECONFIGURE_CPU:
; 2323 : 
; 2324 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;

  01d43	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01d4a	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01d4f	c1 e8 08	 shr	 eax, 8
  01d52	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 2325 : 
; 2326 :         /* Return invalid resource in parm if target does not exist */
; 2327 :         if (i >= sysblk.maxcpu)

  01d56	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d5d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  01d63	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  01d67	7c 17		 jl	 SHORT $LN149@s390_servi

; 2328 :         {
; 2329 :             sccb->reas = SCCB_REAS_INVALID_RSCP;

  01d69	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d6e	c6 40 06 03	 mov	 BYTE PTR [rax+6], 3

; 2330 :             sccb->resp = SCCB_RESP_REJECT;

  01d72	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d77	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 2331 :             break;

  01d7b	e9 08 01 00 00	 jmp	 $LN11@s390_servi
$LN149@s390_servi:

; 2332 :         }
; 2333 : 
; 2334 :         /* Take cpu out of the configuration */
; 2335 :         deconfigure_cpu(i);

  01d80	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  01d84	e8 00 00 00 00	 call	 deconfigure_cpu

; 2336 : 
; 2337 :         /* Set response code X'0020' in SCCB header */
; 2338 :         sccb->reas = SCCB_REAS_NONE;

  01d89	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d8e	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 2339 :         sccb->resp = SCCB_RESP_COMPLETE;

  01d92	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01d97	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 2340 :         break;

  01d9b	e9 e8 00 00 00	 jmp	 $LN11@s390_servi
$LN150@s390_servi:
$invalidcmd$177:
$LN51@s390_servi:

; 2341 : 
; 2342 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 2343 : 
; 2344 :     case SCLP_DISCONNECT_VF:
; 2345 : 
; 2346 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;
; 2347 : 
; 2348 :         /* Return invalid resource in parm if target does not exist */
; 2349 :         if (i >= sysblk.maxcpu || !IS_CPU_ONLINE(i))
; 2350 :         {
; 2351 :             sccb->reas = SCCB_REAS_INVALID_RSCP;
; 2352 :             sccb->resp = SCCB_RESP_REJECT;
; 2353 :             break;
; 2354 :         }
; 2355 : 
; 2356 :         if (sysblk.regs[i]->vf->online)
; 2357 :             // "Processor %s%02X: vector facility configured %s"
; 2358 :             WRMSG( HHC00821, "I", PTYPSTR(i), i, "offline" );
; 2359 : 
; 2360 :         /* Take the VF out of the configuration */
; 2361 :         sysblk.regs[i]->vf->online = 0;
; 2362 : 
; 2363 :         /* Set response code X'0020' in SCCB header */
; 2364 :         sccb->reas = SCCB_REAS_NONE;
; 2365 :         sccb->resp = SCCB_RESP_COMPLETE;
; 2366 :         break;
; 2367 : 
; 2368 :     case SCLP_CONNECT_VF:
; 2369 : 
; 2370 :         i = (sclp_command & SCLP_RESOURCE_MASK) >> SCLP_RESOURCE_SHIFT;
; 2371 : 
; 2372 :         /* Return invalid resource in parm if target does not exist */
; 2373 :         if (i >= sysblk.maxcpu)
; 2374 :         {
; 2375 :             sccb->reas = SCCB_REAS_INVALID_RSCP;
; 2376 :             sccb->resp = SCCB_RESP_REJECT;
; 2377 :             break;
; 2378 :         }
; 2379 : 
; 2380 :         /* Return improper state if associated cpu is offline */
; 2381 :         if (!IS_CPU_ONLINE(i))
; 2382 :         {
; 2383 :             sccb->reas = SCCB_REAS_IMPROPER_RSC;
; 2384 :             sccb->resp = SCCB_RESP_REJECT;
; 2385 :             break;
; 2386 :         }
; 2387 : 
; 2388 :         if (!sysblk.regs[i]->vf->online)
; 2389 :             // "Processor %s%02X: vector facility configured %s"
; 2390 :             WRMSG( HHC00821, "I", PTYPSTR(i), i, "online" );
; 2391 : 
; 2392 :         /* Mark the VF online to the CPU */
; 2393 :         sysblk.regs[i]->vf->online = 1;
; 2394 : 
; 2395 :         /* Set response code X'0020' in SCCB header */
; 2396 :         sccb->reas = SCCB_REAS_NONE;
; 2397 :         sccb->resp = SCCB_RESP_COMPLETE;
; 2398 :         break;
; 2399 : 
; 2400 : #endif /* defined( FEATURE_S370_S390_VECTOR_FACILITY ) */
; 2401 : 
; 2402 : #endif /* defined( FEATURE_CPU_RECONFIG ) */
; 2403 : 
; 2404 :     default:
; 2405 :     invalidcmd:
; 2406 : 
; 2407 :         PTT( PTT_CL_INF | PTT_CL_ERR, "*SERVC", regs->GR_L(r1), regs->GR_L(r2), regs->psw.IA_L );

  01da0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01da7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01daa	48 83 e0 18	 and	 rax, 24
  01dae	48 85 c0	 test	 rax, rax
  01db1	74 6c		 je	 SHORT $LN151@s390_servi
  01db3	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01dbb	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  01dc1	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  01dc8	48 8b 94 24 e8
	11 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01dd0	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  01dd7	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  01dde	48 8b bc 24 e8
	11 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01de6	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  01ded	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01df6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01dfb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189848
  01e02	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e07	44 8b c9	 mov	 r9d, ecx
  01e0a	44 8b c2	 mov	 r8d, edx
  01e0d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189849
  01e14	b9 18 00 00 00	 mov	 ecx, 24
  01e19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN151@s390_servi:
  01e1f	33 c0		 xor	 eax, eax
  01e21	85 c0		 test	 eax, eax
  01e23	0f 85 77 ff ff
	ff		 jne	 $LN51@s390_servi

; 2408 : 
; 2409 :         if (HDC3( debug_sclp_unknown_command, sclp_command, sccb, regs ))

  01e29	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_command
  01e30	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01e34	74 27		 je	 SHORT $LN171@s390_servi
  01e36	4c 8b 84 24 e8
	11 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01e3e	48 8b 54 24 58	 mov	 rdx, QWORD PTR sccb$[rsp]
  01e43	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR sclp_command$[rsp]
  01e4a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_sclp_unknown_command
  01e51	ff 10		 call	 QWORD PTR [rax]
  01e53	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv1201[rsp], rax
  01e5b	eb 0c		 jmp	 SHORT $LN172@s390_servi
$LN171@s390_servi:
  01e5d	48 c7 84 24 70
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv1201[rsp], 0
$LN172@s390_servi:
  01e69	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR tv1201[rsp], 0
  01e72	74 02		 je	 SHORT $LN152@s390_servi

; 2410 :             break;

  01e74	eb 12		 jmp	 SHORT $LN11@s390_servi
$LN152@s390_servi:

; 2411 : 
; 2412 :         /* Set response code X'01F0' for invalid SCLP command */
; 2413 :         sccb->reas = SCCB_REAS_INVALID_CMD;

  01e76	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e7b	c6 40 06 01	 mov	 BYTE PTR [rax+6], 1

; 2414 :         sccb->resp = SCCB_RESP_REJECT;

  01e7f	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e84	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H
$LN11@s390_servi:

; 2415 :         break;
; 2416 : 
; 2417 :     } /* end switch (sclp_command) */
; 2418 : 
; 2419 :     /* If immediate response is requested, return condition code 1 */
; 2420 :     if ((sccb->flag & SCCB_FLAG_SYNC)
; 2421 :         && (sclp_command & SCLP_COMMAND_CLASS) != 0x01)

  01e88	48 8b 44 24 58	 mov	 rax, QWORD PTR sccb$[rsp]
  01e8d	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01e91	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01e96	85 c0		 test	 eax, eax
  01e98	74 22		 je	 SHORT $LN153@s390_servi
  01e9a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR sclp_command$[rsp]
  01ea1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01ea6	83 f8 01	 cmp	 eax, 1
  01ea9	74 11		 je	 SHORT $LN153@s390_servi

; 2422 :     {
; 2423 :         regs->psw.cc = 1;

  01eab	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01eb3	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2424 :         return;

  01eb7	e9 bf 01 00 00	 jmp	 $LN1@s390_servi
$LN153@s390_servi:

; 2425 :     }
; 2426 : 
; 2427 :     /* Set service signal external interrupt pending */
; 2428 :     sysblk.servparm &= ~SERVSIG_ADDR;

  01ebc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01ec3	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01ec9	83 e0 07	 and	 eax, 7
  01ecc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01ed3	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax

; 2429 :     sysblk.servparm |= sccb_absolute_addr;

  01ed9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01ee0	8b 4c 24 64	 mov	 ecx, DWORD PTR sccb_absolute_addr$[rsp]
  01ee4	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  01eea	0b c1		 or	 eax, ecx
  01eec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01ef3	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax
$LN54@s390_servi:

; 2430 :     ON_IC_SERVSIG;

  01ef9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f00	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01f06	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01f0b	85 c0		 test	 eax, eax
  01f0d	0f 85 23 01 00
	00		 jne	 $LN154@s390_servi
  01f13	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f1a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  01f20	0f ba e8 09	 bts	 eax, 9
  01f24	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01f2b	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  01f31	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01f38	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  01f3f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR mask$5[rsp], rax
  01f47	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  01f52	eb 10		 jmp	 SHORT $LN57@s390_servi
$LN55@s390_servi:
  01f54	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  01f5b	ff c0		 inc	 eax
  01f5d	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN57@s390_servi:
  01f64	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR mask$5[rsp], 0
  01f6d	0f 84 c3 00 00
	00		 je	 $LN56@s390_servi
  01f73	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR mask$5[rsp]
  01f7b	48 83 e0 01	 and	 rax, 1
  01f7f	48 85 c0	 test	 rax, rax
  01f82	0f 84 96 00 00
	00		 je	 $LN155@s390_servi
  01f88	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01f90	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01f97	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01f9f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01fa2	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01fa7	85 c0		 test	 eax, eax
  01fa9	74 3b		 je	 SHORT $LN156@s390_servi
  01fab	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01fb3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01fba	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01fc2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01fc5	0d 00 02 00 80	 or	 eax, -2147483136	; 80000200H
  01fca	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01fd2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01fd9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  01fe1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01fe4	eb 38		 jmp	 SHORT $LN157@s390_servi
$LN156@s390_servi:
  01fe6	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01fee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01ff5	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01ffd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02000	0f ba e8 09	 bts	 eax, 9
  02004	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0200c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  02013	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0201b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN157@s390_servi:
$LN155@s390_servi:
  0201e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR mask$5[rsp]
  02026	48 d1 e8	 shr	 rax, 1
  02029	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR mask$5[rsp], rax
  02031	e9 1e ff ff ff	 jmp	 $LN55@s390_servi
$LN56@s390_servi:
$LN154@s390_servi:
  02036	33 c0		 xor	 eax, eax
  02038	85 c0		 test	 eax, eax
  0203a	0f 85 b9 fe ff
	ff		 jne	 $LN54@s390_servi

; 2431 : 
; 2432 :     /* Release the interrupt lock */
; 2433 :     RELEASE_INTLOCK( regs );

  02040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189856
  02047	48 8b 8c 24 e8
	11 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0204f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2434 : 
; 2435 :     /* Set condition code 0 */
; 2436 :     regs->psw.cc = 0;

  02054	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0205c	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2437 : 
; 2438 :     RETURN_INTCHECK( regs );

  02060	48 8b 84 24 e8
	11 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02068	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0206e	ba ff ff ff ff	 mov	 edx, -1
  02073	48 8b c8	 mov	 rcx, rax
  02076	e8 00 00 00 00	 call	 longjmp
$LN1@s390_servi:
$LN158@s390_servi:

; 2439 : } /* end function service_call */

  0207b	48 8b 8c 24 b0
	11 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02083	48 33 cc	 xor	 rcx, rsp
  02086	e8 00 00 00 00	 call	 __security_check_cookie
  0208b	48 81 c4 c8 11
	00 00		 add	 rsp, 4552		; 000011c8H
  02092	5f		 pop	 rdi
  02093	5e		 pop	 rsi
  02094	c3		 ret	 0
  02095	0f 1f 00	 npad	 3
$LN175@s390_servi:
  02098	00 00 00 00	 DD	 $LN99@s390_servi
  0209c	00 00 00 00	 DD	 $LN111@s390_servi
  020a0	00 00 00 00	 DD	 $LN100@s390_servi
  020a4	00 00 00 00	 DD	 $LN110@s390_servi
  020a8	00 00 00 00	 DD	 $LN112@s390_servi
  020ac	00 00 00 00	 DD	 $LN114@s390_servi
  020b0	00 00 00 00	 DD	 $LN113@s390_servi
  020b4	00 00 00 00	 DD	 $LN115@s390_servi
$LN174@s390_servi:
  020b8	00		 DB	 0
  020b9	07		 DB	 7
  020ba	07		 DB	 7
  020bb	07		 DB	 7
  020bc	07		 DB	 7
  020bd	01		 DB	 1
  020be	07		 DB	 7
  020bf	02		 DB	 2
  020c0	07		 DB	 7
  020c1	03		 DB	 3
  020c2	04		 DB	 4
  020c3	07		 DB	 7
  020c4	07		 DB	 7
  020c5	07		 DB	 7
  020c6	07		 DB	 7
  020c7	07		 DB	 7
  020c8	07		 DB	 7
  020c9	07		 DB	 7
  020ca	07		 DB	 7
  020cb	07		 DB	 7
  020cc	07		 DB	 7
  020cd	07		 DB	 7
  020ce	07		 DB	 7
  020cf	07		 DB	 7
  020d0	07		 DB	 7
  020d1	05		 DB	 5
  020d2	06		 DB	 6
s390_service_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
more$ = 96
unitstat$ = 97
sysg_len$ = 100
evd_len$ = 104
sccblen$ = 108
residual$ = 112
sysg_data$ = 120
evd_hdr$ = 128
dev$ = 136
sysg_cmd$ = 144
tv204 = 152
sccb$ = 176
sclp_sysg_poll PROC

; 857  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 858  : SCCB_EVD_HDR*  evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  0000d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00015	48 83 c0 08	 add	 rax, 8
  00019	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 859  : U16            sccblen;                 /* SCCB total length         */
; 860  : U16            evd_len;                 /* SCCB event data length    */
; 861  : U16            sysg_len;                /* SYSG input data length    */
; 862  : DEVBLK*        dev;                     /* -> SYSG console devblk    */
; 863  : BYTE*          sysg_data;               /* -> SYSG input data        */
; 864  : BYTE*          sysg_cmd;                /* -> SYSG input data        */
; 865  : BYTE           unitstat;                /* Unit status               */
; 866  : BYTE           more = 0;                /* Flag for device handler   */

  00021	c6 44 24 60 00	 mov	 BYTE PTR more$[rsp], 0

; 867  : U32            residual;                /* Residual data count       */
; 868  : 
; 869  :     dev = sysblk.sysgdev;

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002d	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00034	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 870  :     if (dev != NULL)

  0003c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00045	0f 84 f9 02 00
	00		 je	 $LN8@sclp_sysg_

; 871  :     {
; 872  :         /* Zeroize the event data header */
; 873  :         memset( evd_hdr, 0, sizeof( SCCB_EVD_HDR ));

  0004b	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00053	33 c0		 xor	 eax, eax
  00055	b9 06 00 00 00	 mov	 ecx, 6
  0005a	f3 aa		 rep stosb

; 874  : 
; 875  :         /* Calculate maximum data length */
; 876  :         FETCH_HW( sccblen, sccb->length );

  0005c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 fetch_hw_noswap
  0006c	0f b7 c8	 movzx	 ecx, ax
  0006f	e8 00 00 00 00	 call	 _byteswap_ushort
  00074	66 89 44 24 6c	 mov	 WORD PTR sccblen$[rsp], ax

; 877  :         evd_len = sccblen - sizeof( SCCB_HEADER );

  00079	0f b7 44 24 6c	 movzx	 eax, WORD PTR sccblen$[rsp]
  0007e	48 83 e8 08	 sub	 rax, 8
  00082	66 89 44 24 68	 mov	 WORD PTR evd_len$[rsp], ax

; 878  :         sysg_data = (BYTE*)(evd_hdr+1);

  00087	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0008f	48 83 c0 06	 add	 rax, 6
  00093	48 89 44 24 78	 mov	 QWORD PTR sysg_data$[rsp], rax

; 879  :         sysg_len = evd_len - sizeof( SCCB_EVD_HDR );

  00098	0f b7 44 24 68	 movzx	 eax, WORD PTR evd_len$[rsp]
  0009d	48 83 e8 06	 sub	 rax, 6
  000a1	66 89 44 24 64	 mov	 WORD PTR sysg_len$[rsp], ax

; 880  : 
; 881  :         /* Insert flag byte before the 3270 input data */
; 882  :         sysg_cmd  = sysg_data;

  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR sysg_data$[rsp]
  000ab	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sysg_cmd$[rsp], rax

; 883  :         sysg_len  -= 1;

  000b3	0f b7 44 24 64	 movzx	 eax, WORD PTR sysg_len$[rsp]
  000b8	ff c8		 dec	 eax
  000ba	66 89 44 24 64	 mov	 WORD PTR sysg_len$[rsp], ax

; 884  :         sysg_data += 1;

  000bf	48 8b 44 24 78	 mov	 rax, QWORD PTR sysg_data$[rsp]
  000c4	48 ff c0	 inc	 rax
  000c7	48 89 44 24 78	 mov	 QWORD PTR sysg_data$[rsp], rax

; 885  : 
; 886  :         /* Execute previously saved 3270 read command */
; 887  :         if (servc_sysg_cmdcode)

  000cc	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR servc_sysg_cmdcode
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 be 01 00
	00		 je	 $LN9@sclp_sysg_

; 888  :         {
; 889  :             *sysg_cmd = 0x00;

  000db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sysg_cmd$[rsp]
  000e3	c6 00 00	 mov	 BYTE PTR [rax], 0

; 890  : 
; 891  :             /* Execute a 3270 read-modified command */
; 892  :             /* dev->hnd->exec points to loc3270_execute_ccw */
; 893  :             (dev->hnd->exec) (dev, /*ccw opcode*/ servc_sysg_cmdcode,

  000e6	0f b7 44 24 64	 movzx	 eax, WORD PTR sysg_len$[rsp]
  000eb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f3	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  000fa	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv204[rsp], rcx
  00102	48 8d 54 24 70	 lea	 rdx, QWORD PTR residual$[rsp]
  00107	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  0010c	48 8d 54 24 61	 lea	 rdx, QWORD PTR unitstat$[rsp]
  00111	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  00116	48 8d 54 24 60	 lea	 rdx, QWORD PTR more$[rsp]
  0011b	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  00120	48 8b 54 24 78	 mov	 rdx, QWORD PTR sysg_data$[rsp]
  00125	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  0012a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00132	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00137	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0013b	45 33 c9	 xor	 r9d, r9d
  0013e	41 b0 20	 mov	 r8b, 32			; 00000020H
  00141	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR servc_sysg_cmdcode
  00148	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv204[rsp]
  00158	ff 50 08	 call	 QWORD PTR [rax+8]

; 894  :                 /*flags*/ CCW_FLAGS_SLI, /*chained*/0,
; 895  :                 /*count*/ sysg_len,
; 896  :                 /*prevcode*/ 0, /*ccwseq*/ 0, /*iobuf*/ sysg_data,
; 897  :                 &more, &unitstat, &residual );
; 898  : 
; 899  :             servc_sysg_cmdcode = 0;

  0015b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR servc_sysg_cmdcode, 0

; 900  : 
; 901  :             /* Set response code X'0040' if unit check occurred */
; 902  :             if (unitstat & CSW_UC)

  00162	0f b6 44 24 61	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00167	83 e0 02	 and	 eax, 2
  0016a	85 c0		 test	 eax, eax
  0016c	74 76		 je	 SHORT $LN11@sclp_sysg_
$LN4@sclp_sysg_:

; 903  :             {
; 904  :                 PTT_ERR("*SERVC", (U32)more, (U32)unitstat, residual );

  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00175	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00178	48 83 e0 10	 and	 rax, 16
  0017c	48 85 c0	 test	 rax, rax
  0017f	74 40		 je	 SHORT $LN12@sclp_sysg_
  00181	8b 44 24 70	 mov	 eax, DWORD PTR residual$[rsp]
  00185	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  0018a	0f b6 54 24 60	 movzx	 edx, BYTE PTR more$[rsp]
  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00198	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179299
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	44 8b c9	 mov	 r9d, ecx
  001ac	44 8b c2	 mov	 r8d, edx
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179300
  001b6	b9 10 00 00 00	 mov	 ecx, 16
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN12@sclp_sysg_:
  001c1	33 c0		 xor	 eax, eax
  001c3	85 c0		 test	 eax, eax
  001c5	75 a7		 jne	 SHORT $LN4@sclp_sysg_

; 905  : 
; 906  :                 /* Set response code X'0040' in SCCB header */
; 907  :                 sccb->reas = SCCB_REAS_NONE;

  001c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  001cf	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 908  :                 sccb->resp = SCCB_RESP_BACKOUT;

  001d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  001db	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 909  :                 return;

  001df	e9 60 01 00 00	 jmp	 $LN1@sclp_sysg_
$LN11@sclp_sysg_:

; 910  :             }
; 911  : 
; 912  :             /* Set response code X'75F0' if SCCB length exceeded */
; 913  :             if (more)

  001e4	0f b6 44 24 60	 movzx	 eax, BYTE PTR more$[rsp]
  001e9	85 c0		 test	 eax, eax
  001eb	74 76		 je	 SHORT $LN13@sclp_sysg_
$LN7@sclp_sysg_:

; 914  :             {
; 915  :                 PTT_ERR("*SERVC", (U32)more, (U32)unitstat, residual );

  001ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f7	48 83 e0 10	 and	 rax, 16
  001fb	48 85 c0	 test	 rax, rax
  001fe	74 40		 je	 SHORT $LN14@sclp_sysg_
  00200	8b 44 24 70	 mov	 eax, DWORD PTR residual$[rsp]
  00204	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00209	0f b6 54 24 60	 movzx	 edx, BYTE PTR more$[rsp]
  0020e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00217	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179303
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	44 8b c9	 mov	 r9d, ecx
  0022b	44 8b c2	 mov	 r8d, edx
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179304
  00235	b9 10 00 00 00	 mov	 ecx, 16
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@sclp_sysg_:
  00240	33 c0		 xor	 eax, eax
  00242	85 c0		 test	 eax, eax
  00244	75 a7		 jne	 SHORT $LN7@sclp_sysg_

; 916  : 
; 917  :                 sccb->reas = SCCB_REAS_EXCEEDS_SCCB;

  00246	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0024e	c6 40 06 75	 mov	 BYTE PTR [rax+6], 117	; 00000075H

; 918  :                 sccb->resp = SCCB_RESP_EXCEEDS_SCCB;

  00252	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0025a	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 919  :                 return;

  0025e	e9 e1 00 00 00	 jmp	 $LN1@sclp_sysg_
$LN13@sclp_sysg_:

; 920  :             }
; 921  : 
; 922  :             /* Calculate actual length read */
; 923  :             sysg_len -= residual;

  00263	0f b7 44 24 64	 movzx	 eax, WORD PTR sysg_len$[rsp]
  00268	2b 44 24 70	 sub	 eax, DWORD PTR residual$[rsp]
  0026c	66 89 44 24 64	 mov	 WORD PTR sysg_len$[rsp], ax

; 924  :             evd_len = sizeof( SCCB_EVD_HDR ) + sysg_len + 1;

  00271	0f b7 44 24 64	 movzx	 eax, WORD PTR sysg_len$[rsp]
  00276	48 83 c0 07	 add	 rax, 7
  0027a	66 89 44 24 68	 mov	 WORD PTR evd_len$[rsp], ax

; 925  : 
; 926  :             /* Set response code X'0020' in SCCB header */
; 927  :             sccb->reas = SCCB_REAS_NONE;

  0027f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00287	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 928  :             sccb->resp = SCCB_RESP_COMPLETE;

  0028b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00293	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 929  :         }

  00297	eb 2d		 jmp	 SHORT $LN10@sclp_sysg_
$LN9@sclp_sysg_:

; 930  :         else
; 931  :         {
; 932  :             evd_len = sizeof( SCCB_EVD_HDR ) + 1;

  00299	b8 07 00 00 00	 mov	 eax, 7
  0029e	66 89 44 24 68	 mov	 WORD PTR evd_len$[rsp], ax

; 933  :             *sysg_cmd = 0x80;

  002a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sysg_cmd$[rsp]
  002ab	c6 00 80	 mov	 BYTE PTR [rax], 128	; 00000080H

; 934  : 
; 935  :             /* Set response code X'0020' in SCCB header */
; 936  :             sccb->reas = SCCB_REAS_NONE;

  002ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  002b6	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 937  :             sccb->resp = SCCB_RESP_COMPLETE;

  002ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  002c2	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN10@sclp_sysg_:

; 938  :         }
; 939  : 
; 940  :         /* Update SCCB length field if variable request */
; 941  :         if (sccb->type & SCCB_TYPE_VARIABLE)

  002c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  002ce	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 43		 je	 SHORT $LN15@sclp_sysg_

; 942  :         {
; 943  :             /* Set new SCCB length */
; 944  :             sccblen = evd_len + sizeof( SCCB_HEADER );

  002db	0f b7 44 24 68	 movzx	 eax, WORD PTR evd_len$[rsp]
  002e0	48 83 c0 08	 add	 rax, 8
  002e4	66 89 44 24 6c	 mov	 WORD PTR sccblen$[rsp], ax

; 945  :             STORE_HW( sccb->length, sccblen );

  002e9	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR sccblen$[rsp]
  002ee	e8 00 00 00 00	 call	 _byteswap_ushort
  002f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sccb$[rsp]
  002fb	0f b7 d0	 movzx	 edx, ax
  002fe	e8 00 00 00 00	 call	 store_hw_noswap

; 946  :             sccb->type &= ~SCCB_TYPE_VARIABLE;

  00303	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0030b	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0030f	0f ba f0 07	 btr	 eax, 7
  00313	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sccb$[rsp]
  0031b	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN15@sclp_sysg_:

; 947  :         }
; 948  : 
; 949  :         /* Set length in event header */
; 950  :         STORE_HW( evd_hdr->totlen, evd_len );

  0031e	0f b7 4c 24 68	 movzx	 ecx, WORD PTR evd_len$[rsp]
  00323	e8 00 00 00 00	 call	 _byteswap_ushort
  00328	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00330	0f b7 d0	 movzx	 edx, ax
  00333	e8 00 00 00 00	 call	 store_hw_noswap

; 951  : 
; 952  :         /* Set type in event header */
; 953  :         evd_hdr->type = SCCB_EVD_TYPE_SYSG;

  00338	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00340	c6 40 02 1b	 mov	 BYTE PTR [rax+2], 27
$LN8@sclp_sysg_:
$LN1@sclp_sysg_:

; 954  :     }
; 955  : }

  00344	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0034b	5f		 pop	 rdi
  0034c	c3		 ret	 0
sclp_sysg_poll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
cmdcode$ = 96
unitstat$ = 97
more$ = 98
sysg_len$ = 100
evd_len$ = 104
evd_hdr$ = 112
residual$ = 120
dev$ = 128
sysg_data$ = 136
tv174 = 144
sccb$ = 176
sclp_sysg_write PROC

; 763  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 764  : SCCB_EVD_HDR* evd_hdr = (SCCB_EVD_HDR*)(sccb+1);

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00014	48 83 c0 08	 add	 rax, 8
  00018	48 89 44 24 70	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 765  : U16           evd_len;                  /* SCCB event data length    */
; 766  : U16           sysg_len;                 /* SYSG output data length   */
; 767  : DEVBLK*       dev;                      /* -> SYSG console devblk    */
; 768  : BYTE*         sysg_data;                /* -> SYSG output data       */
; 769  : BYTE          unitstat;                 /* Unit status               */
; 770  : BYTE          more = 0;                 /* Flag for device handler   */

  0001d	c6 44 24 62 00	 mov	 BYTE PTR more$[rsp], 0

; 771  : U32           residual;                 /* Residual data count       */
; 772  : BYTE         cmdcode;                   /* 3270 read/write command   */
; 773  : 
; 774  :     /* Calculate the address and length of the 3270 datastream */
; 775  :     FETCH_HW( evd_len, evd_hdr->totlen );

  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002f	0f b7 c8	 movzx	 ecx, ax
  00032	e8 00 00 00 00	 call	 _byteswap_ushort
  00037	66 89 44 24 68	 mov	 WORD PTR evd_len$[rsp], ax

; 776  :     sysg_data = (BYTE*)(evd_hdr+1);

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00041	48 83 c0 06	 add	 rax, 6
  00045	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sysg_data$[rsp], rax

; 777  :     sysg_len  = evd_len - sizeof( SCCB_EVD_HDR );

  0004d	0f b7 44 24 68	 movzx	 eax, WORD PTR evd_len$[rsp]
  00052	48 83 e8 06	 sub	 rax, 6
  00056	66 89 44 24 64	 mov	 WORD PTR sysg_len$[rsp], ax

; 778  : 
; 779  :     /* The first data byte is the 3270 command code */
; 780  :     cmdcode = *sysg_data;

  0005b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sysg_data$[rsp]
  00063	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00066	88 44 24 60	 mov	 BYTE PTR cmdcode$[rsp], al

; 781  : 
; 782  :     /* Look for the SYSG console device block */
; 783  :     dev = sysblk.sysgdev;

  0006a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00071	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00078	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 784  :     if (dev == NULL)

  00080	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00089	75 76		 jne	 SHORT $LN8@sclp_sysg_
$LN4@sclp_sysg_:

; 785  :     {
; 786  :         PTT_ERR("*SERVC", (U32)cmdcode, (U32)sysg_len, 0 );

  0008b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00092	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00095	48 83 e0 10	 and	 rax, 16
  00099	48 85 c0	 test	 rax, rax
  0009c	74 40		 je	 SHORT $LN9@sclp_sysg_
  0009e	0f b7 44 24 64	 movzx	 eax, WORD PTR sysg_len$[rsp]
  000a3	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR cmdcode$[rsp]
  000a8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179241
  000c1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000c6	44 8b c8	 mov	 r9d, eax
  000c9	44 8b c1	 mov	 r8d, ecx
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179242
  000d3	b9 10 00 00 00	 mov	 ecx, 16
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@sclp_sysg_:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 a7		 jne	 SHORT $LN4@sclp_sysg_

; 787  : 
; 788  :         /* Set response code X'05F0' in SCCB header */
; 789  :         sccb->reas = SCCB_REAS_IMPROPER_RSC;

  000e4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  000ec	c6 40 06 05	 mov	 BYTE PTR [rax+6], 5

; 790  :         sccb->resp = SCCB_RESP_REJECT;

  000f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  000f8	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 791  :         return;

  000fc	e9 86 01 00 00	 jmp	 $LN1@sclp_sysg_
$LN8@sclp_sysg_:

; 792  :     }
; 793  : 
; 794  :     /* If it is a read CCW then save the command until READ_EVENT_DATA */
; 795  :     if (IS_CCW_READ( cmdcode ))

  00101	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmdcode$[rsp]
  00106	83 e0 03	 and	 eax, 3
  00109	83 f8 02	 cmp	 eax, 2
  0010c	75 4b		 jne	 SHORT $LN10@sclp_sysg_

; 796  :     {
; 797  : 
; 798  :         servc_sysg_cmdcode = cmdcode;

  0010e	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmdcode$[rsp]
  00113	88 05 00 00 00
	00		 mov	 BYTE PTR servc_sysg_cmdcode, al

; 799  : 
; 800  :         /* Indicate Event Processed */
; 801  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00119	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0011e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00122	0f ba e8 07	 bts	 eax, 7
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  0012b	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 802  : 
; 803  :         /* Generate a service call interrupt to trigger READ_EVENT_DATA */
; 804  :         sclp_attn_async( SCCB_EVD_TYPE_SYSG );

  0012e	66 b9 1b 00	 mov	 cx, 27
  00132	e8 00 00 00 00	 call	 sclp_attn_async

; 805  : 
; 806  :         /* Set response code X'0020' in SCCB header */
; 807  :         sccb->reas = SCCB_REAS_NONE;

  00137	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0013f	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 808  :         sccb->resp = SCCB_RESP_COMPLETE;

  00143	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0014b	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 809  :         return;

  0014f	e9 33 01 00 00	 jmp	 $LN1@sclp_sysg_

; 810  :     }

  00154	e9 2e 01 00 00	 jmp	 $LN11@sclp_sysg_
$LN10@sclp_sysg_:

; 811  :     else
; 812  :     {
; 813  :         servc_sysg_cmdcode = 0x00;

  00159	c6 05 00 00 00
	00 00		 mov	 BYTE PTR servc_sysg_cmdcode, 0

; 814  : 
; 815  :         /* Execute the 3270 command in data block */
; 816  :         /* dev->hnd->exec points to loc3270_execute_ccw */
; 817  :         (dev->hnd->exec)( dev, /*ccw opcode*/ cmdcode,

  00160	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sysg_data$[rsp]
  00168	48 ff c0	 inc	 rax
  0016b	0f b7 4c 24 64	 movzx	 ecx, WORD PTR sysg_len$[rsp]
  00170	ff c9		 dec	 ecx
  00172	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0017a	48 8b 92 90 02
	00 00		 mov	 rdx, QWORD PTR [rdx+656]
  00181	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv174[rsp], rdx
  00189	4c 8d 44 24 78	 lea	 r8, QWORD PTR residual$[rsp]
  0018e	4c 89 44 24 50	 mov	 QWORD PTR [rsp+80], r8
  00193	4c 8d 44 24 61	 lea	 r8, QWORD PTR unitstat$[rsp]
  00198	4c 89 44 24 48	 mov	 QWORD PTR [rsp+72], r8
  0019d	4c 8d 44 24 62	 lea	 r8, QWORD PTR more$[rsp]
  001a2	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  001a7	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001ac	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  001b4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001b9	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001bd	45 33 c9	 xor	 r9d, r9d
  001c0	41 b0 20	 mov	 r8b, 32			; 00000020H
  001c3	0f b6 54 24 60	 movzx	 edx, BYTE PTR cmdcode$[rsp]
  001c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv174[rsp]
  001d8	ff 50 08	 call	 QWORD PTR [rax+8]

; 818  :             /*flags*/ CCW_FLAGS_SLI, /*chained*/0,
; 819  :             /*count*/ sysg_len - 1,
; 820  :             /*prevcode*/ 0, /*ccwseq*/ 0, /*iobuf*/ sysg_data+1,
; 821  :             &more, &unitstat, &residual );
; 822  : 
; 823  :         /* Indicate Event Processed */
; 824  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  001db	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  001e0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e4	0f ba e8 07	 bts	 eax, 7
  001e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  001ed	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 825  : 
; 826  :         /* If unit check occured, set response code X'0040' */
; 827  :         if (unitstat & CSW_UC)

  001f0	0f b6 44 24 61	 movzx	 eax, BYTE PTR unitstat$[rsp]
  001f5	83 e0 02	 and	 eax, 2
  001f8	85 c0		 test	 eax, eax
  001fa	74 73		 je	 SHORT $LN12@sclp_sysg_
$LN7@sclp_sysg_:

; 828  :         {
; 829  :             PTT_ERR("*SERVC", (U32)more, (U32)unitstat, residual );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 83 e0 10	 and	 rax, 16
  0020a	48 85 c0	 test	 rax, rax
  0020d	74 40		 je	 SHORT $LN13@sclp_sysg_
  0020f	8b 44 24 78	 mov	 eax, DWORD PTR residual$[rsp]
  00213	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00218	0f b6 54 24 62	 movzx	 edx, BYTE PTR more$[rsp]
  0021d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00226	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179247
  00232	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00237	44 8b c9	 mov	 r9d, ecx
  0023a	44 8b c2	 mov	 r8d, edx
  0023d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179248
  00244	b9 10 00 00 00	 mov	 ecx, 16
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN13@sclp_sysg_:
  0024f	33 c0		 xor	 eax, eax
  00251	85 c0		 test	 eax, eax
  00253	75 a7		 jne	 SHORT $LN7@sclp_sysg_

; 830  : 
; 831  :             /* Set response code X'0040' in SCCB header */
; 832  :             sccb->reas = SCCB_REAS_NONE;

  00255	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0025d	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 833  :             sccb->resp = SCCB_RESP_BACKOUT;

  00261	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00269	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 834  :             return;

  0026d	eb 18		 jmp	 SHORT $LN1@sclp_sysg_
$LN12@sclp_sysg_:

; 835  :         }
; 836  : 
; 837  :         /* Set response code X'0020' in SCCB header */
; 838  :         sccb->reas = SCCB_REAS_NONE;

  0026f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00277	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 839  :         sccb->resp = SCCB_RESP_COMPLETE;

  0027b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00283	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN11@sclp_sysg_:
$LN1@sclp_sysg_:

; 840  :     }
; 841  : }

  00287	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0028e	c3		 ret	 0
sclp_sysg_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
evd_hdr$ = 40
sgq_bk$ = 48
tv79 = 56
sccb$ = 80
sclp_sigq_event PROC

; 702  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 703  : U16           sccb_len;
; 704  : U16           evd_len;
; 705  : SCCB_EVD_HDR* evd_hdr = (SCCB_EVD_HDR*)( sccb    + 1 );

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  0000f	48 83 c0 08	 add	 rax, 8
  00013	48 89 44 24 28	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 706  : SCCB_SGQ_BK*  sgq_bk  = (SCCB_SGQ_BK*) ( evd_hdr + 1 );

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0001d	48 83 c0 06	 add	 rax, 6
  00021	48 89 44 24 30	 mov	 QWORD PTR sgq_bk$[rsp], rax

; 707  : 
; 708  :     FETCH_HW( sccb_len, sccb->length );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00033	0f b7 c8	 movzx	 ecx, ax
  00036	e8 00 00 00 00	 call	 _byteswap_ushort
  0003b	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 709  :     evd_len = sizeof( SCCB_EVD_HDR ) + sizeof( SCCB_SGQ_BK );

  00040	b8 09 00 00 00	 mov	 eax, 9
  00045	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 710  : 
; 711  :     /* Set response code X'75F0' if SCCB length exceeded */
; 712  :     if ((evd_len + sizeof( SCCB_HEADER )) > sccb_len)

  0004a	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  0004f	48 83 c0 08	 add	 rax, 8
  00053	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  00058	48 3b c1	 cmp	 rax, rcx
  0005b	76 17		 jbe	 SHORT $LN2@sclp_sigq_

; 713  :     {
; 714  :         sccb->reas = SCCB_REAS_EXCEEDS_SCCB;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  00062	c6 40 06 75	 mov	 BYTE PTR [rax+6], 117	; 00000075H

; 715  :         sccb->resp = SCCB_RESP_EXCEEDS_SCCB;

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  0006b	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 716  :         return;

  0006f	e9 be 00 00 00	 jmp	 $LN1@sclp_sigq_
$LN2@sclp_sigq_:

; 717  :     }
; 718  : 
; 719  :     /* Zero all fields */
; 720  :     memset( evd_hdr, 0, evd_len );

  00074	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  00079	48 89 44 24 38	 mov	 QWORD PTR tv79[rsp], rax
  0007e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00083	33 c0		 xor	 eax, eax
  00085	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv79[rsp]
  0008a	f3 aa		 rep stosb

; 721  : 
; 722  :     /* Update SCCB length field if variable request */
; 723  :     if (sccb->type & SCCB_TYPE_VARIABLE)

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  00091	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00095	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0009a	85 c0		 test	 eax, eax
  0009c	74 3a		 je	 SHORT $LN3@sclp_sigq_

; 724  :     {
; 725  :         /* Set new SCCB length */
; 726  :         sccb_len = evd_len + sizeof( SCCB_HEADER );

  0009e	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  000a3	48 83 c0 08	 add	 rax, 8
  000a7	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 727  :         STORE_HW( sccb->length, sccb_len );

  000ac	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  000b1	e8 00 00 00 00	 call	 _byteswap_ushort
  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sccb$[rsp]
  000bb	0f b7 d0	 movzx	 edx, ax
  000be	e8 00 00 00 00	 call	 store_hw_noswap

; 728  :         sccb->type &= ~SCCB_TYPE_VARIABLE;

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  000c8	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000cc	0f ba f0 07	 btr	 eax, 7
  000d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sccb$[rsp]
  000d5	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN3@sclp_sigq_:

; 729  :     }
; 730  : 
; 731  :     /* Set length in event header */
; 732  :     STORE_HW( evd_hdr->totlen, evd_len );

  000d8	0f b7 4c 24 20	 movzx	 ecx, WORD PTR evd_len$[rsp]
  000dd	e8 00 00 00 00	 call	 _byteswap_ushort
  000e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  000e7	0f b7 d0	 movzx	 edx, ax
  000ea	e8 00 00 00 00	 call	 store_hw_noswap

; 733  : 
; 734  :     /* Set type in event header */
; 735  :     evd_hdr->type = SCCB_EVD_TYPE_SIGQ;

  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  000f4	c6 40 02 1d	 mov	 BYTE PTR [rax+2], 29

; 736  : 
; 737  :     STORE_HW( sgq_bk->count, servc_signal_quiesce_count );

  000f8	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR servc_signal_quiesce_count
  000ff	e8 00 00 00 00	 call	 _byteswap_ushort
  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sgq_bk$[rsp]
  00109	0f b7 d0	 movzx	 edx, ax
  0010c	e8 00 00 00 00	 call	 store_hw_noswap

; 738  :     sgq_bk->unit = servc_signal_quiesce_unit;

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR sgq_bk$[rsp]
  00116	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR servc_signal_quiesce_unit
  0011d	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 739  : 
; 740  :     /* Set response code X'0020' in SCCB header */
; 741  :     sccb->reas = SCCB_REAS_NONE;

  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  00125	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 742  :     sccb->resp = SCCB_RESP_COMPLETE;

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR sccb$[rsp]
  0012e	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN1@sclp_sigq_:

; 743  : }

  00132	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00136	5f		 pop	 rdi
  00137	c3		 ret	 0
sclp_sigq_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
i$ = 96
cpi_bk$ = 104
evd_hdr$ = 112
$T1 = 120
$T2 = 128
$T3 = 136
$T4 = 144
syslevel$ = 152
systype$ = 160
sysname$ = 176
sysplex$ = 192
buf$5 = 208
__$ArrayPad$ = 336
sccb$ = 368
sclp_cpident PROC

; 578  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 579  :     SCCB_EVD_HDR*  evd_hdr = (SCCB_EVD_HDR*) (sccb    + 1);

  0001e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00026	48 83 c0 08	 add	 rax, 8
  0002a	48 89 44 24 70	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 580  :     SCCB_CPI_BK*   cpi_bk  = (SCCB_CPI_BK*)  (evd_hdr + 1);

  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00034	48 83 c0 06	 add	 rax, 6
  00038	48 89 44 24 68	 mov	 QWORD PTR cpi_bk$[rsp], rax

; 581  : 
; 582  :     char systype[9], sysname[9], sysplex[9];
; 583  :     U64  syslevel;
; 584  :     int i;
; 585  : 
; 586  :     if (*(cpi_bk->system_type )) set_systype( cpi_bk->system_type  );

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  0004b	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00050	85 c0		 test	 eax, eax
  00052	74 11		 je	 SHORT $LN14@sclp_cpide
  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR cpi_bk$[rsp]
  00059	48 83 c0 02	 add	 rax, 2
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 set_systype
$LN14@sclp_cpide:

; 587  :     if (*(cpi_bk->system_name )) set_sysname( cpi_bk->system_name  );

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  00073	0f b6 44 01 12	 movzx	 eax, BYTE PTR [rcx+rax+18]
  00078	85 c0		 test	 eax, eax
  0007a	74 11		 je	 SHORT $LN15@sclp_cpide
  0007c	48 8b 44 24 68	 mov	 rax, QWORD PTR cpi_bk$[rsp]
  00081	48 83 c0 12	 add	 rax, 18
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 set_sysname
$LN15@sclp_cpide:

; 588  :     if (*(cpi_bk->sysplex_name)) set_sysplex( cpi_bk->sysplex_name );

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	48 6b c0 00	 imul	 rax, rax, 0
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  0009b	0f b6 44 01 32	 movzx	 eax, BYTE PTR [rcx+rax+50]
  000a0	85 c0		 test	 eax, eax
  000a2	74 11		 je	 SHORT $LN16@sclp_cpide
  000a4	48 8b 44 24 68	 mov	 rax, QWORD PTR cpi_bk$[rsp]
  000a9	48 83 c0 32	 add	 rax, 50			; 00000032H
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	e8 00 00 00 00	 call	 set_sysplex
$LN16@sclp_cpide:

; 589  : 
; 590  :     for (i=0; i < 8; i++)

  000b5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000bd	eb 0a		 jmp	 SHORT $LN4@sclp_cpide
$LN2@sclp_cpide:
  000bf	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000c3	ff c0		 inc	 eax
  000c5	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@sclp_cpide:
  000c9	83 7c 24 60 08	 cmp	 DWORD PTR i$[rsp], 8
  000ce	7d 65		 jge	 SHORT $LN3@sclp_cpide

; 591  :     {
; 592  :         systype[i] = guest_to_host( cpi_bk->system_type [i] );

  000d0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  000da	0f b6 4c 01 02	 movzx	 ecx, BYTE PTR [rcx+rax+2]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000e5	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ea	88 84 0c a0 00
	00 00		 mov	 BYTE PTR systype$[rsp+rcx], al

; 593  :         sysname[i] = guest_to_host( cpi_bk->system_name [i] );

  000f1	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  000fb	0f b6 4c 01 12	 movzx	 ecx, BYTE PTR [rcx+rax+18]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00106	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0010b	88 84 0c b0 00
	00 00		 mov	 BYTE PTR sysname$[rsp+rcx], al

; 594  :         sysplex[i] = guest_to_host( cpi_bk->sysplex_name[i] );

  00112	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00117	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cpi_bk$[rsp]
  0011c	0f b6 4c 01 32	 movzx	 ecx, BYTE PTR [rcx+rax+50]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00127	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0012c	88 84 0c c0 00
	00 00		 mov	 BYTE PTR sysplex$[rsp+rcx], al

; 595  :     }

  00133	eb 8a		 jmp	 SHORT $LN2@sclp_cpide
$LN3@sclp_cpide:

; 596  : 
; 597  :     systype[8] = sysname[8] = sysplex[8] = 0;

  00135	b8 01 00 00 00	 mov	 eax, 1
  0013a	48 6b c0 08	 imul	 rax, rax, 8
  0013e	48 89 44 24 78	 mov	 QWORD PTR $T1[rsp], rax
  00143	48 83 7c 24 78
	09		 cmp	 QWORD PTR $T1[rsp], 9
  00149	73 02		 jae	 SHORT $LN18@sclp_cpide
  0014b	eb 05		 jmp	 SHORT $LN19@sclp_cpide
$LN18@sclp_cpide:
  0014d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@sclp_cpide:
  00152	48 8b 44 24 78	 mov	 rax, QWORD PTR $T1[rsp]
  00157	c6 84 04 c0 00
	00 00 00	 mov	 BYTE PTR sysplex$[rsp+rax], 0
  0015f	b8 01 00 00 00	 mov	 eax, 1
  00164	48 6b c0 08	 imul	 rax, rax, 8
  00168	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR sysname$[rsp+rax], 0
  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	48 6b c0 08	 imul	 rax, rax, 8
  00179	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR systype$[rsp+rax], 0

; 598  : 
; 599  :     for (i=7; i >= 0 && systype[i] == ' '; i--) systype[i] = 0;

  00181	c7 44 24 60 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  00189	eb 0a		 jmp	 SHORT $LN7@sclp_cpide
$LN5@sclp_cpide:
  0018b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0018f	ff c8		 dec	 eax
  00191	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@sclp_cpide:
  00195	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  0019a	7c 43		 jl	 SHORT $LN6@sclp_cpide
  0019c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001a1	0f be 84 04 a0
	00 00 00	 movsx	 eax, BYTE PTR systype$[rsp+rax]
  001a9	83 f8 20	 cmp	 eax, 32			; 00000020H
  001ac	75 31		 jne	 SHORT $LN6@sclp_cpide
  001ae	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001b3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  001bb	48 83 bc 24 80
	00 00 00 09	 cmp	 QWORD PTR $T2[rsp], 9
  001c4	73 02		 jae	 SHORT $LN20@sclp_cpide
  001c6	eb 05		 jmp	 SHORT $LN21@sclp_cpide
$LN20@sclp_cpide:
  001c8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@sclp_cpide:
  001cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  001d5	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR systype$[rsp+rax], 0
  001dd	eb ac		 jmp	 SHORT $LN5@sclp_cpide
$LN6@sclp_cpide:

; 600  :     for (i=7; i >= 0 && sysname[i] == ' '; i--) sysname[i] = 0;

  001df	c7 44 24 60 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  001e7	eb 0a		 jmp	 SHORT $LN10@sclp_cpide
$LN8@sclp_cpide:
  001e9	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  001ed	ff c8		 dec	 eax
  001ef	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN10@sclp_cpide:
  001f3	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  001f8	7c 43		 jl	 SHORT $LN9@sclp_cpide
  001fa	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001ff	0f be 84 04 b0
	00 00 00	 movsx	 eax, BYTE PTR sysname$[rsp+rax]
  00207	83 f8 20	 cmp	 eax, 32			; 00000020H
  0020a	75 31		 jne	 SHORT $LN9@sclp_cpide
  0020c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00211	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  00219	48 83 bc 24 88
	00 00 00 09	 cmp	 QWORD PTR $T3[rsp], 9
  00222	73 02		 jae	 SHORT $LN22@sclp_cpide
  00224	eb 05		 jmp	 SHORT $LN23@sclp_cpide
$LN22@sclp_cpide:
  00226	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@sclp_cpide:
  0022b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  00233	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR sysname$[rsp+rax], 0
  0023b	eb ac		 jmp	 SHORT $LN8@sclp_cpide
$LN9@sclp_cpide:

; 601  :     for (i=7; i >= 0 && sysplex[i] == ' '; i--) sysplex[i] = 0;

  0023d	c7 44 24 60 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  00245	eb 0a		 jmp	 SHORT $LN13@sclp_cpide
$LN11@sclp_cpide:
  00247	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0024b	ff c8		 dec	 eax
  0024d	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN13@sclp_cpide:
  00251	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  00256	7c 43		 jl	 SHORT $LN12@sclp_cpide
  00258	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0025d	0f be 84 04 c0
	00 00 00	 movsx	 eax, BYTE PTR sysplex$[rsp+rax]
  00265	83 f8 20	 cmp	 eax, 32			; 00000020H
  00268	75 31		 jne	 SHORT $LN12@sclp_cpide
  0026a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0026f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  00277	48 83 bc 24 90
	00 00 00 09	 cmp	 QWORD PTR $T4[rsp], 9
  00280	73 02		 jae	 SHORT $LN24@sclp_cpide
  00282	eb 05		 jmp	 SHORT $LN25@sclp_cpide
$LN24@sclp_cpide:
  00284	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@sclp_cpide:
  00289	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  00291	c6 84 04 c0 00
	00 00 00	 mov	 BYTE PTR sysplex$[rsp+rax], 0
  00299	eb ac		 jmp	 SHORT $LN11@sclp_cpide
$LN12@sclp_cpide:

; 602  : 
; 603  :     FETCH_DW( syslevel, cpi_bk->system_level );

  0029b	48 8b 44 24 68	 mov	 rax, QWORD PTR cpi_bk$[rsp]
  002a0	48 83 c0 22	 add	 rax, 34			; 00000022H
  002a4	48 8b c8	 mov	 rcx, rax
  002a7	e8 00 00 00 00	 call	 fetch_dw_noswap
  002ac	48 8b c8	 mov	 rcx, rax
  002af	e8 00 00 00 00	 call	 _byteswap_uint64
  002b4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR syslevel$[rsp], rax

; 604  : 
; 605  :     // "Control program identification: type %s, name %s, sysplex %s, level %"PRIX64
; 606  :     WRMSG( HHC00004, "I", systype, sysname, sysplex, syslevel );

  002bc	b9 01 00 00 00	 mov	 ecx, 1
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR syslevel$[rsp]
  002cf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sysplex$[rsp]
  002dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e1	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR sysname$[rsp]
  002e9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002ee	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR systype$[rsp]
  002f6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179158
  00302	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179159
  0030e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179160
  00325	ba 5e 02 00 00	 mov	 edx, 606		; 0000025eH
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179161
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 607  : 
; 608  :     {
; 609  :         char buf[128];
; 610  : 
; 611  :         MSGBUF( buf, "%"PRIX64, syslevel );

  00337	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR syslevel$[rsp]
  0033f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179162
  00346	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0034b	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 612  : 
; 613  :         set_symbol( "SYSTYPE",  systype );

  00359	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR systype$[rsp]
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179163
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 614  :         set_symbol( "SYSNAME",  sysname );

  0036e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR sysname$[rsp]
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179164
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 615  :         set_symbol( "SYSPLEX",  sysplex );

  00383	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR sysplex$[rsp]
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179165
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 616  :         set_symbol( "SYSLEVEL", buf     );

  00398	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buf$5[rsp]
  003a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179166
  003a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 617  :     }
; 618  : 
; 619  :     losc_check( systype );

  003ad	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR systype$[rsp]
  003b5	e8 00 00 00 00	 call	 losc_check

; 620  : 
; 621  :     /* Indicate Event Processed */
; 622  :     evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  003ba	48 8b 44 24 70	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  003bf	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003c3	0f ba e8 07	 bts	 eax, 7
  003c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  003cc	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 623  : 
; 624  :     /* Set response code X'0020' in SCCB header */
; 625  :     sccb->reas = SCCB_REAS_NONE;

  003cf	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  003d7	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 626  :     sccb->resp = SCCB_RESP_COMPLETE;

  003db	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  003e3	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN17@sclp_cpide:

; 627  : }

  003e7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ef	48 33 cc	 xor	 rcx, rsp
  003f2	e8 00 00 00 00	 call	 __security_check_cookie
  003f7	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  003fe	c3		 ret	 0
sclp_cpident ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
i$ = 40
event_msglen$ = 44
evd_bk$ = 48
evd_hdr$ = 56
evd_msg$ = 64
sccb$ = 112
type$ = 120
sclp_opcmd_event PROC

; 452  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 453  :     static const BYTE const1_template[] =
; 454  :     {
; 455  :         0x13,0x10,                      /* MDS message unit          */
; 456  :         0x00,0x25,0x13,0x11,            /* MDS routine info          */
; 457  :              0x0E,0x81,                 /* origin location name      */
; 458  :                   0x03,0x01,0x00,       /* Net ID                    */
; 459  :                   0x03,0x02,0x00,       /* NAU Name                  */
; 460  :                   0x06,0x03,0x00,0x00,0x00,0x00,  /* Appl id         */
; 461  :              0x0E,0x82,                 /* Destinition location name */
; 462  :                   0x03,0x01,0x00,       /* Net ID                    */
; 463  :                   0x03,0x02,0x00,       /* NAU Name                  */
; 464  :                   0x06,0x03,0x00,0x00,0x00,0x00,  /* Appl id         */
; 465  :              0x05,0x90,0x00,0x00,0x00,  /* Flags (MDS type = req)    */
; 466  :         0x00,0x0C,0x15,0x49,            /* Agent unit-of-work        */
; 467  :              0x08,0x01,                 /* Requestor loc name        */
; 468  :                   0x03,0x01,0x00,       /* Requestor Net ID          */
; 469  :                   0x03,0x02,0x00        /* Requestor Node ID         */
; 470  :     };
; 471  : 
; 472  :     static const BYTE const2_template[] =
; 473  :     {
; 474  :         0x12,0x12,                      /* CP-MSU                    */
; 475  :         0x00,0x12,0x15,0x4D,            /* RTI                       */
; 476  :              0x0E,0x06,                 /* Name List                 */
; 477  :                   0x06,0x10,0x00,0x03,0x00,0x00,  /* Cascaded
; 478  :                                                        resource list */
; 479  :                   0x06,0x60,0xD6,0xC3,0xC6,0xC1,  /* OAN (C'OCFA')   */
; 480  :         0x00,0x04,0x80,0x70             /* Operate request           */
; 481  :     };
; 482  : 
; 483  :     static const BYTE const3_template[] =
; 484  :     {
; 485  :         0x13,0x20                       /* Text data                 */
; 486  :     };
; 487  : 
; 488  :     static const BYTE const4_template =
; 489  :     {
; 490  :         0x31                            /* Self-defining             */
; 491  :     };
; 492  : 
; 493  :     static const BYTE const5_template =
; 494  :     {
; 495  :         0x30                            /* Text data                 */
; 496  :     };
; 497  : 
; 498  : U16 sccb_len;
; 499  : U16 evd_len;
; 500  : int event_msglen;
; 501  : int i;
; 502  : 
; 503  : SCCB_EVD_HDR* evd_hdr = (SCCB_EVD_HDR*)(sccb    + 1 );

  00010	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  00015	48 83 c0 08	 add	 rax, 8
  00019	48 89 44 24 38	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 504  : SCCB_EVD_BK*  evd_bk  = (SCCB_EVD_BK*) (evd_hdr + 1 );

  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00023	48 83 c0 06	 add	 rax, 6
  00027	48 89 44 24 30	 mov	 QWORD PTR evd_bk$[rsp], rax

; 505  : BYTE*         evd_msg = (BYTE*)        (evd_bk  + 1 );

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  00031	48 83 c0 57	 add	 rax, 87			; 00000057H
  00035	48 89 44 24 40	 mov	 QWORD PTR evd_msg$[rsp], rax

; 506  : 
; 507  :     /* Get SCCB length */
; 508  :     FETCH_HW( sccb_len, sccb->length  );

  0003a	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 fetch_hw_noswap
  00047	0f b7 c8	 movzx	 ecx, ax
  0004a	e8 00 00 00 00	 call	 _byteswap_ushort
  0004f	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 509  : 
; 510  :     /* Command length */
; 511  :     event_msglen = (int)strlen( servc_scpcmdstr );

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:servc_scpcmdstr
  0005b	e8 00 00 00 00	 call	 strlen
  00060	89 44 24 2c	 mov	 DWORD PTR event_msglen$[rsp], eax

; 512  : 
; 513  :     /* Calculate required EVD length */
; 514  :     evd_len = event_msglen + (int)sizeof( SCCB_EVD_HDR ) + (int)sizeof( SCCB_EVD_BK );

  00064	8b 44 24 2c	 mov	 eax, DWORD PTR event_msglen$[rsp]
  00068	83 c0 5d	 add	 eax, 93			; 0000005dH
  0006b	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 515  : 
; 516  :     /* Set response code X'75F0' if SCCB length exceeded */
; 517  :     if ((evd_len + sizeof( SCCB_HEADER )) > sccb_len)

  00070	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  00075	48 83 c0 08	 add	 rax, 8
  00079	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  0007e	48 3b c1	 cmp	 rax, rcx
  00081	76 17		 jbe	 SHORT $LN5@sclp_opcmd

; 518  :     {
; 519  :         sccb->reas = SCCB_REAS_EXCEEDS_SCCB;

  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  00088	c6 40 06 75	 mov	 BYTE PTR [rax+6], 117	; 00000075H

; 520  :         sccb->resp = SCCB_RESP_EXCEEDS_SCCB;

  0008c	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  00091	c6 40 07 f0	 mov	 BYTE PTR [rax+7], 240	; 000000f0H

; 521  :         return;

  00095	e9 cd 01 00 00	 jmp	 $LN1@sclp_opcmd
$LN5@sclp_opcmd:

; 522  :     }
; 523  : 
; 524  :     /* Zero all fields */
; 525  : 
; 526  :     /* Update SCCB length field if variable request */
; 527  :     if (sccb->type & SCCB_TYPE_VARIABLE)

  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  0009f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000a3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000a8	85 c0		 test	 eax, eax
  000aa	74 3a		 je	 SHORT $LN6@sclp_opcmd

; 528  :     {
; 529  :         /* Set new SCCB length */
; 530  :         sccb_len = evd_len + sizeof( SCCB_HEADER );

  000ac	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  000b1	48 83 c0 08	 add	 rax, 8
  000b5	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 531  :         STORE_HW( sccb->length, sccb_len  );

  000ba	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  000bf	e8 00 00 00 00	 call	 _byteswap_ushort
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccb$[rsp]
  000c9	0f b7 d0	 movzx	 edx, ax
  000cc	e8 00 00 00 00	 call	 store_hw_noswap

; 532  :         sccb->type &= ~SCCB_TYPE_VARIABLE;

  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  000d6	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000da	0f ba f0 07	 btr	 eax, 7
  000de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sccb$[rsp]
  000e3	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN6@sclp_opcmd:

; 533  :     }
; 534  : 
; 535  :     /* Set length in event header */
; 536  :     STORE_HW( evd_hdr->totlen, evd_len );

  000e6	0f b7 4c 24 20	 movzx	 ecx, WORD PTR evd_len$[rsp]
  000eb	e8 00 00 00 00	 call	 _byteswap_ushort
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  000f5	0f b7 d0	 movzx	 edx, ax
  000f8	e8 00 00 00 00	 call	 store_hw_noswap

; 537  : 
; 538  :     /* Set type in event header */
; 539  :     evd_hdr->type = type;

  000fd	48 8b 44 24 38	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00102	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR type$[rsp]
  00107	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 540  : 
; 541  :     /* Set message length in event data block */
; 542  :     i = evd_len - sizeof( SCCB_EVD_HDR );

  0010a	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  0010f	48 83 e8 06	 sub	 rax, 6
  00113	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 543  :     STORE_HW( evd_bk->msglen, i  );

  00117	0f b7 4c 24 28	 movzx	 ecx, WORD PTR i$[rsp]
  0011c	e8 00 00 00 00	 call	 _byteswap_ushort
  00121	48 8b 4c 24 30	 mov	 rcx, QWORD PTR evd_bk$[rsp]
  00126	0f b7 d0	 movzx	 edx, ax
  00129	e8 00 00 00 00	 call	 store_hw_noswap

; 544  : 
; 545  :     memcpy( evd_bk->const1, const1_template,

  0012e	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?const1_template@?1??sclp_opcmd_event@@9@9
  0013a	48 8d 78 02	 lea	 rdi, QWORD PTR [rax+2]
  0013e	48 8b f1	 mov	 rsi, rcx
  00141	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00146	f3 a4		 rep movsb

; 546  :                     sizeof( const1_template ));
; 547  :     i -=            sizeof( const1_template ) + 2;

  00148	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0014d	48 83 e8 35	 sub	 rax, 53			; 00000035H
  00151	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 548  :     STORE_HW( evd_bk->cplen, i  );

  00155	0f b7 4c 24 28	 movzx	 ecx, WORD PTR i$[rsp]
  0015a	e8 00 00 00 00	 call	 _byteswap_ushort
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR evd_bk$[rsp]
  00164	48 83 c1 35	 add	 rcx, 53			; 00000035H
  00168	0f b7 d0	 movzx	 edx, ax
  0016b	e8 00 00 00 00	 call	 store_hw_noswap

; 549  : 
; 550  :     memcpy( evd_bk->const2, const2_template,

  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?const2_template@?1??sclp_opcmd_event@@9@9
  0017c	48 8d 78 37	 lea	 rdi, QWORD PTR [rax+55]
  00180	48 8b f1	 mov	 rsi, rcx
  00183	b9 18 00 00 00	 mov	 ecx, 24
  00188	f3 a4		 rep movsb

; 551  :                     sizeof( const2_template ));
; 552  :     i -=            sizeof( const2_template ) + 2;

  0018a	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0018f	48 83 e8 1a	 sub	 rax, 26
  00193	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 553  :     STORE_HW( evd_bk->tdlen, i  );

  00197	0f b7 4c 24 28	 movzx	 ecx, WORD PTR i$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_ushort
  001a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR evd_bk$[rsp]
  001a6	48 83 c1 4f	 add	 rcx, 79			; 0000004fH
  001aa	0f b7 d0	 movzx	 edx, ax
  001ad	e8 00 00 00 00	 call	 store_hw_noswap

; 554  : 
; 555  :     memcpy( evd_bk->const3, const3_template,

  001b2	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  001b7	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?const3_template@?1??sclp_opcmd_event@@9@9
  001be	66 89 48 51	 mov	 WORD PTR [rax+81], cx

; 556  :                     sizeof( const3_template ));
; 557  :     i -=            sizeof( const3_template ) + 2;

  001c2	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001c7	48 83 e8 04	 sub	 rax, 4
  001cb	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 558  : 
; 559  :     evd_bk->sdtlen = i;

  001cf	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  001d4	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR i$[rsp]
  001d9	88 48 53	 mov	 BYTE PTR [rax+83], cl

; 560  :     evd_bk->const4 = const4_template;

  001dc	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  001e1	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?const4_template@?1??sclp_opcmd_event@@9@9
  001e8	88 48 54	 mov	 BYTE PTR [rax+84], cl

; 561  : 
; 562  :     i -= 2;

  001eb	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001ef	83 e8 02	 sub	 eax, 2
  001f2	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 563  :     evd_bk->tmlen = i;

  001f6	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  001fb	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR i$[rsp]
  00200	88 48 55	 mov	 BYTE PTR [rax+85], cl

; 564  :     evd_bk->const5 = const5_template;

  00203	48 8b 44 24 30	 mov	 rax, QWORD PTR evd_bk$[rsp]
  00208	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?const5_template@?1??sclp_opcmd_event@@9@9
  0020f	88 48 56	 mov	 BYTE PTR [rax+86], cl

; 565  : 
; 566  :     /* Copy and translate command */
; 567  :     for (i=0; i < event_msglen; i++)

  00212	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0021a	eb 0a		 jmp	 SHORT $LN4@sclp_opcmd
$LN2@sclp_opcmd:
  0021c	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00220	ff c0		 inc	 eax
  00222	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@sclp_opcmd:
  00226	8b 44 24 2c	 mov	 eax, DWORD PTR event_msglen$[rsp]
  0022a	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0022e	7d 25		 jge	 SHORT $LN3@sclp_opcmd

; 568  :         evd_msg[i] = host_to_guest( servc_scpcmdstr[i] );

  00230	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:servc_scpcmdstr
  0023c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  00246	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  0024b	48 8b 54 24 40	 mov	 rdx, QWORD PTR evd_msg$[rsp]
  00250	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00253	eb c7		 jmp	 SHORT $LN2@sclp_opcmd
$LN3@sclp_opcmd:

; 569  : 
; 570  :     /* Set response code X'0020' in SCCB header */
; 571  :     sccb->reas = SCCB_REAS_NONE;

  00255	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  0025a	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 572  :     sccb->resp = SCCB_RESP_COMPLETE;

  0025e	48 8b 44 24 70	 mov	 rax, QWORD PTR sccb$[rsp]
  00263	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN1@sclp_opcmd:

; 573  : }

  00267	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0026b	5f		 pop	 rdi
  0026c	5e		 pop	 rsi
  0026d	c3		 ret	 0
sclp_opcmd_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
pending$ = 0
tv75 = 4
type$ = 32
sclp_attn_pending PROC

; 367  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 368  : U32 pending;
; 369  : 
; 370  :     if (type)

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR type$[rsp]
  0000e	85 c0		 test	 eax, eax
  00010	74 3d		 je	 SHORT $LN2@sclp_attn_

; 371  :     {
; 372  :         pending = servc_attn_pending & (0x80000000 >> (type -1));

  00012	0f b7 44 24 20	 movzx	 eax, WORD PTR type$[rsp]
  00017	ff c8		 dec	 eax
  00019	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0001e	89 4c 24 04	 mov	 DWORD PTR tv75[rsp], ecx
  00022	0f b6 c8	 movzx	 ecx, al
  00025	8b 44 24 04	 mov	 eax, DWORD PTR tv75[rsp]
  00029	d3 e8		 shr	 eax, cl
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_attn_pending
  00031	23 c8		 and	 ecx, eax
  00033	8b c1		 mov	 eax, ecx
  00035	89 04 24	 mov	 DWORD PTR pending$[rsp], eax

; 373  :         servc_attn_pending &= ~pending;

  00038	8b 04 24	 mov	 eax, DWORD PTR pending$[rsp]
  0003b	f7 d0		 not	 eax
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_attn_pending
  00043	23 c8		 and	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	89 05 00 00 00
	00		 mov	 DWORD PTR servc_attn_pending, eax

; 374  :     }

  0004d	eb 09		 jmp	 SHORT $LN3@sclp_attn_
$LN2@sclp_attn_:

; 375  :     else
; 376  :     {
; 377  :         pending = servc_attn_pending;

  0004f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_attn_pending
  00055	89 04 24	 mov	 DWORD PTR pending$[rsp], eax
$LN3@sclp_attn_:

; 378  :     }
; 379  : 
; 380  :     return pending;

  00058	8b 04 24	 mov	 eax, DWORD PTR pending$[rsp]

; 381  : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
sclp_attn_pending ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
rc$1 = 64
sclp_attn_tid$2 = 68
typ$3 = 72
tv82 = 80
type$ = 112
sclp_attn_async PROC

; 344  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 345  :     if (!IS_IC_SERVSIG)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00016	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0001b	85 c0		 test	 eax, eax
  0001d	75 0f		 jne	 SHORT $LN2@sclp_attn_

; 346  :     {
; 347  :         sclp_attention( type );

  0001f	0f b7 4c 24 70	 movzx	 ecx, WORD PTR type$[rsp]
  00024	e8 00 00 00 00	 call	 sclp_attention

; 348  :     }

  00029	e9 c7 00 00 00	 jmp	 $LN3@sclp_attn_
$LN2@sclp_attn_:

; 349  :     else
; 350  :     {
; 351  :         int rc;
; 352  :         TID sclp_attn_tid;
; 353  :         U16* typ;
; 354  :         typ = malloc( sizeof( U16 ));

  0002e	b9 02 00 00 00	 mov	 ecx, 2
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00039	48 89 44 24 48	 mov	 QWORD PTR typ$3[rsp], rax

; 355  :         *typ = type;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR typ$3[rsp]
  00043	0f b7 4c 24 70	 movzx	 ecx, WORD PTR type$[rsp]
  00048	66 89 08	 mov	 WORD PTR [rax], cx

; 356  :         rc = create_thread( &sclp_attn_tid, &sysblk.detattr,

  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00052	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179033
  0005f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179034
  0006b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00070	4c 8b 4c 24 48	 mov	 r9, QWORD PTR typ$3[rsp]
  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:sclp_attn_thread
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8d 4c 24 44	 lea	 rcx, QWORD PTR sclp_attn_tid$2[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0008a	89 44 24 40	 mov	 DWORD PTR rc$1[rsp], eax

; 357  :                             sclp_attn_thread, typ, "attn_thread" );
; 358  :         if (rc)

  0008e	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00093	74 60		 je	 SHORT $LN4@sclp_attn_

; 359  :             // "Error in function create_thread(): %s"
; 360  :             WRMSG( HHC00102, "E", strerror( rc ));

  00095	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$1[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009f	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000a4	b9 01 00 00 00	 mov	 ecx, 1
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv82[rsp]
  000b4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179036
  000c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179037
  000cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179038
  000e3	ba 68 01 00 00	 mov	 edx, 360		; 00000168H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179039
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@sclp_attn_:
$LN3@sclp_attn_:

; 361  :     }
; 362  : }

  000f5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f9	c3		 ret	 0
sclp_attn_async ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
type$ = 32
arg$ = 64
sclp_attn_thread PROC

; 315  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 316  :     U16* type = (U16*) arg;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR arg$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR type$[rsp], rax

; 317  : 
; 318  :     OBTAIN_INTLOCK( NULL );

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179018
  0001a	33 c9		 xor	 ecx, ecx
  0001c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN2@sclp_attn_:

; 319  :     {
; 320  :         // The VM boys appear to have made an error in not
; 321  :         // allowing for asyncronous attentions to be merged
; 322  :         // with pending interrupts. As such, we will wait here
; 323  :         // until the pending interrupt has been cleared. *JJ
; 324  : 
; 325  :         while (IS_IC_SERVSIG)

  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00028	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0002e	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00033	85 c0		 test	 eax, eax
  00035	74 24		 je	 SHORT $LN3@sclp_attn_

; 326  :         {
; 327  :             RELEASE_INTLOCK (NULL );

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179019
  0003e	33 c9		 xor	 ecx, ecx
  00040	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 328  :             {
; 329  :                 sched_yield();

  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 330  :             }
; 331  :             OBTAIN_INTLOCK( NULL );

  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179020
  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 332  :         }

  00059	eb c6		 jmp	 SHORT $LN2@sclp_attn_
$LN3@sclp_attn_:

; 333  : 
; 334  :         sclp_attention( *type );

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR type$[rsp]
  00060	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00063	e8 00 00 00 00	 call	 sclp_attention

; 335  :         free( type );

  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR type$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 336  :     }
; 337  :     RELEASE_INTLOCK( NULL );

  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179021
  0007a	33 c9		 xor	 ecx, ecx
  0007c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 338  :     return NULL;

  00081	33 c0		 xor	 eax, eax

; 339  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
sclp_attn_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
i$ = 64
p$ = 72
scanlen$1 = 80
seqlen$ = 84
p2$ = 88
$T2 = 96
tv249 = 104
a_msg$ = 112
__$ArrayPad$ = 4208
msglen$ = 4240
e_msg$ = 4248
gh534_fix PROC

; 60   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	b8 88 10 00 00	 mov	 eax, 4232		; 00001088H
  0000e	e8 00 00 00 00	 call	 __chkstk
  00013	48 2b e0	 sub	 rsp, rax
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 70
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 61   :     static bool once   = false;
; 62   :     static bool ignore = false;
; 63   :     static BYTE ESC    = 0;
; 64   : 
; 65   :     static const char* parms  = "0123456789:;<=>?";
; 66   : //  static const char* inter  = " !\"#$%&'()*+,-./"; // (not used)
; 67   :     static const char* final  = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
; 68   :     static       int   prmlen; // (length of above "parms" string)
; 69   :     static       BYTE  subsub[3] = {0};
; 70   : 
; 71   :     BYTE  *p, *p2;   // (work)
; 72   :     int i, seqlen;   // (work)
; 73   : 
; 74   :     // (message translated from guest to host)
; 75   :     BYTE /*ASCII*/ a_msg[ MAX_EVENT_MSG_LEN ];
; 76   : 
; 77   :     /* Ignore messages that are "too long" */
; 78   :     if (msglen >= (int) sizeof( a_msg ))

  00028	81 bc 24 90 10
	00 00 f9 0f 00
	00		 cmp	 DWORD PTR msglen$[rsp], 4089 ; 00000ff9H
  00033	7c 05		 jl	 SHORT $LN11@gh534_fix

; 79   :         return;

  00035	e9 7a 04 00 00	 jmp	 $LN1@gh534_fix
$LN11@gh534_fix:

; 80   : 
; 81   :     /* For empty messages, just echo a blank line */
; 82   :     if (!msglen)

  0003a	83 bc 24 90 10
	00 00 00	 cmp	 DWORD PTR msglen$[rsp], 0
  00042	75 40		 jne	 SHORT $LN12@gh534_fix

; 83   :     {
; 84   :         LOGMSG( "\n" );

  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178948
  00056	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	41 b9 03 00 00
	00		 mov	 r9d, 3
  00066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178949
  0006d	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178950
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 85   :         return;

  0007f	e9 30 04 00 00	 jmp	 $LN1@gh534_fix
$LN12@gh534_fix:

; 86   :     }
; 87   : 
; 88   :     /* Note that IBM zLinux seems to use EBCDIC X'4A' for their
; 89   :        ESCape character, so whatever that translates to is the
; 90   :        host ASCII character that we need to treat as the "ESC"
; 91   :        character that indicates the start of a Control Sequence.
; 92   :        Same thing with the "SUB" character which they also use.
; 93   :     */
; 94   :     if (!once)

  00084	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?once@?1??gh534_fix@@9@9
  0008b	85 c0		 test	 eax, eax
  0008d	75 6a		 jne	 SHORT $LN13@gh534_fix

; 95   :     {
; 96   :         once = true;

  0008f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?once@?1??gh534_fix@@9@9, 1

; 97   :         prmlen    = (int) strlen( parms );

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?parms@?1??gh534_fix@@9@9
  0009d	e8 00 00 00 00	 call	 strlen
  000a2	89 05 00 00 00
	00		 mov	 DWORD PTR ?prmlen@?1??gh534_fix@@9@9, eax

; 98   :         ESC       = guest_to_host( 0x4A /* CODEPAGE 500  '['  */ );

  000a8	b1 4a		 mov	 cl, 74			; 0000004aH
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000b0	88 05 00 00 00
	00		 mov	 BYTE PTR ?ESC@?1??gh534_fix@@9@9, al

; 99   :         subsub[0] = guest_to_host( 0x3F /* CODEPAGE 500 "SUB" */ );

  000b6	b1 3f		 mov	 cl, 63			; 0000003fH
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000be	b9 01 00 00 00	 mov	 ecx, 1
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?subsub@?1??gh534_fix@@9@9
  000ce	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 100  :         subsub[1] = subsub[0];

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?subsub@?1??gh534_fix@@9@9
  000e1	ba 01 00 00 00	 mov	 edx, 1
  000e6	48 6b d2 01	 imul	 rdx, rdx, 1
  000ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?subsub@?1??gh534_fix@@9@9
  000f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f5	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
$LN13@gh534_fix:

; 101  :     }
; 102  : 
; 103  :     /* Convert from guest to host */
; 104  :     for (i=0; i < msglen; i++)

  000f9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00101	eb 0a		 jmp	 SHORT $LN4@gh534_fix
$LN2@gh534_fix:
  00103	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00107	ff c0		 inc	 eax
  00109	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@gh534_fix:
  0010d	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR msglen$[rsp]
  00114	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00118	7d 22		 jge	 SHORT $LN3@gh534_fix

; 105  :         a_msg[i] = guest_to_host( e_msg[i] );

  0011a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0011f	48 8b 8c 24 98
	10 00 00	 mov	 rcx, QWORD PTR e_msg$[rsp]
  00127	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00131	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00136	88 44 0c 70	 mov	 BYTE PTR a_msg$[rsp+rcx], al
  0013a	eb c7		 jmp	 SHORT $LN2@gh534_fix
$LN3@gh534_fix:

; 106  :     a_msg[ msglen ] = 0;

  0013c	48 63 84 24 90
	10 00 00	 movsxd	 rax, DWORD PTR msglen$[rsp]
  00144	48 89 44 24 60	 mov	 QWORD PTR $T2[rsp], rax
  00149	48 81 7c 24 60
	f9 0f 00 00	 cmp	 QWORD PTR $T2[rsp], 4089 ; 00000ff9H
  00152	73 02		 jae	 SHORT $LN28@gh534_fix
  00154	eb 05		 jmp	 SHORT $LN29@gh534_fix
$LN28@gh534_fix:
  00156	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN29@gh534_fix:
  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR $T2[rsp]
  00160	c6 44 04 70 00	 mov	 BYTE PTR a_msg$[rsp+rax], 0

; 107  : 
; 108  :     /*****************************************************************/
; 109  :     /*                       REFERENCE                               */
; 110  :     /*                                                               */
; 111  :     /*    https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_(Con    */
; 112  :     /*            trol_Sequence_Introducer)_sequences                */
; 113  :     /*                                                               */
; 114  :     /*    For Control Sequence Introducer, or CSI, commands,         */
; 115  :     /*    the "ESC [" (written as "\e[" or "\033[" in several        */
; 116  :     /*    programming and scripting languages) is followed by        */
; 117  :     /*    any number (including none!) of "parameter bytes"          */
; 118  :     /*    in the range 0x30-0x3F (ASCII 0-9:;<=>?), then by          */
; 119  :     /*    any number of "intermediate bytes" in the range            */
; 120  :     /*    0x20-0x2F (ASCII space and !"#$%&'()*+,-./), then          */
; 121  :     /*    finally by a single "final byte" in the range 0x40-0x7E    */
; 122  :     /*    (ASCII @A-Z[\]^_`a-z{|}~).                                 */
; 123  :     /*                                                               */
; 124  :     /*****************************************************************/
; 125  : 
; 126  :     for (p = a_msg; msglen;)

  00165	48 8d 44 24 70	 lea	 rax, QWORD PTR a_msg$[rsp]
  0016a	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax
$LN5@gh534_fix:
  0016f	83 bc 24 90 10
	00 00 00	 cmp	 DWORD PTR msglen$[rsp], 0
  00177	0f 84 94 01 00
	00		 je	 $LN6@gh534_fix

; 127  :     {
; 128  :         /* Find the start of the next control sequence */
; 129  :         if (!(p = memchr( p, ESC, msglen )))

  0017d	48 63 84 24 90
	10 00 00	 movsxd	 rax, DWORD PTR msglen$[rsp]
  00185	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?ESC@?1??gh534_fix@@9@9
  0018c	4c 8b c0	 mov	 r8, rax
  0018f	8b d1		 mov	 edx, ecx
  00191	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  00196	e8 00 00 00 00	 call	 memchr
  0019b	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax
  001a0	48 83 7c 24 48
	00		 cmp	 QWORD PTR p$[rsp], 0
  001a6	75 05		 jne	 SHORT $LN14@gh534_fix

; 130  :             break; // (No control sequences remain! We're done!)

  001a8	e9 64 01 00 00	 jmp	 $LN6@gh534_fix
$LN14@gh534_fix:

; 131  : 
; 132  :         /* If the next character is NOT a "parameter byte", then it's
; 133  :            obviously not a CSI. It might be some other Linux escape
; 134  :            sequence though, so we need to check further.
; 135  :         */
; 136  :         if (!memchr( parms, *(p+1), prmlen ))

  001ad	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR ?prmlen@?1??gh534_fix@@9@9
  001b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  001b9	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  001bd	4c 8b c0	 mov	 r8, rax
  001c0	8b d1		 mov	 edx, ecx
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?parms@?1??gh534_fix@@9@9
  001c9	e8 00 00 00 00	 call	 memchr
  001ce	48 85 c0	 test	 rax, rax
  001d1	0f 85 89 00 00
	00		 jne	 $LN15@gh534_fix

; 137  :         {
; 138  :             /*********************************************************/
; 139  :             /*                     REFERENCE                         */
; 140  :             /*                                                       */
; 141  :             /*   console_codes(4) - Linux manual page                */
; 142  :             /*   https://man7.org/linux/man-pages/man4/console_codes.4.html  */
; 143  :             /*                                                       */
; 144  :             /*   ECMA-48 CSI sequences:                              */
; 145  :             /*                                                       */
; 146  :             /*   The action of a CSI sequence is determined by its   */
; 147  :             /*   final character:                                    */
; 148  :             /*                                                       */
; 149  :             /*     K  EL        Erase line (default: from cursor     */
; 150  :             /*                  to end of line).                     */
; 151  :             /*                                                       */
; 152  :             /*        ESC [ 1 K: erase from start of line to cursor. */
; 153  :             /*        ESC [ 2 K: erase whole line.                   */
; 154  :             /*                                                       */
; 155  :             /*********************************************************/
; 156  : 
; 157  :             /* If the next byte is a 'K', then, while this is not a
; 158  :                CSI (Control Sequence Introducer), it appears to be
; 159  :                an escape code that means "Erase line" (from the cursor
; 160  :                to the end of line) which I'm interpreting as meaning:
; 161  : 
; 162  :                "Ignore everything that preceded this escape code
; 163  :                 and consider what follows this escape code as text
; 164  :                 that should be displayed starting from the beginning
; 165  :                 of the current line."
; 166  :             */
; 167  :             if (*(p+1) == 'K')

  001d7	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  001dc	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001e0	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  001e3	75 59		 jne	 SHORT $LN16@gh534_fix

; 168  :             {
; 169  :                 msglen -= (p + 2) - a_msg;

  001e5	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  001ea	48 83 c0 02	 add	 rax, 2
  001ee	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  001f3	48 2b c1	 sub	 rax, rcx
  001f6	48 63 8c 24 90
	10 00 00	 movsxd	 rcx, DWORD PTR msglen$[rsp]
  001fe	48 2b c8	 sub	 rcx, rax
  00201	48 8b c1	 mov	 rax, rcx
  00204	89 84 24 90 10
	00 00		 mov	 DWORD PTR msglen$[rsp], eax

; 170  :                 memmove( a_msg, p + 2, msglen + 1 );

  0020b	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR msglen$[rsp]
  00212	ff c0		 inc	 eax
  00214	48 98		 cdqe
  00216	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  0021b	48 83 c1 02	 add	 rcx, 2
  0021f	4c 8b c0	 mov	 r8, rax
  00222	48 8b d1	 mov	 rdx, rcx
  00225	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  0022a	e8 00 00 00 00	 call	 memmove

; 171  :                 p = a_msg;

  0022f	48 8d 44 24 70	 lea	 rax, QWORD PTR a_msg$[rsp]
  00234	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax

; 172  :                 continue;

  00239	e9 31 ff ff ff	 jmp	 $LN5@gh534_fix
$LN16@gh534_fix:

; 173  :             }
; 174  : 
; 175  :             /* Otherwise it's not an escape sequence; skip over this
; 176  :               non-ESC byte and continue looking for the next ESCape
; 177  :               sequence.
; 178  :             */
; 179  :             ++p; --msglen;  // (skip past this non-ESC)

  0023e	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  00243	48 ff c0	 inc	 rax
  00246	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax
  0024b	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR msglen$[rsp]
  00252	ff c8		 dec	 eax
  00254	89 84 24 90 10
	00 00		 mov	 DWORD PTR msglen$[rsp], eax

; 180  :             continue;       // (look for the next ESC)

  0025b	e9 0f ff ff ff	 jmp	 $LN5@gh534_fix
$LN15@gh534_fix:

; 181  :         }
; 182  : 
; 183  :         /* Remove the ESCape right away */
; 184  :         memmove( p, p + 1, msglen + 1 );   // (+1 to include NULL)

  00260	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR msglen$[rsp]
  00267	ff c0		 inc	 eax
  00269	48 98		 cdqe
  0026b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  00270	48 ff c1	 inc	 rcx
  00273	4c 8b c0	 mov	 r8, rax
  00276	48 8b d1	 mov	 rdx, rcx
  00279	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  0027e	e8 00 00 00 00	 call	 memmove

; 185  :         --msglen;

  00283	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR msglen$[rsp]
  0028a	ff c8		 dec	 eax
  0028c	89 84 24 90 10
	00 00		 mov	 DWORD PTR msglen$[rsp], eax

; 186  : 
; 187  :         /* Find the end of the control sequence */
; 188  :         if (!(p2 = strpbrk( p, final )))

  00293	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?final@?1??gh534_fix@@9@9
  0029a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strpbrk
  002a5	48 89 44 24 58	 mov	 QWORD PTR p2$[rsp], rax
  002aa	48 83 7c 24 58
	00		 cmp	 QWORD PTR p2$[rsp], 0
  002b0	75 02		 jne	 SHORT $LN17@gh534_fix

; 189  :             break; // (Not found?! I guess we're done then!)

  002b2	eb 5d		 jmp	 SHORT $LN6@gh534_fix
$LN17@gh534_fix:

; 190  : 
; 191  :         /* Remove the entire control sequence */
; 192  :         seqlen = (p2 - p) + 1;

  002b4	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  002b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p2$[rsp]
  002be	48 2b c8	 sub	 rcx, rax
  002c1	48 8b c1	 mov	 rax, rcx
  002c4	48 ff c0	 inc	 rax
  002c7	89 44 24 54	 mov	 DWORD PTR seqlen$[rsp], eax

; 193  :         memmove( p, p2 + 1, (msglen - seqlen) + 1 );

  002cb	8b 44 24 54	 mov	 eax, DWORD PTR seqlen$[rsp]
  002cf	8b 8c 24 90 10
	00 00		 mov	 ecx, DWORD PTR msglen$[rsp]
  002d6	2b c8		 sub	 ecx, eax
  002d8	8b c1		 mov	 eax, ecx
  002da	ff c0		 inc	 eax
  002dc	48 98		 cdqe
  002de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p2$[rsp]
  002e3	48 ff c1	 inc	 rcx
  002e6	4c 8b c0	 mov	 r8, rax
  002e9	48 8b d1	 mov	 rdx, rcx
  002ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  002f1	e8 00 00 00 00	 call	 memmove

; 194  :         msglen -= seqlen;

  002f6	8b 44 24 54	 mov	 eax, DWORD PTR seqlen$[rsp]
  002fa	8b 8c 24 90 10
	00 00		 mov	 ecx, DWORD PTR msglen$[rsp]
  00301	2b c8		 sub	 ecx, eax
  00303	8b c1		 mov	 eax, ecx
  00305	89 84 24 90 10
	00 00		 mov	 DWORD PTR msglen$[rsp], eax

; 195  :     }

  0030c	e9 5e fe ff ff	 jmp	 $LN5@gh534_fix
$LN6@gh534_fix:

; 196  : 
; 197  :     /*****************************************************************/
; 198  :     /*                    SPECIAL HANDLING                           */
; 199  :     /*                                                               */
; 200  :     /*   If the message starts with a "in progress" indicator,       */
; 201  :     /*   i.e. "[   ***]" or any variation thereof, i.e. a '['        */
; 202  :     /*   and one or more asterisks before the end ']', then we       */
; 203  :     /*   will simply ignore that entire message and the next         */
; 204  :     /*   message too.                                                */
; 205  :     /*                                                               */
; 206  :     /*****************************************************************/
; 207  :     if (a_msg[0] == '[')

  00311	b8 01 00 00 00	 mov	 eax, 1
  00316	48 6b c0 00	 imul	 rax, rax, 0
  0031a	0f b6 44 04 70	 movzx	 eax, BYTE PTR a_msg$[rsp+rax]
  0031f	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00322	75 75		 jne	 SHORT $LN18@gh534_fix

; 208  :     {
; 209  :         int scanlen = (int) strlen( a_msg );

  00324	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  00329	e8 00 00 00 00	 call	 strlen
  0032e	89 44 24 50	 mov	 DWORD PTR scanlen$1[rsp], eax

; 210  : 
; 211  :         if ((p = memchr( a_msg, ']', scanlen )))

  00332	48 63 44 24 50	 movsxd	 rax, DWORD PTR scanlen$1[rsp]
  00337	4c 8b c0	 mov	 r8, rax
  0033a	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  0033f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  00344	e8 00 00 00 00	 call	 memchr
  00349	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax
  0034e	48 83 7c 24 48
	00		 cmp	 QWORD PTR p$[rsp], 0
  00354	74 43		 je	 SHORT $LN19@gh534_fix

; 212  :         {
; 213  :             if ((scanlen = (p - a_msg)) > 0)

  00356	48 8d 44 24 70	 lea	 rax, QWORD PTR a_msg$[rsp]
  0035b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  00360	48 2b c8	 sub	 rcx, rax
  00363	48 8b c1	 mov	 rax, rcx
  00366	89 44 24 50	 mov	 DWORD PTR scanlen$1[rsp], eax
  0036a	83 7c 24 50 00	 cmp	 DWORD PTR scanlen$1[rsp], 0
  0036f	7e 28		 jle	 SHORT $LN20@gh534_fix

; 214  :             {
; 215  :                 if (memchr( a_msg, '*', scanlen ))

  00371	48 63 44 24 50	 movsxd	 rax, DWORD PTR scanlen$1[rsp]
  00376	4c 8b c0	 mov	 r8, rax
  00379	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  0037e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  00383	e8 00 00 00 00	 call	 memchr
  00388	48 85 c0	 test	 rax, rax
  0038b	74 0c		 je	 SHORT $LN21@gh534_fix

; 216  :                 {
; 217  :                     ignore = true;  // (ignore the NEXT message)

  0038d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ignore@?1??gh534_fix@@9@9, 1

; 218  :                     return;         // (and THIS message too)

  00394	e9 1b 01 00 00	 jmp	 $LN1@gh534_fix
$LN21@gh534_fix:
$LN20@gh534_fix:
$LN19@gh534_fix:
$LN18@gh534_fix:

; 219  :                 }
; 220  :             }
; 221  :         }
; 222  :     }
; 223  : 
; 224  :     /* Ignore this message if our ignore flag is set, but ONLY if the
; 225  :        current message appears to be a continuation (i.e. line wrap)
; 226  :        of the previous message. Otherwise, if it appears to be a new
; 227  :        message (i.e. starts with "[  OK  ]" or "        " = 8 blanks),
; 228  :        then we obviously should NOT ignore it.
; 229  :     */
; 230  :     if (ignore)

  00399	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ignore@?1??gh534_fix@@9@9
  003a0	85 c0		 test	 eax, eax
  003a2	74 42		 je	 SHORT $LN22@gh534_fix

; 231  :     {
; 232  :         ignore = false; // (reset flag)

  003a4	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ignore@?1??gh534_fix@@9@9, 0

; 233  : 
; 234  :         /* if NOT a new message, then ignore it as requested */
; 235  :         if (1
; 236  :             && a_msg[0] != '['
; 237  :             && str_ne_n( a_msg, "        ", 8 )

  003ab	33 c0		 xor	 eax, eax
  003ad	83 f8 01	 cmp	 eax, 1
  003b0	74 34		 je	 SHORT $LN23@gh534_fix
  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 00	 imul	 rax, rax, 0
  003bb	0f b6 44 04 70	 movzx	 eax, BYTE PTR a_msg$[rsp+rax]
  003c0	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  003c3	74 21		 je	 SHORT $LN23@gh534_fix
  003c5	41 b8 08 00 00
	00		 mov	 r8d, 8
  003cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178962
  003d2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  003dd	85 c0		 test	 eax, eax
  003df	74 05		 je	 SHORT $LN23@gh534_fix

; 238  :         )
; 239  :         {
; 240  :             return;

  003e1	e9 ce 00 00 00	 jmp	 $LN1@gh534_fix
$LN23@gh534_fix:
$LN22@gh534_fix:

; 241  :         }
; 242  : 
; 243  :         /* Otherwise it's a new message. Display it. */
; 244  :     }
; 245  : 
; 246  :     /* Lastly, convert any unprintable chars to spaces or underscores */
; 247  :     for (i=0; a_msg[i]; i++)

  003e6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ee	eb 0a		 jmp	 SHORT $LN10@gh534_fix
$LN8@gh534_fix:
  003f0	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003f4	ff c0		 inc	 eax
  003f6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN10@gh534_fix:
  003fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003ff	0f b6 44 04 70	 movzx	 eax, BYTE PTR a_msg$[rsp+rax]
  00404	85 c0		 test	 eax, eax
  00406	74 50		 je	 SHORT $LN9@gh534_fix

; 248  :     {
; 249  :         if (!isprint( a_msg[i] ))

  00408	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0040d	0f b6 44 04 70	 movzx	 eax, BYTE PTR a_msg$[rsp+rax]
  00412	8b c8		 mov	 ecx, eax
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0041a	85 c0		 test	 eax, eax
  0041c	75 38		 jne	 SHORT $LN24@gh534_fix

; 250  :         {
; 251  :             if (a_msg[i] == subsub[0])  // "SUB" character?

  0041e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00423	0f b6 44 04 70	 movzx	 eax, BYTE PTR a_msg$[rsp+rax]
  00428	b9 01 00 00 00	 mov	 ecx, 1
  0042d	48 6b c9 00	 imul	 rcx, rcx, 0
  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?subsub@?1??gh534_fix@@9@9
  00438	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0043c	3b c1		 cmp	 eax, ecx
  0043e	75 0c		 jne	 SHORT $LN25@gh534_fix

; 252  :                 a_msg[i] = '_';         // Replace with underscore

  00440	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00445	c6 44 04 70 5f	 mov	 BYTE PTR a_msg$[rsp+rax], 95 ; 0000005fH
  0044a	eb 0a		 jmp	 SHORT $LN26@gh534_fix
$LN25@gh534_fix:

; 253  :             else
; 254  :                 a_msg[i] = ' ';         // Otherwise with space

  0044c	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00451	c6 44 04 70 20	 mov	 BYTE PTR a_msg$[rsp+rax], 32 ; 00000020H
$LN26@gh534_fix:
$LN24@gh534_fix:

; 255  :         }
; 256  :     }

  00456	eb 98		 jmp	 SHORT $LN8@gh534_fix
$LN9@gh534_fix:

; 257  : 
; 258  :     /* And finally, show the fixed results! */
; 259  :     LOGMSG( "%s\n", RTRIM( a_msg ));

  00458	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178966
  0045f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR a_msg$[rsp]
  00464	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  0046a	48 89 44 24 68	 mov	 QWORD PTR tv249[rsp], rax
  0046f	b9 01 00 00 00	 mov	 ecx, 1
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0047a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv249[rsp]
  0047f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178967
  0048b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00490	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00495	41 b9 03 00 00
	00		 mov	 r9d, 3
  0049b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178968
  004a2	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  004a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178969
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN1@gh534_fix:
$LN27@gh534_fix:

; 260  : }

  004b4	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004bc	48 33 cc	 xor	 rcx, rsp
  004bf	e8 00 00 00 00	 call	 __security_check_cookie
  004c4	48 81 c4 88 10
	00 00		 add	 rsp, 4232		; 00001088H
  004cb	c3		 ret	 0
gh534_fix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_string_error_ PROC

; 842  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 843  :     // "SR: string error, incorrect length"
; 844  :     WRMSG(HHC02021, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178901
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178902
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178903
  00039	ba 4c 03 00 00	 mov	 edx, 844		; 0000034cH
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178904
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 845  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_string_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_value_error_ PROC

; 836  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 837  :     // "SR: value error, incorrect length"
; 838  :     WRMSG(HHC02020, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178896
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178897
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178898
  00039	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178899
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_value_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_read_error_ PROC

; 824  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     // "SR: error in function '%s': '%s'"
; 826  :     WRMSG(HHC02001, "E", "read()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178884
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178885
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178886
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178887
  00062	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178888
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_read_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_write_error_ PROC

; 818  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 819  :     // "SR: error in function '%s': '%s'"
; 820  :     WRMSG(HHC02001, "E", "write()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178878
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178879
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178880
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178881
  00062	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178882
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 821  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_write_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tot$ = 32
siz$ = 40
tv74 = 48
buf$ = 64
__$ArrayPad$ = 320
file$ = 352
len$ = 360
sr_read_skip PROC

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_sk:

; 678  : /* FIXME: Workaround for problem involving gzseek
; 679  :           and large files.  Just read the data. */
; 680  : 
; 681  : BYTE    buf[SR_SKIP_CHUNKSIZE];
; 682  : size_t  siz;
; 683  : size_t  tot;
; 684  : 
; 685  :     TRACE("SR: sr_read_skip:                  len=0x%8.8x\n", len);

  00022	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178790
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003c	85 c0		 test	 eax, eax
  0003e	74 13		 je	 SHORT $LN7@sr_read_sk
  00040	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178792
  0004e	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_sk:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 c9		 jne	 SHORT $LN4@sr_read_sk

; 686  : 
; 687  :     tot = len;

  00059	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax
$LN5@sr_read_sk:

; 688  : 
; 689  :     while (tot)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0006b	74 71		 je	 SHORT $LN6@sr_read_sk

; 690  :     {
; 691  :         siz = tot < SR_SKIP_CHUNKSIZE ? tot : SR_SKIP_CHUNKSIZE;

  0006d	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR tot$[rsp], 256 ; 00000100H
  00076	73 0c		 jae	 SHORT $LN10@sr_read_sk
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tot$[rsp]
  0007d	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00082	eb 09		 jmp	 SHORT $LN11@sr_read_sk
$LN10@sr_read_sk:
  00084	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR tv74[rsp], 256 ; 00000100H
$LN11@sr_read_sk:
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR siz$[rsp], rax

; 692  : 
; 693  :         if ((size_t)SR_READ(buf, 1, siz, file) != siz)

  00097	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR siz$[rsp]
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000b4	48 3b 44 24 28	 cmp	 rax, QWORD PTR siz$[rsp]
  000b9	74 0c		 je	 SHORT $LN8@sr_read_sk

; 694  :         {
; 695  :             sr_read_error_();

  000bb	e8 00 00 00 00	 call	 sr_read_error_

; 696  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 19		 jmp	 SHORT $LN1@sr_read_sk
$LN8@sr_read_sk:

; 697  :         }
; 698  :         tot -= siz;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR siz$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tot$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax

; 699  :     }

  000dc	eb 87		 jmp	 SHORT $LN5@sr_read_sk
$LN6@sr_read_sk:

; 700  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN1@sr_read_sk:

; 701  : }

  000e0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000f7	c3		 ret	 0
sr_read_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
file$ = 48
p$ = 56
len$ = 64
sr_read_string PROC

; 707  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@sr_read_st:

; 708  :     TRACE("SR: sr_read_string:                len=0x%8.8x\n", len);

  00013	8b 54 24 40	 mov	 edx, DWORD PTR len$[rsp]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178805
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0002a	85 c0		 test	 eax, eax
  0002c	74 10		 je	 SHORT $LN5@sr_read_st
  0002e	8b 54 24 40	 mov	 edx, DWORD PTR len$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178807
  00039	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_read_st:
  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 cf		 jne	 SHORT $LN4@sr_read_st

; 709  : 
; 710  :     if (len > SR_MAX_STRING_LENGTH)

  00044	81 7c 24 40 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  0004c	76 0c		 jbe	 SHORT $LN6@sr_read_st

; 711  :     {
; 712  :         sr_string_error_();

  0004e	e8 00 00 00 00	 call	 sr_string_error_

; 713  :         return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	eb 30		 jmp	 SHORT $LN1@sr_read_st
$LN6@sr_read_st:

; 714  :     }
; 715  :     if ((U32)SR_READ(p, 1, len, file) != len)

  0005a	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]
  0005e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR file$[rsp]
  00063	44 8b c0	 mov	 r8d, eax
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00076	3b 44 24 40	 cmp	 eax, DWORD PTR len$[rsp]
  0007a	74 0c		 je	 SHORT $LN7@sr_read_st

; 716  :     {
; 717  :         sr_read_error_();

  0007c	e8 00 00 00 00	 call	 sr_read_error_

; 718  :         return -1;

  00081	b8 ff ff ff ff	 mov	 eax, -1
  00086	eb 02		 jmp	 SHORT $LN1@sr_read_st
$LN7@sr_read_st:

; 719  :     }
; 720  :     return 0;

  00088	33 c0		 xor	 eax, eax
$LN1@sr_read_st:

; 721  : }

  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	c3		 ret	 0
sr_read_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
value$ = 32
tv85 = 40
tv146 = 44
ptr$1 = 48
ptr$2 = 56
ptr$3 = 64
ptr$4 = 72
buf$ = 80
__$ArrayPad$ = 88
file$ = 112
suslen$ = 120
p$ = 128
reslen$ = 136
sr_read_value PROC

; 754  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_va:

; 755  : BYTE    buf[8];
; 756  : U64     value;
; 757  : 
; 758  :     TRACE("SR: sr_read_value:              suslen=0x%8.8x, reslen=0x%8.8x,\n", suslen, reslen);

  00026	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  0002e	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178860
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00045	85 c0		 test	 eax, eax
  00047	74 18		 je	 SHORT $LN12@sr_read_va
  00049	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  00051	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178862
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@sr_read_va:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 bf		 jne	 SHORT $LN4@sr_read_va

; 759  : 
; 760  :     if (suslen != 1 && suslen != 2 && suslen != 4 && suslen != 8)

  00067	83 7c 24 78 01	 cmp	 DWORD PTR suslen$[rsp], 1
  0006c	74 24		 je	 SHORT $LN13@sr_read_va
  0006e	83 7c 24 78 02	 cmp	 DWORD PTR suslen$[rsp], 2
  00073	74 1d		 je	 SHORT $LN13@sr_read_va
  00075	83 7c 24 78 04	 cmp	 DWORD PTR suslen$[rsp], 4
  0007a	74 16		 je	 SHORT $LN13@sr_read_va
  0007c	83 7c 24 78 08	 cmp	 DWORD PTR suslen$[rsp], 8
  00081	74 0f		 je	 SHORT $LN13@sr_read_va

; 761  :     {
; 762  :         sr_value_error_();

  00083	e8 00 00 00 00	 call	 sr_value_error_

; 763  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a8 01 00 00	 jmp	 $LN1@sr_read_va
$LN13@sr_read_va:

; 764  :     }
; 765  : 
; 766  :     if ((U32)SR_READ(buf, 1, suslen, file) != suslen)

  00092	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  00096	4c 8b 4c 24 70	 mov	 r9, QWORD PTR file$[rsp]
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000ae	3b 44 24 78	 cmp	 eax, DWORD PTR suslen$[rsp]
  000b2	74 0f		 je	 SHORT $LN14@sr_read_va

; 767  :     {
; 768  :         sr_read_error_();

  000b4	e8 00 00 00 00	 call	 sr_read_error_

; 769  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 77 01 00 00	 jmp	 $LN1@sr_read_va
$LN14@sr_read_va:

; 770  :     }
; 771  : 
; 772  :     switch (suslen)

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  000c7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  000cb	83 7c 24 28 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d0	74 17		 je	 SHORT $LN15@sr_read_va
  000d2	83 7c 24 28 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 25		 je	 SHORT $LN16@sr_read_va
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 3a		 je	 SHORT $LN17@sr_read_va
  000e0	83 7c 24 28 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 4d		 je	 SHORT $LN18@sr_read_va
  000e7	eb 64		 jmp	 SHORT $LN19@sr_read_va
$LN15@sr_read_va:

; 773  :     {
; 774  :         case 1:  value = buf[0];         break;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  000f7	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000fc	eb 58		 jmp	 SHORT $LN5@sr_read_va
$LN16@sr_read_va:

; 775  :         case 2:  value = fetch_hw (buf); break;

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_hw_noswap
  00108	0f b7 c8	 movzx	 ecx, ax
  0010b	e8 00 00 00 00	 call	 _byteswap_ushort
  00110	0f b7 c0	 movzx	 eax, ax
  00113	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00118	eb 3c		 jmp	 SHORT $LN5@sr_read_va
$LN17@sr_read_va:

; 776  :         case 4:  value = fetch_fw (buf); break;

  0011a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 _byteswap_ulong
  0012b	8b c0		 mov	 eax, eax
  0012d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00132	eb 22		 jmp	 SHORT $LN5@sr_read_va
$LN18@sr_read_va:

; 777  :         case 8:  value = fetch_dw (buf); break;

  00134	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 _byteswap_uint64
  00146	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0014b	eb 09		 jmp	 SHORT $LN5@sr_read_va
$LN19@sr_read_va:

; 778  :         default: value = 0;              break; /* To ward off gcc -Wall */

  0014d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0
$LN5@sr_read_va:
$LN9@sr_read_va:

; 779  :     }
; 780  : 
; 781  :     TRACE("                           val=0x%16.16"PRIx64"\n", value);

  00156	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178870
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016e	85 c0		 test	 eax, eax
  00170	74 11		 je	 SHORT $LN20@sr_read_va
  00172	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178872
  0017e	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@sr_read_va:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 cd		 jne	 SHORT $LN9@sr_read_va

; 782  : 
; 783  :     switch (reslen)

  00189	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reslen$[rsp]
  00190	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00194	83 7c 24 2c 01	 cmp	 DWORD PTR tv146[rsp], 1
  00199	74 1a		 je	 SHORT $LN21@sr_read_va
  0019b	83 7c 24 2c 02	 cmp	 DWORD PTR tv146[rsp], 2
  001a0	74 34		 je	 SHORT $LN22@sr_read_va
  001a2	83 7c 24 2c 04	 cmp	 DWORD PTR tv146[rsp], 4
  001a7	74 4f		 je	 SHORT $LN23@sr_read_va
  001a9	83 7c 24 2c 08	 cmp	 DWORD PTR tv146[rsp], 8
  001ae	74 6e		 je	 SHORT $LN24@sr_read_va
  001b0	e9 83 00 00 00	 jmp	 $LN10@sr_read_va
$LN21@sr_read_va:

; 784  :     {
; 785  :         case 1:
; 786  :         {
; 787  :             BYTE* ptr = p;

  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR ptr$1[rsp], rax

; 788  :             *ptr = (BYTE)(value & 0xFF);

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001c7	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$1[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al

; 789  :             break;

  001d4	eb 62		 jmp	 SHORT $LN10@sr_read_va
$LN22@sr_read_va:

; 790  :         }
; 791  :         case 2:
; 792  :         {
; 793  :             U16* ptr = p;

  001d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001de	48 89 44 24 38	 mov	 QWORD PTR ptr$2[rsp], rax

; 794  :             *ptr = (U16)(value & 0xFFFF);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$2[rsp]
  001f3	66 89 01	 mov	 WORD PTR [rcx], ax

; 795  :             break;

  001f6	eb 40		 jmp	 SHORT $LN10@sr_read_va
$LN23@sr_read_va:

; 796  :         }
; 797  :         case 4:
; 798  :         {
; 799  :             U32* ptr = p;

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00200	48 89 44 24 40	 mov	 QWORD PTR ptr$3[rsp], rax

; 800  :             *ptr = (U32)(value & 0xFFFFFFFF);

  00205	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0020a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0020f	48 23 c8	 and	 rcx, rax
  00212	48 8b c1	 mov	 rax, rcx
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$3[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 801  :             break;

  0021c	eb 1a		 jmp	 SHORT $LN10@sr_read_va
$LN24@sr_read_va:

; 802  :         }
; 803  :         case 8:
; 804  :         {
; 805  :             U64* ptr = p;

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR ptr$4[rsp], rax

; 806  :             *ptr = (U64)(value & 0xFFFFFFFFFFFFFFFFULL);

  0022b	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$4[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00235	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@sr_read_va:

; 807  :             break;
; 808  :         }
; 809  :     }
; 810  :     return 0;

  00238	33 c0		 xor	 eax, eax
$LN1@sr_read_va:

; 811  : }

  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024b	c3		 ret	 0
sr_read_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_read_hdr PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : BYTE  buf[8];
; 658  : 
; 659  :     if (SR_READ(buf, 1, 8, file) != 8)

  00022	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  00027	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0003d	48 83 f8 08	 cmp	 rax, 8
  00041	74 0c		 je	 SHORT $LN5@sr_read_hd

; 660  :     {
; 661  :         sr_read_error_();

  00043	e8 00 00 00 00	 call	 sr_read_error_

; 662  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	eb 7c		 jmp	 SHORT $LN1@sr_read_hd
$LN5@sr_read_hd:

; 663  :     }
; 664  : 
; 665  :     *key = fetch_fw (buf);

  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00054	e8 00 00 00 00	 call	 fetch_fw_noswap
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 _byteswap_ulong
  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00065	89 01		 mov	 DWORD PTR [rcx], eax

; 666  :     *len = fetch_fw (buf+4);

  00067	48 8d 44 24 24	 lea	 rax, QWORD PTR buf$[rsp+4]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@sr_read_hd:

; 667  : 
; 668  :     TRACE("SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x\n", *key, *len);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00087	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008f	8b 10		 mov	 edx, DWORD PTR [rax]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178773
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN6@sr_read_hd
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000b5	8b 10		 mov	 edx, DWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178775
  000be	e8 00 00 00 00	 call	 DebuggerTrace
$LN6@sr_read_hd:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 b9		 jne	 SHORT $LN4@sr_read_hd

; 669  : 
; 670  :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN1@sr_read_hd:

; 671  : }

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
sr_read_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
len$ = 32
file$ = 64
key$ = 72
str$ = 80
sr_write_string PROC

; 566  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 567  : size_t len = strlen(str) + 1;

  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00017	e8 00 00 00 00	 call	 strlen
  0001c	48 ff c0	 inc	 rax
  0001f	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
$LN4@sr_write_s:

; 568  : 
; 569  :     TRACE("SR: sr_write_string: key=0x%8.8x\n", key);

  00024	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178702
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003b	85 c0		 test	 eax, eax
  0003d	74 10		 je	 SHORT $LN5@sr_write_s
  0003f	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178704
  0004a	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_s:
  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 cf		 jne	 SHORT $LN4@sr_write_s

; 570  : 
; 571  :     if (len > SR_MAX_STRING_LENGTH)

  00055	48 81 7c 24 20
	00 10 00 00	 cmp	 QWORD PTR len$[rsp], 4096 ; 00001000H
  0005e	76 0c		 jbe	 SHORT $LN6@sr_write_s

; 572  :     {
; 573  :         sr_string_error_();

  00060	e8 00 00 00 00	 call	 sr_string_error_

; 574  :         return -1;

  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	eb 4d		 jmp	 SHORT $LN1@sr_write_s
$LN6@sr_write_s:

; 575  :     }
; 576  : 
; 577  :     if (sr_write_hdr(file, key, (U32)len) != 0)

  0006c	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00071	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0007a	e8 00 00 00 00	 call	 sr_write_hdr
  0007f	85 c0		 test	 eax, eax
  00081	74 07		 je	 SHORT $LN7@sr_write_s

; 578  :         return -1;

  00083	b8 ff ff ff ff	 mov	 eax, -1
  00088	eb 2f		 jmp	 SHORT $LN1@sr_write_s
$LN7@sr_write_s:

; 579  : 
; 580  :     if ((size_t)SR_WRITE(str, 1, len, file) != len)

  0008a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008f	4c 8b 44 24 20	 mov	 r8, QWORD PTR len$[rsp]
  00094	ba 01 00 00 00	 mov	 edx, 1
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a4	48 3b 44 24 20	 cmp	 rax, QWORD PTR len$[rsp]
  000a9	74 0c		 je	 SHORT $LN8@sr_write_s

; 581  :     {
; 582  :         sr_write_error_();

  000ab	e8 00 00 00 00	 call	 sr_write_error_

; 583  :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 02		 jmp	 SHORT $LN1@sr_write_s
$LN8@sr_write_s:

; 584  :     }
; 585  :     return 0;

  000b7	33 c0		 xor	 eax, eax
$LN1@sr_write_s:

; 586  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
sr_write_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv84 = 32
buf$ = 40
__$ArrayPad$ = 48
file$ = 80
key$ = 88
val$ = 96
len$ = 104
sr_write_value PROC

; 622  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_v:

; 623  : BYTE    buf[8];
; 624  : 
; 625  :     TRACE("SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16.16"PRIx64"\n", key, len, val);

  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178751
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN7@sr_write_v
  0004b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  00050	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00055	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178753
  00060	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_write_v:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 bb		 jne	 SHORT $LN4@sr_write_v

; 626  : 
; 627  :     if (len != 1 && len != 2 && len != 4 && len != 8)

  0006b	83 7c 24 68 01	 cmp	 DWORD PTR len$[rsp], 1
  00070	74 24		 je	 SHORT $LN8@sr_write_v
  00072	83 7c 24 68 02	 cmp	 DWORD PTR len$[rsp], 2
  00077	74 1d		 je	 SHORT $LN8@sr_write_v
  00079	83 7c 24 68 04	 cmp	 DWORD PTR len$[rsp], 4
  0007e	74 16		 je	 SHORT $LN8@sr_write_v
  00080	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00085	74 0f		 je	 SHORT $LN8@sr_write_v

; 628  :     {
; 629  :         sr_value_error_();

  00087	e8 00 00 00 00	 call	 sr_value_error_

; 630  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 d2 00 00 00	 jmp	 $LN1@sr_write_v
$LN8@sr_write_v:

; 631  :     }
; 632  : 
; 633  :     if (sr_write_hdr(file, key, len) != 0)

  00096	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a4	e8 00 00 00 00	 call	 sr_write_hdr
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN9@sr_write_v

; 634  :         return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	e9 b1 00 00 00	 jmp	 $LN1@sr_write_v
$LN9@sr_write_v:

; 635  : 
; 636  :     switch (len)

  000b7	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  000bf	83 7c 24 20 01	 cmp	 DWORD PTR tv84[rsp], 1
  000c4	74 17		 je	 SHORT $LN10@sr_write_v
  000c6	83 7c 24 20 02	 cmp	 DWORD PTR tv84[rsp], 2
  000cb	74 24		 je	 SHORT $LN11@sr_write_v
  000cd	83 7c 24 20 04	 cmp	 DWORD PTR tv84[rsp], 4
  000d2	74 36		 je	 SHORT $LN12@sr_write_v
  000d4	83 7c 24 20 08	 cmp	 DWORD PTR tv84[rsp], 8
  000d9	74 46		 je	 SHORT $LN13@sr_write_v
  000db	eb 5b		 jmp	 SHORT $LN5@sr_write_v
$LN10@sr_write_v:

; 637  :     {
; 638  :         case 1: buf[0]     =  (BYTE)val;  break;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  000eb	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000ef	eb 47		 jmp	 SHORT $LN5@sr_write_v
$LN11@sr_write_v:

; 639  :         case 2: store_hw (buf, (U16)val); break;

  000f1	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 store_hw_noswap
  00108	eb 2e		 jmp	 SHORT $LN5@sr_write_v
$LN12@sr_write_v:

; 640  :         case 4: store_fw (buf, (U32)val); break;

  0010a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	8b d0		 mov	 edx, eax
  00115	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 store_fw_noswap
  0011f	eb 17		 jmp	 SHORT $LN5@sr_write_v
$LN13@sr_write_v:

; 641  :         case 8: store_dw (buf, (U64)val); break;

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR val$[rsp]
  00126	e8 00 00 00 00	 call	 _byteswap_uint64
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00133	e8 00 00 00 00	 call	 store_dw_noswap
$LN5@sr_write_v:

; 642  :     }
; 643  : 
; 644  :     if ((U32)SR_WRITE(buf, 1, len, file) != len)

  00138	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0013c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00141	44 8b c0	 mov	 r8d, eax
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00154	3b 44 24 68	 cmp	 eax, DWORD PTR len$[rsp]
  00158	74 0c		 je	 SHORT $LN14@sr_write_v

; 645  :     {
; 646  :         sr_write_error_();

  0015a	e8 00 00 00 00	 call	 sr_write_error_

; 647  :         return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 02		 jmp	 SHORT $LN1@sr_write_v
$LN14@sr_write_v:

; 648  :     }
; 649  :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@sr_write_v:

; 650  : }

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
sr_write_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_write_hdr PROC

; 546  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_h:

; 547  : BYTE  buf[8];
; 548  : 
; 549  :     TRACE("SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x\n", key, len);

  00021	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00026	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178685
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN5@sr_write_h
  00041	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00046	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178687
  00051	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_h:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 c5		 jne	 SHORT $LN4@sr_write_h

; 550  : 
; 551  :     store_fw (buf, key);

  0005c	8b 4c 24 48	 mov	 ecx, DWORD PTR key$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	e8 00 00 00 00	 call	 store_fw_noswap

; 552  :     store_fw (buf+4, len);

  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR buf$[rsp+4]
  0007f	8b d0		 mov	 edx, eax
  00081	e8 00 00 00 00	 call	 store_fw_noswap

; 553  : 
; 554  :     if (SR_WRITE(buf, 1, 8, file) != 8)

  00086	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a1	48 83 f8 08	 cmp	 rax, 8
  000a5	74 0c		 je	 SHORT $LN6@sr_write_h

; 555  :     {
; 556  :         sr_write_error_();

  000a7	e8 00 00 00 00	 call	 sr_write_error_

; 557  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 02		 jmp	 SHORT $LN1@sr_write_h
$LN6@sr_write_h:

; 558  :     }
; 559  :     return 0;

  000b3	33 c0		 xor	 eax, eax
$LN1@sr_write_h:

; 560  : }

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
sr_write_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
k$1 = 32
l$2 = 36
len$ = 40
tv72 = 48
key$ = 56
file$ = 80
servc_hresume PROC

; 1064 : {

$LN59:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1065 :     size_t key, len;
; 1066 : 
; 1067 :     sclp_reset();

  00009	e8 00 00 00 00	 call	 sclp_reset
$LN4@servc_hres:
$LN7@servc_hres:

; 1068 :     do {
; 1069 :         SR_READ_HDR(file, key, len);

  0000e	4c 8d 44 24 24	 lea	 r8, QWORD PTR l$2[rsp]
  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR k$1[rsp]
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  0001d	e8 00 00 00 00	 call	 sr_read_hdr
  00022	85 c0		 test	 eax, eax
  00024	74 0a		 je	 SHORT $LN37@servc_hres
  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	e9 2a 02 00 00	 jmp	 $LN1@servc_hres
$LN37@servc_hres:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR k$1[rsp]
  00034	48 89 44 24 38	 mov	 QWORD PTR key$[rsp], rax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR l$2[rsp]
  0003d	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  00042	33 c0		 xor	 eax, eax
  00044	85 c0		 test	 eax, eax
  00046	75 c6		 jne	 SHORT $LN7@servc_hres

; 1070 :         switch (key) {

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR key$[rsp]
  0004d	48 89 44 24 30	 mov	 QWORD PTR tv72[rsp], rax
  00052	b8 01 10 e1 ac	 mov	 eax, -1394536447	; ace11001H
  00057	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv72[rsp]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 89 44 24 30	 mov	 QWORD PTR tv72[rsp], rax
  00067	48 83 7c 24 30
	06		 cmp	 QWORD PTR tv72[rsp], 6
  0006d	0f 87 a8 01 00
	00		 ja	 $LN55@servc_hres
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv72[rsp]
  0007f	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN58@servc_hres[rax+rcx*4]
  00086	48 03 c8	 add	 rcx, rax
  00089	ff e1		 jmp	 rcx
$LN38@servc_hres:
$LN12@servc_hres:

; 1071 :         case SR_SYS_SERVC_RECVMASK:
; 1072 :             SR_READ_VALUE(file, len, &servc_cp_recv_mask, sizeof( servc_cp_recv_mask ));

  0008b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00091	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_cp_recv_mask
  00098	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a1	e8 00 00 00 00	 call	 sr_read_value
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN39@servc_hres
  000aa	b8 ff ff ff ff	 mov	 eax, -1
  000af	e9 a6 01 00 00	 jmp	 $LN1@servc_hres
$LN39@servc_hres:
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 d1		 jne	 SHORT $LN12@servc_hres

; 1073 :             break;

  000ba	e9 7b 01 00 00	 jmp	 $LN8@servc_hres
$LN40@servc_hres:
$LN15@servc_hres:

; 1074 :         case SR_SYS_SERVC_SENDMASK:
; 1075 :             SR_READ_VALUE(file, len, &servc_cp_send_mask, sizeof( servc_cp_send_mask ));

  000bf	41 b9 04 00 00
	00		 mov	 r9d, 4
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_cp_send_mask
  000cc	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  000d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000d5	e8 00 00 00 00	 call	 sr_read_value
  000da	85 c0		 test	 eax, eax
  000dc	74 0a		 je	 SHORT $LN41@servc_hres
  000de	b8 ff ff ff ff	 mov	 eax, -1
  000e3	e9 72 01 00 00	 jmp	 $LN1@servc_hres
$LN41@servc_hres:
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	75 d1		 jne	 SHORT $LN15@servc_hres

; 1076 :             break;

  000ee	e9 47 01 00 00	 jmp	 $LN8@servc_hres
$LN42@servc_hres:
$LN18@servc_hres:

; 1077 :         case SR_SYS_SERVC_PENDING:
; 1078 :             SR_READ_VALUE(file, len, &servc_attn_pending, sizeof( servc_attn_pending ));

  000f3	41 b9 04 00 00
	00		 mov	 r9d, 4
  000f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_attn_pending
  00100	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00104	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00109	e8 00 00 00 00	 call	 sr_read_value
  0010e	85 c0		 test	 eax, eax
  00110	74 0a		 je	 SHORT $LN43@servc_hres
  00112	b8 ff ff ff ff	 mov	 eax, -1
  00117	e9 3e 01 00 00	 jmp	 $LN1@servc_hres
$LN43@servc_hres:
  0011c	33 c0		 xor	 eax, eax
  0011e	85 c0		 test	 eax, eax
  00120	75 d1		 jne	 SHORT $LN18@servc_hres

; 1079 :             break;

  00122	e9 13 01 00 00	 jmp	 $LN8@servc_hres
$LN44@servc_hres:

; 1080 :         case SR_SYS_SERVC_SCPCMD:
; 1081 :             if ( len <= sizeof( servc_scpcmdstr ) )

  00127	48 83 7c 24 28
	7c		 cmp	 QWORD PTR len$[rsp], 124 ; 0000007cH
  0012d	77 2c		 ja	 SHORT $LN45@servc_hres
$LN21@servc_hres:

; 1082 :                 SR_READ_STRING(file, servc_scpcmdstr, len);

  0012f	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$[rsp]
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:servc_scpcmdstr
  0013b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00140	e8 00 00 00 00	 call	 sr_read_string
  00145	85 c0		 test	 eax, eax
  00147	74 0a		 je	 SHORT $LN47@servc_hres
  00149	b8 ff ff ff ff	 mov	 eax, -1
  0014e	e9 07 01 00 00	 jmp	 $LN1@servc_hres
$LN47@servc_hres:
  00153	33 c0		 xor	 eax, eax
  00155	85 c0		 test	 eax, eax
  00157	75 d6		 jne	 SHORT $LN21@servc_hres
  00159	eb 22		 jmp	 SHORT $LN46@servc_hres
$LN45@servc_hres:
$LN24@servc_hres:

; 1083 :             else
; 1084 :                 SR_READ_SKIP(file, len);

  0015b	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00164	e8 00 00 00 00	 call	 sr_read_skip
  00169	85 c0		 test	 eax, eax
  0016b	74 0a		 je	 SHORT $LN48@servc_hres
  0016d	b8 ff ff ff ff	 mov	 eax, -1
  00172	e9 e3 00 00 00	 jmp	 $LN1@servc_hres
$LN48@servc_hres:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 de		 jne	 SHORT $LN24@servc_hres
$LN46@servc_hres:

; 1085 :             break;

  0017d	e9 b8 00 00 00	 jmp	 $LN8@servc_hres
$LN49@servc_hres:
$LN27@servc_hres:

; 1086 :         case SR_SYS_SERVC_SQC:
; 1087 :             SR_READ_VALUE(file, len, &servc_signal_quiesce_count,

  00182	41 b9 02 00 00
	00		 mov	 r9d, 2
  00188	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_signal_quiesce_count
  0018f	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00193	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00198	e8 00 00 00 00	 call	 sr_read_value
  0019d	85 c0		 test	 eax, eax
  0019f	74 0a		 je	 SHORT $LN50@servc_hres
  001a1	b8 ff ff ff ff	 mov	 eax, -1
  001a6	e9 af 00 00 00	 jmp	 $LN1@servc_hres
$LN50@servc_hres:
  001ab	33 c0		 xor	 eax, eax
  001ad	85 c0		 test	 eax, eax
  001af	75 d1		 jne	 SHORT $LN27@servc_hres

; 1088 :                               sizeof( servc_signal_quiesce_count ));
; 1089 :             break;

  001b1	e9 84 00 00 00	 jmp	 $LN8@servc_hres
$LN51@servc_hres:
$LN30@servc_hres:

; 1090 :         case SR_SYS_SERVC_SQU:
; 1091 :             SR_READ_VALUE(file, len, &servc_signal_quiesce_unit,

  001b6	41 b9 01 00 00
	00		 mov	 r9d, 1
  001bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_signal_quiesce_unit
  001c3	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  001cc	e8 00 00 00 00	 call	 sr_read_value
  001d1	85 c0		 test	 eax, eax
  001d3	74 07		 je	 SHORT $LN52@servc_hres
  001d5	b8 ff ff ff ff	 mov	 eax, -1
  001da	eb 7e		 jmp	 SHORT $LN1@servc_hres
$LN52@servc_hres:
  001dc	33 c0		 xor	 eax, eax
  001de	85 c0		 test	 eax, eax
  001e0	75 d4		 jne	 SHORT $LN30@servc_hres

; 1092 :                               sizeof( servc_signal_quiesce_unit ));
; 1093 :             break;

  001e2	eb 56		 jmp	 SHORT $LN8@servc_hres
$LN53@servc_hres:
$LN33@servc_hres:

; 1094 :         case SR_SYS_SERVC_PARM:
; 1095 :             SR_READ_VALUE(file, len, &sysblk.servparm, sizeof(sysblk.servparm));

  001e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001eb	48 05 90 12 00
	00		 add	 rax, 4752		; 00001290H
  001f1	41 b9 04 00 00
	00		 mov	 r9d, 4
  001f7	4c 8b c0	 mov	 r8, rax
  001fa	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  001fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00203	e8 00 00 00 00	 call	 sr_read_value
  00208	85 c0		 test	 eax, eax
  0020a	74 07		 je	 SHORT $LN54@servc_hres
  0020c	b8 ff ff ff ff	 mov	 eax, -1
  00211	eb 47		 jmp	 SHORT $LN1@servc_hres
$LN54@servc_hres:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	75 cb		 jne	 SHORT $LN33@servc_hres

; 1096 :             break;

  00219	eb 1f		 jmp	 SHORT $LN8@servc_hres
$LN55@servc_hres:
$LN36@servc_hres:

; 1097 :         default:
; 1098 :             SR_READ_SKIP(file, len);

  0021b	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0021f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00224	e8 00 00 00 00	 call	 sr_read_skip
  00229	85 c0		 test	 eax, eax
  0022b	74 07		 je	 SHORT $LN56@servc_hres
  0022d	b8 ff ff ff ff	 mov	 eax, -1
  00232	eb 26		 jmp	 SHORT $LN1@servc_hres
$LN56@servc_hres:
  00234	33 c0		 xor	 eax, eax
  00236	85 c0		 test	 eax, eax
  00238	75 e1		 jne	 SHORT $LN36@servc_hres
$LN8@servc_hres:

; 1099 :             break;
; 1100 :         }
; 1101 :     } while ((key & SR_SYS_MASK) == SR_SYS_SERVC);

  0023a	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  0023f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00244	48 23 c8	 and	 rcx, rax
  00247	48 8b c1	 mov	 rax, rcx
  0024a	b9 00 10 e1 ac	 mov	 ecx, -1394536448	; ace11000H
  0024f	48 3b c1	 cmp	 rax, rcx
  00252	0f 84 b6 fd ff
	ff		 je	 $LN4@servc_hres

; 1102 :     return 0;

  00258	33 c0		 xor	 eax, eax
$LN1@servc_hres:

; 1103 : }

  0025a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0025e	c3		 ret	 0
  0025f	90		 npad	 1
$LN58@servc_hres:
  00260	00 00 00 00	 DD	 $LN38@servc_hres
  00264	00 00 00 00	 DD	 $LN40@servc_hres
  00268	00 00 00 00	 DD	 $LN42@servc_hres
  0026c	00 00 00 00	 DD	 $LN44@servc_hres
  00270	00 00 00 00	 DD	 $LN49@servc_hres
  00274	00 00 00 00	 DD	 $LN51@servc_hres
  00278	00 00 00 00	 DD	 $LN53@servc_hres
servc_hresume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
file$ = 48
servc_hsuspend PROC

; 1047 : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@servc_hsus:

; 1048 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_RECVMASK, servc_cp_recv_mask, sizeof( servc_cp_recv_mask ));

  00009	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  0000f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00015	44 8b c0	 mov	 r8d, eax
  00018	ba 01 10 e1 ac	 mov	 edx, -1394536447	; ace11001H
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00022	e8 00 00 00 00	 call	 sr_write_value
  00027	85 c0		 test	 eax, eax
  00029	74 0a		 je	 SHORT $LN23@servc_hsus
  0002b	b8 ff ff ff ff	 mov	 eax, -1
  00030	e9 2c 01 00 00	 jmp	 $LN1@servc_hsus
$LN23@servc_hsus:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 ce		 jne	 SHORT $LN4@servc_hsus
$LN7@servc_hsus:

; 1049 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_SENDMASK, servc_cp_send_mask, sizeof( servc_cp_send_mask ));

  0003b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_send_mask
  00041	41 b9 04 00 00
	00		 mov	 r9d, 4
  00047	44 8b c0	 mov	 r8d, eax
  0004a	ba 02 10 e1 ac	 mov	 edx, -1394536446	; ace11002H
  0004f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00054	e8 00 00 00 00	 call	 sr_write_value
  00059	85 c0		 test	 eax, eax
  0005b	74 0a		 je	 SHORT $LN24@servc_hsus
  0005d	b8 ff ff ff ff	 mov	 eax, -1
  00062	e9 fa 00 00 00	 jmp	 $LN1@servc_hsus
$LN24@servc_hsus:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 ce		 jne	 SHORT $LN7@servc_hsus
$LN10@servc_hsus:

; 1050 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_PENDING, servc_attn_pending, sizeof( servc_attn_pending ));

  0006d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_attn_pending
  00073	41 b9 04 00 00
	00		 mov	 r9d, 4
  00079	44 8b c0	 mov	 r8d, eax
  0007c	ba 03 10 e1 ac	 mov	 edx, -1394536445	; ace11003H
  00081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00086	e8 00 00 00 00	 call	 sr_write_value
  0008b	85 c0		 test	 eax, eax
  0008d	74 0a		 je	 SHORT $LN25@servc_hsus
  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 c8 00 00 00	 jmp	 $LN1@servc_hsus
$LN25@servc_hsus:
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 ce		 jne	 SHORT $LN10@servc_hsus
$LN13@servc_hsus:

; 1051 :     SR_WRITE_STRING(file, SR_SYS_SERVC_SCPCMD,  servc_scpcmdstr);

  0009f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:servc_scpcmdstr
  000a6	ba 04 10 e1 ac	 mov	 edx, -1394536444	; ace11004H
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  000b0	e8 00 00 00 00	 call	 sr_write_string
  000b5	85 c0		 test	 eax, eax
  000b7	74 0a		 je	 SHORT $LN26@servc_hsus
  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 9e 00 00 00	 jmp	 $LN1@servc_hsus
$LN26@servc_hsus:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 d6		 jne	 SHORT $LN13@servc_hsus
$LN16@servc_hsus:

; 1052 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_SQC,      servc_signal_quiesce_count,

  000c9	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR servc_signal_quiesce_count
  000d0	41 b9 02 00 00
	00		 mov	 r9d, 2
  000d6	44 8b c0	 mov	 r8d, eax
  000d9	ba 05 10 e1 ac	 mov	 edx, -1394536443	; ace11005H
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  000e3	e8 00 00 00 00	 call	 sr_write_value
  000e8	85 c0		 test	 eax, eax
  000ea	74 07		 je	 SHORT $LN27@servc_hsus
  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	eb 6e		 jmp	 SHORT $LN1@servc_hsus
$LN27@servc_hsus:
  000f3	33 c0		 xor	 eax, eax
  000f5	85 c0		 test	 eax, eax
  000f7	75 d0		 jne	 SHORT $LN16@servc_hsus
$LN19@servc_hsus:

; 1053 :                                          sizeof( servc_signal_quiesce_count ));
; 1054 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_SQU,      servc_signal_quiesce_unit,

  000f9	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR servc_signal_quiesce_unit
  00100	41 b9 01 00 00
	00		 mov	 r9d, 1
  00106	44 8b c0	 mov	 r8d, eax
  00109	ba 06 10 e1 ac	 mov	 edx, -1394536442	; ace11006H
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00113	e8 00 00 00 00	 call	 sr_write_value
  00118	85 c0		 test	 eax, eax
  0011a	74 07		 je	 SHORT $LN28@servc_hsus
  0011c	b8 ff ff ff ff	 mov	 eax, -1
  00121	eb 3e		 jmp	 SHORT $LN1@servc_hsus
$LN28@servc_hsus:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	75 d0		 jne	 SHORT $LN19@servc_hsus
$LN22@servc_hsus:

; 1055 :                                          sizeof( servc_signal_quiesce_unit ));
; 1056 :     SR_WRITE_VALUE(file, SR_SYS_SERVC_PARM,     sysblk.servparm,

  00129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00130	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00136	41 b9 04 00 00
	00		 mov	 r9d, 4
  0013c	44 8b c0	 mov	 r8d, eax
  0013f	ba 07 10 e1 ac	 mov	 edx, -1394536441	; ace11007H
  00144	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00149	e8 00 00 00 00	 call	 sr_write_value
  0014e	85 c0		 test	 eax, eax
  00150	74 07		 je	 SHORT $LN29@servc_hsus
  00152	b8 ff ff ff ff	 mov	 eax, -1
  00157	eb 08		 jmp	 SHORT $LN1@servc_hsus
$LN29@servc_hsus:
  00159	33 c0		 xor	 eax, eax
  0015b	85 c0		 test	 eax, eax
  0015d	75 ca		 jne	 SHORT $LN22@servc_hsus

; 1057 :                                          sizeof(sysblk.servparm));
; 1058 :     return 0;

  0015f	33 c0		 xor	 eax, eax
$LN1@servc_hsus:

; 1059 : }

  00161	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00165	c3		 ret	 0
servc_hsuspend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
sclp_sysg_attention PROC

; 969  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 970  : 
; 971  :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179309
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 972  :     {
; 973  :         sclp_attn_async( SCCB_EVD_TYPE_SYSG );

  00012	66 b9 1b 00	 mov	 cx, 27
  00016	e8 00 00 00 00	 call	 sclp_attn_async

; 974  :     }
; 975  :     RELEASE_INTLOCK( NULL );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179310
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 976  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
sclp_sysg_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
sclp_reset PROC

; 280  :     servc_cp_recv_mask = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR servc_cp_recv_mask, 0

; 281  :     servc_cp_send_mask = 0;

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR servc_cp_send_mask, 0

; 282  :     servc_attn_pending = 0;

  00014	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR servc_attn_pending, 0

; 283  :     servc_signal_quiesce_count = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 05 00 00
	00 00		 mov	 WORD PTR servc_signal_quiesce_count, ax

; 284  :     servc_signal_quiesce_unit = 0;

  00027	c6 05 00 00 00
	00 00		 mov	 BYTE PTR servc_signal_quiesce_unit, 0

; 285  :     servc_sysg_cmdcode = 0;

  0002e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR servc_sysg_cmdcode, 0

; 286  : 
; 287  :     sysblk.servparm = 0;

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	c7 80 90 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4752], 0

; 288  : }

  00046	c3		 ret	 0
sclp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
i$1 = 32
tv162 = 36
mask$2 = 40
type$ = 64
sclp_attention PROC

; 296  : {

$LN15:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 297  :     /* Set pending mask */
; 298  :     servc_attn_pending |= 0x80000000 >> (type -1);

  00009	0f b7 44 24 40	 movzx	 eax, WORD PTR type$[rsp]
  0000e	ff c8		 dec	 eax
  00010	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00015	89 4c 24 24	 mov	 DWORD PTR tv162[rsp], ecx
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	8b 44 24 24	 mov	 eax, DWORD PTR tv162[rsp]
  00020	d3 e8		 shr	 eax, cl
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR servc_attn_pending
  00028	0b c8		 or	 ecx, eax
  0002a	8b c1		 mov	 eax, ecx
  0002c	89 05 00 00 00
	00		 mov	 DWORD PTR servc_attn_pending, eax

; 299  : 
; 300  :     /* Ignore request if already pending */
; 301  :     if (!(IS_IC_SERVSIG && (sysblk.servparm & SERVSIG_PEND)))

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00039	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0003f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00044	85 c0		 test	 eax, eax
  00046	74 18		 je	 SHORT $LN9@sclp_atten
  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004f	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00055	83 e0 01	 and	 eax, 1
  00058	85 c0		 test	 eax, eax
  0005a	0f 85 57 01 00
	00		 jne	 $LN8@sclp_atten
$LN9@sclp_atten:

; 302  :     {
; 303  :         /* Set event pending flag in service parameter */
; 304  :         sysblk.servparm |= SERVSIG_PEND;

  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00067	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  0006d	83 c8 01	 or	 eax, 1
  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00077	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax
$LN4@sclp_atten:

; 305  : 
; 306  :         /* Set service signal interrupt pending for read event data */
; 307  :         ON_IC_SERVSIG;

  0007d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00084	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0008a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 fc 00 00
	00		 jne	 $LN10@sclp_atten
  00097	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009e	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000a4	0f ba e8 09	 bts	 eax, 9
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000af	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  000b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bc	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000c3	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  000c8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000d0	eb 0a		 jmp	 SHORT $LN7@sclp_atten
$LN5@sclp_atten:
  000d2	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000d6	ff c0		 inc	 eax
  000d8	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@sclp_atten:
  000dc	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  000e2	0f 84 ab 00 00
	00		 je	 $LN6@sclp_atten
  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  000ed	48 83 e0 01	 and	 rax, 1
  000f1	48 85 c0	 test	 rax, rax
  000f4	0f 84 87 00 00
	00		 je	 $LN11@sclp_atten
  000fa	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00106	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0010e	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00111	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00116	85 c0		 test	 eax, eax
  00118	74 35		 je	 SHORT $LN12@sclp_atten
  0011a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00126	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0012e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00131	0d 00 02 00 80	 or	 eax, -2147483136	; 80000200H
  00136	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0013b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00142	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0014a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0014d	eb 32		 jmp	 SHORT $LN13@sclp_atten
$LN12@sclp_atten:
  0014f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00154	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00163	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00166	0f ba e8 09	 bts	 eax, 9
  0016a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0016f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00176	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0017e	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN13@sclp_atten:
$LN11@sclp_atten:
  00181	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  00186	48 d1 e8	 shr	 rax, 1
  00189	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  0018e	e9 3f ff ff ff	 jmp	 $LN5@sclp_atten
$LN6@sclp_atten:
$LN10@sclp_atten:
  00193	33 c0		 xor	 eax, eax
  00195	85 c0		 test	 eax, eax
  00197	0f 85 e0 fe ff
	ff		 jne	 $LN4@sclp_atten

; 308  :         WAKEUP_CPUS_MASK( sysblk.waiting_mask );

  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179002
  001a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ab	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  001b2	e8 00 00 00 00	 call	 wakeup_cpus_mask
$LN8@sclp_atten:

; 309  :     }
; 310  : }

  001b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001bb	c3		 ret	 0
sclp_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
count$ = 80
unit$ = 88
signal_quiesce PROC

; 677  : {

$LN4:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 678  :     /* Error if disabled for commands */
; 679  :     if (!SCLP_RECV_ENABLED( SIGQ ))

  0000d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  00013	83 e0 08	 and	 eax, 8
  00016	85 c0		 test	 eax, eax
  00018	75 5a		 jne	 SHORT $LN2@signal_qui

; 680  :     {
; 681  :         // "SCLP console not receiving %s"
; 682  :         WRMSG( HHC00002, "E", "quiesce signals" );

  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179177
  0002c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179178
  00038	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179179
  00044	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00049	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179180
  0005b	ba aa 02 00 00	 mov	 edx, 682		; 000002aaH
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179181
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 683  :         return -1;

  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	eb 3e		 jmp	 SHORT $LN1@signal_qui
$LN2@signal_qui:

; 684  :     }
; 685  : 
; 686  :     OBTAIN_INTLOCK( NULL );

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179182
  0007b	33 c9		 xor	 ecx, ecx
  0007d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 687  :     {
; 688  :         /* Save delay values for signal shutdown event read */
; 689  :         servc_signal_quiesce_count = count;

  00082	0f b7 44 24 50	 movzx	 eax, WORD PTR count$[rsp]
  00087	66 89 05 00 00
	00 00		 mov	 WORD PTR servc_signal_quiesce_count, ax

; 690  :         servc_signal_quiesce_unit  = unit;

  0008e	0f b6 44 24 58	 movzx	 eax, BYTE PTR unit$[rsp]
  00093	88 05 00 00 00
	00		 mov	 BYTE PTR servc_signal_quiesce_unit, al

; 691  : 
; 692  :         sclp_attention( SCCB_EVD_TYPE_SIGQ );

  00099	66 b9 1d 00	 mov	 cx, 29
  0009d	e8 00 00 00 00	 call	 sclp_attention

; 693  :     }
; 694  :     RELEASE_INTLOCK( NULL );

  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179183
  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 695  : 
; 696  :     return 0;

  000b0	33 c0		 xor	 eax, eax
$LN1@signal_qui:

; 697  : }

  000b2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b6	c3		 ret	 0
signal_quiesce ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
can_send_command PROC

; 660  :     return SCLP_RECV_ENABLED( OPCMD );

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  00006	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H

; 661  : }

  0000b	c3		 ret	 0
can_send_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
can_signal_quiesce PROC

; 643  :     return SCLP_RECV_ENABLED( SIGQ );

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  00006	83 e0 08	 and	 eax, 8

; 644  : }

  00009	c3		 ret	 0
can_signal_quiesce ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\service.c
_TEXT	SEGMENT
tv163 = 80
tv141 = 88
tv145 = 96
cmd$1 = 104
command$ = 128
priomsg$ = 136
echo$ = 144
mask$ = 152
scp_command PROC

; 399  : {

$LN13:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 400  :     /* Error if disabled for priority messages */
; 401  :     if (priomsg && !SCLP_RECV_ENABLED( PRIOR ))

  00017	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR priomsg$[rsp]
  0001f	85 c0		 test	 eax, eax
  00021	74 6c		 je	 SHORT $LN2@scp_comman
  00023	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  00029	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0002e	85 c0		 test	 eax, eax
  00030	75 5d		 jne	 SHORT $LN2@scp_comman

; 402  :     {
; 403  :         // "SCLP console not receiving %s"
; 404  :         WRMSG( HHC00002, "E", "priority commands" );

  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179060
  00044	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179061
  00050	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179062
  0005c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	41 b9 03 00 00
	00		 mov	 r9d, 3
  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179063
  00073	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179064
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  :         return -1;

  00085	b8 ff ff ff ff	 mov	 eax, -1
  0008a	e9 05 02 00 00	 jmp	 $LN1@scp_comman
$LN2@scp_comman:

; 406  :     }
; 407  : 
; 408  :     /* Error if disabled for commands */
; 409  :     if (!priomsg && !SCLP_RECV_ENABLED( OPCMD ))

  0008f	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR priomsg$[rsp]
  00097	85 c0		 test	 eax, eax
  00099	75 6c		 jne	 SHORT $LN3@scp_comman
  0009b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR servc_cp_recv_mask
  000a1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000a6	85 c0		 test	 eax, eax
  000a8	75 5d		 jne	 SHORT $LN3@scp_comman

; 410  :     {
; 411  :         // "SCLP console not receiving %s"
; 412  :         WRMSG( HHC00002, "E", "operator commands" );

  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179066
  000bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179067
  000c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179068
  000d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000de	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179069
  000eb	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179070
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 413  :         return -1;

  000fd	b8 ff ff ff ff	 mov	 eax, -1
  00102	e9 8d 01 00 00	 jmp	 $LN1@scp_comman
$LN3@scp_comman:

; 414  :     }
; 415  : 
; 416  :     /* Error if command string is missing */
; 417  :     if (!command[0])

  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	48 6b c0 00	 imul	 rax, rax, 0
  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR command$[rsp]
  00118	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0011c	85 c0		 test	 eax, eax
  0011e	75 51		 jne	 SHORT $LN4@scp_comman

; 418  :     {
; 419  :         // "Empty SCP command issued"
; 420  :         WRMSG( HHC00003, "E" );

  00120	b9 01 00 00 00	 mov	 ecx, 1
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179072
  00132	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179073
  0013e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00143	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00148	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179074
  00155	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179075
  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 421  :         return -1;

  00167	b8 ff ff ff ff	 mov	 eax, -1
  0016c	e9 23 01 00 00	 jmp	 $LN1@scp_comman
$LN4@scp_comman:

; 422  :     }
; 423  : 
; 424  :     /* Echo command to HMC console iuf requested */
; 425  :     if (echo)

  00171	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR echo$[rsp]
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 b2 00 00
	00		 je	 $LN5@scp_comman

; 426  :     {
; 427  :         const char* cmd = mask ? "(suppressed)" : command;

  00181	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR mask$[rsp]
  00189	85 c0		 test	 eax, eax
  0018b	74 0e		 je	 SHORT $LN7@scp_comman
  0018d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179077
  00194	48 89 44 24 58	 mov	 QWORD PTR tv141[rsp], rax
  00199	eb 0d		 jmp	 SHORT $LN8@scp_comman
$LN7@scp_comman:
  0019b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR command$[rsp]
  001a3	48 89 44 24 58	 mov	 QWORD PTR tv141[rsp], rax
$LN8@scp_comman:
  001a8	48 8b 44 24 58	 mov	 rax, QWORD PTR tv141[rsp]
  001ad	48 89 44 24 68	 mov	 QWORD PTR cmd$1[rsp], rax

; 428  : 
; 429  :         // "SCP %scommand: %s"
; 430  :         WRMSG( HHC00160, "I", priomsg ? "priority " : "", cmd );

  001b2	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR priomsg$[rsp]
  001ba	85 c0		 test	 eax, eax
  001bc	74 0e		 je	 SHORT $LN9@scp_comman
  001be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179078
  001c5	48 89 44 24 60	 mov	 QWORD PTR tv145[rsp], rax
  001ca	eb 0c		 jmp	 SHORT $LN10@scp_comman
$LN9@scp_comman:
  001cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179079
  001d3	48 89 44 24 60	 mov	 QWORD PTR tv145[rsp], rax
$LN10@scp_comman:
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cmd$1[rsp]
  001e8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv145[rsp]
  001f2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179080
  001fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179081
  0020a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00214	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179082
  00221	ba ae 01 00 00	 mov	 edx, 430		; 000001aeH
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179083
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@scp_comman:

; 431  :     }
; 432  : 
; 433  :     /* Obtain the interrupt lock */
; 434  :     OBTAIN_INTLOCK( NULL );

  00233	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179084
  0023a	33 c9		 xor	 ecx, ecx
  0023c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 435  : 
; 436  :     /* Save command string and message type for read event data */
; 437  :     STRLCPY( servc_scpcmdstr, command );

  00241	41 b8 7c 00 00
	00		 mov	 r8d, 124		; 0000007cH
  00247	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR command$[rsp]
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:servc_scpcmdstr
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 438  : 
; 439  :     /* Raise attention service signal */
; 440  :     sclp_attention( priomsg ? SCCB_EVD_TYPE_PRIOR : SCCB_EVD_TYPE_OPCMD );

  0025c	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR priomsg$[rsp]
  00264	85 c0		 test	 eax, eax
  00266	74 0a		 je	 SHORT $LN11@scp_comman
  00268	c7 44 24 50 09
	00 00 00	 mov	 DWORD PTR tv163[rsp], 9
  00270	eb 08		 jmp	 SHORT $LN12@scp_comman
$LN11@scp_comman:
  00272	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
$LN12@scp_comman:
  0027a	0f b7 4c 24 50	 movzx	 ecx, WORD PTR tv163[rsp]
  0027f	e8 00 00 00 00	 call	 sclp_attention

; 441  : 
; 442  :     /* Release the interrupt lock */
; 443  :     RELEASE_INTLOCK( NULL );

  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179085
  0028b	33 c9		 xor	 ecx, ecx
  0028d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 444  : 
; 445  :     return 0;

  00292	33 c0		 xor	 eax, eax
$LN1@scp_comman:

; 446  : 
; 447  : } /* end function scp_command */

  00294	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00298	c3		 ret	 0
scp_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
