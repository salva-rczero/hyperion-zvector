; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s370_maddr_l
PUBLIC	concpy
PUBLIC	s370_vstore2_full
PUBLIC	s370_vstore4_full
PUBLIC	s370_vstore8_full
PUBLIC	s370_vfetch2_full
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vfetch8_full
PUBLIC	s370_vstorec
PUBLIC	s370_vstoreb
PUBLIC	s370_vstore2
PUBLIC	s370_vstore4
PUBLIC	s370_vstore8
PUBLIC	s370_vfetchc
PUBLIC	s370_vfetchb
PUBLIC	s370_vfetch2
PUBLIC	s370_vfetch4
PUBLIC	s370_vfetch8
PUBLIC	s370_instfetch
PUBLIC	s370_move_chars
PUBLIC	s370_validate_operand
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore2_full
PUBLIC	s390_vstore4_full
PUBLIC	s390_vstore8_full
PUBLIC	s390_vfetch2_full
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vfetch8_full
PUBLIC	s390_vstorec
PUBLIC	s390_vstoreb
PUBLIC	s390_vstore2
PUBLIC	s390_vstore4
PUBLIC	s390_vstore8
PUBLIC	s390_vfetchc
PUBLIC	s390_vfetchb
PUBLIC	s390_vfetch2
PUBLIC	s390_vfetch4
PUBLIC	s390_vfetch8
PUBLIC	s390_instfetch
PUBLIC	s390_move_chars
PUBLIC	s390_validate_operand
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_maddr_l
PUBLIC	concpy_rl
PUBLIC	z900_vstore2_full
PUBLIC	z900_vstore4_full
PUBLIC	z900_vstore8_full
PUBLIC	z900_vfetch2_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstoreb
PUBLIC	z900_vstore2
PUBLIC	z900_vstore4
PUBLIC	z900_vstore8
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetchb
PUBLIC	z900_vfetch2
PUBLIC	z900_vfetch4
PUBLIC	z900_vfetch8
PUBLIC	z900_instfetch
PUBLIC	z900_move_chars
PUBLIC	z900_move_chars_rl
PUBLIC	z900_move_charx
PUBLIC	z900_validate_operand
PUBLIC	??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
PUBLIC	??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
EXTRN	labs:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$concpy DD imagerel $LN13
	DD	imagerel $LN13+295
	DD	imagerel $unwind$concpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$s370_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+313
	DD	imagerel $unwind$s370_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+356
	DD	imagerel $unwind$s370_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$s370_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstoreb DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$s370_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2 DD imagerel $LN24
	DD	imagerel $LN24+267
	DD	imagerel $unwind$s370_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4 DD imagerel $LN27
	DD	imagerel $LN27+289
	DD	imagerel $unwind$s370_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore8 DD imagerel $LN24
	DD	imagerel $LN24+253
	DD	imagerel $unwind$s370_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchb DD imagerel $LN18
	DD	imagerel $LN18+160
	DD	imagerel $unwind$s370_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8 DD imagerel $LN23
	DD	imagerel $LN23+240
	DD	imagerel $unwind$s370_vfetch8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_instfetch DD imagerel $LN68
	DD	imagerel $LN68+1960
	DD	imagerel $unwind$s370_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_move_chars DD imagerel $LN77
	DD	imagerel $LN77+1917
	DD	imagerel $unwind$s370_move_chars
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_validate_operand DD imagerel $LN24
	DD	imagerel $LN24+271
	DD	imagerel $unwind$s370_validate_operand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+210
	DD	imagerel $unwind$s390_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+364
	DD	imagerel $unwind$s390_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+180
	DD	imagerel $unwind$s390_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$s390_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore2 DD imagerel $LN9
	DD	imagerel $LN9+179
	DD	imagerel $unwind$s390_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$s390_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$s390_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch2 DD imagerel $LN11
	DD	imagerel $LN11+187
	DD	imagerel $unwind$s390_vfetch2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$s390_vfetch8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_instfetch DD imagerel $LN76
	DD	imagerel $LN76+2248
	DD	imagerel $unwind$s390_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_move_chars DD imagerel $LN32
	DD	imagerel $LN32+1593
	DD	imagerel $unwind$s390_move_chars
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$concpy_rl DD imagerel $LN13
	DD	imagerel $LN13+328
	DD	imagerel $unwind$concpy_rl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+216
	DD	imagerel $unwind$z900_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+186
	DD	imagerel $unwind$z900_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore2 DD imagerel $LN9
	DD	imagerel $LN9+188
	DD	imagerel $unwind$z900_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2 DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$z900_vfetch2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_instfetch DD imagerel $LN96
	DD	imagerel $LN96+2956
	DD	imagerel $unwind$z900_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_move_chars DD imagerel $LN32
	DD	imagerel $LN32+1631
	DD	imagerel $unwind$z900_move_chars
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_move_chars_rl DD imagerel $LN32
	DD	imagerel $LN32+1631
	DD	imagerel $unwind$z900_move_chars_rl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_move_charx DD imagerel $LN36
	DD	imagerel $LN36+1054
	DD	imagerel $unwind$z900_move_charx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
;	COMDAT ??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:943', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:863', 00H	; `string'
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_move_charx DD 021a01H
	DD	011011aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_move_chars_rl DD 021a01H
	DD	011011aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_move_chars DD 021a01H
	DD	011011aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_instfetch DD 021001H
	DD	0170110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchb DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore2 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2_full DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore2_full DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$concpy_rl DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_move_chars DD 021901H
	DD	0110119H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_instfetch DD 021001H
	DD	0150110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch2 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore2 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0158H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8_full DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore2_full DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_move_chars DD 021901H
	DD	0150119H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_instfetch DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore8 DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4 DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2 DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0150H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore8_full DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2_full DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$concpy DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_move_charx
_TEXT	SEGMENT
len3$ = 48
tv65 = 52
tv70 = 56
tv76 = 60
tv151 = 64
tv156 = 68
tv167 = 72
tv172 = 76
len1$ = 80
len2$ = 84
tv174 = 88
main2$ = 96
main1$ = 104
tv201 = 112
tv214 = 120
addr1$ = 144
space1$ = 152
key1$ = 160
addr2$ = 168
space2$ = 176
key2$ = 184
len$ = 192
regs$ = 200
z900_move_charx PROC					; COMDAT

; 1296 : {

$LN36:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1297 : BYTE   *main1, *main2;                  /* Main storage pointers     */
; 1298 : int     len1, len2, len3;               /* Work areas for lengths    */
; 1299 : 
; 1300 :     /* Ultra quick out if copying zero bytes */
; 1301 :     if (unlikely( !len ))

  0001a	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00022	75 0a		 jne	 SHORT $LN8@z900_move_
  00024	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN9@z900_move_
$LN8@z900_move_:
  0002e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN9@z900_move_:
  00036	83 7c 24 34 00	 cmp	 DWORD PTR tv65[rsp], 0
  0003b	74 0a		 je	 SHORT $LN12@z900_move_
  0003d	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00045	eb 08		 jmp	 SHORT $LN13@z900_move_
$LN12@z900_move_:
  00047	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN13@z900_move_:
  0004f	83 7c 24 38 00	 cmp	 DWORD PTR tv70[rsp], 0
  00054	74 05		 je	 SHORT $LN4@z900_move_

; 1302 :         return;

  00056	e9 bb 03 00 00	 jmp	 $LN1@z900_move_
$LN4@z900_move_:

; 1303 : 
; 1304 :     ITIMER_SYNC( addr2, len-1, regs );
; 1305 : 
; 1306 :     /* Quick out if copying just 1 byte */
; 1307 :     if (unlikely( len == 1 ))

  0005b	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR len$[rsp], 1
  00063	75 0a		 jne	 SHORT $LN16@z900_move_
  00065	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0006d	eb 08		 jmp	 SHORT $LN17@z900_move_
$LN16@z900_move_:
  0006f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN17@z900_move_:
  00077	83 7c 24 3c 00	 cmp	 DWORD PTR tv76[rsp], 0
  0007c	0f 84 8a 00 00
	00		 je	 $LN5@z900_move_

; 1308 :     {
; 1309 :         main2 = MADDR( addr2, space2, regs, ACCTYPE_READ,  key2 );

  00082	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR key2$[rsp]
  0008a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0008e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00096	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0009e	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR space2$[rsp]
  000a6	ba 01 00 00 00	 mov	 edx, 1
  000ab	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  000b3	e8 00 00 00 00	 call	 z900_maddr_l
  000b8	48 89 44 24 60	 mov	 QWORD PTR main2$[rsp], rax

; 1310 :         main1 = MADDR( addr1, space1, regs, ACCTYPE_WRITE, key1 );

  000bd	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR key1$[rsp]
  000c5	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d1	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d9	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR space1$[rsp]
  000e1	ba 01 00 00 00	 mov	 edx, 1
  000e6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  000ee	e8 00 00 00 00	 call	 z900_maddr_l
  000f3	48 89 44 24 68	 mov	 QWORD PTR main1$[rsp], rax

; 1311 :         *main1 = *main2;

  000f8	48 8b 44 24 68	 mov	 rax, QWORD PTR main1$[rsp]
  000fd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR main2$[rsp]
  00102	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00105	88 08		 mov	 BYTE PTR [rax], cl

; 1312 :         ITIMER_UPDATE( addr1, len-1, regs );
; 1313 :         return;

  00107	e9 0a 03 00 00	 jmp	 $LN1@z900_move_
$LN5@z900_move_:

; 1314 :     }
; 1315 : 
; 1316 :     /* Translate addresses of leftmost operand bytes */
; 1317 :     main2 = MADDRL( addr2, len, space2, regs, ACCTYPE_READ, key2 );

  0010c	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00114	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  0011c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00120	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00128	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00130	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR space2$[rsp]
  00138	48 8b d0	 mov	 rdx, rax
  0013b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  00143	e8 00 00 00 00	 call	 z900_maddr_l
  00148	48 89 44 24 60	 mov	 QWORD PTR main2$[rsp], rax

; 1318 :     main1 = MADDRL( addr1, len, space1, regs, ACCTYPE_WRITE, key1 );

  0014d	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00155	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  0015d	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00161	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00169	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00171	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR space1$[rsp]
  00179	48 8b d0	 mov	 rdx, rax
  0017c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00184	e8 00 00 00 00	 call	 z900_maddr_l
  00189	48 89 44 24 68	 mov	 QWORD PTR main1$[rsp], rax
$LN2@z900_move_:

; 1319 : 
; 1320 :     /* Copy the largest chunks which do not cross a page
; 1321 :        boundary of either source or destination operand */
; 1322 :     while (len > 0)

  0018e	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00196	0f 8e 7a 02 00
	00		 jle	 $LN3@z900_move_

; 1323 :     {
; 1324 :         /* Calculate distance to next 2K boundary */
; 1325 :         len1 = NOCROSSPAGEL( addr1, len ) ? len : (int)(PAGEFRAME_PAGESIZE - (addr1 & PAGEFRAME_BYTEMASK));

  0019c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  001a4	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  001aa	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  001af	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  001b6	3b c1		 cmp	 eax, ecx
  001b8	7f 0a		 jg	 SHORT $LN20@z900_move_
  001ba	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001c2	eb 08		 jmp	 SHORT $LN21@z900_move_
$LN20@z900_move_:
  001c4	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN21@z900_move_:
  001cc	83 7c 24 40 00	 cmp	 DWORD PTR tv151[rsp], 0
  001d1	74 0d		 je	 SHORT $LN22@z900_move_
  001d3	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001da	89 44 24 44	 mov	 DWORD PTR tv156[rsp], eax
  001de	eb 1d		 jmp	 SHORT $LN23@z900_move_
$LN22@z900_move_:
  001e0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  001e8	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  001ee	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  001f3	48 2b c8	 sub	 rcx, rax
  001f6	48 8b c1	 mov	 rax, rcx
  001f9	89 44 24 44	 mov	 DWORD PTR tv156[rsp], eax
$LN23@z900_move_:
  001fd	8b 44 24 44	 mov	 eax, DWORD PTR tv156[rsp]
  00201	89 44 24 50	 mov	 DWORD PTR len1$[rsp], eax

; 1326 :         len2 = NOCROSSPAGEL( addr2, len ) ? len : (int)(PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK));

  00205	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  0020d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00213	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00218	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  0021f	3b c1		 cmp	 eax, ecx
  00221	7f 0a		 jg	 SHORT $LN26@z900_move_
  00223	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  0022b	eb 08		 jmp	 SHORT $LN27@z900_move_
$LN26@z900_move_:
  0022d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN27@z900_move_:
  00235	83 7c 24 48 00	 cmp	 DWORD PTR tv167[rsp], 0
  0023a	74 0d		 je	 SHORT $LN28@z900_move_
  0023c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00243	89 44 24 4c	 mov	 DWORD PTR tv172[rsp], eax
  00247	eb 1d		 jmp	 SHORT $LN29@z900_move_
$LN28@z900_move_:
  00249	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00251	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00257	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0025c	48 2b c8	 sub	 rcx, rax
  0025f	48 8b c1	 mov	 rax, rcx
  00262	89 44 24 4c	 mov	 DWORD PTR tv172[rsp], eax
$LN29@z900_move_:
  00266	8b 44 24 4c	 mov	 eax, DWORD PTR tv172[rsp]
  0026a	89 44 24 54	 mov	 DWORD PTR len2$[rsp], eax

; 1327 :         len3 = len1 < len2 ? len1 : len2;

  0026e	8b 44 24 54	 mov	 eax, DWORD PTR len2$[rsp]
  00272	39 44 24 50	 cmp	 DWORD PTR len1$[rsp], eax
  00276	7d 0a		 jge	 SHORT $LN30@z900_move_
  00278	8b 44 24 50	 mov	 eax, DWORD PTR len1$[rsp]
  0027c	89 44 24 58	 mov	 DWORD PTR tv174[rsp], eax
  00280	eb 08		 jmp	 SHORT $LN31@z900_move_
$LN30@z900_move_:
  00282	8b 44 24 54	 mov	 eax, DWORD PTR len2$[rsp]
  00286	89 44 24 58	 mov	 DWORD PTR tv174[rsp], eax
$LN31@z900_move_:
  0028a	8b 44 24 58	 mov	 eax, DWORD PTR tv174[rsp]
  0028e	89 44 24 30	 mov	 DWORD PTR len3$[rsp], eax

; 1328 : 
; 1329 :         /* Copy bytes from source to destination */
; 1330 :         concpy( regs, main1, main2, len3 );

  00292	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len3$[rsp]
  00297	4c 8b 44 24 60	 mov	 r8, QWORD PTR main2$[rsp]
  0029c	48 8b 54 24 68	 mov	 rdx, QWORD PTR main1$[rsp]
  002a1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	e8 00 00 00 00	 call	 concpy

; 1331 : 
; 1332 :         /* Calculate virtual addresses for next chunk */
; 1333 :         addr1 = (addr1 + len3) & ADDRESS_MAXWRAP( regs );

  002ae	48 63 44 24 30	 movsxd	 rax, DWORD PTR len3$[rsp]
  002b3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  002bb	48 03 c8	 add	 rcx, rax
  002be	48 8b c1	 mov	 rax, rcx
  002c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002d0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 1334 :         addr2 = (addr2 + len3) & ADDRESS_MAXWRAP( regs );

  002d8	48 63 44 24 30	 movsxd	 rax, DWORD PTR len3$[rsp]
  002dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  002e5	48 03 c8	 add	 rcx, rax
  002e8	48 8b c1	 mov	 rax, rcx
  002eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002fa	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 1335 : 
; 1336 :         /* Adjust remaining length */
; 1337 :         len -= len3;

  00302	8b 44 24 30	 mov	 eax, DWORD PTR len3$[rsp]
  00306	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0030d	2b c8		 sub	 ecx, eax
  0030f	8b c1		 mov	 eax, ecx
  00311	89 84 24 c0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1338 : 
; 1339 :         /* Exit if no more bytes to move */
; 1340 :         if (len == 0) break;

  00318	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00320	75 05		 jne	 SHORT $LN6@z900_move_
  00322	e9 ef 00 00 00	 jmp	 $LN3@z900_move_
$LN6@z900_move_:

; 1341 : 
; 1342 :         /* Adjust addresses for start of next chunk, or
; 1343 :            translate again if a 2K boundary was crossed */
; 1344 :         main2 = (addr2 & PAGEFRAME_BYTEMASK) ? main2 + len3 : MADDRL( addr2, len, space2, regs, ACCTYPE_READ,  key2 );

  00327	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  0032f	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00335	48 85 c0	 test	 rax, rax
  00338	74 17		 je	 SHORT $LN32@z900_move_
  0033a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len3$[rsp]
  0033f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR main2$[rsp]
  00344	48 03 c8	 add	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	48 89 44 24 70	 mov	 QWORD PTR tv201[rsp], rax
  0034f	eb 41		 jmp	 SHORT $LN33@z900_move_
$LN32@z900_move_:
  00351	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00359	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  00361	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00365	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0036d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00375	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR space2$[rsp]
  0037d	48 8b d0	 mov	 rdx, rax
  00380	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  00388	e8 00 00 00 00	 call	 z900_maddr_l
  0038d	48 89 44 24 70	 mov	 QWORD PTR tv201[rsp], rax
$LN33@z900_move_:
  00392	48 8b 44 24 70	 mov	 rax, QWORD PTR tv201[rsp]
  00397	48 89 44 24 60	 mov	 QWORD PTR main2$[rsp], rax

; 1345 :         main1 = (addr1 & PAGEFRAME_BYTEMASK) ? main1 + len3 : MADDRL( addr1, len, space1, regs, ACCTYPE_WRITE, key1 );

  0039c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  003a4	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  003aa	48 85 c0	 test	 rax, rax
  003ad	74 17		 je	 SHORT $LN34@z900_move_
  003af	48 63 44 24 30	 movsxd	 rax, DWORD PTR len3$[rsp]
  003b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR main1$[rsp]
  003b9	48 03 c8	 add	 rcx, rax
  003bc	48 8b c1	 mov	 rax, rcx
  003bf	48 89 44 24 78	 mov	 QWORD PTR tv214[rsp], rax
  003c4	eb 41		 jmp	 SHORT $LN35@z900_move_
$LN34@z900_move_:
  003c6	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  003ce	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  003d6	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  003da	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  003e2	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003ea	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR space1$[rsp]
  003f2	48 8b d0	 mov	 rdx, rax
  003f5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  003fd	e8 00 00 00 00	 call	 z900_maddr_l
  00402	48 89 44 24 78	 mov	 QWORD PTR tv214[rsp], rax
$LN35@z900_move_:
  00407	48 8b 44 24 78	 mov	 rax, QWORD PTR tv214[rsp]
  0040c	48 89 44 24 68	 mov	 QWORD PTR main1$[rsp], rax

; 1346 : 
; 1347 :     } /* end while(len) */

  00411	e9 78 fd ff ff	 jmp	 $LN2@z900_move_
$LN3@z900_move_:
$LN1@z900_move_:

; 1348 : 
; 1349 :     ITIMER_UPDATE( addr1, len-1, regs );
; 1350 : 
; 1351 : } /* end function ARCH_DEP( move_charx ) */

  00416	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0041d	c3		 ret	 0
z900_move_charx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_move_chars_rl
_TEXT	SEGMENT
len1$ = 48
len2$ = 52
source1$ = 56
dest1$ = 64
source2$ = 72
tv65 = 80
tv70 = 84
tv147 = 88
tv159 = 92
tv226 = 96
dest2$ = 104
sk1$ = 112
sk2$ = 120
addr1$ = 144
arn1$ = 152
key1$ = 160
addr2$ = 168
arn2$ = 176
key2$ = 184
len$ = 192
regs$ = 200
z900_move_chars_rl PROC					; COMDAT

; 1158 : {

$LN32:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1159 : BYTE   *dest1,   *dest2;                /* Destination addresses     */
; 1160 : BYTE   *source1, *source2;              /* Source addresses          */
; 1161 : BYTE   *sk1,     *sk2;                  /* Storage key addresses     */
; 1162 : int     len1,     len2;                 /* Lengths to copy           */
; 1163 : 
; 1164 :     ITIMER_SYNC( addr2, len, regs );
; 1165 : 
; 1166 :     /* Quick out if copying just 1 byte */
; 1167 :     if (unlikely( !len ))

  0001a	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00022	75 0a		 jne	 SHORT $LN14@z900_move_
  00024	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN15@z900_move_
$LN14@z900_move_:
  0002e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN15@z900_move_:
  00036	83 7c 24 50 00	 cmp	 DWORD PTR tv65[rsp], 0
  0003b	74 0a		 je	 SHORT $LN18@z900_move_
  0003d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00045	eb 08		 jmp	 SHORT $LN19@z900_move_
$LN18@z900_move_:
  00047	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN19@z900_move_:
  0004f	83 7c 24 54 00	 cmp	 DWORD PTR tv70[rsp], 0
  00054	0f 84 8a 00 00
	00		 je	 $LN2@z900_move_

; 1168 :     {
; 1169 :         source1 = MADDR( addr2, arn2, regs, ACCTYPE_READ,  key2 );

  0005a	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR key2$[rsp]
  00062	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00066	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006e	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00076	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  0008b	e8 00 00 00 00	 call	 z900_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1170 :         dest1   = MADDR( addr1, arn1, regs, ACCTYPE_WRITE, key1 );

  00095	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR key1$[rsp]
  0009d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000a1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a9	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  000b9	ba 01 00 00 00	 mov	 edx, 1
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  000c6	e8 00 00 00 00	 call	 z900_maddr_l
  000cb	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1171 :         *dest1  = *source1;

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR dest1$[rsp]
  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR source1$[rsp]
  000da	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000dd	88 08		 mov	 BYTE PTR [rax], cl

; 1172 :         ITIMER_UPDATE( addr1, len, regs );
; 1173 :         return;

  000df	e9 73 05 00 00	 jmp	 $LN1@z900_move_
$LN2@z900_move_:

; 1174 :     }
; 1175 : 
; 1176 :     /* Translate addresses of leftmost operand bytes */
; 1177 :     source1 = MADDRL( addr2, len+1, arn2, regs, ACCTYPE_READ, key2 );

  000e4	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	48 98		 cdqe
  000ef	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  000f7	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000fb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00103	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0010b	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  00113	48 8b d0	 mov	 rdx, rax
  00116	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_maddr_l
  00123	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1178 :     dest1   = MADDRL( addr1, len+1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );

  00128	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0012f	ff c0		 inc	 eax
  00131	48 98		 cdqe
  00133	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  0013b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0013f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00147	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0014f	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00157	48 8b d0	 mov	 rdx, rax
  0015a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00162	e8 00 00 00 00	 call	 z900_maddr_l
  00167	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1179 :     sk1 = regs->dat.storkey;

  0016c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0017b	48 89 44 24 70	 mov	 QWORD PTR sk1$[rsp], rax

; 1180 : 
; 1181 :     /* There are several scenarios (in optimal order):
; 1182 :      * (1) dest boundary and source boundary not crossed
; 1183 :      * (2) dest boundary not crossed and source boundary crossed
; 1184 :      * (3) dest boundary crossed and source boundary not crossed
; 1185 :      * (4) dest boundary and source boundary are crossed
; 1186 :      *     (a) dest and source boundary cross at the same time
; 1187 :      *     (b) dest boundary crossed first
; 1188 :      *     (c) source boundary crossed first
; 1189 :      * Note: since the operand length is limited to 256 bytes,
; 1190 :      *       neither operand can cross more than one 2K boundary.
; 1191 :      */
; 1192 :     if (NOCROSSPAGE( addr1, len ))

  00180	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  00188	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0018e	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00193	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  0019a	3b c1		 cmp	 eax, ecx
  0019c	7f 0a		 jg	 SHORT $LN22@z900_move_
  0019e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  001a6	eb 08		 jmp	 SHORT $LN23@z900_move_
$LN22@z900_move_:
  001a8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN23@z900_move_:
  001b0	83 7c 24 58 00	 cmp	 DWORD PTR tv147[rsp], 0
  001b5	0f 84 4a 01 00
	00		 je	 $LN3@z900_move_

; 1193 :     {
; 1194 :         if (NOCROSSPAGE( addr2, len ))

  001bb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  001c3	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  001c9	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  001ce	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  001d5	3b c1		 cmp	 eax, ecx
  001d7	7f 0a		 jg	 SHORT $LN26@z900_move_
  001d9	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  001e1	eb 08		 jmp	 SHORT $LN27@z900_move_
$LN26@z900_move_:
  001e3	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN27@z900_move_:
  001eb	83 7c 24 5c 00	 cmp	 DWORD PTR tv159[rsp], 0
  001f0	74 28		 je	 SHORT $LN5@z900_move_

; 1195 :         {
; 1196 :             /* (1) - No boundaries are crossed */
; 1197 :             concpy_rl( regs, dest1, source1, len + 1 );

  001f2	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f9	ff c0		 inc	 eax
  001fb	44 8b c8	 mov	 r9d, eax
  001fe	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00203	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00208	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	e8 00 00 00 00	 call	 concpy_rl

; 1198 :         }

  00215	e9 d4 00 00 00	 jmp	 $LN6@z900_move_
$LN5@z900_move_:

; 1199 :         else
; 1200 :         {
; 1201 :             /* (2) - Source operand crosses a boundary */
; 1202 :             len1 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  0021a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00222	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00228	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0022d	48 2b c8	 sub	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1203 :             source2 = MADDRL( (addr2 + len1) & ADDRESS_MAXWRAP( regs ),

  00237	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0023e	ff c0		 inc	 eax
  00240	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  00244	48 98		 cdqe
  00246	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  0024b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR addr2$[rsp]
  00253	48 03 d1	 add	 rdx, rcx
  00256	48 8b ca	 mov	 rcx, rdx
  00259	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00261	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00268	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  00270	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00274	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0027c	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00284	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0028c	48 8b d0	 mov	 rdx, rax
  0028f	e8 00 00 00 00	 call	 z900_maddr_l
  00294	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1204 :                    len + 1 - len1, arn2, regs, ACCTYPE_READ, key2 );
; 1205 : 
; 1206 :             concpy_rl( regs, dest1 + len1, source2, len - len1 + 1 );

  00299	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  0029d	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  002a4	2b c8		 sub	 ecx, eax
  002a6	8b c1		 mov	 eax, ecx
  002a8	ff c0		 inc	 eax
  002aa	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  002af	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002b4	48 03 d1	 add	 rdx, rcx
  002b7	48 8b ca	 mov	 rcx, rdx
  002ba	44 8b c8	 mov	 r9d, eax
  002bd	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  002c2	48 8b d1	 mov	 rdx, rcx
  002c5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	e8 00 00 00 00	 call	 concpy_rl

; 1207 :             concpy_rl( regs, dest1,        source1,       len1     );

  002d2	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  002d7	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  002dc	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	e8 00 00 00 00	 call	 concpy_rl
$LN6@z900_move_:

; 1208 :         }
; 1209 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  002ee	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  002f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f6	83 c8 06	 or	 eax, 6
  002f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  002fe	88 01		 mov	 BYTE PTR [rcx], al

; 1210 :     }

  00300	e9 52 03 00 00	 jmp	 $LN4@z900_move_
$LN3@z900_move_:

; 1211 :     else
; 1212 :     {
; 1213 :         /* Destination operand crosses a boundary */
; 1214 :         len1 = PAGEFRAME_PAGESIZE - (addr1 & PAGEFRAME_BYTEMASK);

  00305	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  0030d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00313	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00318	48 2b c8	 sub	 rcx, rax
  0031b	48 8b c1	 mov	 rax, rcx
  0031e	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1215 :         dest2 = MADDRL( (addr1 + len1) & ADDRESS_MAXWRAP( regs ),

  00322	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00329	ff c0		 inc	 eax
  0032b	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  0032f	48 98		 cdqe
  00331	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00336	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr1$[rsp]
  0033e	48 03 d1	 add	 rdx, rcx
  00341	48 8b ca	 mov	 rcx, rdx
  00344	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00353	0f b6 94 24 a0
	00 00 00	 movzx	 edx, BYTE PTR key1$[rsp]
  0035b	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0035f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00367	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0036f	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00377	48 8b d0	 mov	 rdx, rax
  0037a	e8 00 00 00 00	 call	 z900_maddr_l
  0037f	48 89 44 24 68	 mov	 QWORD PTR dest2$[rsp], rax

; 1216 :             len + 1 - len1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );
; 1217 :         sk2 = regs->dat.storkey;

  00384	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00393	48 89 44 24 78	 mov	 QWORD PTR sk2$[rsp], rax

; 1218 : 
; 1219 :         if (NOCROSSPAGE( addr2, len ))

  00398	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  003a0	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  003a6	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  003ab	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  003b2	3b c1		 cmp	 eax, ecx
  003b4	7f 0a		 jg	 SHORT $LN30@z900_move_
  003b6	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  003be	eb 08		 jmp	 SHORT $LN31@z900_move_
$LN30@z900_move_:
  003c0	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN31@z900_move_:
  003c8	83 7c 24 60 00	 cmp	 DWORD PTR tv226[rsp], 0
  003cd	74 5a		 je	 SHORT $LN7@z900_move_

; 1220 :         {
; 1221 :              /* (3) - Source operand crosses a boundary */
; 1222 :              concpy_rl( regs, dest2, source1 + len1, len - len1 + 1 );

  003cf	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  003d3	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  003da	2b c8		 sub	 ecx, eax
  003dc	8b c1		 mov	 eax, ecx
  003de	ff c0		 inc	 eax
  003e0	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  003e5	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  003ea	48 03 d1	 add	 rdx, rcx
  003ed	48 8b ca	 mov	 rcx, rdx
  003f0	44 8b c8	 mov	 r9d, eax
  003f3	4c 8b c1	 mov	 r8, rcx
  003f6	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  003fb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	e8 00 00 00 00	 call	 concpy_rl

; 1223 :              concpy_rl( regs, dest1, source1,              len1     );

  00408	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  0040d	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00412	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00417	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	e8 00 00 00 00	 call	 concpy_rl

; 1224 :         }

  00424	e9 0a 02 00 00	 jmp	 $LN8@z900_move_
$LN7@z900_move_:

; 1225 :         else
; 1226 :         {
; 1227 :             /* (4) - Both operands cross a boundary */
; 1228 :             len2 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  00429	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00431	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00437	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0043c	48 2b c8	 sub	 rcx, rax
  0043f	48 8b c1	 mov	 rax, rcx
  00442	89 44 24 34	 mov	 DWORD PTR len2$[rsp], eax

; 1229 :             source2 = MADDRL( (addr2 + len2) & ADDRESS_MAXWRAP( regs ),

  00446	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0044d	ff c0		 inc	 eax
  0044f	2b 44 24 34	 sub	 eax, DWORD PTR len2$[rsp]
  00453	48 98		 cdqe
  00455	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0045a	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR addr2$[rsp]
  00462	48 03 d1	 add	 rdx, rcx
  00465	48 8b ca	 mov	 rcx, rdx
  00468	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00470	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00477	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  0047f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00483	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0048b	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00493	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0049b	48 8b d0	 mov	 rdx, rax
  0049e	e8 00 00 00 00	 call	 z900_maddr_l
  004a3	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1230 :                 len + 1 - len2, arn2, regs, ACCTYPE_READ, key2 );
; 1231 : 
; 1232 :             if (len1 == len2)

  004a8	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  004ac	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  004b0	75 4c		 jne	 SHORT $LN9@z900_move_

; 1233 :             {
; 1234 :                 /* (4a) - Both operands cross at the same time */
; 1235 :                 concpy_rl( regs, dest2, source2, len - len1 + 1 );

  004b2	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  004b6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  004bd	2b c8		 sub	 ecx, eax
  004bf	8b c1		 mov	 eax, ecx
  004c1	ff c0		 inc	 eax
  004c3	44 8b c8	 mov	 r9d, eax
  004c6	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  004cb	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  004d0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d8	e8 00 00 00 00	 call	 concpy_rl

; 1236 :                 concpy_rl( regs, dest1, source1,       len1     );

  004dd	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  004e2	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  004e7	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  004ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f4	e8 00 00 00 00	 call	 concpy_rl

; 1237 :             }

  004f9	e9 35 01 00 00	 jmp	 $LN10@z900_move_
$LN9@z900_move_:

; 1238 :             else if (len1 < len2)

  004fe	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00502	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  00506	0f 8d 96 00 00
	00		 jge	 $LN11@z900_move_

; 1239 :             {
; 1240 :                 /* (4b) - Destination operand crosses first */
; 1241 :                 concpy_rl( regs, dest2 + len2 - len1, source2,        len  - len2 + 1 );

  0050c	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00510	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00517	2b c8		 sub	 ecx, eax
  00519	8b c1		 mov	 eax, ecx
  0051b	ff c0		 inc	 eax
  0051d	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00522	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00527	48 03 d1	 add	 rdx, rcx
  0052a	48 8b ca	 mov	 rcx, rdx
  0052d	48 63 54 24 30	 movsxd	 rdx, DWORD PTR len1$[rsp]
  00532	48 2b ca	 sub	 rcx, rdx
  00535	44 8b c8	 mov	 r9d, eax
  00538	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  0053d	48 8b d1	 mov	 rdx, rcx
  00540	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00548	e8 00 00 00 00	 call	 concpy_rl

; 1242 :                 concpy_rl( regs, dest2,               source1 + len1, len2 - len1     );

  0054d	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  00551	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  00555	2b c8		 sub	 ecx, eax
  00557	8b c1		 mov	 eax, ecx
  00559	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  0055e	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  00563	48 03 d1	 add	 rdx, rcx
  00566	48 8b ca	 mov	 rcx, rdx
  00569	44 8b c8	 mov	 r9d, eax
  0056c	4c 8b c1	 mov	 r8, rcx
  0056f	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00574	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057c	e8 00 00 00 00	 call	 concpy_rl

; 1243 :                 concpy_rl( regs, dest1,               source1,               len1     );

  00581	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00586	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  0058b	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00590	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00598	e8 00 00 00 00	 call	 concpy_rl

; 1244 :             }

  0059d	e9 91 00 00 00	 jmp	 $LN12@z900_move_
$LN11@z900_move_:

; 1245 :             else
; 1246 :             {
; 1247 :                 /* (4c) - Source operand crosses first */
; 1248 :                 concpy_rl( regs, dest2,        source2 + len1 - len2, len -  len1 + 1 );

  005a2	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  005a6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  005ad	2b c8		 sub	 ecx, eax
  005af	8b c1		 mov	 eax, ecx
  005b1	ff c0		 inc	 eax
  005b3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  005b8	48 8b 54 24 48	 mov	 rdx, QWORD PTR source2$[rsp]
  005bd	48 03 d1	 add	 rdx, rcx
  005c0	48 8b ca	 mov	 rcx, rdx
  005c3	48 63 54 24 34	 movsxd	 rdx, DWORD PTR len2$[rsp]
  005c8	48 2b ca	 sub	 rcx, rdx
  005cb	44 8b c8	 mov	 r9d, eax
  005ce	4c 8b c1	 mov	 r8, rcx
  005d1	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  005d6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005de	e8 00 00 00 00	 call	 concpy_rl

; 1249 :                 concpy_rl( regs, dest1 + len2, source2,               len1 - len2     );

  005e3	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  005e7	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  005eb	2b c8		 sub	 ecx, eax
  005ed	8b c1		 mov	 eax, ecx
  005ef	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  005f4	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  005f9	48 03 d1	 add	 rdx, rcx
  005fc	48 8b ca	 mov	 rcx, rdx
  005ff	44 8b c8	 mov	 r9d, eax
  00602	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  00607	48 8b d1	 mov	 rdx, rcx
  0060a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00612	e8 00 00 00 00	 call	 concpy_rl

; 1250 :                 concpy_rl( regs, dest1,        source1,                      len2     );

  00617	44 8b 4c 24 34	 mov	 r9d, DWORD PTR len2$[rsp]
  0061c	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00621	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00626	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	e8 00 00 00 00	 call	 concpy_rl
$LN12@z900_move_:
$LN10@z900_move_:
$LN8@z900_move_:

; 1251 :             }
; 1252 :         }
; 1253 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  00633	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  00638	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0063b	83 c8 06	 or	 eax, 6
  0063e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  00643	88 01		 mov	 BYTE PTR [rcx], al

; 1254 :         *sk2 |= (STORKEY_REF | STORKEY_CHANGE);

  00645	48 8b 44 24 78	 mov	 rax, QWORD PTR sk2$[rsp]
  0064a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0064d	83 c8 06	 or	 eax, 6
  00650	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sk2$[rsp]
  00655	88 01		 mov	 BYTE PTR [rcx], al
$LN4@z900_move_:
$LN1@z900_move_:

; 1255 :     }
; 1256 :     ITIMER_UPDATE( addr1, len, regs );
; 1257 : 
; 1258 : } /* end function ARCH_DEP( move_chars_rl ) */

  00657	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0065e	c3		 ret	 0
z900_move_chars_rl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_move_chars
_TEXT	SEGMENT
len1$ = 48
len2$ = 52
source1$ = 56
dest1$ = 64
source2$ = 72
tv65 = 80
tv70 = 84
tv147 = 88
tv159 = 92
tv226 = 96
dest2$ = 104
sk1$ = 112
sk2$ = 120
addr1$ = 144
arn1$ = 152
key1$ = 160
addr2$ = 168
arn2$ = 176
key2$ = 184
len$ = 192
regs$ = 200
z900_move_chars PROC					; COMDAT

; 1005 : {

$LN32:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1006 : BYTE   *dest1,   *dest2;                /* Destination addresses     */
; 1007 : BYTE   *source1, *source2;              /* Source addresses          */
; 1008 : BYTE   *sk1,     *sk2;                  /* Storage key addresses     */
; 1009 : int     len1,     len2;                 /* Lengths to copy           */
; 1010 : 
; 1011 :     ITIMER_SYNC( addr2, len, regs );
; 1012 : 
; 1013 :     /* Quick out if copying just 1 byte */
; 1014 :     if (unlikely( !len ))

  0001a	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00022	75 0a		 jne	 SHORT $LN14@z900_move_
  00024	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN15@z900_move_
$LN14@z900_move_:
  0002e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN15@z900_move_:
  00036	83 7c 24 50 00	 cmp	 DWORD PTR tv65[rsp], 0
  0003b	74 0a		 je	 SHORT $LN18@z900_move_
  0003d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00045	eb 08		 jmp	 SHORT $LN19@z900_move_
$LN18@z900_move_:
  00047	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN19@z900_move_:
  0004f	83 7c 24 54 00	 cmp	 DWORD PTR tv70[rsp], 0
  00054	0f 84 8a 00 00
	00		 je	 $LN2@z900_move_

; 1015 :     {
; 1016 :         source1 = MADDR( addr2, arn2, regs, ACCTYPE_READ,  key2 );

  0005a	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR key2$[rsp]
  00062	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00066	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006e	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00076	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  0008b	e8 00 00 00 00	 call	 z900_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1017 :         dest1   = MADDR( addr1, arn1, regs, ACCTYPE_WRITE, key1 );

  00095	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR key1$[rsp]
  0009d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000a1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a9	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  000b9	ba 01 00 00 00	 mov	 edx, 1
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  000c6	e8 00 00 00 00	 call	 z900_maddr_l
  000cb	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1018 :         *dest1 = *source1;

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR dest1$[rsp]
  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR source1$[rsp]
  000da	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000dd	88 08		 mov	 BYTE PTR [rax], cl

; 1019 :         ITIMER_UPDATE( addr1, len, regs );
; 1020 :         return;

  000df	e9 73 05 00 00	 jmp	 $LN1@z900_move_
$LN2@z900_move_:

; 1021 :     }
; 1022 : 
; 1023 :     /* Translate addresses of leftmost operand bytes */
; 1024 :     source1 = MADDRL( addr2, len+1, arn2, regs, ACCTYPE_READ, key2 );

  000e4	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	48 98		 cdqe
  000ef	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  000f7	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000fb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00103	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0010b	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  00113	48 8b d0	 mov	 rdx, rax
  00116	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  0011e	e8 00 00 00 00	 call	 z900_maddr_l
  00123	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1025 :     dest1   = MADDRL( addr1, len+1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );

  00128	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0012f	ff c0		 inc	 eax
  00131	48 98		 cdqe
  00133	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  0013b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0013f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00147	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0014f	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00157	48 8b d0	 mov	 rdx, rax
  0015a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00162	e8 00 00 00 00	 call	 z900_maddr_l
  00167	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1026 :     sk1 = regs->dat.storkey;

  0016c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0017b	48 89 44 24 70	 mov	 QWORD PTR sk1$[rsp], rax

; 1027 : 
; 1028 :     /* There are several scenarios (in optimal order):
; 1029 :      * (1) dest boundary and source boundary not crossed
; 1030 :      * (2) dest boundary not crossed and source boundary crossed
; 1031 :      * (3) dest boundary crossed and source boundary not crossed
; 1032 :      * (4) dest boundary and source boundary are crossed
; 1033 :      *     (a) dest and source boundary cross at the same time
; 1034 :      *     (b) dest boundary crossed first
; 1035 :      *     (c) source boundary crossed first
; 1036 :      * Note: since the operand length is limited to 256 bytes,
; 1037 :      *       neither operand can cross more than one 2K boundary.
; 1038 :      */
; 1039 :     if (NOCROSSPAGE( addr1, len ))

  00180	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  00188	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0018e	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00193	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  0019a	3b c1		 cmp	 eax, ecx
  0019c	7f 0a		 jg	 SHORT $LN22@z900_move_
  0019e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  001a6	eb 08		 jmp	 SHORT $LN23@z900_move_
$LN22@z900_move_:
  001a8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN23@z900_move_:
  001b0	83 7c 24 58 00	 cmp	 DWORD PTR tv147[rsp], 0
  001b5	0f 84 4a 01 00
	00		 je	 $LN3@z900_move_

; 1040 :     {
; 1041 :         if (NOCROSSPAGE( addr2, len ))

  001bb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  001c3	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  001c9	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  001ce	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  001d5	3b c1		 cmp	 eax, ecx
  001d7	7f 0a		 jg	 SHORT $LN26@z900_move_
  001d9	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  001e1	eb 08		 jmp	 SHORT $LN27@z900_move_
$LN26@z900_move_:
  001e3	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN27@z900_move_:
  001eb	83 7c 24 5c 00	 cmp	 DWORD PTR tv159[rsp], 0
  001f0	74 28		 je	 SHORT $LN5@z900_move_

; 1042 :         {
; 1043 :             /* (1) - No boundaries are crossed */
; 1044 :             concpy( regs, dest1, source1, len + 1 );

  001f2	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f9	ff c0		 inc	 eax
  001fb	44 8b c8	 mov	 r9d, eax
  001fe	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00203	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00208	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	e8 00 00 00 00	 call	 concpy

; 1045 :         }

  00215	e9 d4 00 00 00	 jmp	 $LN6@z900_move_
$LN5@z900_move_:

; 1046 :         else
; 1047 :         {
; 1048 :             /* (2) - Source operand crosses a boundary */
; 1049 :             len1 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  0021a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00222	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00228	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0022d	48 2b c8	 sub	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1050 :             source2 = MADDRL( (addr2 + len1) & ADDRESS_MAXWRAP( regs ),

  00237	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0023e	ff c0		 inc	 eax
  00240	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  00244	48 98		 cdqe
  00246	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  0024b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR addr2$[rsp]
  00253	48 03 d1	 add	 rdx, rcx
  00256	48 8b ca	 mov	 rcx, rdx
  00259	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00261	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00268	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  00270	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00274	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0027c	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00284	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0028c	48 8b d0	 mov	 rdx, rax
  0028f	e8 00 00 00 00	 call	 z900_maddr_l
  00294	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1051 :                    len + 1 - len1, arn2, regs, ACCTYPE_READ, key2 );
; 1052 : 
; 1053 :             concpy( regs, dest1,        source1,       len1     );

  00299	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  0029e	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  002a3	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002a8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b0	e8 00 00 00 00	 call	 concpy

; 1054 :             concpy( regs, dest1 + len1, source2, len - len1 + 1 );

  002b5	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  002b9	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  002c0	2b c8		 sub	 ecx, eax
  002c2	8b c1		 mov	 eax, ecx
  002c4	ff c0		 inc	 eax
  002c6	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  002cb	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002d0	48 03 d1	 add	 rdx, rcx
  002d3	48 8b ca	 mov	 rcx, rdx
  002d6	44 8b c8	 mov	 r9d, eax
  002d9	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  002de	48 8b d1	 mov	 rdx, rcx
  002e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	e8 00 00 00 00	 call	 concpy
$LN6@z900_move_:

; 1055 :         }
; 1056 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  002ee	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  002f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f6	83 c8 06	 or	 eax, 6
  002f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  002fe	88 01		 mov	 BYTE PTR [rcx], al

; 1057 :     }

  00300	e9 52 03 00 00	 jmp	 $LN4@z900_move_
$LN3@z900_move_:

; 1058 :     else
; 1059 :     {
; 1060 :         /* Destination operand crosses a boundary */
; 1061 :         len1 = PAGEFRAME_PAGESIZE - (addr1 & PAGEFRAME_BYTEMASK);

  00305	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  0030d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00313	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00318	48 2b c8	 sub	 rcx, rax
  0031b	48 8b c1	 mov	 rax, rcx
  0031e	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1062 :         dest2 = MADDRL( (addr1 + len1) & ADDRESS_MAXWRAP( regs ),

  00322	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00329	ff c0		 inc	 eax
  0032b	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  0032f	48 98		 cdqe
  00331	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00336	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr1$[rsp]
  0033e	48 03 d1	 add	 rdx, rcx
  00341	48 8b ca	 mov	 rcx, rdx
  00344	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00353	0f b6 94 24 a0
	00 00 00	 movzx	 edx, BYTE PTR key1$[rsp]
  0035b	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0035f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00367	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0036f	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00377	48 8b d0	 mov	 rdx, rax
  0037a	e8 00 00 00 00	 call	 z900_maddr_l
  0037f	48 89 44 24 68	 mov	 QWORD PTR dest2$[rsp], rax

; 1063 :             len + 1 - len1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );
; 1064 :         sk2 = regs->dat.storkey;

  00384	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00393	48 89 44 24 78	 mov	 QWORD PTR sk2$[rsp], rax

; 1065 : 
; 1066 :         if (NOCROSSPAGE( addr2, len ))

  00398	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  003a0	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  003a6	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  003ab	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  003b2	3b c1		 cmp	 eax, ecx
  003b4	7f 0a		 jg	 SHORT $LN30@z900_move_
  003b6	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  003be	eb 08		 jmp	 SHORT $LN31@z900_move_
$LN30@z900_move_:
  003c0	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN31@z900_move_:
  003c8	83 7c 24 60 00	 cmp	 DWORD PTR tv226[rsp], 0
  003cd	74 5a		 je	 SHORT $LN7@z900_move_

; 1067 :         {
; 1068 :              /* (3) - Source operand crosses a boundary */
; 1069 :              concpy( regs, dest1, source1,              len1     );

  003cf	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  003d4	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  003d9	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  003de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e6	e8 00 00 00 00	 call	 concpy

; 1070 :              concpy( regs, dest2, source1 + len1, len - len1 + 1 );

  003eb	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  003ef	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  003f6	2b c8		 sub	 ecx, eax
  003f8	8b c1		 mov	 eax, ecx
  003fa	ff c0		 inc	 eax
  003fc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00401	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  00406	48 03 d1	 add	 rdx, rcx
  00409	48 8b ca	 mov	 rcx, rdx
  0040c	44 8b c8	 mov	 r9d, eax
  0040f	4c 8b c1	 mov	 r8, rcx
  00412	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00417	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	e8 00 00 00 00	 call	 concpy

; 1071 :         }

  00424	e9 0a 02 00 00	 jmp	 $LN8@z900_move_
$LN7@z900_move_:

; 1072 :         else
; 1073 :         {
; 1074 :             /* (4) - Both operands cross a boundary */
; 1075 :             len2 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  00429	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  00431	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00437	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0043c	48 2b c8	 sub	 rcx, rax
  0043f	48 8b c1	 mov	 rax, rcx
  00442	89 44 24 34	 mov	 DWORD PTR len2$[rsp], eax

; 1076 :             source2 = MADDRL( (addr2 + len2) & ADDRESS_MAXWRAP( regs ),

  00446	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0044d	ff c0		 inc	 eax
  0044f	2b 44 24 34	 sub	 eax, DWORD PTR len2$[rsp]
  00453	48 98		 cdqe
  00455	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0045a	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR addr2$[rsp]
  00462	48 03 d1	 add	 rdx, rcx
  00465	48 8b ca	 mov	 rcx, rdx
  00468	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00470	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00477	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  0047f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00483	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0048b	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00493	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0049b	48 8b d0	 mov	 rdx, rax
  0049e	e8 00 00 00 00	 call	 z900_maddr_l
  004a3	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1077 :                 len + 1 - len2, arn2, regs, ACCTYPE_READ, key2 );
; 1078 : 
; 1079 :             if (len1 == len2)

  004a8	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  004ac	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  004b0	75 4c		 jne	 SHORT $LN9@z900_move_

; 1080 :             {
; 1081 :                 /* (4a) - Both operands cross at the same time */
; 1082 :                 concpy( regs, dest1, source1,       len1     );

  004b2	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  004b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  004bc	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  004c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c9	e8 00 00 00 00	 call	 concpy

; 1083 :                 concpy( regs, dest2, source2, len - len1 + 1 );

  004ce	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  004d2	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  004d9	2b c8		 sub	 ecx, eax
  004db	8b c1		 mov	 eax, ecx
  004dd	ff c0		 inc	 eax
  004df	44 8b c8	 mov	 r9d, eax
  004e2	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  004e7	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  004ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f4	e8 00 00 00 00	 call	 concpy

; 1084 :             }

  004f9	e9 35 01 00 00	 jmp	 $LN10@z900_move_
$LN9@z900_move_:

; 1085 :             else if (len1 < len2)

  004fe	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00502	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  00506	0f 8d 96 00 00
	00		 jge	 $LN11@z900_move_

; 1086 :             {
; 1087 :                 /* (4b) - Destination operand crosses first */
; 1088 :                 concpy( regs, dest1,               source1,               len1     );

  0050c	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00511	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00516	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0051b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00523	e8 00 00 00 00	 call	 concpy

; 1089 :                 concpy( regs, dest2,               source1 + len1, len2 - len1     );

  00528	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  0052c	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  00530	2b c8		 sub	 ecx, eax
  00532	8b c1		 mov	 eax, ecx
  00534	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00539	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  0053e	48 03 d1	 add	 rdx, rcx
  00541	48 8b ca	 mov	 rcx, rdx
  00544	44 8b c8	 mov	 r9d, eax
  00547	4c 8b c1	 mov	 r8, rcx
  0054a	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  0054f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00557	e8 00 00 00 00	 call	 concpy

; 1090 :                 concpy( regs, dest2 + len2 - len1, source2,        len  - len2 + 1 );

  0055c	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00560	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00567	2b c8		 sub	 ecx, eax
  00569	8b c1		 mov	 eax, ecx
  0056b	ff c0		 inc	 eax
  0056d	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00572	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00577	48 03 d1	 add	 rdx, rcx
  0057a	48 8b ca	 mov	 rcx, rdx
  0057d	48 63 54 24 30	 movsxd	 rdx, DWORD PTR len1$[rsp]
  00582	48 2b ca	 sub	 rcx, rdx
  00585	44 8b c8	 mov	 r9d, eax
  00588	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  0058d	48 8b d1	 mov	 rdx, rcx
  00590	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00598	e8 00 00 00 00	 call	 concpy

; 1091 :             }

  0059d	e9 91 00 00 00	 jmp	 $LN12@z900_move_
$LN11@z900_move_:

; 1092 :             else
; 1093 :             {
; 1094 :                 /* (4c) - Source operand crosses first */
; 1095 :                 concpy( regs, dest1,        source1,                      len2     );

  005a2	44 8b 4c 24 34	 mov	 r9d, DWORD PTR len2$[rsp]
  005a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  005ac	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  005b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b9	e8 00 00 00 00	 call	 concpy

; 1096 :                 concpy( regs, dest1 + len2, source2,               len1 - len2     );

  005be	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  005c2	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  005c6	2b c8		 sub	 ecx, eax
  005c8	8b c1		 mov	 eax, ecx
  005ca	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  005cf	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  005d4	48 03 d1	 add	 rdx, rcx
  005d7	48 8b ca	 mov	 rcx, rdx
  005da	44 8b c8	 mov	 r9d, eax
  005dd	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  005e2	48 8b d1	 mov	 rdx, rcx
  005e5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ed	e8 00 00 00 00	 call	 concpy

; 1097 :                 concpy( regs, dest2,        source2 + len1 - len2, len -  len1 + 1 );

  005f2	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  005f6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  005fd	2b c8		 sub	 ecx, eax
  005ff	8b c1		 mov	 eax, ecx
  00601	ff c0		 inc	 eax
  00603	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00608	48 8b 54 24 48	 mov	 rdx, QWORD PTR source2$[rsp]
  0060d	48 03 d1	 add	 rdx, rcx
  00610	48 8b ca	 mov	 rcx, rdx
  00613	48 63 54 24 34	 movsxd	 rdx, DWORD PTR len2$[rsp]
  00618	48 2b ca	 sub	 rcx, rdx
  0061b	44 8b c8	 mov	 r9d, eax
  0061e	4c 8b c1	 mov	 r8, rcx
  00621	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00626	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	e8 00 00 00 00	 call	 concpy
$LN12@z900_move_:
$LN10@z900_move_:
$LN8@z900_move_:

; 1098 :             }
; 1099 :         }
; 1100 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  00633	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  00638	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0063b	83 c8 06	 or	 eax, 6
  0063e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  00643	88 01		 mov	 BYTE PTR [rcx], al

; 1101 :         *sk2 |= (STORKEY_REF | STORKEY_CHANGE);

  00645	48 8b 44 24 78	 mov	 rax, QWORD PTR sk2$[rsp]
  0064a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0064d	83 c8 06	 or	 eax, 6
  00650	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sk2$[rsp]
  00655	88 01		 mov	 BYTE PTR [rcx], al
$LN4@z900_move_:
$LN1@z900_move_:

; 1102 :     }
; 1103 :     ITIMER_UPDATE( addr1, len, regs );
; 1104 : 
; 1105 : } /* end function ARCH_DEP(move_chars) */

  00657	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0065e	c3		 ret	 0
z900_move_chars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 56
ip$ = 64
offset$ = 72
len$ = 76
tv128 = 80
tv130 = 84
tv137 = 88
tv156 = 92
tv172 = 96
tv174 = 100
tv180 = 104
tv187 = 108
tv204 = 112
tv239 = 116
tv238 = 120
tv240 = 124
tv256 = 128
tv350 = 132
tv351 = 136
dest$ = 144
tv75 = 152
tv77 = 160
tv357 = 168
regs$ = 192
exec$ = 200
z900_instfetch PROC					; COMDAT

; 777  : {

$LN96:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 1c		 je	 SHORT $LN52@z900_instf
  0001a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00029	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  00031	e9 85 00 00 00	 jmp	 $LN53@z900_instf
$LN52@z900_instf:
  00036	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00046	74 4c		 je	 SHORT $LN50@z900_instf
  00048	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 2b c1	 sub	 rax, rcx
  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0008a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00092	eb 17		 jmp	 SHORT $LN51@z900_instf
$LN50@z900_instf:
  00094	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  000a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN51@z900_instf:
  000ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000b3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN53@z900_instf:
  000bb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv77[rsp]
  000c3	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000c8	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000d0	75 69		 jne	 SHORT $LN23@z900_instf
$LN4@z900_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000e2	74 51		 je	 SHORT $LN24@z900_instf
  000e4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  000fb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ff	48 2b c1	 sub	 rax, rcx
  00102	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00111	48 03 c8	 add	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00126	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN24@z900_instf:
  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 97		 jne	 SHORT $LN4@z900_instf
$LN23@z900_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  00140	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00146	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0014a	48 81 7c 24 30
	00 08 00 00	 cmp	 QWORD PTR addr$[rsp], 2048 ; 00000800H
  00153	73 0a		 jae	 SHORT $LN56@z900_instf
  00155	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0015d	eb 08		 jmp	 SHORT $LN57@z900_instf
$LN56@z900_instf:
  0015f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN57@z900_instf:
  00167	83 7c 24 50 00	 cmp	 DWORD PTR tv128[rsp], 0
  0016c	74 0a		 je	 SHORT $LN58@z900_instf
  0016e	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv130[rsp], 2048 ; 00000800H
  00176	eb 08		 jmp	 SHORT $LN59@z900_instf
$LN58@z900_instf:
  00178	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv130[rsp], 4096 ; 00001000H
$LN59@z900_instf:
  00180	8b 44 24 54	 mov	 eax, DWORD PTR tv130[rsp]
  00184	89 44 24 38	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00188	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0018c	83 e0 01	 and	 eax, 1
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN62@z900_instf
  00193	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN63@z900_instf
$LN62@z900_instf:
  0019d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN63@z900_instf:
  001a5	83 7c 24 58 00	 cmp	 DWORD PTR tv137[rsp], 0
  001aa	74 44		 je	 SHORT $LN25@z900_instf

; 798  :     {
; 799  :         if (!exec)

  001ac	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  001b4	75 1f		 jne	 SHORT $LN26@z900_instf

; 800  :             regs->instinvalid = 1;

  001b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001be	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c4	83 c8 08	 or	 eax, 8
  001c7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cf	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN26@z900_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001d5	ba 06 00 00 00	 mov	 edx, 6
  001da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001f0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001fe	c1 e8 02	 shr	 eax, 2
  00201	83 e0 01	 and	 eax, 1
  00204	85 c0		 test	 eax, eax
  00206	74 0a		 je	 SHORT $LN66@z900_instf
  00208	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  00210	eb 08		 jmp	 SHORT $LN67@z900_instf
$LN66@z900_instf:
  00212	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN67@z900_instf:
  0021a	83 7c 24 5c 00	 cmp	 DWORD PTR tv156[rsp], 0
  0021f	0f 84 16 05 00
	00		 je	 $LN27@z900_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  00225	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00231	83 e0 04	 and	 eax, 4
  00234	85 c0		 test	 eax, eax
  00236	74 0a		 je	 SHORT $LN68@z900_instf
  00238	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00240	eb 08		 jmp	 SHORT $LN69@z900_instf
$LN68@z900_instf:
  00242	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN69@z900_instf:
  0024a	83 7c 24 60 00	 cmp	 DWORD PTR tv172[rsp], 0
  0024f	74 0a		 je	 SHORT $LN70@z900_instf
  00251	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv174[rsp], 16
  00259	eb 08		 jmp	 SHORT $LN71@z900_instf
$LN70@z900_instf:
  0025b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN71@z900_instf:
  00263	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0026f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00274	85 c0		 test	 eax, eax
  00276	74 0a		 je	 SHORT $LN72@z900_instf
  00278	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00280	eb 08		 jmp	 SHORT $LN73@z900_instf
$LN72@z900_instf:
  00282	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN73@z900_instf:
  0028a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00292	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00296	83 e0 40	 and	 eax, 64			; 00000040H
  00299	85 c0		 test	 eax, eax
  0029b	74 0a		 je	 SHORT $LN74@z900_instf
  0029d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002a5	eb 08		 jmp	 SHORT $LN75@z900_instf
$LN74@z900_instf:
  002a7	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN75@z900_instf:
  002af	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002bd	83 e0 01	 and	 eax, 1
  002c0	c1 e0 07	 shl	 eax, 7
  002c3	83 c8 40	 or	 eax, 64			; 00000040H
  002c6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002d4	d1 e9		 shr	 ecx, 1
  002d6	83 e1 01	 and	 ecx, 1
  002d9	c1 e1 05	 shl	 ecx, 5
  002dc	0b c1		 or	 eax, ecx
  002de	0b 44 24 64	 or	 eax, DWORD PTR tv174[rsp]
  002e2	8b 4c 24 68	 mov	 ecx, DWORD PTR tv180[rsp]
  002e6	c1 e1 03	 shl	 ecx, 3
  002e9	0b c1		 or	 eax, ecx
  002eb	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv187[rsp]
  002ef	c1 e1 02	 shl	 ecx, 2
  002f2	0b c1		 or	 eax, ecx
  002f4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  00303	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0030b	75 14		 jne	 SHORT $LN28@z900_instf

; 822  :             regs->peradr = addr;

  0030d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00315	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0031a	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN28@z900_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00321	33 c0		 xor	 eax, eax
  00323	83 f8 01	 cmp	 eax, 1
  00326	0f 84 22 02 00
	00		 je	 $LN29@z900_instf
  0032c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00334	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0033a	c1 e8 02	 shr	 eax, 2
  0033d	83 e0 01	 and	 eax, 1
  00340	85 c0		 test	 eax, eax
  00342	74 0a		 je	 SHORT $LN78@z900_instf
  00344	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  0034c	eb 08		 jmp	 SHORT $LN79@z900_instf
$LN78@z900_instf:
  0034e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN79@z900_instf:
  00356	83 7c 24 70 00	 cmp	 DWORD PTR tv204[rsp], 0
  0035b	0f 84 ed 01 00
	00		 je	 $LN29@z900_instf
  00361	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0036c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00371	85 c0		 test	 eax, eax
  00373	0f 84 d5 01 00
	00		 je	 $LN29@z900_instf
  00379	b8 08 00 00 00	 mov	 eax, 8
  0037e	48 6b c0 0c	 imul	 rax, rax, 12
  00382	b9 08 00 00 00	 mov	 ecx, 8
  00387	48 6b c9 0b	 imul	 rcx, rcx, 11
  0038b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00393	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039b	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  003a3	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  003ab	72 5c		 jb	 SHORT $LN84@z900_instf
  003ad	b8 08 00 00 00	 mov	 eax, 8
  003b2	48 6b c0 0b	 imul	 rax, rax, 11
  003b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003be	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003c6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003cb	72 2a		 jb	 SHORT $LN80@z900_instf
  003cd	b8 08 00 00 00	 mov	 eax, 8
  003d2	48 6b c0 0c	 imul	 rax, rax, 12
  003d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003e6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003eb	77 0a		 ja	 SHORT $LN80@z900_instf
  003ed	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  003f5	eb 08		 jmp	 SHORT $LN83@z900_instf
$LN80@z900_instf:
  003f7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN83@z900_instf:
  003ff	8b 44 24 74	 mov	 eax, DWORD PTR tv239[rsp]
  00403	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
  00407	eb 5a		 jmp	 SHORT $LN85@z900_instf
$LN84@z900_instf:
  00409	b8 08 00 00 00	 mov	 eax, 8
  0040e	48 6b c0 0b	 imul	 rax, rax, 11
  00412	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00422	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00427	73 2a		 jae	 SHORT $LN81@z900_instf
  00429	b8 08 00 00 00	 mov	 eax, 8
  0042e	48 6b c0 0c	 imul	 rax, rax, 12
  00432	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00442	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00447	76 0a		 jbe	 SHORT $LN81@z900_instf
  00449	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  00451	eb 08		 jmp	 SHORT $LN82@z900_instf
$LN81@z900_instf:
  00453	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
$LN82@z900_instf:
  0045b	8b 44 24 78	 mov	 eax, DWORD PTR tv238[rsp]
  0045f	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
$LN85@z900_instf:
  00463	83 7c 24 7c 00	 cmp	 DWORD PTR tv240[rsp], 0
  00468	0f 84 e0 00 00
	00		 je	 $LN29@z900_instf
$LN7@z900_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  0046e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00476	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00479	0f ba e8 16	 bts	 eax, 22
  0047d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00488	33 c0		 xor	 eax, eax
  0048a	85 c0		 test	 eax, eax
  0048c	75 e0		 jne	 SHORT $LN7@z900_instf

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))

  0048e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00496	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049c	c1 e8 02	 shr	 eax, 2
  0049f	83 e0 01	 and	 eax, 1
  004a2	85 c0		 test	 eax, eax
  004a4	74 0d		 je	 SHORT $LN88@z900_instf
  004a6	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  004b1	eb 0b		 jmp	 SHORT $LN89@z900_instf
$LN88@z900_instf:
  004b3	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN89@z900_instf:
  004be	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv256[rsp], 0
  004c6	0f 84 82 00 00
	00		 je	 $LN30@z900_instf
  004cc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004d7	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  004dc	85 c0		 test	 eax, eax
  004de	74 6e		 je	 SHORT $LN30@z900_instf
$LN10@z900_instf:

; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );

  004e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e8	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  004eb	0f ba e8 10	 bts	 eax, 16
  004ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f7	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  004fa	33 c0		 xor	 eax, eax
  004fc	85 c0		 test	 eax, eax
  004fe	75 e0		 jne	 SHORT $LN10@z900_instf

; 839  :                 regs->psw.IA = addr;

  00500	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00508	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0050d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 840  :                 regs->psw.zeroilc = 1;

  00514	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00522	83 c8 04	 or	 eax, 4
  00525	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052d	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );

  00533	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00538	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00540	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_instf:
$LN29@z900_instf:

; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  0054e	33 c0		 xor	 eax, eax
  00550	83 f8 01	 cmp	 eax, 1
  00553	0f 84 e2 01 00
	00		 je	 $LN31@z900_instf
  00559	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00561	0f 85 d4 01 00
	00		 jne	 $LN31@z900_instf
  00567	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00575	c1 e8 10	 shr	 eax, 16
  00578	83 e0 01	 and	 eax, 1
  0057b	85 c0		 test	 eax, eax
  0057d	0f 85 b8 01 00
	00		 jne	 $LN31@z900_instf
  00583	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00593	0f 84 a2 01 00
	00		 je	 $LN31@z900_instf
  00599	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0059e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a6	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  005ad	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  005b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ba	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  005be	0f 83 77 01 00
	00		 jae	 $LN31@z900_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)

  005c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005d3	85 c0		 test	 eax, eax
  005d5	74 4d		 je	 SHORT $LN32@z900_instf

; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)

  005d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e7	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  005ee	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  005f5	75 2d		 jne	 SHORT $LN33@z900_instf

; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;

  005f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00606	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060e	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00615	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061d	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN33@z900_instf:
$LN32@z900_instf:
$LN13@z900_instf:

; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );

  00624	33 c0		 xor	 eax, eax
  00626	83 f8 01	 cmp	 eax, 1
  00629	74 6f		 je	 SHORT $LN34@z900_instf
  0062b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00633	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0063a	85 c0		 test	 eax, eax
  0063c	74 5c		 je	 SHORT $LN34@z900_instf
  0063e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064e	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00655	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00659	72 3f		 jb	 SHORT $LN34@z900_instf
  0065b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00663	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00669	0f ba e8 1f	 bts	 eax, 31
  0066d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0067b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00682	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00688	ba fe ff ff ff	 mov	 edx, -2
  0068d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00695	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_instf:
  0069a	33 c0		 xor	 eax, eax
  0069c	85 c0		 test	 eax, eax
  0069e	75 84		 jne	 SHORT $LN13@z900_instf

; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  006a0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006b7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006bb	48 2b c1	 sub	 rax, rcx
  006be	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c6	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  006cd	48 03 c8	 add	 rcx, rax
  006d0	48 8b c1	 mov	 rax, rcx
  006d3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006db	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  006e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ea	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  006f1	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  006f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fe	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00703	0f b6 c0	 movzx	 eax, al
  00706	85 c0		 test	 eax, eax
  00708	74 20		 je	 SHORT $LN35@z900_instf
$LN16@z900_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  0070a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00712	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00715	0f ba f0 16	 btr	 eax, 22
  00719	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00721	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00724	33 c0		 xor	 eax, eax
  00726	85 c0		 test	 eax, eax
  00728	75 e0		 jne	 SHORT $LN16@z900_instf
$LN35@z900_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  0072a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00732	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00736	e9 49 04 00 00	 jmp	 $LN1@z900_instf
$LN31@z900_instf:
$LN27@z900_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  0073b	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00743	75 1f		 jne	 SHORT $LN36@z900_instf

; 882  :         regs->instinvalid = 1;

  00745	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00753	83 c8 08	 or	 eax, 8
  00756	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN36@z900_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  00764	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00770	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00774	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0077c	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00784	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0078a	ba 06 00 00 00	 mov	 edx, 6
  0078f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00794	e8 00 00 00 00	 call	 z900_maddr_l
  00799	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  0079e	b8 01 00 00 00	 mov	 eax, 1
  007a3	48 6b c0 00	 imul	 rax, rax, 0
  007a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  007b3	7d 0d		 jge	 SHORT $LN92@z900_instf
  007b5	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv351[rsp], 2
  007c0	eb 3f		 jmp	 SHORT $LN93@z900_instf
$LN92@z900_instf:
  007c2	b8 01 00 00 00	 mov	 eax, 1
  007c7	48 6b c0 00	 imul	 rax, rax, 0
  007cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007d4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  007d9	7d 0d		 jge	 SHORT $LN90@z900_instf
  007db	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv350[rsp], 4
  007e6	eb 0b		 jmp	 SHORT $LN91@z900_instf
$LN90@z900_instf:
  007e8	c7 84 24 84 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv350[rsp], 6
$LN91@z900_instf:
  007f3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv350[rsp]
  007fa	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
$LN93@z900_instf:
  00801	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv351[rsp]
  00808	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  0080c	03 c8		 add	 ecx, eax
  0080e	8b c1		 mov	 eax, ecx
  00810	3b 44 24 38	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00814	0f 8e 06 01 00
	00		 jle	 $LN37@z900_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0081a	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00822	74 18		 je	 SHORT $LN94@z900_instf
  00824	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0082c	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00832	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  0083a	eb 16		 jmp	 SHORT $LN95@z900_instf
$LN94@z900_instf:
  0083c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00844	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0084a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
$LN95@z900_instf:
  00852	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv357[rsp]
  0085a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00862	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0086a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  0086f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00871	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  00873	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00877	8b 4c 24 38	 mov	 ecx, DWORD PTR pagesz$[rsp]
  0087b	2b c8		 sub	 ecx, eax
  0087d	8b c1		 mov	 eax, ecx
  0087f	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  00883	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  00888	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0088d	48 03 c8	 add	 rcx, rax
  00890	48 8b c1	 mov	 rax, rcx
  00893	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  008a2	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  008a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008af	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  008b3	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  008b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  008bf	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008c7	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  008cd	ba 01 00 00 00	 mov	 edx, 1
  008d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  008d7	e8 00 00 00 00	 call	 z900_maddr_l
  008dc	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  008e1	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  008e9	75 1c		 jne	 SHORT $LN39@z900_instf

; 899  :             regs->ip = ip - len;

  008eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  008f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  008f5	48 2b c8	 sub	 rcx, rax
  008f8	48 8b c1	 mov	 rax, rcx
  008fb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN39@z900_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00907	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  0090c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00914	48 8b 54 24 40	 mov	 rdx, QWORD PTR ip$[rsp]
  00919	8b 12		 mov	 edx, DWORD PTR [rdx]
  0091b	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0091e	eb 28		 jmp	 SHORT $LN38@z900_instf
$LN37@z900_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  00920	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00925	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0092d	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00935	75 11		 jne	 SHORT $LN40@z900_instf

; 907  :             regs->ip = ip;

  00937	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  00944	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN40@z900_instf:
$LN38@z900_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00948	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00950	0f 85 c0 00 00
	00		 jne	 $LN41@z900_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00956	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00964	83 e0 f7	 and	 eax, -9			; fffffff7H
  00967	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096f	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00975	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  0097a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00980	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00988	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  0098f	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00994	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0099a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  009a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009b7	c1 e8 10	 shr	 eax, 16
  009ba	83 e0 01	 and	 eax, 1
  009bd	85 c0		 test	 eax, eax
  009bf	75 18		 jne	 SHORT $LN44@z900_instf
  009c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009cf	c1 e8 02	 shr	 eax, 2
  009d2	83 e0 01	 and	 eax, 1
  009d5	85 c0		 test	 eax, eax
  009d7	74 15		 je	 SHORT $LN42@z900_instf
$LN44@z900_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  009d9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e1	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  009ec	eb 28		 jmp	 SHORT $LN43@z900_instf
$LN42@z900_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  009ee	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  009f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00a02	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00a07	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0f	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN43@z900_instf:
$LN41@z900_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)

  00a16	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a25	85 c0		 test	 eax, eax
  00a27	74 4d		 je	 SHORT $LN45@z900_instf

; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)

  00a29	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a31	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a39	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  00a40	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  00a47	75 2d		 jne	 SHORT $LN46@z900_instf

; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;

  00a49	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a51	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00a58	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a60	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00a67	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6f	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN46@z900_instf:
$LN45@z900_instf:
$LN19@z900_instf:

; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );

  00a76	33 c0		 xor	 eax, eax
  00a78	83 f8 01	 cmp	 eax, 1
  00a7b	74 6f		 je	 SHORT $LN47@z900_instf
  00a7d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a85	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a8c	85 c0		 test	 eax, eax
  00a8e	74 5c		 je	 SHORT $LN47@z900_instf
  00a90	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a98	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa0	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00aa7	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00aab	72 3f		 jb	 SHORT $LN47@z900_instf
  00aad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00abb	0f ba e8 1f	 bts	 eax, 31
  00abf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00acd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00ad4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00ada	ba fe ff ff ff	 mov	 edx, -2
  00adf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ae7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN47@z900_instf:
  00aec	33 c0		 xor	 eax, eax
  00aee	85 c0		 test	 eax, eax
  00af0	75 84		 jne	 SHORT $LN19@z900_instf

; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00af2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00afa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b02	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00b09	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00b0d	48 2b c1	 sub	 rax, rcx
  00b10	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b18	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00b1f	48 03 c8	 add	 rcx, rax
  00b22	48 8b c1	 mov	 rax, rcx
  00b25	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00b34	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b3c	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00b43	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00b48	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b50	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00b55	0f b6 c0	 movzx	 eax, al
  00b58	85 c0		 test	 eax, eax
  00b5a	74 20		 je	 SHORT $LN48@z900_instf
$LN22@z900_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00b5c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b64	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00b67	0f ba f0 16	 btr	 eax, 22
  00b6b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b73	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00b76	33 c0		 xor	 eax, eax
  00b78	85 c0		 test	 eax, eax
  00b7a	75 e0		 jne	 SHORT $LN22@z900_instf
$LN48@z900_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  00b7c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@z900_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  00b84	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00b8b	c3		 ret	 0
z900_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2 PROC					; COMDAT

; 679  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 01	 and	 rax, 1
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  00063	74 47		 je	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );
; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 02 00 00 00	 mov	 edx, 2
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	e8 00 00 00 00	 call	 _byteswap_ushort
  000aa	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000ac	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000ba	e8 00 00 00 00	 call	 z900_vfetch2_full
$LN1@z900_vfetc:

; 689  : }

  000bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c3	c3		 ret	 0
z900_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
z900_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore2
_TEXT	SEGMENT
tv73 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore2 PROC					; COMDAT

; 541  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 83 e0 01	 and	 rax, 1
  00021	48 85 c0	 test	 rax, rax
  00024	74 1d		 je	 SHORT $LN5@z900_vstor
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  00037	75 0a		 jne	 SHORT $LN5@z900_vstor
  00039	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN5@z900_vstor:
  00043	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN8@z900_vstor:
  0004b	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00050	74 4c		 je	 SHORT $LN2@z900_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0005b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0005f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00067	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0006c	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00071	ba 02 00 00 00	 mov	 edx, 2
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0007b	e8 00 00 00 00	 call	 z900_maddr_l
  00080	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  00085	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  0008a	e8 00 00 00 00	 call	 _byteswap_ushort
  0008f	0f b7 d0	 movzx	 edx, ax
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00097	e8 00 00 00 00	 call	 store_hw_noswap

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );
; 550  :     }

  0009c	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  0009e	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000ad	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  000b2	e8 00 00 00 00	 call	 z900_vstore2_full
$LN3@z900_vstor:

; 553  : }

  000b7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bb	c3		 ret	 0
z900_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004d	c1 e0 08	 shl	 eax, 8
  00050	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0005a	48 ff c0	 inc	 rax
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00072	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00076	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00083	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00088	ba 01 00 00 00	 mov	 edx, 1
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 z900_maddr_l
  00095	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0009f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a2	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  000a7	0b c8		 or	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000b0	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
z900_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
z900_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00018	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00021	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00025	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002d	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00032	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00037	ba 01 00 00 00	 mov	 edx, 1
  0003c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  00041	e8 00 00 00 00	 call	 z900_maddr_l
  00046	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  0004b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00057	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR addr$[rsp]
  00061	48 ff c0	 inc	 rax
  00064	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00070	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00079	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0007d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00085	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0008a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 z900_maddr_l
  0009c	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a9	83 c8 06	 or	 eax, 6
  000ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000b1	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000b3	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000b8	c1 f8 08	 sar	 eax, 8
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000c0	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000c2	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000d1	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000d3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d7	c3		 ret	 0
z900_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT concpy_rl
_TEXT	SEGMENT
u8d$ = 32
u8s$ = 40
regs$ = 64
d$ = 72
s$ = 80
n$ = 88
concpy_rl PROC						; COMDAT

; 230  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 231  :     BYTE* u8d = (BYTE*)d + n;

  00018	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  0001d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR d$[rsp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax

; 232  :     BYTE* u8s = (BYTE*)s + n;

  0002d	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax
$LN2@concpy_rl:

; 233  : 
; 234  :     /* Copy until ready or 8 byte integral boundary */
; 235  :     while (n && ((uintptr_t) u8d & 7))

  00042	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  00047	74 43		 je	 SHORT $LN3@concpy_rl
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  0004e	48 83 e0 07	 and	 rax, 7
  00052	48 85 c0	 test	 rax, rax
  00055	74 35		 je	 SHORT $LN3@concpy_rl

; 236  :     {
; 237  :         *--u8d = *--u8s;

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  0005c	48 ff c8	 dec	 rax
  0005f	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00069	48 ff c8	 dec	 rax
  0006c	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u8s$[rsp]
  0007b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007e	88 08		 mov	 BYTE PTR [rax], cl

; 238  :         n--;

  00080	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  00084	ff c8		 dec	 eax
  00086	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 239  :     }

  0008a	eb b6		 jmp	 SHORT $LN2@concpy_rl
$LN3@concpy_rl:
$LN6@concpy_rl:

; 240  : 
; 241  : #if !((defined( SIZEOF_LONG )  && SIZEOF_LONG  > 7) || \
; 242  :       (defined( SIZEOF_INT_P ) && SIZEOF_INT_P > 7) || \
; 243  :        defined( OPTION_STRICT_ALLIGNMENT ))
; 244  : 
; 245  :     /* Code for 32-bit builds... */
; 246  : 
; 247  :     /* Copy full words in right condition, on enough length and (src - dst) distance */
; 248  :     if (1
; 249  :         && n
; 250  :         && regs->cpubit == regs->sysblk->started_mask
; 251  :         && abs( u8d - u8s ) > 3
; 252  :     )
; 253  :     {
; 254  :         while (n > 3)
; 255  :         {
; 256  :             store_fw_noswap( u8d-4, fetch_fw_noswap( u8s-4 ));
; 257  :             u8d -= 4;
; 258  :             u8s -= 4;
; 259  :             n   -= 4;
; 260  :         }
; 261  :     }
; 262  :     else // copy double words...
; 263  : 
; 264  : #else // x64 builds
; 265  : 
; 266  :     UNREFERENCED( regs );

  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	75 fa		 jne	 SHORT $LN6@concpy_rl

; 267  : 
; 268  : #endif // end code for 32-bit builds
; 269  : 
; 270  :     /* Copy double words on enough length and (src - dst) distance */
; 271  :     if (n && labs( u8d - u8s ) > 7)

  00092	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  00097	74 6e		 je	 SHORT $LN11@concpy_rl
  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u8d$[rsp]
  000a3	48 2b c8	 sub	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	8b c8		 mov	 ecx, eax
  000ab	e8 00 00 00 00	 call	 labs
  000b0	83 f8 07	 cmp	 eax, 7
  000b3	7e 52		 jle	 SHORT $LN11@concpy_rl
$LN7@concpy_rl:

; 272  :     {
; 273  :         while (n > 7)

  000b5	83 7c 24 58 07	 cmp	 DWORD PTR n$[rsp], 7
  000ba	7e 4b		 jle	 SHORT $LN8@concpy_rl

; 274  :         {
; 275  :             store_dw_noswap( u8d-8, fetch_dw_noswap( u8s - 8 ));

  000bc	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  000c1	48 83 e8 08	 sub	 rax, 8
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 fetch_dw_noswap
  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u8d$[rsp]
  000d2	48 83 e9 08	 sub	 rcx, 8
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	e8 00 00 00 00	 call	 store_dw_noswap

; 276  :             u8d -= 8;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  000e3	48 83 e8 08	 sub	 rax, 8
  000e7	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax

; 277  :             u8s -= 8;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  000f1	48 83 e8 08	 sub	 rax, 8
  000f5	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax

; 278  :             n   -= 8;

  000fa	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  000fe	83 e8 08	 sub	 eax, 8
  00101	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 279  :         }

  00105	eb ae		 jmp	 SHORT $LN7@concpy_rl
$LN8@concpy_rl:
$LN11@concpy_rl:
$LN9@concpy_rl:

; 280  :     }
; 281  : 
; 282  :     /* Copy leftovers */
; 283  :     while (n)

  00107	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  0010c	74 35		 je	 SHORT $LN10@concpy_rl

; 284  :     {
; 285  :         *--u8d = *--u8s;

  0010e	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  00113	48 ff c8	 dec	 rax
  00116	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax
  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00120	48 ff c8	 dec	 rax
  00123	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax
  00128	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  0012d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u8s$[rsp]
  00132	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00135	88 08		 mov	 BYTE PTR [rax], cl

; 286  :         n--;

  00137	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  0013b	ff c8		 dec	 eax
  0013d	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 287  :     }

  00141	eb c4		 jmp	 SHORT $LN9@concpy_rl
$LN10@concpy_rl:

; 288  : } /* end function concpy_rl */

  00143	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00147	c3		 ret	 0
concpy_rl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_move_chars
_TEXT	SEGMENT
len1$ = 48
len2$ = 52
source1$ = 56
dest1$ = 64
source2$ = 72
tv65 = 80
tv70 = 84
tv145 = 88
tv155 = 92
tv216 = 96
dest2$ = 104
sk1$ = 112
sk2$ = 120
addr1$ = 144
arn1$ = 152
key1$ = 160
addr2$ = 168
arn2$ = 176
key2$ = 184
len$ = 192
regs$ = 200
s390_move_chars PROC					; COMDAT

; 1005 : {

$LN32:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1006 : BYTE   *dest1,   *dest2;                /* Destination addresses     */
; 1007 : BYTE   *source1, *source2;              /* Source addresses          */
; 1008 : BYTE   *sk1,     *sk2;                  /* Storage key addresses     */
; 1009 : int     len1,     len2;                 /* Lengths to copy           */
; 1010 : 
; 1011 :     ITIMER_SYNC( addr2, len, regs );
; 1012 : 
; 1013 :     /* Quick out if copying just 1 byte */
; 1014 :     if (unlikely( !len ))

  00019	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00021	75 0a		 jne	 SHORT $LN14@s390_move_
  00023	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002b	eb 08		 jmp	 SHORT $LN15@s390_move_
$LN14@s390_move_:
  0002d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN15@s390_move_:
  00035	83 7c 24 50 00	 cmp	 DWORD PTR tv65[rsp], 0
  0003a	74 0a		 je	 SHORT $LN18@s390_move_
  0003c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN19@s390_move_
$LN18@s390_move_:
  00046	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN19@s390_move_:
  0004e	83 7c 24 54 00	 cmp	 DWORD PTR tv70[rsp], 0
  00053	0f 84 88 00 00
	00		 je	 $LN2@s390_move_

; 1015 :     {
; 1016 :         source1 = MADDR( addr2, arn2, regs, ACCTYPE_READ,  key2 );

  00059	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR key2$[rsp]
  00061	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00065	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00075	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  00089	e8 00 00 00 00	 call	 s390_maddr_l
  0008e	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1017 :         dest1   = MADDR( addr1, arn1, regs, ACCTYPE_WRITE, key1 );

  00093	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR key1$[rsp]
  0009b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0009f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a7	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000af	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  000c3	e8 00 00 00 00	 call	 s390_maddr_l
  000c8	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1018 :         *dest1 = *source1;

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR dest1$[rsp]
  000d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR source1$[rsp]
  000d7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000da	88 08		 mov	 BYTE PTR [rax], cl

; 1019 :         ITIMER_UPDATE( addr1, len, regs );
; 1020 :         return;

  000dc	e9 50 05 00 00	 jmp	 $LN1@s390_move_
$LN2@s390_move_:

; 1021 :     }
; 1022 : 
; 1023 :     /* Translate addresses of leftmost operand bytes */
; 1024 :     source1 = MADDRL( addr2, len+1, arn2, regs, ACCTYPE_READ, key2 );

  000e1	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000e8	ff c0		 inc	 eax
  000ea	48 98		 cdqe
  000ec	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  000f4	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f8	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00100	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00108	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  00110	48 8b d0	 mov	 rdx, rax
  00113	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  0011a	e8 00 00 00 00	 call	 s390_maddr_l
  0011f	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1025 :     dest1   = MADDRL( addr1, len+1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );

  00124	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0012b	ff c0		 inc	 eax
  0012d	48 98		 cdqe
  0012f	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  00137	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0013b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00143	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0014b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00153	48 8b d0	 mov	 rdx, rax
  00156	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  0015d	e8 00 00 00 00	 call	 s390_maddr_l
  00162	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1026 :     sk1 = regs->dat.storkey;

  00167	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00176	48 89 44 24 70	 mov	 QWORD PTR sk1$[rsp], rax

; 1027 : 
; 1028 :     /* There are several scenarios (in optimal order):
; 1029 :      * (1) dest boundary and source boundary not crossed
; 1030 :      * (2) dest boundary not crossed and source boundary crossed
; 1031 :      * (3) dest boundary crossed and source boundary not crossed
; 1032 :      * (4) dest boundary and source boundary are crossed
; 1033 :      *     (a) dest and source boundary cross at the same time
; 1034 :      *     (b) dest boundary crossed first
; 1035 :      *     (c) source boundary crossed first
; 1036 :      * Note: since the operand length is limited to 256 bytes,
; 1037 :      *       neither operand can cross more than one 2K boundary.
; 1038 :      */
; 1039 :     if (NOCROSSPAGE( addr1, len ))

  0017b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr1$[rsp]
  00182	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00187	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  0018c	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  00193	3b c1		 cmp	 eax, ecx
  00195	7f 0a		 jg	 SHORT $LN22@s390_move_
  00197	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  0019f	eb 08		 jmp	 SHORT $LN23@s390_move_
$LN22@s390_move_:
  001a1	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s390_move_:
  001a9	83 7c 24 58 00	 cmp	 DWORD PTR tv145[rsp], 0
  001ae	0f 84 3f 01 00
	00		 je	 $LN3@s390_move_

; 1040 :     {
; 1041 :         if (NOCROSSPAGE( addr2, len ))

  001b4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  001bb	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001c0	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  001c5	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  001cc	3b c1		 cmp	 eax, ecx
  001ce	7f 0a		 jg	 SHORT $LN26@s390_move_
  001d0	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  001d8	eb 08		 jmp	 SHORT $LN27@s390_move_
$LN26@s390_move_:
  001da	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN27@s390_move_:
  001e2	83 7c 24 5c 00	 cmp	 DWORD PTR tv155[rsp], 0
  001e7	74 28		 je	 SHORT $LN5@s390_move_

; 1042 :         {
; 1043 :             /* (1) - No boundaries are crossed */
; 1044 :             concpy( regs, dest1, source1, len + 1 );

  001e9	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f0	ff c0		 inc	 eax
  001f2	44 8b c8	 mov	 r9d, eax
  001f5	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  001fa	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  001ff	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	e8 00 00 00 00	 call	 concpy

; 1045 :         }

  0020c	e9 cb 00 00 00	 jmp	 $LN6@s390_move_
$LN5@s390_move_:

; 1046 :         else
; 1047 :         {
; 1048 :             /* (2) - Source operand crosses a boundary */
; 1049 :             len1 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  00211	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  00218	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0021d	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00222	2b c8		 sub	 ecx, eax
  00224	8b c1		 mov	 eax, ecx
  00226	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1050 :             source2 = MADDRL( (addr2 + len1) & ADDRESS_MAXWRAP( regs ),

  0022a	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00231	ff c0		 inc	 eax
  00233	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  00237	48 98		 cdqe
  00239	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  0023d	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  00244	03 d1		 add	 edx, ecx
  00246	8b ca		 mov	 ecx, edx
  00248	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00250	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00256	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  0025e	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00262	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0026a	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00272	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0027a	48 8b d0	 mov	 rdx, rax
  0027d	e8 00 00 00 00	 call	 s390_maddr_l
  00282	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1051 :                    len + 1 - len1, arn2, regs, ACCTYPE_READ, key2 );
; 1052 : 
; 1053 :             concpy( regs, dest1,        source1,       len1     );

  00287	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  0028c	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00291	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00296	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	e8 00 00 00 00	 call	 concpy

; 1054 :             concpy( regs, dest1 + len1, source2, len - len1 + 1 );

  002a3	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  002a7	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  002ae	2b c8		 sub	 ecx, eax
  002b0	8b c1		 mov	 eax, ecx
  002b2	ff c0		 inc	 eax
  002b4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  002b9	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002be	48 03 d1	 add	 rdx, rcx
  002c1	48 8b ca	 mov	 rcx, rdx
  002c4	44 8b c8	 mov	 r9d, eax
  002c7	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  002cc	48 8b d1	 mov	 rdx, rcx
  002cf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d7	e8 00 00 00 00	 call	 concpy
$LN6@s390_move_:

; 1055 :         }
; 1056 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  002dc	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  002e1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e4	83 c8 06	 or	 eax, 6
  002e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  002ec	88 01		 mov	 BYTE PTR [rcx], al

; 1057 :     }

  002ee	e9 3e 03 00 00	 jmp	 $LN4@s390_move_
$LN3@s390_move_:

; 1058 :     else
; 1059 :     {
; 1060 :         /* Destination operand crosses a boundary */
; 1061 :         len1 = PAGEFRAME_PAGESIZE - (addr1 & PAGEFRAME_BYTEMASK);

  002f3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr1$[rsp]
  002fa	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  002ff	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00304	2b c8		 sub	 ecx, eax
  00306	8b c1		 mov	 eax, ecx
  00308	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1062 :         dest2 = MADDRL( (addr1 + len1) & ADDRESS_MAXWRAP( regs ),

  0030c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00313	ff c0		 inc	 eax
  00315	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  00319	48 98		 cdqe
  0031b	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  0031f	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr1$[rsp]
  00326	03 d1		 add	 edx, ecx
  00328	8b ca		 mov	 ecx, edx
  0032a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00332	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00338	0f b6 94 24 a0
	00 00 00	 movzx	 edx, BYTE PTR key1$[rsp]
  00340	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00344	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0034c	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00354	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  0035c	48 8b d0	 mov	 rdx, rax
  0035f	e8 00 00 00 00	 call	 s390_maddr_l
  00364	48 89 44 24 68	 mov	 QWORD PTR dest2$[rsp], rax

; 1063 :             len + 1 - len1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );
; 1064 :         sk2 = regs->dat.storkey;

  00369	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00371	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00378	48 89 44 24 78	 mov	 QWORD PTR sk2$[rsp], rax

; 1065 : 
; 1066 :         if (NOCROSSPAGE( addr2, len ))

  0037d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  00384	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00389	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  0038e	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  00395	3b c1		 cmp	 eax, ecx
  00397	7f 0a		 jg	 SHORT $LN30@s390_move_
  00399	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  003a1	eb 08		 jmp	 SHORT $LN31@s390_move_
$LN30@s390_move_:
  003a3	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN31@s390_move_:
  003ab	83 7c 24 60 00	 cmp	 DWORD PTR tv216[rsp], 0
  003b0	74 5a		 je	 SHORT $LN7@s390_move_

; 1067 :         {
; 1068 :              /* (3) - Source operand crosses a boundary */
; 1069 :              concpy( regs, dest1, source1,              len1     );

  003b2	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  003b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  003bc	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  003c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	e8 00 00 00 00	 call	 concpy

; 1070 :              concpy( regs, dest2, source1 + len1, len - len1 + 1 );

  003ce	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  003d2	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  003d9	2b c8		 sub	 ecx, eax
  003db	8b c1		 mov	 eax, ecx
  003dd	ff c0		 inc	 eax
  003df	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  003e4	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  003e9	48 03 d1	 add	 rdx, rcx
  003ec	48 8b ca	 mov	 rcx, rdx
  003ef	44 8b c8	 mov	 r9d, eax
  003f2	4c 8b c1	 mov	 r8, rcx
  003f5	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  003fa	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	e8 00 00 00 00	 call	 concpy

; 1071 :         }

  00407	e9 01 02 00 00	 jmp	 $LN8@s390_move_
$LN7@s390_move_:

; 1072 :         else
; 1073 :         {
; 1074 :             /* (4) - Both operands cross a boundary */
; 1075 :             len2 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  0040c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  00413	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00418	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0041d	2b c8		 sub	 ecx, eax
  0041f	8b c1		 mov	 eax, ecx
  00421	89 44 24 34	 mov	 DWORD PTR len2$[rsp], eax

; 1076 :             source2 = MADDRL( (addr2 + len2) & ADDRESS_MAXWRAP( regs ),

  00425	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0042c	ff c0		 inc	 eax
  0042e	2b 44 24 34	 sub	 eax, DWORD PTR len2$[rsp]
  00432	48 98		 cdqe
  00434	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  00438	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  0043f	03 d1		 add	 edx, ecx
  00441	8b ca		 mov	 ecx, edx
  00443	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0044b	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00451	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  00459	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0045d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00465	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0046d	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  00475	48 8b d0	 mov	 rdx, rax
  00478	e8 00 00 00 00	 call	 s390_maddr_l
  0047d	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1077 :                 len + 1 - len2, arn2, regs, ACCTYPE_READ, key2 );
; 1078 : 
; 1079 :             if (len1 == len2)

  00482	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00486	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  0048a	75 4c		 jne	 SHORT $LN9@s390_move_

; 1080 :             {
; 1081 :                 /* (4a) - Both operands cross at the same time */
; 1082 :                 concpy( regs, dest1, source1,       len1     );

  0048c	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00491	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00496	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0049b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a3	e8 00 00 00 00	 call	 concpy

; 1083 :                 concpy( regs, dest2, source2, len - len1 + 1 );

  004a8	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  004ac	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  004b3	2b c8		 sub	 ecx, eax
  004b5	8b c1		 mov	 eax, ecx
  004b7	ff c0		 inc	 eax
  004b9	44 8b c8	 mov	 r9d, eax
  004bc	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  004c1	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  004c6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ce	e8 00 00 00 00	 call	 concpy

; 1084 :             }

  004d3	e9 35 01 00 00	 jmp	 $LN10@s390_move_
$LN9@s390_move_:

; 1085 :             else if (len1 < len2)

  004d8	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  004dc	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  004e0	0f 8d 96 00 00
	00		 jge	 $LN11@s390_move_

; 1086 :             {
; 1087 :                 /* (4b) - Destination operand crosses first */
; 1088 :                 concpy( regs, dest1,               source1,               len1     );

  004e6	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  004eb	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  004f0	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  004f5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004fd	e8 00 00 00 00	 call	 concpy

; 1089 :                 concpy( regs, dest2,               source1 + len1, len2 - len1     );

  00502	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  00506	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  0050a	2b c8		 sub	 ecx, eax
  0050c	8b c1		 mov	 eax, ecx
  0050e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00513	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  00518	48 03 d1	 add	 rdx, rcx
  0051b	48 8b ca	 mov	 rcx, rdx
  0051e	44 8b c8	 mov	 r9d, eax
  00521	4c 8b c1	 mov	 r8, rcx
  00524	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00529	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00531	e8 00 00 00 00	 call	 concpy

; 1090 :                 concpy( regs, dest2 + len2 - len1, source2,        len  - len2 + 1 );

  00536	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  0053a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00541	2b c8		 sub	 ecx, eax
  00543	8b c1		 mov	 eax, ecx
  00545	ff c0		 inc	 eax
  00547	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0054c	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00551	48 03 d1	 add	 rdx, rcx
  00554	48 8b ca	 mov	 rcx, rdx
  00557	48 63 54 24 30	 movsxd	 rdx, DWORD PTR len1$[rsp]
  0055c	48 2b ca	 sub	 rcx, rdx
  0055f	44 8b c8	 mov	 r9d, eax
  00562	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  00567	48 8b d1	 mov	 rdx, rcx
  0056a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00572	e8 00 00 00 00	 call	 concpy

; 1091 :             }

  00577	e9 91 00 00 00	 jmp	 $LN12@s390_move_
$LN11@s390_move_:

; 1092 :             else
; 1093 :             {
; 1094 :                 /* (4c) - Source operand crosses first */
; 1095 :                 concpy( regs, dest1,        source1,                      len2     );

  0057c	44 8b 4c 24 34	 mov	 r9d, DWORD PTR len2$[rsp]
  00581	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00586	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0058b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00593	e8 00 00 00 00	 call	 concpy

; 1096 :                 concpy( regs, dest1 + len2, source2,               len1 - len2     );

  00598	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  0059c	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  005a0	2b c8		 sub	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  005a9	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  005ae	48 03 d1	 add	 rdx, rcx
  005b1	48 8b ca	 mov	 rcx, rdx
  005b4	44 8b c8	 mov	 r9d, eax
  005b7	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  005bc	48 8b d1	 mov	 rdx, rcx
  005bf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c7	e8 00 00 00 00	 call	 concpy

; 1097 :                 concpy( regs, dest2,        source2 + len1 - len2, len -  len1 + 1 );

  005cc	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  005d0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  005d7	2b c8		 sub	 ecx, eax
  005d9	8b c1		 mov	 eax, ecx
  005db	ff c0		 inc	 eax
  005dd	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  005e2	48 8b 54 24 48	 mov	 rdx, QWORD PTR source2$[rsp]
  005e7	48 03 d1	 add	 rdx, rcx
  005ea	48 8b ca	 mov	 rcx, rdx
  005ed	48 63 54 24 34	 movsxd	 rdx, DWORD PTR len2$[rsp]
  005f2	48 2b ca	 sub	 rcx, rdx
  005f5	44 8b c8	 mov	 r9d, eax
  005f8	4c 8b c1	 mov	 r8, rcx
  005fb	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest2$[rsp]
  00600	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00608	e8 00 00 00 00	 call	 concpy
$LN12@s390_move_:
$LN10@s390_move_:
$LN8@s390_move_:

; 1098 :             }
; 1099 :         }
; 1100 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  0060d	48 8b 44 24 70	 mov	 rax, QWORD PTR sk1$[rsp]
  00612	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00615	83 c8 06	 or	 eax, 6
  00618	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sk1$[rsp]
  0061d	88 01		 mov	 BYTE PTR [rcx], al

; 1101 :         *sk2 |= (STORKEY_REF | STORKEY_CHANGE);

  0061f	48 8b 44 24 78	 mov	 rax, QWORD PTR sk2$[rsp]
  00624	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00627	83 c8 06	 or	 eax, 6
  0062a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sk2$[rsp]
  0062f	88 01		 mov	 BYTE PTR [rcx], al
$LN4@s390_move_:
$LN1@s390_move_:

; 1102 :     }
; 1103 :     ITIMER_UPDATE( addr1, len, regs );
; 1104 : 
; 1105 : } /* end function ARCH_DEP(move_chars) */

  00631	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00638	c3		 ret	 0
s390_move_chars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv78 = 72
tv80 = 76
tv133 = 80
tv135 = 84
tv142 = 88
tv161 = 92
tv177 = 96
tv179 = 100
tv185 = 104
tv192 = 108
tv210 = 112
tv251 = 116
tv250 = 120
tv252 = 124
tv310 = 128
tv311 = 132
dest$ = 136
tv317 = 144
regs$ = 176
exec$ = 184
s390_instfetch PROC					; COMDAT

; 777  : {

$LN76:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s390_instf
  0001a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
  0002c	eb 72		 jmp	 SHORT $LN37@s390_instf
$LN36@s390_instf:
  0002e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 46		 je	 SHORT $LN34@s390_instf
  00040	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0007d	48 23 c1	 and	 rax, rcx
  00080	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
  00084	eb 12		 jmp	 SHORT $LN35@s390_instf
$LN34@s390_instf:
  00086	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00094	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
$LN35@s390_instf:
  00098	8b 44 24 48	 mov	 eax, DWORD PTR tv78[rsp]
  0009c	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
$LN37@s390_instf:
  000a0	8b 44 24 4c	 mov	 eax, DWORD PTR tv80[rsp]
  000a4	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000a8	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000b0	75 66		 jne	 SHORT $LN14@s390_instf
$LN4@s390_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000c2	74 4e		 je	 SHORT $LN15@s390_instf
  000c4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000da	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000e2	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000e9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ed	48 2b ca	 sub	 rcx, rdx
  000f0	48 03 c1	 add	 rax, rcx
  000f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00101	48 23 c1	 and	 rax, rcx
  00104	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s390_instf:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 9a		 jne	 SHORT $LN4@s390_instf
$LN14@s390_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00118	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  0011c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00121	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  00125	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  0012d	73 0a		 jae	 SHORT $LN40@s390_instf
  0012f	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN41@s390_instf
$LN40@s390_instf:
  00139	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN41@s390_instf:
  00141	83 7c 24 50 00	 cmp	 DWORD PTR tv133[rsp], 0
  00146	74 0a		 je	 SHORT $LN42@s390_instf
  00148	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv135[rsp], 2048 ; 00000800H
  00150	eb 08		 jmp	 SHORT $LN43@s390_instf
$LN42@s390_instf:
  00152	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv135[rsp], 4096 ; 00001000H
$LN43@s390_instf:
  0015a	8b 44 24 54	 mov	 eax, DWORD PTR tv135[rsp]
  0015e	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00162	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00166	83 e0 01	 and	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	74 0a		 je	 SHORT $LN46@s390_instf
  0016d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00175	eb 08		 jmp	 SHORT $LN47@s390_instf
$LN46@s390_instf:
  00177	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN47@s390_instf:
  0017f	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  00184	74 44		 je	 SHORT $LN16@s390_instf

; 798  :     {
; 799  :         if (!exec)

  00186	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0018e	75 1f		 jne	 SHORT $LN17@s390_instf

; 800  :             regs->instinvalid = 1;

  00190	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019e	83 c8 08	 or	 eax, 8
  001a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s390_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001af	ba 06 00 00 00	 mov	 edx, 6
  001b4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001d8	c1 e8 02	 shr	 eax, 2
  001db	83 e0 01	 and	 eax, 1
  001de	85 c0		 test	 eax, eax
  001e0	74 0a		 je	 SHORT $LN50@s390_instf
  001e2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ea	eb 08		 jmp	 SHORT $LN51@s390_instf
$LN50@s390_instf:
  001ec	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN51@s390_instf:
  001f4	83 7c 24 5c 00	 cmp	 DWORD PTR tv161[rsp], 0
  001f9	0f 84 72 03 00
	00		 je	 $LN18@s390_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  001ff	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00207	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0020b	83 e0 04	 and	 eax, 4
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN52@s390_instf
  00212	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN53@s390_instf
$LN52@s390_instf:
  0021c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN53@s390_instf:
  00224	83 7c 24 60 00	 cmp	 DWORD PTR tv177[rsp], 0
  00229	74 0a		 je	 SHORT $LN54@s390_instf
  0022b	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv179[rsp], 16
  00233	eb 08		 jmp	 SHORT $LN55@s390_instf
$LN54@s390_instf:
  00235	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN55@s390_instf:
  0023d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00245	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00249	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024e	85 c0		 test	 eax, eax
  00250	74 0a		 je	 SHORT $LN56@s390_instf
  00252	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0025a	eb 08		 jmp	 SHORT $LN57@s390_instf
$LN56@s390_instf:
  0025c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN57@s390_instf:
  00264	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00270	83 e0 40	 and	 eax, 64			; 00000040H
  00273	85 c0		 test	 eax, eax
  00275	74 0a		 je	 SHORT $LN58@s390_instf
  00277	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  0027f	eb 08		 jmp	 SHORT $LN59@s390_instf
$LN58@s390_instf:
  00281	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN59@s390_instf:
  00289	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00297	83 e0 01	 and	 eax, 1
  0029a	c1 e0 07	 shl	 eax, 7
  0029d	83 c8 40	 or	 eax, 64			; 00000040H
  002a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a8	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002ae	d1 e9		 shr	 ecx, 1
  002b0	83 e1 01	 and	 ecx, 1
  002b3	c1 e1 05	 shl	 ecx, 5
  002b6	0b c1		 or	 eax, ecx
  002b8	0b 44 24 64	 or	 eax, DWORD PTR tv179[rsp]
  002bc	8b 4c 24 68	 mov	 ecx, DWORD PTR tv185[rsp]
  002c0	c1 e1 03	 shl	 ecx, 3
  002c3	0b c1		 or	 eax, ecx
  002c5	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv192[rsp]
  002c9	c1 e1 02	 shl	 ecx, 2
  002cc	0b c1		 or	 eax, ecx
  002ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  002dd	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  002e5	75 13		 jne	 SHORT $LN19@s390_instf

; 822  :             regs->peradr = addr;

  002e7	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  002eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s390_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  002fa	33 c0		 xor	 eax, eax
  002fc	83 f8 01	 cmp	 eax, 1
  002ff	0f 84 6e 01 00
	00		 je	 $LN20@s390_instf
  00305	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00313	c1 e8 02	 shr	 eax, 2
  00316	83 e0 01	 and	 eax, 1
  00319	85 c0		 test	 eax, eax
  0031b	74 0a		 je	 SHORT $LN62@s390_instf
  0031d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN63@s390_instf
$LN62@s390_instf:
  00327	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN63@s390_instf:
  0032f	83 7c 24 70 00	 cmp	 DWORD PTR tv210[rsp], 0
  00334	0f 84 39 01 00
	00		 je	 $LN20@s390_instf
  0033a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00342	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00345	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 21 01 00
	00		 je	 $LN20@s390_instf
  00352	b8 08 00 00 00	 mov	 eax, 8
  00357	48 6b c0 0c	 imul	 rax, rax, 12
  0035b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0036a	0f ba f0 1f	 btr	 eax, 31
  0036e	b9 08 00 00 00	 mov	 ecx, 8
  00373	48 6b c9 0b	 imul	 rcx, rcx, 11
  00377	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037f	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00386	0f ba f1 1f	 btr	 ecx, 31
  0038a	3b c1		 cmp	 eax, ecx
  0038c	72 60		 jb	 SHORT $LN68@s390_instf
  0038e	b8 08 00 00 00	 mov	 eax, 8
  00393	48 6b c0 0b	 imul	 rax, rax, 11
  00397	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003a6	0f ba f0 1f	 btr	 eax, 31
  003aa	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003ae	72 2c		 jb	 SHORT $LN64@s390_instf
  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 0c	 imul	 rax, rax, 12
  003b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003c8	0f ba f0 1f	 btr	 eax, 31
  003cc	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003d0	77 0a		 ja	 SHORT $LN64@s390_instf
  003d2	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  003da	eb 08		 jmp	 SHORT $LN67@s390_instf
$LN64@s390_instf:
  003dc	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN67@s390_instf:
  003e4	8b 44 24 74	 mov	 eax, DWORD PTR tv251[rsp]
  003e8	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
  003ec	eb 5e		 jmp	 SHORT $LN69@s390_instf
$LN68@s390_instf:
  003ee	b8 08 00 00 00	 mov	 eax, 8
  003f3	48 6b c0 0b	 imul	 rax, rax, 11
  003f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ff	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00406	0f ba f0 1f	 btr	 eax, 31
  0040a	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  0040e	73 2c		 jae	 SHORT $LN65@s390_instf
  00410	b8 08 00 00 00	 mov	 eax, 8
  00415	48 6b c0 0c	 imul	 rax, rax, 12
  00419	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00421	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00428	0f ba f0 1f	 btr	 eax, 31
  0042c	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00430	76 0a		 jbe	 SHORT $LN65@s390_instf
  00432	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
  0043a	eb 08		 jmp	 SHORT $LN66@s390_instf
$LN65@s390_instf:
  0043c	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
$LN66@s390_instf:
  00444	8b 44 24 78	 mov	 eax, DWORD PTR tv250[rsp]
  00448	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
$LN69@s390_instf:
  0044c	83 7c 24 7c 00	 cmp	 DWORD PTR tv252[rsp], 0
  00451	74 20		 je	 SHORT $LN20@s390_instf
$LN7@s390_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0045e	0f ba e8 16	 bts	 eax, 22
  00462	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046d	33 c0		 xor	 eax, eax
  0046f	85 c0		 test	 eax, eax
  00471	75 e0		 jne	 SHORT $LN7@s390_instf
$LN20@s390_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00473	33 c0		 xor	 eax, eax
  00475	83 f8 01	 cmp	 eax, 1
  00478	0f 84 f3 00 00
	00		 je	 $LN21@s390_instf
  0047e	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00486	0f 85 e5 00 00
	00		 jne	 $LN21@s390_instf
  0048c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00494	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049a	c1 e8 10	 shr	 eax, 16
  0049d	83 e0 01	 and	 eax, 1
  004a0	85 c0		 test	 eax, eax
  004a2	0f 85 c9 00 00
	00		 jne	 $LN21@s390_instf
  004a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004b8	0f 84 b3 00 00
	00		 je	 $LN21@s390_instf
  004be	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  004c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004cb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  004d2	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  004d7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  004e3	0f 83 88 00 00
	00		 jae	 $LN21@s390_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  004e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ff	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00507	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0050e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00512	48 2b ca	 sub	 rcx, rdx
  00515	48 03 c1	 add	 rax, rcx
  00518	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00526	48 23 c1	 and	 rax, rcx
  00529	8b c0		 mov	 eax, eax
  0052b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00533	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0053a	33 c0		 xor	 eax, eax
  0053c	85 c0		 test	 eax, eax
  0053e	74 20		 je	 SHORT $LN22@s390_instf
$LN10@s390_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00540	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0054b	0f ba f0 16	 btr	 eax, 22
  0054f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00557	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0055a	33 c0		 xor	 eax, eax
  0055c	85 c0		 test	 eax, eax
  0055e	75 e0		 jne	 SHORT $LN10@s390_instf
$LN22@s390_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00560	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00568	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0056c	e9 4f 03 00 00	 jmp	 $LN1@s390_instf
$LN21@s390_instf:
$LN18@s390_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00571	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00579	75 1f		 jne	 SHORT $LN23@s390_instf

; 882  :         regs->instinvalid = 1;

  0057b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00583	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00589	83 c8 08	 or	 eax, 8
  0058c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00594	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s390_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  0059a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005a6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005aa	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005b2	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ba	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005c0	ba 06 00 00 00	 mov	 edx, 6
  005c5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005c9	e8 00 00 00 00	 call	 s390_maddr_l
  005ce	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  005d3	b8 01 00 00 00	 mov	 eax, 1
  005d8	48 6b c0 00	 imul	 rax, rax, 0
  005dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005e5	83 f8 40	 cmp	 eax, 64			; 00000040H
  005e8	7d 0d		 jge	 SHORT $LN72@s390_instf
  005ea	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv311[rsp], 2
  005f5	eb 3f		 jmp	 SHORT $LN73@s390_instf
$LN72@s390_instf:
  005f7	b8 01 00 00 00	 mov	 eax, 1
  005fc	48 6b c0 00	 imul	 rax, rax, 0
  00600	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00605	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00609	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0060e	7d 0d		 jge	 SHORT $LN70@s390_instf
  00610	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv310[rsp], 4
  0061b	eb 0b		 jmp	 SHORT $LN71@s390_instf
$LN70@s390_instf:
  0061d	c7 84 24 80 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv310[rsp], 6
$LN71@s390_instf:
  00628	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  0062f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
$LN73@s390_instf:
  00636	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv311[rsp]
  0063d	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00641	03 c8		 add	 ecx, eax
  00643	8b c1		 mov	 eax, ecx
  00645	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00649	0f 8e ff 00 00
	00		 jle	 $LN24@s390_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0064f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00657	74 18		 je	 SHORT $LN74@s390_instf
  00659	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00667	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
  0066f	eb 16		 jmp	 SHORT $LN75@s390_instf
$LN74@s390_instf:
  00671	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00679	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0067f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
$LN75@s390_instf:
  00687	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  0068f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00697	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0069f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  006a4	8b 09		 mov	 ecx, DWORD PTR [rcx]
  006a6	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  006a8	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  006ac	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  006b0	2b c8		 sub	 ecx, eax
  006b2	8b c1		 mov	 eax, ecx
  006b4	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  006b8	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  006bc	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  006c0	03 c8		 add	 ecx, eax
  006c2	8b c1		 mov	 eax, ecx
  006c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  006d2	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  006d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006de	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  006e2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  006e6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  006ee	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006f6	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  006fc	ba 01 00 00 00	 mov	 edx, 1
  00701	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  00705	e8 00 00 00 00	 call	 s390_maddr_l
  0070a	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  0070f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00717	75 1c		 jne	 SHORT $LN26@s390_instf

; 899  :             regs->ip = ip - len;

  00719	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0071e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00723	48 2b c8	 sub	 rcx, rax
  00726	48 8b c1	 mov	 rax, rcx
  00729	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00731	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s390_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00735	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00742	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00747	8b 12		 mov	 edx, DWORD PTR [rdx]
  00749	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0074c	eb 28		 jmp	 SHORT $LN25@s390_instf
$LN24@s390_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0074e	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00753	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0075b	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00763	75 11		 jne	 SHORT $LN27@s390_instf

; 907  :             regs->ip = ip;

  00765	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00772	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s390_instf:
$LN25@s390_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00776	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0077e	0f 85 bd 00 00
	00		 jne	 $LN28@s390_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00784	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00792	83 e0 f7	 and	 eax, -9			; fffffff7H
  00795	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079d	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  007a3	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  007a7	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  007ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  007bf	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  007c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cd	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  007d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007e2	c1 e8 10	 shr	 eax, 16
  007e5	83 e0 01	 and	 eax, 1
  007e8	85 c0		 test	 eax, eax
  007ea	75 18		 jne	 SHORT $LN31@s390_instf
  007ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007fa	c1 e8 02	 shr	 eax, 2
  007fd	83 e0 01	 and	 eax, 1
  00800	85 c0		 test	 eax, eax
  00802	74 15		 je	 SHORT $LN29@s390_instf
$LN31@s390_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  00804	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080c	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00817	eb 28		 jmp	 SHORT $LN30@s390_instf
$LN29@s390_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00819	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0081e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00826	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0082d	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00832	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083a	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s390_instf:
$LN28@s390_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00841	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00849	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0084f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00857	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0085f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00866	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0086a	48 2b ca	 sub	 rcx, rdx
  0086d	48 03 c1	 add	 rax, rcx
  00870	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00878	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0087e	48 23 c1	 and	 rax, rcx
  00881	8b c0		 mov	 eax, eax
  00883	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088b	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00892	33 c0		 xor	 eax, eax
  00894	85 c0		 test	 eax, eax
  00896	74 20		 je	 SHORT $LN32@s390_instf
$LN13@s390_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00898	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  008a3	0f ba f0 16	 btr	 eax, 22
  008a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008af	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  008b2	33 c0		 xor	 eax, eax
  008b4	85 c0		 test	 eax, eax
  008b6	75 e0		 jne	 SHORT $LN13@s390_instf
$LN32@s390_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  008b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s390_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  008c0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  008c7	c3		 ret	 0
s390_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0001a	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  0001f	77 0a		 ja	 SHORT $LN6@s390_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vfetc
$LN6@s390_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@s390_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	74 46		 je	 SHORT $LN2@s390_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00043	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00047	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0004f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00054	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00059	ba 08 00 00 00	 mov	 edx, 8
  0005e	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00071	e8 00 00 00 00	 call	 fetch_dw_noswap
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 _byteswap_uint64
  0007e	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00080	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  00085	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  00089	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0008d	e8 00 00 00 00	 call	 s390_vfetch8_full
$LN1@s390_vfetc:

; 737  : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
s390_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch2 PROC					; COMDAT

; 679  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  0005c	74 46		 je	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );
; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 02 00 00 00	 mov	 edx, 2
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_hw_noswap
  0009a	0f b7 c8	 movzx	 ecx, ax
  0009d	e8 00 00 00 00	 call	 _byteswap_ushort
  000a2	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000a4	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a9	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ad	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b1	e8 00 00 00 00	 call	 s390_vfetch2_full
$LN1@s390_vfetc:

; 689  : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
s390_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s390_maddr_l
  0003e	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
s390_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00017	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00020	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  00025	77 0a		 ja	 SHORT $LN7@s390_vstor
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@s390_vstor:
  00039	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003e	74 4b		 je	 SHORT $LN2@s390_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00040	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00049	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005a	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0005f	ba 08 00 00 00	 mov	 edx, 8
  00064	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 s390_maddr_l
  0006d	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00084	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  00089	eb 18		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  0008b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00090	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00095	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0009e	e8 00 00 00 00	 call	 s390_vstore8_full
$LN3@s390_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
s390_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore2
_TEXT	SEGMENT
tv73 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore2 PROC					; COMDAT

; 541  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00017	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 1a		 je	 SHORT $LN5@s390_vstor
  00022	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  00030	75 0a		 jne	 SHORT $LN5@s390_vstor
  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0003a	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN5@s390_vstor:
  0003c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN8@s390_vstor:
  00044	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00049	74 4b		 je	 SHORT $LN2@s390_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0004b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00050	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00054	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00058	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00060	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0006a	ba 02 00 00 00	 mov	 edx, 2
  0006f	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  00073	e8 00 00 00 00	 call	 s390_maddr_l
  00078	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  0007d	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  00082	e8 00 00 00 00	 call	 _byteswap_ushort
  00087	0f b7 d0	 movzx	 edx, ax
  0008a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0008f	e8 00 00 00 00	 call	 store_hw_noswap

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );
; 550  :     }

  00094	eb 18		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  00096	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0009b	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000a0	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000a4	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  000a9	e8 00 00 00 00	 call	 s390_vstore2_full
$LN3@s390_vstor:

; 553  : }

  000ae	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b2	c3		 ret	 0
s390_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l
  00043	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
s390_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s390_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b5	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c3	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c7	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000cb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d3	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000db	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e3	48 8b d0	 mov	 rdx, rax
  000e6	e8 00 00 00 00	 call	 s390_maddr_l
  000eb	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000f0	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000fa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fd	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  00102	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 fetch_dw_noswap
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  00114	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s390_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00064	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0006d	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00071	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00079	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007e	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 s390_maddr_l
  0008f	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00099	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  000a1	0b c8		 or	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000aa	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000af	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b3	c3		 ret	 0
s390_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
s390_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00052	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00056	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00066	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 s390_maddr_l
  0007d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00091	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009f	48 98		 cdqe
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000ac	03 d1		 add	 edx, ecx
  000ae	8b ca		 mov	 ecx, edx
  000b0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000be	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000ca	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d6	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000de	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e6	48 8b d0	 mov	 rdx, rax
  000e9	e8 00 00 00 00	 call	 s390_maddr_l
  000ee	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fb	83 c8 06	 or	 eax, 6
  000fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  00103	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00105	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0010d	e8 00 00 00 00	 call	 _byteswap_uint64
  00112	48 8b d0	 mov	 rdx, rax
  00115	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0011f	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00124	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00129	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0012e	48 8b f1	 mov	 rsi, rcx
  00131	48 8b c8	 mov	 rcx, rax
  00134	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00136	b8 08 00 00 00	 mov	 eax, 8
  0013b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0013f	48 98		 cdqe
  00141	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00146	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0014b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00150	48 8b f1	 mov	 rsi, rcx
  00153	48 8b c8	 mov	 rcx, rax
  00156	f3 a4		 rep movsb

; 384  : }

  00158	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015d	48 33 cc	 xor	 rcx, rsp
  00160	e8 00 00 00 00	 call	 __security_check_cookie
  00165	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00169	5f		 pop	 rdi
  0016a	5e		 pop	 rsi
  0016b	c3		 ret	 0
s390_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s390_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0003f	e8 00 00 00 00	 call	 s390_maddr_l
  00044	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  00049	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00055	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005a	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0005e	ff c0		 inc	 eax
  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0006b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00074	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00078	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00080	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00085	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0008a	ba 01 00 00 00	 mov	 edx, 1
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 s390_maddr_l
  00096	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  000a0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a3	83 c8 06	 or	 eax, 6
  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000ab	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000ad	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000b2	c1 f8 08	 sar	 eax, 8
  000b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000ba	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000bc	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000cb	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d1	c3		 ret	 0
s390_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_validate_operand
_TEXT	SEGMENT
tv79 = 48
tv94 = 52
tv138 = 56
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s370_validate_operand PROC				; COMDAT

; 1376 : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0004c	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN11@s370_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN12@s370_valid
$LN11@s370_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@s370_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 3e		 je	 SHORT $LN5@s370_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0008c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009d	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 s370_maddr_l

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }

  000ae	eb 5a		 jmp	 SHORT $LN6@s370_valid
$LN5@s370_valid:
$LN4@s370_valid:

; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );

  000b0	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b5	73 0a		 jae	 SHORT $LN15@s370_valid
  000b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN16@s370_valid
$LN15@s370_valid:
  000c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@s370_valid:
  000c9	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  000ce	74 1b		 je	 SHORT $LN17@s370_valid
  000d0	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000d4	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	83 f8 50	 cmp	 eax, 80			; 00000050H
  000df	72 0a		 jb	 SHORT $LN17@s370_valid
  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e9	eb 08		 jmp	 SHORT $LN23@s370_valid
$LN17@s370_valid:
  000eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN23@s370_valid:
  000f3	83 7c 24 38 00	 cmp	 DWORD PTR tv138[rsp], 0
  000f8	74 0a		 je	 SHORT $LN7@s370_valid
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_valid:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 a6		 jne	 SHORT $LN4@s370_valid
$LN6@s370_valid:

; 1389 : #endif
; 1390 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
s370_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_move_chars
_TEXT	SEGMENT
len1$ = 48
len2$ = 52
source1$ = 56
dest1$ = 64
source2$ = 72
tv68 = 80
tv80 = 84
tv85 = 88
tv90 = 92
tv142 = 96
tv154 = 100
tv185 = 104
tv195 = 108
tv254 = 112
tv346 = 116
tv358 = 120
dest2$ = 128
sk1$ = 136
sk2$ = 144
addr1$ = 176
arn1$ = 184
key1$ = 192
addr2$ = 200
arn2$ = 208
key2$ = 216
len$ = 224
regs$ = 232
s370_move_chars PROC					; COMDAT

; 1005 : {

$LN77:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@s370_move_:

; 1006 : BYTE   *dest1,   *dest2;                /* Destination addresses     */
; 1007 : BYTE   *source1, *source2;              /* Source addresses          */
; 1008 : BYTE   *sk1,     *sk2;                  /* Storage key addresses     */
; 1009 : int     len1,     len2;                 /* Lengths to copy           */
; 1010 : 
; 1011 :     ITIMER_SYNC( addr2, len, regs );

  00019	83 bc 24 c8 00
	00 00 54	 cmp	 DWORD PTR addr2$[rsp], 84 ; 00000054H
  00021	73 0a		 jae	 SHORT $LN28@s370_move_
  00023	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0002b	eb 08		 jmp	 SHORT $LN29@s370_move_
$LN28@s370_move_:
  0002d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN29@s370_move_:
  00035	83 7c 24 50 00	 cmp	 DWORD PTR tv68[rsp], 0
  0003a	74 21		 je	 SHORT $LN30@s370_move_
  0003c	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00043	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  0004a	03 c8		 add	 ecx, eax
  0004c	8b c1		 mov	 eax, ecx
  0004e	83 f8 50	 cmp	 eax, 80			; 00000050H
  00051	72 0a		 jb	 SHORT $LN30@s370_move_
  00053	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  0005b	eb 08		 jmp	 SHORT $LN36@s370_move_
$LN30@s370_move_:
  0005d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN36@s370_move_:
  00065	83 7c 24 54 00	 cmp	 DWORD PTR tv80[rsp], 0
  0006a	74 0d		 je	 SHORT $LN11@s370_move_
  0006c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	e8 00 00 00 00	 call	 s370_store_int_timer
$LN11@s370_move_:
  00079	33 c0		 xor	 eax, eax
  0007b	85 c0		 test	 eax, eax
  0007d	75 9a		 jne	 SHORT $LN4@s370_move_

; 1012 : 
; 1013 :     /* Quick out if copying just 1 byte */
; 1014 :     if (unlikely( !len ))

  0007f	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00087	75 0a		 jne	 SHORT $LN37@s370_move_
  00089	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  00091	eb 08		 jmp	 SHORT $LN38@s370_move_
$LN37@s370_move_:
  00093	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN38@s370_move_:
  0009b	83 7c 24 58 00	 cmp	 DWORD PTR tv85[rsp], 0
  000a0	74 0a		 je	 SHORT $LN41@s370_move_
  000a2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN42@s370_move_
$LN41@s370_move_:
  000ac	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN42@s370_move_:
  000b4	83 7c 24 5c 00	 cmp	 DWORD PTR tv90[rsp], 0
  000b9	0f 84 ee 00 00
	00		 je	 $LN12@s370_move_

; 1015 :     {
; 1016 :         source1 = MADDR( addr2, arn2, regs, ACCTYPE_READ,  key2 );

  000bf	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR key2$[rsp]
  000c7	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000cb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d3	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000db	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  000e3	ba 01 00 00 00	 mov	 edx, 1
  000e8	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  000ef	e8 00 00 00 00	 call	 s370_maddr_l
  000f4	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1017 :         dest1   = MADDR( addr1, arn1, regs, ACCTYPE_WRITE, key1 );

  000f9	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR key1$[rsp]
  00101	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00105	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0010d	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00115	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  0011d	ba 01 00 00 00	 mov	 edx, 1
  00122	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  00129	e8 00 00 00 00	 call	 s370_maddr_l
  0012e	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1018 :         *dest1 = *source1;

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR dest1$[rsp]
  00138	48 8b 4c 24 38	 mov	 rcx, QWORD PTR source1$[rsp]
  0013d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00140	88 08		 mov	 BYTE PTR [rax], cl
$LN7@s370_move_:

; 1019 :         ITIMER_UPDATE( addr1, len, regs );

  00142	83 bc 24 b0 00
	00 00 54	 cmp	 DWORD PTR addr1$[rsp], 84 ; 00000054H
  0014a	73 0a		 jae	 SHORT $LN45@s370_move_
  0014c	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00154	eb 08		 jmp	 SHORT $LN46@s370_move_
$LN45@s370_move_:
  00156	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN46@s370_move_:
  0015e	83 7c 24 60 00	 cmp	 DWORD PTR tv142[rsp], 0
  00163	74 21		 je	 SHORT $LN47@s370_move_
  00165	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0016c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  00173	03 c8		 add	 ecx, eax
  00175	8b c1		 mov	 eax, ecx
  00177	83 f8 50	 cmp	 eax, 80			; 00000050H
  0017a	72 0a		 jb	 SHORT $LN47@s370_move_
  0017c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00184	eb 08		 jmp	 SHORT $LN53@s370_move_
$LN47@s370_move_:
  00186	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN53@s370_move_:
  0018e	83 7c 24 64 00	 cmp	 DWORD PTR tv154[rsp], 0
  00193	74 0d		 je	 SHORT $LN13@s370_move_
  00195	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN13@s370_move_:
  001a2	33 c0		 xor	 eax, eax
  001a4	85 c0		 test	 eax, eax
  001a6	75 9a		 jne	 SHORT $LN7@s370_move_

; 1020 :         return;

  001a8	e9 c8 05 00 00	 jmp	 $LN1@s370_move_
$LN12@s370_move_:

; 1021 :     }
; 1022 : 
; 1023 :     /* Translate addresses of leftmost operand bytes */
; 1024 :     source1 = MADDRL( addr2, len+1, arn2, regs, ACCTYPE_READ, key2 );

  001ad	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001b4	ff c0		 inc	 eax
  001b6	48 98		 cdqe
  001b8	0f b6 8c 24 d8
	00 00 00	 movzx	 ecx, BYTE PTR key2$[rsp]
  001c0	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  001c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001cc	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d4	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  001dc	48 8b d0	 mov	 rdx, rax
  001df	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  001e6	e8 00 00 00 00	 call	 s370_maddr_l
  001eb	48 89 44 24 38	 mov	 QWORD PTR source1$[rsp], rax

; 1025 :     dest1   = MADDRL( addr1, len+1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );

  001f0	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f7	ff c0		 inc	 eax
  001f9	48 98		 cdqe
  001fb	0f b6 8c 24 c0
	00 00 00	 movzx	 ecx, BYTE PTR key1$[rsp]
  00203	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00207	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0020f	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00217	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  0021f	48 8b d0	 mov	 rdx, rax
  00222	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  00229	e8 00 00 00 00	 call	 s370_maddr_l
  0022e	48 89 44 24 40	 mov	 QWORD PTR dest1$[rsp], rax

; 1026 :     sk1 = regs->dat.storkey;

  00233	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023b	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00242	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sk1$[rsp], rax

; 1027 : 
; 1028 :     /* There are several scenarios (in optimal order):
; 1029 :      * (1) dest boundary and source boundary not crossed
; 1030 :      * (2) dest boundary not crossed and source boundary crossed
; 1031 :      * (3) dest boundary crossed and source boundary not crossed
; 1032 :      * (4) dest boundary and source boundary are crossed
; 1033 :      *     (a) dest and source boundary cross at the same time
; 1034 :      *     (b) dest boundary crossed first
; 1035 :      *     (c) source boundary crossed first
; 1036 :      * Note: since the operand length is limited to 256 bytes,
; 1037 :      *       neither operand can cross more than one 2K boundary.
; 1038 :      */
; 1039 :     if (NOCROSSPAGE( addr1, len ))

  0024a	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR addr1$[rsp]
  00251	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00256	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  0025b	2b 8c 24 e0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  00262	3b c1		 cmp	 eax, ecx
  00264	7f 0a		 jg	 SHORT $LN56@s370_move_
  00266	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0026e	eb 08		 jmp	 SHORT $LN57@s370_move_
$LN56@s370_move_:
  00270	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN57@s370_move_:
  00278	83 7c 24 68 00	 cmp	 DWORD PTR tv185[rsp], 0
  0027d	0f 84 3d 01 00
	00		 je	 $LN14@s370_move_

; 1040 :     {
; 1041 :         if (NOCROSSPAGE( addr2, len ))

  00283	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  0028a	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0028f	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00294	2b 8c 24 e0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  0029b	3b c1		 cmp	 eax, ecx
  0029d	7f 0a		 jg	 SHORT $LN60@s370_move_
  0029f	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002a7	eb 08		 jmp	 SHORT $LN61@s370_move_
$LN60@s370_move_:
  002a9	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN61@s370_move_:
  002b1	83 7c 24 6c 00	 cmp	 DWORD PTR tv195[rsp], 0
  002b6	74 28		 je	 SHORT $LN16@s370_move_

; 1042 :         {
; 1043 :             /* (1) - No boundaries are crossed */
; 1044 :             concpy( regs, dest1, source1, len + 1 );

  002b8	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002bf	ff c0		 inc	 eax
  002c1	44 8b c8	 mov	 r9d, eax
  002c4	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  002c9	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  002ce	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 concpy

; 1045 :         }

  002db	e9 c3 00 00 00	 jmp	 $LN17@s370_move_
$LN16@s370_move_:

; 1046 :         else
; 1047 :         {
; 1048 :             /* (2) - Source operand crosses a boundary */
; 1049 :             len1 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  002e0	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  002e7	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  002ec	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  002f1	2b c8		 sub	 ecx, eax
  002f3	8b c1		 mov	 eax, ecx
  002f5	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1050 :             source2 = MADDRL( (addr2 + len1) & ADDRESS_MAXWRAP( regs ),

  002f9	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00300	ff c0		 inc	 eax
  00302	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  00306	48 98		 cdqe
  00308	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  0030c	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  00313	03 d1		 add	 edx, ecx
  00315	8b ca		 mov	 ecx, edx
  00317	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0031d	0f b6 94 24 d8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  00325	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00329	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00331	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00339	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  00341	48 8b d0	 mov	 rdx, rax
  00344	e8 00 00 00 00	 call	 s370_maddr_l
  00349	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1051 :                    len + 1 - len1, arn2, regs, ACCTYPE_READ, key2 );
; 1052 : 
; 1053 :             concpy( regs, dest1,        source1,       len1     );

  0034e	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00353	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00358	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0035d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00365	e8 00 00 00 00	 call	 concpy

; 1054 :             concpy( regs, dest1 + len1, source2, len - len1 + 1 );

  0036a	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  0036e	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00375	2b c8		 sub	 ecx, eax
  00377	8b c1		 mov	 eax, ecx
  00379	ff c0		 inc	 eax
  0037b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  00380	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00385	48 03 d1	 add	 rdx, rcx
  00388	48 8b ca	 mov	 rcx, rdx
  0038b	44 8b c8	 mov	 r9d, eax
  0038e	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  00393	48 8b d1	 mov	 rdx, rcx
  00396	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039e	e8 00 00 00 00	 call	 concpy
$LN17@s370_move_:

; 1055 :         }
; 1056 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  003a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sk1$[rsp]
  003ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003ae	83 c8 06	 or	 eax, 6
  003b1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  003b9	88 01		 mov	 BYTE PTR [rcx], al

; 1057 :     }

  003bb	e9 4f 03 00 00	 jmp	 $LN15@s370_move_
$LN14@s370_move_:

; 1058 :     else
; 1059 :     {
; 1060 :         /* Destination operand crosses a boundary */
; 1061 :         len1 = PAGEFRAME_PAGESIZE - (addr1 & PAGEFRAME_BYTEMASK);

  003c0	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR addr1$[rsp]
  003c7	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  003cc	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  003d1	2b c8		 sub	 ecx, eax
  003d3	8b c1		 mov	 eax, ecx
  003d5	89 44 24 30	 mov	 DWORD PTR len1$[rsp], eax

; 1062 :         dest2 = MADDRL( (addr1 + len1) & ADDRESS_MAXWRAP( regs ),

  003d9	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  003e0	ff c0		 inc	 eax
  003e2	2b 44 24 30	 sub	 eax, DWORD PTR len1$[rsp]
  003e6	48 98		 cdqe
  003e8	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  003ec	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR addr1$[rsp]
  003f3	03 d1		 add	 edx, ecx
  003f5	8b ca		 mov	 ecx, edx
  003f7	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  003fd	0f b6 94 24 c0
	00 00 00	 movzx	 edx, BYTE PTR key1$[rsp]
  00405	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00409	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00411	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00419	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR arn1$[rsp]
  00421	48 8b d0	 mov	 rdx, rax
  00424	e8 00 00 00 00	 call	 s370_maddr_l
  00429	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest2$[rsp], rax

; 1063 :             len + 1 - len1, arn1, regs, ACCTYPE_WRITE_SKP, key1 );
; 1064 :         sk2 = regs->dat.storkey;

  00431	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00439	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00440	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sk2$[rsp], rax

; 1065 : 
; 1066 :         if (NOCROSSPAGE( addr2, len ))

  00448	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  0044f	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00454	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00459	2b 8c 24 e0 00
	00 00		 sub	 ecx, DWORD PTR len$[rsp]
  00460	3b c1		 cmp	 eax, ecx
  00462	7f 0a		 jg	 SHORT $LN64@s370_move_
  00464	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  0046c	eb 08		 jmp	 SHORT $LN65@s370_move_
$LN64@s370_move_:
  0046e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv254[rsp], 0
$LN65@s370_move_:
  00476	83 7c 24 70 00	 cmp	 DWORD PTR tv254[rsp], 0
  0047b	74 5d		 je	 SHORT $LN18@s370_move_

; 1067 :         {
; 1068 :              /* (3) - Source operand crosses a boundary */
; 1069 :              concpy( regs, dest1, source1,              len1     );

  0047d	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00482	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00487	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0048c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00494	e8 00 00 00 00	 call	 concpy

; 1070 :              concpy( regs, dest2, source1 + len1, len - len1 + 1 );

  00499	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  0049d	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  004a4	2b c8		 sub	 ecx, eax
  004a6	8b c1		 mov	 eax, ecx
  004a8	ff c0		 inc	 eax
  004aa	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  004af	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  004b4	48 03 d1	 add	 rdx, rcx
  004b7	48 8b ca	 mov	 rcx, rdx
  004ba	44 8b c8	 mov	 r9d, eax
  004bd	4c 8b c1	 mov	 r8, rcx
  004c0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest2$[rsp]
  004c8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d0	e8 00 00 00 00	 call	 concpy

; 1071 :         }

  004d5	e9 05 02 00 00	 jmp	 $LN19@s370_move_
$LN18@s370_move_:

; 1072 :         else
; 1073 :         {
; 1074 :             /* (4) - Both operands cross a boundary */
; 1075 :             len2 = PAGEFRAME_PAGESIZE - (addr2 & PAGEFRAME_BYTEMASK);

  004da	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  004e1	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  004e6	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  004eb	2b c8		 sub	 ecx, eax
  004ed	8b c1		 mov	 eax, ecx
  004ef	89 44 24 34	 mov	 DWORD PTR len2$[rsp], eax

; 1076 :             source2 = MADDRL( (addr2 + len2) & ADDRESS_MAXWRAP( regs ),

  004f3	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  004fa	ff c0		 inc	 eax
  004fc	2b 44 24 34	 sub	 eax, DWORD PTR len2$[rsp]
  00500	48 98		 cdqe
  00502	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  00506	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  0050d	03 d1		 add	 edx, ecx
  0050f	8b ca		 mov	 ecx, edx
  00511	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00517	0f b6 94 24 d8
	00 00 00	 movzx	 edx, BYTE PTR key2$[rsp]
  0051f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00523	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0052b	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00533	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR arn2$[rsp]
  0053b	48 8b d0	 mov	 rdx, rax
  0053e	e8 00 00 00 00	 call	 s370_maddr_l
  00543	48 89 44 24 48	 mov	 QWORD PTR source2$[rsp], rax

; 1077 :                 len + 1 - len2, arn2, regs, ACCTYPE_READ, key2 );
; 1078 : 
; 1079 :             if (len1 == len2)

  00548	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  0054c	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  00550	75 4f		 jne	 SHORT $LN20@s370_move_

; 1080 :             {
; 1081 :                 /* (4a) - Both operands cross at the same time */
; 1082 :                 concpy( regs, dest1, source1,       len1     );

  00552	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  00557	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  0055c	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  00561	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00569	e8 00 00 00 00	 call	 concpy

; 1083 :                 concpy( regs, dest2, source2, len - len1 + 1 );

  0056e	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  00572	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00579	2b c8		 sub	 ecx, eax
  0057b	8b c1		 mov	 eax, ecx
  0057d	ff c0		 inc	 eax
  0057f	44 8b c8	 mov	 r9d, eax
  00582	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  00587	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest2$[rsp]
  0058f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00597	e8 00 00 00 00	 call	 concpy

; 1084 :             }

  0059c	e9 3e 01 00 00	 jmp	 $LN21@s370_move_
$LN20@s370_move_:

; 1085 :             else if (len1 < len2)

  005a1	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  005a5	39 44 24 30	 cmp	 DWORD PTR len1$[rsp], eax
  005a9	0f 8d 9c 00 00
	00		 jge	 $LN22@s370_move_

; 1086 :             {
; 1087 :                 /* (4b) - Destination operand crosses first */
; 1088 :                 concpy( regs, dest1,               source1,               len1     );

  005af	44 8b 4c 24 30	 mov	 r9d, DWORD PTR len1$[rsp]
  005b4	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  005b9	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  005be	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c6	e8 00 00 00 00	 call	 concpy

; 1089 :                 concpy( regs, dest2,               source1 + len1, len2 - len1     );

  005cb	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  005cf	8b 4c 24 34	 mov	 ecx, DWORD PTR len2$[rsp]
  005d3	2b c8		 sub	 ecx, eax
  005d5	8b c1		 mov	 eax, ecx
  005d7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  005dc	48 8b 54 24 38	 mov	 rdx, QWORD PTR source1$[rsp]
  005e1	48 03 d1	 add	 rdx, rcx
  005e4	48 8b ca	 mov	 rcx, rdx
  005e7	44 8b c8	 mov	 r9d, eax
  005ea	4c 8b c1	 mov	 r8, rcx
  005ed	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest2$[rsp]
  005f5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fd	e8 00 00 00 00	 call	 concpy

; 1090 :                 concpy( regs, dest2 + len2 - len1, source2,        len  - len2 + 1 );

  00602	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  00606	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0060d	2b c8		 sub	 ecx, eax
  0060f	8b c1		 mov	 eax, ecx
  00611	ff c0		 inc	 eax
  00613	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00618	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest2$[rsp]
  00620	48 03 d1	 add	 rdx, rcx
  00623	48 8b ca	 mov	 rcx, rdx
  00626	48 63 54 24 30	 movsxd	 rdx, DWORD PTR len1$[rsp]
  0062b	48 2b ca	 sub	 rcx, rdx
  0062e	44 8b c8	 mov	 r9d, eax
  00631	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  00636	48 8b d1	 mov	 rdx, rcx
  00639	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00641	e8 00 00 00 00	 call	 concpy

; 1091 :             }

  00646	e9 94 00 00 00	 jmp	 $LN23@s370_move_
$LN22@s370_move_:

; 1092 :             else
; 1093 :             {
; 1094 :                 /* (4c) - Source operand crosses first */
; 1095 :                 concpy( regs, dest1,        source1,                      len2     );

  0064b	44 8b 4c 24 34	 mov	 r9d, DWORD PTR len2$[rsp]
  00650	4c 8b 44 24 38	 mov	 r8, QWORD PTR source1$[rsp]
  00655	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0065a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00662	e8 00 00 00 00	 call	 concpy

; 1096 :                 concpy( regs, dest1 + len2, source2,               len1 - len2     );

  00667	8b 44 24 34	 mov	 eax, DWORD PTR len2$[rsp]
  0066b	8b 4c 24 30	 mov	 ecx, DWORD PTR len1$[rsp]
  0066f	2b c8		 sub	 ecx, eax
  00671	8b c1		 mov	 eax, ecx
  00673	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00678	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest1$[rsp]
  0067d	48 03 d1	 add	 rdx, rcx
  00680	48 8b ca	 mov	 rcx, rdx
  00683	44 8b c8	 mov	 r9d, eax
  00686	4c 8b 44 24 48	 mov	 r8, QWORD PTR source2$[rsp]
  0068b	48 8b d1	 mov	 rdx, rcx
  0068e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00696	e8 00 00 00 00	 call	 concpy

; 1097 :                 concpy( regs, dest2,        source2 + len1 - len2, len -  len1 + 1 );

  0069b	8b 44 24 30	 mov	 eax, DWORD PTR len1$[rsp]
  0069f	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  006a6	2b c8		 sub	 ecx, eax
  006a8	8b c1		 mov	 eax, ecx
  006aa	ff c0		 inc	 eax
  006ac	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len1$[rsp]
  006b1	48 8b 54 24 48	 mov	 rdx, QWORD PTR source2$[rsp]
  006b6	48 03 d1	 add	 rdx, rcx
  006b9	48 8b ca	 mov	 rcx, rdx
  006bc	48 63 54 24 34	 movsxd	 rdx, DWORD PTR len2$[rsp]
  006c1	48 2b ca	 sub	 rcx, rdx
  006c4	44 8b c8	 mov	 r9d, eax
  006c7	4c 8b c1	 mov	 r8, rcx
  006ca	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest2$[rsp]
  006d2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006da	e8 00 00 00 00	 call	 concpy
$LN23@s370_move_:
$LN21@s370_move_:
$LN19@s370_move_:

; 1098 :             }
; 1099 :         }
; 1100 :         *sk1 |= (STORKEY_REF | STORKEY_CHANGE);

  006df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sk1$[rsp]
  006e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006ea	83 c8 06	 or	 eax, 6
  006ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sk1$[rsp]
  006f5	88 01		 mov	 BYTE PTR [rcx], al

; 1101 :         *sk2 |= (STORKEY_REF | STORKEY_CHANGE);

  006f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sk2$[rsp]
  006ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00702	83 c8 06	 or	 eax, 6
  00705	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sk2$[rsp]
  0070d	88 01		 mov	 BYTE PTR [rcx], al
$LN15@s370_move_:
$LN10@s370_move_:

; 1102 :     }
; 1103 :     ITIMER_UPDATE( addr1, len, regs );

  0070f	83 bc 24 b0 00
	00 00 54	 cmp	 DWORD PTR addr1$[rsp], 84 ; 00000054H
  00717	73 0a		 jae	 SHORT $LN68@s370_move_
  00719	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv346[rsp], 1
  00721	eb 08		 jmp	 SHORT $LN69@s370_move_
$LN68@s370_move_:
  00723	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv346[rsp], 0
$LN69@s370_move_:
  0072b	83 7c 24 74 00	 cmp	 DWORD PTR tv346[rsp], 0
  00730	74 21		 je	 SHORT $LN70@s370_move_
  00732	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00739	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR addr1$[rsp]
  00740	03 c8		 add	 ecx, eax
  00742	8b c1		 mov	 eax, ecx
  00744	83 f8 50	 cmp	 eax, 80			; 00000050H
  00747	72 0a		 jb	 SHORT $LN70@s370_move_
  00749	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv358[rsp], 1
  00751	eb 08		 jmp	 SHORT $LN76@s370_move_
$LN70@s370_move_:
  00753	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv358[rsp], 0
$LN76@s370_move_:
  0075b	83 7c 24 78 00	 cmp	 DWORD PTR tv358[rsp], 0
  00760	74 0d		 je	 SHORT $LN24@s370_move_
  00762	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0076a	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN24@s370_move_:
  0076f	33 c0		 xor	 eax, eax
  00771	85 c0		 test	 eax, eax
  00773	75 9a		 jne	 SHORT $LN10@s370_move_
$LN1@s370_move_:

; 1104 : 
; 1105 : } /* end function ARCH_DEP(move_chars) */

  00775	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0077c	c3		 ret	 0
s370_move_chars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv76 = 72
tv78 = 76
tv129 = 80
tv131 = 84
tv138 = 88
tv157 = 92
tv174 = 96
tv215 = 100
tv214 = 104
tv216 = 108
tv272 = 112
tv273 = 116
dest$ = 120
tv279 = 128
regs$ = 160
exec$ = 168
s370_instfetch PROC					; COMDAT

; 777  : {

$LN68:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s370_instf
  0001a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
  0002c	eb 67		 jmp	 SHORT $LN37@s370_instf
$LN36@s370_instf:
  0002e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 3b		 je	 SHORT $LN34@s370_instf
  00040	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00075	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
  00079	eb 12		 jmp	 SHORT $LN35@s370_instf
$LN34@s370_instf:
  0007b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00089	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
$LN35@s370_instf:
  0008d	8b 44 24 48	 mov	 eax, DWORD PTR tv76[rsp]
  00091	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
$LN37@s370_instf:
  00095	8b 44 24 4c	 mov	 eax, DWORD PTR tv78[rsp]
  00099	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  0009d	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000a5	75 5b		 jne	 SHORT $LN14@s370_instf
$LN4@s370_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000af	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000b7	74 43		 je	 SHORT $LN15@s370_instf
  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000de	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000e2	48 2b ca	 sub	 rcx, rdx
  000e5	48 03 c1	 add	 rax, rcx
  000e8	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s370_instf:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 a5		 jne	 SHORT $LN4@s370_instf
$LN14@s370_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00102	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00106	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0010b	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0010f	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  00117	73 0a		 jae	 SHORT $LN40@s370_instf
  00119	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
  00121	eb 08		 jmp	 SHORT $LN41@s370_instf
$LN40@s370_instf:
  00123	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN41@s370_instf:
  0012b	83 7c 24 50 00	 cmp	 DWORD PTR tv129[rsp], 0
  00130	74 0a		 je	 SHORT $LN42@s370_instf
  00132	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
  0013a	eb 08		 jmp	 SHORT $LN43@s370_instf
$LN42@s370_instf:
  0013c	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
$LN43@s370_instf:
  00144	8b 44 24 54	 mov	 eax, DWORD PTR tv131[rsp]
  00148	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  0014c	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 0a		 je	 SHORT $LN46@s370_instf
  00157	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  0015f	eb 08		 jmp	 SHORT $LN47@s370_instf
$LN46@s370_instf:
  00161	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN47@s370_instf:
  00169	83 7c 24 58 00	 cmp	 DWORD PTR tv138[rsp], 0
  0016e	74 44		 je	 SHORT $LN16@s370_instf

; 798  :     {
; 799  :         if (!exec)

  00170	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00178	75 1f		 jne	 SHORT $LN17@s370_instf

; 800  :             regs->instinvalid = 1;

  0017a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00188	83 c8 08	 or	 eax, 8
  0018b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s370_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s370_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001b4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c2	c1 e8 02	 shr	 eax, 2
  001c5	83 e0 01	 and	 eax, 1
  001c8	85 c0		 test	 eax, eax
  001ca	74 0a		 je	 SHORT $LN50@s370_instf
  001cc	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  001d4	eb 08		 jmp	 SHORT $LN51@s370_instf
$LN50@s370_instf:
  001d6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN51@s370_instf:
  001de	83 7c 24 5c 00	 cmp	 DWORD PTR tv157[rsp], 0
  001e3	0f 84 9d 02 00
	00		 je	 $LN18@s370_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */
; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;

  001e9	33 c0		 xor	 eax, eax
  001eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  001fa	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00202	75 13		 jne	 SHORT $LN19@s370_instf

; 822  :             regs->peradr = addr;

  00204	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00208	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s370_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00217	33 c0		 xor	 eax, eax
  00219	83 f8 01	 cmp	 eax, 1
  0021c	0f 84 75 01 00
	00		 je	 $LN20@s370_instf
  00222	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00230	c1 e8 02	 shr	 eax, 2
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	74 0a		 je	 SHORT $LN54@s370_instf
  0023a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00242	eb 08		 jmp	 SHORT $LN55@s370_instf
$LN54@s370_instf:
  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN55@s370_instf:
  0024c	83 7c 24 60 00	 cmp	 DWORD PTR tv174[rsp], 0
  00251	0f 84 40 01 00
	00		 je	 $LN20@s370_instf
  00257	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00262	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00267	85 c0		 test	 eax, eax
  00269	0f 84 28 01 00
	00		 je	 $LN20@s370_instf
  0026f	b8 08 00 00 00	 mov	 eax, 8
  00274	48 6b c0 0c	 imul	 rax, rax, 12
  00278	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00280	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00287	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0028c	b9 08 00 00 00	 mov	 ecx, 8
  00291	48 6b c9 0b	 imul	 rcx, rcx, 11
  00295	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0029d	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  002a4	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  002aa	3b c1		 cmp	 eax, ecx
  002ac	72 62		 jb	 SHORT $LN60@s370_instf
  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 0b	 imul	 rax, rax, 11
  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002c6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002cb	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002cf	72 2d		 jb	 SHORT $LN56@s370_instf
  002d1	b8 08 00 00 00	 mov	 eax, 8
  002d6	48 6b c0 0c	 imul	 rax, rax, 12
  002da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002e9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002ee	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002f2	77 0a		 ja	 SHORT $LN56@s370_instf
  002f4	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  002fc	eb 08		 jmp	 SHORT $LN59@s370_instf
$LN56@s370_instf:
  002fe	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN59@s370_instf:
  00306	8b 44 24 64	 mov	 eax, DWORD PTR tv215[rsp]
  0030a	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
  0030e	eb 60		 jmp	 SHORT $LN61@s370_instf
$LN60@s370_instf:
  00310	b8 08 00 00 00	 mov	 eax, 8
  00315	48 6b c0 0b	 imul	 rax, rax, 11
  00319	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00328	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0032d	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00331	73 2d		 jae	 SHORT $LN57@s370_instf
  00333	b8 08 00 00 00	 mov	 eax, 8
  00338	48 6b c0 0c	 imul	 rax, rax, 12
  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0034b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00350	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00354	76 0a		 jbe	 SHORT $LN57@s370_instf
  00356	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
  0035e	eb 08		 jmp	 SHORT $LN58@s370_instf
$LN57@s370_instf:
  00360	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
$LN58@s370_instf:
  00368	8b 44 24 68	 mov	 eax, DWORD PTR tv214[rsp]
  0036c	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
$LN61@s370_instf:
  00370	83 7c 24 6c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00375	74 20		 je	 SHORT $LN20@s370_instf
$LN7@s370_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00377	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00382	0f ba e8 16	 bts	 eax, 22
  00386	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038e	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	75 e0		 jne	 SHORT $LN7@s370_instf
$LN20@s370_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00397	33 c0		 xor	 eax, eax
  00399	83 f8 01	 cmp	 eax, 1
  0039c	0f 84 e4 00 00
	00		 je	 $LN21@s370_instf
  003a2	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  003aa	0f 85 d6 00 00
	00		 jne	 $LN21@s370_instf
  003b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003be	c1 e8 10	 shr	 eax, 16
  003c1	83 e0 01	 and	 eax, 1
  003c4	85 c0		 test	 eax, eax
  003c6	0f 85 ba 00 00
	00		 jne	 $LN21@s370_instf
  003cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003dc	0f 84 a4 00 00
	00		 je	 $LN21@s370_instf
  003e2	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  003e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ef	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003f6	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  003fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00407	73 7d		 jae	 SHORT $LN21@s370_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00409	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00411	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00417	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00427	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0042e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00432	48 2b ca	 sub	 rcx, rdx
  00435	48 03 c1	 add	 rax, rcx
  00438	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0043e	8b c0		 mov	 eax, eax
  00440	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00448	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0044f	33 c0		 xor	 eax, eax
  00451	85 c0		 test	 eax, eax
  00453	74 20		 je	 SHORT $LN22@s370_instf
$LN10@s370_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00455	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00460	0f ba f0 16	 btr	 eax, 22
  00464	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 e0		 jne	 SHORT $LN10@s370_instf
$LN22@s370_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00475	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00481	e9 1a 03 00 00	 jmp	 $LN1@s370_instf
$LN21@s370_instf:
$LN18@s370_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00486	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0048e	75 1f		 jne	 SHORT $LN23@s370_instf

; 882  :         regs->instinvalid = 1;

  00490	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00498	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049e	83 c8 08	 or	 eax, 8
  004a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s370_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  004af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  004bb	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  004bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  004c7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004cf	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  004d5	ba 06 00 00 00	 mov	 edx, 6
  004da	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  004de	e8 00 00 00 00	 call	 s370_maddr_l
  004e3	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  004e8	b8 01 00 00 00	 mov	 eax, 1
  004ed	48 6b c0 00	 imul	 rax, rax, 0
  004f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  004f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004fa	83 f8 40	 cmp	 eax, 64			; 00000040H
  004fd	7d 0a		 jge	 SHORT $LN64@s370_instf
  004ff	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv273[rsp], 2
  00507	eb 33		 jmp	 SHORT $LN65@s370_instf
$LN64@s370_instf:
  00509	b8 01 00 00 00	 mov	 eax, 1
  0050e	48 6b c0 00	 imul	 rax, rax, 0
  00512	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00517	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00520	7d 0a		 jge	 SHORT $LN62@s370_instf
  00522	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv272[rsp], 4
  0052a	eb 08		 jmp	 SHORT $LN63@s370_instf
$LN62@s370_instf:
  0052c	c7 44 24 70 06
	00 00 00	 mov	 DWORD PTR tv272[rsp], 6
$LN63@s370_instf:
  00534	8b 44 24 70	 mov	 eax, DWORD PTR tv272[rsp]
  00538	89 44 24 74	 mov	 DWORD PTR tv273[rsp], eax
$LN65@s370_instf:
  0053c	8b 44 24 74	 mov	 eax, DWORD PTR tv273[rsp]
  00540	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00544	03 c8		 add	 ecx, eax
  00546	8b c1		 mov	 eax, ecx
  00548	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  0054c	0f 8e ed 00 00
	00		 jle	 $LN24@s370_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  00552	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0055a	74 18		 je	 SHORT $LN66@s370_instf
  0055c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  0056a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  00572	eb 16		 jmp	 SHORT $LN67@s370_instf
$LN66@s370_instf:
  00574	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057c	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00582	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN67@s370_instf:
  0058a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv279[rsp]
  00592	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00597	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
  0059c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005a1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  005a3	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  005a5	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  005a9	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  005ad	2b c8		 sub	 ecx, eax
  005af	8b c1		 mov	 eax, ecx
  005b1	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  005b5	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  005b9	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005bd	03 c8		 add	 ecx, eax
  005bf	8b c1		 mov	 eax, ecx
  005c1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  005c6	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  005ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005d6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005da	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005e2	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ea	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005f0	ba 01 00 00 00	 mov	 edx, 1
  005f5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005f9	e8 00 00 00 00	 call	 s370_maddr_l
  005fe	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  00603	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0060b	75 1c		 jne	 SHORT $LN26@s370_instf

; 899  :             regs->ip = ip - len;

  0060d	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  00612	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00617	48 2b c8	 sub	 rcx, rax
  0061a	48 8b c1	 mov	 rax, rcx
  0061d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00625	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s370_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00629	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0062e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dest$[rsp]
  00633	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00638	8b 12		 mov	 edx, DWORD PTR [rdx]
  0063a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0063d	eb 25		 jmp	 SHORT $LN25@s370_instf
$LN24@s370_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0063f	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00644	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  00649	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00651	75 11		 jne	 SHORT $LN27@s370_instf

; 907  :             regs->ip = ip;

  00653	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00660	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s370_instf:
$LN25@s370_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00664	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0066c	0f 85 bd 00 00
	00		 jne	 $LN28@s370_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00672	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00680	83 e0 f7	 and	 eax, -9			; fffffff7H
  00683	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068b	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00691	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00695	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0069a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a2	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  006a8	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  006ad	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  006b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bb	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  006c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ca	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006d0	c1 e8 10	 shr	 eax, 16
  006d3	83 e0 01	 and	 eax, 1
  006d6	85 c0		 test	 eax, eax
  006d8	75 18		 jne	 SHORT $LN31@s370_instf
  006da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006e8	c1 e8 02	 shr	 eax, 2
  006eb	83 e0 01	 and	 eax, 1
  006ee	85 c0		 test	 eax, eax
  006f0	74 15		 je	 SHORT $LN29@s370_instf
$LN31@s370_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  006f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fa	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00705	eb 28		 jmp	 SHORT $LN30@s370_instf
$LN29@s370_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00707	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0070c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00714	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0071b	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00720	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00728	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s370_instf:
$LN28@s370_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  0072f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00737	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0073d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00745	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0074d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00754	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00758	48 2b ca	 sub	 rcx, rdx
  0075b	48 03 c1	 add	 rax, rcx
  0075e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00764	8b c0		 mov	 eax, eax
  00766	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00775	33 c0		 xor	 eax, eax
  00777	85 c0		 test	 eax, eax
  00779	74 20		 je	 SHORT $LN32@s370_instf
$LN13@s370_instf:

; 952  :         OFF_IC_PER_IF( regs );

  0077b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00786	0f ba f0 16	 btr	 eax, 22
  0078a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00792	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00795	33 c0		 xor	 eax, eax
  00797	85 c0		 test	 eax, eax
  00799	75 e0		 jne	 SHORT $LN13@s370_instf
$LN32@s370_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  0079b	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s370_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  007a0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  007a7	c3		 ret	 0
s370_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8
_TEXT	SEGMENT
tv70 = 48
tv76 = 52
tv88 = 56
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch8 PROC					; COMDAT

; 711  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0001a	3d f8 07 00 00	 cmp	 eax, 2040		; 000007f8H
  0001f	77 0a		 ja	 SHORT $LN10@s370_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vfetc
$LN10@s370_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN11@s370_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	0f 84 9b 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );

  0003e	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00043	73 0a		 jae	 SHORT $LN14@s370_vfetc
  00045	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN15@s370_vfetc
$LN14@s370_vfetc:
  0004f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN15@s370_vfetc:
  00057	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  0005c	74 16		 je	 SHORT $LN16@s370_vfetc
  0005e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00062	83 c0 07	 add	 eax, 7
  00065	83 f8 50	 cmp	 eax, 80			; 00000050H
  00068	72 0a		 jb	 SHORT $LN16@s370_vfetc
  0006a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN22@s370_vfetc
$LN16@s370_vfetc:
  00074	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN22@s370_vfetc:
  0007c	83 7c 24 38 00	 cmp	 DWORD PTR tv88[rsp], 0
  00081	74 0a		 je	 SHORT $LN6@s370_vfetc
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	e8 00 00 00 00	 call	 s370_store_int_timer
$LN6@s370_vfetc:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00093	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00098	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0009c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000a0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000a8	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ad	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000b2	ba 08 00 00 00	 mov	 edx, 8
  000b7	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000bb	e8 00 00 00 00	 call	 s370_maddr_l
  000c0	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ca	e8 00 00 00 00	 call	 fetch_dw_noswap
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 _byteswap_uint64
  000d7	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  000d9	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000de	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  000e2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000e6	e8 00 00 00 00	 call	 s370_vfetch8_full
$LN1@s370_vfetc:

; 737  : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
s370_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch2 PROC					; COMDAT

; 679  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  0005c	0f 84 9a 00 00
	00		 je	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 15		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	ff c0		 inc	 eax
  00088	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008b	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00095	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00097	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  0009f	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a4	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 ac		 jne	 SHORT $LN4@s370_vfetc

; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000bf	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d5	ba 02 00 00 00	 mov	 edx, 2
  000da	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f2	0f b7 c8	 movzx	 ecx, ax
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch2_full
$LN1@s370_vfetc:

; 689  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchb
_TEXT	SEGMENT
tv68 = 48
tv78 = 52
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetchb PROC					; COMDAT

; 667  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_vfetc:

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );

  00011	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00016	73 0a		 jae	 SHORT $LN9@s370_vfetc
  00018	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN10@s370_vfetc:
  0002a	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  0002f	74 11		 je	 SHORT $LN11@s370_vfetc
  00031	83 7c 24 50 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00036	72 0a		 jb	 SHORT $LN11@s370_vfetc
  00038	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN17@s370_vfetc
$LN11@s370_vfetc:
  00042	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN17@s370_vfetc:
  0004a	83 7c 24 34 00	 cmp	 DWORD PTR tv78[rsp], 0
  0004f	74 0a		 je	 SHORT $LN5@s370_vfetc
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	e8 00 00 00 00	 call	 s370_store_int_timer
$LN5@s370_vfetc:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN4@s370_vfetc

; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00066	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00076	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00089	e8 00 00 00 00	 call	 s370_maddr_l
  0008e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00098	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0009b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009f	c3		 ret	 0
s370_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore8
_TEXT	SEGMENT
tv70 = 48
tv92 = 52
tv136 = 56
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore8 PROC					; COMDAT

; 577  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00017	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00020	3d f8 07 00 00	 cmp	 eax, 2040		; 000007f8H
  00025	77 0a		 ja	 SHORT $LN11@s370_vstor
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN12@s370_vstor:
  00039	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003e	74 4b		 je	 SHORT $LN5@s370_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00040	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00049	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0005a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0005f	ba 08 00 00 00	 mov	 edx, 8
  00064	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 s370_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00072	48 8b 4c 24 60	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  00084	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  00089	eb 18		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  0008b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00090	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00095	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR value$[rsp]
  0009e	e8 00 00 00 00	 call	 s370_vstore8_full
$LN6@s370_vstor:
$LN4@s370_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );

  000a3	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000a8	73 0a		 jae	 SHORT $LN15@s370_vstor
  000aa	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b2	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@s370_vstor:
  000bc	83 7c 24 34 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c1	74 16		 je	 SHORT $LN17@s370_vstor
  000c3	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000c7	83 c0 07	 add	 eax, 7
  000ca	83 f8 50	 cmp	 eax, 80			; 00000050H
  000cd	72 0a		 jb	 SHORT $LN17@s370_vstor
  000cf	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000d7	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  000d9	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN23@s370_vstor:
  000e1	83 7c 24 38 00	 cmp	 DWORD PTR tv136[rsp], 0
  000e6	74 0a		 je	 SHORT $LN7@s370_vstor
  000e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 ab		 jne	 SHORT $LN4@s370_vstor

; 612  : }

  000f8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fc	c3		 ret	 0
s370_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv92 = 56
tv136 = 60
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore4 PROC					; COMDAT

; 559  : {

$LN27:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN10@s370_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vstor
$LN10@s370_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN11@s370_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN14@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN15@s370_vstor
$LN14@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN15@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 14		 jne	 SHORT $LN7@s370_vstor
  00053	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0005c	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  00061	0f 87 9e 00 00
	00		 ja	 $LN5@s370_vstor
$LN7@s370_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00070	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00074	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00081	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_maddr_l
  00094	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00099	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  0009d	e8 00 00 00 00	 call	 _byteswap_ulong
  000a2	8b d0		 mov	 edx, eax
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a9	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@s370_vstor:

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );

  000ae	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b3	73 0a		 jae	 SHORT $LN18@s370_vstor
  000b5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000bd	eb 08		 jmp	 SHORT $LN19@s370_vstor
$LN18@s370_vstor:
  000bf	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN19@s370_vstor:
  000c7	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000cc	74 16		 je	 SHORT $LN20@s370_vstor
  000ce	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000d2	83 c0 03	 add	 eax, 3
  000d5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d8	72 0a		 jb	 SHORT $LN20@s370_vstor
  000da	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000e2	eb 08		 jmp	 SHORT $LN26@s370_vstor
$LN20@s370_vstor:
  000e4	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN26@s370_vstor:
  000ec	83 7c 24 3c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000f1	74 0a		 je	 SHORT $LN8@s370_vstor
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN8@s370_vstor:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 ab		 jne	 SHORT $LN4@s370_vstor

; 568  :     }

  00103	eb 17		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  00105	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0010a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00113	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  00117	e8 00 00 00 00	 call	 s370_vstore4_full
$LN6@s370_vstor:

; 571  : }

  0011c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00120	c3		 ret	 0
s370_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2
_TEXT	SEGMENT
tv73 = 48
tv91 = 52
tv135 = 56
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2 PROC					; COMDAT

; 541  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00017	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 1a		 je	 SHORT $LN9@s370_vstor
  00022	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00030	75 0a		 jne	 SHORT $LN9@s370_vstor
  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0003a	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN9@s370_vstor:
  0003c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN12@s370_vstor:
  00044	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00049	0f 84 9f 00 00
	00		 je	 $LN5@s370_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0004f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00054	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00058	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00069	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	ba 02 00 00 00	 mov	 edx, 2
  00073	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  00077	e8 00 00 00 00	 call	 s370_maddr_l
  0007c	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  00081	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00086	e8 00 00 00 00	 call	 _byteswap_ushort
  0008b	0f b7 d0	 movzx	 edx, ax
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  00093	e8 00 00 00 00	 call	 store_hw_noswap
$LN4@s370_vstor:

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );

  00098	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0009d	73 0a		 jae	 SHORT $LN15@s370_vstor
  0009f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000a7	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000a9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN16@s370_vstor:
  000b1	83 7c 24 34 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b6	74 15		 je	 SHORT $LN17@s370_vstor
  000b8	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000bc	ff c0		 inc	 eax
  000be	83 f8 50	 cmp	 eax, 80			; 00000050H
  000c1	72 0a		 jb	 SHORT $LN17@s370_vstor
  000c3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  000cd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN23@s370_vstor:
  000d5	83 7c 24 38 00	 cmp	 DWORD PTR tv135[rsp], 0
  000da	74 0a		 je	 SHORT $LN7@s370_vstor
  000dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 ac		 jne	 SHORT $LN4@s370_vstor

; 550  :     }

  000ec	eb 18		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  000ee	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  000f3	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  000fc	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00101	e8 00 00 00 00	 call	 s370_vstore2_full
$LN6@s370_vstor:

; 553  : }

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	c3		 ret	 0
s370_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstoreb
_TEXT	SEGMENT
tv76 = 48
tv86 = 52
main1$ = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s370_vstoreb PROC					; COMDAT

; 529  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l
  00043	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl
$LN4@s370_vstor:

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );

  00054	83 7c 24 58 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00059	73 0a		 jae	 SHORT $LN9@s370_vstor
  0005b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN10@s370_vstor
$LN9@s370_vstor:
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN10@s370_vstor:
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00072	74 11		 je	 SHORT $LN11@s370_vstor
  00074	83 7c 24 58 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00079	72 0a		 jb	 SHORT $LN11@s370_vstor
  0007b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00083	eb 08		 jmp	 SHORT $LN17@s370_vstor
$LN11@s370_vstor:
  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN17@s370_vstor:
  0008d	83 7c 24 34 00	 cmp	 DWORD PTR tv86[rsp], 0
  00092	74 0a		 je	 SHORT $LN5@s370_vstor
  00094	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN5@s370_vstor:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b0		 jne	 SHORT $LN4@s370_vstor

; 535  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
s370_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002e	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s370_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000b3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bf	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d3	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000e8	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f5	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  000fa	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  000ff	e8 00 00 00 00	 call	 fetch_dw_noswap
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s370_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 s370_maddr_l
  00089	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00096	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  0009b	0b c8		 or	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000a4	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
s370_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
s370_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0002f	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00034	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00052	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00056	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00066	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 s370_maddr_l
  0007d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00091	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009f	48 98		 cdqe
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000ac	03 d1		 add	 edx, ecx
  000ae	8b ca		 mov	 ecx, edx
  000b0	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000b6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ce	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d6	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000de	48 8b d0	 mov	 rdx, rax
  000e1	e8 00 00 00 00	 call	 s370_maddr_l
  000e6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f3	83 c8 06	 or	 eax, 6
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000fb	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  000fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00105	e8 00 00 00 00	 call	 _byteswap_uint64
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  00117	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0011c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00121	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00126	48 8b f1	 mov	 rsi, rcx
  00129	48 8b c8	 mov	 rcx, rax
  0012c	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  0012e	b8 08 00 00 00	 mov	 eax, 8
  00133	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00137	48 98		 cdqe
  00139	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  0013e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00143	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00148	48 8b f1	 mov	 rsi, rcx
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	f3 a4		 rep movsb

; 384  : }

  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00155	48 33 cc	 xor	 rcx, rsp
  00158	e8 00 00 00 00	 call	 __security_check_cookie
  0015d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00161	5f		 pop	 rdi
  00162	5e		 pop	 rsi
  00163	c3		 ret	 0
s370_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s370_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00021	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s370_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0009d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000a9	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ad	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000bd	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	e8 00 00 00 00	 call	 s370_maddr_l
  000cd	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	83 c8 06	 or	 eax, 6
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000e2	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000e4	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000f4	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  000f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000fe	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00103	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00108	48 8b f1	 mov	 rsi, rcx
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00119	48 98		 cdqe
  0011b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00120	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00125	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0012a	48 8b f1	 mov	 rsi, rcx
  0012d	48 8b c8	 mov	 rcx, rax
  00130	f3 a4		 rep movsb

; 350  : }

  00132	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
s370_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0003f	e8 00 00 00 00	 call	 s370_maddr_l
  00044	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  00049	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00055	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005a	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0005e	ff c0		 inc	 eax
  00060	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00065	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0006e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 01 00 00 00	 mov	 edx, 1
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 s370_maddr_l
  00090	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  0009a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009d	83 c8 06	 or	 eax, 6
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000a5	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000a7	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000ac	c1 f8 08	 sar	 eax, 8
  000af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000b4	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000b6	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000c5	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000c7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000cb	c3		 ret	 0
s370_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT concpy
_TEXT	SEGMENT
u8d$ = 32
u8s$ = 40
regs$ = 64
d$ = 72
s$ = 80
n$ = 88
concpy	PROC						; COMDAT

; 160  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 161  :     BYTE* u8d = d;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR d$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax

; 162  :     BYTE* u8s = s;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00027	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax
$LN2@concpy:

; 163  : 
; 164  :     /* Copy until ready or 8 byte integral boundary */
; 165  :     while (n && ((uintptr_t) u8d & 7))

  0002c	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  00031	74 43		 je	 SHORT $LN3@concpy
  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00038	48 83 e0 07	 and	 rax, 7
  0003c	48 85 c0	 test	 rax, rax
  0003f	74 35		 je	 SHORT $LN3@concpy

; 166  :     {
; 167  :         *u8d++ = *u8s++;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u8s$[rsp]
  0004b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004e	88 08		 mov	 BYTE PTR [rax], cl
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00055	48 ff c0	 inc	 rax
  00058	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  00062	48 ff c0	 inc	 rax
  00065	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax

; 168  :         n--;

  0006a	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  0006e	ff c8		 dec	 eax
  00070	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 169  :     }

  00074	eb b6		 jmp	 SHORT $LN2@concpy
$LN3@concpy:
$LN6@concpy:

; 170  : 
; 171  : #if !((defined( SIZEOF_LONG )  && SIZEOF_LONG  > 7) || \
; 172  :       (defined( SIZEOF_INT_P ) && SIZEOF_INT_P > 7) || \
; 173  :        defined( OPTION_STRICT_ALLIGNMENT ))
; 174  : 
; 175  :     /* Code for 32-bit builds... */
; 176  : 
; 177  :     /* Copy full words in right condition, on enough length and src - dst distance */
; 178  :     if (1
; 179  :         && n
; 180  :         && regs->cpubit == regs->sysblk->started_mask
; 181  :         && abs( u8d - u8s ) > 3
; 182  :     )
; 183  :     {
; 184  :         while (n > 3)
; 185  :         {
; 186  :             store_fw_noswap( u8d, fetch_fw_noswap( u8s ));
; 187  :             u8d += 4;
; 188  :             u8s += 4;
; 189  :             n   -= 4;
; 190  :         }
; 191  :     }
; 192  :     else // copy double words
; 193  : 
; 194  : #else // x64 builds
; 195  : 
; 196  :     UNREFERENCED( regs );

  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 fa		 jne	 SHORT $LN6@concpy

; 197  : 
; 198  : #endif // end code for 32-bit builds
; 199  : 
; 200  :     /* Copy double words on enough length and src - dst distance */
; 201  :     if (n && labs( u8d - u8s ) > 7)

  0007c	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  00081	74 63		 je	 SHORT $LN11@concpy
  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u8d$[rsp]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	8b c8		 mov	 ecx, eax
  00095	e8 00 00 00 00	 call	 labs
  0009a	83 f8 07	 cmp	 eax, 7
  0009d	7e 47		 jle	 SHORT $LN11@concpy
$LN7@concpy:

; 202  :     {
; 203  :         while(n > 7)

  0009f	83 7c 24 58 07	 cmp	 DWORD PTR n$[rsp], 7
  000a4	7e 40		 jle	 SHORT $LN8@concpy

; 204  :         {
; 205  :             store_dw_noswap( u8d, fetch_dw_noswap( u8s ));

  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u8s$[rsp]
  000ab	e8 00 00 00 00	 call	 fetch_dw_noswap
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u8d$[rsp]
  000b8	e8 00 00 00 00	 call	 store_dw_noswap

; 206  :             u8d += 8;

  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  000c2	48 83 c0 08	 add	 rax, 8
  000c6	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax

; 207  :             u8s += 8;

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  000d0	48 83 c0 08	 add	 rax, 8
  000d4	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax

; 208  :             n -= 8;

  000d9	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  000dd	83 e8 08	 sub	 eax, 8
  000e0	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 209  :         }

  000e4	eb b9		 jmp	 SHORT $LN7@concpy
$LN8@concpy:
$LN11@concpy:
$LN9@concpy:

; 210  :     }
; 211  : 
; 212  :     /* Copy leftovers */
; 213  :     while (n)

  000e6	83 7c 24 58 00	 cmp	 DWORD PTR n$[rsp], 0
  000eb	74 35		 je	 SHORT $LN10@concpy

; 214  :     {
; 215  :         *u8d++ = *u8s++;

  000ed	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  000f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR u8s$[rsp]
  000f7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000fa	88 08		 mov	 BYTE PTR [rax], cl
  000fc	48 8b 44 24 20	 mov	 rax, QWORD PTR u8d$[rsp]
  00101	48 ff c0	 inc	 rax
  00104	48 89 44 24 20	 mov	 QWORD PTR u8d$[rsp], rax
  00109	48 8b 44 24 28	 mov	 rax, QWORD PTR u8s$[rsp]
  0010e	48 ff c0	 inc	 rax
  00111	48 89 44 24 28	 mov	 QWORD PTR u8s$[rsp], rax

; 216  :         n--;

  00116	8b 44 24 58	 mov	 eax, DWORD PTR n$[rsp]
  0011a	ff c8		 dec	 eax
  0011c	89 44 24 58	 mov	 DWORD PTR n$[rsp], eax

; 217  :     }

  00120	eb c4		 jmp	 SHORT $LN9@concpy
$LN10@concpy:

; 218  : } /* end function concpy */

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	c3		 ret	 0
concpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
