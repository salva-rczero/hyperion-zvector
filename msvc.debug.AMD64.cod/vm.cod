; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	s370_diag_devtype
PUBLIC	s370_syncblk_io
PUBLIC	s370_syncgen_io
PUBLIC	s370_extid_call
PUBLIC	s370_cpcmd_call
PUBLIC	s370_diag_ppagerel
PUBLIC	s370_vm_info
PUBLIC	s370_device_info
PUBLIC	s370_access_reipl_data
PUBLIC	s370_pseudo_timer
PUBLIC	s370_inter_user_communication_vehicle
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__get_storage_key
PUBLIC	s370__put_storage_key
PUBLIC	s370__or_storage_key
PUBLIC	s370_get_2K_storage_key
PUBLIC	s370_put_2K_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_get_storage_key
PUBLIC	s370_put_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s370_fetch_main_absolute
PUBLIC	s370_fetch_fullword_absolute
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	s370_vstoreb
PUBLIC	s370_vfetchc
PUBLIC	s370_validate_operand
PUBLIC	s370_vmdevice_data
PUBLIC	s390_diag_devtype
PUBLIC	s390_syncblk_io
PUBLIC	s390_syncgen_io
PUBLIC	s390_extid_call
PUBLIC	s390_cpcmd_call
PUBLIC	s390_diag_ppagerel
PUBLIC	s390_vm_info
PUBLIC	s390_device_info
PUBLIC	s390_access_reipl_data
PUBLIC	s390_pseudo_timer
PUBLIC	s390_inter_user_communication_vehicle
PUBLIC	s390__get_storage_key
PUBLIC	s390__put_storage_key
PUBLIC	s390__or_storage_key
PUBLIC	s390_get_4K_storage_key
PUBLIC	s390_put_4K_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_get_storage_key
PUBLIC	s390_put_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_fetch_main_absolute
PUBLIC	s390_fetch_fullword_absolute
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	s390_vstoreb
PUBLIC	s390_vfetchc
PUBLIC	s390_validate_operand
PUBLIC	s390_vmdevice_data
PUBLIC	z900_diag_devtype
PUBLIC	z900_syncblk_io
PUBLIC	z900_syncgen_io
PUBLIC	z900_extid_call
PUBLIC	z900_cpcmd_call
PUBLIC	z900_diag_ppagerel
PUBLIC	z900_vm_info
PUBLIC	z900_device_info
PUBLIC	z900_access_reipl_data
PUBLIC	z900_pseudo_timer
PUBLIC	z900_inter_user_communication_vehicle
PUBLIC	z900__get_storage_key
PUBLIC	z900__put_storage_key
PUBLIC	z900__or_storage_key
PUBLIC	z900_get_4K_storage_key
PUBLIC	z900_put_4K_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_get_storage_key
PUBLIC	z900_put_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_fetch_main_absolute
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_fetch_fullword_absolute
PUBLIC	z900_store_doubleword_absolute
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vstoreb
PUBLIC	z900_vfetchc
PUBLIC	z900_validate_operand
PUBLIC	z900_vmdevice_data
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp_strftime:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_trim:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	query_tzoffset:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	s370_execute_ccw_chain:PROC
EXTRN	s390_execute_ccw_chain:PROC
EXTRN	z900_execute_ccw_chain:PROC
EXTRN	find_device_by_devnum:PROC
EXTRN	get_lparname:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	__imp_fbadasd_syncblk_io:PROC
EXTRN	ecpsvm_doiucv:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_panel_command_capture:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169950 DB	01H DUP (?)
$SG169994 DB	01H DUP (?)
$SG170010 DB	01H DUP (?)
$SG180459 DB	01H DUP (?)
$SG180503 DB	01H DUP (?)
$SG180519 DB	01H DUP (?)
$SG193846 DB	01H DUP (?)
$SG193890 DB	01H DUP (?)
$SG193906 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$s370_diag_devtype DD imagerel $LN11
	DD	imagerel $LN11+307
	DD	imagerel $unwind$s370_diag_devtype
$pdata$s370_syncblk_io DD imagerel $LN49
	DD	imagerel $LN49+2728
	DD	imagerel $unwind$s370_syncblk_io
$pdata$s370_syncgen_io DD imagerel $LN36
	DD	imagerel $LN36+1853
	DD	imagerel $unwind$s370_syncgen_io
$pdata$s370_extid_call DD imagerel $LN19
	DD	imagerel $LN19+981
	DD	imagerel $unwind$s370_extid_call
$pdata$s370_cpcmd_call DD imagerel $LN37
	DD	imagerel $LN37+1561
	DD	imagerel $unwind$s370_cpcmd_call
$pdata$s370_diag_ppagerel DD imagerel $LN17
	DD	imagerel $LN17+369
	DD	imagerel $unwind$s370_diag_ppagerel
$pdata$s370_vm_info DD imagerel $LN14
	DD	imagerel $LN14+385
	DD	imagerel $unwind$s370_vm_info
$pdata$s370_device_info DD imagerel $LN28
	DD	imagerel $LN28+942
	DD	imagerel $unwind$s370_device_info
$pdata$s370_access_reipl_data DD imagerel $LN9
	DD	imagerel $LN9+257
	DD	imagerel $unwind$s370_access_reipl_data
$pdata$s370_pseudo_timer DD imagerel $LN12
	DD	imagerel $LN12+551
	DD	imagerel $unwind$s370_pseudo_timer
$pdata$s370_inter_user_communication_vehicle DD imagerel $LN18
	DD	imagerel $LN18+376
	DD	imagerel $unwind$s370_inter_user_communication_vehicle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+118
	DD	imagerel $unwind$s370__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__put_storage_key DD imagerel $LN8
	DD	imagerel $LN8+104
	DD	imagerel $unwind$s370__put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s370_get_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_put_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_put_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s370_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_put_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$s370_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s370_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstoreb DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$s370_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_validate_operand DD imagerel $LN24
	DD	imagerel $LN24+271
	DD	imagerel $unwind$s370_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$is_shell_command DD imagerel is_shell_command
	DD	imagerel is_shell_command+124
	DD	imagerel $unwind$is_shell_command
$pdata$s370_vmdevice_data DD imagerel $LN33
	DD	imagerel $LN33+1065
	DD	imagerel $unwind$s370_vmdevice_data
$pdata$s390_diag_devtype DD imagerel $LN11
	DD	imagerel $LN11+307
	DD	imagerel $unwind$s390_diag_devtype
$pdata$s390_syncblk_io DD imagerel $LN51
	DD	imagerel $LN51+2847
	DD	imagerel $unwind$s390_syncblk_io
$pdata$s390_syncgen_io DD imagerel $LN37
	DD	imagerel $LN37+1922
	DD	imagerel $unwind$s390_syncgen_io
$pdata$s390_extid_call DD imagerel $LN19
	DD	imagerel $LN19+981
	DD	imagerel $unwind$s390_extid_call
$pdata$s390_cpcmd_call DD imagerel $LN37
	DD	imagerel $LN37+1561
	DD	imagerel $unwind$s390_cpcmd_call
$pdata$s390_diag_ppagerel DD imagerel $LN17
	DD	imagerel $LN17+369
	DD	imagerel $unwind$s390_diag_ppagerel
$pdata$s390_vm_info DD imagerel $LN14
	DD	imagerel $LN14+385
	DD	imagerel $unwind$s390_vm_info
$pdata$s390_device_info DD imagerel $LN28
	DD	imagerel $LN28+942
	DD	imagerel $unwind$s390_device_info
$pdata$s390_access_reipl_data DD imagerel $LN9
	DD	imagerel $LN9+257
	DD	imagerel $unwind$s390_access_reipl_data
$pdata$s390_pseudo_timer DD imagerel $LN12
	DD	imagerel $LN12+551
	DD	imagerel $unwind$s390_pseudo_timer
$pdata$s390_inter_user_communication_vehicle DD imagerel $LN17
	DD	imagerel $LN17+358
	DD	imagerel $unwind$s390_inter_user_communication_vehicle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$s390__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__put_storage_key DD imagerel $LN8
	DD	imagerel $LN8+93
	DD	imagerel $unwind$s390__put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s390_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_put_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_put_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s390_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_put_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_main_absolute DD imagerel $LN9
	DD	imagerel $LN9+284
	DD	imagerel $unwind$s390_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s390_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$s390_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$s390_vmdevice_data DD imagerel $LN33
	DD	imagerel $LN33+1065
	DD	imagerel $unwind$s390_vmdevice_data
$pdata$z900_diag_devtype DD imagerel $LN12
	DD	imagerel $LN12+340
	DD	imagerel $unwind$z900_diag_devtype
$pdata$z900_syncblk_io DD imagerel $LN51
	DD	imagerel $LN51+2853
	DD	imagerel $unwind$z900_syncblk_io
$pdata$z900_syncgen_io DD imagerel $LN37
	DD	imagerel $LN37+1928
	DD	imagerel $unwind$z900_syncgen_io
$pdata$z900_extid_call DD imagerel $LN19
	DD	imagerel $LN19+983
	DD	imagerel $unwind$z900_extid_call
$pdata$z900_cpcmd_call DD imagerel $LN37
	DD	imagerel $LN37+1565
	DD	imagerel $unwind$z900_cpcmd_call
$pdata$z900_diag_ppagerel DD imagerel $LN17
	DD	imagerel $LN17+371
	DD	imagerel $unwind$z900_diag_ppagerel
$pdata$z900_vm_info DD imagerel $LN23
	DD	imagerel $LN23+887
	DD	imagerel $unwind$z900_vm_info
$pdata$z900_device_info DD imagerel $LN29
	DD	imagerel $LN29+963
	DD	imagerel $unwind$z900_device_info
$pdata$z900_access_reipl_data DD imagerel $LN9
	DD	imagerel $LN9+259
	DD	imagerel $unwind$z900_access_reipl_data
$pdata$z900_pseudo_timer DD imagerel $LN12
	DD	imagerel $LN12+553
	DD	imagerel $unwind$z900_pseudo_timer
$pdata$z900_inter_user_communication_vehicle DD imagerel $LN17
	DD	imagerel $LN17+383
	DD	imagerel $unwind$z900_inter_user_communication_vehicle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$z900__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__put_storage_key DD imagerel $LN8
	DD	imagerel $LN8+93
	DD	imagerel $unwind$z900__put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$z900_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_put_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_put_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_storage_key DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$z900_get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_put_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_put_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$z900_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$z900_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_store_doubleword_absolute DD imagerel $LN7
	DD	imagerel $LN7+208
	DD	imagerel $unwind$z900_store_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_vmdevice_data DD imagerel $LN34
	DD	imagerel $LN34+1095
	DD	imagerel $unwind$z900_vmdevice_data
pdata	ENDS
_DATA	SEGMENT
vmdev	DW	0671H
	DB	01H
	DB	020H
	DB	0c0H
	ORG $+1
	DW	01052H
	DB	080H
	DB	00H
	DB	0c0H
	ORG $+1
	DW	01403H
	DB	010H
	DB	041H
	DB	0c0H
	ORG $+1
	DW	01442H
	DB	020H
	DB	088H
	DB	0c0H
	ORG $+1
	DW	02305H
	DB	04H
	DB	02H
	DB	0c0H
	ORG $+1
	DW	02311H
	DB	04H
	DB	080H
	DB	0c0H
	ORG $+1
	DW	02314H
	DB	04H
	DB	040H
	DB	0c0H
	ORG $+1
	DW	02501H
	DB	020H
	DB	081H
	DB	0c0H
	ORG $+1
	DW	02703H
	DB	080H
	DB	040H
	DB	0c0H
	ORG $+1
	DW	03088H
	DB	02H
	DB	080H
	DB	0c0H
	ORG $+1
	DW	03211H
	DB	020H
	DB	042H
	DB	0c0H
	ORG $+1
	DW	03215H
	DB	080H
	DB	00H
	DB	0c0H
	ORG $+1
	DW	03270H
	DB	040H
	DB	04H
	DB	0c0H
	ORG $+1
	DW	03287H
	DB	040H
	DB	02H
	DB	0c0H
	ORG $+1
	DW	03310H
	DB	01H
	DB	01H
	DB	0c0H
	ORG $+1
	DW	03330H
	DB	04H
	DB	010H
	DB	0c0H
	ORG $+1
	DW	03340H
	DB	04H
	DB	01H
	DB	0c0H
	ORG $+1
	DW	03350H
	DB	04H
	DB	08H
	DB	0c0H
	ORG $+1
	DW	03370H
	DB	01H
	DB	02H
	DB	0c0H
	ORG $+1
	DW	03375H
	DB	04H
	DB	04H
	DB	0c0H
	ORG $+1
	DW	03380H
	DB	04H
	DB	020H
	DB	0c0H
	ORG $+1
	DW	03390H
	DB	04H
	DB	082H
	DB	040H
	ORG $+1
	DW	03410H
	DB	08H
	DB	08H
	DB	0c0H
	ORG $+1
	DW	03420H
	DB	08H
	DB	010H
	DB	0c0H
	ORG $+1
	DW	03422H
	DB	08H
	DB	082H
	DB	0c0H
	ORG $+1
	DW	03430H
	DB	08H
	DB	02H
	DB	0c0H
	ORG $+1
	DW	03480H
	DB	08H
	DB	01H
	DB	0c0H
	ORG $+1
	DW	03490H
	DB	08H
	DB	081H
	DB	040H
	ORG $+1
	DW	03505H
	DB	020H
	DB	084H
	DB	0c0H
	ORG $+1
	DW	03525H
	DB	010H
	DB	084H
	DB	0c0H
	ORG $+1
	DW	03590H
	DB	08H
	DB	083H
	DB	0c0H
	ORG $+1
	DW	03705H
	DB	02H
	DB	040H
	DB	0c0H
	ORG $+1
	DW	08809H
	DB	08H
	DB	04H
	DB	0c0H
	ORG $+1
	DW	09332H
	DB	01H
	DB	08H
	DB	0c0H
	ORG $+1
	DW	09335H
	DB	01H
	DB	04H
	DB	0c0H
	ORG $+1
	DW	09336H
	DB	01H
	DB	040H
	DB	0c0H
	ORG $+1
	DW	09345H
	DB	04H
	DB	081H
	DB	040H
	ORG $+1
	DW	09347H
	DB	08H
	DB	084H
	DB	0c0H
	ORG $+1
$SG169714 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG169717 DB	'sh', 00H
	ORG $+1
$SG169718 DB	'exec', 00H
	ORG $+3
$SG169837 DB	'vm.c:597', 00H
	ORG $+3
$SG169846 DB	'WRITE', 00H
	ORG $+2
$SG169848 DB	'I', 00H
	ORG $+2
$SG169841 DB	'vm.c:613', 00H
	ORG $+3
$SG169948 DB	'%d.%d', 00H
	ORG $+2
$SG169997 DB	'E', 00H
	ORG $+2
$SG169842 DB	'vm.c:622', 00H
	ORG $+3
$SG169847 DB	'READ', 00H
	ORG $+7
$SG169849 DB	'HHC01952%s %1d:%04X:Diagnose X''0A4'':%s blk=%8.8X adr=%'
	DB	'8.8X len=%8.8X', 0aH, 00H
	ORG $+2
$SG169850 DB	's370_syncblk_io', 00H
$SG169851 DB	'vm.c', 00H
	ORG $+3
$SG169910 DB	'vm.c:839', 00H
	ORG $+3
$SG170000 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG170002 DB	'I', 00H
	ORG $+2
$SG169914 DB	'vm.c:855', 00H
	ORG $+3
$SG170012 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG170014 DB	'I', 00H
	ORG $+2
$SG169915 DB	'vm.c:864', 00H
	ORG $+3
$SG170203 DB	'*IUCV', 00H
	ORG $+2
$SG180355 DB	'I', 00H
	ORG $+2
$SG169917 DB	'vm.c:886', 00H
	ORG $+3
$SG180353 DB	'WRITE', 00H
	ORG $+2
$SG180506 DB	'E', 00H
	ORG $+2
$SG169918 DB	'vm.c:890', 00H
	ORG $+3
$SG180457 DB	'%d.%d', 00H
	ORG $+2
$SG180509 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG180511 DB	'I', 00H
	ORG $+2
$SG169949 DB	'"4.6.0.10893-SDL-DEV-g5b56a850-modified"', 00H
	ORG $+3
$SG180521 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG180523 DB	'I', 00H
	ORG $+2
$SG169951 DB	07fH, 0feH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	ORG $+7
$SG170003 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG170004 DB	's370_cpcmd_call', 00H
$SG170005 DB	'vm.c', 00H
	ORG $+3
$SG169998 DB	'HHC01953%s DIAG8 access to shell disallowed by SHCMDOPT '
	DB	'setting', 0aH, 00H
	ORG $+3
$SG180711 DB	'*IUCV', 00H
	ORG $+2
$SG193742 DB	'I', 00H
	ORG $+2
$SG170001 DB	'Starting', 00H
	ORG $+3
$SG193740 DB	'WRITE', 00H
	ORG $+2
$SG193893 DB	'E', 00H
	ORG $+2
$SG170013 DB	'Completed', 00H
	ORG $+2
$SG193896 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG193898 DB	'I', 00H
	ORG $+2
$SG170015 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG170016 DB	's370_cpcmd_call', 00H
$SG170017 DB	'vm.c', 00H
	ORG $+3
$SG170046 DB	'vm.c:1250', 00H
	ORG $+2
$SG193908 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG193910 DB	'I', 00H
	ORG $+2
$SG170047 DB	'*DIAG0B0', 00H
	ORG $+3
$SG193844 DB	'%d.%d', 00H
	ORG $+6
$SG170081 DB	'vm.c:1325', 00H
	ORG $+6
$SG170082 DB	'*DIAG210', 00H
	ORG $+7
?timefmt@?1??s370_pseudo_timer@@9@9 DB '%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d', 00H ; `s370_pseudo_timer'::`2'::timefmt
	ORG $+7
$SG170202 DB	'vm.c:1709', 00H
	ORG $+6
$SG180341 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:597', 00H
$SG180344 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:604', 00H
$SG180348 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:613', 00H
$SG180349 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:622', 00H
$SG180354 DB	'READ', 00H
	ORG $+3
$SG180357 DB	's390_syncblk_io', 00H
$SG180358 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG180356 DB	'HHC01952%s %1d:%04X:Diagnose X''0A4'':%s blk=%8.8X adr=%'
	DB	'8.8X len=%8.8X', 0aH, 00H
	ORG $+2
$SG180416 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:839', 00H
$SG180419 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:846', 00H
$SG180423 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:855', 00H
$SG180424 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:864', 00H
$SG180426 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:886', 00H
$SG180427 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:890', 00H
$SG180458 DB	'"4.6.0.10893-SDL-DEV-g5b56a850-modified"', 00H
	ORG $+7
$SG180460 DB	07fH, 0feH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	ORG $+7
$SG180512 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG180513 DB	's390_cpcmd_call', 00H
$SG180514 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG180507 DB	'HHC01953%s DIAG8 access to shell disallowed by SHCMDOPT '
	DB	'setting', 0aH, 00H
	ORG $+7
$SG180510 DB	'Starting', 00H
	ORG $+7
$SG180522 DB	'Completed', 00H
	ORG $+6
$SG180524 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG180525 DB	's390_cpcmd_call', 00H
$SG180526 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG180555 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1250', 00H
	ORG $+7
$SG180556 DB	'*DIAG0B0', 00H
	ORG $+7
$SG180590 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1325', 00H
	ORG $+7
$SG180591 DB	'*DIAG210', 00H
	ORG $+7
?timefmt@?1??s390_pseudo_timer@@9@9 DB '%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d', 00H ; `s390_pseudo_timer'::`2'::timefmt
	ORG $+7
$SG180710 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1709', 00H
	ORG $+7
$SG193728 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:597', 00H
$SG193731 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:604', 00H
$SG193735 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:613', 00H
$SG193736 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:622', 00H
$SG193741 DB	'READ', 00H
	ORG $+3
$SG193743 DB	'HHC01952%s %1d:%04X:Diagnose X''0A4'':%s blk=%8.8X adr=%'
	DB	'8.8X len=%8.8X', 0aH, 00H
	ORG $+2
$SG193744 DB	'z900_syncblk_io', 00H
$SG193745 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG193803 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:839', 00H
$SG193806 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:846', 00H
$SG193810 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:855', 00H
$SG193811 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:864', 00H
$SG193813 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:886', 00H
$SG193814 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:890', 00H
$SG193845 DB	'"4.6.0.10893-SDL-DEV-g5b56a850-modified"', 00H
	ORG $+7
$SG193847 DB	07fH, 0feH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	ORG $+7
$SG193894 DB	'HHC01953%s DIAG8 access to shell disallowed by SHCMDOPT '
	DB	'setting', 0aH, 00H
	ORG $+7
$SG193897 DB	'Starting', 00H
	ORG $+7
$SG193899 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG193900 DB	'z900_cpcmd_call', 00H
$SG193901 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG193909 DB	'Completed', 00H
	ORG $+6
$SG193911 DB	'HHC01950%s %s guest issued panel command: %s', 0aH, 00H
	ORG $+2
$SG193912 DB	'z900_cpcmd_call', 00H
$SG193913 DB	'C:\papa\MyGit\hyperion-zvector\vm.c', 00H
	ORG $+4
$SG193942 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1250', 00H
	ORG $+7
$SG193943 DB	'*DIAG0B0', 00H
	ORG $+7
$SG193978 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1325', 00H
	ORG $+7
$SG193979 DB	'*DIAG210', 00H
	ORG $+7
?timefmt@?1??z900_pseudo_timer@@9@9 DB '%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d', 00H ; `z900_pseudo_timer'::`2'::timefmt
	ORG $+7
$SG194110 DB	'C:\papa\MyGit\hyperion-zvector\vm.c:1709', 00H
	ORG $+3
$SG194111 DB	'*IUCV', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_store_doubleword_absolute DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_put_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_put_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__put_storage_key DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_main_absolute DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_put_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_put_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__put_storage_key DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_put_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_put_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_2K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__put_storage_key DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pseudo_timer
	DD	025H
	DD	020fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_device_info
	DD	020H
	DD	03a9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_cpcmd_call
	DD	01eH
	DD	0605H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_extid_call
	DD	01eH
	DD	03bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_syncgen_io
	DD	020H
	DD	076eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_syncblk_io
	DD	020H
	DD	0b0bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_pseudo_timer
	DD	025H
	DD	020dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_device_info
	DD	020H
	DD	0394H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_cpcmd_call
	DD	01eH
	DD	0601H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_extid_call
	DD	01eH
	DD	03bdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_syncgen_io
	DD	020H
	DD	0768H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_syncblk_io
	DD	020H
	DD	0b05H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pseudo_timer
	DD	025H
	DD	020dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_device_info
	DD	020H
	DD	0394H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_cpcmd_call
	DD	01eH
	DD	0601H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_extid_call
	DD	01eH
	DD	03bdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_syncgen_io
	DD	020H
	DD	0723H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_syncblk_io
	DD	020H
	DD	0a8eH
voltbl	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$s370_diag_devtype DD 011101H
	DD	08211H
$unwind$s370_syncblk_io DD 042819H
	DD	0270116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$s370_syncgen_io DD 042819H
	DD	01b0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_extid_call DD 022619H
	DD	0170114H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_cpcmd_call DD 022619H
	DD	05b0114H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$s370_diag_ppagerel DD 011101H
	DD	08211H
$unwind$s370_vm_info DD 011101H
	DD	06211H
$unwind$s370_device_info DD 042819H
	DD	02f0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$s370_access_reipl_data DD 011101H
	DD	0a211H
$unwind$s370_pseudo_timer DD 042d19H
	DD	01d011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_inter_user_communication_vehicle DD 010e01H
	DD	0a20eH
$unwind$is_shell_command DD 010901H
	DD	06209H
$unwind$s370_vmdevice_data DD 021801H
	DD	070147218H
$unwind$s390_diag_devtype DD 011101H
	DD	08211H
$unwind$s390_syncblk_io DD 042819H
	DD	0270116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$s390_syncgen_io DD 042819H
	DD	01b0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_extid_call DD 022619H
	DD	0170114H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s390_cpcmd_call DD 022619H
	DD	05b0114H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$s390_diag_ppagerel DD 011101H
	DD	08211H
$unwind$s390_vm_info DD 011101H
	DD	06211H
$unwind$s390_device_info DD 042819H
	DD	02f0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$s390_access_reipl_data DD 011101H
	DD	0a211H
$unwind$s390_pseudo_timer DD 042d19H
	DD	01d011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s390_inter_user_communication_vehicle DD 010e01H
	DD	0a20eH
$unwind$s390_vmdevice_data DD 021801H
	DD	070147218H
$unwind$z900_diag_devtype DD 011101H
	DD	08211H
$unwind$z900_syncblk_io DD 042819H
	DD	0270116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$z900_syncgen_io DD 042819H
	DD	01b0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_extid_call DD 022619H
	DD	0170114H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_cpcmd_call DD 022619H
	DD	05b0114H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$z900_diag_ppagerel DD 011101H
	DD	08211H
$unwind$z900_vm_info DD 011101H
	DD	0a211H
$unwind$z900_device_info DD 042819H
	DD	02f0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$z900_access_reipl_data DD 011101H
	DD	0a211H
$unwind$z900_pseudo_timer DD 042d19H
	DD	01d011bH
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$z900_inter_user_communication_vehicle DD 010e01H
	DD	0a20eH
$unwind$z900_vmdevice_data DD 021801H
	DD	070147218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 32
tv176 = 36
dev$ = 40
vmentry$ = 48
code$ = 80
devnum$ = 88
vdat$ = 96
rdat$ = 104
z900_vmdevice_data PROC

; 298  : {

$LN34:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 299  : U32      i;                      /* loop index                      */
; 300  : VMDEVTBL *vmentry;               /* -> VMDEVTBL entry found         */
; 301  : DEVBLK   *dev;                   /* -> DEVBLK                       */
; 302  : 
; 303  :     /* Clear vdat and rdat */
; 304  :     memset (vdat, 0, sizeof(*vdat));

  00018	48 8b 7c 24 60	 mov	 rdi, QWORD PTR vdat$[rsp]
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	f3 aa		 rep stosb

; 305  :     memset (rdat, 0, sizeof(*rdat));

  00026	48 8b 7c 24 68	 mov	 rdi, QWORD PTR rdat$[rsp]
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 04 00 00 00	 mov	 ecx, 4
  00032	f3 aa		 rep stosb

; 306  : 
; 307  :     /* Locate the device block */
; 308  :     dev = find_device_by_devnum (0,devnum);

  00034	0f b7 54 24 58	 movzx	 edx, WORD PTR devnum$[rsp]
  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 find_device_by_devnum
  00040	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 309  : 
; 310  :     /* Return 0 if device is not found */
; 311  :     if (!dev)

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0004b	75 07		 jne	 SHORT $LN7@z900_vmdev

; 312  :        return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 ed 03 00 00	 jmp	 $LN1@z900_vmdev
$LN7@z900_vmdev:

; 313  : 
; 314  :     /* Indicate the device is dedicated - all Hercules devices are */
; 315  :     vdat->vdevstat = DS_DED;

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00059	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 316  : 
; 317  :     /* Find the device in the VM table */
; 318  :     vmentry=NULL;

  0005d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR vmentry$[rsp], 0

; 319  :     for (i = 0; i < (int)VMDEV_NUM; i++)

  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006e	eb 0a		 jmp	 SHORT $LN4@z900_vmdev
$LN2@z900_vmdev:
  00070	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00074	ff c0		 inc	 eax
  00076	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_vmdev:
  0007a	83 7c 24 20 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  0007f	73 3e		 jae	 SHORT $LN3@z900_vmdev

; 320  :        {
; 321  : #if 0 // debug
; 322  :            LOGMSG( "vmdevice_data: i=%i %4.4X %2.2X %2.2X %2.2X\n",i,
; 323  :                    vmdev[i].vmhtype, vmdev[i].vmdevcls, vmdev[i].vmdevtyp, vmdev[i].vmdiags );
; 324  : #endif
; 325  :            if (dev->devtype == vmdev[i].vmhtype)

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0008a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0008e	48 6b c9 06	 imul	 rcx, rcx, 6
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:vmdev
  00099	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0009d	3b c1		 cmp	 eax, ecx
  0009f	75 1c		 jne	 SHORT $LN8@z900_vmdev

; 326  :            {
; 327  :                vmentry = &vmdev[i];

  000a1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a5	48 6b c0 06	 imul	 rax, rax, 6
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:vmdev
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 89 44 24 30	 mov	 QWORD PTR vmentry$[rsp], rax

; 328  :                break;

  000bb	eb 02		 jmp	 SHORT $LN3@z900_vmdev
$LN8@z900_vmdev:

; 329  :            }
; 330  :        }

  000bd	eb b1		 jmp	 SHORT $LN2@z900_vmdev
$LN3@z900_vmdev:

; 331  : #if 0 // debug
; 332  :     LOGMSG( "FOUND: %4.4X %2.2X %2.2X %2.2X\n",
; 333  :             vmentry->vmhtype, vmentry->vmdevcls, vmentry->vmdevtyp, vmentry->vmdiags );
; 334  : #endif
; 335  : 
; 336  :     /* If device is not in the table or it isn't recognized by DIAG X'24' */
; 337  :     if ( !vmentry || ( code==0x24 && !(vmentry->vmdiags & VMDIAG024 ) ) )

  000bf	48 83 7c 24 30
	00		 cmp	 QWORD PTR vmentry$[rsp], 0
  000c5	74 19		 je	 SHORT $LN10@z900_vmdev
  000c7	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  000cc	75 3e		 jne	 SHORT $LN9@z900_vmdev
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR vmentry$[rsp]
  000d3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000d7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN9@z900_vmdev
$LN10@z900_vmdev:

; 338  :     {
; 339  :         /* Set the real and virtual data to an unsupported device */
; 340  :         vdat->vdevcls = DC_SPEC;

  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000e5	c6 00 02	 mov	 BYTE PTR [rax], 2

; 341  :         vdat->vdevtyp = DT_UNKN;

  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000ed	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 342  :         rdat->rdevcls = DC_SPEC;

  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000f6	c6 00 02	 mov	 BYTE PTR [rax], 2

; 343  :         rdat->rdevtyp = DT_UNKN;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000fe	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 344  :         return dev;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00107	e9 35 03 00 00	 jmp	 $LN1@z900_vmdev
$LN9@z900_vmdev:

; 345  :     }
; 346  : 
; 347  :     /* Set the virtual and real data to the device's VM class and type */
; 348  :     vdat->vdevcls = vmentry->vmdevcls;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00116	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0011a	88 08		 mov	 BYTE PTR [rax], cl

; 349  :     vdat->vdevtyp = vmentry->vmdevtyp;

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00121	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00126	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0012a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 350  :     rdat->rdevcls = vmentry->vmdevcls;

  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00137	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0013b	88 08		 mov	 BYTE PTR [rax], cl

; 351  :     rdat->rdevtyp = vmentry->vmdevtyp;

  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00147	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0014b	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 352  : 
; 353  :     /* Indicate if the device is busy */
; 354  :     if (0
; 355  :         || dev->startpending
; 356  :         || (1

  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 42		 jne	 SHORT $LN12@z900_vmdev
  00154	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00159	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0015f	c1 e8 19	 shr	 eax, 25
  00162	83 e0 01	 and	 eax, 1
  00165	85 c0		 test	 eax, eax
  00167	75 2d		 jne	 SHORT $LN12@z900_vmdev
  00169	33 c0		 xor	 eax, eax
  0016b	83 f8 01	 cmp	 eax, 1
  0016e	74 3a		 je	 SHORT $LN11@z900_vmdev
  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00175	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0017b	c1 e8 13	 shr	 eax, 19
  0017e	83 e0 01	 and	 eax, 1
  00181	85 c0		 test	 eax, eax
  00183	74 25		 je	 SHORT $LN11@z900_vmdev
  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00194	75 14		 jne	 SHORT $LN11@z900_vmdev
$LN12@z900_vmdev:

; 357  :             && dev->busy
; 358  : #if defined( OPTION_SHARED_DEVICES )
; 359  :             && dev->shioactive == DEV_SYS_LOCAL
; 360  : #endif // defined( OPTION_SHARED_DEVICES )
; 361  :            )
; 362  :     )
; 363  :         vdat->vdevstat |= DS_BUSY;

  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  0019b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0019f	83 c8 20	 or	 eax, 32			; 00000020H
  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001a7	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN11@z900_vmdev:

; 364  : 
; 365  :     /* Set virtual device flags, and real device model and features */
; 366  :     vdat->vdevflag = 0x00;

  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001af	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 367  :     rdat->rdevmodl = 0x00;

  001b3	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001b8	c6 40 02 00	 mov	 BYTE PTR [rax+2], 0

; 368  :     rdat->rdevfeat = 0x00;

  001bc	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001c1	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 369  : 
; 370  :     if (dev->hnd->reserve)           /* Indicate if RESERVE/RELEASE supported */

  001c5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  001d1	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001d6	74 14		 je	 SHORT $LN13@z900_vmdev

; 371  :         vdat->vdevflag |= DF_RSRL;

  001d8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001dd	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e1	83 c8 02	 or	 eax, 2
  001e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001e9	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN13@z900_vmdev:

; 372  : 
; 373  : #if defined(FEATURE_MIDAW_FACILITY)
; 374  :     /* If DIAGNOSE X'210', indicate if MIDAW's are supported */
; 375  :     if (code==0x210)

  001ec	81 7c 24 50 10
	02 00 00	 cmp	 DWORD PTR code$[rsp], 528 ; 00000210H
  001f4	75 14		 jne	 SHORT $LN14@z900_vmdev

; 376  :         vdat->vdevflag |= DF_MIDAW;

  001f6	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001fb	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001ff	83 c8 01	 or	 eax, 1
  00202	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  00207	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN14@z900_vmdev:

; 377  : #endif /* FEATURE_MIDAW_FACILITY */
; 378  : 
; 379  :     switch (rdat->rdevcls) {

  0020a	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0020f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00212	88 44 24 24	 mov	 BYTE PTR tv176[rsp], al
  00216	80 7c 24 24 01	 cmp	 BYTE PTR tv176[rsp], 1
  0021b	0f 84 4c 01 00
	00		 je	 $LN24@z900_vmdev
  00221	80 7c 24 24 02	 cmp	 BYTE PTR tv176[rsp], 2
  00226	0f 84 f7 01 00
	00		 je	 $LN31@z900_vmdev
  0022c	80 7c 24 24 04	 cmp	 BYTE PTR tv176[rsp], 4
  00231	74 10		 je	 SHORT $LN15@z900_vmdev
  00233	80 7c 24 24 80	 cmp	 BYTE PTR tv176[rsp], 128 ; 00000080H
  00238	0f 84 4c 01 00
	00		 je	 $LN25@z900_vmdev
  0023e	e9 f9 01 00 00	 jmp	 $LN5@z900_vmdev
$LN15@z900_vmdev:

; 380  :     case DC_DASD:
; 381  :          if (dev->hnd->reserve)

  00243	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00248	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0024f	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00254	74 14		 je	 SHORT $LN16@z900_vmdev

; 382  :             rdat->rdevfeat |= DRF_RSRL;

  00256	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0025b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0025f	83 c8 02	 or	 eax, 2
  00262	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00267	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN16@z900_vmdev:

; 383  :          if (dev->numsense==24)

  0026a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0026f	83 b8 60 03 00
	00 18		 cmp	 DWORD PTR [rax+864], 24
  00276	75 14		 jne	 SHORT $LN17@z900_vmdev

; 384  :             rdat->rdevfeat |= DRF_EXTSNS;

  00278	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0027d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00281	83 c8 40	 or	 eax, 64			; 00000040H
  00284	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00289	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN17@z900_vmdev:

; 385  :          if (dev->ckdtab->sectors)

  0028c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00291	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00298	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  0029c	85 c0		 test	 eax, eax
  0029e	74 15		 je	 SHORT $LN18@z900_vmdev

; 386  :             rdat->rdevfeat |= DRF_RPS;

  002a0	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002a5	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002a9	0f ba e8 07	 bts	 eax, 7
  002ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002b2	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN18@z900_vmdev:

; 387  :          if (dev->devtype == 0x3340)

  002b5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ba	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002be	3d 40 33 00 00	 cmp	 eax, 13120		; 00003340H
  002c3	75 3f		 jne	 SHORT $LN19@z900_vmdev

; 388  :          {
; 389  :             if (dev->ckdtab->model==0x01)

  002c5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ca	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002d1	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  002d5	83 f8 01	 cmp	 eax, 1
  002d8	75 16		 jne	 SHORT $LN20@z900_vmdev

; 390  :                rdat->rdevfeat |= DRF_35M;

  002da	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002df	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002e3	83 c8 08	 or	 eax, 8
  002e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002eb	88 41 03	 mov	 BYTE PTR [rcx+3], al
  002ee	eb 14		 jmp	 SHORT $LN21@z900_vmdev
$LN20@z900_vmdev:

; 391  :             else
; 392  :                rdat->rdevfeat |= DRF_70M;

  002f0	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002f5	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002f9	83 c8 04	 or	 eax, 4
  002fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00301	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN21@z900_vmdev:
$LN19@z900_vmdev:

; 393  :          }
; 394  :          if ( dev->devtype == 0x3380  && code == 0x24)

  00304	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00309	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0030d	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  00312	75 3c		 jne	 SHORT $LN22@z900_vmdev
  00314	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  00319	75 35		 jne	 SHORT $LN22@z900_vmdev

; 395  :             rdat->rdevmodl = (dev->ckdtab->model & 0x0F) | (dev->ckdcu->model & 0xF0);

  0031b	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00320	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00327	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  0032b	83 e0 0f	 and	 eax, 15
  0032e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00333	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  0033a	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  0033e	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00344	0b c1		 or	 eax, ecx
  00346	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0034b	88 41 02	 mov	 BYTE PTR [rcx+2], al
  0034e	eb 18		 jmp	 SHORT $LN23@z900_vmdev
$LN22@z900_vmdev:

; 396  :          else
; 397  :             rdat->rdevmodl = dev->ckdtab->model;

  00350	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00355	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0035c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00361	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00365	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN23@z900_vmdev:

; 398  :          break;

  00368	e9 cf 00 00 00	 jmp	 $LN5@z900_vmdev
$LN24@z900_vmdev:

; 399  :      case DC_FBA:
; 400  :          rdat->rdevmodl = dev->fbatab->model;

  0036d	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00372	48 8b 80 80 11
	00 00		 mov	 rax, QWORD PTR [rax+4480]
  00379	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0037e	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00382	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 401  :          break;

  00385	e9 b2 00 00 00	 jmp	 $LN5@z900_vmdev
$LN25@z900_vmdev:

; 402  :      case DC_TERM:
; 403  :          if (dev->devtype==0x3215)

  0038a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00393	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00398	75 0b		 jne	 SHORT $LN26@z900_vmdev

; 404  :          {
; 405  :             rdat->rdevfeat = 0x50;

  0039a	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0039f	c6 40 03 50	 mov	 BYTE PTR [rax+3], 80	; 00000050H

; 406  :             /* Note: 0x50 is carried forward from the previous version of       */
; 407  :             /* DIAGNOSE X'24'. The actual meaning was not previously documented */
; 408  :          }

  003a3	eb 7c		 jmp	 SHORT $LN27@z900_vmdev
$LN26@z900_vmdev:

; 409  :          else
; 410  :          {
; 411  :             if (dev->devtype==0x2703 && dev->commadpt)

  003a5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003aa	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  003ae	3d 03 27 00 00	 cmp	 eax, 9987		; 00002703H
  003b3	75 6c		 jne	 SHORT $LN28@z900_vmdev
  003b5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003ba	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  003c2	74 5d		 je	 SHORT $LN28@z900_vmdev

; 412  :             {
; 413  :                 if (dev->commadpt->enabled)

  003c4	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003c9	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003d0	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  003d6	83 e0 01	 and	 eax, 1
  003d9	85 c0		 test	 eax, eax
  003db	74 15		 je	 SHORT $LN29@z900_vmdev

; 414  :                    vdat->vdevflag |= DF_ENA;

  003dd	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  003e2	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003e6	0f ba e8 07	 bts	 eax, 7
  003ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  003ef	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN29@z900_vmdev:

; 415  :                 if (dev->commadpt->connect)

  003f2	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003f7	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003fe	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  00404	d1 e8		 shr	 eax, 1
  00406	83 e0 01	 and	 eax, 1
  00409	85 c0		 test	 eax, eax
  0040b	74 14		 je	 SHORT $LN30@z900_vmdev

; 416  :                    vdat->vdevflag |= DF_CONN;

  0040d	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00412	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00416	83 c8 40	 or	 eax, 64			; 00000040H
  00419	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  0041e	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN30@z900_vmdev:
$LN28@z900_vmdev:
$LN27@z900_vmdev:

; 417  :             }
; 418  :          }
; 419  :          break;

  00421	eb 19		 jmp	 SHORT $LN5@z900_vmdev
$LN31@z900_vmdev:

; 420  :      case DC_SPEC:
; 421  :          if (rdat->rdevtyp==DT_CTCA)

  00423	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00428	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0042c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00431	75 09		 jne	 SHORT $LN32@z900_vmdev

; 422  :             rdat->rdevfeat = DRF_CTCA;

  00433	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00438	c6 40 03 40	 mov	 BYTE PTR [rax+3], 64	; 00000040H
$LN32@z900_vmdev:
$LN5@z900_vmdev:

; 423  :      }
; 424  : 
; 425  :      /* Return the located DEVBLK to the caller */
; 426  :      return dev;

  0043c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@z900_vmdev:

; 427  : 
; 428  : } /* end function vmdevice_data */

  00441	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00445	5f		 pop	 rdi
  00446	c3		 ret	 0
z900_vmdevice_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_store_doubleword_absolute
_TEXT	SEGMENT
value$ = 64
addr$ = 72
regs$ = 80
z900_store_doubleword_absolute PROC			; COMDAT

; 863  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_store:

; 864  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 865  :     if (addr > regs->mainlim - 8)
; 866  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 867  : #endif
; 868  : 
; 869  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 870  :        is treated as a no-operation if SIE_MODE not active */
; 871  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001e	d1 e8		 shr	 eax, 1
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 6b		 je	 SHORT $LN5@z900_store
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00032	c1 e8 02	 shr	 eax, 2
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	75 56		 jne	 SHORT $LN5@z900_store
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00048	48 03 44 24 48	 add	 rax, QWORD PTR addr$[rsp]
  0004d	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00056	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0005b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0006d	ba fd ff ff ff	 mov	 edx, -3
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 z900_logical_to_main_l
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00086	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0008d	48 89 44 24 48	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_store:
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_store

; 872  : 
; 873  :     /* Set the main storage reference and change bits */
; 874  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  0009c	b2 06		 mov	 dl, 6
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 z900_or_storage_key

; 875  : 
; 876  :     /* Store the doubleword into absolute storage */
; 877  :     store_dw( regs->mainstor + addr, value );

  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value$[rsp]
  000ad	e8 00 00 00 00	 call	 _byteswap_uint64
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000be	48 03 4c 24 48	 add	 rcx, QWORD PTR addr$[rsp]
  000c3	48 8b d0	 mov	 rdx, rax
  000c6	e8 00 00 00 00	 call	 store_dw_noswap

; 878  : 
; 879  : } /* end function store_doubleword_absolute */

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
z900_store_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
z900_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
z900_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6b		 je	 SHORT $LN5@z900_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 56		 jne	 SHORT $LN5@z900_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00081	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00088	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_fetch:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00097	b2 04		 mov	 dl, 4
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009e	e8 00 00 00 00	 call	 z900_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000af	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b8	c3		 ret	 0
z900_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
z900_put_storage_key PROC				; COMDAT

; 272  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 273  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 274  :     ARCH_DEP( put_2K_storage_key )( abs, key );
; 275  : #else
; 276  :     ARCH_DEP( put_4K_storage_key )( abs, key );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR key$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_put_4K_storage_key

; 277  : #endif
; 278  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_storage_key
_TEXT	SEGMENT
abs$ = 48
z900_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_get_4K_storage_key

; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
z900_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_put_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
z900_put_4K_storage_key PROC				; COMDAT

; 240  :   inline void  ARCH_DEP( put_4K_storage_key )     (              U64 abs, BYTE key  ) {        ARCH_DEP( _put_storage_key     )(      abs, key  & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR key$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__put_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_put_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
z900_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 z900__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
z900_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
K$ = 64
z900__put_storage_key PROC				; COMDAT

; 158  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900__put_:

; 159  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__put_

; 160  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 24		 je	 SHORT $LN5@z900__put_

; 161  :     {
; 162  :         *_get_storekey1_ptr( abs ) = key;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  0002d	88 08		 mov	 BYTE PTR [rax], cl

; 163  :         *_get_storekey2_ptr( abs ) = key;

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00034	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00039	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  0003e	88 08		 mov	 BYTE PTR [rax], cl

; 164  :     }

  00040	eb 16		 jmp	 SHORT $LN6@z900__put_
$LN5@z900__put_:

; 165  :     else
; 166  :     {
; 167  :         *_get_storekey_ptr(  abs, K ) = key;

  00042	0f b6 54 24 40	 movzx	 edx, BYTE PTR K$[rsp]
  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0004c	e8 00 00 00 00	 call	 _get_storekey_ptr
  00051	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  00056	88 08		 mov	 BYTE PTR [rax], cl
$LN6@z900__put_:

; 168  :     }
; 169  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
z900__put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
z900__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@z900__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@z900__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@z900__get_
$LN5@z900__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@z900__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
z900__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
b2$ = 64
temp$1 = 68
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_inter_user_communication_vehicle PROC

; 1686 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1687 : int     b2;                             /* Effective addr base       */
; 1688 : VADR    effective_addr2;                /* Effective address         */
; 1689 : 
; 1690 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN11@z900_inter
  00048	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_inter:
$LN4@z900_inter:
  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN12@z900_inter
  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN12@z900_inter:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_inter

; 1691 :     PER_ZEROADDR_XCHECK( regs, b2 );

  000b5	8b 54 24 40	 mov	 edx, DWORD PTR b2$[rsp]
  000b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1692 : 
; 1693 : #if defined(FEATURE_ECPSVM)
; 1694 :     if(ecpsvm_doiucv(regs,b2,effective_addr2)==0)
; 1695 :     {
; 1696 :         return;
; 1697 :     }
; 1698 : #endif
; 1699 : 
; 1700 :     /* Program check if in problem state,
; 1701 :        the IUCV instruction generates an operation exception
; 1702 :        rather then a priviliged operation exception when
; 1703 :        executed in problem state                                 *JJ */
; 1704 :     if ( PROBSTATE(&regs->psw) )

  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000cc	83 e0 01	 and	 eax, 1
  000cf	85 c0		 test	 eax, eax
  000d1	74 0f		 je	 SHORT $LN13@z900_inter

; 1705 :         ARCH_DEP(program_interrupt) (regs, PGM_OPERATION_EXCEPTION);

  000d3	ba 01 00 00 00	 mov	 edx, 1
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_inter:
$LN7@z900_inter:

; 1706 : 
; 1707 :     SIE_INTERCEPT(regs);

  000e2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ed	d1 e8		 shr	 eax, 1
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	74 18		 je	 SHORT $LN14@z900_inter
  000f6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000fb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00101	ba fc ff ff ff	 mov	 edx, -4
  00106	48 8b c8	 mov	 rcx, rax
  00109	e8 00 00 00 00	 call	 longjmp
$LN14@z900_inter:
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	75 ce		 jne	 SHORT $LN7@z900_inter
$LN10@z900_inter:

; 1708 : 
; 1709 :     PTT_ERR("*IUCV",b2,effective_addr2,regs->psw.IA_L);

  00114	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0011b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011e	48 83 e0 10	 and	 rax, 16
  00122	48 85 c0	 test	 rax, rax
  00125	74 44		 je	 SHORT $LN15@z900_inter
  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00132	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR b2$[rsp]
  00137	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00140	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194110
  0014c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00151	4c 8b 4c 24 48	 mov	 r9, QWORD PTR effective_addr2$[rsp]
  00156	4c 8b c1	 mov	 r8, rcx
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194111
  00160	b9 10 00 00 00	 mov	 ecx, 16
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@z900_inter:
  0016b	33 c0		 xor	 eax, eax
  0016d	85 c0		 test	 eax, eax
  0016f	75 a3		 jne	 SHORT $LN10@z900_inter

; 1710 : 
; 1711 :     /* Set condition code to indicate IUCV not available */
; 1712 :     regs->psw.cc = 3;

  00171	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00176	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN16@z900_inter:

; 1713 : }

  0017a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017e	c3		 ret	 0
z900_inter_user_communication_vehicle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 48
buflen$ = 52
bufadr$ = 56
timeval$ = 64
tmptr$ = 72
buf$ = 80
dattim$ = 144
__$ArrayPad$ = 208
code$ = 256
r1$ = 264
r2$ = 272
regs$ = 280
z900_pseudo_timer PROC

; 1508 : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1509 : int     i;                              /* Array subscript           */
; 1510 : time_t  timeval;                        /* Current time              */
; 1511 : struct  tm *tmptr;                      /* -> Current time structure */
; 1512 : U32     bufadr;                         /* Real addr of data buffer  */
; 1513 : U32     buflen;                         /* Length of data buffer     */
; 1514 : char    buf[64];                        /* Response buffer           */
; 1515 : BYTE    dattim[64];                     /* Date and time (EBCDIC)    */
; 1516 : #define DIAG_DATEFMT_SHORT      0x80    /* Date format mm/dd/yy      */
; 1517 : #define DIAG_DATEFMT_FULL       0x40    /* Date format mm/dd/yyyy    */
; 1518 : #define DIAG_DATEFMT_ISO        0x20    /* Date format yyyy-mm-dd    */
; 1519 : #define DIAG_DATEFMT_SYSDFLT    0x10    /* System-wide default format*/
; 1520 : static  char timefmt[]="%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d";
; 1521 : 
; 1522 :     /* Get the current date and time in EBCDIC */
; 1523 :     timeval = time(NULL);

  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 time
  00034	48 89 44 24 40	 mov	 QWORD PTR timeval$[rsp], rax

; 1524 :     tmptr = localtime(&timeval);

  00039	48 8d 4c 24 40	 lea	 rcx, QWORD PTR timeval$[rsp]
  0003e	e8 00 00 00 00	 call	 localtime
  00043	48 89 44 24 48	 mov	 QWORD PTR tmptr$[rsp], rax

; 1525 :     strftime((char *)dattim, sizeof(dattim), timefmt, tmptr);

  00048	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tmptr$[rsp]
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?timefmt@?1??z900_pseudo_timer@@9@9
  00054	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00059	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 1526 :     for (i = 0; dattim[i] != '\0'; i++)

  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@z900_pseud
$LN2@z900_pseud:
  00071	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_pseud:
  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR dattim$[rsp+rax]
  00088	85 c0		 test	 eax, eax
  0008a	74 21		 je	 SHORT $LN3@z900_pseud

; 1527 :         dattim[i] = host_to_guest(dattim[i]);

  0008c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00091	0f b6 8c 04 90
	00 00 00	 movzx	 ecx, BYTE PTR dattim$[rsp+rax]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0009f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a4	88 84 0c 90 00
	00 00		 mov	 BYTE PTR dattim$[rsp+rcx], al
  000ab	eb c4		 jmp	 SHORT $LN2@z900_pseud
$LN3@z900_pseud:

; 1528 : 
; 1529 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1530 :     bufadr = regs->GR_L(r1);

  000ad	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c4	89 44 24 38	 mov	 DWORD PTR bufadr$[rsp], eax

; 1531 :     buflen = regs->GR_L(r2);

  000c8	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000d0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000df	89 44 24 34	 mov	 DWORD PTR buflen$[rsp], eax

; 1532 : 
; 1533 :     /* Use length 32 if R2 is zero or function code is 00C */
; 1534 :     if (r2 == 0 || code == 0x00C)

  000e3	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  000eb	74 0a		 je	 SHORT $LN6@z900_pseud
  000ed	83 bc 24 00 01
	00 00 0c	 cmp	 DWORD PTR code$[rsp], 12
  000f5	75 08		 jne	 SHORT $LN5@z900_pseud
$LN6@z900_pseud:

; 1535 :         buflen = 32;

  000f7	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 32 ; 00000020H
$LN5@z900_pseud:

; 1536 : 
; 1537 :     /* Program check if R1 and R2 specify the same non-zero
; 1538 :        register number, or if buffer length is less than or
; 1539 :        equal to zero, or if buffer address is zero, or if
; 1540 :        buffer is not on a doubleword boundary */
; 1541 :     if ((r2 != 0 && r2 == r1)
; 1542 :         || (S32)buflen <= 0
; 1543 :         || bufadr == 0
; 1544 :         || (bufadr & 0x00000007))

  000ff	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  00107	74 10		 je	 SHORT $LN9@z900_pseud
  00109	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00110	39 84 24 10 01
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  00117	74 19		 je	 SHORT $LN8@z900_pseud
$LN9@z900_pseud:
  00119	83 7c 24 34 00	 cmp	 DWORD PTR buflen$[rsp], 0
  0011e	7e 12		 jle	 SHORT $LN8@z900_pseud
  00120	83 7c 24 38 00	 cmp	 DWORD PTR bufadr$[rsp], 0
  00125	74 0b		 je	 SHORT $LN8@z900_pseud
  00127	8b 44 24 38	 mov	 eax, DWORD PTR bufadr$[rsp]
  0012b	83 e0 07	 and	 eax, 7
  0012e	85 c0		 test	 eax, eax
  00130	74 12		 je	 SHORT $LN7@z900_pseud
$LN8@z900_pseud:

; 1545 :     {
; 1546 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_pseud:

; 1547 :     }
; 1548 : 
; 1549 :     /* Build the response buffer */
; 1550 :     memset (buf, 0, sizeof(buf));

  00144	48 8d 44 24 50	 lea	 rax, QWORD PTR buf$[rsp]
  00149	48 8b f8	 mov	 rdi, rax
  0014c	33 c0		 xor	 eax, eax
  0014e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00153	f3 aa		 rep stosb

; 1551 :     /* Bytes 0-7 contain the date as EBCDIC MM/DD/YY */
; 1552 :     memcpy (buf, dattim, 8);

  00155	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp]
  0015d	48 89 44 24 50	 mov	 QWORD PTR buf$[rsp], rax

; 1553 :     /* Bytes 8-15 contain the time as EBCDIC HH:MM:SS */
; 1554 :     memcpy (buf+8, dattim+8, 8);

  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp+8]
  0016a	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp+8], rax

; 1555 :     /* Bytes 16-23 contain the virtual CPU time used in microseconds */
; 1556 :     /* Bytes 24-31 contain the total CPU time used in microseconds */
; 1557 :     /* Bytes 32-41 contain the date as EBCDIC MM/DD/YYYY */
; 1558 :     memcpy (buf+32, dattim+16, 10);

  0016f	48 8d 44 24 70	 lea	 rax, QWORD PTR buf$[rsp+32]
  00174	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+16]
  0017c	48 8b f8	 mov	 rdi, rax
  0017f	48 8b f1	 mov	 rsi, rcx
  00182	b9 0a 00 00 00	 mov	 ecx, 10
  00187	f3 a4		 rep movsb

; 1559 :     /* Bytes 42-47 contain binary zeroes */
; 1560 :     /* Bytes 48-57 contain the date as EBCDIC YYYY-MM-DD */
; 1561 :     memcpy (buf+48, dattim+26, 10);

  00189	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+48]
  00191	48 8d 8c 24 aa
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+26]
  00199	48 8b f8	 mov	 rdi, rax
  0019c	48 8b f1	 mov	 rsi, rcx
  0019f	b9 0a 00 00 00	 mov	 ecx, 10
  001a4	f3 a4		 rep movsb

; 1562 :     /* Byte 58 contains the diagnose 270 version code */
; 1563 :     buf[58] = 0x01;

  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	48 6b c0 3a	 imul	 rax, rax, 58		; 0000003aH
  001af	c6 44 04 50 01	 mov	 BYTE PTR buf$[rsp+rax], 1

; 1564 :     /* Byte 59 contains the user's default date format */
; 1565 :     buf[59] = DIAG_DATEFMT_ISO;

  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	48 6b c0 3b	 imul	 rax, rax, 59		; 0000003bH
  001bd	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1566 :     /* Byte 60 contains the system default date format */
; 1567 :     buf[60] = DIAG_DATEFMT_ISO;

  001c2	b8 01 00 00 00	 mov	 eax, 1
  001c7	48 6b c0 3c	 imul	 rax, rax, 60		; 0000003cH
  001cb	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1568 :     /* Bytes 61-63 contain binary zeroes */
; 1569 : 
; 1570 : #if 0 // debug
; 1571 :     LOGMSG( "Diagnose X'%3.3X':"
; 1572 : 
; 1573 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1574 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1575 : 
; 1576 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1577 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1578 : 
; 1579 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1580 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1581 : 
; 1582 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1583 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1584 : 
; 1585 :             , code
; 1586 : 
; 1587 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1588 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1589 : 
; 1590 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1591 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1592 : 
; 1593 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1594 :             , buf[40], buf[41], buf[42], buf[43], buf[44], buf[45], buf[46], buf[47]
; 1595 : 
; 1596 :             , buf[48], buf[49], buf[50], buf[51], buf[52], buf[53], buf[54], buf[55]
; 1597 :             , buf[56], buf[57], buf[58], buf[59], buf[60], buf[61], buf[63], buf[63]
; 1598 :         );
; 1599 : #endif
; 1600 : 
; 1601 :     /* Enforce maximum length to store */
; 1602 :     if (buflen > sizeof(buf))

  001d0	8b 44 24 34	 mov	 eax, DWORD PTR buflen$[rsp]
  001d4	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  001d8	76 08		 jbe	 SHORT $LN10@z900_pseud

; 1603 :         buflen = sizeof(buf);

  001da	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 64 ; 00000040H
$LN10@z900_pseud:

; 1604 : 
; 1605 :     /* Store the response buffer at the operand location */
; 1606 :     ARCH_DEP(vstorec) (buf, buflen-1, bufadr, USE_REAL_ADDR, regs);

  001e2	8b 44 24 38	 mov	 eax, DWORD PTR bufadr$[rsp]
  001e6	8b 4c 24 34	 mov	 ecx, DWORD PTR buflen$[rsp]
  001ea	ff c9		 dec	 ecx
  001ec	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001f9	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  001ff	44 8b c0	 mov	 r8d, eax
  00202	0f b6 d1	 movzx	 edx, cl
  00205	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0020a	e8 00 00 00 00	 call	 z900_vstorec

; 1607 : 
; 1608 : } /* end function pseudo_timer */

  0020f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00217	48 33 cc	 xor	 rcx, rsp
  0021a	e8 00 00 00 00	 call	 __security_check_cookie
  0021f	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00226	5f		 pop	 rdi
  00227	5e		 pop	 rsi
  00228	c3		 ret	 0
z900_pseudo_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
buflen$ = 64
bufadr$ = 68
r1$ = 96
r2$ = 104
regs$ = 112
z900_access_reipl_data PROC

; 1229 : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1230 : U32     bufadr;                         /* Real addr of data buffer  */
; 1231 : U32     buflen;                         /* Length of data buffer     */
; 1232 : 
; 1233 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1234 :     bufadr = regs->GR_L(r1);

  00011	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 44	 mov	 DWORD PTR bufadr$[rsp], eax

; 1235 :     buflen = regs->GR_L(r2);

  00026	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0002b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00037	89 44 24 40	 mov	 DWORD PTR buflen$[rsp], eax

; 1236 : 
; 1237 :     /* Program check if buffer length is negative */
; 1238 :     if ((S32)buflen < 0)

  0003b	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00040	7d 0f		 jge	 SHORT $LN5@z900_acces

; 1239 :     {
; 1240 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00042	ba 06 00 00 00	 mov	 edx, 6
  00047	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	e8 00 00 00 00	 call	 z900_program_interrupt
$LN5@z900_acces:

; 1241 :     }
; 1242 : 
; 1243 :     /* Store IPL information if buffer length is non-zero */
; 1244 :     if (buflen > 0)

  00051	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00056	76 18		 jbe	 SHORT $LN6@z900_acces

; 1245 :     {
; 1246 :         /* Store one byte of zero to indicate no IPL information */
; 1247 :         ARCH_DEP(vstoreb) (0, bufadr, USE_REAL_ADDR, regs);

  00058	8b 44 24 44	 mov	 eax, DWORD PTR bufadr$[rsp]
  0005c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00061	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00067	8b d0		 mov	 edx, eax
  00069	33 c9		 xor	 ecx, ecx
  0006b	e8 00 00 00 00	 call	 z900_vstoreb
$LN6@z900_acces:
$LN4@z900_acces:

; 1248 :     }
; 1249 : 
; 1250 :     PTT_ERR("*DIAG0B0",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	48 83 e0 10	 and	 rax, 16
  0007e	48 85 c0	 test	 rax, rax
  00081	74 60		 je	 SHORT $LN7@z900_acces
  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00088	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0008e	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00093	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00098	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  0009f	48 63 54 24 60	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000a4	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000a9	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  000b1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ba	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193942
  000c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cb	44 8b c9	 mov	 r9d, ecx
  000ce	44 8b c2	 mov	 r8d, edx
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193943
  000d8	b9 10 00 00 00	 mov	 ecx, 16
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN7@z900_acces:
  000e3	33 c0		 xor	 eax, eax
  000e5	85 c0		 test	 eax, eax
  000e7	75 87		 jne	 SHORT $LN4@z900_acces

; 1251 : 
; 1252 :     /* Return code 4 means no re-IPL information available */
; 1253 :     regs->GR_L(r2) = 4;

  000e9	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  000ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1254 : 
; 1255 : } /* end function access_reipl_data */

  000fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00102	c3		 ret	 0
z900_access_reipl_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
bloklen$ = 64
tv185 = 68
dev$ = 72
devnum$ = 80
blokaddr$ = 88
vrdc$ = 96
__$ArrayPad$ = 352
r1$ = 400
r2$ = 408
regs$ = 416
z900_device_info PROC

; 1262 : {

$LN29:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_devic:

; 1263 : DEVBLK   *dev;             /* -> Device block                        */
; 1264 : VRDCBLOK vrdc;             /* VRDCBLOK                               */
; 1265 : RADR     blokaddr;         /* Location of the VRDCBLOK               */
; 1266 : U16      bloklen;          /* Length from the VRDCBLOK               */
; 1267 : #if 0
; 1268 : /* Only required if implementation is for the z/VM 5.3 level */
; 1269 : U16      reserved;         /* Bytes 14 and 15                        */
; 1270 : #endif
; 1271 : U16      devnum;           /* Device number from the VRDCBLOK        */
; 1272 : 
; 1273 : 
; 1274 :     UNREFERENCED(r2);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN4@z900_devic

; 1275 : 
; 1276 :     if (regs->GR_L(r1) & 0x3
; 1277 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1278 :         || (regs->psw.amode64)

  0002e	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00036	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00045	83 e0 03	 and	 eax, 3
  00048	85 c0		 test	 eax, eax
  0004a	75 15		 jne	 SHORT $LN11@z900_devic
  0004c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 12		 je	 SHORT $LN10@z900_devic
$LN11@z900_devic:

; 1279 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1280 :        )
; 1281 :     {
; 1282 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_devic:

; 1283 :     }
; 1284 : 
; 1285 :     blokaddr = regs->GR_L(r1);

  00073	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008a	48 89 44 24 58	 mov	 QWORD PTR blokaddr$[rsp], rax

; 1286 : 
; 1287 :     /* Fetch the first 4 bytes of the VRDCBLOK */
; 1288 :     ARCH_DEP(vfetchc) (&vrdc, 3, blokaddr, USE_REAL_ADDR, regs);

  0008f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009c	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000a2	4c 8b 44 24 58	 mov	 r8, QWORD PTR blokaddr$[rsp]
  000a7	b2 03		 mov	 dl, 3
  000a9	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  000ae	e8 00 00 00 00	 call	 z900_vfetchc

; 1289 : 
; 1290 :     /* Get the VRDCBLOK length from the working VRDC */
; 1291 :     FETCH_HW(bloklen,&vrdc.vrdclen);

  000b3	48 8d 4c 24 62	 lea	 rcx, QWORD PTR vrdc$[rsp+2]
  000b8	e8 00 00 00 00	 call	 fetch_hw_noswap
  000bd	0f b7 c8	 movzx	 ecx, ax
  000c0	e8 00 00 00 00	 call	 _byteswap_ushort
  000c5	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax

; 1292 : 
; 1293 :     /* VRDCBLOK length must be at least 8 bytes */
; 1294 :     if (bloklen<8)

  000ca	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000cf	83 f8 08	 cmp	 eax, 8
  000d2	7d 12		 jge	 SHORT $LN12@z900_devic

; 1295 :     {
; 1296 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000d4	ba 06 00 00 00	 mov	 edx, 6
  000d9	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN12@z900_devic:

; 1297 :     }
; 1298 : 
; 1299 :     /* Fetch remainder of supplied VRDCBLOK, but no more */
; 1300 :     if (bloklen>VRDCBLOK_SIZE)

  000e6	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000eb	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000f1	76 0a		 jbe	 SHORT $LN13@z900_devic

; 1301 :        bloklen=VRDCBLOK_SIZE;

  000f3	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000f8	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax
$LN13@z900_devic:

; 1302 :     ARCH_DEP(vfetchc) (&vrdc.vrdcvdat,bloklen-5,blokaddr+4, USE_REAL_ADDR, regs);

  000fd	48 8b 44 24 58	 mov	 rax, QWORD PTR blokaddr$[rsp]
  00102	48 83 c0 04	 add	 rax, 4
  00106	0f b7 4c 24 40	 movzx	 ecx, WORD PTR bloklen$[rsp]
  0010b	83 e9 05	 sub	 ecx, 5
  0010e	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00116	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0011b	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00121	4c 8b c0	 mov	 r8, rax
  00124	0f b6 d1	 movzx	 edx, cl
  00127	48 8d 4c 24 64	 lea	 rcx, QWORD PTR vrdc$[rsp+4]
  0012c	e8 00 00 00 00	 call	 z900_vfetchc

; 1303 : 
; 1304 : #if 0
; 1305 :     /* If length is 16 or greater, bytes 14 and 15 must be zero on z/VM 5.3.0 or earlier */
; 1306 :     if ( bloklen>=16)
; 1307 :     {
; 1308 :          FETCH_HW(reserved,&vrdc.vrdcrsvd);
; 1309 :          if (reserved != 0)
; 1310 :          {
; 1311 :               ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1312 :          }
; 1313 :     }
; 1314 : #endif
; 1315 : 
; 1316 :     /* Get the device number from the working VRDC */
; 1317 :     FETCH_HW(devnum,&vrdc.vrdcdvno);

  00131	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  00136	e8 00 00 00 00	 call	 fetch_hw_noswap
  0013b	0f b7 c8	 movzx	 ecx, ax
  0013e	e8 00 00 00 00	 call	 _byteswap_ushort
  00143	66 89 44 24 50	 mov	 WORD PTR devnum$[rsp], ax

; 1318 : 
; 1319 :     /* Locate the device block and set the virtual and real device information */
; 1320 :     dev = ARCH_DEP(vmdevice_data) (0x210,devnum,&vrdc.vrdcvdat,&vrdc.vrdcrcdt);

  00148	4c 8d 4c 24 68	 lea	 r9, QWORD PTR vrdc$[rsp+8]
  0014d	4c 8d 44 24 64	 lea	 r8, QWORD PTR vrdc$[rsp+4]
  00152	0f b7 54 24 50	 movzx	 edx, WORD PTR devnum$[rsp]
  00157	b9 10 02 00 00	 mov	 ecx, 528		; 00000210H
  0015c	e8 00 00 00 00	 call	 z900_vmdevice_data
  00161	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 1321 : 
; 1322 :     /* Return condition code 3 if device does not exist */
; 1323 :     if (!dev)

  00166	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0016c	0f 85 96 00 00
	00		 jne	 $LN14@z900_devic
$LN7@z900_devic:

; 1324 :     {
; 1325 :         PTT_ERR("*DIAG210",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00172	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00179	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017c	48 83 e0 10	 and	 rax, 16
  00180	48 85 c0	 test	 rax, rax
  00183	74 6f		 je	 SHORT $LN15@z900_devic
  00185	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00193	48 63 8c 24 98
	01 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0019b	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a3	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  001aa	48 63 94 24 90
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001b2	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ba	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193978
  001d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dc	44 8b c9	 mov	 r9d, ecx
  001df	44 8b c2	 mov	 r8d, edx
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193979
  001e9	b9 10 00 00 00	 mov	 ecx, 16
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@z900_devic:
  001f4	33 c0		 xor	 eax, eax
  001f6	85 c0		 test	 eax, eax
  001f8	0f 85 74 ff ff
	ff		 jne	 $LN7@z900_devic

; 1326 :         return 3;

  001fe	b8 03 00 00 00	 mov	 eax, 3
  00203	e9 a1 01 00 00	 jmp	 $LN1@z900_devic
$LN14@z900_devic:

; 1327 :     }
; 1328 : 
; 1329 :     /* Set the underlying device and real device features */
; 1330 :     vrdc.vrdcundv=0x00;

  00208	c6 44 24 6c 00	 mov	 BYTE PTR vrdc$[rsp+12], 0

; 1331 :     vrdc.vrdcrdaf=0x00;

  0020d	c6 44 24 6d 00	 mov	 BYTE PTR vrdc$[rsp+13], 0

; 1332 : 
; 1333 :     /* Create device dependent mappings */
; 1334 :     if (vrdc.vrdcvdat.vdevcls == DC_DASD)

  00212	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  00217	83 f8 04	 cmp	 eax, 4
  0021a	0f 85 ed 00 00
	00		 jne	 $LN16@z900_devic

; 1335 :     {
; 1336 :         memcpy(&vrdc.vrdcrdc,dev->devchar,42);

  00220	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  00225	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0022a	48 8b f8	 mov	 rdi, rax
  0022d	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  00234	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00239	f3 a4		 rep movsb

; 1337 :         switch (dev->devtype)

  0023b	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00240	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00244	89 44 24 44	 mov	 DWORD PTR tv185[rsp], eax
  00248	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv185[rsp], 13104 ; 00003330H
  00250	7f 2a		 jg	 SHORT $LN28@z900_devic
  00252	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv185[rsp], 13104 ; 00003330H
  0025a	74 36		 je	 SHORT $LN21@z900_devic
  0025c	81 7c 24 44 05
	23 00 00	 cmp	 DWORD PTR tv185[rsp], 8965 ; 00002305H
  00264	74 2c		 je	 SHORT $LN20@z900_devic
  00266	81 7c 24 44 11
	23 00 00	 cmp	 DWORD PTR tv185[rsp], 8977 ; 00002311H
  0026e	74 22		 je	 SHORT $LN18@z900_devic
  00270	81 7c 24 44 14
	23 00 00	 cmp	 DWORD PTR tv185[rsp], 8980 ; 00002314H
  00278	74 18		 je	 SHORT $LN19@z900_devic
  0027a	eb 6c		 jmp	 SHORT $LN8@z900_devic
$LN28@z900_devic:
  0027c	81 7c 24 44 40
	33 00 00	 cmp	 DWORD PTR tv185[rsp], 13120 ; 00003340H
  00284	74 0c		 je	 SHORT $LN22@z900_devic
  00286	81 7c 24 44 50
	33 00 00	 cmp	 DWORD PTR tv185[rsp], 13136 ; 00003350H
  0028e	74 02		 je	 SHORT $LN23@z900_devic
  00290	eb 56		 jmp	 SHORT $LN8@z900_devic
$LN18@z900_devic:
$LN19@z900_devic:
$LN20@z900_devic:
$LN21@z900_devic:
$LN22@z900_devic:
$LN23@z900_devic:

; 1338 :         {
; 1339 :              case 0x2311:
; 1340 :              case 0x2314:
; 1341 :              case 0x2305:
; 1342 :              case 0x3330:
; 1343 :              case 0x3340:
; 1344 :              case 0x3350:
; 1345 :                   /* Set non-keyed overhead */
; 1346 :                   STORE_HW(&vrdc.vrdcrdc[0x18],dev->ckdtab->f2);

  00292	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00297	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0029e	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  002a2	e8 00 00 00 00	 call	 _byteswap_ushort
  002a7	b9 01 00 00 00	 mov	 ecx, 1
  002ac	48 6b c9 18	 imul	 rcx, rcx, 24
  002b0	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002b5	0f b7 d0	 movzx	 edx, ax
  002b8	e8 00 00 00 00	 call	 store_hw_noswap

; 1347 :                   /* Set keyed overhead */
; 1348 :                   STORE_HW(&vrdc.vrdcrdc[0x1A],dev->ckdtab->f1);

  002bd	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002c2	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002c9	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  002cd	e8 00 00 00 00	 call	 _byteswap_ushort
  002d2	b9 01 00 00 00	 mov	 ecx, 1
  002d7	48 6b c9 1a	 imul	 rcx, rcx, 26
  002db	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002e0	0f b7 d0	 movzx	 edx, ax
  002e3	e8 00 00 00 00	 call	 store_hw_noswap
$LN8@z900_devic:

; 1349 :              /* Note: for all other DASD devices these fields contain bytes 24-27 of the RDC */
; 1350 :         }
; 1351 :         /* Set Control Unit ID */
; 1352 :         vrdc.vrdcrdc[0x2A]=dev->devchar[56];

  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  002f1	b9 01 00 00 00	 mov	 ecx, 1
  002f6	48 6b c9 2a	 imul	 rcx, rcx, 42		; 0000002aH
  002fa	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  002ff	0f b6 84 02 6c
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1388]
  00307	88 44 0c 70	 mov	 BYTE PTR vrdc$[rsp+rcx+16], al

; 1353 :     }

  0030b	eb 25		 jmp	 SHORT $LN17@z900_devic
$LN16@z900_devic:

; 1354 :     else if (vrdc.vrdcvdat.vdevcls == DC_FBA)

  0030d	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  00312	83 f8 01	 cmp	 eax, 1
  00315	75 1b		 jne	 SHORT $LN24@z900_devic

; 1355 :         memcpy(&vrdc.vrdcrdc,dev->devchar,32);

  00317	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  0031c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00321	48 8b f8	 mov	 rdi, rax
  00324	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  0032b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00330	f3 a4		 rep movsb
$LN24@z900_devic:
$LN17@z900_devic:

; 1356 : 
; 1357 :     /* Set Path Group ID */
; 1358 :     memcpy(&vrdc.vrdcpgid,dev->pgid,11);

  00332	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR vrdc$[rsp+80]
  0033a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0033f	48 8b f8	 mov	 rdi, rax
  00342	48 8d b1 ad 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1453]
  00349	b9 0b 00 00 00	 mov	 ecx, 11
  0034e	f3 a4		 rep movsb

; 1359 : 
; 1360 :     /* Set version */
; 1361 :     if (bloklen>0x60)

  00350	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  00355	83 f8 60	 cmp	 eax, 96			; 00000060H
  00358	7e 08		 jle	 SHORT $LN25@z900_devic

; 1362 :        vrdc.vrdcvers=0x01;

  0035a	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR vrdc$[rsp+96], 1
$LN25@z900_devic:

; 1363 : 
; 1364 :     /* Set underlying real device */
; 1365 :     if (!(vrdc.vrdcrdaf & VRDCEMRD))

  00362	0f b6 44 24 6d	 movzx	 eax, BYTE PTR vrdc$[rsp+13]
  00367	83 e0 02	 and	 eax, 2
  0036a	85 c0		 test	 eax, eax
  0036c	75 0d		 jne	 SHORT $LN26@z900_devic

; 1366 :        memcpy(&vrdc.vrdcrdev,&vrdc.vrdcdvno,2);

  0036e	0f b7 44 24 60	 movzx	 eax, WORD PTR vrdc$[rsp]
  00373	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR vrdc$[rsp+128], ax
$LN26@z900_devic:

; 1367 : 
; 1368 :     /* Update the VRDC in main storage */
; 1369 :     ARCH_DEP(vstorec) (&vrdc, bloklen-1, blokaddr, USE_REAL_ADDR, regs);

  0037b	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  00380	ff c8		 dec	 eax
  00382	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0038f	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00395	4c 8b 44 24 58	 mov	 r8, QWORD PTR blokaddr$[rsp]
  0039a	0f b6 d0	 movzx	 edx, al
  0039d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  003a2	e8 00 00 00 00	 call	 z900_vstorec

; 1370 : 
; 1371 :     /* Return condition code 0 for success */
; 1372 :     return 0;

  003a7	33 c0		 xor	 eax, eax
$LN1@z900_devic:

; 1373 : 
; 1374 : } /* end function device_info */

  003a9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b1	48 33 cc	 xor	 rcx, rsp
  003b4	e8 00 00 00 00	 call	 __security_check_cookie
  003b9	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  003c0	5f		 pop	 rdi
  003c1	5e		 pop	 rsi
  003c2	c3		 ret	 0
z900_device_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
tv69 = 36
stgarea$ = 40
dev$ = 48
stglen$ = 56
tv214 = 64
r1$ = 96
r2$ = 104
regs$ = 112
z900_vm_info PROC

; 1382 : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1383 : DEVBLK  *dev;                          /* -> Device block            */
; 1384 : U16     devnum;                        /* Device number              */
; 1385 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1386 : RADR    stgarea;                       /* Storage extent area        */
; 1387 : S64     stglen;                        /* Storage extent area length */
; 1388 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1389 : 
; 1390 :     /* Ry contains the subcode */
; 1391 :     switch(regs->GR_L(r2))

  00011	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00026	83 7c 24 24 00	 cmp	 DWORD PTR tv69[rsp], 0
  0002b	74 2d		 je	 SHORT $LN4@z900_vm_in
  0002d	83 7c 24 24 04	 cmp	 DWORD PTR tv69[rsp], 4
  00032	74 68		 je	 SHORT $LN6@z900_vm_in
  00034	83 7c 24 24 08	 cmp	 DWORD PTR tv69[rsp], 8
  00039	0f 84 c8 00 00
	00		 je	 $LN9@z900_vm_in
  0003f	83 7c 24 24 0c	 cmp	 DWORD PTR tv69[rsp], 12
  00044	0f 84 94 01 00
	00		 je	 $LN14@z900_vm_in
  0004a	83 7c 24 24 10	 cmp	 DWORD PTR tv69[rsp], 16
  0004f	0f 84 ca 01 00
	00		 je	 $LN15@z900_vm_in
  00055	e9 09 03 00 00	 jmp	 $LN19@z900_vm_in
$LN4@z900_vm_in:

; 1392 :     {
; 1393 :     case 0x00000000: /* Highest addressable byte */
; 1394 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1395 : 
; 1396 :         /* Program check if running in z/Architecture mode and */
; 1397 :         /* 64-bit addressing is being used.                    */
; 1398 :         if (regs->psw.amode64)

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00065	83 e0 01	 and	 eax, 1
  00068	85 c0		 test	 eax, eax
  0006a	74 0f		 je	 SHORT $LN5@z900_vm_in

; 1399 :         {
; 1400 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0006c	ba 06 00 00 00	 mov	 edx, 6
  00071	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	e8 00 00 00 00	 call	 z900_program_interrupt
$LN5@z900_vm_in:

; 1401 :         }
; 1402 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1403 :         regs->GR_L(r1) = regs->mainlim; /* provide highest addressable byte */

  0007b	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00080	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	8b 92 58 08 00
	00		 mov	 edx, DWORD PTR [rdx+2136]
  00090	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1404 :         return;

  00097	e9 d6 02 00 00	 jmp	 $LN1@z900_vm_in
$LN6@z900_vm_in:

; 1405 : 
; 1406 :     case 0x00000004: /* Provide BYUSER ID value */
; 1407 : 
; 1408 :         /* Program check if Rx and Ry are the same registers or        */
; 1409 :         /* or Ry is not an even register or the address provided       */
; 1410 :         /* in Rx is not on a doubleword boundary or if running         */
; 1411 :         /* in z/Architecture mode and 64-bit addressing is being used. */
; 1412 :         if ( r1 == r2 || r2 & 0x1 || regs->GR_L(r1) & 0x7
; 1413 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1414 :              || (regs->psw.amode64)

  0009c	8b 44 24 68	 mov	 eax, DWORD PTR r2$[rsp]
  000a0	39 44 24 60	 cmp	 DWORD PTR r1$[rsp], eax
  000a4	74 35		 je	 SHORT $LN8@z900_vm_in
  000a6	8b 44 24 68	 mov	 eax, DWORD PTR r2$[rsp]
  000aa	83 e0 01	 and	 eax, 1
  000ad	85 c0		 test	 eax, eax
  000af	75 2a		 jne	 SHORT $LN8@z900_vm_in
  000b1	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c2	83 e0 07	 and	 eax, 7
  000c5	85 c0		 test	 eax, eax
  000c7	75 12		 jne	 SHORT $LN8@z900_vm_in
  000c9	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d4	83 e0 01	 and	 eax, 1
  000d7	85 c0		 test	 eax, eax
  000d9	74 0f		 je	 SHORT $LN7@z900_vm_in
$LN8@z900_vm_in:

; 1415 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1416 :            )
; 1417 :         {
; 1418 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000db	ba 06 00 00 00	 mov	 edx, 6
  000e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_vm_in:

; 1419 :         }
; 1420 :         regs->GR_L(r2+1)=0x4; /* Indicate no BYUSER ID for Hercules */

  000ea	8b 44 24 68	 mov	 eax, DWORD PTR r2$[rsp]
  000ee	ff c0		 inc	 eax
  000f0	48 98		 cdqe
  000f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1421 :         return;

  00102	e9 6b 02 00 00	 jmp	 $LN1@z900_vm_in
$LN9@z900_vm_in:

; 1422 : 
; 1423 :     case 0x00000008: /* Return number of lines per page */
; 1424 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1425 : 
; 1426 :         /* Program check if running in z/Architecture mode and */
; 1427 :         /* 64-bit addressing is being used.                    */
; 1428 :         if (regs->psw.amode64)

  00107	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00112	83 e0 01	 and	 eax, 1
  00115	85 c0		 test	 eax, eax
  00117	74 0f		 je	 SHORT $LN10@z900_vm_in

; 1429 :         {
; 1430 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00119	ba 06 00 00 00	 mov	 edx, 6
  0011e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_vm_in:

; 1431 :         }
; 1432 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1433 : 
; 1434 :         /* Get the device number from the Rx register */
; 1435 :         devnum=regs->GR_LHL(r1);

  00128	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  0013a	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 1436 : 
; 1437 :         /* Locate the device block */
; 1438 :         dev = find_device_by_devnum(0,devnum);

  0013f	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  00144	33 c9		 xor	 ecx, ecx
  00146	e8 00 00 00 00	 call	 find_device_by_devnum
  0014b	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 1439 : 
; 1440 :         /* Set 0 lines per page for a valid printer or console (meaning SPOOL is OFF) */
; 1441 :         if (dev != NULL &&

  00150	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00156	74 6c		 je	 SHORT $LN11@z900_vm_in
  00158	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0015d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00161	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00166	74 30		 je	 SHORT $LN13@z900_vm_in
  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0016d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00171	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00176	74 20		 je	 SHORT $LN13@z900_vm_in
  00178	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0017d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00181	3d 52 10 00 00	 cmp	 eax, 4178		; 00001052H
  00186	74 10		 je	 SHORT $LN13@z900_vm_in
  00188	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0018d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00191	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00196	75 2c		 jne	 SHORT $LN11@z900_vm_in
$LN13@z900_vm_in:

; 1442 :               (dev->devtype == 0x1403 ||
; 1443 :                dev->devtype == 0x3211 ||
; 1444 :                dev->devtype == 0x1052 ||
; 1445 :                dev->devtype == 0x3215 )
; 1446 :             )
; 1447 :         {
; 1448 :            regs->GR_L(r1) = 0; /* Set zero lines per page */

  00198	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1449 :            regs->GR_L(r2) = 0; /* Set return code to indicate a valid device */

  001ad	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1450 :         }

  001c2	eb 15		 jmp	 SHORT $LN12@z900_vm_in
$LN11@z900_vm_in:

; 1451 :         else
; 1452 :         {
; 1453 :            regs->GR_L(r2) = 4; /* Set return code to indicate an invalid device */

  001c4	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  001c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN12@z900_vm_in:

; 1454 :         }
; 1455 :         return;

  001d9	e9 94 01 00 00	 jmp	 $LN1@z900_vm_in
$LN14@z900_vm_in:

; 1456 : 
; 1457 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1458 :     case 0x0000000C: /* Return highest addressable byte for z/Architecture machine */
; 1459 :          regs->GR_G(r1) = regs->mainlim;

  001de	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  001ed	48 8b 92 58 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2136]
  001f4	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1460 :          regs->GR_G(r2) = regs->mainlim;

  001fc	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00201	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00206	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0020b	48 8b 92 58 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2136]
  00212	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1461 :          return;

  0021a	e9 53 01 00 00	 jmp	 $LN1@z900_vm_in
$LN15@z900_vm_in:

; 1462 : 
; 1463 :     case 0x00000010: /* Set storage extent */
; 1464 : 
; 1465 :          /* Obtain the storage extent area real address from Rx */
; 1466 :          /* and its length from Rx+1                            */
; 1467 :          stgarea=regs->GR_G(r1);

  0021f	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00224	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00231	48 89 44 24 28	 mov	 QWORD PTR stgarea$[rsp], rax

; 1468 :          stglen=regs->GR_G(r1+1); /* Length is treated as a signed value */

  00236	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  0023a	ff c0		 inc	 eax
  0023c	48 98		 cdqe
  0023e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0024b	48 89 44 24 38	 mov	 QWORD PTR stglen$[rsp], rax

; 1469 : 
; 1470 :          /* Program check if Rx is not an even register or the address */
; 1471 :          /* provided in Rx is not on a quadword boundary or the length */
; 1472 :          /* provided in Rx+1 is not positive or not a multiple of 16   */
; 1473 :          if ( r1 & 1 || stgarea & 0xF || stglen <= 0 || stglen & 0xF )

  00250	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  00254	83 e0 01	 and	 eax, 1
  00257	85 c0		 test	 eax, eax
  00259	75 24		 jne	 SHORT $LN17@z900_vm_in
  0025b	48 8b 44 24 28	 mov	 rax, QWORD PTR stgarea$[rsp]
  00260	48 83 e0 0f	 and	 rax, 15
  00264	48 85 c0	 test	 rax, rax
  00267	75 16		 jne	 SHORT $LN17@z900_vm_in
  00269	48 83 7c 24 38
	00		 cmp	 QWORD PTR stglen$[rsp], 0
  0026f	7e 0e		 jle	 SHORT $LN17@z900_vm_in
  00271	48 8b 44 24 38	 mov	 rax, QWORD PTR stglen$[rsp]
  00276	48 83 e0 0f	 and	 rax, 15
  0027a	48 85 c0	 test	 rax, rax
  0027d	74 0f		 je	 SHORT $LN16@z900_vm_in
$LN17@z900_vm_in:

; 1474 :          {
; 1475 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0027f	ba 06 00 00 00	 mov	 edx, 6
  00284	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	e8 00 00 00 00	 call	 z900_program_interrupt
$LN16@z900_vm_in:

; 1476 :          }
; 1477 : 
; 1478 :          /* Convert real address to absolute address */
; 1479 :          stgarea=APPLY_PREFIXING(stgarea,regs->PX );

  0028e	48 8b 44 24 28	 mov	 rax, QWORD PTR stgarea$[rsp]
  00293	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00299	48 85 c0	 test	 rax, rax
  0029c	74 22		 je	 SHORT $LN21@z900_vm_in
  0029e	48 8b 44 24 28	 mov	 rax, QWORD PTR stgarea$[rsp]
  002a3	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  002a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  002ae	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  002b2	74 0c		 je	 SHORT $LN21@z900_vm_in
  002b4	48 8b 44 24 28	 mov	 rax, QWORD PTR stgarea$[rsp]
  002b9	48 89 44 24 40	 mov	 QWORD PTR tv214[rsp], rax
  002be	eb 19		 jmp	 SHORT $LN22@z900_vm_in
$LN21@z900_vm_in:
  002c0	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002c5	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR stgarea$[rsp]
  002ce	48 33 c8	 xor	 rcx, rax
  002d1	48 8b c1	 mov	 rax, rcx
  002d4	48 89 44 24 40	 mov	 QWORD PTR tv214[rsp], rax
$LN22@z900_vm_in:
  002d9	48 8b 44 24 40	 mov	 rax, QWORD PTR tv214[rsp]
  002de	48 89 44 24 28	 mov	 QWORD PTR stgarea$[rsp], rax

; 1480 : 
; 1481 :          /* Check to ensure extent information can be stored */
; 1482 :          if (stgarea > regs->mainlim - 16)

  002e3	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002ef	48 83 e8 10	 sub	 rax, 16
  002f3	48 39 44 24 28	 cmp	 QWORD PTR stgarea$[rsp], rax
  002f8	76 15		 jbe	 SHORT $LN18@z900_vm_in

; 1483 :          {
; 1484 :              regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  002fa	ba 05 00 00 00	 mov	 edx, 5
  002ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00309	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_vm_in:

; 1485 :          }
; 1486 :          /* Set start of storage extent to zero */
; 1487 :          ARCH_DEP(store_doubleword_absolute)(0,stgarea,regs);

  0030f	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00314	48 8b 54 24 28	 mov	 rdx, QWORD PTR stgarea$[rsp]
  00319	33 c9		 xor	 ecx, ecx
  0031b	e8 00 00 00 00	 call	 z900_store_doubleword_absolute

; 1488 :          /* Set end of storage extent to last addressable byte of main storage */
; 1489 :          ARCH_DEP(store_doubleword_absolute)(regs->mainlim,stgarea+8,regs);

  00320	48 8b 44 24 28	 mov	 rax, QWORD PTR stgarea$[rsp]
  00325	48 83 c0 08	 add	 rax, 8
  00329	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  0032e	48 8b d0	 mov	 rdx, rax
  00331	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00336	48 8b 88 58 08
	00 00		 mov	 rcx, QWORD PTR [rax+2136]
  0033d	e8 00 00 00 00	 call	 z900_store_doubleword_absolute

; 1490 :          /* Set number of extents to 1 in Ry */
; 1491 :          regs->GR_G(r2) = 1;

  00342	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00347	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	48 c7 84 c1 80
	02 00 00 01 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+640], 1

; 1492 :          /* Indicate all extents returned */
; 1493 :          regs->psw.cc = 0;

  00358	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0035d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1494 :          return;

  00361	eb 0f		 jmp	 SHORT $LN1@z900_vm_in
$LN19@z900_vm_in:

; 1495 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1496 : 
; 1497 :     default: /* Invalid subcode */
; 1498 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00363	ba 06 00 00 00	 mov	 edx, 6
  00368	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0036d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN1@z900_vm_in:

; 1499 :     }
; 1500 : }

  00372	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00376	c3		 ret	 0
z900_vm_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
func$ = 32
skey$ = 33
refchg$1 = 34
abs$ = 36
tv134 = 40
end$ = 44
start$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
z900_diag_ppagerel PROC

; 1614 : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1615 : U32     abs, start, end;                /* Absolute frame addresses  */
; 1616 : BYTE    skey;                           /* Specified storage key     */
; 1617 : BYTE    func;                           /* Function code...          */
; 1618 : #define DIAG214_EPR             0x00    /* Establish pending release */
; 1619 : #define DIAG214_CPR             0x01    /* Cancel pending release    */
; 1620 : #define DIAG214_CAPR            0x02    /* Cancel all pending release*/
; 1621 : #define DIAG214_CPRV            0x03    /* Cancel and validate       */
; 1622 : 
; 1623 :     /* Program check if R1 is not an even-numbered register */
; 1624 :     if (r1 & 1)

  00011	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	74 0f		 je	 SHORT $LN7@z900_diag_

; 1625 :     {
; 1626 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0001c	ba 06 00 00 00	 mov	 edx, 6
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_diag_:

; 1627 :     }
; 1628 : 
; 1629 :     /* Extract the function code from R1+1 register bits 24-31 */
; 1630 :     func = regs->GR_L(r1+1) & 0xFF;

  0002b	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0002f	ff c0		 inc	 eax
  00031	48 98		 cdqe
  00033	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	88 44 24 20	 mov	 BYTE PTR func$[rsp], al

; 1631 : 
; 1632 :     /* Extract the start/end addresses from R1 and R1+1 registers */
; 1633 :     start = regs->GR_L(r1) & STORAGE_KEY_PAGEMASK;

  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0005f	89 44 24 30	 mov	 DWORD PTR start$[rsp], eax

; 1634 :     end = regs->GR_L(r1+1) & STORAGE_KEY_PAGEMASK;

  00063	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00067	ff c0		 inc	 eax
  00069	48 98		 cdqe
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0007d	89 44 24 2c	 mov	 DWORD PTR end$[rsp], eax

; 1635 : 
; 1636 :     /* Validate start/end addresses if function is not CAPR */
; 1637 :     if (func != DIAG214_CAPR
; 1638 :         && (start > end || end > regs->mainlim))

  00081	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  00086	83 f8 02	 cmp	 eax, 2
  00089	74 2b		 je	 SHORT $LN8@z900_diag_
  0008b	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  0008f	39 44 24 30	 cmp	 DWORD PTR start$[rsp], eax
  00093	77 12		 ja	 SHORT $LN9@z900_diag_
  00095	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000a5	76 0f		 jbe	 SHORT $LN8@z900_diag_
$LN9@z900_diag_:

; 1639 :     {
; 1640 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000a7	ba 06 00 00 00	 mov	 edx, 6
  000ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN8@z900_diag_:

; 1641 :     }
; 1642 : 
; 1643 :     /* Process depending on function code */
; 1644 :     switch (func)

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  000bb	88 44 24 28	 mov	 BYTE PTR tv134[rsp], al
  000bf	80 7c 24 28 00	 cmp	 BYTE PTR tv134[rsp], 0
  000c4	74 1b		 je	 SHORT $LN10@z900_diag_
  000c6	80 7c 24 28 01	 cmp	 BYTE PTR tv134[rsp], 1
  000cb	74 19		 je	 SHORT $LN11@z900_diag_
  000cd	80 7c 24 28 02	 cmp	 BYTE PTR tv134[rsp], 2
  000d2	0f 84 83 00 00
	00		 je	 $LN14@z900_diag_
  000d8	80 7c 24 28 03	 cmp	 BYTE PTR tv134[rsp], 3
  000dd	74 07		 je	 SHORT $LN12@z900_diag_
  000df	eb 7c		 jmp	 SHORT $LN15@z900_diag_
$LN10@z900_diag_:

; 1645 :     {
; 1646 :     case DIAG214_EPR:  /* Establish Pending Release */
; 1647 :         break;

  000e1	e9 86 00 00 00	 jmp	 $LN2@z900_diag_
$LN11@z900_diag_:
$LN12@z900_diag_:

; 1648 : 
; 1649 :     case DIAG214_CPR:  /* Cancel Pending Release */
; 1650 :     case DIAG214_CPRV: /* Cancel Pending Release and Validate */
; 1651 : 
; 1652 :         /* Do not set storage keys if R2 is register 0 */
; 1653 :         if (r2 == 0) break;

  000e6	83 7c 24 58 00	 cmp	 DWORD PTR r2$[rsp], 0
  000eb	75 02		 jne	 SHORT $LN13@z900_diag_
  000ed	eb 7d		 jmp	 SHORT $LN2@z900_diag_
$LN13@z900_diag_:

; 1654 : 
; 1655 :         /* Obtain key from R2 register bits 24-28 */
; 1656 :         skey = regs->GR_L(r2) & (STORKEY_KEY | STORKEY_FETCH);

  000ef	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00100	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00105	88 44 24 21	 mov	 BYTE PTR skey$[rsp], al

; 1657 : 
; 1658 :         /* Set storage key for each frame within specified range
; 1659 :            without changing existing reference and change bits.
; 1660 :         */
; 1661 :         for (abs = start; abs <= end; abs += STORAGE_KEY_PAGESIZE)

  00109	8b 44 24 30	 mov	 eax, DWORD PTR start$[rsp]
  0010d	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
  00111	eb 0d		 jmp	 SHORT $LN6@z900_diag_
$LN4@z900_diag_:
  00113	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  00117	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0011c	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
$LN6@z900_diag_:
  00120	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00124	39 44 24 24	 cmp	 DWORD PTR abs$[rsp], eax
  00128	77 2f		 ja	 SHORT $LN5@z900_diag_

; 1662 :         {
; 1663 :             BYTE refchg = ARCH_DEP( get_storage_key )( abs ) & (STORKEY_REF | STORKEY_CHANGE);

  0012a	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  0012e	8b c8		 mov	 ecx, eax
  00130	e8 00 00 00 00	 call	 z900_get_storage_key
  00135	0f b6 c0	 movzx	 eax, al
  00138	83 e0 06	 and	 eax, 6
  0013b	88 44 24 22	 mov	 BYTE PTR refchg$1[rsp], al

; 1664 :             ARCH_DEP( put_storage_key )( abs, skey | refchg );

  0013f	0f b6 44 24 21	 movzx	 eax, BYTE PTR skey$[rsp]
  00144	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR refchg$1[rsp]
  00149	0b c1		 or	 eax, ecx
  0014b	8b 4c 24 24	 mov	 ecx, DWORD PTR abs$[rsp]
  0014f	0f b6 d0	 movzx	 edx, al
  00152	e8 00 00 00 00	 call	 z900_put_storage_key

; 1665 :         }

  00157	eb ba		 jmp	 SHORT $LN4@z900_diag_
$LN5@z900_diag_:

; 1666 : 
; 1667 :         break;

  00159	eb 11		 jmp	 SHORT $LN2@z900_diag_
$LN14@z900_diag_:

; 1668 : 
; 1669 :     case DIAG214_CAPR:  /* Cancel All Pending Releases */
; 1670 :         break;

  0015b	eb 0f		 jmp	 SHORT $LN2@z900_diag_
$LN15@z900_diag_:

; 1671 : 
; 1672 :     default:            /* Invalid function code */
; 1673 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015d	ba 06 00 00 00	 mov	 edx, 6
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	e8 00 00 00 00	 call	 z900_program_interrupt
$LN2@z900_diag_:

; 1674 :     } /* end switch(func) */
; 1675 : 
; 1676 :     /* Return condition code zero */
; 1677 :     return 0;

  0016c	33 c0		 xor	 eax, eax

; 1678 : 
; 1679 : } /* end function diag_ppagerel */

  0016e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00172	c3		 ret	 0
z900_diag_ppagerel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
cmdflags$ = 80
i$ = 84
resplen$1 = 88
rem$2 = 92
chunk$3 = 96
cmdlen$ = 100
maxrlen$ = 104
resp$ = 112
cc$ = 120
tv251 = 124
freeresp$ = 128
cmdaddr$ = 132
respadr$ = 136
$T4 = 144
tv182 = 152
tv208 = 160
tv266 = 168
cmd$ = 176
msg$ = 448
__$ArrayPad$ = 704
r1$ = 736
r2$ = 744
regs$ = 752
z900_cpcmd_call PROC

; 1057 : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1058 : U32     i;                              /* Array subscript           */
; 1059 : U32     cc;                             /* Condition code            */
; 1060 : U32     cmdaddr;                        /* Address of command string */
; 1061 : U32     cmdlen;                         /* Length of command string  */
; 1062 : U32     respadr;                        /* Address of response buffer*/
; 1063 : U32     maxrlen;                        /* Length of response buffer */
; 1064 : BYTE    cmdflags;                       /* Command flags             */
; 1065 : 
; 1066 : #define CMDFLAGS_REJPASSW     0x80      /* Reject password in command*/
; 1067 : #define CMDFLAGS_RESPONSE     0x40      /* Return response in buffer */
; 1068 : #define CMDFLAGS_REQPASSW     0x20      /* Prompt for password       */
; 1069 : #define CMDFLAGS_RESERVED     0x1F      /* Reserved bits, must be 0  */
; 1070 : 
; 1071 : char    msg[256];                       /* Message work area         */
; 1072 : char    cmd[256+1];                     /* Input command +1 for NULL */
; 1073 : char*   resp;                           /* Output response           */
; 1074 : int     freeresp;                       /* Flag to free resp         */
; 1075 : 
; 1076 :     /* Obtain address of command from R1 register
; 1077 :        and command length and flags from R2 register
; 1078 :     */
; 1079 :     cmdaddr  = regs->GR_L( r1 );

  00026	48 63 84 24 e0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 84 24 84 00
	00 00		 mov	 DWORD PTR cmdaddr$[rsp], eax

; 1080 :     cmdflags = regs->GR_L( r2 ) >> 24;

  00044	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0004c	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0005b	c1 e8 18	 shr	 eax, 24
  0005e	88 44 24 50	 mov	 BYTE PTR cmdflags$[rsp], al

; 1081 :     cmdlen   = regs->GR_L( r2 ) & 0x00FFFFFF;

  00062	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0006a	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0007e	89 44 24 64	 mov	 DWORD PTR cmdlen$[rsp], eax

; 1082 : 
; 1083 :     /* Program check if invalid flags, or if command string
; 1084 :        is too long, or if response buffer is specified and
; 1085 :        registers are consecutive or either register specifies
; 1086 :        register 15
; 1087 :     */
; 1088 :     if (0
; 1089 :         || (cmdflags & CMDFLAGS_RESERVED)
; 1090 :         || (cmdlen > (sizeof(cmd)-1))   // (room for NULL terminator!)
; 1091 :         || (1

  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 69		 jne	 SHORT $LN15@z900_cpcmd
  00088	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  0008d	83 e0 1f	 and	 eax, 31
  00090	85 c0		 test	 eax, eax
  00092	75 5d		 jne	 SHORT $LN15@z900_cpcmd
  00094	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  00098	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  0009e	77 51		 ja	 SHORT $LN15@z900_cpcmd
  000a0	33 c0		 xor	 eax, eax
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	74 5c		 je	 SHORT $LN14@z900_cpcmd
  000a7	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  000ac	83 e0 40	 and	 eax, 64			; 00000040H
  000af	85 c0		 test	 eax, eax
  000b1	74 50		 je	 SHORT $LN14@z900_cpcmd
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 38		 jne	 SHORT $LN16@z900_cpcmd
  000b9	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000c0	ff c0		 inc	 eax
  000c2	39 84 24 e0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  000c9	74 26		 je	 SHORT $LN16@z900_cpcmd
  000cb	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	39 84 24 e8 02
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  000db	74 14		 je	 SHORT $LN16@z900_cpcmd
  000dd	83 bc 24 e0 02
	00 00 0f	 cmp	 DWORD PTR r1$[rsp], 15
  000e5	74 0a		 je	 SHORT $LN16@z900_cpcmd
  000e7	83 bc 24 e8 02
	00 00 0f	 cmp	 DWORD PTR r2$[rsp], 15
  000ef	75 12		 jne	 SHORT $LN14@z900_cpcmd
$LN16@z900_cpcmd:
$LN15@z900_cpcmd:

; 1092 :             && (cmdflags & CMDFLAGS_RESPONSE)
; 1093 :             && (0
; 1094 :                 || r1 == r2 + 1
; 1095 :                 || r2 == r1 + 1
; 1096 :                 || r1 == 15
; 1097 :                 || r2 == 15
; 1098 :                )
; 1099 :            )
; 1100 :     )
; 1101 :     {
; 1102 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000f1	ba 06 00 00 00	 mov	 edx, 6
  000f6	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_cpcmd:

; 1103 :     }
; 1104 : 
; 1105 :     /* Put machine into stopped state if command length is zero */
; 1106 :     if (cmdlen == 0)

  00103	83 7c 24 64 00	 cmp	 DWORD PTR cmdlen$[rsp], 0
  00108	75 52		 jne	 SHORT $LN17@z900_cpcmd

; 1107 :     {
; 1108 :         regs->opinterv = 0;

  0010a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00118	83 e0 ef	 and	 eax, -17		; ffffffefH
  0011b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1109 :         regs->cpustate = CPUSTATE_STOPPED;

  00129	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN4@z900_cpcmd:

; 1110 :         ON_IC_INTERRUPT( regs );

  00135	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00140	0f ba e8 1f	 bts	 eax, 31
  00144	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 e0		 jne	 SHORT $LN4@z900_cpcmd

; 1111 :         return 0;

  00155	33 c0		 xor	 eax, eax
  00157	e9 a9 04 00 00	 jmp	 $LN1@z900_cpcmd
$LN17@z900_cpcmd:

; 1112 :     }
; 1113 : 
; 1114 :     /* Obtain the EBCDIC command string from guest storage */
; 1115 :     ARCH_DEP( vfetchc )( cmd, cmdlen-1, cmdaddr, USE_REAL_ADDR, regs );

  0015c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR cmdaddr$[rsp]
  00163	8b 4c 24 64	 mov	 ecx, DWORD PTR cmdlen$[rsp]
  00167	ff c9		 dec	 ecx
  00169	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00176	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0017c	44 8b c0	 mov	 r8d, eax
  0017f	0f b6 d1	 movzx	 edx, cl
  00182	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0018a	e8 00 00 00 00	 call	 z900_vfetchc

; 1116 : 
; 1117 :     /* Translate guest EBCDIC command to host ASCII format */
; 1118 :     for (i=0; i < cmdlen; i++)

  0018f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00197	eb 0a		 jmp	 SHORT $LN7@z900_cpcmd
$LN5@z900_cpcmd:
  00199	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0019d	ff c0		 inc	 eax
  0019f	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_cpcmd:
  001a3	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  001a7	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  001ab	73 1f		 jae	 SHORT $LN6@z900_cpcmd

; 1119 :         cmd[i] = guest_to_host( cmd[i] );

  001ad	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001b1	0f b6 8c 04 b0
	00 00 00	 movzx	 ecx, BYTE PTR cmd$[rsp+rax]
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  001bf	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  001c3	88 84 0c b0 00
	00 00		 mov	 BYTE PTR cmd$[rsp+rcx], al
  001ca	eb cd		 jmp	 SHORT $LN5@z900_cpcmd
$LN6@z900_cpcmd:

; 1120 :     cmd[i] = 0; // (null terminate!)

  001cc	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001d0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  001d8	48 81 bc 24 90
	00 00 00 01 01
	00 00		 cmp	 QWORD PTR $T4[rsp], 257	; 00000101H
  001e4	73 02		 jae	 SHORT $LN33@z900_cpcmd
  001e6	eb 05		 jmp	 SHORT $LN34@z900_cpcmd
$LN33@z900_cpcmd:
  001e8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@z900_cpcmd:
  001ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  001f5	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR cmd$[rsp+rax], 0

; 1121 : 
; 1122 :     /* Execute the Hercules emulator (hypervisor) command */
; 1123 :     resp = "";

  001fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193890
  00204	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1124 :     freeresp = 0;

  00209	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 0

; 1125 : 
; 1126 : #if !defined( FEATURE_HERCULES_DIAGCALLS )
; 1127 :         // "Hercules-specific DIAG instructions support not included in engine build"
; 1128 :         MSGBUF( msg, MSG( HHC01954, "E" ));
; 1129 :         resp = &msg[0];
; 1130 : #else
; 1131 :     /************************************************************
; 1132 :      *  SECURITY CHECK: Reject attempts to issue "shell" type
; 1133 :      *  commands unless specifically allowed by SHCMDOPT option.
; 1134 :      ************************************************************/
; 1135 :     if (1
; 1136 :         && is_shell_command( cmd )
; 1137 :         && (sysblk.shcmdopt & (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8))

  00214	33 c0		 xor	 eax, eax
  00216	83 f8 01	 cmp	 eax, 1
  00219	74 66		 je	 SHORT $LN18@z900_cpcmd
  0021b	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00223	e8 00 00 00 00	 call	 is_shell_command
  00228	0f b6 c0	 movzx	 eax, al
  0022b	85 c0		 test	 eax, eax
  0022d	74 52		 je	 SHORT $LN18@z900_cpcmd
  0022f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00236	0f b6 80 2f 11
	00 00		 movzx	 eax, BYTE PTR [rax+4399]
  0023d	83 e0 03	 and	 eax, 3
  00240	83 f8 03	 cmp	 eax, 3
  00243	74 3c		 je	 SHORT $LN18@z900_cpcmd

; 1138 :                            != (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8)
; 1139 :     )
; 1140 :     {
; 1141 :         // "DIAG8 access to shell disallowed by SHCMDOPT setting"
; 1142 :         MSGBUF( msg, MSG( HHC01953, "E" ));

  00245	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193893
  0024c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193894
  00253	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00258	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR msg$[rsp]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1143 :         resp = &msg[0];

  00266	b8 01 00 00 00	 mov	 eax, 1
  0026b	48 6b c0 00	 imul	 rax, rax, 0
  0026f	48 8d 84 04 c0
	01 00 00	 lea	 rax, QWORD PTR msg$[rsp+rax]
  00277	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1144 :     }

  0027c	e9 7e 01 00 00	 jmp	 $LN19@z900_cpcmd
$LN18@z900_cpcmd:

; 1145 :     else
; 1146 :     {
; 1147 :         /* It's either not a "shell" type command or the
; 1148 :            SHCMDOPT option is allowing them to be issued
; 1149 :            so we can go ahead and execute the command. */
; 1150 : 
; 1151 :         // "%s guest issued panel command: %s"
; 1152 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  00281	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00288	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0028f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00294	85 c0		 test	 eax, eax
  00296	74 7d		 je	 SHORT $LN20@z900_cpcmd

; 1153 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Starting", RTRIM( cmd ));

  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193896
  0029f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  002ad	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv182[rsp], rax
  002b5	b9 01 00 00 00	 mov	 ecx, 1
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv182[rsp]
  002c8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193897
  002d4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193898
  002e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193899
  002ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f6	41 b9 02 00 00
	00		 mov	 r9d, 2
  002fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193900
  00303	ba 81 04 00 00	 mov	 edx, 1153		; 00000481H
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193901
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@z900_cpcmd:

; 1154 : 
; 1155 :         /* Issue the command and capture the response */
; 1156 :         if (cmdflags & CMDFLAGS_RESPONSE)

  00315	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  0031a	83 e0 40	 and	 eax, 64			; 00000040H
  0031d	85 c0		 test	 eax, eax
  0031f	74 39		 je	 SHORT $LN21@z900_cpcmd

; 1157 :         {
; 1158 :             panel_command_capture( cmd, &resp, false );

  00321	45 33 c0	 xor	 r8d, r8d
  00324	48 8d 54 24 70	 lea	 rdx, QWORD PTR resp$[rsp]
  00329	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_panel_command_capture

; 1159 : 
; 1160 :             if (resp)

  00337	48 83 7c 24 70
	00		 cmp	 QWORD PTR resp$[rsp], 0
  0033d	74 0d		 je	 SHORT $LN23@z900_cpcmd

; 1161 :                 freeresp = 1;

  0033f	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 1
  0034a	eb 0c		 jmp	 SHORT $LN24@z900_cpcmd
$LN23@z900_cpcmd:

; 1162 :             else
; 1163 :                 resp = "";

  0034c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193906
  00353	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax
$LN24@z900_cpcmd:

; 1164 :         }

  00358	eb 11		 jmp	 SHORT $LN22@z900_cpcmd
$LN21@z900_cpcmd:

; 1165 :         else /* Issue command normally (no response wanted) */
; 1166 :         {
; 1167 :             panel_command( cmd );

  0035a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00362	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  00369	ff 10		 call	 QWORD PTR [rax]
$LN22@z900_cpcmd:

; 1168 :         }
; 1169 : 
; 1170 :         // "%s guest issued panel command: %s"
; 1171 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  0036b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00372	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00379	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0037e	85 c0		 test	 eax, eax
  00380	74 7d		 je	 SHORT $LN25@z900_cpcmd

; 1172 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Completed", RTRIM( cmd ));

  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193908
  00389	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  00397	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv208[rsp], rax
  0039f	b9 01 00 00 00	 mov	 ecx, 1
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003aa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv208[rsp]
  003b2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193909
  003be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193910
  003ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193911
  003d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	41 b9 02 00 00
	00		 mov	 r9d, 2
  003e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193912
  003ed	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193913
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@z900_cpcmd:
$LN19@z900_cpcmd:

; 1173 :     }
; 1174 : #endif // defined( FEATURE_HERCULES_DIAGCALLS )
; 1175 : 
; 1176 :     /* Copy response to guest storage if response requested */
; 1177 :     if (cmdflags & CMDFLAGS_RESPONSE)

  003ff	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  00404	83 e0 40	 and	 eax, 64			; 00000040H
  00407	85 c0		 test	 eax, eax
  00409	0f 84 ba 01 00
	00		 je	 $LN26@z900_cpcmd

; 1178 :     {
; 1179 :         U32 resplen, chunk, rem;
; 1180 : 
; 1181 :         /* Translate host ASCII response to guest EBCDIC format */
; 1182 :         for (i=0, resplen = (U32) strlen( resp ); i < resplen; i++)

  0040f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00417	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  0041c	e8 00 00 00 00	 call	 strlen
  00421	89 44 24 58	 mov	 DWORD PTR resplen$1[rsp], eax
  00425	eb 0a		 jmp	 SHORT $LN10@z900_cpcmd
$LN8@z900_cpcmd:
  00427	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0042b	ff c0		 inc	 eax
  0042d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_cpcmd:
  00431	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  00435	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00439	73 21		 jae	 SHORT $LN9@z900_cpcmd

; 1183 :             resp[i] = host_to_guest( resp[i] );

  0043b	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0043f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  00444	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00448	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0044e	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00452	48 8b 54 24 70	 mov	 rdx, QWORD PTR resp$[rsp]
  00457	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0045a	eb cb		 jmp	 SHORT $LN8@z900_cpcmd
$LN9@z900_cpcmd:

; 1184 : 
; 1185 :         /* Retrieve guest's response parameters */
; 1186 :         respadr = regs->GR_L( r1+1 );

  0045c	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00463	ff c0		 inc	 eax
  00465	48 98		 cdqe
  00467	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00476	89 84 24 88 00
	00 00		 mov	 DWORD PTR respadr$[rsp], eax

; 1187 :         maxrlen = regs->GR_L( r2+1 );

  0047d	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00484	ff c0		 inc	 eax
  00486	48 98		 cdqe
  00488	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00490	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00497	89 44 24 68	 mov	 DWORD PTR maxrlen$[rsp], eax

; 1188 : 
; 1189 :         /* Copy the response to guest storage in 256 byte chunks */
; 1190 :         for (i=0, chunk=256, rem = MIN( resplen, maxrlen ); rem; rem -= chunk, i += chunk)

  0049b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004a3	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR chunk$3[rsp], 256 ; 00000100H
  004ab	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004af	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  004b3	73 0a		 jae	 SHORT $LN35@z900_cpcmd
  004b5	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  004b9	89 44 24 7c	 mov	 DWORD PTR tv251[rsp], eax
  004bd	eb 08		 jmp	 SHORT $LN36@z900_cpcmd
$LN35@z900_cpcmd:
  004bf	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004c3	89 44 24 7c	 mov	 DWORD PTR tv251[rsp], eax
$LN36@z900_cpcmd:
  004c7	8b 44 24 7c	 mov	 eax, DWORD PTR tv251[rsp]
  004cb	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004cf	eb 20		 jmp	 SHORT $LN13@z900_cpcmd
$LN11@z900_cpcmd:
  004d1	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004d5	8b 4c 24 5c	 mov	 ecx, DWORD PTR rem$2[rsp]
  004d9	2b c8		 sub	 ecx, eax
  004db	8b c1		 mov	 eax, ecx
  004dd	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004e1	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004e5	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  004e9	03 c8		 add	 ecx, eax
  004eb	8b c1		 mov	 eax, ecx
  004ed	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_cpcmd:
  004f1	83 7c 24 5c 00	 cmp	 DWORD PTR rem$2[rsp], 0
  004f6	74 6e		 je	 SHORT $LN12@z900_cpcmd

; 1191 :         {
; 1192 :             if (rem < chunk) chunk = rem;

  004f8	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004fc	39 44 24 5c	 cmp	 DWORD PTR rem$2[rsp], eax
  00500	73 08		 jae	 SHORT $LN28@z900_cpcmd
  00502	8b 44 24 5c	 mov	 eax, DWORD PTR rem$2[rsp]
  00506	89 44 24 60	 mov	 DWORD PTR chunk$3[rsp], eax
$LN28@z900_cpcmd:

; 1193 :             ARCH_DEP( vstorec )( &resp[i], chunk-1, respadr+i, USE_REAL_ADDR, regs );

  0050a	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0050e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR respadr$[rsp]
  00515	03 c8		 add	 ecx, eax
  00517	8b c1		 mov	 eax, ecx
  00519	8b c0		 mov	 eax, eax
  0051b	8b 4c 24 60	 mov	 ecx, DWORD PTR chunk$3[rsp]
  0051f	ff c9		 dec	 ecx
  00521	8b 54 24 54	 mov	 edx, DWORD PTR i$[rsp]
  00525	4c 8b 44 24 70	 mov	 r8, QWORD PTR resp$[rsp]
  0052a	4c 03 c2	 add	 r8, rdx
  0052d	49 8b d0	 mov	 rdx, r8
  00530	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv266[rsp], rdx
  00538	4c 8b 84 24 f0
	02 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00540	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00545	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0054b	44 8b c0	 mov	 r8d, eax
  0054e	0f b6 d1	 movzx	 edx, cl
  00551	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv266[rsp]
  00559	48 8b c8	 mov	 rcx, rax
  0055c	e8 00 00 00 00	 call	 z900_vstorec

; 1194 :         }

  00561	e9 6b ff ff ff	 jmp	 $LN11@z900_cpcmd
$LN12@z900_cpcmd:

; 1195 : 
; 1196 :         /* Update guest response register and set condition code */
; 1197 :         if (resplen <= maxrlen)

  00566	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  0056a	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  0056e	77 28		 ja	 SHORT $LN29@z900_cpcmd

; 1198 :         {
; 1199 :             /* They have the complete response */
; 1200 :             regs->GR_L( r2+1 ) = resplen;

  00570	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00577	ff c0		 inc	 eax
  00579	48 98		 cdqe
  0057b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00583	8b 54 24 58	 mov	 edx, DWORD PTR resplen$1[rsp]
  00587	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1201 :             cc = 0;

  0058e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1202 :         }

  00596	eb 2f		 jmp	 SHORT $LN30@z900_cpcmd
$LN29@z900_cpcmd:

; 1203 :         else
; 1204 :         {
; 1205 :             /* Their response buffer is too small */
; 1206 :             regs->GR_L( r2+1 ) = (resplen - maxrlen);

  00598	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  0059c	8b 4c 24 58	 mov	 ecx, DWORD PTR resplen$1[rsp]
  005a0	2b c8		 sub	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005ab	ff c1		 inc	 ecx
  005ad	48 63 c9	 movsxd	 rcx, ecx
  005b0	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1207 :             cc = 1;

  005bf	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN30@z900_cpcmd:

; 1208 :         }
; 1209 :     }

  005c7	eb 08		 jmp	 SHORT $LN27@z900_cpcmd
$LN26@z900_cpcmd:

; 1210 :     else
; 1211 :         cc = 0;

  005c9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN27@z900_cpcmd:

; 1212 : 
; 1213 :     /* Set R2 register to CP completion code */
; 1214 :     regs->GR_L( r2 ) = 0;

  005d1	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005d9	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e1	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1215 : 
; 1216 :     /* Free memory malloc'ed by panel_command_capture */
; 1217 :     if (freeresp)

  005ec	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR freeresp$[rsp], 0
  005f4	74 0b		 je	 SHORT $LN31@z900_cpcmd

; 1218 :         free( resp );

  005f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN31@z900_cpcmd:

; 1219 : 
; 1220 :     /* Return condition code */
; 1221 :     return cc;

  00601	8b 44 24 78	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@z900_cpcmd:
$LN32@z900_cpcmd:

; 1222 : 
; 1223 : } /* end function cpcmd_call */

  00605	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0060d	48 33 cc	 xor	 rcx, rsp
  00610	e8 00 00 00 00	 call	 __security_check_cookie
  00615	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  0061c	c3		 ret	 0
z900_cpcmd_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
c$ = 48
idlen$ = 52
i$ = 56
tzdiff$ = 60
tv161 = 64
ver$ = 68
idaddr$ = 72
puser$ = 80
tv183 = 88
rel$ = 92
$T1 = 96
$T2 = 104
$T3 = 112
$T4 = 120
buf$ = 128
__$ArrayPad$ = 168
r1$ = 192
r2$ = 200
regs$ = 208
z900_extid_call PROC

; 936  : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 937  : int        i;                           /* Array subscript           */
; 938  : int        ver, rel;                    /* Version and release number*/
; 939  : int        tzdiff;                      /* Time zone differential    */
; 940  : U32        idaddr;                      /* Address of storage operand*/
; 941  : U32        idlen;                       /* Length of storage operand */
; 942  : BYTE       buf[40];                     /* Extended identification   */
; 943  : #if defined( HAVE_GETLOGIN_R )
; 944  :   #if !defined(LOGIN_NAME_MAX)
; 945  :     #define LOGIN_NAME_MAX 100
; 946  :   #endif
; 947  : char       unam[LOGIN_NAME_MAX+1];      /* User name                 */
; 948  : #endif
; 949  : char      *puser;                       /* Pointer to user name      */
; 950  : BYTE       c;                           /* Character work area       */
; 951  : 
; 952  :     /* Load storage operand address from R1 register */
; 953  :     idaddr = regs->GR_L(r1);

  00026	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 44 24 48	 mov	 DWORD PTR idaddr$[rsp], eax

; 954  : 
; 955  :     /* Program check if operand is not on a doubleword boundary */
; 956  :     if (idaddr & 0x00000007)

  00041	8b 44 24 48	 mov	 eax, DWORD PTR idaddr$[rsp]
  00045	83 e0 07	 and	 eax, 7
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN5@z900_extid

; 957  :     {
; 958  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0004c	ba 06 00 00 00	 mov	 edx, 6
  00051	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 z900_program_interrupt
$LN5@z900_extid:

; 959  :     }
; 960  : 
; 961  :     /* Load storage operand length from R2 register */
; 962  :     idlen = regs->GR_L(r2);

  0005e	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00066	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00075	89 44 24 34	 mov	 DWORD PTR idlen$[rsp], eax

; 963  : 
; 964  :     /* Program check if operand length is invalid */
; 965  :     if (idlen < 1)

  00079	83 7c 24 34 01	 cmp	 DWORD PTR idlen$[rsp], 1
  0007e	73 12		 jae	 SHORT $LN6@z900_extid

; 966  :     {
; 967  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00080	ba 06 00 00 00	 mov	 edx, 6
  00085	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_extid:

; 968  :     }
; 969  : 
; 970  :     /* Bytes 0-7 contain the system name ("HERCULES" in EBCDIC) */
; 971  :     get_lparname(buf);

  00092	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0009a	e8 00 00 00 00	 call	 get_lparname

; 972  : 
; 973  :     /* Bytes 8-9 contain the execution environment bits */
; 974  :     buf[8] = 0x00;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 08	 imul	 rax, rax, 8
  000a8	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  000ad	48 83 7c 24 60
	28		 cmp	 QWORD PTR $T1[rsp], 40	; 00000028H
  000b3	73 02		 jae	 SHORT $LN9@z900_extid
  000b5	eb 05		 jmp	 SHORT $LN10@z900_extid
$LN9@z900_extid:
  000b7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@z900_extid:
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000c1	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 975  :     buf[9] = 0x00;

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	48 6b c0 09	 imul	 rax, rax, 9
  000d2	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  000d7	48 83 7c 24 68
	28		 cmp	 QWORD PTR $T2[rsp], 40	; 00000028H
  000dd	73 02		 jae	 SHORT $LN11@z900_extid
  000df	eb 05		 jmp	 SHORT $LN12@z900_extid
$LN11@z900_extid:
  000e1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@z900_extid:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  000eb	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 976  : 
; 977  :     /* Byte 10 contains the system product version number */
; 978  :     sscanf (QSTR(VERSION), "%d.%d", &ver, &rel);

  000f3	4c 8d 4c 24 5c	 lea	 r9, QWORD PTR rel$[rsp]
  000f8	4c 8d 44 24 44	 lea	 r8, QWORD PTR ver$[rsp]
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193844
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193845
  0010b	e8 00 00 00 00	 call	 sscanf

; 979  :     buf[10] = ver & 0xff;

  00110	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  00114	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 0a	 imul	 rcx, rcx, 10
  00122	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 980  : 
; 981  :     /* Byte 11 contains version number from STIDP */
; 982  :     buf[11] = regs->cpuversion;

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 0b	 imul	 rax, rax, 11
  00132	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	0f b6 49 3e	 movzx	 ecx, BYTE PTR [rcx+62]
  0013e	88 8c 04 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl

; 983  : 
; 984  :     /* Bytes 12-13 contain MCEL length from STIDP */
; 985  :     buf[12] = (regs->cpuid >> 8) & 0xFF;

  00145	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00151	48 c1 e8 08	 shr	 rax, 8
  00155	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0015b	b9 01 00 00 00	 mov	 ecx, 1
  00160	48 6b c9 0c	 imul	 rcx, rcx, 12
  00164	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 986  :     buf[13] = regs->cpuid & 0xFF;

  0016b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00177	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 0d	 imul	 rcx, rcx, 13
  00186	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 987  : 
; 988  :     /* Bytes 14-15 contain the CP address */
; 989  :     buf[14] = (regs->cpuad >> 8) & 0xFF;

  0018d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0019c	c1 f8 08	 sar	 eax, 8
  0019f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001a4	b9 01 00 00 00	 mov	 ecx, 1
  001a9	48 6b c9 0e	 imul	 rcx, rcx, 14
  001ad	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 990  :     buf[15] = regs->cpuad & 0xFF;

  001b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	48 6b c9 0f	 imul	 rcx, rcx, 15
  001d1	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 991  : 
; 992  :     /* Bytes 16-23 contain the userid in EBCDIC */
; 993  : #if defined( HAVE_GETLOGIN_R )
; 994  :     memset( unam, 0, sizeof(unam) );
; 995  :     VERIFY( getlogin_r ( unam, sizeof(unam) ) == 0 );
; 996  :     puser = unam;
; 997  : #else
; 998  :     puser = "";

  001d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193846
  001df	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax

; 999  : #endif
; 1000 :     for (i = 0; i < 8; i++)

  001e4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ec	eb 0a		 jmp	 SHORT $LN4@z900_extid
$LN2@z900_extid:
  001ee	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  001f2	ff c0		 inc	 eax
  001f4	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_extid:
  001f8	83 7c 24 38 08	 cmp	 DWORD PTR i$[rsp], 8
  001fd	7d 61		 jge	 SHORT $LN3@z900_extid

; 1001 :     {
; 1002 :         c = (*puser == '\0' ? SPACE : *(puser++));

  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00204	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00207	85 c0		 test	 eax, eax
  00209	75 0a		 jne	 SHORT $LN13@z900_extid
  0020b	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR tv161[rsp], 32 ; 00000020H
  00213	eb 19		 jmp	 SHORT $LN14@z900_extid
$LN13@z900_extid:
  00215	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  0021a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0021d	89 44 24 40	 mov	 DWORD PTR tv161[rsp], eax
  00221	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00226	48 ff c0	 inc	 rax
  00229	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax
$LN14@z900_extid:
  0022e	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv161[rsp]
  00233	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 1003 :         buf[16+i] = host_to_guest(toupper(c));

  00237	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0023c	8b c8		 mov	 ecx, eax
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00244	0f b6 c8	 movzx	 ecx, al
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0024d	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00251	83 c1 10	 add	 ecx, 16
  00254	48 63 c9	 movsxd	 rcx, ecx
  00257	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1004 :     }

  0025e	eb 8e		 jmp	 SHORT $LN2@z900_extid
$LN3@z900_extid:

; 1005 : 
; 1006 :     /* Bytes 24-31 contain the program product bitmap */
; 1007 :     memcpy (buf+24, "\x7F\xFE\x00\x00\x00\x00\x00\x00", 8);

  00260	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR $SG193847
  00267	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR buf$[rsp+24], rax

; 1008 : 
; 1009 :     /* Bytes 32-35 contain the time zone differential */
; 1010 :     tzdiff = query_tzoffset();   /* returns +/-HHMM as an integer */

  0026f	e8 00 00 00 00	 call	 query_tzoffset
  00274	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1011 :     tzdiff = ((tzdiff/100)*3600)+((tzdiff%100)*60);

  00278	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  0027c	99		 cdq
  0027d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00282	f7 f9		 idiv	 ecx
  00284	69 c0 10 0e 00
	00		 imul	 eax, eax, 3600		; 00000e10H
  0028a	89 44 24 58	 mov	 DWORD PTR tv183[rsp], eax
  0028e	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  00292	99		 cdq
  00293	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00298	f7 f9		 idiv	 ecx
  0029a	8b c2		 mov	 eax, edx
  0029c	6b c0 3c	 imul	 eax, eax, 60		; 0000003cH
  0029f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv183[rsp]
  002a3	03 c8		 add	 ecx, eax
  002a5	8b c1		 mov	 eax, ecx
  002a7	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1012 :     STORE_FW(buf+32,tzdiff);

  002ab	8b 4c 24 3c	 mov	 ecx, DWORD PTR tzdiff$[rsp]
  002af	e8 00 00 00 00	 call	 _byteswap_ulong
  002b4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+32]
  002bc	8b d0		 mov	 edx, eax
  002be	e8 00 00 00 00	 call	 store_fw_noswap

; 1013 : 
; 1014 :     /* Bytes 36-39 contain version, level, and service level */
; 1015 :     buf[36] = ver & 0xff;

  002c3	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  002c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002cc	b9 01 00 00 00	 mov	 ecx, 1
  002d1	48 6b c9 24	 imul	 rcx, rcx, 36		; 00000024H
  002d5	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1016 :     buf[37] = rel & 0xff;

  002dc	8b 44 24 5c	 mov	 eax, DWORD PTR rel$[rsp]
  002e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	48 6b c9 25	 imul	 rcx, rcx, 37		; 00000025H
  002ee	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1017 :     buf[38] = 0x00;

  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 26	 imul	 rax, rax, 38		; 00000026H
  002fe	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00303	48 83 7c 24 70
	28		 cmp	 QWORD PTR $T3[rsp], 40	; 00000028H
  00309	73 02		 jae	 SHORT $LN15@z900_extid
  0030b	eb 05		 jmp	 SHORT $LN16@z900_extid
$LN15@z900_extid:
  0030d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@z900_extid:
  00312	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  00317	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1018 :     buf[39] = 0x00;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  00328	48 89 44 24 78	 mov	 QWORD PTR $T4[rsp], rax
  0032d	48 83 7c 24 78
	28		 cmp	 QWORD PTR $T4[rsp], 40	; 00000028H
  00333	73 02		 jae	 SHORT $LN17@z900_extid
  00335	eb 05		 jmp	 SHORT $LN18@z900_extid
$LN17@z900_extid:
  00337	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN18@z900_extid:
  0033c	48 8b 44 24 78	 mov	 rax, QWORD PTR $T4[rsp]
  00341	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1019 : 
; 1020 : #if 0 // debug
; 1021 :     LOGMSG( "Diagnose X'000':"
; 1022 : 
; 1023 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1024 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1025 : 
; 1026 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1027 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1028 : 
; 1029 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1030 : 
; 1031 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1032 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1033 : 
; 1034 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1035 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1036 : 
; 1037 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1038 :         );
; 1039 : #endif
; 1040 : 
; 1041 :     /* Enforce maximum length to store */
; 1042 :     if (idlen > sizeof(buf))

  00349	8b 44 24 34	 mov	 eax, DWORD PTR idlen$[rsp]
  0034d	48 83 f8 28	 cmp	 rax, 40			; 00000028H
  00351	76 08		 jbe	 SHORT $LN7@z900_extid

; 1043 :         idlen = sizeof(buf);

  00353	c7 44 24 34 28
	00 00 00	 mov	 DWORD PTR idlen$[rsp], 40 ; 00000028H
$LN7@z900_extid:

; 1044 : 
; 1045 :     /* Store the extended identification code at operand address */
; 1046 :     ARCH_DEP(vstorec) (buf, idlen-1, idaddr, USE_REAL_ADDR, regs);

  0035b	8b 44 24 48	 mov	 eax, DWORD PTR idaddr$[rsp]
  0035f	8b 4c 24 34	 mov	 ecx, DWORD PTR idlen$[rsp]
  00363	ff c9		 dec	 ecx
  00365	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036d	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00372	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00378	44 8b c0	 mov	 r8d, eax
  0037b	0f b6 d1	 movzx	 edx, cl
  0037e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00386	e8 00 00 00 00	 call	 z900_vstorec

; 1047 : 
; 1048 :     /* Deduct number of bytes from the R2 register */
; 1049 :     regs->GR_L(r2) -= idlen;

  0038b	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00393	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	8b 54 24 34	 mov	 edx, DWORD PTR idlen$[rsp]
  0039f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a6	2b c2		 sub	 eax, edx
  003a8	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003b0	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003b8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN8@z900_extid:

; 1050 : 
; 1051 : } /* end function extid_call */

  003bf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c7	48 33 cc	 xor	 rcx, rsp
  003ca	e8 00 00 00 00	 call	 __security_check_cookie
  003cf	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003d6	c3		 ret	 0
z900_extid_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
accum$ = 48
unitstat$ = 49
i$ = 52
dev$ = 56
chanstat$ = 64
residual$ = 68
numsense$ = 72
lastccw$ = 76
iopaddr$ = 80
devnum$ = 84
ccwaddr$ = 88
tv166 = 92
ioparm$ = 96
__$ArrayPad$ = 192
r1$ = 240
r2$ = 248
regs$ = 256
z900_syncgen_io PROC

; 749  : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 750  : U32             i;                      /* Array subscript           */
; 751  : U32             numsense;               /* Number of sense bytes     */
; 752  : U32             iopaddr;                /* Address of HCPSGIOP       */
; 753  : HCPSGIOP        ioparm;                 /* I/O parameter list        */
; 754  : DEVBLK         *dev;                    /* -> Device block           */
; 755  : U16             devnum;                 /* Device number             */
; 756  : U16             residual;               /* Residual byte count       */
; 757  : U32             ccwaddr;                /* Address of channel program*/
; 758  : U32             lastccw;                /* CCW address at interrupt  */
; 759  : BYTE            accum;                  /* Work area                 */
; 760  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 31 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 761  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 40 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@z900_syncg:

; 762  : 
; 763  : //FIXME: code not right for shared devices
; 764  : 
; 765  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@z900_syncg

; 766  : 
; 767  :     /* Register R1 contains the real address of the parameter list */
; 768  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 44 24 50	 mov	 DWORD PTR iopaddr$[rsp], eax

; 769  : 
; 770  :     /* Program check if parameter list not on fullword boundary */
; 771  :     if (iopaddr & 0x00000003)

  00053	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  00057	83 e0 03	 and	 eax, 3
  0005a	85 c0		 test	 eax, eax
  0005c	74 12		 je	 SHORT $LN17@z900_syncg

; 772  :     {
; 773  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0005e	ba 06 00 00 00	 mov	 edx, 6
  00063	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN17@z900_syncg:

; 774  :     }
; 775  : 
; 776  :     /* Ensure that parameter list operand is addressable */
; 777  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00070	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  00074	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00081	41 b9 02 00 00
	00		 mov	 r9d, 2
  00087	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  0008d	ba fe ff ff ff	 mov	 edx, -2
  00092	8b c8		 mov	 ecx, eax
  00094	e8 00 00 00 00	 call	 z900_validate_operand

; 778  :                         ACCTYPE_WRITE, regs);
; 779  : 
; 780  :     /* Fetch the parameter list from real storage */
; 781  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00099	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  0009d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000aa	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000b0	44 8b c0	 mov	 r8d, eax
  000b3	b2 57		 mov	 dl, 87			; 00000057H
  000b5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000ba	e8 00 00 00 00	 call	 z900_vfetchc

; 782  : 
; 783  :     /* Load numeric fields from the parameter list */
; 784  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	48 6b c0 00	 imul	 rax, rax, 0
  000c8	0f b6 44 04 60	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000cd	c1 e0 08	 shl	 eax, 8
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	48 6b c9 01	 imul	 rcx, rcx, 1
  000d9	0f b6 4c 0c 60	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000de	0b c1		 or	 eax, ecx
  000e0	66 89 44 24 54	 mov	 WORD PTR devnum$[rsp], ax

; 785  :     ccwaddr = (ioparm.ccwaddr[0] << 24)

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 00	 imul	 rax, rax, 0
  000ee	0f b6 44 04 68	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  000f3	c1 e0 18	 shl	 eax, 24
  000f6	b9 01 00 00 00	 mov	 ecx, 1
  000fb	48 6b c9 01	 imul	 rcx, rcx, 1
  000ff	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00104	c1 e1 10	 shl	 ecx, 16
  00107	0b c1		 or	 eax, ecx
  00109	b9 01 00 00 00	 mov	 ecx, 1
  0010e	48 6b c9 02	 imul	 rcx, rcx, 2
  00112	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00117	c1 e1 08	 shl	 ecx, 8
  0011a	0b c1		 or	 eax, ecx
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	48 6b c9 03	 imul	 rcx, rcx, 3
  00125	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  0012a	0b c1		 or	 eax, ecx
  0012c	89 44 24 58	 mov	 DWORD PTR ccwaddr$[rsp], eax

; 786  :                 | (ioparm.ccwaddr[1] << 16)
; 787  :                 | (ioparm.ccwaddr[2] << 8)
; 788  :                 | ioparm.ccwaddr[3];
; 789  : 
; 790  :     /* Locate the device block */
; 791  :     dev = find_device_by_devnum (0,devnum);

  00130	0f b7 54 24 54	 movzx	 edx, WORD PTR devnum$[rsp]
  00135	33 c9		 xor	 ecx, ecx
  00137	e8 00 00 00 00	 call	 find_device_by_devnum
  0013c	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 792  : 
; 793  :     /* Set return code 1 and cond code 1 if device does not exist */
; 794  :     if (dev == NULL)

  00141	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00147	75 26		 jne	 SHORT $LN18@z900_syncg

; 795  :     {
; 796  :         regs->GR_L(15) = 1;

  00149	b8 08 00 00 00	 mov	 eax, 8
  0014e	48 6b c0 0f	 imul	 rax, rax, 15
  00152	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	c7 84 01 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 1

; 797  :         return 1;

  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	e9 ff 05 00 00	 jmp	 $LN1@z900_syncg
$LN18@z900_syncg:

; 798  :     }
; 799  : 
; 800  :     /* Program check if protect key bits 4-7 are not zero
; 801  :        or if the reserved bits in the flag byte are not zero */
; 802  :     if ((ioparm.akey & 0x0F) || (ioparm.flag & HCPSGIOP_FLAG_RESV))

  0016f	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00174	83 e0 0f	 and	 eax, 15
  00177	85 c0		 test	 eax, eax
  00179	75 0c		 jne	 SHORT $LN20@z900_syncg
  0017b	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00180	83 e0 7f	 and	 eax, 127		; 0000007fH
  00183	85 c0		 test	 eax, eax
  00185	74 12		 je	 SHORT $LN19@z900_syncg
$LN20@z900_syncg:

; 803  :     {
; 804  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00187	ba 15 00 00 00	 mov	 edx, 21
  0018c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_syncg:

; 805  :     }
; 806  : 
; 807  : #ifdef FEATURE_S370_CHANNEL
; 808  :     /* Program check if flag byte specifies format-1 CCW */
; 809  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)
; 810  :     {
; 811  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);
; 812  :     }
; 813  : #endif /*FEATURE_S370_CHANNEL*/
; 814  : 
; 815  :     /* Program check if CCW is not on a doubleword boundary,
; 816  :        or if CCW address exceeds maximum according to CCW format */
; 817  :     if ((ccwaddr & 0x00000007) || ccwaddr >

  00199	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  0019d	83 e0 07	 and	 eax, 7
  001a0	85 c0		 test	 eax, eax
  001a2	75 2a		 jne	 SHORT $LN22@z900_syncg
  001a4	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  001a9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ae	85 c0		 test	 eax, eax
  001b0	74 0a		 je	 SHORT $LN35@z900_syncg
  001b2	c7 44 24 5c ff
	ff ff 7f	 mov	 DWORD PTR tv166[rsp], 2147483647 ; 7fffffffH
  001ba	eb 08		 jmp	 SHORT $LN36@z900_syncg
$LN35@z900_syncg:
  001bc	c7 44 24 5c ff
	ff ff 00	 mov	 DWORD PTR tv166[rsp], 16777215 ; 00ffffffH
$LN36@z900_syncg:
  001c4	8b 44 24 5c	 mov	 eax, DWORD PTR tv166[rsp]
  001c8	39 44 24 58	 cmp	 DWORD PTR ccwaddr$[rsp], eax
  001cc	76 12		 jbe	 SHORT $LN21@z900_syncg
$LN22@z900_syncg:

; 818  :            ((ioparm.flag & HCPSGIOP_FORMAT1_CCW) ?
; 819  :                         (U32)0x7FFFFFFF : (U32)0x00FFFFFF))
; 820  :     {
; 821  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001ce	ba 15 00 00 00	 mov	 edx, 21
  001d3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_syncg:

; 822  :     }
; 823  : 
; 824  :     /* Program check if reserved fields are not zero */
; 825  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  001e0	c6 44 24 30 00	 mov	 BYTE PTR accum$[rsp], 0
  001e5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ed	eb 0a		 jmp	 SHORT $LN7@z900_syncg
$LN5@z900_syncg:
  001ef	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  001f3	ff c0		 inc	 eax
  001f5	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_syncg:
  001f9	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  001fd	48 83 f8 04	 cmp	 rax, 4
  00201	73 18		 jae	 SHORT $LN6@z900_syncg

; 826  :         accum |= ioparm.resv1[i];

  00203	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00207	0f b6 44 04 64	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  0020c	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00211	0b c8		 or	 ecx, eax
  00213	8b c1		 mov	 eax, ecx
  00215	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  00219	eb d4		 jmp	 SHORT $LN5@z900_syncg
$LN6@z900_syncg:

; 827  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  0021b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00223	eb 0a		 jmp	 SHORT $LN10@z900_syncg
$LN8@z900_syncg:
  00225	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00229	ff c0		 inc	 eax
  0022b	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_syncg:
  0022f	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00233	48 83 f8 04	 cmp	 rax, 4
  00237	73 18		 jae	 SHORT $LN9@z900_syncg

; 828  :         accum |= ioparm.resv2[i];

  00239	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0023d	0f b6 44 04 6c	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  00242	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00247	0b c8		 or	 ecx, eax
  00249	8b c1		 mov	 eax, ecx
  0024b	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  0024f	eb d4		 jmp	 SHORT $LN8@z900_syncg
$LN9@z900_syncg:

; 829  :     for (i = 0; i < sizeof(ioparm.resv3); i++)

  00251	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00259	eb 0a		 jmp	 SHORT $LN13@z900_syncg
$LN11@z900_syncg:
  0025b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0025f	ff c0		 inc	 eax
  00261	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_syncg:
  00265	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00269	48 83 f8 05	 cmp	 rax, 5
  0026d	73 18		 jae	 SHORT $LN12@z900_syncg

; 830  :         accum |= ioparm.resv3[i];

  0026f	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00273	0f b6 44 04 79	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  00278	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  0027d	0b c8		 or	 ecx, eax
  0027f	8b c1		 mov	 eax, ecx
  00281	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  00285	eb d4		 jmp	 SHORT $LN11@z900_syncg
$LN12@z900_syncg:

; 831  :     for (i = 0; i < sizeof(ioparm.resv4); i++)

  00287	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0028f	eb 0a		 jmp	 SHORT $LN16@z900_syncg
$LN14@z900_syncg:
  00291	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00295	ff c0		 inc	 eax
  00297	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN16@z900_syncg:
  0029b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0029f	48 83 f8 18	 cmp	 rax, 24
  002a3	73 1b		 jae	 SHORT $LN15@z900_syncg

; 832  :         accum |= ioparm.resv4[i];

  002a5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002a9	0f b6 84 04 80
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  002b1	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  002b6	0b c8		 or	 ecx, eax
  002b8	8b c1		 mov	 eax, ecx
  002ba	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  002be	eb d1		 jmp	 SHORT $LN14@z900_syncg
$LN15@z900_syncg:

; 833  :     if (accum != 0)

  002c0	0f b6 44 24 30	 movzx	 eax, BYTE PTR accum$[rsp]
  002c5	85 c0		 test	 eax, eax
  002c7	74 12		 je	 SHORT $LN23@z900_syncg

; 834  :     {
; 835  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002c9	ba 15 00 00 00	 mov	 edx, 21
  002ce	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_syncg:

; 836  :     }
; 837  : 
; 838  :     /* Obtain the interrupt lock */
; 839  :     obtain_lock (&dev->lock);

  002db	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002e0	48 83 c0 38	 add	 rax, 56			; 00000038H
  002e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193803
  002eb	48 8b c8	 mov	 rcx, rax
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 840  : 
; 841  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 842  :     /* Return code 5 and condition code 1 if status pending */
; 843  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 844  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))

  002f4	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002f9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00300	83 e0 01	 and	 eax, 1
  00303	85 c0		 test	 eax, eax
  00305	75 13		 jne	 SHORT $LN25@z900_syncg
  00307	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0030c	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00313	83 e0 01	 and	 eax, 1
  00316	85 c0		 test	 eax, eax
  00318	74 3f		 je	 SHORT $LN24@z900_syncg
$LN25@z900_syncg:

; 845  :     {
; 846  :         release_lock (&dev->lock);

  0031a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0031f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193806
  0032a	48 8b c8	 mov	 rcx, rax
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 847  :         regs->GR_L(15) = 5;

  00333	b8 08 00 00 00	 mov	 eax, 8
  00338	48 6b c0 0f	 imul	 rax, rax, 15
  0033c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 848  :         return 1;

  0034f	b8 01 00 00 00	 mov	 eax, 1
  00354	e9 15 04 00 00	 jmp	 $LN1@z900_syncg
$LN24@z900_syncg:

; 849  :     }
; 850  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 851  : 
; 852  :     /* Return code 5 and condition code 1 if device is busy */
; 853  :     if (dev->busy || IOPENDING(dev))

  00359	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0035e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00364	c1 e8 13	 shr	 eax, 19
  00367	83 e0 01	 and	 eax, 1
  0036a	85 c0		 test	 eax, eax
  0036c	75 54		 jne	 SHORT $LN27@z900_syncg
  0036e	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00373	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00379	c1 e8 16	 shr	 eax, 22
  0037c	83 e0 01	 and	 eax, 1
  0037f	85 c0		 test	 eax, eax
  00381	75 3f		 jne	 SHORT $LN28@z900_syncg
  00383	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00388	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0038e	c1 e8 17	 shr	 eax, 23
  00391	83 e0 01	 and	 eax, 1
  00394	85 c0		 test	 eax, eax
  00396	75 2a		 jne	 SHORT $LN28@z900_syncg
  00398	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0039d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003a3	c1 e8 18	 shr	 eax, 24
  003a6	83 e0 01	 and	 eax, 1
  003a9	85 c0		 test	 eax, eax
  003ab	75 15		 jne	 SHORT $LN28@z900_syncg
  003ad	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003b2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003b8	c1 e8 1b	 shr	 eax, 27
  003bb	83 e0 01	 and	 eax, 1
  003be	85 c0		 test	 eax, eax
  003c0	74 3f		 je	 SHORT $LN26@z900_syncg
$LN28@z900_syncg:
$LN27@z900_syncg:

; 854  :     {
; 855  :         release_lock (&dev->lock);

  003c2	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003c7	48 83 c0 38	 add	 rax, 56			; 00000038H
  003cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193810
  003d2	48 8b c8	 mov	 rcx, rax
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 856  :         regs->GR_L(15) = 5;

  003db	b8 08 00 00 00	 mov	 eax, 8
  003e0	48 6b c0 0f	 imul	 rax, rax, 15
  003e4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ec	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 857  :         return 1;

  003f7	b8 01 00 00 00	 mov	 eax, 1
  003fc	e9 6d 03 00 00	 jmp	 $LN1@z900_syncg
$LN26@z900_syncg:

; 858  :     }
; 859  : 
; 860  :     /* Set the device busy indicator */
; 861  :     dev->busy = 1;

  00401	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00406	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0040c	0f ba e8 13	 bts	 eax, 19
  00410	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00415	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 862  : 
; 863  :     /* Release the device lock */
; 864  :     release_lock (&dev->lock);

  0041b	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00420	48 83 c0 38	 add	 rax, 56			; 00000038H
  00424	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193811
  0042b	48 8b c8	 mov	 rcx, rax
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 865  : 
; 866  :     /* Build the operation request block */
; 867  :     memset (&dev->orb, 0, sizeof(ORB));

  00434	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00439	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  0043f	48 8b f8	 mov	 rdi, rax
  00442	33 c0		 xor	 eax, eax
  00444	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00449	f3 aa		 rep stosb

; 868  :     STORE_FW(dev->orb.ccwaddr, ccwaddr);

  0044b	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  0044f	e8 00 00 00 00	 call	 _byteswap_ulong
  00454	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00459	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  00460	8b d0		 mov	 edx, eax
  00462	e8 00 00 00 00	 call	 store_fw_noswap

; 869  :     dev->orb.flag4 = ioparm.akey & ORB4_KEY;

  00467	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  0046c	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00471	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00476	88 81 d0 02 00
	00		 mov	 BYTE PTR [rcx+720], al

; 870  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)

  0047c	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00481	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00486	85 c0		 test	 eax, eax
  00488	74 1b		 je	 SHORT $LN29@z900_syncg

; 871  :         dev->orb.flag5 |= ORB5_F;

  0048a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00496	0f ba e8 07	 bts	 eax, 7
  0049a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0049f	88 81 d1 02 00
	00		 mov	 BYTE PTR [rcx+721], al
$LN29@z900_syncg:

; 872  : 
; 873  :     /* Execute the channel program synchronously */
; 874  :     ARCH_DEP(execute_ccw_chain) (dev);

  004a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  004aa	e8 00 00 00 00	 call	 z900_execute_ccw_chain

; 875  : 
; 876  :     /* Obtain status, CCW address, and residual byte count */
; 877  :     lastccw = (dev->scsw.ccwaddr[0] << 24)

  004af	b8 01 00 00 00	 mov	 eax, 1
  004b4	48 6b c0 00	 imul	 rax, rax, 0
  004b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  004bd	0f b6 84 01 0c
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+780]
  004c5	c1 e0 18	 shl	 eax, 24
  004c8	b9 01 00 00 00	 mov	 ecx, 1
  004cd	48 6b c9 01	 imul	 rcx, rcx, 1
  004d1	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004d6	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004de	c1 e1 10	 shl	 ecx, 16
  004e1	0b c1		 or	 eax, ecx
  004e3	b9 01 00 00 00	 mov	 ecx, 1
  004e8	48 6b c9 02	 imul	 rcx, rcx, 2
  004ec	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004f1	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004f9	c1 e1 08	 shl	 ecx, 8
  004fc	0b c1		 or	 eax, ecx
  004fe	b9 01 00 00 00	 mov	 ecx, 1
  00503	48 6b c9 03	 imul	 rcx, rcx, 3
  00507	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  0050c	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  00514	0b c1		 or	 eax, ecx
  00516	89 44 24 4c	 mov	 DWORD PTR lastccw$[rsp], eax

; 878  :                 | (dev->scsw.ccwaddr[1] << 16)
; 879  :                 | (dev->scsw.ccwaddr[2] << 8)
; 880  :                 | dev->scsw.ccwaddr[3];
; 881  :     unitstat = dev->scsw.unitstat;

  0051a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0051f	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  00526	88 44 24 31	 mov	 BYTE PTR unitstat$[rsp], al

; 882  :     chanstat = dev->scsw.chanstat;

  0052a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0052f	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  00536	88 44 24 40	 mov	 BYTE PTR chanstat$[rsp], al

; 883  :     residual = (dev->scsw.count[0] << 8) | dev->scsw.count[1];

  0053a	b8 01 00 00 00	 mov	 eax, 1
  0053f	48 6b c0 00	 imul	 rax, rax, 0
  00543	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00548	0f b6 84 01 12
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+786]
  00550	c1 e0 08	 shl	 eax, 8
  00553	b9 01 00 00 00	 mov	 ecx, 1
  00558	48 6b c9 01	 imul	 rcx, rcx, 1
  0055c	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  00561	0f b6 8c 0a 12
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+786]
  00569	0b c1		 or	 eax, ecx
  0056b	66 89 44 24 44	 mov	 WORD PTR residual$[rsp], ax

; 884  : 
; 885  :     /* Clear the interrupt pending and device busy conditions */
; 886  :     obtain_lock (&dev->lock);

  00570	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00575	48 83 c0 38	 add	 rax, 56			; 00000038H
  00579	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193813
  00580	48 8b c8	 mov	 rcx, rax
  00583	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 887  :     dev->busy = dev->pending = 0;

  00589	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0058e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00594	0f ba f0 16	 btr	 eax, 22
  00598	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0059d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  005a3	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005a8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ae	0f ba f0 13	 btr	 eax, 19
  005b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  005b7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 888  :     dev->scsw.flag2 = 0;

  005bd	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005c2	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 889  :     dev->scsw.flag3 = 0;

  005c9	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005ce	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 890  :     release_lock (&dev->lock);

  005d5	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005da	48 83 c0 38	 add	 rax, 56			; 00000038H
  005de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193814
  005e5	48 8b c8	 mov	 rcx, rax
  005e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 891  : 
; 892  :     /* Store the last CCW address in the parameter list */
; 893  :     ioparm.lastccw[0] = (lastccw >> 24) & 0xFF;

  005ee	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005f2	c1 e8 18	 shr	 eax, 24
  005f5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005fa	b9 01 00 00 00	 mov	 ecx, 1
  005ff	48 6b c9 00	 imul	 rcx, rcx, 0
  00603	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 894  :     ioparm.lastccw[1] = (lastccw >> 16) & 0xFF;

  00607	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  0060b	c1 e8 10	 shr	 eax, 16
  0060e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00613	b9 01 00 00 00	 mov	 ecx, 1
  00618	48 6b c9 01	 imul	 rcx, rcx, 1
  0061c	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 895  :     ioparm.lastccw[2] = (lastccw >> 8) & 0xFF;

  00620	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  00624	c1 e8 08	 shr	 eax, 8
  00627	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0062c	b9 01 00 00 00	 mov	 ecx, 1
  00631	48 6b c9 02	 imul	 rcx, rcx, 2
  00635	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 896  :     ioparm.lastccw[3] = lastccw & 0xFF;

  00639	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  0063d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00642	b9 01 00 00 00	 mov	 ecx, 1
  00647	48 6b c9 03	 imul	 rcx, rcx, 3
  0064b	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 897  : 
; 898  :     /* Store the device and subchannel status in the parameter list */
; 899  :     ioparm.unitstat = unitstat;

  0064f	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00654	88 44 24 74	 mov	 BYTE PTR ioparm$[rsp+20], al

; 900  :     ioparm.chanstat = chanstat;

  00658	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0065d	88 44 24 75	 mov	 BYTE PTR ioparm$[rsp+21], al

; 901  : 
; 902  :     /* Store the residual byte count in the parameter list */
; 903  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  00661	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  00666	c1 f8 08	 sar	 eax, 8
  00669	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0066e	b9 01 00 00 00	 mov	 ecx, 1
  00673	48 6b c9 00	 imul	 rcx, rcx, 0
  00677	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 904  :     ioparm.residual[1] = residual & 0xFF;

  0067b	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  00680	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00685	b9 01 00 00 00	 mov	 ecx, 1
  0068a	48 6b c9 01	 imul	 rcx, rcx, 1
  0068e	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 905  : 
; 906  :     /* Return sense data if unit check occurred */
; 907  :     if (unitstat & CSW_UC)

  00692	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00697	83 e0 02	 and	 eax, 2
  0069a	85 c0		 test	 eax, eax
  0069c	74 72		 je	 SHORT $LN30@z900_syncg

; 908  :     {
; 909  :         numsense = dev->numsense;

  0069e	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  006a3	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  006a9	89 44 24 48	 mov	 DWORD PTR numsense$[rsp], eax

; 910  :         if (numsense > sizeof(ioparm.sense))

  006ad	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006b1	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  006b5	76 08		 jbe	 SHORT $LN31@z900_syncg

; 911  :             numsense = sizeof(ioparm.sense);

  006b7	c7 44 24 48 20
	00 00 00	 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN31@z900_syncg:

; 912  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  006bf	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006c3	c1 e8 08	 shr	 eax, 8
  006c6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006cb	b9 01 00 00 00	 mov	 ecx, 1
  006d0	48 6b c9 00	 imul	 rcx, rcx, 0
  006d4	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 913  :         ioparm.sensecount[1] = numsense & 0xFF;

  006d8	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006e1	b9 01 00 00 00	 mov	 ecx, 1
  006e6	48 6b c9 01	 imul	 rcx, rcx, 1
  006ea	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 914  :         memcpy (ioparm.sense, dev->sense, numsense);

  006ee	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  006f7	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  006fe	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  00706	48 8b fa	 mov	 rdi, rdx
  00709	48 8b f1	 mov	 rsi, rcx
  0070c	8b c8		 mov	 ecx, eax
  0070e	f3 a4		 rep movsb
$LN30@z900_syncg:

; 915  :     }
; 916  : 
; 917  :     /* Store the updated parameter list in real storage */
; 918  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00710	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  00714	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00721	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00727	44 8b c0	 mov	 r8d, eax
  0072a	b2 57		 mov	 dl, 87			; 00000057H
  0072c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  00731	e8 00 00 00 00	 call	 z900_vstorec

; 919  : 
; 920  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 921  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00736	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0073b	83 f8 0c	 cmp	 eax, 12
  0073e	75 09		 jne	 SHORT $LN33@z900_syncg
  00740	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00745	85 c0		 test	 eax, eax
  00747	74 23		 je	 SHORT $LN32@z900_syncg
$LN33@z900_syncg:

; 922  :     {
; 923  :         regs->GR_L(15) = 13;

  00749	b8 08 00 00 00	 mov	 eax, 8
  0074e	48 6b c0 0f	 imul	 rax, rax, 15
  00752	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075a	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 924  :         return 3;

  00765	b8 03 00 00 00	 mov	 eax, 3
  0076a	eb 02		 jmp	 SHORT $LN1@z900_syncg
$LN32@z900_syncg:

; 925  :     }
; 926  : 
; 927  :     /* Return with condition code 0 and register 15 unchanged */
; 928  :     return 0;

  0076c	33 c0		 xor	 eax, eax
$LN1@z900_syncg:

; 929  : 
; 930  : } /* end function syncgen_io */

  0076e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00776	48 33 cc	 xor	 rcx, rsp
  00779	e8 00 00 00 00	 call	 __security_check_cookie
  0077e	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00785	5f		 pop	 rdi
  00786	5e		 pop	 rsi
  00787	c3		 ret	 0
z900_syncgen_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
chanstat$ = 112
accum$ = 113
unitstat$ = 114
dev$ = 120
skey1$ = 128
skey2$ = 129
i$ = 132
blksize$ = 136
sbiaddr$ = 140
blkcount$ = 144
absadr$ = 148
numsense$ = 152
iopaddr$ = 156
devnum$ = 160
sbicount$ = 164
residual$ = 168
tv341 = 172
tv347 = 176
blknum$ = 180
tv336 = 184
ioparm$ = 192
__$ArrayPad$ = 288
r1$ = 336
r2$ = 344
regs$ = 352
z900_syncblk_io PROC

; 491  : {

$LN51:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 492  : U32             i;                      /* Array subscript           */
; 493  : U32             numsense;               /* Number of sense bytes     */
; 494  : U32             iopaddr;                /* Address of HCPSBIOP       */
; 495  : HCPSBIOP        ioparm;                 /* I/O parameter list        */
; 496  : DEVBLK         *dev;                    /* -> Device block           */
; 497  : U16             devnum;                 /* Device number             */
; 498  : U32             residual;               /* Residual byte count       */
; 499  : U32             blksize;                /* Fixed block size          */
; 500  : U32             sbiaddr;                /* Addr of SBILIST           */
; 501  : U32             sbicount;               /* Number of SBILIST entries */
; 502  : U32             blkcount;               /* Number of blocks processed*/
; 503  : U32             blknum;                 /* Block number              */
; 504  : U32             absadr;                 /* Absolute storage address  */
; 505  : BYTE            accum;                  /* Work area                 */
; 506  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 72 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 507  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 70 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@z900_syncb:

; 508  : BYTE            skey1, skey2;           /* Storage keys of first and
; 509  :                                            last byte of I/O buffer   */
; 510  : //FIXME: code not right for shared devices
; 511  : 
; 512  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@z900_syncb

; 513  : 
; 514  :     /* Register R1 contains the real address of the parameter list */
; 515  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR iopaddr$[rsp], eax

; 516  : 
; 517  :     /* Program check if parameter list not on fullword boundary */
; 518  :     if (iopaddr & 0x00000003)

  00056	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  0005d	83 e0 03	 and	 eax, 3
  00060	85 c0		 test	 eax, eax
  00062	74 12		 je	 SHORT $LN14@z900_syncb

; 519  :     {
; 520  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00064	ba 06 00 00 00	 mov	 edx, 6
  00069	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_syncb:

; 521  :     }
; 522  : 
; 523  :     /* Ensure that parameter list operand is addressable */
; 524  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00076	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  0007d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00090	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  00096	ba fe ff ff ff	 mov	 edx, -2
  0009b	8b c8		 mov	 ecx, eax
  0009d	e8 00 00 00 00	 call	 z900_validate_operand

; 525  :                         ACCTYPE_WRITE, regs);
; 526  : 
; 527  :     /* Fetch the parameter list from real storage */
; 528  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  000a2	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  000a9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b6	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000bc	44 8b c0	 mov	 r8d, eax
  000bf	b2 57		 mov	 dl, 87			; 00000057H
  000c1	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000c9	e8 00 00 00 00	 call	 z900_vfetchc

; 529  : 
; 530  :     /* Load numeric fields from the parameter list */
; 531  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000ce	b8 01 00 00 00	 mov	 eax, 1
  000d3	48 6b c0 00	 imul	 rax, rax, 0
  000d7	0f b6 84 04 c0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000df	c1 e0 08	 shl	 eax, 8
  000e2	b9 01 00 00 00	 mov	 ecx, 1
  000e7	48 6b c9 01	 imul	 rcx, rcx, 1
  000eb	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000f3	0b c1		 or	 eax, ecx
  000f5	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax

; 532  :     blksize = (ioparm.blksize[0] << 24)

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	0f b6 84 04 c4
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  0010e	c1 e0 18	 shl	 eax, 24
  00111	b9 01 00 00 00	 mov	 ecx, 1
  00116	48 6b c9 01	 imul	 rcx, rcx, 1
  0011a	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  00122	c1 e1 10	 shl	 ecx, 16
  00125	0b c1		 or	 eax, ecx
  00127	b9 01 00 00 00	 mov	 ecx, 1
  0012c	48 6b c9 02	 imul	 rcx, rcx, 2
  00130	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  00138	c1 e1 08	 shl	 ecx, 8
  0013b	0b c1		 or	 eax, ecx
  0013d	b9 01 00 00 00	 mov	 ecx, 1
  00142	48 6b c9 03	 imul	 rcx, rcx, 3
  00146	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  0014e	0b c1		 or	 eax, ecx
  00150	89 84 24 88 00
	00 00		 mov	 DWORD PTR blksize$[rsp], eax

; 533  :                 | (ioparm.blksize[1] << 16)
; 534  :                 | (ioparm.blksize[2] << 8)
; 535  :                 | ioparm.blksize[3];
; 536  :     sbiaddr = (ioparm.sbiaddr[0] << 24)

  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	48 6b c0 00	 imul	 rax, rax, 0
  00160	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  00168	c1 e0 18	 shl	 eax, 24
  0016b	b9 01 00 00 00	 mov	 ecx, 1
  00170	48 6b c9 01	 imul	 rcx, rcx, 1
  00174	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  0017c	c1 e1 10	 shl	 ecx, 16
  0017f	0b c1		 or	 eax, ecx
  00181	b9 01 00 00 00	 mov	 ecx, 1
  00186	48 6b c9 02	 imul	 rcx, rcx, 2
  0018a	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00192	c1 e1 08	 shl	 ecx, 8
  00195	0b c1		 or	 eax, ecx
  00197	b9 01 00 00 00	 mov	 ecx, 1
  0019c	48 6b c9 03	 imul	 rcx, rcx, 3
  001a0	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  001a8	0b c1		 or	 eax, ecx
  001aa	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 537  :                 | (ioparm.sbiaddr[1] << 16)
; 538  :                 | (ioparm.sbiaddr[2] << 8)
; 539  :                 | ioparm.sbiaddr[3];
; 540  :     sbicount = (ioparm.sbicount[0] << 24)

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 00	 imul	 rax, rax, 0
  001ba	0f b6 84 04 cc
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  001c2	c1 e0 18	 shl	 eax, 24
  001c5	b9 01 00 00 00	 mov	 ecx, 1
  001ca	48 6b c9 01	 imul	 rcx, rcx, 1
  001ce	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001d6	c1 e1 10	 shl	 ecx, 16
  001d9	0b c1		 or	 eax, ecx
  001db	b9 01 00 00 00	 mov	 ecx, 1
  001e0	48 6b c9 02	 imul	 rcx, rcx, 2
  001e4	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001ec	c1 e1 08	 shl	 ecx, 8
  001ef	0b c1		 or	 eax, ecx
  001f1	b9 01 00 00 00	 mov	 ecx, 1
  001f6	48 6b c9 03	 imul	 rcx, rcx, 3
  001fa	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  00202	0b c1		 or	 eax, ecx
  00204	89 84 24 a4 00
	00 00		 mov	 DWORD PTR sbicount$[rsp], eax

; 541  :                 | (ioparm.sbicount[1] << 16)
; 542  :                 | (ioparm.sbicount[2] << 8)
; 543  :                 | ioparm.sbicount[3];
; 544  : 
; 545  :     /* Locate the device block */
; 546  :     dev = find_device_by_devnum (0,devnum);

  0020b	0f b7 94 24 a0
	00 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  00213	33 c9		 xor	 ecx, ecx
  00215	e8 00 00 00 00	 call	 find_device_by_devnum
  0021a	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax

; 547  : 
; 548  :     /* Set return code 2 and cond code 1 if device does not exist
; 549  :        or does not support the synchronous I/O call */
; 550  :     if (dev == NULL || dev->devtype != 0x3370)

  0021f	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00225	74 10		 je	 SHORT $LN16@z900_syncb
  00227	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0022c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00230	3d 70 33 00 00	 cmp	 eax, 13168		; 00003370H
  00235	74 26		 je	 SHORT $LN15@z900_syncb
$LN16@z900_syncb:

; 551  :     {
; 552  :         regs->GR_L(15) = 2;

  00237	b8 08 00 00 00	 mov	 eax, 8
  0023c	48 6b c0 0f	 imul	 rax, rax, 15
  00240	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	c7 84 01 80 02
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 2

; 553  :         return 1;

  00253	b8 01 00 00 00	 mov	 eax, 1
  00258	e9 ae 08 00 00	 jmp	 $LN1@z900_syncb
$LN15@z900_syncb:

; 554  :     }
; 555  : 
; 556  :     /* Program check if protect key bits 4-7 are not zero
; 557  :        or if I/O request type is not read or write */
; 558  :     if ((ioparm.akey & 0x0F)
; 559  :         || !(ioparm.type == HCPSBIOP_WRITE

  0025d	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00265	83 e0 0f	 and	 eax, 15
  00268	85 c0		 test	 eax, eax
  0026a	75 1a		 jne	 SHORT $LN18@z900_syncb
  0026c	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00274	83 f8 01	 cmp	 eax, 1
  00277	74 1f		 je	 SHORT $LN17@z900_syncb
  00279	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00281	83 f8 02	 cmp	 eax, 2
  00284	74 12		 je	 SHORT $LN17@z900_syncb
$LN18@z900_syncb:

; 560  :             || ioparm.type == HCPSBIOP_READ))
; 561  :     {
; 562  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00286	ba 15 00 00 00	 mov	 edx, 21
  0028b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	e8 00 00 00 00	 call	 z900_program_interrupt
$LN17@z900_syncb:

; 563  :     }
; 564  : 
; 565  :     /* Set return code 8 and cond code 2 if blocksize is invalid */
; 566  :     if (!(blksize == 512 || blksize == 1024

  00298	81 bc 24 88 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR blksize$[rsp], 512 ; 00000200H
  002a3	74 4d		 je	 SHORT $LN19@z900_syncb
  002a5	81 bc 24 88 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR blksize$[rsp], 1024 ; 00000400H
  002b0	74 40		 je	 SHORT $LN19@z900_syncb
  002b2	81 bc 24 88 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR blksize$[rsp], 2048 ; 00000800H
  002bd	74 33		 je	 SHORT $LN19@z900_syncb
  002bf	81 bc 24 88 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR blksize$[rsp], 4096 ; 00001000H
  002ca	74 26		 je	 SHORT $LN19@z900_syncb

; 567  :             || blksize == 2048 || blksize == 4096))
; 568  :     {
; 569  :         regs->GR_L(15) = 8;

  002cc	b8 08 00 00 00	 mov	 eax, 8
  002d1	48 6b c0 0f	 imul	 rax, rax, 15
  002d5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002dd	c7 84 01 80 02
	00 00 08 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 8

; 570  :         return 2;

  002e8	b8 02 00 00 00	 mov	 eax, 2
  002ed	e9 19 08 00 00	 jmp	 $LN1@z900_syncb
$LN19@z900_syncb:

; 571  :     }
; 572  : 
; 573  :     /* Program check if SBILIST is not on a doubleword boundary */
; 574  :     if (sbiaddr & 0x00000007)

  002f2	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  002f9	83 e0 07	 and	 eax, 7
  002fc	85 c0		 test	 eax, eax
  002fe	74 12		 je	 SHORT $LN20@z900_syncb

; 575  :     {
; 576  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00300	ba 15 00 00 00	 mov	 edx, 21
  00305	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_syncb:

; 577  :     }
; 578  : 
; 579  :     /* Program check if reserved fields are not zero */
; 580  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  00312	c6 44 24 71 00	 mov	 BYTE PTR accum$[rsp], 0
  00317	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00322	eb 10		 jmp	 SHORT $LN7@z900_syncb
$LN5@z900_syncb:
  00324	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0032b	ff c0		 inc	 eax
  0032d	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_syncb:
  00334	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0033b	48 83 f8 05	 cmp	 rax, 5
  0033f	73 1e		 jae	 SHORT $LN6@z900_syncb

; 581  :         accum |= ioparm.resv1[i];

  00341	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00348	0f b6 84 04 d9
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  00350	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  00355	0b c8		 or	 ecx, eax
  00357	8b c1		 mov	 eax, ecx
  00359	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  0035d	eb c5		 jmp	 SHORT $LN5@z900_syncb
$LN6@z900_syncb:

; 582  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  0035f	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0036a	eb 10		 jmp	 SHORT $LN10@z900_syncb
$LN8@z900_syncb:
  0036c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00373	ff c0		 inc	 eax
  00375	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_syncb:
  0037c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00383	48 83 f8 18	 cmp	 rax, 24
  00387	73 1e		 jae	 SHORT $LN9@z900_syncb

; 583  :         accum |= ioparm.resv2[i];

  00389	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00390	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  00398	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  0039d	0b c8		 or	 ecx, eax
  0039f	8b c1		 mov	 eax, ecx
  003a1	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  003a5	eb c5		 jmp	 SHORT $LN8@z900_syncb
$LN9@z900_syncb:

; 584  :     if (accum != 0)

  003a7	0f b6 44 24 71	 movzx	 eax, BYTE PTR accum$[rsp]
  003ac	85 c0		 test	 eax, eax
  003ae	74 12		 je	 SHORT $LN21@z900_syncb

; 585  :     {
; 586  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  003b0	ba 15 00 00 00	 mov	 edx, 21
  003b5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bd	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_syncb:

; 587  :     }
; 588  : 
; 589  :     /* Set return code 11 and cond code 2 if SBI count is invalid */
; 590  :     if (sbicount < 1 || sbicount > 500)

  003c2	83 bc 24 a4 00
	00 00 01	 cmp	 DWORD PTR sbicount$[rsp], 1
  003ca	72 0d		 jb	 SHORT $LN23@z900_syncb
  003cc	81 bc 24 a4 00
	00 00 f4 01 00
	00		 cmp	 DWORD PTR sbicount$[rsp], 500 ; 000001f4H
  003d7	76 26		 jbe	 SHORT $LN22@z900_syncb
$LN23@z900_syncb:

; 591  :     {
; 592  :         regs->GR_L(15) = 11;

  003d9	b8 08 00 00 00	 mov	 eax, 8
  003de	48 6b c0 0f	 imul	 rax, rax, 15
  003e2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ea	c7 84 01 80 02
	00 00 0b 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 11

; 593  :         return 2;

  003f5	b8 02 00 00 00	 mov	 eax, 2
  003fa	e9 0c 07 00 00	 jmp	 $LN1@z900_syncb
$LN22@z900_syncb:

; 594  :     }
; 595  : 
; 596  :     /* Obtain the device lock */
; 597  :     obtain_lock (&dev->lock);

  003ff	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00404	48 83 c0 38	 add	 rax, 56			; 00000038H
  00408	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193728
  0040f	48 8b c8	 mov	 rcx, rax
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 598  : 
; 599  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 600  :     /* Return code 5 and condition code 1 if status pending */
; 601  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 602  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))

  00418	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0041d	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00424	83 e0 01	 and	 eax, 1
  00427	85 c0		 test	 eax, eax
  00429	75 13		 jne	 SHORT $LN25@z900_syncb
  0042b	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00430	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00437	83 e0 01	 and	 eax, 1
  0043a	85 c0		 test	 eax, eax
  0043c	74 3f		 je	 SHORT $LN24@z900_syncb
$LN25@z900_syncb:

; 603  :     {
; 604  :         release_lock (&dev->lock);

  0043e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00443	48 83 c0 38	 add	 rax, 56			; 00000038H
  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193731
  0044e	48 8b c8	 mov	 rcx, rax
  00451	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 605  :         regs->GR_L(15) = 5;

  00457	b8 08 00 00 00	 mov	 eax, 8
  0045c	48 6b c0 0f	 imul	 rax, rax, 15
  00460	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00468	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 606  :         return 1;

  00473	b8 01 00 00 00	 mov	 eax, 1
  00478	e9 8e 06 00 00	 jmp	 $LN1@z900_syncb
$LN24@z900_syncb:

; 607  :     }
; 608  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 609  : 
; 610  :     /* Return code 5 and condition code 1 if device is busy */
; 611  :     if (dev->busy || IOPENDING(dev))

  0047d	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00482	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00488	c1 e8 13	 shr	 eax, 19
  0048b	83 e0 01	 and	 eax, 1
  0048e	85 c0		 test	 eax, eax
  00490	75 54		 jne	 SHORT $LN27@z900_syncb
  00492	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00497	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0049d	c1 e8 16	 shr	 eax, 22
  004a0	83 e0 01	 and	 eax, 1
  004a3	85 c0		 test	 eax, eax
  004a5	75 3f		 jne	 SHORT $LN28@z900_syncb
  004a7	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004ac	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004b2	c1 e8 17	 shr	 eax, 23
  004b5	83 e0 01	 and	 eax, 1
  004b8	85 c0		 test	 eax, eax
  004ba	75 2a		 jne	 SHORT $LN28@z900_syncb
  004bc	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004c1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004c7	c1 e8 18	 shr	 eax, 24
  004ca	83 e0 01	 and	 eax, 1
  004cd	85 c0		 test	 eax, eax
  004cf	75 15		 jne	 SHORT $LN28@z900_syncb
  004d1	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004d6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004dc	c1 e8 1b	 shr	 eax, 27
  004df	83 e0 01	 and	 eax, 1
  004e2	85 c0		 test	 eax, eax
  004e4	74 3f		 je	 SHORT $LN26@z900_syncb
$LN28@z900_syncb:
$LN27@z900_syncb:

; 612  :     {
; 613  :         release_lock (&dev->lock);

  004e6	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004eb	48 83 c0 38	 add	 rax, 56			; 00000038H
  004ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193735
  004f6	48 8b c8	 mov	 rcx, rax
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 614  :         regs->GR_L(15) = 5;

  004ff	b8 08 00 00 00	 mov	 eax, 8
  00504	48 6b c0 0f	 imul	 rax, rax, 15
  00508	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00510	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 615  :         return 1;

  0051b	b8 01 00 00 00	 mov	 eax, 1
  00520	e9 e6 05 00 00	 jmp	 $LN1@z900_syncb
$LN26@z900_syncb:

; 616  :     }
; 617  : 
; 618  :     /* Set the device busy indicator */
; 619  :     dev->busy = 1;

  00525	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0052a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00530	0f ba e8 13	 bts	 eax, 19
  00534	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00539	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 620  : 
; 621  :     /* Release the device lock */
; 622  :     release_lock (&dev->lock);

  0053f	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00544	48 83 c0 38	 add	 rax, 56			; 00000038H
  00548	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193736
  0054f	48 8b c8	 mov	 rcx, rax
  00552	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 623  : 
; 624  :     /* Process each entry in the SBILIST */
; 625  :     for (blkcount = 0; blkcount < sbicount; blkcount++)

  00558	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR blkcount$[rsp], 0
  00563	eb 10		 jmp	 SHORT $LN13@z900_syncb
$LN11@z900_syncb:
  00565	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  0056c	ff c0		 inc	 eax
  0056e	89 84 24 90 00
	00 00		 mov	 DWORD PTR blkcount$[rsp], eax
$LN13@z900_syncb:
  00575	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR sbicount$[rsp]
  0057c	39 84 24 90 00
	00 00		 cmp	 DWORD PTR blkcount$[rsp], eax
  00583	0f 83 82 03 00
	00		 jae	 $LN12@z900_syncb

; 626  :     {
; 627  :         /* Return code 10 and cond code 2 if SBILIST entry
; 628  :            is outside main storage or is fetch protected.
; 629  :            Note that the SBI address is an absolute address
; 630  :            and is not subject to fetch-protection override
; 631  :            or storage-protection override mechanisms, and
; 632  :            an SBILIST entry cannot cross a page boundary */
; 633  :         if (sbiaddr > regs->mainlim
; 634  :             || ((ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_FETCH)

  00589	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00590	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00598	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0059f	77 46		 ja	 SHORT $LN30@z900_syncb
  005a1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005a8	8b c8		 mov	 ecx, eax
  005aa	e8 00 00 00 00	 call	 z900_get_storage_key
  005af	0f b6 c0	 movzx	 eax, al
  005b2	83 e0 08	 and	 eax, 8
  005b5	85 c0		 test	 eax, eax
  005b7	74 54		 je	 SHORT $LN29@z900_syncb
  005b9	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005c0	8b c8		 mov	 ecx, eax
  005c2	e8 00 00 00 00	 call	 z900_get_storage_key
  005c7	0f b6 c0	 movzx	 eax, al
  005ca	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005cf	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  005d7	3b c1		 cmp	 eax, ecx
  005d9	74 32		 je	 SHORT $LN29@z900_syncb
  005db	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  005e3	85 c0		 test	 eax, eax
  005e5	74 26		 je	 SHORT $LN29@z900_syncb
$LN30@z900_syncb:

; 635  :                 && (ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_KEY) != ioparm.akey
; 636  :                 && ioparm.akey != 0))
; 637  :         {
; 638  :             regs->GR_L(15) = 10;

  005e7	b8 08 00 00 00	 mov	 eax, 8
  005ec	48 6b c0 0f	 imul	 rax, rax, 15
  005f0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f8	c7 84 01 80 02
	00 00 0a 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 10

; 639  :             return 2;

  00603	b8 02 00 00 00	 mov	 eax, 2
  00608	e9 fe 04 00 00	 jmp	 $LN1@z900_syncb
$LN29@z900_syncb:

; 640  :         }
; 641  : 
; 642  :         /* Load block number and data address from SBILIST */
; 643  :         blknum = ARCH_DEP(fetch_fullword_absolute)(sbiaddr, regs);

  0060d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00614	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0061c	8b c8		 mov	 ecx, eax
  0061e	e8 00 00 00 00	 call	 z900_fetch_fullword_absolute
  00623	89 84 24 b4 00
	00 00		 mov	 DWORD PTR blknum$[rsp], eax

; 644  :         absadr = ARCH_DEP(fetch_fullword_absolute)(sbiaddr+4, regs);

  0062a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00631	83 c0 04	 add	 eax, 4
  00634	8b c0		 mov	 eax, eax
  00636	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0063e	8b c8		 mov	 ecx, eax
  00640	e8 00 00 00 00	 call	 z900_fetch_fullword_absolute
  00645	89 84 24 94 00
	00 00		 mov	 DWORD PTR absadr$[rsp], eax

; 645  : 
; 646  :         if (dev->ccwtrace)

  0064c	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00651	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00657	c1 e8 0f	 shr	 eax, 15
  0065a	83 e0 01	 and	 eax, 1
  0065d	85 c0		 test	 eax, eax
  0065f	0f 84 04 01 00
	00		 je	 $LN31@z900_syncb

; 647  :         {
; 648  :             WRMSG(HHC01952, "I",

  00665	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0066d	83 f8 01	 cmp	 eax, 1
  00670	75 11		 jne	 SHORT $LN45@z900_syncb
  00672	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193740
  00679	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00681	eb 0f		 jmp	 SHORT $LN46@z900_syncb
$LN45@z900_syncb:
  00683	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193741
  0068a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN46@z900_syncb:
  00692	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00698	74 12		 je	 SHORT $LN47@z900_syncb
  0069a	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0069f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006a3	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv341[rsp], eax
  006aa	eb 0b		 jmp	 SHORT $LN48@z900_syncb
$LN47@z900_syncb:
  006ac	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv341[rsp], 0
$LN48@z900_syncb:
  006b7	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006bd	74 14		 je	 SHORT $LN49@z900_syncb
  006bf	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  006c4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006c8	d1 f8		 sar	 eax, 1
  006ca	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv347[rsp], eax
  006d1	eb 0b		 jmp	 SHORT $LN50@z900_syncb
$LN49@z900_syncb:
  006d3	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv347[rsp], 0
$LN50@z900_syncb:
  006de	b9 01 00 00 00	 mov	 ecx, 1
  006e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  006f0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  006f4	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR absadr$[rsp]
  006fb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  006ff	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR blknum$[rsp]
  00706	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0070a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  00712	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00717	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv341[rsp]
  0071e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00722	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv347[rsp]
  00729	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0072d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193742
  00734	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00739	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193743
  00740	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00745	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0074a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00750	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193744
  00757	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  0075c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193745
  00763	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@z900_syncb:

; 649  :                     LCSS_DEVNUM,
; 650  :                     (ioparm.type == HCPSBIOP_WRITE ? "WRITE" : "READ"),
; 651  :                     blknum, absadr, blksize);
; 652  :         }
; 653  : 
; 654  :         /* Return code 12 and cond code 2 if buffer exceeds storage */
; 655  :         if (absadr > regs->mainlim - blksize)

  00769	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00770	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  00777	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0077f	48 8b 92 58 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2136]
  00786	48 2b d1	 sub	 rdx, rcx
  00789	48 8b ca	 mov	 rcx, rdx
  0078c	48 3b c1	 cmp	 rax, rcx
  0078f	76 26		 jbe	 SHORT $LN32@z900_syncb

; 656  :         {
; 657  :             regs->GR_L(15) = 12;

  00791	b8 08 00 00 00	 mov	 eax, 8
  00796	48 6b c0 0f	 imul	 rax, rax, 15
  0079a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a2	c7 84 01 80 02
	00 00 0c 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 12

; 658  :             return 2;

  007ad	b8 02 00 00 00	 mov	 eax, 2
  007b2	e9 54 03 00 00	 jmp	 $LN1@z900_syncb
$LN32@z900_syncb:

; 659  :         }
; 660  : 
; 661  :         /* Channel protection check if access key does not match
; 662  :            storage keys of buffer.  Note that the buffer address is
; 663  :            an absolute address, the buffer cannot span more than two
; 664  :            pages, and the access is not subject to fetch-protection
; 665  :            override, storage-protection override, or low-address
; 666  :            protection */
; 667  :         skey1 = ARCH_DEP( get_storage_key )( absadr );

  007b7	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  007be	8b c8		 mov	 ecx, eax
  007c0	e8 00 00 00 00	 call	 z900_get_storage_key
  007c5	88 84 24 80 00
	00 00		 mov	 BYTE PTR skey1$[rsp], al

; 668  :         skey2 = ARCH_DEP( get_storage_key )( absadr + blksize - 1 );

  007cc	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  007d3	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  007da	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  007de	8b c0		 mov	 eax, eax
  007e0	8b c8		 mov	 ecx, eax
  007e2	e8 00 00 00 00	 call	 z900_get_storage_key
  007e7	88 84 24 81 00
	00 00		 mov	 BYTE PTR skey2$[rsp], al

; 669  :         if (ioparm.akey != 0
; 670  :             && (

  007ee	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  007f6	85 c0		 test	 eax, eax
  007f8	74 7b		 je	 SHORT $LN33@z900_syncb
  007fa	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR skey1$[rsp]
  00802	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00807	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  0080f	3b c1		 cmp	 eax, ecx
  00811	74 1c		 je	 SHORT $LN35@z900_syncb
  00813	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR skey1$[rsp]
  0081b	83 e0 08	 and	 eax, 8
  0081e	85 c0		 test	 eax, eax
  00820	75 42		 jne	 SHORT $LN34@z900_syncb
  00822	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0082a	83 f8 02	 cmp	 eax, 2
  0082d	74 35		 je	 SHORT $LN34@z900_syncb
$LN35@z900_syncb:
  0082f	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR skey2$[rsp]
  00837	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0083c	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  00844	3b c1		 cmp	 eax, ecx
  00846	74 2d		 je	 SHORT $LN33@z900_syncb
  00848	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR skey2$[rsp]
  00850	83 e0 08	 and	 eax, 8
  00853	85 c0		 test	 eax, eax
  00855	75 0d		 jne	 SHORT $LN36@z900_syncb
  00857	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0085f	83 f8 02	 cmp	 eax, 2
  00862	75 11		 jne	 SHORT $LN33@z900_syncb
$LN36@z900_syncb:
$LN34@z900_syncb:

; 671  :                    ((skey1 & STORKEY_KEY) != ioparm.akey
; 672  :                     && ((skey1 & STORKEY_FETCH)
; 673  :                         || ioparm.type == HCPSBIOP_READ))
; 674  :                 || ((skey2 & STORKEY_KEY) != ioparm.akey
; 675  :                     && ((skey2 & STORKEY_FETCH)
; 676  :                         || ioparm.type == HCPSBIOP_READ))
; 677  :             ))
; 678  :         {
; 679  :             chanstat |= CSW_PROTC;

  00864	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00869	83 c8 10	 or	 eax, 16
  0086c	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al

; 680  :             break;

  00870	e9 96 00 00 00	 jmp	 $LN12@z900_syncb
$LN33@z900_syncb:

; 681  :         }
; 682  : 
; 683  :         /* Call device handler to read or write one block */
; 684  :         fbadasd_syncblk_io (dev, ioparm.type, blknum, blksize,

  00875	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  0087c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00884	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  0088b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR residual$[rsp]
  00893	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00898	48 8d 4c 24 72	 lea	 rcx, QWORD PTR unitstat$[rsp]
  0089d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a7	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR blksize$[rsp]
  008af	44 8b 84 24 b4
	00 00 00	 mov	 r8d, DWORD PTR blknum$[rsp]
  008b7	0f b6 94 24 c3
	00 00 00	 movzx	 edx, BYTE PTR ioparm$[rsp+3]
  008bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  008c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fbadasd_syncblk_io

; 685  :                             regs->mainstor + absadr,
; 686  :                             &unitstat, &residual);
; 687  : 
; 688  :         /* Set incorrect length if residual count is non-zero */
; 689  :         if (residual != 0)

  008ca	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR residual$[rsp], 0
  008d2	74 0c		 je	 SHORT $LN37@z900_syncb

; 690  :             chanstat |= CSW_IL;

  008d4	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  008d9	83 c8 40	 or	 eax, 64			; 00000040H
  008dc	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al
$LN37@z900_syncb:

; 691  : 
; 692  :         /* Exit if any unusual status */
; 693  :         if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  008e0	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  008e5	83 f8 0c	 cmp	 eax, 12
  008e8	75 09		 jne	 SHORT $LN39@z900_syncb
  008ea	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  008ef	85 c0		 test	 eax, eax
  008f1	74 02		 je	 SHORT $LN38@z900_syncb
$LN39@z900_syncb:

; 694  :             break;

  008f3	eb 16		 jmp	 SHORT $LN12@z900_syncb
$LN38@z900_syncb:

; 695  : 
; 696  :         /* Point to next SBILIST entry */
; 697  :         sbiaddr += 8;

  008f5	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  008fc	83 c0 08	 add	 eax, 8
  008ff	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 698  : 
; 699  :     } /* end for(blkcount) */

  00906	e9 5a fc ff ff	 jmp	 $LN11@z900_syncb
$LN12@z900_syncb:

; 700  : 
; 701  :     /* Reset the device busy indicator */
; 702  :     dev->busy = 0;

  0090b	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00910	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00916	0f ba f0 13	 btr	 eax, 19
  0091a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  0091f	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 703  : 
; 704  :     /* Store the block count in the parameter list */
; 705  :     ioparm.blkcount[0] = (blkcount >> 24) & 0xFF;

  00925	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  0092c	c1 e8 18	 shr	 eax, 24
  0092f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00934	b9 01 00 00 00	 mov	 ecx, 1
  00939	48 6b c9 00	 imul	 rcx, rcx, 0
  0093d	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 706  :     ioparm.blkcount[1] = (blkcount >> 16) & 0xFF;

  00944	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  0094b	c1 e8 10	 shr	 eax, 16
  0094e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00953	b9 01 00 00 00	 mov	 ecx, 1
  00958	48 6b c9 01	 imul	 rcx, rcx, 1
  0095c	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 707  :     ioparm.blkcount[2] = (blkcount >> 8) & 0xFF;

  00963	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  0096a	c1 e8 08	 shr	 eax, 8
  0096d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00972	b9 01 00 00 00	 mov	 ecx, 1
  00977	48 6b c9 02	 imul	 rcx, rcx, 2
  0097b	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 708  :     ioparm.blkcount[3] = blkcount & 0xFF;

  00982	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00989	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0098e	b9 01 00 00 00	 mov	 ecx, 1
  00993	48 6b c9 03	 imul	 rcx, rcx, 3
  00997	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 709  : 
; 710  :     /* Store the device and subchannel status in the parameter list */
; 711  :     ioparm.unitstat = unitstat;

  0099e	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  009a3	88 84 24 d4 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+20], al

; 712  :     ioparm.chanstat = chanstat;

  009aa	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  009af	88 84 24 d5 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+21], al

; 713  : 
; 714  :     /* Store the residual byte count in the parameter list */
; 715  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  009b6	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  009bd	c1 e8 08	 shr	 eax, 8
  009c0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009c5	b9 01 00 00 00	 mov	 ecx, 1
  009ca	48 6b c9 00	 imul	 rcx, rcx, 0
  009ce	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 716  :     ioparm.residual[1] = residual & 0xFF;

  009d5	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  009dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009e1	b9 01 00 00 00	 mov	 ecx, 1
  009e6	48 6b c9 01	 imul	 rcx, rcx, 1
  009ea	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 717  : 
; 718  :     /* Return sense data if unit check occurred */
; 719  :     if (unitstat & CSW_UC)

  009f1	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  009f6	83 e0 02	 and	 eax, 2
  009f9	85 c0		 test	 eax, eax
  009fb	0f 84 8a 00 00
	00		 je	 $LN40@z900_syncb

; 720  :     {
; 721  :         numsense = dev->numsense;

  00a01	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00a06	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00a0c	89 84 24 98 00
	00 00		 mov	 DWORD PTR numsense$[rsp], eax

; 722  :         if (numsense > sizeof(ioparm.sense))

  00a13	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a1a	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00a1e	76 0b		 jbe	 SHORT $LN41@z900_syncb

; 723  :             numsense = sizeof(ioparm.sense);

  00a20	c7 84 24 98 00
	00 00 20 00 00
	00		 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN41@z900_syncb:

; 724  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  00a2b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a32	c1 e8 08	 shr	 eax, 8
  00a35	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a3a	b9 01 00 00 00	 mov	 ecx, 1
  00a3f	48 6b c9 00	 imul	 rcx, rcx, 0
  00a43	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 725  :         ioparm.sensecount[1] = numsense & 0xFF;

  00a4a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a51	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a56	b9 01 00 00 00	 mov	 ecx, 1
  00a5b	48 6b c9 01	 imul	 rcx, rcx, 1
  00a5f	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 726  :         memcpy (ioparm.sense, dev->sense, numsense);

  00a66	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a6d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00a72	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00a79	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  00a81	48 8b fa	 mov	 rdi, rdx
  00a84	48 8b f1	 mov	 rsi, rcx
  00a87	8b c8		 mov	 ecx, eax
  00a89	f3 a4		 rep movsb
$LN40@z900_syncb:

; 727  :     }
; 728  : 
; 729  :     /* Store the updated parameter list in real storage */
; 730  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00a8b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  00a92	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a9a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a9f	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00aa5	44 8b c0	 mov	 r8d, eax
  00aa8	b2 57		 mov	 dl, 87			; 00000057H
  00aaa	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  00ab2	e8 00 00 00 00	 call	 z900_vstorec

; 731  : 
; 732  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 733  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00ab7	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00abc	83 f8 0c	 cmp	 eax, 12
  00abf	75 09		 jne	 SHORT $LN43@z900_syncb
  00ac1	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00ac6	85 c0		 test	 eax, eax
  00ac8	74 23		 je	 SHORT $LN42@z900_syncb
$LN43@z900_syncb:

; 734  :     {
; 735  :         regs->GR_L(15) = 13;

  00aca	b8 08 00 00 00	 mov	 eax, 8
  00acf	48 6b c0 0f	 imul	 rax, rax, 15
  00ad3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00adb	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 736  :         return 3;

  00ae6	b8 03 00 00 00	 mov	 eax, 3
  00aeb	eb 1e		 jmp	 SHORT $LN1@z900_syncb
$LN42@z900_syncb:

; 737  :     }
; 738  : 
; 739  :     /* Set return code 0 and cond code 0 */
; 740  :     regs->GR_L(15) = 0;

  00aed	b8 08 00 00 00	 mov	 eax, 8
  00af2	48 6b c0 0f	 imul	 rax, rax, 15
  00af6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00afe	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 741  :     return 0;

  00b09	33 c0		 xor	 eax, eax
$LN1@z900_syncb:

; 742  : 
; 743  : } /* end function syncblk_io */

  00b0b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b13	48 33 cc	 xor	 rcx, rsp
  00b16	e8 00 00 00 00	 call	 __security_check_cookie
  00b1b	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00b22	5f		 pop	 rdi
  00b23	5e		 pop	 rsi
  00b24	c3		 ret	 0
z900_syncblk_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
vdat$ = 36
rdat$ = 40
dev$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
z900_diag_devtype PROC

; 434  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 435  : DEVBLK         *dev;                    /* -> Device block           */
; 436  : U16             devnum;                 /* Device number             */
; 437  : VRDCVDAT        vdat;                   /* Virtual device data       */
; 438  : VRDCRCDT        rdat;                   /* Real device data          */
; 439  : 
; 440  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 441  :      /* Program check if 64-bit addressing is being used. */
; 442  :      if (regs->psw.amode64)

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001c	83 e0 01	 and	 eax, 1
  0001f	85 c0		 test	 eax, eax
  00021	74 0f		 je	 SHORT $LN5@z900_diag_

; 443  :      {
; 444  :          ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00023	ba 06 00 00 00	 mov	 edx, 6
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN5@z900_diag_:

; 445  :      }
; 446  : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 447  : 
; 448  :     /* Return console information if R1 register is all ones */
; 449  :     if (regs->GR_L(r1) == 0xFFFFFFFF)

  00032	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	83 bc c1 80 02
	00 00 ff	 cmp	 DWORD PTR [rcx+rax*8+640], -1 ; ffffffffH
  00044	75 74		 jne	 SHORT $LN6@z900_diag_

; 450  :     {
; 451  :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00046	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004d	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00054	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  00059	eb 0e		 jmp	 SHORT $LN4@z900_diag_
$LN2@z900_diag_:
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00060	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00064	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@z900_diag_:
  00069	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0006f	74 49		 je	 SHORT $LN3@z900_diag_

; 452  :             if ( dev->allocated
; 453  :                  && ( dev->devtype == 0x3215 || dev->devtype == 0x1503 )

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00076	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0007a	74 3c		 je	 SHORT $LN7@z900_diag_
  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00081	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00085	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  0008a	74 10		 je	 SHORT $LN8@z900_diag_
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00091	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00095	3d 03 15 00 00	 cmp	 eax, 5379		; 00001503H
  0009a	75 1c		 jne	 SHORT $LN7@z900_diag_
$LN8@z900_diag_:

; 454  :                )
; 455  :             {
; 456  :                 regs->GR_L(r1) = dev->devnum;

  0009c	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000a6	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000aa	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	89 8c c2 80 02
	00 00		 mov	 DWORD PTR [rdx+rax*8+640], ecx

; 457  :                 break;

  000b6	eb 02		 jmp	 SHORT $LN3@z900_diag_
$LN7@z900_diag_:

; 458  :             }

  000b8	eb a1		 jmp	 SHORT $LN2@z900_diag_
$LN3@z900_diag_:
$LN6@z900_diag_:

; 459  :     }
; 460  : 
; 461  :     /* Extract the device number from the R1 register */
; 462  :     devnum = regs->GR_L(r1);

  000ba	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000cc	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 463  : 
; 464  :     /* Locate the device block and set the virtual and real device information */
; 465  :     dev = ARCH_DEP(vmdevice_data) (0x24,devnum,&vdat,&rdat);

  000d1	4c 8d 4c 24 28	 lea	 r9, QWORD PTR rdat$[rsp]
  000d6	4c 8d 44 24 24	 lea	 r8, QWORD PTR vdat$[rsp]
  000db	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  000e0	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  000e5	e8 00 00 00 00	 call	 z900_vmdevice_data
  000ea	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 466  : 
; 467  :     /* Return condition code 3 if device does not exist */
; 468  :     if (!dev)

  000ef	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000f5	75 07		 jne	 SHORT $LN9@z900_diag_

; 469  :         return 3;

  000f7	b8 03 00 00 00	 mov	 eax, 3
  000fc	eb 51		 jmp	 SHORT $LN1@z900_diag_
$LN9@z900_diag_:

; 470  : 
; 471  :     /* Return virtual device information in the R2 register */
; 472  :     FETCH_FW(regs->GR_L(r2),&vdat);

  000fe	48 8d 4c 24 24	 lea	 rcx, QWORD PTR vdat$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_fw_noswap
  00108	8b c8		 mov	 ecx, eax
  0010a	e8 00 00 00 00	 call	 _byteswap_ulong
  0010f	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00114	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00119	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 473  : 
; 474  :     /* Return real device information in the R2+1 register */
; 475  :     if (r2 != 15)

  00120	83 7c 24 58 0f	 cmp	 DWORD PTR r2$[rsp], 15
  00125	74 26		 je	 SHORT $LN10@z900_diag_

; 476  :         FETCH_FW(regs->GR_L(r2+1),&rdat);

  00127	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rdat$[rsp]
  0012c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00131	8b c8		 mov	 ecx, eax
  00133	e8 00 00 00 00	 call	 _byteswap_ulong
  00138	8b 4c 24 58	 mov	 ecx, DWORD PTR r2$[rsp]
  0013c	ff c1		 inc	 ecx
  0013e	48 63 c9	 movsxd	 rcx, ecx
  00141	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00146	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN10@z900_diag_:

; 477  : #if 0 // debug
; 478  :     LOGMSG( "Diagnose X'024':devnum=%4.4X VRDCVDAT=%8.8X VRDCRCDT=%8.8X\n",
; 479  :             devnum, vdat, rdat );
; 480  : #endif
; 481  : 
; 482  :     /* Return condition code 0 */
; 483  :     return 0;

  0014d	33 c0		 xor	 eax, eax
$LN1@z900_diag_:

; 484  : 
; 485  : } /* end function diag_devtype */

  0014f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00153	c3		 ret	 0
z900_diag_devtype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 32
tv170 = 36
dev$ = 40
vmentry$ = 48
code$ = 80
devnum$ = 88
vdat$ = 96
rdat$ = 104
s390_vmdevice_data PROC

; 298  : {

$LN33:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 299  : U32      i;                      /* loop index                      */
; 300  : VMDEVTBL *vmentry;               /* -> VMDEVTBL entry found         */
; 301  : DEVBLK   *dev;                   /* -> DEVBLK                       */
; 302  : 
; 303  :     /* Clear vdat and rdat */
; 304  :     memset (vdat, 0, sizeof(*vdat));

  00018	48 8b 7c 24 60	 mov	 rdi, QWORD PTR vdat$[rsp]
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	f3 aa		 rep stosb

; 305  :     memset (rdat, 0, sizeof(*rdat));

  00026	48 8b 7c 24 68	 mov	 rdi, QWORD PTR rdat$[rsp]
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 04 00 00 00	 mov	 ecx, 4
  00032	f3 aa		 rep stosb

; 306  : 
; 307  :     /* Locate the device block */
; 308  :     dev = find_device_by_devnum (0,devnum);

  00034	0f b7 54 24 58	 movzx	 edx, WORD PTR devnum$[rsp]
  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 find_device_by_devnum
  00040	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 309  : 
; 310  :     /* Return 0 if device is not found */
; 311  :     if (!dev)

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0004b	75 07		 jne	 SHORT $LN7@s390_vmdev

; 312  :        return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 cf 03 00 00	 jmp	 $LN1@s390_vmdev
$LN7@s390_vmdev:

; 313  : 
; 314  :     /* Indicate the device is dedicated - all Hercules devices are */
; 315  :     vdat->vdevstat = DS_DED;

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00059	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 316  : 
; 317  :     /* Find the device in the VM table */
; 318  :     vmentry=NULL;

  0005d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR vmentry$[rsp], 0

; 319  :     for (i = 0; i < (int)VMDEV_NUM; i++)

  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006e	eb 0a		 jmp	 SHORT $LN4@s390_vmdev
$LN2@s390_vmdev:
  00070	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00074	ff c0		 inc	 eax
  00076	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_vmdev:
  0007a	83 7c 24 20 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  0007f	73 3e		 jae	 SHORT $LN3@s390_vmdev

; 320  :        {
; 321  : #if 0 // debug
; 322  :            LOGMSG( "vmdevice_data: i=%i %4.4X %2.2X %2.2X %2.2X\n",i,
; 323  :                    vmdev[i].vmhtype, vmdev[i].vmdevcls, vmdev[i].vmdevtyp, vmdev[i].vmdiags );
; 324  : #endif
; 325  :            if (dev->devtype == vmdev[i].vmhtype)

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0008a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0008e	48 6b c9 06	 imul	 rcx, rcx, 6
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:vmdev
  00099	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0009d	3b c1		 cmp	 eax, ecx
  0009f	75 1c		 jne	 SHORT $LN8@s390_vmdev

; 326  :            {
; 327  :                vmentry = &vmdev[i];

  000a1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a5	48 6b c0 06	 imul	 rax, rax, 6
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:vmdev
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 89 44 24 30	 mov	 QWORD PTR vmentry$[rsp], rax

; 328  :                break;

  000bb	eb 02		 jmp	 SHORT $LN3@s390_vmdev
$LN8@s390_vmdev:

; 329  :            }
; 330  :        }

  000bd	eb b1		 jmp	 SHORT $LN2@s390_vmdev
$LN3@s390_vmdev:

; 331  : #if 0 // debug
; 332  :     LOGMSG( "FOUND: %4.4X %2.2X %2.2X %2.2X\n",
; 333  :             vmentry->vmhtype, vmentry->vmdevcls, vmentry->vmdevtyp, vmentry->vmdiags );
; 334  : #endif
; 335  : 
; 336  :     /* If device is not in the table or it isn't recognized by DIAG X'24' */
; 337  :     if ( !vmentry || ( code==0x24 && !(vmentry->vmdiags & VMDIAG024 ) ) )

  000bf	48 83 7c 24 30
	00		 cmp	 QWORD PTR vmentry$[rsp], 0
  000c5	74 19		 je	 SHORT $LN10@s390_vmdev
  000c7	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  000cc	75 3e		 jne	 SHORT $LN9@s390_vmdev
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR vmentry$[rsp]
  000d3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000d7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN9@s390_vmdev
$LN10@s390_vmdev:

; 338  :     {
; 339  :         /* Set the real and virtual data to an unsupported device */
; 340  :         vdat->vdevcls = DC_SPEC;

  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000e5	c6 00 02	 mov	 BYTE PTR [rax], 2

; 341  :         vdat->vdevtyp = DT_UNKN;

  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000ed	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 342  :         rdat->rdevcls = DC_SPEC;

  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000f6	c6 00 02	 mov	 BYTE PTR [rax], 2

; 343  :         rdat->rdevtyp = DT_UNKN;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000fe	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 344  :         return dev;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00107	e9 17 03 00 00	 jmp	 $LN1@s390_vmdev
$LN9@s390_vmdev:

; 345  :     }
; 346  : 
; 347  :     /* Set the virtual and real data to the device's VM class and type */
; 348  :     vdat->vdevcls = vmentry->vmdevcls;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00116	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0011a	88 08		 mov	 BYTE PTR [rax], cl

; 349  :     vdat->vdevtyp = vmentry->vmdevtyp;

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00121	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00126	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0012a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 350  :     rdat->rdevcls = vmentry->vmdevcls;

  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00137	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0013b	88 08		 mov	 BYTE PTR [rax], cl

; 351  :     rdat->rdevtyp = vmentry->vmdevtyp;

  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00147	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0014b	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 352  : 
; 353  :     /* Indicate if the device is busy */
; 354  :     if (0
; 355  :         || dev->startpending
; 356  :         || (1

  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 42		 jne	 SHORT $LN12@s390_vmdev
  00154	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00159	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0015f	c1 e8 19	 shr	 eax, 25
  00162	83 e0 01	 and	 eax, 1
  00165	85 c0		 test	 eax, eax
  00167	75 2d		 jne	 SHORT $LN12@s390_vmdev
  00169	33 c0		 xor	 eax, eax
  0016b	83 f8 01	 cmp	 eax, 1
  0016e	74 3a		 je	 SHORT $LN11@s390_vmdev
  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00175	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0017b	c1 e8 13	 shr	 eax, 19
  0017e	83 e0 01	 and	 eax, 1
  00181	85 c0		 test	 eax, eax
  00183	74 25		 je	 SHORT $LN11@s390_vmdev
  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00194	75 14		 jne	 SHORT $LN11@s390_vmdev
$LN12@s390_vmdev:

; 357  :             && dev->busy
; 358  : #if defined( OPTION_SHARED_DEVICES )
; 359  :             && dev->shioactive == DEV_SYS_LOCAL
; 360  : #endif // defined( OPTION_SHARED_DEVICES )
; 361  :            )
; 362  :     )
; 363  :         vdat->vdevstat |= DS_BUSY;

  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  0019b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0019f	83 c8 20	 or	 eax, 32			; 00000020H
  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001a7	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN11@s390_vmdev:

; 364  : 
; 365  :     /* Set virtual device flags, and real device model and features */
; 366  :     vdat->vdevflag = 0x00;

  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001af	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 367  :     rdat->rdevmodl = 0x00;

  001b3	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001b8	c6 40 02 00	 mov	 BYTE PTR [rax+2], 0

; 368  :     rdat->rdevfeat = 0x00;

  001bc	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001c1	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 369  : 
; 370  :     if (dev->hnd->reserve)           /* Indicate if RESERVE/RELEASE supported */

  001c5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  001d1	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001d6	74 14		 je	 SHORT $LN13@s390_vmdev

; 371  :         vdat->vdevflag |= DF_RSRL;

  001d8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001dd	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e1	83 c8 02	 or	 eax, 2
  001e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001e9	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN13@s390_vmdev:

; 372  : 
; 373  : #if defined(FEATURE_MIDAW_FACILITY)
; 374  :     /* If DIAGNOSE X'210', indicate if MIDAW's are supported */
; 375  :     if (code==0x210)
; 376  :         vdat->vdevflag |= DF_MIDAW;
; 377  : #endif /* FEATURE_MIDAW_FACILITY */
; 378  : 
; 379  :     switch (rdat->rdevcls) {

  001ec	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f4	88 44 24 24	 mov	 BYTE PTR tv170[rsp], al
  001f8	80 7c 24 24 01	 cmp	 BYTE PTR tv170[rsp], 1
  001fd	0f 84 4c 01 00
	00		 je	 $LN23@s390_vmdev
  00203	80 7c 24 24 02	 cmp	 BYTE PTR tv170[rsp], 2
  00208	0f 84 f7 01 00
	00		 je	 $LN30@s390_vmdev
  0020e	80 7c 24 24 04	 cmp	 BYTE PTR tv170[rsp], 4
  00213	74 10		 je	 SHORT $LN14@s390_vmdev
  00215	80 7c 24 24 80	 cmp	 BYTE PTR tv170[rsp], 128 ; 00000080H
  0021a	0f 84 4c 01 00
	00		 je	 $LN24@s390_vmdev
  00220	e9 f9 01 00 00	 jmp	 $LN5@s390_vmdev
$LN14@s390_vmdev:

; 380  :     case DC_DASD:
; 381  :          if (dev->hnd->reserve)

  00225	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00231	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00236	74 14		 je	 SHORT $LN15@s390_vmdev

; 382  :             rdat->rdevfeat |= DRF_RSRL;

  00238	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0023d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00241	83 c8 02	 or	 eax, 2
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00249	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN15@s390_vmdev:

; 383  :          if (dev->numsense==24)

  0024c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00251	83 b8 60 03 00
	00 18		 cmp	 DWORD PTR [rax+864], 24
  00258	75 14		 jne	 SHORT $LN16@s390_vmdev

; 384  :             rdat->rdevfeat |= DRF_EXTSNS;

  0025a	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0025f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00263	83 c8 40	 or	 eax, 64			; 00000040H
  00266	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0026b	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN16@s390_vmdev:

; 385  :          if (dev->ckdtab->sectors)

  0026e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00273	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0027a	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  0027e	85 c0		 test	 eax, eax
  00280	74 15		 je	 SHORT $LN17@s390_vmdev

; 386  :             rdat->rdevfeat |= DRF_RPS;

  00282	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00287	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0028b	0f ba e8 07	 bts	 eax, 7
  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00294	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN17@s390_vmdev:

; 387  :          if (dev->devtype == 0x3340)

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0029c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002a0	3d 40 33 00 00	 cmp	 eax, 13120		; 00003340H
  002a5	75 3f		 jne	 SHORT $LN18@s390_vmdev

; 388  :          {
; 389  :             if (dev->ckdtab->model==0x01)

  002a7	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ac	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002b3	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  002b7	83 f8 01	 cmp	 eax, 1
  002ba	75 16		 jne	 SHORT $LN19@s390_vmdev

; 390  :                rdat->rdevfeat |= DRF_35M;

  002bc	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002c1	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002c5	83 c8 08	 or	 eax, 8
  002c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002cd	88 41 03	 mov	 BYTE PTR [rcx+3], al
  002d0	eb 14		 jmp	 SHORT $LN20@s390_vmdev
$LN19@s390_vmdev:

; 391  :             else
; 392  :                rdat->rdevfeat |= DRF_70M;

  002d2	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002d7	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002db	83 c8 04	 or	 eax, 4
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002e3	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN20@s390_vmdev:
$LN18@s390_vmdev:

; 393  :          }
; 394  :          if ( dev->devtype == 0x3380  && code == 0x24)

  002e6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002eb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002ef	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  002f4	75 3c		 jne	 SHORT $LN21@s390_vmdev
  002f6	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  002fb	75 35		 jne	 SHORT $LN21@s390_vmdev

; 395  :             rdat->rdevmodl = (dev->ckdtab->model & 0x0F) | (dev->ckdcu->model & 0xF0);

  002fd	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00302	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00309	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  0030d	83 e0 0f	 and	 eax, 15
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  0031c	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  00320	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00326	0b c1		 or	 eax, ecx
  00328	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0032d	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00330	eb 18		 jmp	 SHORT $LN22@s390_vmdev
$LN21@s390_vmdev:

; 396  :          else
; 397  :             rdat->rdevmodl = dev->ckdtab->model;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00337	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0033e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00343	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00347	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN22@s390_vmdev:

; 398  :          break;

  0034a	e9 cf 00 00 00	 jmp	 $LN5@s390_vmdev
$LN23@s390_vmdev:

; 399  :      case DC_FBA:
; 400  :          rdat->rdevmodl = dev->fbatab->model;

  0034f	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00354	48 8b 80 80 11
	00 00		 mov	 rax, QWORD PTR [rax+4480]
  0035b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00360	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00364	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 401  :          break;

  00367	e9 b2 00 00 00	 jmp	 $LN5@s390_vmdev
$LN24@s390_vmdev:

; 402  :      case DC_TERM:
; 403  :          if (dev->devtype==0x3215)

  0036c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00371	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00375	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  0037a	75 0b		 jne	 SHORT $LN25@s390_vmdev

; 404  :          {
; 405  :             rdat->rdevfeat = 0x50;

  0037c	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00381	c6 40 03 50	 mov	 BYTE PTR [rax+3], 80	; 00000050H

; 406  :             /* Note: 0x50 is carried forward from the previous version of       */
; 407  :             /* DIAGNOSE X'24'. The actual meaning was not previously documented */
; 408  :          }

  00385	eb 7c		 jmp	 SHORT $LN26@s390_vmdev
$LN25@s390_vmdev:

; 409  :          else
; 410  :          {
; 411  :             if (dev->devtype==0x2703 && dev->commadpt)

  00387	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0038c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00390	3d 03 27 00 00	 cmp	 eax, 9987		; 00002703H
  00395	75 6c		 jne	 SHORT $LN27@s390_vmdev
  00397	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0039c	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  003a4	74 5d		 je	 SHORT $LN27@s390_vmdev

; 412  :             {
; 413  :                 if (dev->commadpt->enabled)

  003a6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003ab	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003b2	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  003b8	83 e0 01	 and	 eax, 1
  003bb	85 c0		 test	 eax, eax
  003bd	74 15		 je	 SHORT $LN28@s390_vmdev

; 414  :                    vdat->vdevflag |= DF_ENA;

  003bf	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  003c4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003c8	0f ba e8 07	 bts	 eax, 7
  003cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  003d1	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN28@s390_vmdev:

; 415  :                 if (dev->commadpt->connect)

  003d4	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003d9	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003e0	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  003e6	d1 e8		 shr	 eax, 1
  003e8	83 e0 01	 and	 eax, 1
  003eb	85 c0		 test	 eax, eax
  003ed	74 14		 je	 SHORT $LN29@s390_vmdev

; 416  :                    vdat->vdevflag |= DF_CONN;

  003ef	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  003f4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003f8	83 c8 40	 or	 eax, 64			; 00000040H
  003fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  00400	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN29@s390_vmdev:
$LN27@s390_vmdev:
$LN26@s390_vmdev:

; 417  :             }
; 418  :          }
; 419  :          break;

  00403	eb 19		 jmp	 SHORT $LN5@s390_vmdev
$LN30@s390_vmdev:

; 420  :      case DC_SPEC:
; 421  :          if (rdat->rdevtyp==DT_CTCA)

  00405	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0040a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0040e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00413	75 09		 jne	 SHORT $LN31@s390_vmdev

; 422  :             rdat->rdevfeat = DRF_CTCA;

  00415	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0041a	c6 40 03 40	 mov	 BYTE PTR [rax+3], 64	; 00000040H
$LN31@s390_vmdev:
$LN5@s390_vmdev:

; 423  :      }
; 424  : 
; 425  :      /* Return the located DEVBLK to the caller */
; 426  :      return dev;

  0041e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@s390_vmdev:

; 427  : 
; 428  : } /* end function vmdevice_data */

  00423	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00427	5f		 pop	 rdi
  00428	c3		 ret	 0
s390_vmdevice_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l
  00043	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
s390_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s390_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_main_absolute
_TEXT	SEGMENT
tv128 = 48
addr$ = 80
regs$ = 88
s390_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 ca 00 00
	00		 je	 $LN5@s390_fetch
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	0f 85 b1 00 00
	00		 jne	 $LN5@s390_fetch
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0004b	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0004f	75 44		 jne	 SHORT $LN7@s390_fetch
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00056	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0005d	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  00062	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0006b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00070	41 b9 04 00 00
	00		 mov	 r9d, 4
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00082	ba fd ff ff ff	 mov	 edx, -3
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0008e	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00093	eb 43		 jmp	 SHORT $LN8@s390_fetch
$LN7@s390_fetch:
  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a1	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  000a6	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b4	41 b9 04 00 00
	00		 mov	 r9d, 4
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d3	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_fetch:
  000d8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e4	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000eb	48 89 44 24 50	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_fetch:
  000f0	33 c0		 xor	 eax, eax
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  000fa	b2 04		 mov	 dl, 4
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00101	e8 00 00 00 00	 call	 s390_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00112	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
s390_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
s390_put_storage_key PROC				; COMDAT

; 272  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 273  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 274  :     ARCH_DEP( put_2K_storage_key )( abs, key );
; 275  : #else
; 276  :     ARCH_DEP( put_4K_storage_key )( abs, key );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR key$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_put_4K_storage_key

; 277  : #endif
; 278  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_storage_key
_TEXT	SEGMENT
abs$ = 48
s390_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_get_4K_storage_key

; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s390_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_put_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
s390_put_4K_storage_key PROC				; COMDAT

; 240  :   inline void  ARCH_DEP( put_4K_storage_key )     (              U64 abs, BYTE key  ) {        ARCH_DEP( _put_storage_key     )(      abs, key  & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR key$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__put_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_put_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
s390_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s390__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s390_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
K$ = 64
s390__put_storage_key PROC				; COMDAT

; 158  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@s390__put_:

; 159  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__put_

; 160  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 24		 je	 SHORT $LN5@s390__put_

; 161  :     {
; 162  :         *_get_storekey1_ptr( abs ) = key;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  0002d	88 08		 mov	 BYTE PTR [rax], cl

; 163  :         *_get_storekey2_ptr( abs ) = key;

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00034	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00039	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  0003e	88 08		 mov	 BYTE PTR [rax], cl

; 164  :     }

  00040	eb 16		 jmp	 SHORT $LN6@s390__put_
$LN5@s390__put_:

; 165  :     else
; 166  :     {
; 167  :         *_get_storekey_ptr(  abs, K ) = key;

  00042	0f b6 54 24 40	 movzx	 edx, BYTE PTR K$[rsp]
  00047	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0004c	e8 00 00 00 00	 call	 _get_storekey_ptr
  00051	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  00056	88 08		 mov	 BYTE PTR [rax], cl
$LN6@s390__put_:

; 168  :     }
; 169  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
s390__put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s390__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s390__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@s390__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@s390__get_
$LN5@s390__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s390__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
s390__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
effective_addr2$ = 64
b2$ = 68
temp$1 = 72
inst$ = 96
regs$ = 104
s390_inter_user_communication_vehicle PROC

; 1686 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1687 : int     b2;                             /* Effective addr base       */
; 1688 : VADR    effective_addr2;                /* Effective address         */
; 1689 : 
; 1690 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN11@s390_inter
  00045	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s390_inter:
$LN4@s390_inter:
  00079	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN12@s390_inter
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN12@s390_inter:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_inter

; 1691 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 1692 : 
; 1693 : #if defined(FEATURE_ECPSVM)
; 1694 :     if(ecpsvm_doiucv(regs,b2,effective_addr2)==0)
; 1695 :     {
; 1696 :         return;
; 1697 :     }
; 1698 : #endif
; 1699 : 
; 1700 :     /* Program check if in problem state,
; 1701 :        the IUCV instruction generates an operation exception
; 1702 :        rather then a priviliged operation exception when
; 1703 :        executed in problem state                                 *JJ */
; 1704 :     if ( PROBSTATE(&regs->psw) )

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 0f		 je	 SHORT $LN13@s390_inter

; 1705 :         ARCH_DEP(program_interrupt) (regs, PGM_OPERATION_EXCEPTION);

  000b8	ba 01 00 00 00	 mov	 edx, 1
  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	e8 00 00 00 00	 call	 s390_program_interrupt
$LN13@s390_inter:
$LN7@s390_inter:

; 1706 : 
; 1707 :     SIE_INTERCEPT(regs);

  000c7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d2	d1 e8		 shr	 eax, 1
  000d4	83 e0 01	 and	 eax, 1
  000d7	85 c0		 test	 eax, eax
  000d9	74 18		 je	 SHORT $LN14@s390_inter
  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e6	ba fc ff ff ff	 mov	 edx, -4
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	e8 00 00 00 00	 call	 longjmp
$LN14@s390_inter:
  000f3	33 c0		 xor	 eax, eax
  000f5	85 c0		 test	 eax, eax
  000f7	75 ce		 jne	 SHORT $LN7@s390_inter
$LN10@s390_inter:

; 1708 : 
; 1709 :     PTT_ERR("*IUCV",b2,effective_addr2,regs->psw.IA_L);

  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00100	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00103	48 83 e0 10	 and	 rax, 16
  00107	48 85 c0	 test	 rax, rax
  0010a	74 46		 je	 SHORT $LN15@s390_inter
  0010c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00111	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00117	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011b	48 63 54 24 44	 movsxd	 rdx, DWORD PTR b2$[rsp]
  00120	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00129	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0012e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180710
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	44 8b c9	 mov	 r9d, ecx
  0013d	4c 8b c2	 mov	 r8, rdx
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180711
  00147	b9 10 00 00 00	 mov	 ecx, 16
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@s390_inter:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 a1		 jne	 SHORT $LN10@s390_inter

; 1710 : 
; 1711 :     /* Set condition code to indicate IUCV not available */
; 1712 :     regs->psw.cc = 3;

  00158	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN16@s390_inter:

; 1713 : }

  00161	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00165	c3		 ret	 0
s390_inter_user_communication_vehicle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 48
buflen$ = 52
bufadr$ = 56
timeval$ = 64
tmptr$ = 72
buf$ = 80
dattim$ = 144
__$ArrayPad$ = 208
code$ = 256
r1$ = 264
r2$ = 272
regs$ = 280
s390_pseudo_timer PROC

; 1508 : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1509 : int     i;                              /* Array subscript           */
; 1510 : time_t  timeval;                        /* Current time              */
; 1511 : struct  tm *tmptr;                      /* -> Current time structure */
; 1512 : U32     bufadr;                         /* Real addr of data buffer  */
; 1513 : U32     buflen;                         /* Length of data buffer     */
; 1514 : char    buf[64];                        /* Response buffer           */
; 1515 : BYTE    dattim[64];                     /* Date and time (EBCDIC)    */
; 1516 : #define DIAG_DATEFMT_SHORT      0x80    /* Date format mm/dd/yy      */
; 1517 : #define DIAG_DATEFMT_FULL       0x40    /* Date format mm/dd/yyyy    */
; 1518 : #define DIAG_DATEFMT_ISO        0x20    /* Date format yyyy-mm-dd    */
; 1519 : #define DIAG_DATEFMT_SYSDFLT    0x10    /* System-wide default format*/
; 1520 : static  char timefmt[]="%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d";
; 1521 : 
; 1522 :     /* Get the current date and time in EBCDIC */
; 1523 :     timeval = time(NULL);

  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 time
  00034	48 89 44 24 40	 mov	 QWORD PTR timeval$[rsp], rax

; 1524 :     tmptr = localtime(&timeval);

  00039	48 8d 4c 24 40	 lea	 rcx, QWORD PTR timeval$[rsp]
  0003e	e8 00 00 00 00	 call	 localtime
  00043	48 89 44 24 48	 mov	 QWORD PTR tmptr$[rsp], rax

; 1525 :     strftime((char *)dattim, sizeof(dattim), timefmt, tmptr);

  00048	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tmptr$[rsp]
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?timefmt@?1??s390_pseudo_timer@@9@9
  00054	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00059	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 1526 :     for (i = 0; dattim[i] != '\0'; i++)

  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@s390_pseud
$LN2@s390_pseud:
  00071	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_pseud:
  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR dattim$[rsp+rax]
  00088	85 c0		 test	 eax, eax
  0008a	74 21		 je	 SHORT $LN3@s390_pseud

; 1527 :         dattim[i] = host_to_guest(dattim[i]);

  0008c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00091	0f b6 8c 04 90
	00 00 00	 movzx	 ecx, BYTE PTR dattim$[rsp+rax]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0009f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a4	88 84 0c 90 00
	00 00		 mov	 BYTE PTR dattim$[rsp+rcx], al
  000ab	eb c4		 jmp	 SHORT $LN2@s390_pseud
$LN3@s390_pseud:

; 1528 : 
; 1529 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1530 :     bufadr = regs->GR_L(r1);

  000ad	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c4	89 44 24 38	 mov	 DWORD PTR bufadr$[rsp], eax

; 1531 :     buflen = regs->GR_L(r2);

  000c8	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000d0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000df	89 44 24 34	 mov	 DWORD PTR buflen$[rsp], eax

; 1532 : 
; 1533 :     /* Use length 32 if R2 is zero or function code is 00C */
; 1534 :     if (r2 == 0 || code == 0x00C)

  000e3	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  000eb	74 0a		 je	 SHORT $LN6@s390_pseud
  000ed	83 bc 24 00 01
	00 00 0c	 cmp	 DWORD PTR code$[rsp], 12
  000f5	75 08		 jne	 SHORT $LN5@s390_pseud
$LN6@s390_pseud:

; 1535 :         buflen = 32;

  000f7	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 32 ; 00000020H
$LN5@s390_pseud:

; 1536 : 
; 1537 :     /* Program check if R1 and R2 specify the same non-zero
; 1538 :        register number, or if buffer length is less than or
; 1539 :        equal to zero, or if buffer address is zero, or if
; 1540 :        buffer is not on a doubleword boundary */
; 1541 :     if ((r2 != 0 && r2 == r1)
; 1542 :         || (S32)buflen <= 0
; 1543 :         || bufadr == 0
; 1544 :         || (bufadr & 0x00000007))

  000ff	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  00107	74 10		 je	 SHORT $LN9@s390_pseud
  00109	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00110	39 84 24 10 01
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  00117	74 19		 je	 SHORT $LN8@s390_pseud
$LN9@s390_pseud:
  00119	83 7c 24 34 00	 cmp	 DWORD PTR buflen$[rsp], 0
  0011e	7e 12		 jle	 SHORT $LN8@s390_pseud
  00120	83 7c 24 38 00	 cmp	 DWORD PTR bufadr$[rsp], 0
  00125	74 0b		 je	 SHORT $LN8@s390_pseud
  00127	8b 44 24 38	 mov	 eax, DWORD PTR bufadr$[rsp]
  0012b	83 e0 07	 and	 eax, 7
  0012e	85 c0		 test	 eax, eax
  00130	74 12		 je	 SHORT $LN7@s390_pseud
$LN8@s390_pseud:

; 1545 :     {
; 1546 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_pseud:

; 1547 :     }
; 1548 : 
; 1549 :     /* Build the response buffer */
; 1550 :     memset (buf, 0, sizeof(buf));

  00144	48 8d 44 24 50	 lea	 rax, QWORD PTR buf$[rsp]
  00149	48 8b f8	 mov	 rdi, rax
  0014c	33 c0		 xor	 eax, eax
  0014e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00153	f3 aa		 rep stosb

; 1551 :     /* Bytes 0-7 contain the date as EBCDIC MM/DD/YY */
; 1552 :     memcpy (buf, dattim, 8);

  00155	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp]
  0015d	48 89 44 24 50	 mov	 QWORD PTR buf$[rsp], rax

; 1553 :     /* Bytes 8-15 contain the time as EBCDIC HH:MM:SS */
; 1554 :     memcpy (buf+8, dattim+8, 8);

  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp+8]
  0016a	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp+8], rax

; 1555 :     /* Bytes 16-23 contain the virtual CPU time used in microseconds */
; 1556 :     /* Bytes 24-31 contain the total CPU time used in microseconds */
; 1557 :     /* Bytes 32-41 contain the date as EBCDIC MM/DD/YYYY */
; 1558 :     memcpy (buf+32, dattim+16, 10);

  0016f	48 8d 44 24 70	 lea	 rax, QWORD PTR buf$[rsp+32]
  00174	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+16]
  0017c	48 8b f8	 mov	 rdi, rax
  0017f	48 8b f1	 mov	 rsi, rcx
  00182	b9 0a 00 00 00	 mov	 ecx, 10
  00187	f3 a4		 rep movsb

; 1559 :     /* Bytes 42-47 contain binary zeroes */
; 1560 :     /* Bytes 48-57 contain the date as EBCDIC YYYY-MM-DD */
; 1561 :     memcpy (buf+48, dattim+26, 10);

  00189	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+48]
  00191	48 8d 8c 24 aa
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+26]
  00199	48 8b f8	 mov	 rdi, rax
  0019c	48 8b f1	 mov	 rsi, rcx
  0019f	b9 0a 00 00 00	 mov	 ecx, 10
  001a4	f3 a4		 rep movsb

; 1562 :     /* Byte 58 contains the diagnose 270 version code */
; 1563 :     buf[58] = 0x01;

  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	48 6b c0 3a	 imul	 rax, rax, 58		; 0000003aH
  001af	c6 44 04 50 01	 mov	 BYTE PTR buf$[rsp+rax], 1

; 1564 :     /* Byte 59 contains the user's default date format */
; 1565 :     buf[59] = DIAG_DATEFMT_ISO;

  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	48 6b c0 3b	 imul	 rax, rax, 59		; 0000003bH
  001bd	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1566 :     /* Byte 60 contains the system default date format */
; 1567 :     buf[60] = DIAG_DATEFMT_ISO;

  001c2	b8 01 00 00 00	 mov	 eax, 1
  001c7	48 6b c0 3c	 imul	 rax, rax, 60		; 0000003cH
  001cb	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1568 :     /* Bytes 61-63 contain binary zeroes */
; 1569 : 
; 1570 : #if 0 // debug
; 1571 :     LOGMSG( "Diagnose X'%3.3X':"
; 1572 : 
; 1573 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1574 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1575 : 
; 1576 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1577 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1578 : 
; 1579 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1580 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1581 : 
; 1582 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1583 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1584 : 
; 1585 :             , code
; 1586 : 
; 1587 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1588 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1589 : 
; 1590 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1591 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1592 : 
; 1593 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1594 :             , buf[40], buf[41], buf[42], buf[43], buf[44], buf[45], buf[46], buf[47]
; 1595 : 
; 1596 :             , buf[48], buf[49], buf[50], buf[51], buf[52], buf[53], buf[54], buf[55]
; 1597 :             , buf[56], buf[57], buf[58], buf[59], buf[60], buf[61], buf[63], buf[63]
; 1598 :         );
; 1599 : #endif
; 1600 : 
; 1601 :     /* Enforce maximum length to store */
; 1602 :     if (buflen > sizeof(buf))

  001d0	8b 44 24 34	 mov	 eax, DWORD PTR buflen$[rsp]
  001d4	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  001d8	76 08		 jbe	 SHORT $LN10@s390_pseud

; 1603 :         buflen = sizeof(buf);

  001da	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 64 ; 00000040H
$LN10@s390_pseud:

; 1604 : 
; 1605 :     /* Store the response buffer at the operand location */
; 1606 :     ARCH_DEP(vstorec) (buf, buflen-1, bufadr, USE_REAL_ADDR, regs);

  001e2	8b 44 24 34	 mov	 eax, DWORD PTR buflen$[rsp]
  001e6	ff c8		 dec	 eax
  001e8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f5	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  001fb	44 8b 44 24 38	 mov	 r8d, DWORD PTR bufadr$[rsp]
  00200	0f b6 d0	 movzx	 edx, al
  00203	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00208	e8 00 00 00 00	 call	 s390_vstorec

; 1607 : 
; 1608 : } /* end function pseudo_timer */

  0020d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00215	48 33 cc	 xor	 rcx, rsp
  00218	e8 00 00 00 00	 call	 __security_check_cookie
  0021d	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00224	5f		 pop	 rdi
  00225	5e		 pop	 rsi
  00226	c3		 ret	 0
s390_pseudo_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
buflen$ = 64
bufadr$ = 68
r1$ = 96
r2$ = 104
regs$ = 112
s390_access_reipl_data PROC

; 1229 : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1230 : U32     bufadr;                         /* Real addr of data buffer  */
; 1231 : U32     buflen;                         /* Length of data buffer     */
; 1232 : 
; 1233 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1234 :     bufadr = regs->GR_L(r1);

  00011	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 44	 mov	 DWORD PTR bufadr$[rsp], eax

; 1235 :     buflen = regs->GR_L(r2);

  00026	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0002b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00037	89 44 24 40	 mov	 DWORD PTR buflen$[rsp], eax

; 1236 : 
; 1237 :     /* Program check if buffer length is negative */
; 1238 :     if ((S32)buflen < 0)

  0003b	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00040	7d 0f		 jge	 SHORT $LN5@s390_acces

; 1239 :     {
; 1240 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00042	ba 06 00 00 00	 mov	 edx, 6
  00047	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	e8 00 00 00 00	 call	 s390_program_interrupt
$LN5@s390_acces:

; 1241 :     }
; 1242 : 
; 1243 :     /* Store IPL information if buffer length is non-zero */
; 1244 :     if (buflen > 0)

  00051	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00056	76 16		 jbe	 SHORT $LN6@s390_acces

; 1245 :     {
; 1246 :         /* Store one byte of zero to indicate no IPL information */
; 1247 :         ARCH_DEP(vstoreb) (0, bufadr, USE_REAL_ADDR, regs);

  00058	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00063	8b 54 24 44	 mov	 edx, DWORD PTR bufadr$[rsp]
  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 s390_vstoreb
$LN6@s390_acces:
$LN4@s390_acces:

; 1248 :     }
; 1249 : 
; 1250 :     PTT_ERR("*DIAG0B0",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 83 e0 10	 and	 rax, 16
  0007c	48 85 c0	 test	 rax, rax
  0007f	74 60		 je	 SHORT $LN7@s390_acces
  00081	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00086	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0008c	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00091	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00096	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  0009d	48 63 54 24 60	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000a2	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000a7	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  000af	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180555
  000c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c9	44 8b c9	 mov	 r9d, ecx
  000cc	44 8b c2	 mov	 r8d, edx
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180556
  000d6	b9 10 00 00 00	 mov	 ecx, 16
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN7@s390_acces:
  000e1	33 c0		 xor	 eax, eax
  000e3	85 c0		 test	 eax, eax
  000e5	75 87		 jne	 SHORT $LN4@s390_acces

; 1251 : 
; 1252 :     /* Return code 4 means no re-IPL information available */
; 1253 :     regs->GR_L(r2) = 4;

  000e7	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  000ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1254 : 
; 1255 : } /* end function access_reipl_data */

  000fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00100	c3		 ret	 0
s390_access_reipl_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
bloklen$ = 64
tv183 = 68
dev$ = 72
devnum$ = 80
blokaddr$ = 88
vrdc$ = 96
__$ArrayPad$ = 352
r1$ = 400
r2$ = 408
regs$ = 416
s390_device_info PROC

; 1262 : {

$LN28:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s390_devic:

; 1263 : DEVBLK   *dev;             /* -> Device block                        */
; 1264 : VRDCBLOK vrdc;             /* VRDCBLOK                               */
; 1265 : RADR     blokaddr;         /* Location of the VRDCBLOK               */
; 1266 : U16      bloklen;          /* Length from the VRDCBLOK               */
; 1267 : #if 0
; 1268 : /* Only required if implementation is for the z/VM 5.3 level */
; 1269 : U16      reserved;         /* Bytes 14 and 15                        */
; 1270 : #endif
; 1271 : U16      devnum;           /* Device number from the VRDCBLOK        */
; 1272 : 
; 1273 : 
; 1274 :     UNREFERENCED(r2);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN4@s390_devic

; 1275 : 
; 1276 :     if (regs->GR_L(r1) & 0x3

  0002e	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00036	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00045	83 e0 03	 and	 eax, 3
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN10@s390_devic

; 1277 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1278 :         || (regs->psw.amode64)
; 1279 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1280 :        )
; 1281 :     {
; 1282 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0004c	ba 06 00 00 00	 mov	 edx, 6
  00051	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 s390_program_interrupt
$LN10@s390_devic:

; 1283 :     }
; 1284 : 
; 1285 :     blokaddr = regs->GR_L(r1);

  0005e	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00066	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00075	48 89 44 24 58	 mov	 QWORD PTR blokaddr$[rsp], rax

; 1286 : 
; 1287 :     /* Fetch the first 4 bytes of the VRDCBLOK */
; 1288 :     ARCH_DEP(vfetchc) (&vrdc, 3, blokaddr, USE_REAL_ADDR, regs);

  0007a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00087	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0008d	44 8b 44 24 58	 mov	 r8d, DWORD PTR blokaddr$[rsp]
  00092	b2 03		 mov	 dl, 3
  00094	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  00099	e8 00 00 00 00	 call	 s390_vfetchc

; 1289 : 
; 1290 :     /* Get the VRDCBLOK length from the working VRDC */
; 1291 :     FETCH_HW(bloklen,&vrdc.vrdclen);

  0009e	48 8d 4c 24 62	 lea	 rcx, QWORD PTR vrdc$[rsp+2]
  000a3	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a8	0f b7 c8	 movzx	 ecx, ax
  000ab	e8 00 00 00 00	 call	 _byteswap_ushort
  000b0	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax

; 1292 : 
; 1293 :     /* VRDCBLOK length must be at least 8 bytes */
; 1294 :     if (bloklen<8)

  000b5	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000ba	83 f8 08	 cmp	 eax, 8
  000bd	7d 12		 jge	 SHORT $LN11@s390_devic

; 1295 :     {
; 1296 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000bf	ba 06 00 00 00	 mov	 edx, 6
  000c4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	e8 00 00 00 00	 call	 s390_program_interrupt
$LN11@s390_devic:

; 1297 :     }
; 1298 : 
; 1299 :     /* Fetch remainder of supplied VRDCBLOK, but no more */
; 1300 :     if (bloklen>VRDCBLOK_SIZE)

  000d1	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000d6	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000dc	76 0a		 jbe	 SHORT $LN12@s390_devic

; 1301 :        bloklen=VRDCBLOK_SIZE;

  000de	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000e3	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax
$LN12@s390_devic:

; 1302 :     ARCH_DEP(vfetchc) (&vrdc.vrdcvdat,bloklen-5,blokaddr+4, USE_REAL_ADDR, regs);

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR blokaddr$[rsp]
  000ed	48 83 c0 04	 add	 rax, 4
  000f1	0f b7 4c 24 40	 movzx	 ecx, WORD PTR bloklen$[rsp]
  000f6	83 e9 05	 sub	 ecx, 5
  000f9	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00101	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00106	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0010c	44 8b c0	 mov	 r8d, eax
  0010f	0f b6 d1	 movzx	 edx, cl
  00112	48 8d 4c 24 64	 lea	 rcx, QWORD PTR vrdc$[rsp+4]
  00117	e8 00 00 00 00	 call	 s390_vfetchc

; 1303 : 
; 1304 : #if 0
; 1305 :     /* If length is 16 or greater, bytes 14 and 15 must be zero on z/VM 5.3.0 or earlier */
; 1306 :     if ( bloklen>=16)
; 1307 :     {
; 1308 :          FETCH_HW(reserved,&vrdc.vrdcrsvd);
; 1309 :          if (reserved != 0)
; 1310 :          {
; 1311 :               ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1312 :          }
; 1313 :     }
; 1314 : #endif
; 1315 : 
; 1316 :     /* Get the device number from the working VRDC */
; 1317 :     FETCH_HW(devnum,&vrdc.vrdcdvno);

  0011c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  00121	e8 00 00 00 00	 call	 fetch_hw_noswap
  00126	0f b7 c8	 movzx	 ecx, ax
  00129	e8 00 00 00 00	 call	 _byteswap_ushort
  0012e	66 89 44 24 50	 mov	 WORD PTR devnum$[rsp], ax

; 1318 : 
; 1319 :     /* Locate the device block and set the virtual and real device information */
; 1320 :     dev = ARCH_DEP(vmdevice_data) (0x210,devnum,&vrdc.vrdcvdat,&vrdc.vrdcrcdt);

  00133	4c 8d 4c 24 68	 lea	 r9, QWORD PTR vrdc$[rsp+8]
  00138	4c 8d 44 24 64	 lea	 r8, QWORD PTR vrdc$[rsp+4]
  0013d	0f b7 54 24 50	 movzx	 edx, WORD PTR devnum$[rsp]
  00142	b9 10 02 00 00	 mov	 ecx, 528		; 00000210H
  00147	e8 00 00 00 00	 call	 s390_vmdevice_data
  0014c	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 1321 : 
; 1322 :     /* Return condition code 3 if device does not exist */
; 1323 :     if (!dev)

  00151	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00157	0f 85 96 00 00
	00		 jne	 $LN13@s390_devic
$LN7@s390_devic:

; 1324 :     {
; 1325 :         PTT_ERR("*DIAG210",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00164	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00167	48 83 e0 10	 and	 rax, 16
  0016b	48 85 c0	 test	 rax, rax
  0016e	74 6f		 je	 SHORT $LN14@s390_devic
  00170	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00178	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0017e	48 63 8c 24 98
	01 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00186	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018e	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00195	48 63 94 24 90
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0019d	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a5	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001ad	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180590
  001c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c7	44 8b c9	 mov	 r9d, ecx
  001ca	44 8b c2	 mov	 r8d, edx
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180591
  001d4	b9 10 00 00 00	 mov	 ecx, 16
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s390_devic:
  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	0f 85 74 ff ff
	ff		 jne	 $LN7@s390_devic

; 1326 :         return 3;

  001e9	b8 03 00 00 00	 mov	 eax, 3
  001ee	e9 a1 01 00 00	 jmp	 $LN1@s390_devic
$LN13@s390_devic:

; 1327 :     }
; 1328 : 
; 1329 :     /* Set the underlying device and real device features */
; 1330 :     vrdc.vrdcundv=0x00;

  001f3	c6 44 24 6c 00	 mov	 BYTE PTR vrdc$[rsp+12], 0

; 1331 :     vrdc.vrdcrdaf=0x00;

  001f8	c6 44 24 6d 00	 mov	 BYTE PTR vrdc$[rsp+13], 0

; 1332 : 
; 1333 :     /* Create device dependent mappings */
; 1334 :     if (vrdc.vrdcvdat.vdevcls == DC_DASD)

  001fd	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  00202	83 f8 04	 cmp	 eax, 4
  00205	0f 85 ed 00 00
	00		 jne	 $LN15@s390_devic

; 1335 :     {
; 1336 :         memcpy(&vrdc.vrdcrdc,dev->devchar,42);

  0020b	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  00210	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00215	48 8b f8	 mov	 rdi, rax
  00218	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  0021f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00224	f3 a4		 rep movsb

; 1337 :         switch (dev->devtype)

  00226	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0022b	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0022f	89 44 24 44	 mov	 DWORD PTR tv183[rsp], eax
  00233	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13104 ; 00003330H
  0023b	7f 2a		 jg	 SHORT $LN27@s390_devic
  0023d	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13104 ; 00003330H
  00245	74 36		 je	 SHORT $LN20@s390_devic
  00247	81 7c 24 44 05
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8965 ; 00002305H
  0024f	74 2c		 je	 SHORT $LN19@s390_devic
  00251	81 7c 24 44 11
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8977 ; 00002311H
  00259	74 22		 je	 SHORT $LN17@s390_devic
  0025b	81 7c 24 44 14
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8980 ; 00002314H
  00263	74 18		 je	 SHORT $LN18@s390_devic
  00265	eb 6c		 jmp	 SHORT $LN8@s390_devic
$LN27@s390_devic:
  00267	81 7c 24 44 40
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13120 ; 00003340H
  0026f	74 0c		 je	 SHORT $LN21@s390_devic
  00271	81 7c 24 44 50
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13136 ; 00003350H
  00279	74 02		 je	 SHORT $LN22@s390_devic
  0027b	eb 56		 jmp	 SHORT $LN8@s390_devic
$LN17@s390_devic:
$LN18@s390_devic:
$LN19@s390_devic:
$LN20@s390_devic:
$LN21@s390_devic:
$LN22@s390_devic:

; 1338 :         {
; 1339 :              case 0x2311:
; 1340 :              case 0x2314:
; 1341 :              case 0x2305:
; 1342 :              case 0x3330:
; 1343 :              case 0x3340:
; 1344 :              case 0x3350:
; 1345 :                   /* Set non-keyed overhead */
; 1346 :                   STORE_HW(&vrdc.vrdcrdc[0x18],dev->ckdtab->f2);

  0027d	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00282	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00289	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  0028d	e8 00 00 00 00	 call	 _byteswap_ushort
  00292	b9 01 00 00 00	 mov	 ecx, 1
  00297	48 6b c9 18	 imul	 rcx, rcx, 24
  0029b	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002a0	0f b7 d0	 movzx	 edx, ax
  002a3	e8 00 00 00 00	 call	 store_hw_noswap

; 1347 :                   /* Set keyed overhead */
; 1348 :                   STORE_HW(&vrdc.vrdcrdc[0x1A],dev->ckdtab->f1);

  002a8	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002ad	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002b4	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	b9 01 00 00 00	 mov	 ecx, 1
  002c2	48 6b c9 1a	 imul	 rcx, rcx, 26
  002c6	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002cb	0f b7 d0	 movzx	 edx, ax
  002ce	e8 00 00 00 00	 call	 store_hw_noswap
$LN8@s390_devic:

; 1349 :              /* Note: for all other DASD devices these fields contain bytes 24-27 of the RDC */
; 1350 :         }
; 1351 :         /* Set Control Unit ID */
; 1352 :         vrdc.vrdcrdc[0x2A]=dev->devchar[56];

  002d3	b8 01 00 00 00	 mov	 eax, 1
  002d8	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  002dc	b9 01 00 00 00	 mov	 ecx, 1
  002e1	48 6b c9 2a	 imul	 rcx, rcx, 42		; 0000002aH
  002e5	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  002ea	0f b6 84 02 6c
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1388]
  002f2	88 44 0c 70	 mov	 BYTE PTR vrdc$[rsp+rcx+16], al

; 1353 :     }

  002f6	eb 25		 jmp	 SHORT $LN16@s390_devic
$LN15@s390_devic:

; 1354 :     else if (vrdc.vrdcvdat.vdevcls == DC_FBA)

  002f8	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  002fd	83 f8 01	 cmp	 eax, 1
  00300	75 1b		 jne	 SHORT $LN23@s390_devic

; 1355 :         memcpy(&vrdc.vrdcrdc,dev->devchar,32);

  00302	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  00307	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0030c	48 8b f8	 mov	 rdi, rax
  0030f	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  00316	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0031b	f3 a4		 rep movsb
$LN23@s390_devic:
$LN16@s390_devic:

; 1356 : 
; 1357 :     /* Set Path Group ID */
; 1358 :     memcpy(&vrdc.vrdcpgid,dev->pgid,11);

  0031d	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR vrdc$[rsp+80]
  00325	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0032a	48 8b f8	 mov	 rdi, rax
  0032d	48 8d b1 ad 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1453]
  00334	b9 0b 00 00 00	 mov	 ecx, 11
  00339	f3 a4		 rep movsb

; 1359 : 
; 1360 :     /* Set version */
; 1361 :     if (bloklen>0x60)

  0033b	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  00340	83 f8 60	 cmp	 eax, 96			; 00000060H
  00343	7e 08		 jle	 SHORT $LN24@s390_devic

; 1362 :        vrdc.vrdcvers=0x01;

  00345	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR vrdc$[rsp+96], 1
$LN24@s390_devic:

; 1363 : 
; 1364 :     /* Set underlying real device */
; 1365 :     if (!(vrdc.vrdcrdaf & VRDCEMRD))

  0034d	0f b6 44 24 6d	 movzx	 eax, BYTE PTR vrdc$[rsp+13]
  00352	83 e0 02	 and	 eax, 2
  00355	85 c0		 test	 eax, eax
  00357	75 0d		 jne	 SHORT $LN25@s390_devic

; 1366 :        memcpy(&vrdc.vrdcrdev,&vrdc.vrdcdvno,2);

  00359	0f b7 44 24 60	 movzx	 eax, WORD PTR vrdc$[rsp]
  0035e	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR vrdc$[rsp+128], ax
$LN25@s390_devic:

; 1367 : 
; 1368 :     /* Update the VRDC in main storage */
; 1369 :     ARCH_DEP(vstorec) (&vrdc, bloklen-1, blokaddr, USE_REAL_ADDR, regs);

  00366	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  0036b	ff c8		 dec	 eax
  0036d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00375	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0037a	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00380	44 8b 44 24 58	 mov	 r8d, DWORD PTR blokaddr$[rsp]
  00385	0f b6 d0	 movzx	 edx, al
  00388	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  0038d	e8 00 00 00 00	 call	 s390_vstorec

; 1370 : 
; 1371 :     /* Return condition code 0 for success */
; 1372 :     return 0;

  00392	33 c0		 xor	 eax, eax
$LN1@s390_devic:

; 1373 : 
; 1374 : } /* end function device_info */

  00394	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039c	48 33 cc	 xor	 rcx, rsp
  0039f	e8 00 00 00 00	 call	 __security_check_cookie
  003a4	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  003ab	5f		 pop	 rdi
  003ac	5e		 pop	 rsi
  003ad	c3		 ret	 0
s390_device_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
tv69 = 36
dev$ = 40
r1$ = 64
r2$ = 72
regs$ = 80
s390_vm_info PROC

; 1382 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1383 : DEVBLK  *dev;                          /* -> Device block            */
; 1384 : U16     devnum;                        /* Device number              */
; 1385 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1386 : RADR    stgarea;                       /* Storage extent area        */
; 1387 : S64     stglen;                        /* Storage extent area length */
; 1388 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1389 : 
; 1390 :     /* Ry contains the subcode */
; 1391 :     switch(regs->GR_L(r2))

  00011	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00026	83 7c 24 24 00	 cmp	 DWORD PTR tv69[rsp], 0
  0002b	74 13		 je	 SHORT $LN4@s390_vm_in
  0002d	83 7c 24 24 04	 cmp	 DWORD PTR tv69[rsp], 4
  00032	74 2d		 je	 SHORT $LN5@s390_vm_in
  00034	83 7c 24 24 08	 cmp	 DWORD PTR tv69[rsp], 8
  00039	74 7f		 je	 SHORT $LN8@s390_vm_in
  0003b	e9 2d 01 00 00	 jmp	 $LN12@s390_vm_in
$LN4@s390_vm_in:

; 1392 :     {
; 1393 :     case 0x00000000: /* Highest addressable byte */
; 1394 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1395 : 
; 1396 :         /* Program check if running in z/Architecture mode and */
; 1397 :         /* 64-bit addressing is being used.                    */
; 1398 :         if (regs->psw.amode64)
; 1399 :         {
; 1400 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1401 :         }
; 1402 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1403 :         regs->GR_L(r1) = regs->mainlim; /* provide highest addressable byte */

  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0004f	8b 92 58 08 00
	00		 mov	 edx, DWORD PTR [rdx+2136]
  00055	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1404 :         return;

  0005c	e9 1b 01 00 00	 jmp	 $LN1@s390_vm_in
$LN5@s390_vm_in:

; 1405 : 
; 1406 :     case 0x00000004: /* Provide BYUSER ID value */
; 1407 : 
; 1408 :         /* Program check if Rx and Ry are the same registers or        */
; 1409 :         /* or Ry is not an even register or the address provided       */
; 1410 :         /* in Rx is not on a doubleword boundary or if running         */
; 1411 :         /* in z/Architecture mode and 64-bit addressing is being used. */
; 1412 :         if ( r1 == r2 || r2 & 0x1 || regs->GR_L(r1) & 0x7

  00061	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  00065	39 44 24 40	 cmp	 DWORD PTR r1$[rsp], eax
  00069	74 23		 je	 SHORT $LN7@s390_vm_in
  0006b	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0006f	83 e0 01	 and	 eax, 1
  00072	85 c0		 test	 eax, eax
  00074	75 18		 jne	 SHORT $LN7@s390_vm_in
  00076	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00087	83 e0 07	 and	 eax, 7
  0008a	85 c0		 test	 eax, eax
  0008c	74 0f		 je	 SHORT $LN6@s390_vm_in
$LN7@s390_vm_in:

; 1413 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1414 :              || (regs->psw.amode64)
; 1415 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1416 :            )
; 1417 :         {
; 1418 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0008e	ba 06 00 00 00	 mov	 edx, 6
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	e8 00 00 00 00	 call	 s390_program_interrupt
$LN6@s390_vm_in:

; 1419 :         }
; 1420 :         regs->GR_L(r2+1)=0x4; /* Indicate no BYUSER ID for Hercules */

  0009d	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  000a1	ff c0		 inc	 eax
  000a3	48 98		 cdqe
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1421 :         return;

  000b5	e9 c2 00 00 00	 jmp	 $LN1@s390_vm_in
$LN8@s390_vm_in:

; 1422 : 
; 1423 :     case 0x00000008: /* Return number of lines per page */
; 1424 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1425 : 
; 1426 :         /* Program check if running in z/Architecture mode and */
; 1427 :         /* 64-bit addressing is being used.                    */
; 1428 :         if (regs->psw.amode64)
; 1429 :         {
; 1430 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1431 :         }
; 1432 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1433 : 
; 1434 :         /* Get the device number from the Rx register */
; 1435 :         devnum=regs->GR_LHL(r1);

  000ba	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000cc	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 1436 : 
; 1437 :         /* Locate the device block */
; 1438 :         dev = find_device_by_devnum(0,devnum);

  000d1	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  000d6	33 c9		 xor	 ecx, ecx
  000d8	e8 00 00 00 00	 call	 find_device_by_devnum
  000dd	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 1439 : 
; 1440 :         /* Set 0 lines per page for a valid printer or console (meaning SPOOL is OFF) */
; 1441 :         if (dev != NULL &&

  000e2	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000e8	74 6c		 je	 SHORT $LN9@s390_vm_in
  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  000f3	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  000f8	74 30		 je	 SHORT $LN11@s390_vm_in
  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00103	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00108	74 20		 je	 SHORT $LN11@s390_vm_in
  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0010f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00113	3d 52 10 00 00	 cmp	 eax, 4178		; 00001052H
  00118	74 10		 je	 SHORT $LN11@s390_vm_in
  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0011f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00123	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00128	75 2c		 jne	 SHORT $LN9@s390_vm_in
$LN11@s390_vm_in:

; 1442 :               (dev->devtype == 0x1403 ||
; 1443 :                dev->devtype == 0x3211 ||
; 1444 :                dev->devtype == 0x1052 ||
; 1445 :                dev->devtype == 0x3215 )
; 1446 :             )
; 1447 :         {
; 1448 :            regs->GR_L(r1) = 0; /* Set zero lines per page */

  0012a	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1449 :            regs->GR_L(r2) = 0; /* Set return code to indicate a valid device */

  0013f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1450 :         }

  00154	eb 15		 jmp	 SHORT $LN10@s390_vm_in
$LN9@s390_vm_in:

; 1451 :         else
; 1452 :         {
; 1453 :            regs->GR_L(r2) = 4; /* Set return code to indicate an invalid device */

  00156	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN10@s390_vm_in:

; 1454 :         }
; 1455 :         return;

  0016b	eb 0f		 jmp	 SHORT $LN1@s390_vm_in
$LN12@s390_vm_in:

; 1456 : 
; 1457 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1458 :     case 0x0000000C: /* Return highest addressable byte for z/Architecture machine */
; 1459 :          regs->GR_G(r1) = regs->mainlim;
; 1460 :          regs->GR_G(r2) = regs->mainlim;
; 1461 :          return;
; 1462 : 
; 1463 :     case 0x00000010: /* Set storage extent */
; 1464 : 
; 1465 :          /* Obtain the storage extent area real address from Rx */
; 1466 :          /* and its length from Rx+1                            */
; 1467 :          stgarea=regs->GR_G(r1);
; 1468 :          stglen=regs->GR_G(r1+1); /* Length is treated as a signed value */
; 1469 : 
; 1470 :          /* Program check if Rx is not an even register or the address */
; 1471 :          /* provided in Rx is not on a quadword boundary or the length */
; 1472 :          /* provided in Rx+1 is not positive or not a multiple of 16   */
; 1473 :          if ( r1 & 1 || stgarea & 0xF || stglen <= 0 || stglen & 0xF )
; 1474 :          {
; 1475 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1476 :          }
; 1477 : 
; 1478 :          /* Convert real address to absolute address */
; 1479 :          stgarea=APPLY_PREFIXING(stgarea,regs->PX );
; 1480 : 
; 1481 :          /* Check to ensure extent information can be stored */
; 1482 :          if (stgarea > regs->mainlim - 16)
; 1483 :          {
; 1484 :              regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);
; 1485 :          }
; 1486 :          /* Set start of storage extent to zero */
; 1487 :          ARCH_DEP(store_doubleword_absolute)(0,stgarea,regs);
; 1488 :          /* Set end of storage extent to last addressable byte of main storage */
; 1489 :          ARCH_DEP(store_doubleword_absolute)(regs->mainlim,stgarea+8,regs);
; 1490 :          /* Set number of extents to 1 in Ry */
; 1491 :          regs->GR_G(r2) = 1;
; 1492 :          /* Indicate all extents returned */
; 1493 :          regs->psw.cc = 0;
; 1494 :          return;
; 1495 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1496 : 
; 1497 :     default: /* Invalid subcode */
; 1498 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0016d	ba 06 00 00 00	 mov	 edx, 6
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 s390_program_interrupt
$LN1@s390_vm_in:

; 1499 :     }
; 1500 : }

  0017c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00180	c3		 ret	 0
s390_vm_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
func$ = 32
skey$ = 33
refchg$1 = 34
abs$ = 36
tv130 = 40
end$ = 44
start$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
s390_diag_ppagerel PROC

; 1614 : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1615 : U32     abs, start, end;                /* Absolute frame addresses  */
; 1616 : BYTE    skey;                           /* Specified storage key     */
; 1617 : BYTE    func;                           /* Function code...          */
; 1618 : #define DIAG214_EPR             0x00    /* Establish pending release */
; 1619 : #define DIAG214_CPR             0x01    /* Cancel pending release    */
; 1620 : #define DIAG214_CAPR            0x02    /* Cancel all pending release*/
; 1621 : #define DIAG214_CPRV            0x03    /* Cancel and validate       */
; 1622 : 
; 1623 :     /* Program check if R1 is not an even-numbered register */
; 1624 :     if (r1 & 1)

  00011	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	74 0f		 je	 SHORT $LN7@s390_diag_

; 1625 :     {
; 1626 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0001c	ba 06 00 00 00	 mov	 edx, 6
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_diag_:

; 1627 :     }
; 1628 : 
; 1629 :     /* Extract the function code from R1+1 register bits 24-31 */
; 1630 :     func = regs->GR_L(r1+1) & 0xFF;

  0002b	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0002f	ff c0		 inc	 eax
  00031	48 98		 cdqe
  00033	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	88 44 24 20	 mov	 BYTE PTR func$[rsp], al

; 1631 : 
; 1632 :     /* Extract the start/end addresses from R1 and R1+1 registers */
; 1633 :     start = regs->GR_L(r1) & STORAGE_KEY_PAGEMASK;

  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0005e	89 44 24 30	 mov	 DWORD PTR start$[rsp], eax

; 1634 :     end = regs->GR_L(r1+1) & STORAGE_KEY_PAGEMASK;

  00062	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00066	ff c0		 inc	 eax
  00068	48 98		 cdqe
  0006a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00076	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0007b	89 44 24 2c	 mov	 DWORD PTR end$[rsp], eax

; 1635 : 
; 1636 :     /* Validate start/end addresses if function is not CAPR */
; 1637 :     if (func != DIAG214_CAPR
; 1638 :         && (start > end || end > regs->mainlim))

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  00084	83 f8 02	 cmp	 eax, 2
  00087	74 2b		 je	 SHORT $LN8@s390_diag_
  00089	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  0008d	39 44 24 30	 cmp	 DWORD PTR start$[rsp], eax
  00091	77 12		 ja	 SHORT $LN9@s390_diag_
  00093	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000a3	76 0f		 jbe	 SHORT $LN8@s390_diag_
$LN9@s390_diag_:

; 1639 :     {
; 1640 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000a5	ba 06 00 00 00	 mov	 edx, 6
  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	e8 00 00 00 00	 call	 s390_program_interrupt
$LN8@s390_diag_:

; 1641 :     }
; 1642 : 
; 1643 :     /* Process depending on function code */
; 1644 :     switch (func)

  000b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  000b9	88 44 24 28	 mov	 BYTE PTR tv130[rsp], al
  000bd	80 7c 24 28 00	 cmp	 BYTE PTR tv130[rsp], 0
  000c2	74 1b		 je	 SHORT $LN10@s390_diag_
  000c4	80 7c 24 28 01	 cmp	 BYTE PTR tv130[rsp], 1
  000c9	74 19		 je	 SHORT $LN11@s390_diag_
  000cb	80 7c 24 28 02	 cmp	 BYTE PTR tv130[rsp], 2
  000d0	0f 84 83 00 00
	00		 je	 $LN14@s390_diag_
  000d6	80 7c 24 28 03	 cmp	 BYTE PTR tv130[rsp], 3
  000db	74 07		 je	 SHORT $LN12@s390_diag_
  000dd	eb 7c		 jmp	 SHORT $LN15@s390_diag_
$LN10@s390_diag_:

; 1645 :     {
; 1646 :     case DIAG214_EPR:  /* Establish Pending Release */
; 1647 :         break;

  000df	e9 86 00 00 00	 jmp	 $LN2@s390_diag_
$LN11@s390_diag_:
$LN12@s390_diag_:

; 1648 : 
; 1649 :     case DIAG214_CPR:  /* Cancel Pending Release */
; 1650 :     case DIAG214_CPRV: /* Cancel Pending Release and Validate */
; 1651 : 
; 1652 :         /* Do not set storage keys if R2 is register 0 */
; 1653 :         if (r2 == 0) break;

  000e4	83 7c 24 58 00	 cmp	 DWORD PTR r2$[rsp], 0
  000e9	75 02		 jne	 SHORT $LN13@s390_diag_
  000eb	eb 7d		 jmp	 SHORT $LN2@s390_diag_
$LN13@s390_diag_:

; 1654 : 
; 1655 :         /* Obtain key from R2 register bits 24-28 */
; 1656 :         skey = regs->GR_L(r2) & (STORKEY_KEY | STORKEY_FETCH);

  000ed	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000fe	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00103	88 44 24 21	 mov	 BYTE PTR skey$[rsp], al

; 1657 : 
; 1658 :         /* Set storage key for each frame within specified range
; 1659 :            without changing existing reference and change bits.
; 1660 :         */
; 1661 :         for (abs = start; abs <= end; abs += STORAGE_KEY_PAGESIZE)

  00107	8b 44 24 30	 mov	 eax, DWORD PTR start$[rsp]
  0010b	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
  0010f	eb 0d		 jmp	 SHORT $LN6@s390_diag_
$LN4@s390_diag_:
  00111	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  00115	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  0011a	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
$LN6@s390_diag_:
  0011e	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00122	39 44 24 24	 cmp	 DWORD PTR abs$[rsp], eax
  00126	77 2f		 ja	 SHORT $LN5@s390_diag_

; 1662 :         {
; 1663 :             BYTE refchg = ARCH_DEP( get_storage_key )( abs ) & (STORKEY_REF | STORKEY_CHANGE);

  00128	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  0012c	8b c8		 mov	 ecx, eax
  0012e	e8 00 00 00 00	 call	 s390_get_storage_key
  00133	0f b6 c0	 movzx	 eax, al
  00136	83 e0 06	 and	 eax, 6
  00139	88 44 24 22	 mov	 BYTE PTR refchg$1[rsp], al

; 1664 :             ARCH_DEP( put_storage_key )( abs, skey | refchg );

  0013d	0f b6 44 24 21	 movzx	 eax, BYTE PTR skey$[rsp]
  00142	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR refchg$1[rsp]
  00147	0b c1		 or	 eax, ecx
  00149	8b 4c 24 24	 mov	 ecx, DWORD PTR abs$[rsp]
  0014d	0f b6 d0	 movzx	 edx, al
  00150	e8 00 00 00 00	 call	 s390_put_storage_key

; 1665 :         }

  00155	eb ba		 jmp	 SHORT $LN4@s390_diag_
$LN5@s390_diag_:

; 1666 : 
; 1667 :         break;

  00157	eb 11		 jmp	 SHORT $LN2@s390_diag_
$LN14@s390_diag_:

; 1668 : 
; 1669 :     case DIAG214_CAPR:  /* Cancel All Pending Releases */
; 1670 :         break;

  00159	eb 0f		 jmp	 SHORT $LN2@s390_diag_
$LN15@s390_diag_:

; 1671 : 
; 1672 :     default:            /* Invalid function code */
; 1673 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015b	ba 06 00 00 00	 mov	 edx, 6
  00160	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	e8 00 00 00 00	 call	 s390_program_interrupt
$LN2@s390_diag_:

; 1674 :     } /* end switch(func) */
; 1675 : 
; 1676 :     /* Return condition code zero */
; 1677 :     return 0;

  0016a	33 c0		 xor	 eax, eax

; 1678 : 
; 1679 : } /* end function diag_ppagerel */

  0016c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00170	c3		 ret	 0
s390_diag_ppagerel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
cmdflags$ = 80
i$ = 84
resplen$1 = 88
rem$2 = 92
chunk$3 = 96
cmdlen$ = 100
maxrlen$ = 104
resp$ = 112
cc$ = 120
tv250 = 124
freeresp$ = 128
cmdaddr$ = 132
respadr$ = 136
$T4 = 144
tv181 = 152
tv207 = 160
tv264 = 168
cmd$ = 176
msg$ = 448
__$ArrayPad$ = 704
r1$ = 736
r2$ = 744
regs$ = 752
s390_cpcmd_call PROC

; 1057 : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1058 : U32     i;                              /* Array subscript           */
; 1059 : U32     cc;                             /* Condition code            */
; 1060 : U32     cmdaddr;                        /* Address of command string */
; 1061 : U32     cmdlen;                         /* Length of command string  */
; 1062 : U32     respadr;                        /* Address of response buffer*/
; 1063 : U32     maxrlen;                        /* Length of response buffer */
; 1064 : BYTE    cmdflags;                       /* Command flags             */
; 1065 : 
; 1066 : #define CMDFLAGS_REJPASSW     0x80      /* Reject password in command*/
; 1067 : #define CMDFLAGS_RESPONSE     0x40      /* Return response in buffer */
; 1068 : #define CMDFLAGS_REQPASSW     0x20      /* Prompt for password       */
; 1069 : #define CMDFLAGS_RESERVED     0x1F      /* Reserved bits, must be 0  */
; 1070 : 
; 1071 : char    msg[256];                       /* Message work area         */
; 1072 : char    cmd[256+1];                     /* Input command +1 for NULL */
; 1073 : char*   resp;                           /* Output response           */
; 1074 : int     freeresp;                       /* Flag to free resp         */
; 1075 : 
; 1076 :     /* Obtain address of command from R1 register
; 1077 :        and command length and flags from R2 register
; 1078 :     */
; 1079 :     cmdaddr  = regs->GR_L( r1 );

  00026	48 63 84 24 e0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 84 24 84 00
	00 00		 mov	 DWORD PTR cmdaddr$[rsp], eax

; 1080 :     cmdflags = regs->GR_L( r2 ) >> 24;

  00044	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0004c	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0005b	c1 e8 18	 shr	 eax, 24
  0005e	88 44 24 50	 mov	 BYTE PTR cmdflags$[rsp], al

; 1081 :     cmdlen   = regs->GR_L( r2 ) & 0x00FFFFFF;

  00062	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0006a	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0007e	89 44 24 64	 mov	 DWORD PTR cmdlen$[rsp], eax

; 1082 : 
; 1083 :     /* Program check if invalid flags, or if command string
; 1084 :        is too long, or if response buffer is specified and
; 1085 :        registers are consecutive or either register specifies
; 1086 :        register 15
; 1087 :     */
; 1088 :     if (0
; 1089 :         || (cmdflags & CMDFLAGS_RESERVED)
; 1090 :         || (cmdlen > (sizeof(cmd)-1))   // (room for NULL terminator!)
; 1091 :         || (1

  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 69		 jne	 SHORT $LN15@s390_cpcmd
  00088	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  0008d	83 e0 1f	 and	 eax, 31
  00090	85 c0		 test	 eax, eax
  00092	75 5d		 jne	 SHORT $LN15@s390_cpcmd
  00094	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  00098	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  0009e	77 51		 ja	 SHORT $LN15@s390_cpcmd
  000a0	33 c0		 xor	 eax, eax
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	74 5c		 je	 SHORT $LN14@s390_cpcmd
  000a7	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  000ac	83 e0 40	 and	 eax, 64			; 00000040H
  000af	85 c0		 test	 eax, eax
  000b1	74 50		 je	 SHORT $LN14@s390_cpcmd
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 38		 jne	 SHORT $LN16@s390_cpcmd
  000b9	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000c0	ff c0		 inc	 eax
  000c2	39 84 24 e0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  000c9	74 26		 je	 SHORT $LN16@s390_cpcmd
  000cb	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	39 84 24 e8 02
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  000db	74 14		 je	 SHORT $LN16@s390_cpcmd
  000dd	83 bc 24 e0 02
	00 00 0f	 cmp	 DWORD PTR r1$[rsp], 15
  000e5	74 0a		 je	 SHORT $LN16@s390_cpcmd
  000e7	83 bc 24 e8 02
	00 00 0f	 cmp	 DWORD PTR r2$[rsp], 15
  000ef	75 12		 jne	 SHORT $LN14@s390_cpcmd
$LN16@s390_cpcmd:
$LN15@s390_cpcmd:

; 1092 :             && (cmdflags & CMDFLAGS_RESPONSE)
; 1093 :             && (0
; 1094 :                 || r1 == r2 + 1
; 1095 :                 || r2 == r1 + 1
; 1096 :                 || r1 == 15
; 1097 :                 || r2 == 15
; 1098 :                )
; 1099 :            )
; 1100 :     )
; 1101 :     {
; 1102 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000f1	ba 06 00 00 00	 mov	 edx, 6
  000f6	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_cpcmd:

; 1103 :     }
; 1104 : 
; 1105 :     /* Put machine into stopped state if command length is zero */
; 1106 :     if (cmdlen == 0)

  00103	83 7c 24 64 00	 cmp	 DWORD PTR cmdlen$[rsp], 0
  00108	75 52		 jne	 SHORT $LN17@s390_cpcmd

; 1107 :     {
; 1108 :         regs->opinterv = 0;

  0010a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00118	83 e0 ef	 and	 eax, -17		; ffffffefH
  0011b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1109 :         regs->cpustate = CPUSTATE_STOPPED;

  00129	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN4@s390_cpcmd:

; 1110 :         ON_IC_INTERRUPT( regs );

  00135	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00140	0f ba e8 1f	 bts	 eax, 31
  00144	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 e0		 jne	 SHORT $LN4@s390_cpcmd

; 1111 :         return 0;

  00155	33 c0		 xor	 eax, eax
  00157	e9 a5 04 00 00	 jmp	 $LN1@s390_cpcmd
$LN17@s390_cpcmd:

; 1112 :     }
; 1113 : 
; 1114 :     /* Obtain the EBCDIC command string from guest storage */
; 1115 :     ARCH_DEP( vfetchc )( cmd, cmdlen-1, cmdaddr, USE_REAL_ADDR, regs );

  0015c	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  00160	ff c8		 dec	 eax
  00162	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0016f	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00175	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR cmdaddr$[rsp]
  0017d	0f b6 d0	 movzx	 edx, al
  00180	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00188	e8 00 00 00 00	 call	 s390_vfetchc

; 1116 : 
; 1117 :     /* Translate guest EBCDIC command to host ASCII format */
; 1118 :     for (i=0; i < cmdlen; i++)

  0018d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00195	eb 0a		 jmp	 SHORT $LN7@s390_cpcmd
$LN5@s390_cpcmd:
  00197	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0019b	ff c0		 inc	 eax
  0019d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_cpcmd:
  001a1	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  001a5	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  001a9	73 1f		 jae	 SHORT $LN6@s390_cpcmd

; 1119 :         cmd[i] = guest_to_host( cmd[i] );

  001ab	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001af	0f b6 8c 04 b0
	00 00 00	 movzx	 ecx, BYTE PTR cmd$[rsp+rax]
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  001bd	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  001c1	88 84 0c b0 00
	00 00		 mov	 BYTE PTR cmd$[rsp+rcx], al
  001c8	eb cd		 jmp	 SHORT $LN5@s390_cpcmd
$LN6@s390_cpcmd:

; 1120 :     cmd[i] = 0; // (null terminate!)

  001ca	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001ce	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  001d6	48 81 bc 24 90
	00 00 00 01 01
	00 00		 cmp	 QWORD PTR $T4[rsp], 257	; 00000101H
  001e2	73 02		 jae	 SHORT $LN33@s390_cpcmd
  001e4	eb 05		 jmp	 SHORT $LN34@s390_cpcmd
$LN33@s390_cpcmd:
  001e6	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@s390_cpcmd:
  001eb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  001f3	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR cmd$[rsp+rax], 0

; 1121 : 
; 1122 :     /* Execute the Hercules emulator (hypervisor) command */
; 1123 :     resp = "";

  001fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180503
  00202	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1124 :     freeresp = 0;

  00207	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 0

; 1125 : 
; 1126 : #if !defined( FEATURE_HERCULES_DIAGCALLS )
; 1127 :         // "Hercules-specific DIAG instructions support not included in engine build"
; 1128 :         MSGBUF( msg, MSG( HHC01954, "E" ));
; 1129 :         resp = &msg[0];
; 1130 : #else
; 1131 :     /************************************************************
; 1132 :      *  SECURITY CHECK: Reject attempts to issue "shell" type
; 1133 :      *  commands unless specifically allowed by SHCMDOPT option.
; 1134 :      ************************************************************/
; 1135 :     if (1
; 1136 :         && is_shell_command( cmd )
; 1137 :         && (sysblk.shcmdopt & (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8))

  00212	33 c0		 xor	 eax, eax
  00214	83 f8 01	 cmp	 eax, 1
  00217	74 66		 je	 SHORT $LN18@s390_cpcmd
  00219	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00221	e8 00 00 00 00	 call	 is_shell_command
  00226	0f b6 c0	 movzx	 eax, al
  00229	85 c0		 test	 eax, eax
  0022b	74 52		 je	 SHORT $LN18@s390_cpcmd
  0022d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00234	0f b6 80 2f 11
	00 00		 movzx	 eax, BYTE PTR [rax+4399]
  0023b	83 e0 03	 and	 eax, 3
  0023e	83 f8 03	 cmp	 eax, 3
  00241	74 3c		 je	 SHORT $LN18@s390_cpcmd

; 1138 :                            != (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8)
; 1139 :     )
; 1140 :     {
; 1141 :         // "DIAG8 access to shell disallowed by SHCMDOPT setting"
; 1142 :         MSGBUF( msg, MSG( HHC01953, "E" ));

  00243	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180506
  0024a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180507
  00251	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00256	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR msg$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1143 :         resp = &msg[0];

  00264	b8 01 00 00 00	 mov	 eax, 1
  00269	48 6b c0 00	 imul	 rax, rax, 0
  0026d	48 8d 84 04 c0
	01 00 00	 lea	 rax, QWORD PTR msg$[rsp+rax]
  00275	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1144 :     }

  0027a	e9 7e 01 00 00	 jmp	 $LN19@s390_cpcmd
$LN18@s390_cpcmd:

; 1145 :     else
; 1146 :     {
; 1147 :         /* It's either not a "shell" type command or the
; 1148 :            SHCMDOPT option is allowing them to be issued
; 1149 :            so we can go ahead and execute the command. */
; 1150 : 
; 1151 :         // "%s guest issued panel command: %s"
; 1152 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  0027f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00286	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0028d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00292	85 c0		 test	 eax, eax
  00294	74 7d		 je	 SHORT $LN20@s390_cpcmd

; 1153 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Starting", RTRIM( cmd ));

  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180509
  0029d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  002ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv181[rsp], rax
  002b3	b9 01 00 00 00	 mov	 ecx, 1
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv181[rsp]
  002c6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180510
  002d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180511
  002de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180512
  002ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f4	41 b9 02 00 00
	00		 mov	 r9d, 2
  002fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180513
  00301	ba 81 04 00 00	 mov	 edx, 1153		; 00000481H
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180514
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@s390_cpcmd:

; 1154 : 
; 1155 :         /* Issue the command and capture the response */
; 1156 :         if (cmdflags & CMDFLAGS_RESPONSE)

  00313	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  00318	83 e0 40	 and	 eax, 64			; 00000040H
  0031b	85 c0		 test	 eax, eax
  0031d	74 39		 je	 SHORT $LN21@s390_cpcmd

; 1157 :         {
; 1158 :             panel_command_capture( cmd, &resp, false );

  0031f	45 33 c0	 xor	 r8d, r8d
  00322	48 8d 54 24 70	 lea	 rdx, QWORD PTR resp$[rsp]
  00327	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_panel_command_capture

; 1159 : 
; 1160 :             if (resp)

  00335	48 83 7c 24 70
	00		 cmp	 QWORD PTR resp$[rsp], 0
  0033b	74 0d		 je	 SHORT $LN23@s390_cpcmd

; 1161 :                 freeresp = 1;

  0033d	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 1
  00348	eb 0c		 jmp	 SHORT $LN24@s390_cpcmd
$LN23@s390_cpcmd:

; 1162 :             else
; 1163 :                 resp = "";

  0034a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180519
  00351	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax
$LN24@s390_cpcmd:

; 1164 :         }

  00356	eb 11		 jmp	 SHORT $LN22@s390_cpcmd
$LN21@s390_cpcmd:

; 1165 :         else /* Issue command normally (no response wanted) */
; 1166 :         {
; 1167 :             panel_command( cmd );

  00358	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00360	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  00367	ff 10		 call	 QWORD PTR [rax]
$LN22@s390_cpcmd:

; 1168 :         }
; 1169 : 
; 1170 :         // "%s guest issued panel command: %s"
; 1171 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  00369	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00370	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00377	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0037c	85 c0		 test	 eax, eax
  0037e	74 7d		 je	 SHORT $LN25@s390_cpcmd

; 1172 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Completed", RTRIM( cmd ));

  00380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180521
  00387	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  00395	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  0039d	b9 01 00 00 00	 mov	 ecx, 1
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  003b0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180522
  003bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180523
  003c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180524
  003d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003de	41 b9 02 00 00
	00		 mov	 r9d, 2
  003e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180525
  003eb	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180526
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@s390_cpcmd:
$LN19@s390_cpcmd:

; 1173 :     }
; 1174 : #endif // defined( FEATURE_HERCULES_DIAGCALLS )
; 1175 : 
; 1176 :     /* Copy response to guest storage if response requested */
; 1177 :     if (cmdflags & CMDFLAGS_RESPONSE)

  003fd	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  00402	83 e0 40	 and	 eax, 64			; 00000040H
  00405	85 c0		 test	 eax, eax
  00407	0f 84 b8 01 00
	00		 je	 $LN26@s390_cpcmd

; 1178 :     {
; 1179 :         U32 resplen, chunk, rem;
; 1180 : 
; 1181 :         /* Translate host ASCII response to guest EBCDIC format */
; 1182 :         for (i=0, resplen = (U32) strlen( resp ); i < resplen; i++)

  0040d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00415	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  0041a	e8 00 00 00 00	 call	 strlen
  0041f	89 44 24 58	 mov	 DWORD PTR resplen$1[rsp], eax
  00423	eb 0a		 jmp	 SHORT $LN10@s390_cpcmd
$LN8@s390_cpcmd:
  00425	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00429	ff c0		 inc	 eax
  0042b	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_cpcmd:
  0042f	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  00433	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00437	73 21		 jae	 SHORT $LN9@s390_cpcmd

; 1183 :             resp[i] = host_to_guest( resp[i] );

  00439	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0043d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  00442	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00446	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0044c	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00450	48 8b 54 24 70	 mov	 rdx, QWORD PTR resp$[rsp]
  00455	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00458	eb cb		 jmp	 SHORT $LN8@s390_cpcmd
$LN9@s390_cpcmd:

; 1184 : 
; 1185 :         /* Retrieve guest's response parameters */
; 1186 :         respadr = regs->GR_L( r1+1 );

  0045a	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00461	ff c0		 inc	 eax
  00463	48 98		 cdqe
  00465	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00474	89 84 24 88 00
	00 00		 mov	 DWORD PTR respadr$[rsp], eax

; 1187 :         maxrlen = regs->GR_L( r2+1 );

  0047b	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00482	ff c0		 inc	 eax
  00484	48 98		 cdqe
  00486	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00495	89 44 24 68	 mov	 DWORD PTR maxrlen$[rsp], eax

; 1188 : 
; 1189 :         /* Copy the response to guest storage in 256 byte chunks */
; 1190 :         for (i=0, chunk=256, rem = MIN( resplen, maxrlen ); rem; rem -= chunk, i += chunk)

  00499	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004a1	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR chunk$3[rsp], 256 ; 00000100H
  004a9	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004ad	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  004b1	73 0a		 jae	 SHORT $LN35@s390_cpcmd
  004b3	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  004b7	89 44 24 7c	 mov	 DWORD PTR tv250[rsp], eax
  004bb	eb 08		 jmp	 SHORT $LN36@s390_cpcmd
$LN35@s390_cpcmd:
  004bd	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004c1	89 44 24 7c	 mov	 DWORD PTR tv250[rsp], eax
$LN36@s390_cpcmd:
  004c5	8b 44 24 7c	 mov	 eax, DWORD PTR tv250[rsp]
  004c9	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004cd	eb 20		 jmp	 SHORT $LN13@s390_cpcmd
$LN11@s390_cpcmd:
  004cf	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004d3	8b 4c 24 5c	 mov	 ecx, DWORD PTR rem$2[rsp]
  004d7	2b c8		 sub	 ecx, eax
  004d9	8b c1		 mov	 eax, ecx
  004db	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004df	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004e3	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  004e7	03 c8		 add	 ecx, eax
  004e9	8b c1		 mov	 eax, ecx
  004eb	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN13@s390_cpcmd:
  004ef	83 7c 24 5c 00	 cmp	 DWORD PTR rem$2[rsp], 0
  004f4	74 6c		 je	 SHORT $LN12@s390_cpcmd

; 1191 :         {
; 1192 :             if (rem < chunk) chunk = rem;

  004f6	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004fa	39 44 24 5c	 cmp	 DWORD PTR rem$2[rsp], eax
  004fe	73 08		 jae	 SHORT $LN28@s390_cpcmd
  00500	8b 44 24 5c	 mov	 eax, DWORD PTR rem$2[rsp]
  00504	89 44 24 60	 mov	 DWORD PTR chunk$3[rsp], eax
$LN28@s390_cpcmd:

; 1193 :             ARCH_DEP( vstorec )( &resp[i], chunk-1, respadr+i, USE_REAL_ADDR, regs );

  00508	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0050c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR respadr$[rsp]
  00513	03 c8		 add	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	8b 4c 24 60	 mov	 ecx, DWORD PTR chunk$3[rsp]
  0051b	ff c9		 dec	 ecx
  0051d	8b 54 24 54	 mov	 edx, DWORD PTR i$[rsp]
  00521	4c 8b 44 24 70	 mov	 r8, QWORD PTR resp$[rsp]
  00526	4c 03 c2	 add	 r8, rdx
  00529	49 8b d0	 mov	 rdx, r8
  0052c	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv264[rsp], rdx
  00534	4c 8b 84 24 f0
	02 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0053c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00541	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00547	44 8b c0	 mov	 r8d, eax
  0054a	0f b6 d1	 movzx	 edx, cl
  0054d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv264[rsp]
  00555	48 8b c8	 mov	 rcx, rax
  00558	e8 00 00 00 00	 call	 s390_vstorec

; 1194 :         }

  0055d	e9 6d ff ff ff	 jmp	 $LN11@s390_cpcmd
$LN12@s390_cpcmd:

; 1195 : 
; 1196 :         /* Update guest response register and set condition code */
; 1197 :         if (resplen <= maxrlen)

  00562	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  00566	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  0056a	77 28		 ja	 SHORT $LN29@s390_cpcmd

; 1198 :         {
; 1199 :             /* They have the complete response */
; 1200 :             regs->GR_L( r2+1 ) = resplen;

  0056c	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00573	ff c0		 inc	 eax
  00575	48 98		 cdqe
  00577	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057f	8b 54 24 58	 mov	 edx, DWORD PTR resplen$1[rsp]
  00583	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1201 :             cc = 0;

  0058a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1202 :         }

  00592	eb 2f		 jmp	 SHORT $LN30@s390_cpcmd
$LN29@s390_cpcmd:

; 1203 :         else
; 1204 :         {
; 1205 :             /* Their response buffer is too small */
; 1206 :             regs->GR_L( r2+1 ) = (resplen - maxrlen);

  00594	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  00598	8b 4c 24 58	 mov	 ecx, DWORD PTR resplen$1[rsp]
  0059c	2b c8		 sub	 ecx, eax
  0059e	8b c1		 mov	 eax, ecx
  005a0	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005a7	ff c1		 inc	 ecx
  005a9	48 63 c9	 movsxd	 rcx, ecx
  005ac	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1207 :             cc = 1;

  005bb	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN30@s390_cpcmd:

; 1208 :         }
; 1209 :     }

  005c3	eb 08		 jmp	 SHORT $LN27@s390_cpcmd
$LN26@s390_cpcmd:

; 1210 :     else
; 1211 :         cc = 0;

  005c5	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN27@s390_cpcmd:

; 1212 : 
; 1213 :     /* Set R2 register to CP completion code */
; 1214 :     regs->GR_L( r2 ) = 0;

  005cd	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005d5	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1215 : 
; 1216 :     /* Free memory malloc'ed by panel_command_capture */
; 1217 :     if (freeresp)

  005e8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR freeresp$[rsp], 0
  005f0	74 0b		 je	 SHORT $LN31@s390_cpcmd

; 1218 :         free( resp );

  005f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN31@s390_cpcmd:

; 1219 : 
; 1220 :     /* Return condition code */
; 1221 :     return cc;

  005fd	8b 44 24 78	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@s390_cpcmd:
$LN32@s390_cpcmd:

; 1222 : 
; 1223 : } /* end function cpcmd_call */

  00601	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00609	48 33 cc	 xor	 rcx, rsp
  0060c	e8 00 00 00 00	 call	 __security_check_cookie
  00611	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  00618	c3		 ret	 0
s390_cpcmd_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
c$ = 48
idlen$ = 52
i$ = 56
tzdiff$ = 60
tv161 = 64
ver$ = 68
idaddr$ = 72
puser$ = 80
tv183 = 88
rel$ = 92
$T1 = 96
$T2 = 104
$T3 = 112
$T4 = 120
buf$ = 128
__$ArrayPad$ = 168
r1$ = 192
r2$ = 200
regs$ = 208
s390_extid_call PROC

; 936  : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 937  : int        i;                           /* Array subscript           */
; 938  : int        ver, rel;                    /* Version and release number*/
; 939  : int        tzdiff;                      /* Time zone differential    */
; 940  : U32        idaddr;                      /* Address of storage operand*/
; 941  : U32        idlen;                       /* Length of storage operand */
; 942  : BYTE       buf[40];                     /* Extended identification   */
; 943  : #if defined( HAVE_GETLOGIN_R )
; 944  :   #if !defined(LOGIN_NAME_MAX)
; 945  :     #define LOGIN_NAME_MAX 100
; 946  :   #endif
; 947  : char       unam[LOGIN_NAME_MAX+1];      /* User name                 */
; 948  : #endif
; 949  : char      *puser;                       /* Pointer to user name      */
; 950  : BYTE       c;                           /* Character work area       */
; 951  : 
; 952  :     /* Load storage operand address from R1 register */
; 953  :     idaddr = regs->GR_L(r1);

  00026	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 44 24 48	 mov	 DWORD PTR idaddr$[rsp], eax

; 954  : 
; 955  :     /* Program check if operand is not on a doubleword boundary */
; 956  :     if (idaddr & 0x00000007)

  00041	8b 44 24 48	 mov	 eax, DWORD PTR idaddr$[rsp]
  00045	83 e0 07	 and	 eax, 7
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN5@s390_extid

; 957  :     {
; 958  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0004c	ba 06 00 00 00	 mov	 edx, 6
  00051	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 s390_program_interrupt
$LN5@s390_extid:

; 959  :     }
; 960  : 
; 961  :     /* Load storage operand length from R2 register */
; 962  :     idlen = regs->GR_L(r2);

  0005e	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00066	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00075	89 44 24 34	 mov	 DWORD PTR idlen$[rsp], eax

; 963  : 
; 964  :     /* Program check if operand length is invalid */
; 965  :     if (idlen < 1)

  00079	83 7c 24 34 01	 cmp	 DWORD PTR idlen$[rsp], 1
  0007e	73 12		 jae	 SHORT $LN6@s390_extid

; 966  :     {
; 967  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00080	ba 06 00 00 00	 mov	 edx, 6
  00085	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	e8 00 00 00 00	 call	 s390_program_interrupt
$LN6@s390_extid:

; 968  :     }
; 969  : 
; 970  :     /* Bytes 0-7 contain the system name ("HERCULES" in EBCDIC) */
; 971  :     get_lparname(buf);

  00092	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0009a	e8 00 00 00 00	 call	 get_lparname

; 972  : 
; 973  :     /* Bytes 8-9 contain the execution environment bits */
; 974  :     buf[8] = 0x00;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 08	 imul	 rax, rax, 8
  000a8	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  000ad	48 83 7c 24 60
	28		 cmp	 QWORD PTR $T1[rsp], 40	; 00000028H
  000b3	73 02		 jae	 SHORT $LN9@s390_extid
  000b5	eb 05		 jmp	 SHORT $LN10@s390_extid
$LN9@s390_extid:
  000b7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@s390_extid:
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000c1	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 975  :     buf[9] = 0x00;

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	48 6b c0 09	 imul	 rax, rax, 9
  000d2	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  000d7	48 83 7c 24 68
	28		 cmp	 QWORD PTR $T2[rsp], 40	; 00000028H
  000dd	73 02		 jae	 SHORT $LN11@s390_extid
  000df	eb 05		 jmp	 SHORT $LN12@s390_extid
$LN11@s390_extid:
  000e1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@s390_extid:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  000eb	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 976  : 
; 977  :     /* Byte 10 contains the system product version number */
; 978  :     sscanf (QSTR(VERSION), "%d.%d", &ver, &rel);

  000f3	4c 8d 4c 24 5c	 lea	 r9, QWORD PTR rel$[rsp]
  000f8	4c 8d 44 24 44	 lea	 r8, QWORD PTR ver$[rsp]
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180457
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180458
  0010b	e8 00 00 00 00	 call	 sscanf

; 979  :     buf[10] = ver & 0xff;

  00110	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  00114	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 0a	 imul	 rcx, rcx, 10
  00122	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 980  : 
; 981  :     /* Byte 11 contains version number from STIDP */
; 982  :     buf[11] = regs->cpuversion;

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 0b	 imul	 rax, rax, 11
  00132	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	0f b6 49 3e	 movzx	 ecx, BYTE PTR [rcx+62]
  0013e	88 8c 04 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl

; 983  : 
; 984  :     /* Bytes 12-13 contain MCEL length from STIDP */
; 985  :     buf[12] = (regs->cpuid >> 8) & 0xFF;

  00145	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00151	48 c1 e8 08	 shr	 rax, 8
  00155	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0015b	b9 01 00 00 00	 mov	 ecx, 1
  00160	48 6b c9 0c	 imul	 rcx, rcx, 12
  00164	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 986  :     buf[13] = regs->cpuid & 0xFF;

  0016b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00177	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 0d	 imul	 rcx, rcx, 13
  00186	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 987  : 
; 988  :     /* Bytes 14-15 contain the CP address */
; 989  :     buf[14] = (regs->cpuad >> 8) & 0xFF;

  0018d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0019c	c1 f8 08	 sar	 eax, 8
  0019f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001a4	b9 01 00 00 00	 mov	 ecx, 1
  001a9	48 6b c9 0e	 imul	 rcx, rcx, 14
  001ad	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 990  :     buf[15] = regs->cpuad & 0xFF;

  001b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	48 6b c9 0f	 imul	 rcx, rcx, 15
  001d1	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 991  : 
; 992  :     /* Bytes 16-23 contain the userid in EBCDIC */
; 993  : #if defined( HAVE_GETLOGIN_R )
; 994  :     memset( unam, 0, sizeof(unam) );
; 995  :     VERIFY( getlogin_r ( unam, sizeof(unam) ) == 0 );
; 996  :     puser = unam;
; 997  : #else
; 998  :     puser = "";

  001d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180459
  001df	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax

; 999  : #endif
; 1000 :     for (i = 0; i < 8; i++)

  001e4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ec	eb 0a		 jmp	 SHORT $LN4@s390_extid
$LN2@s390_extid:
  001ee	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  001f2	ff c0		 inc	 eax
  001f4	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_extid:
  001f8	83 7c 24 38 08	 cmp	 DWORD PTR i$[rsp], 8
  001fd	7d 61		 jge	 SHORT $LN3@s390_extid

; 1001 :     {
; 1002 :         c = (*puser == '\0' ? SPACE : *(puser++));

  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00204	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00207	85 c0		 test	 eax, eax
  00209	75 0a		 jne	 SHORT $LN13@s390_extid
  0020b	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR tv161[rsp], 32 ; 00000020H
  00213	eb 19		 jmp	 SHORT $LN14@s390_extid
$LN13@s390_extid:
  00215	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  0021a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0021d	89 44 24 40	 mov	 DWORD PTR tv161[rsp], eax
  00221	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00226	48 ff c0	 inc	 rax
  00229	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax
$LN14@s390_extid:
  0022e	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv161[rsp]
  00233	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 1003 :         buf[16+i] = host_to_guest(toupper(c));

  00237	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0023c	8b c8		 mov	 ecx, eax
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00244	0f b6 c8	 movzx	 ecx, al
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0024d	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00251	83 c1 10	 add	 ecx, 16
  00254	48 63 c9	 movsxd	 rcx, ecx
  00257	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1004 :     }

  0025e	eb 8e		 jmp	 SHORT $LN2@s390_extid
$LN3@s390_extid:

; 1005 : 
; 1006 :     /* Bytes 24-31 contain the program product bitmap */
; 1007 :     memcpy (buf+24, "\x7F\xFE\x00\x00\x00\x00\x00\x00", 8);

  00260	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR $SG180460
  00267	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR buf$[rsp+24], rax

; 1008 : 
; 1009 :     /* Bytes 32-35 contain the time zone differential */
; 1010 :     tzdiff = query_tzoffset();   /* returns +/-HHMM as an integer */

  0026f	e8 00 00 00 00	 call	 query_tzoffset
  00274	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1011 :     tzdiff = ((tzdiff/100)*3600)+((tzdiff%100)*60);

  00278	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  0027c	99		 cdq
  0027d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00282	f7 f9		 idiv	 ecx
  00284	69 c0 10 0e 00
	00		 imul	 eax, eax, 3600		; 00000e10H
  0028a	89 44 24 58	 mov	 DWORD PTR tv183[rsp], eax
  0028e	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  00292	99		 cdq
  00293	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00298	f7 f9		 idiv	 ecx
  0029a	8b c2		 mov	 eax, edx
  0029c	6b c0 3c	 imul	 eax, eax, 60		; 0000003cH
  0029f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv183[rsp]
  002a3	03 c8		 add	 ecx, eax
  002a5	8b c1		 mov	 eax, ecx
  002a7	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1012 :     STORE_FW(buf+32,tzdiff);

  002ab	8b 4c 24 3c	 mov	 ecx, DWORD PTR tzdiff$[rsp]
  002af	e8 00 00 00 00	 call	 _byteswap_ulong
  002b4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+32]
  002bc	8b d0		 mov	 edx, eax
  002be	e8 00 00 00 00	 call	 store_fw_noswap

; 1013 : 
; 1014 :     /* Bytes 36-39 contain version, level, and service level */
; 1015 :     buf[36] = ver & 0xff;

  002c3	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  002c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002cc	b9 01 00 00 00	 mov	 ecx, 1
  002d1	48 6b c9 24	 imul	 rcx, rcx, 36		; 00000024H
  002d5	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1016 :     buf[37] = rel & 0xff;

  002dc	8b 44 24 5c	 mov	 eax, DWORD PTR rel$[rsp]
  002e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	48 6b c9 25	 imul	 rcx, rcx, 37		; 00000025H
  002ee	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1017 :     buf[38] = 0x00;

  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 26	 imul	 rax, rax, 38		; 00000026H
  002fe	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00303	48 83 7c 24 70
	28		 cmp	 QWORD PTR $T3[rsp], 40	; 00000028H
  00309	73 02		 jae	 SHORT $LN15@s390_extid
  0030b	eb 05		 jmp	 SHORT $LN16@s390_extid
$LN15@s390_extid:
  0030d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@s390_extid:
  00312	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  00317	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1018 :     buf[39] = 0x00;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  00328	48 89 44 24 78	 mov	 QWORD PTR $T4[rsp], rax
  0032d	48 83 7c 24 78
	28		 cmp	 QWORD PTR $T4[rsp], 40	; 00000028H
  00333	73 02		 jae	 SHORT $LN17@s390_extid
  00335	eb 05		 jmp	 SHORT $LN18@s390_extid
$LN17@s390_extid:
  00337	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN18@s390_extid:
  0033c	48 8b 44 24 78	 mov	 rax, QWORD PTR $T4[rsp]
  00341	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1019 : 
; 1020 : #if 0 // debug
; 1021 :     LOGMSG( "Diagnose X'000':"
; 1022 : 
; 1023 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1024 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1025 : 
; 1026 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1027 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1028 : 
; 1029 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1030 : 
; 1031 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1032 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1033 : 
; 1034 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1035 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1036 : 
; 1037 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1038 :         );
; 1039 : #endif
; 1040 : 
; 1041 :     /* Enforce maximum length to store */
; 1042 :     if (idlen > sizeof(buf))

  00349	8b 44 24 34	 mov	 eax, DWORD PTR idlen$[rsp]
  0034d	48 83 f8 28	 cmp	 rax, 40			; 00000028H
  00351	76 08		 jbe	 SHORT $LN7@s390_extid

; 1043 :         idlen = sizeof(buf);

  00353	c7 44 24 34 28
	00 00 00	 mov	 DWORD PTR idlen$[rsp], 40 ; 00000028H
$LN7@s390_extid:

; 1044 : 
; 1045 :     /* Store the extended identification code at operand address */
; 1046 :     ARCH_DEP(vstorec) (buf, idlen-1, idaddr, USE_REAL_ADDR, regs);

  0035b	8b 44 24 34	 mov	 eax, DWORD PTR idlen$[rsp]
  0035f	ff c8		 dec	 eax
  00361	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0036e	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00374	44 8b 44 24 48	 mov	 r8d, DWORD PTR idaddr$[rsp]
  00379	0f b6 d0	 movzx	 edx, al
  0037c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00384	e8 00 00 00 00	 call	 s390_vstorec

; 1047 : 
; 1048 :     /* Deduct number of bytes from the R2 register */
; 1049 :     regs->GR_L(r2) -= idlen;

  00389	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00391	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	8b 54 24 34	 mov	 edx, DWORD PTR idlen$[rsp]
  0039d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a4	2b c2		 sub	 eax, edx
  003a6	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003ae	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003b6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN8@s390_extid:

; 1050 : 
; 1051 : } /* end function extid_call */

  003bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c5	48 33 cc	 xor	 rcx, rsp
  003c8	e8 00 00 00 00	 call	 __security_check_cookie
  003cd	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003d4	c3		 ret	 0
s390_extid_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
accum$ = 48
unitstat$ = 49
i$ = 52
dev$ = 56
chanstat$ = 64
residual$ = 68
numsense$ = 72
lastccw$ = 76
iopaddr$ = 80
devnum$ = 84
ccwaddr$ = 88
tv164 = 92
ioparm$ = 96
__$ArrayPad$ = 192
r1$ = 240
r2$ = 248
regs$ = 256
s390_syncgen_io PROC

; 749  : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 750  : U32             i;                      /* Array subscript           */
; 751  : U32             numsense;               /* Number of sense bytes     */
; 752  : U32             iopaddr;                /* Address of HCPSGIOP       */
; 753  : HCPSGIOP        ioparm;                 /* I/O parameter list        */
; 754  : DEVBLK         *dev;                    /* -> Device block           */
; 755  : U16             devnum;                 /* Device number             */
; 756  : U16             residual;               /* Residual byte count       */
; 757  : U32             ccwaddr;                /* Address of channel program*/
; 758  : U32             lastccw;                /* CCW address at interrupt  */
; 759  : BYTE            accum;                  /* Work area                 */
; 760  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 31 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 761  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 40 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@s390_syncg:

; 762  : 
; 763  : //FIXME: code not right for shared devices
; 764  : 
; 765  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@s390_syncg

; 766  : 
; 767  :     /* Register R1 contains the real address of the parameter list */
; 768  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 44 24 50	 mov	 DWORD PTR iopaddr$[rsp], eax

; 769  : 
; 770  :     /* Program check if parameter list not on fullword boundary */
; 771  :     if (iopaddr & 0x00000003)

  00053	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  00057	83 e0 03	 and	 eax, 3
  0005a	85 c0		 test	 eax, eax
  0005c	74 12		 je	 SHORT $LN17@s390_syncg

; 772  :     {
; 773  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0005e	ba 06 00 00 00	 mov	 edx, 6
  00063	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	e8 00 00 00 00	 call	 s390_program_interrupt
$LN17@s390_syncg:

; 774  :     }
; 775  : 
; 776  :     /* Ensure that parameter list operand is addressable */
; 777  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00070	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	41 b9 02 00 00
	00		 mov	 r9d, 2
  00083	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  00089	ba fe ff ff ff	 mov	 edx, -2
  0008e	8b 4c 24 50	 mov	 ecx, DWORD PTR iopaddr$[rsp]
  00092	e8 00 00 00 00	 call	 s390_validate_operand

; 778  :                         ACCTYPE_WRITE, regs);
; 779  : 
; 780  :     /* Fetch the parameter list from real storage */
; 781  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00097	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000aa	44 8b 44 24 50	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  000af	b2 57		 mov	 dl, 87			; 00000057H
  000b1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000b6	e8 00 00 00 00	 call	 s390_vfetchc

; 782  : 
; 783  :     /* Load numeric fields from the parameter list */
; 784  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 00	 imul	 rax, rax, 0
  000c4	0f b6 44 04 60	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000c9	c1 e0 08	 shl	 eax, 8
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	48 6b c9 01	 imul	 rcx, rcx, 1
  000d5	0f b6 4c 0c 60	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000da	0b c1		 or	 eax, ecx
  000dc	66 89 44 24 54	 mov	 WORD PTR devnum$[rsp], ax

; 785  :     ccwaddr = (ioparm.ccwaddr[0] << 24)

  000e1	b8 01 00 00 00	 mov	 eax, 1
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	0f b6 44 04 68	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  000ef	c1 e0 18	 shl	 eax, 24
  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	48 6b c9 01	 imul	 rcx, rcx, 1
  000fb	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00100	c1 e1 10	 shl	 ecx, 16
  00103	0b c1		 or	 eax, ecx
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 02	 imul	 rcx, rcx, 2
  0010e	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00113	c1 e1 08	 shl	 ecx, 8
  00116	0b c1		 or	 eax, ecx
  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	48 6b c9 03	 imul	 rcx, rcx, 3
  00121	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00126	0b c1		 or	 eax, ecx
  00128	89 44 24 58	 mov	 DWORD PTR ccwaddr$[rsp], eax

; 786  :                 | (ioparm.ccwaddr[1] << 16)
; 787  :                 | (ioparm.ccwaddr[2] << 8)
; 788  :                 | ioparm.ccwaddr[3];
; 789  : 
; 790  :     /* Locate the device block */
; 791  :     dev = find_device_by_devnum (0,devnum);

  0012c	0f b7 54 24 54	 movzx	 edx, WORD PTR devnum$[rsp]
  00131	33 c9		 xor	 ecx, ecx
  00133	e8 00 00 00 00	 call	 find_device_by_devnum
  00138	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 792  : 
; 793  :     /* Set return code 1 and cond code 1 if device does not exist */
; 794  :     if (dev == NULL)

  0013d	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00143	75 26		 jne	 SHORT $LN18@s390_syncg

; 795  :     {
; 796  :         regs->GR_L(15) = 1;

  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 0f	 imul	 rax, rax, 15
  0014e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	c7 84 01 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 1

; 797  :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 fd 05 00 00	 jmp	 $LN1@s390_syncg
$LN18@s390_syncg:

; 798  :     }
; 799  : 
; 800  :     /* Program check if protect key bits 4-7 are not zero
; 801  :        or if the reserved bits in the flag byte are not zero */
; 802  :     if ((ioparm.akey & 0x0F) || (ioparm.flag & HCPSGIOP_FLAG_RESV))

  0016b	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00170	83 e0 0f	 and	 eax, 15
  00173	85 c0		 test	 eax, eax
  00175	75 0c		 jne	 SHORT $LN20@s390_syncg
  00177	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0017c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0017f	85 c0		 test	 eax, eax
  00181	74 12		 je	 SHORT $LN19@s390_syncg
$LN20@s390_syncg:

; 803  :     {
; 804  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00183	ba 15 00 00 00	 mov	 edx, 21
  00188	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00190	e8 00 00 00 00	 call	 s390_program_interrupt
$LN19@s390_syncg:

; 805  :     }
; 806  : 
; 807  : #ifdef FEATURE_S370_CHANNEL
; 808  :     /* Program check if flag byte specifies format-1 CCW */
; 809  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)
; 810  :     {
; 811  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);
; 812  :     }
; 813  : #endif /*FEATURE_S370_CHANNEL*/
; 814  : 
; 815  :     /* Program check if CCW is not on a doubleword boundary,
; 816  :        or if CCW address exceeds maximum according to CCW format */
; 817  :     if ((ccwaddr & 0x00000007) || ccwaddr >

  00195	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00199	83 e0 07	 and	 eax, 7
  0019c	85 c0		 test	 eax, eax
  0019e	75 2a		 jne	 SHORT $LN22@s390_syncg
  001a0	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  001a5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001aa	85 c0		 test	 eax, eax
  001ac	74 0a		 je	 SHORT $LN35@s390_syncg
  001ae	c7 44 24 5c ff
	ff ff 7f	 mov	 DWORD PTR tv164[rsp], 2147483647 ; 7fffffffH
  001b6	eb 08		 jmp	 SHORT $LN36@s390_syncg
$LN35@s390_syncg:
  001b8	c7 44 24 5c ff
	ff ff 00	 mov	 DWORD PTR tv164[rsp], 16777215 ; 00ffffffH
$LN36@s390_syncg:
  001c0	8b 44 24 5c	 mov	 eax, DWORD PTR tv164[rsp]
  001c4	39 44 24 58	 cmp	 DWORD PTR ccwaddr$[rsp], eax
  001c8	76 12		 jbe	 SHORT $LN21@s390_syncg
$LN22@s390_syncg:

; 818  :            ((ioparm.flag & HCPSGIOP_FORMAT1_CCW) ?
; 819  :                         (U32)0x7FFFFFFF : (U32)0x00FFFFFF))
; 820  :     {
; 821  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001ca	ba 15 00 00 00	 mov	 edx, 21
  001cf	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	e8 00 00 00 00	 call	 s390_program_interrupt
$LN21@s390_syncg:

; 822  :     }
; 823  : 
; 824  :     /* Program check if reserved fields are not zero */
; 825  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  001dc	c6 44 24 30 00	 mov	 BYTE PTR accum$[rsp], 0
  001e1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e9	eb 0a		 jmp	 SHORT $LN7@s390_syncg
$LN5@s390_syncg:
  001eb	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  001ef	ff c0		 inc	 eax
  001f1	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_syncg:
  001f5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  001f9	48 83 f8 04	 cmp	 rax, 4
  001fd	73 18		 jae	 SHORT $LN6@s390_syncg

; 826  :         accum |= ioparm.resv1[i];

  001ff	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00203	0f b6 44 04 64	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  00208	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  0020d	0b c8		 or	 ecx, eax
  0020f	8b c1		 mov	 eax, ecx
  00211	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  00215	eb d4		 jmp	 SHORT $LN5@s390_syncg
$LN6@s390_syncg:

; 827  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  00217	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0021f	eb 0a		 jmp	 SHORT $LN10@s390_syncg
$LN8@s390_syncg:
  00221	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00225	ff c0		 inc	 eax
  00227	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_syncg:
  0022b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0022f	48 83 f8 04	 cmp	 rax, 4
  00233	73 18		 jae	 SHORT $LN9@s390_syncg

; 828  :         accum |= ioparm.resv2[i];

  00235	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00239	0f b6 44 04 6c	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  0023e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00243	0b c8		 or	 ecx, eax
  00245	8b c1		 mov	 eax, ecx
  00247	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  0024b	eb d4		 jmp	 SHORT $LN8@s390_syncg
$LN9@s390_syncg:

; 829  :     for (i = 0; i < sizeof(ioparm.resv3); i++)

  0024d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00255	eb 0a		 jmp	 SHORT $LN13@s390_syncg
$LN11@s390_syncg:
  00257	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0025b	ff c0		 inc	 eax
  0025d	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN13@s390_syncg:
  00261	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00265	48 83 f8 05	 cmp	 rax, 5
  00269	73 18		 jae	 SHORT $LN12@s390_syncg

; 830  :         accum |= ioparm.resv3[i];

  0026b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0026f	0f b6 44 04 79	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  00274	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00279	0b c8		 or	 ecx, eax
  0027b	8b c1		 mov	 eax, ecx
  0027d	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  00281	eb d4		 jmp	 SHORT $LN11@s390_syncg
$LN12@s390_syncg:

; 831  :     for (i = 0; i < sizeof(ioparm.resv4); i++)

  00283	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0028b	eb 0a		 jmp	 SHORT $LN16@s390_syncg
$LN14@s390_syncg:
  0028d	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00291	ff c0		 inc	 eax
  00293	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN16@s390_syncg:
  00297	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0029b	48 83 f8 18	 cmp	 rax, 24
  0029f	73 1b		 jae	 SHORT $LN15@s390_syncg

; 832  :         accum |= ioparm.resv4[i];

  002a1	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002a5	0f b6 84 04 80
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  002ad	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  002b2	0b c8		 or	 ecx, eax
  002b4	8b c1		 mov	 eax, ecx
  002b6	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  002ba	eb d1		 jmp	 SHORT $LN14@s390_syncg
$LN15@s390_syncg:

; 833  :     if (accum != 0)

  002bc	0f b6 44 24 30	 movzx	 eax, BYTE PTR accum$[rsp]
  002c1	85 c0		 test	 eax, eax
  002c3	74 12		 je	 SHORT $LN23@s390_syncg

; 834  :     {
; 835  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002c5	ba 15 00 00 00	 mov	 edx, 21
  002ca	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	e8 00 00 00 00	 call	 s390_program_interrupt
$LN23@s390_syncg:

; 836  :     }
; 837  : 
; 838  :     /* Obtain the interrupt lock */
; 839  :     obtain_lock (&dev->lock);

  002d7	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002dc	48 83 c0 38	 add	 rax, 56			; 00000038H
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180416
  002e7	48 8b c8	 mov	 rcx, rax
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 840  : 
; 841  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 842  :     /* Return code 5 and condition code 1 if status pending */
; 843  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 844  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))

  002f0	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002f5	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  002fc	83 e0 01	 and	 eax, 1
  002ff	85 c0		 test	 eax, eax
  00301	75 13		 jne	 SHORT $LN25@s390_syncg
  00303	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00308	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  0030f	83 e0 01	 and	 eax, 1
  00312	85 c0		 test	 eax, eax
  00314	74 3f		 je	 SHORT $LN24@s390_syncg
$LN25@s390_syncg:

; 845  :     {
; 846  :         release_lock (&dev->lock);

  00316	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0031b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0031f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180419
  00326	48 8b c8	 mov	 rcx, rax
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 847  :         regs->GR_L(15) = 5;

  0032f	b8 08 00 00 00	 mov	 eax, 8
  00334	48 6b c0 0f	 imul	 rax, rax, 15
  00338	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00340	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 848  :         return 1;

  0034b	b8 01 00 00 00	 mov	 eax, 1
  00350	e9 13 04 00 00	 jmp	 $LN1@s390_syncg
$LN24@s390_syncg:

; 849  :     }
; 850  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 851  : 
; 852  :     /* Return code 5 and condition code 1 if device is busy */
; 853  :     if (dev->busy || IOPENDING(dev))

  00355	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0035a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00360	c1 e8 13	 shr	 eax, 19
  00363	83 e0 01	 and	 eax, 1
  00366	85 c0		 test	 eax, eax
  00368	75 54		 jne	 SHORT $LN27@s390_syncg
  0036a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0036f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00375	c1 e8 16	 shr	 eax, 22
  00378	83 e0 01	 and	 eax, 1
  0037b	85 c0		 test	 eax, eax
  0037d	75 3f		 jne	 SHORT $LN28@s390_syncg
  0037f	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00384	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0038a	c1 e8 17	 shr	 eax, 23
  0038d	83 e0 01	 and	 eax, 1
  00390	85 c0		 test	 eax, eax
  00392	75 2a		 jne	 SHORT $LN28@s390_syncg
  00394	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00399	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0039f	c1 e8 18	 shr	 eax, 24
  003a2	83 e0 01	 and	 eax, 1
  003a5	85 c0		 test	 eax, eax
  003a7	75 15		 jne	 SHORT $LN28@s390_syncg
  003a9	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003ae	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003b4	c1 e8 1b	 shr	 eax, 27
  003b7	83 e0 01	 and	 eax, 1
  003ba	85 c0		 test	 eax, eax
  003bc	74 3f		 je	 SHORT $LN26@s390_syncg
$LN28@s390_syncg:
$LN27@s390_syncg:

; 854  :     {
; 855  :         release_lock (&dev->lock);

  003be	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003c3	48 83 c0 38	 add	 rax, 56			; 00000038H
  003c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180423
  003ce	48 8b c8	 mov	 rcx, rax
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 856  :         regs->GR_L(15) = 5;

  003d7	b8 08 00 00 00	 mov	 eax, 8
  003dc	48 6b c0 0f	 imul	 rax, rax, 15
  003e0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e8	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 857  :         return 1;

  003f3	b8 01 00 00 00	 mov	 eax, 1
  003f8	e9 6b 03 00 00	 jmp	 $LN1@s390_syncg
$LN26@s390_syncg:

; 858  :     }
; 859  : 
; 860  :     /* Set the device busy indicator */
; 861  :     dev->busy = 1;

  003fd	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00402	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00408	0f ba e8 13	 bts	 eax, 19
  0040c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00411	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 862  : 
; 863  :     /* Release the device lock */
; 864  :     release_lock (&dev->lock);

  00417	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0041c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00420	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180424
  00427	48 8b c8	 mov	 rcx, rax
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 865  : 
; 866  :     /* Build the operation request block */
; 867  :     memset (&dev->orb, 0, sizeof(ORB));

  00430	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00435	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  0043b	48 8b f8	 mov	 rdi, rax
  0043e	33 c0		 xor	 eax, eax
  00440	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00445	f3 aa		 rep stosb

; 868  :     STORE_FW(dev->orb.ccwaddr, ccwaddr);

  00447	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  0044b	e8 00 00 00 00	 call	 _byteswap_ulong
  00450	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00455	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  0045c	8b d0		 mov	 edx, eax
  0045e	e8 00 00 00 00	 call	 store_fw_noswap

; 869  :     dev->orb.flag4 = ioparm.akey & ORB4_KEY;

  00463	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00468	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0046d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00472	88 81 d0 02 00
	00		 mov	 BYTE PTR [rcx+720], al

; 870  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)

  00478	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0047d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00482	85 c0		 test	 eax, eax
  00484	74 1b		 je	 SHORT $LN29@s390_syncg

; 871  :         dev->orb.flag5 |= ORB5_F;

  00486	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0048b	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00492	0f ba e8 07	 bts	 eax, 7
  00496	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	88 81 d1 02 00
	00		 mov	 BYTE PTR [rcx+721], al
$LN29@s390_syncg:

; 872  : 
; 873  :     /* Execute the channel program synchronously */
; 874  :     ARCH_DEP(execute_ccw_chain) (dev);

  004a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  004a6	e8 00 00 00 00	 call	 s390_execute_ccw_chain

; 875  : 
; 876  :     /* Obtain status, CCW address, and residual byte count */
; 877  :     lastccw = (dev->scsw.ccwaddr[0] << 24)

  004ab	b8 01 00 00 00	 mov	 eax, 1
  004b0	48 6b c0 00	 imul	 rax, rax, 0
  004b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  004b9	0f b6 84 01 0c
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+780]
  004c1	c1 e0 18	 shl	 eax, 24
  004c4	b9 01 00 00 00	 mov	 ecx, 1
  004c9	48 6b c9 01	 imul	 rcx, rcx, 1
  004cd	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004d2	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004da	c1 e1 10	 shl	 ecx, 16
  004dd	0b c1		 or	 eax, ecx
  004df	b9 01 00 00 00	 mov	 ecx, 1
  004e4	48 6b c9 02	 imul	 rcx, rcx, 2
  004e8	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004ed	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004f5	c1 e1 08	 shl	 ecx, 8
  004f8	0b c1		 or	 eax, ecx
  004fa	b9 01 00 00 00	 mov	 ecx, 1
  004ff	48 6b c9 03	 imul	 rcx, rcx, 3
  00503	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  00508	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  00510	0b c1		 or	 eax, ecx
  00512	89 44 24 4c	 mov	 DWORD PTR lastccw$[rsp], eax

; 878  :                 | (dev->scsw.ccwaddr[1] << 16)
; 879  :                 | (dev->scsw.ccwaddr[2] << 8)
; 880  :                 | dev->scsw.ccwaddr[3];
; 881  :     unitstat = dev->scsw.unitstat;

  00516	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0051b	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  00522	88 44 24 31	 mov	 BYTE PTR unitstat$[rsp], al

; 882  :     chanstat = dev->scsw.chanstat;

  00526	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0052b	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  00532	88 44 24 40	 mov	 BYTE PTR chanstat$[rsp], al

; 883  :     residual = (dev->scsw.count[0] << 8) | dev->scsw.count[1];

  00536	b8 01 00 00 00	 mov	 eax, 1
  0053b	48 6b c0 00	 imul	 rax, rax, 0
  0053f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00544	0f b6 84 01 12
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+786]
  0054c	c1 e0 08	 shl	 eax, 8
  0054f	b9 01 00 00 00	 mov	 ecx, 1
  00554	48 6b c9 01	 imul	 rcx, rcx, 1
  00558	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  0055d	0f b6 8c 0a 12
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+786]
  00565	0b c1		 or	 eax, ecx
  00567	66 89 44 24 44	 mov	 WORD PTR residual$[rsp], ax

; 884  : 
; 885  :     /* Clear the interrupt pending and device busy conditions */
; 886  :     obtain_lock (&dev->lock);

  0056c	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00571	48 83 c0 38	 add	 rax, 56			; 00000038H
  00575	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180426
  0057c	48 8b c8	 mov	 rcx, rax
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 887  :     dev->busy = dev->pending = 0;

  00585	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0058a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00590	0f ba f0 16	 btr	 eax, 22
  00594	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00599	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  0059f	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005a4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005aa	0f ba f0 13	 btr	 eax, 19
  005ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  005b3	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 888  :     dev->scsw.flag2 = 0;

  005b9	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005be	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 889  :     dev->scsw.flag3 = 0;

  005c5	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005ca	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 890  :     release_lock (&dev->lock);

  005d1	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005d6	48 83 c0 38	 add	 rax, 56			; 00000038H
  005da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180427
  005e1	48 8b c8	 mov	 rcx, rax
  005e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 891  : 
; 892  :     /* Store the last CCW address in the parameter list */
; 893  :     ioparm.lastccw[0] = (lastccw >> 24) & 0xFF;

  005ea	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005ee	c1 e8 18	 shr	 eax, 24
  005f1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005f6	b9 01 00 00 00	 mov	 ecx, 1
  005fb	48 6b c9 00	 imul	 rcx, rcx, 0
  005ff	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 894  :     ioparm.lastccw[1] = (lastccw >> 16) & 0xFF;

  00603	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  00607	c1 e8 10	 shr	 eax, 16
  0060a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0060f	b9 01 00 00 00	 mov	 ecx, 1
  00614	48 6b c9 01	 imul	 rcx, rcx, 1
  00618	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 895  :     ioparm.lastccw[2] = (lastccw >> 8) & 0xFF;

  0061c	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  00620	c1 e8 08	 shr	 eax, 8
  00623	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00628	b9 01 00 00 00	 mov	 ecx, 1
  0062d	48 6b c9 02	 imul	 rcx, rcx, 2
  00631	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 896  :     ioparm.lastccw[3] = lastccw & 0xFF;

  00635	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  00639	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0063e	b9 01 00 00 00	 mov	 ecx, 1
  00643	48 6b c9 03	 imul	 rcx, rcx, 3
  00647	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 897  : 
; 898  :     /* Store the device and subchannel status in the parameter list */
; 899  :     ioparm.unitstat = unitstat;

  0064b	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00650	88 44 24 74	 mov	 BYTE PTR ioparm$[rsp+20], al

; 900  :     ioparm.chanstat = chanstat;

  00654	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00659	88 44 24 75	 mov	 BYTE PTR ioparm$[rsp+21], al

; 901  : 
; 902  :     /* Store the residual byte count in the parameter list */
; 903  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  0065d	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  00662	c1 f8 08	 sar	 eax, 8
  00665	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0066a	b9 01 00 00 00	 mov	 ecx, 1
  0066f	48 6b c9 00	 imul	 rcx, rcx, 0
  00673	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 904  :     ioparm.residual[1] = residual & 0xFF;

  00677	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  0067c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00681	b9 01 00 00 00	 mov	 ecx, 1
  00686	48 6b c9 01	 imul	 rcx, rcx, 1
  0068a	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 905  : 
; 906  :     /* Return sense data if unit check occurred */
; 907  :     if (unitstat & CSW_UC)

  0068e	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00693	83 e0 02	 and	 eax, 2
  00696	85 c0		 test	 eax, eax
  00698	74 72		 je	 SHORT $LN30@s390_syncg

; 908  :     {
; 909  :         numsense = dev->numsense;

  0069a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0069f	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  006a5	89 44 24 48	 mov	 DWORD PTR numsense$[rsp], eax

; 910  :         if (numsense > sizeof(ioparm.sense))

  006a9	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006ad	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  006b1	76 08		 jbe	 SHORT $LN31@s390_syncg

; 911  :             numsense = sizeof(ioparm.sense);

  006b3	c7 44 24 48 20
	00 00 00	 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN31@s390_syncg:

; 912  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  006bb	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006bf	c1 e8 08	 shr	 eax, 8
  006c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006c7	b9 01 00 00 00	 mov	 ecx, 1
  006cc	48 6b c9 00	 imul	 rcx, rcx, 0
  006d0	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 913  :         ioparm.sensecount[1] = numsense & 0xFF;

  006d4	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006d8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006dd	b9 01 00 00 00	 mov	 ecx, 1
  006e2	48 6b c9 01	 imul	 rcx, rcx, 1
  006e6	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 914  :         memcpy (ioparm.sense, dev->sense, numsense);

  006ea	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  006f3	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  006fa	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  00702	48 8b fa	 mov	 rdi, rdx
  00705	48 8b f1	 mov	 rsi, rcx
  00708	8b c8		 mov	 ecx, eax
  0070a	f3 a4		 rep movsb
$LN30@s390_syncg:

; 915  :     }
; 916  : 
; 917  :     /* Store the updated parameter list in real storage */
; 918  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  0070c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00714	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00719	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0071f	44 8b 44 24 50	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  00724	b2 57		 mov	 dl, 87			; 00000057H
  00726	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  0072b	e8 00 00 00 00	 call	 s390_vstorec

; 919  : 
; 920  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 921  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00730	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00735	83 f8 0c	 cmp	 eax, 12
  00738	75 09		 jne	 SHORT $LN33@s390_syncg
  0073a	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0073f	85 c0		 test	 eax, eax
  00741	74 23		 je	 SHORT $LN32@s390_syncg
$LN33@s390_syncg:

; 922  :     {
; 923  :         regs->GR_L(15) = 13;

  00743	b8 08 00 00 00	 mov	 eax, 8
  00748	48 6b c0 0f	 imul	 rax, rax, 15
  0074c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00754	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 924  :         return 3;

  0075f	b8 03 00 00 00	 mov	 eax, 3
  00764	eb 02		 jmp	 SHORT $LN1@s390_syncg
$LN32@s390_syncg:

; 925  :     }
; 926  : 
; 927  :     /* Return with condition code 0 and register 15 unchanged */
; 928  :     return 0;

  00766	33 c0		 xor	 eax, eax
$LN1@s390_syncg:

; 929  : 
; 930  : } /* end function syncgen_io */

  00768	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00770	48 33 cc	 xor	 rcx, rsp
  00773	e8 00 00 00 00	 call	 __security_check_cookie
  00778	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0077f	5f		 pop	 rdi
  00780	5e		 pop	 rsi
  00781	c3		 ret	 0
s390_syncgen_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
chanstat$ = 112
accum$ = 113
unitstat$ = 114
dev$ = 120
skey1$ = 128
skey2$ = 129
i$ = 132
blksize$ = 136
sbiaddr$ = 140
blkcount$ = 144
absadr$ = 148
numsense$ = 152
iopaddr$ = 156
devnum$ = 160
sbicount$ = 164
residual$ = 168
tv339 = 172
tv345 = 176
blknum$ = 180
tv334 = 184
ioparm$ = 192
__$ArrayPad$ = 288
r1$ = 336
r2$ = 344
regs$ = 352
s390_syncblk_io PROC

; 491  : {

$LN51:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 492  : U32             i;                      /* Array subscript           */
; 493  : U32             numsense;               /* Number of sense bytes     */
; 494  : U32             iopaddr;                /* Address of HCPSBIOP       */
; 495  : HCPSBIOP        ioparm;                 /* I/O parameter list        */
; 496  : DEVBLK         *dev;                    /* -> Device block           */
; 497  : U16             devnum;                 /* Device number             */
; 498  : U32             residual;               /* Residual byte count       */
; 499  : U32             blksize;                /* Fixed block size          */
; 500  : U32             sbiaddr;                /* Addr of SBILIST           */
; 501  : U32             sbicount;               /* Number of SBILIST entries */
; 502  : U32             blkcount;               /* Number of blocks processed*/
; 503  : U32             blknum;                 /* Block number              */
; 504  : U32             absadr;                 /* Absolute storage address  */
; 505  : BYTE            accum;                  /* Work area                 */
; 506  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 72 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 507  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 70 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@s390_syncb:

; 508  : BYTE            skey1, skey2;           /* Storage keys of first and
; 509  :                                            last byte of I/O buffer   */
; 510  : //FIXME: code not right for shared devices
; 511  : 
; 512  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@s390_syncb

; 513  : 
; 514  :     /* Register R1 contains the real address of the parameter list */
; 515  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR iopaddr$[rsp], eax

; 516  : 
; 517  :     /* Program check if parameter list not on fullword boundary */
; 518  :     if (iopaddr & 0x00000003)

  00056	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  0005d	83 e0 03	 and	 eax, 3
  00060	85 c0		 test	 eax, eax
  00062	74 12		 je	 SHORT $LN14@s390_syncb

; 519  :     {
; 520  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00064	ba 06 00 00 00	 mov	 edx, 6
  00069	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_syncb:

; 521  :     }
; 522  : 
; 523  :     /* Ensure that parameter list operand is addressable */
; 524  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00076	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00083	41 b9 02 00 00
	00		 mov	 r9d, 2
  00089	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  0008f	ba fe ff ff ff	 mov	 edx, -2
  00094	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR iopaddr$[rsp]
  0009b	e8 00 00 00 00	 call	 s390_validate_operand

; 525  :                         ACCTYPE_WRITE, regs);
; 526  : 
; 527  :     /* Fetch the parameter list from real storage */
; 528  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  000a0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ad	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000b3	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  000bb	b2 57		 mov	 dl, 87			; 00000057H
  000bd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000c5	e8 00 00 00 00	 call	 s390_vfetchc

; 529  : 
; 530  :     /* Load numeric fields from the parameter list */
; 531  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 00	 imul	 rax, rax, 0
  000d3	0f b6 84 04 c0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000db	c1 e0 08	 shl	 eax, 8
  000de	b9 01 00 00 00	 mov	 ecx, 1
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000ef	0b c1		 or	 eax, ecx
  000f1	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax

; 532  :     blksize = (ioparm.blksize[0] << 24)

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	0f b6 84 04 c4
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  0010a	c1 e0 18	 shl	 eax, 24
  0010d	b9 01 00 00 00	 mov	 ecx, 1
  00112	48 6b c9 01	 imul	 rcx, rcx, 1
  00116	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  0011e	c1 e1 10	 shl	 ecx, 16
  00121	0b c1		 or	 eax, ecx
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	48 6b c9 02	 imul	 rcx, rcx, 2
  0012c	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  00134	c1 e1 08	 shl	 ecx, 8
  00137	0b c1		 or	 eax, ecx
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	48 6b c9 03	 imul	 rcx, rcx, 3
  00142	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  0014a	0b c1		 or	 eax, ecx
  0014c	89 84 24 88 00
	00 00		 mov	 DWORD PTR blksize$[rsp], eax

; 533  :                 | (ioparm.blksize[1] << 16)
; 534  :                 | (ioparm.blksize[2] << 8)
; 535  :                 | ioparm.blksize[3];
; 536  :     sbiaddr = (ioparm.sbiaddr[0] << 24)

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	48 6b c0 00	 imul	 rax, rax, 0
  0015c	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  00164	c1 e0 18	 shl	 eax, 24
  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	48 6b c9 01	 imul	 rcx, rcx, 1
  00170	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00178	c1 e1 10	 shl	 ecx, 16
  0017b	0b c1		 or	 eax, ecx
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 02	 imul	 rcx, rcx, 2
  00186	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  0018e	c1 e1 08	 shl	 ecx, 8
  00191	0b c1		 or	 eax, ecx
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	48 6b c9 03	 imul	 rcx, rcx, 3
  0019c	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  001a4	0b c1		 or	 eax, ecx
  001a6	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 537  :                 | (ioparm.sbiaddr[1] << 16)
; 538  :                 | (ioparm.sbiaddr[2] << 8)
; 539  :                 | ioparm.sbiaddr[3];
; 540  :     sbicount = (ioparm.sbicount[0] << 24)

  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	48 6b c0 00	 imul	 rax, rax, 0
  001b6	0f b6 84 04 cc
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  001be	c1 e0 18	 shl	 eax, 24
  001c1	b9 01 00 00 00	 mov	 ecx, 1
  001c6	48 6b c9 01	 imul	 rcx, rcx, 1
  001ca	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001d2	c1 e1 10	 shl	 ecx, 16
  001d5	0b c1		 or	 eax, ecx
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	48 6b c9 02	 imul	 rcx, rcx, 2
  001e0	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001e8	c1 e1 08	 shl	 ecx, 8
  001eb	0b c1		 or	 eax, ecx
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	48 6b c9 03	 imul	 rcx, rcx, 3
  001f6	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001fe	0b c1		 or	 eax, ecx
  00200	89 84 24 a4 00
	00 00		 mov	 DWORD PTR sbicount$[rsp], eax

; 541  :                 | (ioparm.sbicount[1] << 16)
; 542  :                 | (ioparm.sbicount[2] << 8)
; 543  :                 | ioparm.sbicount[3];
; 544  : 
; 545  :     /* Locate the device block */
; 546  :     dev = find_device_by_devnum (0,devnum);

  00207	0f b7 94 24 a0
	00 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  0020f	33 c9		 xor	 ecx, ecx
  00211	e8 00 00 00 00	 call	 find_device_by_devnum
  00216	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax

; 547  : 
; 548  :     /* Set return code 2 and cond code 1 if device does not exist
; 549  :        or does not support the synchronous I/O call */
; 550  :     if (dev == NULL || dev->devtype != 0x3370)

  0021b	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00221	74 10		 je	 SHORT $LN16@s390_syncb
  00223	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00228	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0022c	3d 70 33 00 00	 cmp	 eax, 13168		; 00003370H
  00231	74 26		 je	 SHORT $LN15@s390_syncb
$LN16@s390_syncb:

; 551  :     {
; 552  :         regs->GR_L(15) = 2;

  00233	b8 08 00 00 00	 mov	 eax, 8
  00238	48 6b c0 0f	 imul	 rax, rax, 15
  0023c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	c7 84 01 80 02
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 2

; 553  :         return 1;

  0024f	b8 01 00 00 00	 mov	 eax, 1
  00254	e9 ac 08 00 00	 jmp	 $LN1@s390_syncb
$LN15@s390_syncb:

; 554  :     }
; 555  : 
; 556  :     /* Program check if protect key bits 4-7 are not zero
; 557  :        or if I/O request type is not read or write */
; 558  :     if ((ioparm.akey & 0x0F)
; 559  :         || !(ioparm.type == HCPSBIOP_WRITE

  00259	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00261	83 e0 0f	 and	 eax, 15
  00264	85 c0		 test	 eax, eax
  00266	75 1a		 jne	 SHORT $LN18@s390_syncb
  00268	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00270	83 f8 01	 cmp	 eax, 1
  00273	74 1f		 je	 SHORT $LN17@s390_syncb
  00275	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0027d	83 f8 02	 cmp	 eax, 2
  00280	74 12		 je	 SHORT $LN17@s390_syncb
$LN18@s390_syncb:

; 560  :             || ioparm.type == HCPSBIOP_READ))
; 561  :     {
; 562  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00282	ba 15 00 00 00	 mov	 edx, 21
  00287	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN17@s390_syncb:

; 563  :     }
; 564  : 
; 565  :     /* Set return code 8 and cond code 2 if blocksize is invalid */
; 566  :     if (!(blksize == 512 || blksize == 1024

  00294	81 bc 24 88 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR blksize$[rsp], 512 ; 00000200H
  0029f	74 4d		 je	 SHORT $LN19@s390_syncb
  002a1	81 bc 24 88 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR blksize$[rsp], 1024 ; 00000400H
  002ac	74 40		 je	 SHORT $LN19@s390_syncb
  002ae	81 bc 24 88 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR blksize$[rsp], 2048 ; 00000800H
  002b9	74 33		 je	 SHORT $LN19@s390_syncb
  002bb	81 bc 24 88 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR blksize$[rsp], 4096 ; 00001000H
  002c6	74 26		 je	 SHORT $LN19@s390_syncb

; 567  :             || blksize == 2048 || blksize == 4096))
; 568  :     {
; 569  :         regs->GR_L(15) = 8;

  002c8	b8 08 00 00 00	 mov	 eax, 8
  002cd	48 6b c0 0f	 imul	 rax, rax, 15
  002d1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	c7 84 01 80 02
	00 00 08 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 8

; 570  :         return 2;

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 17 08 00 00	 jmp	 $LN1@s390_syncb
$LN19@s390_syncb:

; 571  :     }
; 572  : 
; 573  :     /* Program check if SBILIST is not on a doubleword boundary */
; 574  :     if (sbiaddr & 0x00000007)

  002ee	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  002f5	83 e0 07	 and	 eax, 7
  002f8	85 c0		 test	 eax, eax
  002fa	74 12		 je	 SHORT $LN20@s390_syncb

; 575  :     {
; 576  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002fc	ba 15 00 00 00	 mov	 edx, 21
  00301	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_syncb:

; 577  :     }
; 578  : 
; 579  :     /* Program check if reserved fields are not zero */
; 580  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  0030e	c6 44 24 71 00	 mov	 BYTE PTR accum$[rsp], 0
  00313	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0031e	eb 10		 jmp	 SHORT $LN7@s390_syncb
$LN5@s390_syncb:
  00320	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00327	ff c0		 inc	 eax
  00329	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_syncb:
  00330	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00337	48 83 f8 05	 cmp	 rax, 5
  0033b	73 1e		 jae	 SHORT $LN6@s390_syncb

; 581  :         accum |= ioparm.resv1[i];

  0033d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00344	0f b6 84 04 d9
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  0034c	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  00351	0b c8		 or	 ecx, eax
  00353	8b c1		 mov	 eax, ecx
  00355	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  00359	eb c5		 jmp	 SHORT $LN5@s390_syncb
$LN6@s390_syncb:

; 582  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  0035b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00366	eb 10		 jmp	 SHORT $LN10@s390_syncb
$LN8@s390_syncb:
  00368	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0036f	ff c0		 inc	 eax
  00371	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_syncb:
  00378	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0037f	48 83 f8 18	 cmp	 rax, 24
  00383	73 1e		 jae	 SHORT $LN9@s390_syncb

; 583  :         accum |= ioparm.resv2[i];

  00385	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0038c	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  00394	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  00399	0b c8		 or	 ecx, eax
  0039b	8b c1		 mov	 eax, ecx
  0039d	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  003a1	eb c5		 jmp	 SHORT $LN8@s390_syncb
$LN9@s390_syncb:

; 584  :     if (accum != 0)

  003a3	0f b6 44 24 71	 movzx	 eax, BYTE PTR accum$[rsp]
  003a8	85 c0		 test	 eax, eax
  003aa	74 12		 je	 SHORT $LN21@s390_syncb

; 585  :     {
; 586  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  003ac	ba 15 00 00 00	 mov	 edx, 21
  003b1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	e8 00 00 00 00	 call	 s390_program_interrupt
$LN21@s390_syncb:

; 587  :     }
; 588  : 
; 589  :     /* Set return code 11 and cond code 2 if SBI count is invalid */
; 590  :     if (sbicount < 1 || sbicount > 500)

  003be	83 bc 24 a4 00
	00 00 01	 cmp	 DWORD PTR sbicount$[rsp], 1
  003c6	72 0d		 jb	 SHORT $LN23@s390_syncb
  003c8	81 bc 24 a4 00
	00 00 f4 01 00
	00		 cmp	 DWORD PTR sbicount$[rsp], 500 ; 000001f4H
  003d3	76 26		 jbe	 SHORT $LN22@s390_syncb
$LN23@s390_syncb:

; 591  :     {
; 592  :         regs->GR_L(15) = 11;

  003d5	b8 08 00 00 00	 mov	 eax, 8
  003da	48 6b c0 0f	 imul	 rax, rax, 15
  003de	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e6	c7 84 01 80 02
	00 00 0b 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 11

; 593  :         return 2;

  003f1	b8 02 00 00 00	 mov	 eax, 2
  003f6	e9 0a 07 00 00	 jmp	 $LN1@s390_syncb
$LN22@s390_syncb:

; 594  :     }
; 595  : 
; 596  :     /* Obtain the device lock */
; 597  :     obtain_lock (&dev->lock);

  003fb	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00400	48 83 c0 38	 add	 rax, 56			; 00000038H
  00404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180341
  0040b	48 8b c8	 mov	 rcx, rax
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 598  : 
; 599  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 600  :     /* Return code 5 and condition code 1 if status pending */
; 601  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 602  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))

  00414	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00419	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00420	83 e0 01	 and	 eax, 1
  00423	85 c0		 test	 eax, eax
  00425	75 13		 jne	 SHORT $LN25@s390_syncb
  00427	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0042c	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00433	83 e0 01	 and	 eax, 1
  00436	85 c0		 test	 eax, eax
  00438	74 3f		 je	 SHORT $LN24@s390_syncb
$LN25@s390_syncb:

; 603  :     {
; 604  :         release_lock (&dev->lock);

  0043a	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0043f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00443	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180344
  0044a	48 8b c8	 mov	 rcx, rax
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 605  :         regs->GR_L(15) = 5;

  00453	b8 08 00 00 00	 mov	 eax, 8
  00458	48 6b c0 0f	 imul	 rax, rax, 15
  0045c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00464	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 606  :         return 1;

  0046f	b8 01 00 00 00	 mov	 eax, 1
  00474	e9 8c 06 00 00	 jmp	 $LN1@s390_syncb
$LN24@s390_syncb:

; 607  :     }
; 608  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 609  : 
; 610  :     /* Return code 5 and condition code 1 if device is busy */
; 611  :     if (dev->busy || IOPENDING(dev))

  00479	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0047e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00484	c1 e8 13	 shr	 eax, 19
  00487	83 e0 01	 and	 eax, 1
  0048a	85 c0		 test	 eax, eax
  0048c	75 54		 jne	 SHORT $LN27@s390_syncb
  0048e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00493	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00499	c1 e8 16	 shr	 eax, 22
  0049c	83 e0 01	 and	 eax, 1
  0049f	85 c0		 test	 eax, eax
  004a1	75 3f		 jne	 SHORT $LN28@s390_syncb
  004a3	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004a8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004ae	c1 e8 17	 shr	 eax, 23
  004b1	83 e0 01	 and	 eax, 1
  004b4	85 c0		 test	 eax, eax
  004b6	75 2a		 jne	 SHORT $LN28@s390_syncb
  004b8	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004bd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004c3	c1 e8 18	 shr	 eax, 24
  004c6	83 e0 01	 and	 eax, 1
  004c9	85 c0		 test	 eax, eax
  004cb	75 15		 jne	 SHORT $LN28@s390_syncb
  004cd	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004d2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004d8	c1 e8 1b	 shr	 eax, 27
  004db	83 e0 01	 and	 eax, 1
  004de	85 c0		 test	 eax, eax
  004e0	74 3f		 je	 SHORT $LN26@s390_syncb
$LN28@s390_syncb:
$LN27@s390_syncb:

; 612  :     {
; 613  :         release_lock (&dev->lock);

  004e2	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004e7	48 83 c0 38	 add	 rax, 56			; 00000038H
  004eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180348
  004f2	48 8b c8	 mov	 rcx, rax
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 614  :         regs->GR_L(15) = 5;

  004fb	b8 08 00 00 00	 mov	 eax, 8
  00500	48 6b c0 0f	 imul	 rax, rax, 15
  00504	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050c	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 615  :         return 1;

  00517	b8 01 00 00 00	 mov	 eax, 1
  0051c	e9 e4 05 00 00	 jmp	 $LN1@s390_syncb
$LN26@s390_syncb:

; 616  :     }
; 617  : 
; 618  :     /* Set the device busy indicator */
; 619  :     dev->busy = 1;

  00521	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00526	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0052c	0f ba e8 13	 bts	 eax, 19
  00530	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00535	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 620  : 
; 621  :     /* Release the device lock */
; 622  :     release_lock (&dev->lock);

  0053b	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00540	48 83 c0 38	 add	 rax, 56			; 00000038H
  00544	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180349
  0054b	48 8b c8	 mov	 rcx, rax
  0054e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 623  : 
; 624  :     /* Process each entry in the SBILIST */
; 625  :     for (blkcount = 0; blkcount < sbicount; blkcount++)

  00554	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR blkcount$[rsp], 0
  0055f	eb 10		 jmp	 SHORT $LN13@s390_syncb
$LN11@s390_syncb:
  00561	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00568	ff c0		 inc	 eax
  0056a	89 84 24 90 00
	00 00		 mov	 DWORD PTR blkcount$[rsp], eax
$LN13@s390_syncb:
  00571	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR sbicount$[rsp]
  00578	39 84 24 90 00
	00 00		 cmp	 DWORD PTR blkcount$[rsp], eax
  0057f	0f 83 82 03 00
	00		 jae	 $LN12@s390_syncb

; 626  :     {
; 627  :         /* Return code 10 and cond code 2 if SBILIST entry
; 628  :            is outside main storage or is fetch protected.
; 629  :            Note that the SBI address is an absolute address
; 630  :            and is not subject to fetch-protection override
; 631  :            or storage-protection override mechanisms, and
; 632  :            an SBILIST entry cannot cross a page boundary */
; 633  :         if (sbiaddr > regs->mainlim
; 634  :             || ((ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_FETCH)

  00585	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  0058c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00594	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0059b	77 46		 ja	 SHORT $LN30@s390_syncb
  0059d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005a4	8b c8		 mov	 ecx, eax
  005a6	e8 00 00 00 00	 call	 s390_get_storage_key
  005ab	0f b6 c0	 movzx	 eax, al
  005ae	83 e0 08	 and	 eax, 8
  005b1	85 c0		 test	 eax, eax
  005b3	74 54		 je	 SHORT $LN29@s390_syncb
  005b5	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005bc	8b c8		 mov	 ecx, eax
  005be	e8 00 00 00 00	 call	 s390_get_storage_key
  005c3	0f b6 c0	 movzx	 eax, al
  005c6	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005cb	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  005d3	3b c1		 cmp	 eax, ecx
  005d5	74 32		 je	 SHORT $LN29@s390_syncb
  005d7	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  005df	85 c0		 test	 eax, eax
  005e1	74 26		 je	 SHORT $LN29@s390_syncb
$LN30@s390_syncb:

; 635  :                 && (ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_KEY) != ioparm.akey
; 636  :                 && ioparm.akey != 0))
; 637  :         {
; 638  :             regs->GR_L(15) = 10;

  005e3	b8 08 00 00 00	 mov	 eax, 8
  005e8	48 6b c0 0f	 imul	 rax, rax, 15
  005ec	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f4	c7 84 01 80 02
	00 00 0a 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 10

; 639  :             return 2;

  005ff	b8 02 00 00 00	 mov	 eax, 2
  00604	e9 fc 04 00 00	 jmp	 $LN1@s390_syncb
$LN29@s390_syncb:

; 640  :         }
; 641  : 
; 642  :         /* Load block number and data address from SBILIST */
; 643  :         blknum = ARCH_DEP(fetch_fullword_absolute)(sbiaddr, regs);

  00609	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00610	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00618	8b c8		 mov	 ecx, eax
  0061a	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  0061f	89 84 24 b4 00
	00 00		 mov	 DWORD PTR blknum$[rsp], eax

; 644  :         absadr = ARCH_DEP(fetch_fullword_absolute)(sbiaddr+4, regs);

  00626	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  0062d	83 c0 04	 add	 eax, 4
  00630	8b c0		 mov	 eax, eax
  00632	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0063a	8b c8		 mov	 ecx, eax
  0063c	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  00641	89 84 24 94 00
	00 00		 mov	 DWORD PTR absadr$[rsp], eax

; 645  : 
; 646  :         if (dev->ccwtrace)

  00648	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0064d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00653	c1 e8 0f	 shr	 eax, 15
  00656	83 e0 01	 and	 eax, 1
  00659	85 c0		 test	 eax, eax
  0065b	0f 84 04 01 00
	00		 je	 $LN31@s390_syncb

; 647  :         {
; 648  :             WRMSG(HHC01952, "I",

  00661	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00669	83 f8 01	 cmp	 eax, 1
  0066c	75 11		 jne	 SHORT $LN45@s390_syncb
  0066e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180353
  00675	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv334[rsp], rax
  0067d	eb 0f		 jmp	 SHORT $LN46@s390_syncb
$LN45@s390_syncb:
  0067f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180354
  00686	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv334[rsp], rax
$LN46@s390_syncb:
  0068e	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00694	74 12		 je	 SHORT $LN47@s390_syncb
  00696	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0069b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0069f	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
  006a6	eb 0b		 jmp	 SHORT $LN48@s390_syncb
$LN47@s390_syncb:
  006a8	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv339[rsp], 0
$LN48@s390_syncb:
  006b3	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006b9	74 14		 je	 SHORT $LN49@s390_syncb
  006bb	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  006c0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006c4	d1 f8		 sar	 eax, 1
  006c6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv345[rsp], eax
  006cd	eb 0b		 jmp	 SHORT $LN50@s390_syncb
$LN49@s390_syncb:
  006cf	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv345[rsp], 0
$LN50@s390_syncb:
  006da	b9 01 00 00 00	 mov	 ecx, 1
  006df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e5	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  006ec	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  006f0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR absadr$[rsp]
  006f7	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  006fb	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR blknum$[rsp]
  00702	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00706	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv334[rsp]
  0070e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00713	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv339[rsp]
  0071a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0071e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv345[rsp]
  00725	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00729	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180355
  00730	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00735	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180356
  0073c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00741	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00746	41 b9 03 00 00
	00		 mov	 r9d, 3
  0074c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180357
  00753	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  00758	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180358
  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@s390_syncb:

; 649  :                     LCSS_DEVNUM,
; 650  :                     (ioparm.type == HCPSBIOP_WRITE ? "WRITE" : "READ"),
; 651  :                     blknum, absadr, blksize);
; 652  :         }
; 653  : 
; 654  :         /* Return code 12 and cond code 2 if buffer exceeds storage */
; 655  :         if (absadr > regs->mainlim - blksize)

  00765	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  0076c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  00773	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0077b	48 8b 92 58 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2136]
  00782	48 2b d1	 sub	 rdx, rcx
  00785	48 8b ca	 mov	 rcx, rdx
  00788	48 3b c1	 cmp	 rax, rcx
  0078b	76 26		 jbe	 SHORT $LN32@s390_syncb

; 656  :         {
; 657  :             regs->GR_L(15) = 12;

  0078d	b8 08 00 00 00	 mov	 eax, 8
  00792	48 6b c0 0f	 imul	 rax, rax, 15
  00796	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079e	c7 84 01 80 02
	00 00 0c 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 12

; 658  :             return 2;

  007a9	b8 02 00 00 00	 mov	 eax, 2
  007ae	e9 52 03 00 00	 jmp	 $LN1@s390_syncb
$LN32@s390_syncb:

; 659  :         }
; 660  : 
; 661  :         /* Channel protection check if access key does not match
; 662  :            storage keys of buffer.  Note that the buffer address is
; 663  :            an absolute address, the buffer cannot span more than two
; 664  :            pages, and the access is not subject to fetch-protection
; 665  :            override, storage-protection override, or low-address
; 666  :            protection */
; 667  :         skey1 = ARCH_DEP( get_storage_key )( absadr );

  007b3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  007ba	8b c8		 mov	 ecx, eax
  007bc	e8 00 00 00 00	 call	 s390_get_storage_key
  007c1	88 84 24 80 00
	00 00		 mov	 BYTE PTR skey1$[rsp], al

; 668  :         skey2 = ARCH_DEP( get_storage_key )( absadr + blksize - 1 );

  007c8	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  007cf	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  007d6	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  007da	8b c0		 mov	 eax, eax
  007dc	8b c8		 mov	 ecx, eax
  007de	e8 00 00 00 00	 call	 s390_get_storage_key
  007e3	88 84 24 81 00
	00 00		 mov	 BYTE PTR skey2$[rsp], al

; 669  :         if (ioparm.akey != 0
; 670  :             && (

  007ea	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  007f2	85 c0		 test	 eax, eax
  007f4	74 7b		 je	 SHORT $LN33@s390_syncb
  007f6	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR skey1$[rsp]
  007fe	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00803	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  0080b	3b c1		 cmp	 eax, ecx
  0080d	74 1c		 je	 SHORT $LN35@s390_syncb
  0080f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR skey1$[rsp]
  00817	83 e0 08	 and	 eax, 8
  0081a	85 c0		 test	 eax, eax
  0081c	75 42		 jne	 SHORT $LN34@s390_syncb
  0081e	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00826	83 f8 02	 cmp	 eax, 2
  00829	74 35		 je	 SHORT $LN34@s390_syncb
$LN35@s390_syncb:
  0082b	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR skey2$[rsp]
  00833	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00838	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  00840	3b c1		 cmp	 eax, ecx
  00842	74 2d		 je	 SHORT $LN33@s390_syncb
  00844	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR skey2$[rsp]
  0084c	83 e0 08	 and	 eax, 8
  0084f	85 c0		 test	 eax, eax
  00851	75 0d		 jne	 SHORT $LN36@s390_syncb
  00853	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0085b	83 f8 02	 cmp	 eax, 2
  0085e	75 11		 jne	 SHORT $LN33@s390_syncb
$LN36@s390_syncb:
$LN34@s390_syncb:

; 671  :                    ((skey1 & STORKEY_KEY) != ioparm.akey
; 672  :                     && ((skey1 & STORKEY_FETCH)
; 673  :                         || ioparm.type == HCPSBIOP_READ))
; 674  :                 || ((skey2 & STORKEY_KEY) != ioparm.akey
; 675  :                     && ((skey2 & STORKEY_FETCH)
; 676  :                         || ioparm.type == HCPSBIOP_READ))
; 677  :             ))
; 678  :         {
; 679  :             chanstat |= CSW_PROTC;

  00860	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00865	83 c8 10	 or	 eax, 16
  00868	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al

; 680  :             break;

  0086c	e9 96 00 00 00	 jmp	 $LN12@s390_syncb
$LN33@s390_syncb:

; 681  :         }
; 682  : 
; 683  :         /* Call device handler to read or write one block */
; 684  :         fbadasd_syncblk_io (dev, ioparm.type, blknum, blksize,

  00871	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00878	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00880	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00887	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR residual$[rsp]
  0088f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00894	48 8d 4c 24 72	 lea	 rcx, QWORD PTR unitstat$[rsp]
  00899	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0089e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a3	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR blksize$[rsp]
  008ab	44 8b 84 24 b4
	00 00 00	 mov	 r8d, DWORD PTR blknum$[rsp]
  008b3	0f b6 94 24 c3
	00 00 00	 movzx	 edx, BYTE PTR ioparm$[rsp+3]
  008bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  008c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fbadasd_syncblk_io

; 685  :                             regs->mainstor + absadr,
; 686  :                             &unitstat, &residual);
; 687  : 
; 688  :         /* Set incorrect length if residual count is non-zero */
; 689  :         if (residual != 0)

  008c6	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR residual$[rsp], 0
  008ce	74 0c		 je	 SHORT $LN37@s390_syncb

; 690  :             chanstat |= CSW_IL;

  008d0	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  008d5	83 c8 40	 or	 eax, 64			; 00000040H
  008d8	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al
$LN37@s390_syncb:

; 691  : 
; 692  :         /* Exit if any unusual status */
; 693  :         if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  008dc	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  008e1	83 f8 0c	 cmp	 eax, 12
  008e4	75 09		 jne	 SHORT $LN39@s390_syncb
  008e6	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  008eb	85 c0		 test	 eax, eax
  008ed	74 02		 je	 SHORT $LN38@s390_syncb
$LN39@s390_syncb:

; 694  :             break;

  008ef	eb 16		 jmp	 SHORT $LN12@s390_syncb
$LN38@s390_syncb:

; 695  : 
; 696  :         /* Point to next SBILIST entry */
; 697  :         sbiaddr += 8;

  008f1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  008f8	83 c0 08	 add	 eax, 8
  008fb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 698  : 
; 699  :     } /* end for(blkcount) */

  00902	e9 5a fc ff ff	 jmp	 $LN11@s390_syncb
$LN12@s390_syncb:

; 700  : 
; 701  :     /* Reset the device busy indicator */
; 702  :     dev->busy = 0;

  00907	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0090c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00912	0f ba f0 13	 btr	 eax, 19
  00916	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  0091b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 703  : 
; 704  :     /* Store the block count in the parameter list */
; 705  :     ioparm.blkcount[0] = (blkcount >> 24) & 0xFF;

  00921	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00928	c1 e8 18	 shr	 eax, 24
  0092b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00930	b9 01 00 00 00	 mov	 ecx, 1
  00935	48 6b c9 00	 imul	 rcx, rcx, 0
  00939	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 706  :     ioparm.blkcount[1] = (blkcount >> 16) & 0xFF;

  00940	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00947	c1 e8 10	 shr	 eax, 16
  0094a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0094f	b9 01 00 00 00	 mov	 ecx, 1
  00954	48 6b c9 01	 imul	 rcx, rcx, 1
  00958	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 707  :     ioparm.blkcount[2] = (blkcount >> 8) & 0xFF;

  0095f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00966	c1 e8 08	 shr	 eax, 8
  00969	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0096e	b9 01 00 00 00	 mov	 ecx, 1
  00973	48 6b c9 02	 imul	 rcx, rcx, 2
  00977	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 708  :     ioparm.blkcount[3] = blkcount & 0xFF;

  0097e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00985	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0098a	b9 01 00 00 00	 mov	 ecx, 1
  0098f	48 6b c9 03	 imul	 rcx, rcx, 3
  00993	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 709  : 
; 710  :     /* Store the device and subchannel status in the parameter list */
; 711  :     ioparm.unitstat = unitstat;

  0099a	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0099f	88 84 24 d4 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+20], al

; 712  :     ioparm.chanstat = chanstat;

  009a6	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  009ab	88 84 24 d5 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+21], al

; 713  : 
; 714  :     /* Store the residual byte count in the parameter list */
; 715  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  009b2	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  009b9	c1 e8 08	 shr	 eax, 8
  009bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009c1	b9 01 00 00 00	 mov	 ecx, 1
  009c6	48 6b c9 00	 imul	 rcx, rcx, 0
  009ca	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 716  :     ioparm.residual[1] = residual & 0xFF;

  009d1	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  009d8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009dd	b9 01 00 00 00	 mov	 ecx, 1
  009e2	48 6b c9 01	 imul	 rcx, rcx, 1
  009e6	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 717  : 
; 718  :     /* Return sense data if unit check occurred */
; 719  :     if (unitstat & CSW_UC)

  009ed	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  009f2	83 e0 02	 and	 eax, 2
  009f5	85 c0		 test	 eax, eax
  009f7	0f 84 8a 00 00
	00		 je	 $LN40@s390_syncb

; 720  :     {
; 721  :         numsense = dev->numsense;

  009fd	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00a02	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00a08	89 84 24 98 00
	00 00		 mov	 DWORD PTR numsense$[rsp], eax

; 722  :         if (numsense > sizeof(ioparm.sense))

  00a0f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a16	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00a1a	76 0b		 jbe	 SHORT $LN41@s390_syncb

; 723  :             numsense = sizeof(ioparm.sense);

  00a1c	c7 84 24 98 00
	00 00 20 00 00
	00		 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN41@s390_syncb:

; 724  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  00a27	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a2e	c1 e8 08	 shr	 eax, 8
  00a31	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a36	b9 01 00 00 00	 mov	 ecx, 1
  00a3b	48 6b c9 00	 imul	 rcx, rcx, 0
  00a3f	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 725  :         ioparm.sensecount[1] = numsense & 0xFF;

  00a46	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a4d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a52	b9 01 00 00 00	 mov	 ecx, 1
  00a57	48 6b c9 01	 imul	 rcx, rcx, 1
  00a5b	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 726  :         memcpy (ioparm.sense, dev->sense, numsense);

  00a62	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  00a69	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00a6e	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00a75	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  00a7d	48 8b fa	 mov	 rdi, rdx
  00a80	48 8b f1	 mov	 rsi, rcx
  00a83	8b c8		 mov	 ecx, eax
  00a85	f3 a4		 rep movsb
$LN40@s390_syncb:

; 727  :     }
; 728  : 
; 729  :     /* Store the updated parameter list in real storage */
; 730  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00a87	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a8f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a94	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00a9a	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  00aa2	b2 57		 mov	 dl, 87			; 00000057H
  00aa4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  00aac	e8 00 00 00 00	 call	 s390_vstorec

; 731  : 
; 732  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 733  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00ab1	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00ab6	83 f8 0c	 cmp	 eax, 12
  00ab9	75 09		 jne	 SHORT $LN43@s390_syncb
  00abb	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00ac0	85 c0		 test	 eax, eax
  00ac2	74 23		 je	 SHORT $LN42@s390_syncb
$LN43@s390_syncb:

; 734  :     {
; 735  :         regs->GR_L(15) = 13;

  00ac4	b8 08 00 00 00	 mov	 eax, 8
  00ac9	48 6b c0 0f	 imul	 rax, rax, 15
  00acd	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ad5	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 736  :         return 3;

  00ae0	b8 03 00 00 00	 mov	 eax, 3
  00ae5	eb 1e		 jmp	 SHORT $LN1@s390_syncb
$LN42@s390_syncb:

; 737  :     }
; 738  : 
; 739  :     /* Set return code 0 and cond code 0 */
; 740  :     regs->GR_L(15) = 0;

  00ae7	b8 08 00 00 00	 mov	 eax, 8
  00aec	48 6b c0 0f	 imul	 rax, rax, 15
  00af0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00af8	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 741  :     return 0;

  00b03	33 c0		 xor	 eax, eax
$LN1@s390_syncb:

; 742  : 
; 743  : } /* end function syncblk_io */

  00b05	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b0d	48 33 cc	 xor	 rcx, rsp
  00b10	e8 00 00 00 00	 call	 __security_check_cookie
  00b15	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00b1c	5f		 pop	 rdi
  00b1d	5e		 pop	 rsi
  00b1e	c3		 ret	 0
s390_syncblk_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
vdat$ = 36
rdat$ = 40
dev$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
s390_diag_devtype PROC

; 434  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 435  : DEVBLK         *dev;                    /* -> Device block           */
; 436  : U16             devnum;                 /* Device number             */
; 437  : VRDCVDAT        vdat;                   /* Virtual device data       */
; 438  : VRDCRCDT        rdat;                   /* Real device data          */
; 439  : 
; 440  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 441  :      /* Program check if 64-bit addressing is being used. */
; 442  :      if (regs->psw.amode64)
; 443  :      {
; 444  :          ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 445  :      }
; 446  : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 447  : 
; 448  :     /* Return console information if R1 register is all ones */
; 449  :     if (regs->GR_L(r1) == 0xFFFFFFFF)

  00011	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	83 bc c1 80 02
	00 00 ff	 cmp	 DWORD PTR [rcx+rax*8+640], -1 ; ffffffffH
  00023	75 74		 jne	 SHORT $LN5@s390_diag_

; 450  :     {
; 451  :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00033	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  00038	eb 0e		 jmp	 SHORT $LN4@s390_diag_
$LN2@s390_diag_:
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00043	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@s390_diag_:
  00048	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0004e	74 49		 je	 SHORT $LN3@s390_diag_

; 452  :             if ( dev->allocated
; 453  :                  && ( dev->devtype == 0x3215 || dev->devtype == 0x1503 )

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00055	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00059	74 3c		 je	 SHORT $LN6@s390_diag_
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00060	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00064	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00069	74 10		 je	 SHORT $LN7@s390_diag_
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00070	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00074	3d 03 15 00 00	 cmp	 eax, 5379		; 00001503H
  00079	75 1c		 jne	 SHORT $LN6@s390_diag_
$LN7@s390_diag_:

; 454  :                )
; 455  :             {
; 456  :                 regs->GR_L(r1) = dev->devnum;

  0007b	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00080	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00085	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00089	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0008e	89 8c c2 80 02
	00 00		 mov	 DWORD PTR [rdx+rax*8+640], ecx

; 457  :                 break;

  00095	eb 02		 jmp	 SHORT $LN3@s390_diag_
$LN6@s390_diag_:

; 458  :             }

  00097	eb a1		 jmp	 SHORT $LN2@s390_diag_
$LN3@s390_diag_:
$LN5@s390_diag_:

; 459  :     }
; 460  : 
; 461  :     /* Extract the device number from the R1 register */
; 462  :     devnum = regs->GR_L(r1);

  00099	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000ab	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 463  : 
; 464  :     /* Locate the device block and set the virtual and real device information */
; 465  :     dev = ARCH_DEP(vmdevice_data) (0x24,devnum,&vdat,&rdat);

  000b0	4c 8d 4c 24 28	 lea	 r9, QWORD PTR rdat$[rsp]
  000b5	4c 8d 44 24 24	 lea	 r8, QWORD PTR vdat$[rsp]
  000ba	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  000bf	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  000c4	e8 00 00 00 00	 call	 s390_vmdevice_data
  000c9	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 466  : 
; 467  :     /* Return condition code 3 if device does not exist */
; 468  :     if (!dev)

  000ce	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000d4	75 07		 jne	 SHORT $LN8@s390_diag_

; 469  :         return 3;

  000d6	b8 03 00 00 00	 mov	 eax, 3
  000db	eb 51		 jmp	 SHORT $LN1@s390_diag_
$LN8@s390_diag_:

; 470  : 
; 471  :     /* Return virtual device information in the R2 register */
; 472  :     FETCH_FW(regs->GR_L(r2),&vdat);

  000dd	48 8d 4c 24 24	 lea	 rcx, QWORD PTR vdat$[rsp]
  000e2	e8 00 00 00 00	 call	 fetch_fw_noswap
  000e7	8b c8		 mov	 ecx, eax
  000e9	e8 00 00 00 00	 call	 _byteswap_ulong
  000ee	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000f3	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  000f8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 473  : 
; 474  :     /* Return real device information in the R2+1 register */
; 475  :     if (r2 != 15)

  000ff	83 7c 24 58 0f	 cmp	 DWORD PTR r2$[rsp], 15
  00104	74 26		 je	 SHORT $LN9@s390_diag_

; 476  :         FETCH_FW(regs->GR_L(r2+1),&rdat);

  00106	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rdat$[rsp]
  0010b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00110	8b c8		 mov	 ecx, eax
  00112	e8 00 00 00 00	 call	 _byteswap_ulong
  00117	8b 4c 24 58	 mov	 ecx, DWORD PTR r2$[rsp]
  0011b	ff c1		 inc	 ecx
  0011d	48 63 c9	 movsxd	 rcx, ecx
  00120	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00125	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN9@s390_diag_:

; 477  : #if 0 // debug
; 478  :     LOGMSG( "Diagnose X'024':devnum=%4.4X VRDCVDAT=%8.8X VRDCRCDT=%8.8X\n",
; 479  :             devnum, vdat, rdat );
; 480  : #endif
; 481  : 
; 482  :     /* Return condition code 0 */
; 483  :     return 0;

  0012c	33 c0		 xor	 eax, eax
$LN1@s390_diag_:

; 484  : 
; 485  : } /* end function diag_devtype */

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
s390_diag_devtype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 32
tv170 = 36
dev$ = 40
vmentry$ = 48
code$ = 80
devnum$ = 88
vdat$ = 96
rdat$ = 104
s370_vmdevice_data PROC

; 298  : {

$LN33:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 299  : U32      i;                      /* loop index                      */
; 300  : VMDEVTBL *vmentry;               /* -> VMDEVTBL entry found         */
; 301  : DEVBLK   *dev;                   /* -> DEVBLK                       */
; 302  : 
; 303  :     /* Clear vdat and rdat */
; 304  :     memset (vdat, 0, sizeof(*vdat));

  00018	48 8b 7c 24 60	 mov	 rdi, QWORD PTR vdat$[rsp]
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	f3 aa		 rep stosb

; 305  :     memset (rdat, 0, sizeof(*rdat));

  00026	48 8b 7c 24 68	 mov	 rdi, QWORD PTR rdat$[rsp]
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 04 00 00 00	 mov	 ecx, 4
  00032	f3 aa		 rep stosb

; 306  : 
; 307  :     /* Locate the device block */
; 308  :     dev = find_device_by_devnum (0,devnum);

  00034	0f b7 54 24 58	 movzx	 edx, WORD PTR devnum$[rsp]
  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 find_device_by_devnum
  00040	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 309  : 
; 310  :     /* Return 0 if device is not found */
; 311  :     if (!dev)

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0004b	75 07		 jne	 SHORT $LN7@s370_vmdev

; 312  :        return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 cf 03 00 00	 jmp	 $LN1@s370_vmdev
$LN7@s370_vmdev:

; 313  : 
; 314  :     /* Indicate the device is dedicated - all Hercules devices are */
; 315  :     vdat->vdevstat = DS_DED;

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00059	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 316  : 
; 317  :     /* Find the device in the VM table */
; 318  :     vmentry=NULL;

  0005d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR vmentry$[rsp], 0

; 319  :     for (i = 0; i < (int)VMDEV_NUM; i++)

  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006e	eb 0a		 jmp	 SHORT $LN4@s370_vmdev
$LN2@s370_vmdev:
  00070	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00074	ff c0		 inc	 eax
  00076	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_vmdev:
  0007a	83 7c 24 20 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  0007f	73 3e		 jae	 SHORT $LN3@s370_vmdev

; 320  :        {
; 321  : #if 0 // debug
; 322  :            LOGMSG( "vmdevice_data: i=%i %4.4X %2.2X %2.2X %2.2X\n",i,
; 323  :                    vmdev[i].vmhtype, vmdev[i].vmdevcls, vmdev[i].vmdevtyp, vmdev[i].vmdiags );
; 324  : #endif
; 325  :            if (dev->devtype == vmdev[i].vmhtype)

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0008a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0008e	48 6b c9 06	 imul	 rcx, rcx, 6
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:vmdev
  00099	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0009d	3b c1		 cmp	 eax, ecx
  0009f	75 1c		 jne	 SHORT $LN8@s370_vmdev

; 326  :            {
; 327  :                vmentry = &vmdev[i];

  000a1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a5	48 6b c0 06	 imul	 rax, rax, 6
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:vmdev
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	48 89 44 24 30	 mov	 QWORD PTR vmentry$[rsp], rax

; 328  :                break;

  000bb	eb 02		 jmp	 SHORT $LN3@s370_vmdev
$LN8@s370_vmdev:

; 329  :            }
; 330  :        }

  000bd	eb b1		 jmp	 SHORT $LN2@s370_vmdev
$LN3@s370_vmdev:

; 331  : #if 0 // debug
; 332  :     LOGMSG( "FOUND: %4.4X %2.2X %2.2X %2.2X\n",
; 333  :             vmentry->vmhtype, vmentry->vmdevcls, vmentry->vmdevtyp, vmentry->vmdiags );
; 334  : #endif
; 335  : 
; 336  :     /* If device is not in the table or it isn't recognized by DIAG X'24' */
; 337  :     if ( !vmentry || ( code==0x24 && !(vmentry->vmdiags & VMDIAG024 ) ) )

  000bf	48 83 7c 24 30
	00		 cmp	 QWORD PTR vmentry$[rsp], 0
  000c5	74 19		 je	 SHORT $LN10@s370_vmdev
  000c7	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  000cc	75 3e		 jne	 SHORT $LN9@s370_vmdev
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR vmentry$[rsp]
  000d3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000d7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN9@s370_vmdev
$LN10@s370_vmdev:

; 338  :     {
; 339  :         /* Set the real and virtual data to an unsupported device */
; 340  :         vdat->vdevcls = DC_SPEC;

  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000e5	c6 00 02	 mov	 BYTE PTR [rax], 2

; 341  :         vdat->vdevtyp = DT_UNKN;

  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  000ed	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 342  :         rdat->rdevcls = DC_SPEC;

  000f1	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000f6	c6 00 02	 mov	 BYTE PTR [rax], 2

; 343  :         rdat->rdevtyp = DT_UNKN;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  000fe	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 344  :         return dev;

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00107	e9 17 03 00 00	 jmp	 $LN1@s370_vmdev
$LN9@s370_vmdev:

; 345  :     }
; 346  : 
; 347  :     /* Set the virtual and real data to the device's VM class and type */
; 348  :     vdat->vdevcls = vmentry->vmdevcls;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00116	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0011a	88 08		 mov	 BYTE PTR [rax], cl

; 349  :     vdat->vdevtyp = vmentry->vmdevtyp;

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  00121	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00126	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0012a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 350  :     rdat->rdevcls = vmentry->vmdevcls;

  0012d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00137	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  0013b	88 08		 mov	 BYTE PTR [rax], cl

; 351  :     rdat->rdevtyp = vmentry->vmdevtyp;

  0013d	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vmentry$[rsp]
  00147	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0014b	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 352  : 
; 353  :     /* Indicate if the device is busy */
; 354  :     if (0
; 355  :         || dev->startpending
; 356  :         || (1

  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 42		 jne	 SHORT $LN12@s370_vmdev
  00154	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00159	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0015f	c1 e8 19	 shr	 eax, 25
  00162	83 e0 01	 and	 eax, 1
  00165	85 c0		 test	 eax, eax
  00167	75 2d		 jne	 SHORT $LN12@s370_vmdev
  00169	33 c0		 xor	 eax, eax
  0016b	83 f8 01	 cmp	 eax, 1
  0016e	74 3a		 je	 SHORT $LN11@s370_vmdev
  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00175	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0017b	c1 e8 13	 shr	 eax, 19
  0017e	83 e0 01	 and	 eax, 1
  00181	85 c0		 test	 eax, eax
  00183	74 25		 je	 SHORT $LN11@s370_vmdev
  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00194	75 14		 jne	 SHORT $LN11@s370_vmdev
$LN12@s370_vmdev:

; 357  :             && dev->busy
; 358  : #if defined( OPTION_SHARED_DEVICES )
; 359  :             && dev->shioactive == DEV_SYS_LOCAL
; 360  : #endif // defined( OPTION_SHARED_DEVICES )
; 361  :            )
; 362  :     )
; 363  :         vdat->vdevstat |= DS_BUSY;

  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  0019b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0019f	83 c8 20	 or	 eax, 32			; 00000020H
  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001a7	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN11@s370_vmdev:

; 364  : 
; 365  :     /* Set virtual device flags, and real device model and features */
; 366  :     vdat->vdevflag = 0x00;

  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001af	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 367  :     rdat->rdevmodl = 0x00;

  001b3	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001b8	c6 40 02 00	 mov	 BYTE PTR [rax+2], 0

; 368  :     rdat->rdevfeat = 0x00;

  001bc	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001c1	c6 40 03 00	 mov	 BYTE PTR [rax+3], 0

; 369  : 
; 370  :     if (dev->hnd->reserve)           /* Indicate if RESERVE/RELEASE supported */

  001c5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  001d1	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001d6	74 14		 je	 SHORT $LN13@s370_vmdev

; 371  :         vdat->vdevflag |= DF_RSRL;

  001d8	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  001dd	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e1	83 c8 02	 or	 eax, 2
  001e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  001e9	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN13@s370_vmdev:

; 372  : 
; 373  : #if defined(FEATURE_MIDAW_FACILITY)
; 374  :     /* If DIAGNOSE X'210', indicate if MIDAW's are supported */
; 375  :     if (code==0x210)
; 376  :         vdat->vdevflag |= DF_MIDAW;
; 377  : #endif /* FEATURE_MIDAW_FACILITY */
; 378  : 
; 379  :     switch (rdat->rdevcls) {

  001ec	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  001f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f4	88 44 24 24	 mov	 BYTE PTR tv170[rsp], al
  001f8	80 7c 24 24 01	 cmp	 BYTE PTR tv170[rsp], 1
  001fd	0f 84 4c 01 00
	00		 je	 $LN23@s370_vmdev
  00203	80 7c 24 24 02	 cmp	 BYTE PTR tv170[rsp], 2
  00208	0f 84 f7 01 00
	00		 je	 $LN30@s370_vmdev
  0020e	80 7c 24 24 04	 cmp	 BYTE PTR tv170[rsp], 4
  00213	74 10		 je	 SHORT $LN14@s370_vmdev
  00215	80 7c 24 24 80	 cmp	 BYTE PTR tv170[rsp], 128 ; 00000080H
  0021a	0f 84 4c 01 00
	00		 je	 $LN24@s370_vmdev
  00220	e9 f9 01 00 00	 jmp	 $LN5@s370_vmdev
$LN14@s370_vmdev:

; 380  :     case DC_DASD:
; 381  :          if (dev->hnd->reserve)

  00225	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00231	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00236	74 14		 je	 SHORT $LN15@s370_vmdev

; 382  :             rdat->rdevfeat |= DRF_RSRL;

  00238	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0023d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00241	83 c8 02	 or	 eax, 2
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00249	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN15@s370_vmdev:

; 383  :          if (dev->numsense==24)

  0024c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00251	83 b8 60 03 00
	00 18		 cmp	 DWORD PTR [rax+864], 24
  00258	75 14		 jne	 SHORT $LN16@s370_vmdev

; 384  :             rdat->rdevfeat |= DRF_EXTSNS;

  0025a	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0025f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00263	83 c8 40	 or	 eax, 64			; 00000040H
  00266	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0026b	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN16@s370_vmdev:

; 385  :          if (dev->ckdtab->sectors)

  0026e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00273	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0027a	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  0027e	85 c0		 test	 eax, eax
  00280	74 15		 je	 SHORT $LN17@s370_vmdev

; 386  :             rdat->rdevfeat |= DRF_RPS;

  00282	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00287	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0028b	0f ba e8 07	 bts	 eax, 7
  0028f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00294	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN17@s370_vmdev:

; 387  :          if (dev->devtype == 0x3340)

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0029c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002a0	3d 40 33 00 00	 cmp	 eax, 13120		; 00003340H
  002a5	75 3f		 jne	 SHORT $LN18@s370_vmdev

; 388  :          {
; 389  :             if (dev->ckdtab->model==0x01)

  002a7	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002ac	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002b3	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  002b7	83 f8 01	 cmp	 eax, 1
  002ba	75 16		 jne	 SHORT $LN19@s370_vmdev

; 390  :                rdat->rdevfeat |= DRF_35M;

  002bc	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002c1	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002c5	83 c8 08	 or	 eax, 8
  002c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002cd	88 41 03	 mov	 BYTE PTR [rcx+3], al
  002d0	eb 14		 jmp	 SHORT $LN20@s370_vmdev
$LN19@s370_vmdev:

; 391  :             else
; 392  :                rdat->rdevfeat |= DRF_70M;

  002d2	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  002d7	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002db	83 c8 04	 or	 eax, 4
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  002e3	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN20@s370_vmdev:
$LN18@s370_vmdev:

; 393  :          }
; 394  :          if ( dev->devtype == 0x3380  && code == 0x24)

  002e6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  002eb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002ef	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  002f4	75 3c		 jne	 SHORT $LN21@s370_vmdev
  002f6	83 7c 24 50 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  002fb	75 35		 jne	 SHORT $LN21@s370_vmdev

; 395  :             rdat->rdevmodl = (dev->ckdtab->model & 0x0F) | (dev->ckdcu->model & 0xF0);

  002fd	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00302	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00309	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  0030d	83 e0 0f	 and	 eax, 15
  00310	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  0031c	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  00320	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00326	0b c1		 or	 eax, ecx
  00328	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  0032d	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00330	eb 18		 jmp	 SHORT $LN22@s370_vmdev
$LN21@s370_vmdev:

; 396  :          else
; 397  :             rdat->rdevmodl = dev->ckdtab->model;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00337	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0033e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00343	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00347	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN22@s370_vmdev:

; 398  :          break;

  0034a	e9 cf 00 00 00	 jmp	 $LN5@s370_vmdev
$LN23@s370_vmdev:

; 399  :      case DC_FBA:
; 400  :          rdat->rdevmodl = dev->fbatab->model;

  0034f	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00354	48 8b 80 80 11
	00 00		 mov	 rax, QWORD PTR [rax+4480]
  0035b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rdat$[rsp]
  00360	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00364	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 401  :          break;

  00367	e9 b2 00 00 00	 jmp	 $LN5@s370_vmdev
$LN24@s370_vmdev:

; 402  :      case DC_TERM:
; 403  :          if (dev->devtype==0x3215)

  0036c	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00371	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00375	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  0037a	75 0b		 jne	 SHORT $LN25@s370_vmdev

; 404  :          {
; 405  :             rdat->rdevfeat = 0x50;

  0037c	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  00381	c6 40 03 50	 mov	 BYTE PTR [rax+3], 80	; 00000050H

; 406  :             /* Note: 0x50 is carried forward from the previous version of       */
; 407  :             /* DIAGNOSE X'24'. The actual meaning was not previously documented */
; 408  :          }

  00385	eb 7c		 jmp	 SHORT $LN26@s370_vmdev
$LN25@s370_vmdev:

; 409  :          else
; 410  :          {
; 411  :             if (dev->devtype==0x2703 && dev->commadpt)

  00387	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0038c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00390	3d 03 27 00 00	 cmp	 eax, 9987		; 00002703H
  00395	75 6c		 jne	 SHORT $LN27@s370_vmdev
  00397	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0039c	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  003a4	74 5d		 je	 SHORT $LN27@s370_vmdev

; 412  :             {
; 413  :                 if (dev->commadpt->enabled)

  003a6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003ab	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003b2	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  003b8	83 e0 01	 and	 eax, 1
  003bb	85 c0		 test	 eax, eax
  003bd	74 15		 je	 SHORT $LN28@s370_vmdev

; 414  :                    vdat->vdevflag |= DF_ENA;

  003bf	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  003c4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003c8	0f ba e8 07	 bts	 eax, 7
  003cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  003d1	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN28@s370_vmdev:

; 415  :                 if (dev->commadpt->connect)

  003d4	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  003d9	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003e0	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [rax+360]
  003e6	d1 e8		 shr	 eax, 1
  003e8	83 e0 01	 and	 eax, 1
  003eb	85 c0		 test	 eax, eax
  003ed	74 14		 je	 SHORT $LN29@s370_vmdev

; 416  :                    vdat->vdevflag |= DF_CONN;

  003ef	48 8b 44 24 60	 mov	 rax, QWORD PTR vdat$[rsp]
  003f4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003f8	83 c8 40	 or	 eax, 64			; 00000040H
  003fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vdat$[rsp]
  00400	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN29@s370_vmdev:
$LN27@s370_vmdev:
$LN26@s370_vmdev:

; 417  :             }
; 418  :          }
; 419  :          break;

  00403	eb 19		 jmp	 SHORT $LN5@s370_vmdev
$LN30@s370_vmdev:

; 420  :      case DC_SPEC:
; 421  :          if (rdat->rdevtyp==DT_CTCA)

  00405	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0040a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0040e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00413	75 09		 jne	 SHORT $LN31@s370_vmdev

; 422  :             rdat->rdevfeat = DRF_CTCA;

  00415	48 8b 44 24 68	 mov	 rax, QWORD PTR rdat$[rsp]
  0041a	c6 40 03 40	 mov	 BYTE PTR [rax+3], 64	; 00000040H
$LN31@s370_vmdev:
$LN5@s370_vmdev:

; 423  :      }
; 424  : 
; 425  :      /* Return the located DEVBLK to the caller */
; 426  :      return dev;

  0041e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@s370_vmdev:

; 427  : 
; 428  : } /* end function vmdevice_data */

  00423	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00427	5f		 pop	 rdi
  00428	c3		 ret	 0
s370_vmdevice_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
is_shcmd$ = 32
cmd_work$ = 40
cmd$ = 64
is_shell_command PROC

; 269  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 270  :     char* cmd_work  = strdup( cmd );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cmd$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00014	48 89 44 24 28	 mov	 QWORD PTR cmd_work$[rsp], rax

; 271  :     BYTE  is_shcmd  = FALSE;

  00019	c6 44 24 20 00	 mov	 BYTE PTR is_shcmd$[rsp], 0

; 272  : 
; 273  :     /* Remove leading/trailing blanks */
; 274  :     TRIM( cmd_work );

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169714
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmd_work$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trim

; 275  : 
; 276  :     /* Check for possible "shell" type command */
; 277  :     if (0
; 278  :         || strcasecmp( cmd_work, "sh"   ) == 0  // (shell command)
; 279  :         || strcasecmp( cmd_work, "exec" ) == 0  // (rexx command)

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 2c		 jne	 SHORT $LN3@is_shell_c
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169717
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmd_work$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00048	85 c0		 test	 eax, eax
  0004a	74 16		 je	 SHORT $LN3@is_shell_c
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169718
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmd_work$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0005e	85 c0		 test	 eax, eax
  00060	75 05		 jne	 SHORT $LN2@is_shell_c
$LN3@is_shell_c:

; 280  :     )
; 281  :         is_shcmd = TRUE;  /* Looks like a 'sh' shell command! */

  00062	c6 44 24 20 01	 mov	 BYTE PTR is_shcmd$[rsp], 1
$LN2@is_shell_c:

; 282  : 
; 283  :     free( cmd_work );

  00067	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmd_work$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 284  :     return is_shcmd;

  00072	0f b6 44 24 20	 movzx	 eax, BYTE PTR is_shcmd$[rsp]

; 285  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
is_shell_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_validate_operand
_TEXT	SEGMENT
tv79 = 48
tv94 = 52
tv138 = 56
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s370_validate_operand PROC				; COMDAT

; 1376 : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0004c	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN11@s370_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN12@s370_valid
$LN11@s370_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@s370_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 3e		 je	 SHORT $LN5@s370_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0008c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009d	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 s370_maddr_l

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }

  000ae	eb 5a		 jmp	 SHORT $LN6@s370_valid
$LN5@s370_valid:
$LN4@s370_valid:

; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );

  000b0	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b5	73 0a		 jae	 SHORT $LN15@s370_valid
  000b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN16@s370_valid
$LN15@s370_valid:
  000c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@s370_valid:
  000c9	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  000ce	74 1b		 je	 SHORT $LN17@s370_valid
  000d0	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000d4	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	83 f8 50	 cmp	 eax, 80			; 00000050H
  000df	72 0a		 jb	 SHORT $LN17@s370_valid
  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e9	eb 08		 jmp	 SHORT $LN23@s370_valid
$LN17@s370_valid:
  000eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN23@s370_valid:
  000f3	83 7c 24 38 00	 cmp	 DWORD PTR tv138[rsp], 0
  000f8	74 0a		 je	 SHORT $LN7@s370_valid
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_valid:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 a6		 jne	 SHORT $LN4@s370_valid
$LN6@s370_valid:

; 1389 : #endif
; 1390 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
s370_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstoreb
_TEXT	SEGMENT
tv76 = 48
tv86 = 52
main1$ = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s370_vstoreb PROC					; COMDAT

; 529  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l
  00043	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl
$LN4@s370_vstor:

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );

  00054	83 7c 24 58 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00059	73 0a		 jae	 SHORT $LN9@s370_vstor
  0005b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN10@s370_vstor
$LN9@s370_vstor:
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN10@s370_vstor:
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00072	74 11		 je	 SHORT $LN11@s370_vstor
  00074	83 7c 24 58 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00079	72 0a		 jb	 SHORT $LN11@s370_vstor
  0007b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00083	eb 08		 jmp	 SHORT $LN17@s370_vstor
$LN11@s370_vstor:
  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN17@s370_vstor:
  0008d	83 7c 24 34 00	 cmp	 DWORD PTR tv86[rsp], 0
  00092	74 0a		 je	 SHORT $LN5@s370_vstor
  00094	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN5@s370_vstor:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b0		 jne	 SHORT $LN4@s370_vstor

; 535  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
s370_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s370_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
s370_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6a		 je	 SHORT $LN5@s370_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 55		 jne	 SHORT $LN5@s370_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00080	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00087	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s370_fetch:
  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 78 ff ff
	ff		 jne	 $LN4@s370_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00096	b2 04		 mov	 dl, 4
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009d	e8 00 00 00 00	 call	 s370_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a2	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000ae	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
s370_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
s370_put_storage_key PROC				; COMDAT

; 272  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 273  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 274  :     ARCH_DEP( put_2K_storage_key )( abs, key );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR key$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_put_2K_storage_key

; 275  : #else
; 276  :     ARCH_DEP( put_4K_storage_key )( abs, key );
; 277  : #endif
; 278  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_storage_key
_TEXT	SEGMENT
abs$ = 48
s370_get_storage_key PROC				; COMDAT

; 254  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 255  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 256  :     return ARCH_DEP( get_2K_storage_key )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s370_get_2K_storage_key

; 257  : #else
; 258  :     return ARCH_DEP( get_4K_storage_key )( abs );
; 259  : #endif
; 260  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s370_get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_put_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
s370_put_2K_storage_key PROC				; COMDAT

; 229  :   inline void  ARCH_DEP( put_2K_storage_key )     (              U64 abs, BYTE key  ) {        ARCH_DEP( _put_storage_key     )(      abs, key  & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR key$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__put_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_put_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
s370_get_2K_storage_key PROC				; COMDAT

; 228  :   inline BYTE  ARCH_DEP( get_2K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 2 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 02		 mov	 dl, 2
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s370__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s370_get_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__put_storage_key
_TEXT	SEGMENT
abs$ = 48
key$ = 56
K$ = 64
s370__put_storage_key PROC				; COMDAT

; 158  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@s370__put_:

; 159  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__put_

; 160  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 40	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 2b		 jne	 SHORT $LN5@s370__put_
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 24		 je	 SHORT $LN5@s370__put_

; 161  :     {
; 162  :         *_get_storekey1_ptr( abs ) = key;

  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  00038	88 08		 mov	 BYTE PTR [rax], cl

; 163  :         *_get_storekey2_ptr( abs ) = key;

  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0003f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00044	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  00049	88 08		 mov	 BYTE PTR [rax], cl

; 164  :     }

  0004b	eb 16		 jmp	 SHORT $LN6@s370__put_
$LN5@s370__put_:

; 165  :     else
; 166  :     {
; 167  :         *_get_storekey_ptr(  abs, K ) = key;

  0004d	0f b6 54 24 40	 movzx	 edx, BYTE PTR K$[rsp]
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00057	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005c	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR key$[rsp]
  00061	88 08		 mov	 BYTE PTR [rax], cl
$LN6@s370__put_:

; 168  :     }
; 169  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
s370__put_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s370__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s370__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	0f b6 44 24 48	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 39		 jne	 SHORT $LN5@s370__get_
  0001d	33 c0		 xor	 eax, eax
  0001f	83 f8 01	 cmp	 eax, 1
  00022	74 32		 je	 SHORT $LN5@s370__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00029	e8 00 00 00 00	 call	 _get_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0003a	e8 00 00 00 00	 call	 _get_storekey2_ptr
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00047	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx
  00050	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00054	eb 16		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  00056	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00060	e8 00 00 00 00	 call	 _get_storekey_ptr
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 140  :     return skey;

  0006c	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
s370__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
effective_addr2$ = 64
b2$ = 68
temp$1 = 72
inst$ = 96
regs$ = 104
s370_inter_user_communication_vehicle PROC

; 1686 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1687 : int     b2;                             /* Effective addr base       */
; 1688 : VADR    effective_addr2;                /* Effective address         */
; 1689 : 
; 1690 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN11@s370_inter
  00045	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s370_inter:
$LN4@s370_inter:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN12@s370_inter
  0008c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN12@s370_inter:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_inter

; 1691 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 1692 : 
; 1693 : #if defined(FEATURE_ECPSVM)
; 1694 :     if(ecpsvm_doiucv(regs,b2,effective_addr2)==0)

  0009e	44 8b 44 24 40	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  000a3	8b 54 24 44	 mov	 edx, DWORD PTR b2$[rsp]
  000a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 ecpsvm_doiucv
  000b1	85 c0		 test	 eax, eax
  000b3	75 05		 jne	 SHORT $LN13@s370_inter

; 1695 :     {
; 1696 :         return;

  000b5	e9 b9 00 00 00	 jmp	 $LN1@s370_inter
$LN13@s370_inter:

; 1697 :     }
; 1698 : #endif
; 1699 : 
; 1700 :     /* Program check if in problem state,
; 1701 :        the IUCV instruction generates an operation exception
; 1702 :        rather then a priviliged operation exception when
; 1703 :        executed in problem state                                 *JJ */
; 1704 :     if ( PROBSTATE(&regs->psw) )

  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000c3	83 e0 01	 and	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	74 0f		 je	 SHORT $LN14@s370_inter

; 1705 :         ARCH_DEP(program_interrupt) (regs, PGM_OPERATION_EXCEPTION);

  000ca	ba 01 00 00 00	 mov	 edx, 1
  000cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d4	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_inter:
$LN7@s370_inter:

; 1706 : 
; 1707 :     SIE_INTERCEPT(regs);

  000d9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 18		 je	 SHORT $LN15@s370_inter
  000ed	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000f8	ba fc ff ff ff	 mov	 edx, -4
  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 longjmp
$LN15@s370_inter:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 ce		 jne	 SHORT $LN7@s370_inter
$LN10@s370_inter:

; 1708 : 
; 1709 :     PTT_ERR("*IUCV",b2,effective_addr2,regs->psw.IA_L);

  0010b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00112	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00115	48 83 e0 10	 and	 rax, 16
  00119	48 85 c0	 test	 rax, rax
  0011c	74 46		 je	 SHORT $LN16@s370_inter
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00129	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0012d	48 63 54 24 44	 movsxd	 rdx, DWORD PTR b2$[rsp]
  00132	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0013b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170202
  00147	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014c	44 8b c9	 mov	 r9d, ecx
  0014f	4c 8b c2	 mov	 r8, rdx
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170203
  00159	b9 10 00 00 00	 mov	 ecx, 16
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_inter:
  00164	33 c0		 xor	 eax, eax
  00166	85 c0		 test	 eax, eax
  00168	75 a1		 jne	 SHORT $LN10@s370_inter

; 1710 : 
; 1711 :     /* Set condition code to indicate IUCV not available */
; 1712 :     regs->psw.cc = 3;

  0016a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_inter:
$LN17@s370_inter:

; 1713 : }

  00173	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00177	c3		 ret	 0
s370_inter_user_communication_vehicle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
i$ = 48
buflen$ = 52
bufadr$ = 56
timeval$ = 64
tmptr$ = 72
buf$ = 80
dattim$ = 144
__$ArrayPad$ = 208
code$ = 256
r1$ = 264
r2$ = 272
regs$ = 280
s370_pseudo_timer PROC

; 1508 : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1509 : int     i;                              /* Array subscript           */
; 1510 : time_t  timeval;                        /* Current time              */
; 1511 : struct  tm *tmptr;                      /* -> Current time structure */
; 1512 : U32     bufadr;                         /* Real addr of data buffer  */
; 1513 : U32     buflen;                         /* Length of data buffer     */
; 1514 : char    buf[64];                        /* Response buffer           */
; 1515 : BYTE    dattim[64];                     /* Date and time (EBCDIC)    */
; 1516 : #define DIAG_DATEFMT_SHORT      0x80    /* Date format mm/dd/yy      */
; 1517 : #define DIAG_DATEFMT_FULL       0x40    /* Date format mm/dd/yyyy    */
; 1518 : #define DIAG_DATEFMT_ISO        0x20    /* Date format yyyy-mm-dd    */
; 1519 : #define DIAG_DATEFMT_SYSDFLT    0x10    /* System-wide default format*/
; 1520 : static  char timefmt[]="%m/%d/%y%H:%M:%S%m/%d/%Y%Y-%m-%d";
; 1521 : 
; 1522 :     /* Get the current date and time in EBCDIC */
; 1523 :     timeval = time(NULL);

  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 time
  00034	48 89 44 24 40	 mov	 QWORD PTR timeval$[rsp], rax

; 1524 :     tmptr = localtime(&timeval);

  00039	48 8d 4c 24 40	 lea	 rcx, QWORD PTR timeval$[rsp]
  0003e	e8 00 00 00 00	 call	 localtime
  00043	48 89 44 24 48	 mov	 QWORD PTR tmptr$[rsp], rax

; 1525 :     strftime((char *)dattim, sizeof(dattim), timefmt, tmptr);

  00048	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tmptr$[rsp]
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?timefmt@?1??s370_pseudo_timer@@9@9
  00054	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00059	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 1526 :     for (i = 0; dattim[i] != '\0'; i++)

  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@s370_pseud
$LN2@s370_pseud:
  00071	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_pseud:
  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR dattim$[rsp+rax]
  00088	85 c0		 test	 eax, eax
  0008a	74 21		 je	 SHORT $LN3@s370_pseud

; 1527 :         dattim[i] = host_to_guest(dattim[i]);

  0008c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00091	0f b6 8c 04 90
	00 00 00	 movzx	 ecx, BYTE PTR dattim$[rsp+rax]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0009f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a4	88 84 0c 90 00
	00 00		 mov	 BYTE PTR dattim$[rsp+rcx], al
  000ab	eb c4		 jmp	 SHORT $LN2@s370_pseud
$LN3@s370_pseud:

; 1528 : 
; 1529 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1530 :     bufadr = regs->GR_L(r1);

  000ad	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c4	89 44 24 38	 mov	 DWORD PTR bufadr$[rsp], eax

; 1531 :     buflen = regs->GR_L(r2);

  000c8	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000d0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000df	89 44 24 34	 mov	 DWORD PTR buflen$[rsp], eax

; 1532 : 
; 1533 :     /* Use length 32 if R2 is zero or function code is 00C */
; 1534 :     if (r2 == 0 || code == 0x00C)

  000e3	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  000eb	74 0a		 je	 SHORT $LN6@s370_pseud
  000ed	83 bc 24 00 01
	00 00 0c	 cmp	 DWORD PTR code$[rsp], 12
  000f5	75 08		 jne	 SHORT $LN5@s370_pseud
$LN6@s370_pseud:

; 1535 :         buflen = 32;

  000f7	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 32 ; 00000020H
$LN5@s370_pseud:

; 1536 : 
; 1537 :     /* Program check if R1 and R2 specify the same non-zero
; 1538 :        register number, or if buffer length is less than or
; 1539 :        equal to zero, or if buffer address is zero, or if
; 1540 :        buffer is not on a doubleword boundary */
; 1541 :     if ((r2 != 0 && r2 == r1)
; 1542 :         || (S32)buflen <= 0
; 1543 :         || bufadr == 0
; 1544 :         || (bufadr & 0x00000007))

  000ff	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR r2$[rsp], 0
  00107	74 10		 je	 SHORT $LN9@s370_pseud
  00109	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00110	39 84 24 10 01
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  00117	74 19		 je	 SHORT $LN8@s370_pseud
$LN9@s370_pseud:
  00119	83 7c 24 34 00	 cmp	 DWORD PTR buflen$[rsp], 0
  0011e	7e 12		 jle	 SHORT $LN8@s370_pseud
  00120	83 7c 24 38 00	 cmp	 DWORD PTR bufadr$[rsp], 0
  00125	74 0b		 je	 SHORT $LN8@s370_pseud
  00127	8b 44 24 38	 mov	 eax, DWORD PTR bufadr$[rsp]
  0012b	83 e0 07	 and	 eax, 7
  0012e	85 c0		 test	 eax, eax
  00130	74 12		 je	 SHORT $LN7@s370_pseud
$LN8@s370_pseud:

; 1545 :     {
; 1546 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN7@s370_pseud:

; 1547 :     }
; 1548 : 
; 1549 :     /* Build the response buffer */
; 1550 :     memset (buf, 0, sizeof(buf));

  00144	48 8d 44 24 50	 lea	 rax, QWORD PTR buf$[rsp]
  00149	48 8b f8	 mov	 rdi, rax
  0014c	33 c0		 xor	 eax, eax
  0014e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00153	f3 aa		 rep stosb

; 1551 :     /* Bytes 0-7 contain the date as EBCDIC MM/DD/YY */
; 1552 :     memcpy (buf, dattim, 8);

  00155	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp]
  0015d	48 89 44 24 50	 mov	 QWORD PTR buf$[rsp], rax

; 1553 :     /* Bytes 8-15 contain the time as EBCDIC HH:MM:SS */
; 1554 :     memcpy (buf+8, dattim+8, 8);

  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dattim$[rsp+8]
  0016a	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp+8], rax

; 1555 :     /* Bytes 16-23 contain the virtual CPU time used in microseconds */
; 1556 :     /* Bytes 24-31 contain the total CPU time used in microseconds */
; 1557 :     /* Bytes 32-41 contain the date as EBCDIC MM/DD/YYYY */
; 1558 :     memcpy (buf+32, dattim+16, 10);

  0016f	48 8d 44 24 70	 lea	 rax, QWORD PTR buf$[rsp+32]
  00174	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+16]
  0017c	48 8b f8	 mov	 rdi, rax
  0017f	48 8b f1	 mov	 rsi, rcx
  00182	b9 0a 00 00 00	 mov	 ecx, 10
  00187	f3 a4		 rep movsb

; 1559 :     /* Bytes 42-47 contain binary zeroes */
; 1560 :     /* Bytes 48-57 contain the date as EBCDIC YYYY-MM-DD */
; 1561 :     memcpy (buf+48, dattim+26, 10);

  00189	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+48]
  00191	48 8d 8c 24 aa
	00 00 00	 lea	 rcx, QWORD PTR dattim$[rsp+26]
  00199	48 8b f8	 mov	 rdi, rax
  0019c	48 8b f1	 mov	 rsi, rcx
  0019f	b9 0a 00 00 00	 mov	 ecx, 10
  001a4	f3 a4		 rep movsb

; 1562 :     /* Byte 58 contains the diagnose 270 version code */
; 1563 :     buf[58] = 0x01;

  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	48 6b c0 3a	 imul	 rax, rax, 58		; 0000003aH
  001af	c6 44 04 50 01	 mov	 BYTE PTR buf$[rsp+rax], 1

; 1564 :     /* Byte 59 contains the user's default date format */
; 1565 :     buf[59] = DIAG_DATEFMT_ISO;

  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	48 6b c0 3b	 imul	 rax, rax, 59		; 0000003bH
  001bd	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1566 :     /* Byte 60 contains the system default date format */
; 1567 :     buf[60] = DIAG_DATEFMT_ISO;

  001c2	b8 01 00 00 00	 mov	 eax, 1
  001c7	48 6b c0 3c	 imul	 rax, rax, 60		; 0000003cH
  001cb	c6 44 04 50 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H

; 1568 :     /* Bytes 61-63 contain binary zeroes */
; 1569 : 
; 1570 : #if 0 // debug
; 1571 :     LOGMSG( "Diagnose X'%3.3X':"
; 1572 : 
; 1573 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1574 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1575 : 
; 1576 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1577 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1578 : 
; 1579 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1580 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1581 : 
; 1582 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1583 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1584 : 
; 1585 :             , code
; 1586 : 
; 1587 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1588 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1589 : 
; 1590 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1591 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1592 : 
; 1593 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1594 :             , buf[40], buf[41], buf[42], buf[43], buf[44], buf[45], buf[46], buf[47]
; 1595 : 
; 1596 :             , buf[48], buf[49], buf[50], buf[51], buf[52], buf[53], buf[54], buf[55]
; 1597 :             , buf[56], buf[57], buf[58], buf[59], buf[60], buf[61], buf[63], buf[63]
; 1598 :         );
; 1599 : #endif
; 1600 : 
; 1601 :     /* Enforce maximum length to store */
; 1602 :     if (buflen > sizeof(buf))

  001d0	8b 44 24 34	 mov	 eax, DWORD PTR buflen$[rsp]
  001d4	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  001d8	76 08		 jbe	 SHORT $LN10@s370_pseud

; 1603 :         buflen = sizeof(buf);

  001da	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR buflen$[rsp], 64 ; 00000040H
$LN10@s370_pseud:

; 1604 : 
; 1605 :     /* Store the response buffer at the operand location */
; 1606 :     ARCH_DEP(vstorec) (buf, buflen-1, bufadr, USE_REAL_ADDR, regs);

  001e2	8b 44 24 34	 mov	 eax, DWORD PTR buflen$[rsp]
  001e6	ff c8		 dec	 eax
  001e8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f5	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  001fb	44 8b 44 24 38	 mov	 r8d, DWORD PTR bufadr$[rsp]
  00200	0f b6 d0	 movzx	 edx, al
  00203	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00208	e8 00 00 00 00	 call	 s370_vstorec

; 1607 : 
; 1608 : } /* end function pseudo_timer */

  0020d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00215	48 33 cc	 xor	 rcx, rsp
  00218	e8 00 00 00 00	 call	 __security_check_cookie
  0021d	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00224	5f		 pop	 rdi
  00225	5e		 pop	 rsi
  00226	c3		 ret	 0
s370_pseudo_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
buflen$ = 64
bufadr$ = 68
r1$ = 96
r2$ = 104
regs$ = 112
s370_access_reipl_data PROC

; 1229 : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1230 : U32     bufadr;                         /* Real addr of data buffer  */
; 1231 : U32     buflen;                         /* Length of data buffer     */
; 1232 : 
; 1233 :     /* Obtain buffer address and length from R1 and R2 registers */
; 1234 :     bufadr = regs->GR_L(r1);

  00011	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00016	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 44	 mov	 DWORD PTR bufadr$[rsp], eax

; 1235 :     buflen = regs->GR_L(r2);

  00026	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0002b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00037	89 44 24 40	 mov	 DWORD PTR buflen$[rsp], eax

; 1236 : 
; 1237 :     /* Program check if buffer length is negative */
; 1238 :     if ((S32)buflen < 0)

  0003b	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00040	7d 0f		 jge	 SHORT $LN5@s370_acces

; 1239 :     {
; 1240 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00042	ba 06 00 00 00	 mov	 edx, 6
  00047	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	e8 00 00 00 00	 call	 s370_program_interrupt
$LN5@s370_acces:

; 1241 :     }
; 1242 : 
; 1243 :     /* Store IPL information if buffer length is non-zero */
; 1244 :     if (buflen > 0)

  00051	83 7c 24 40 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00056	76 16		 jbe	 SHORT $LN6@s370_acces

; 1245 :     {
; 1246 :         /* Store one byte of zero to indicate no IPL information */
; 1247 :         ARCH_DEP(vstoreb) (0, bufadr, USE_REAL_ADDR, regs);

  00058	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00063	8b 54 24 44	 mov	 edx, DWORD PTR bufadr$[rsp]
  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 s370_vstoreb
$LN6@s370_acces:
$LN4@s370_acces:

; 1248 :     }
; 1249 : 
; 1250 :     PTT_ERR("*DIAG0B0",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 83 e0 10	 and	 rax, 16
  0007c	48 85 c0	 test	 rax, rax
  0007f	74 60		 je	 SHORT $LN7@s370_acces
  00081	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00086	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0008c	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00091	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00096	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  0009d	48 63 54 24 60	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000a2	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000a7	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  000af	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170046
  000c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c9	44 8b c9	 mov	 r9d, ecx
  000cc	44 8b c2	 mov	 r8d, edx
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170047
  000d6	b9 10 00 00 00	 mov	 ecx, 16
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN7@s370_acces:
  000e1	33 c0		 xor	 eax, eax
  000e3	85 c0		 test	 eax, eax
  000e5	75 87		 jne	 SHORT $LN4@s370_acces

; 1251 : 
; 1252 :     /* Return code 4 means no re-IPL information available */
; 1253 :     regs->GR_L(r2) = 4;

  000e7	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  000ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1254 : 
; 1255 : } /* end function access_reipl_data */

  000fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00100	c3		 ret	 0
s370_access_reipl_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
bloklen$ = 64
tv183 = 68
dev$ = 72
devnum$ = 80
blokaddr$ = 88
vrdc$ = 96
__$ArrayPad$ = 352
r1$ = 400
r2$ = 408
regs$ = 416
s370_device_info PROC

; 1262 : {

$LN28:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_devic:

; 1263 : DEVBLK   *dev;             /* -> Device block                        */
; 1264 : VRDCBLOK vrdc;             /* VRDCBLOK                               */
; 1265 : RADR     blokaddr;         /* Location of the VRDCBLOK               */
; 1266 : U16      bloklen;          /* Length from the VRDCBLOK               */
; 1267 : #if 0
; 1268 : /* Only required if implementation is for the z/VM 5.3 level */
; 1269 : U16      reserved;         /* Bytes 14 and 15                        */
; 1270 : #endif
; 1271 : U16      devnum;           /* Device number from the VRDCBLOK        */
; 1272 : 
; 1273 : 
; 1274 :     UNREFERENCED(r2);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN4@s370_devic

; 1275 : 
; 1276 :     if (regs->GR_L(r1) & 0x3

  0002e	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00036	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00045	83 e0 03	 and	 eax, 3
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN10@s370_devic

; 1277 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1278 :         || (regs->psw.amode64)
; 1279 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1280 :        )
; 1281 :     {
; 1282 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0004c	ba 06 00 00 00	 mov	 edx, 6
  00051	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_devic:

; 1283 :     }
; 1284 : 
; 1285 :     blokaddr = regs->GR_L(r1);

  0005e	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00066	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00075	48 89 44 24 58	 mov	 QWORD PTR blokaddr$[rsp], rax

; 1286 : 
; 1287 :     /* Fetch the first 4 bytes of the VRDCBLOK */
; 1288 :     ARCH_DEP(vfetchc) (&vrdc, 3, blokaddr, USE_REAL_ADDR, regs);

  0007a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00087	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0008d	44 8b 44 24 58	 mov	 r8d, DWORD PTR blokaddr$[rsp]
  00092	b2 03		 mov	 dl, 3
  00094	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  00099	e8 00 00 00 00	 call	 s370_vfetchc

; 1289 : 
; 1290 :     /* Get the VRDCBLOK length from the working VRDC */
; 1291 :     FETCH_HW(bloklen,&vrdc.vrdclen);

  0009e	48 8d 4c 24 62	 lea	 rcx, QWORD PTR vrdc$[rsp+2]
  000a3	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a8	0f b7 c8	 movzx	 ecx, ax
  000ab	e8 00 00 00 00	 call	 _byteswap_ushort
  000b0	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax

; 1292 : 
; 1293 :     /* VRDCBLOK length must be at least 8 bytes */
; 1294 :     if (bloklen<8)

  000b5	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000ba	83 f8 08	 cmp	 eax, 8
  000bd	7d 12		 jge	 SHORT $LN11@s370_devic

; 1295 :     {
; 1296 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000bf	ba 06 00 00 00	 mov	 edx, 6
  000c4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_devic:

; 1297 :     }
; 1298 : 
; 1299 :     /* Fetch remainder of supplied VRDCBLOK, but no more */
; 1300 :     if (bloklen>VRDCBLOK_SIZE)

  000d1	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  000d6	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000dc	76 0a		 jbe	 SHORT $LN12@s370_devic

; 1301 :        bloklen=VRDCBLOK_SIZE;

  000de	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000e3	66 89 44 24 40	 mov	 WORD PTR bloklen$[rsp], ax
$LN12@s370_devic:

; 1302 :     ARCH_DEP(vfetchc) (&vrdc.vrdcvdat,bloklen-5,blokaddr+4, USE_REAL_ADDR, regs);

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR blokaddr$[rsp]
  000ed	48 83 c0 04	 add	 rax, 4
  000f1	0f b7 4c 24 40	 movzx	 ecx, WORD PTR bloklen$[rsp]
  000f6	83 e9 05	 sub	 ecx, 5
  000f9	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00101	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00106	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0010c	44 8b c0	 mov	 r8d, eax
  0010f	0f b6 d1	 movzx	 edx, cl
  00112	48 8d 4c 24 64	 lea	 rcx, QWORD PTR vrdc$[rsp+4]
  00117	e8 00 00 00 00	 call	 s370_vfetchc

; 1303 : 
; 1304 : #if 0
; 1305 :     /* If length is 16 or greater, bytes 14 and 15 must be zero on z/VM 5.3.0 or earlier */
; 1306 :     if ( bloklen>=16)
; 1307 :     {
; 1308 :          FETCH_HW(reserved,&vrdc.vrdcrsvd);
; 1309 :          if (reserved != 0)
; 1310 :          {
; 1311 :               ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1312 :          }
; 1313 :     }
; 1314 : #endif
; 1315 : 
; 1316 :     /* Get the device number from the working VRDC */
; 1317 :     FETCH_HW(devnum,&vrdc.vrdcdvno);

  0011c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  00121	e8 00 00 00 00	 call	 fetch_hw_noswap
  00126	0f b7 c8	 movzx	 ecx, ax
  00129	e8 00 00 00 00	 call	 _byteswap_ushort
  0012e	66 89 44 24 50	 mov	 WORD PTR devnum$[rsp], ax

; 1318 : 
; 1319 :     /* Locate the device block and set the virtual and real device information */
; 1320 :     dev = ARCH_DEP(vmdevice_data) (0x210,devnum,&vrdc.vrdcvdat,&vrdc.vrdcrcdt);

  00133	4c 8d 4c 24 68	 lea	 r9, QWORD PTR vrdc$[rsp+8]
  00138	4c 8d 44 24 64	 lea	 r8, QWORD PTR vrdc$[rsp+4]
  0013d	0f b7 54 24 50	 movzx	 edx, WORD PTR devnum$[rsp]
  00142	b9 10 02 00 00	 mov	 ecx, 528		; 00000210H
  00147	e8 00 00 00 00	 call	 s370_vmdevice_data
  0014c	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 1321 : 
; 1322 :     /* Return condition code 3 if device does not exist */
; 1323 :     if (!dev)

  00151	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00157	0f 85 96 00 00
	00		 jne	 $LN13@s370_devic
$LN7@s370_devic:

; 1324 :     {
; 1325 :         PTT_ERR("*DIAG210",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00164	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00167	48 83 e0 10	 and	 rax, 16
  0016b	48 85 c0	 test	 rax, rax
  0016e	74 6f		 je	 SHORT $LN14@s370_devic
  00170	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00178	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0017e	48 63 8c 24 98
	01 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00186	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018e	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00195	48 63 94 24 90
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0019d	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a5	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  001ad	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170081
  001c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c7	44 8b c9	 mov	 r9d, ecx
  001ca	44 8b c2	 mov	 r8d, edx
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170082
  001d4	b9 10 00 00 00	 mov	 ecx, 16
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s370_devic:
  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	0f 85 74 ff ff
	ff		 jne	 $LN7@s370_devic

; 1326 :         return 3;

  001e9	b8 03 00 00 00	 mov	 eax, 3
  001ee	e9 a1 01 00 00	 jmp	 $LN1@s370_devic
$LN13@s370_devic:

; 1327 :     }
; 1328 : 
; 1329 :     /* Set the underlying device and real device features */
; 1330 :     vrdc.vrdcundv=0x00;

  001f3	c6 44 24 6c 00	 mov	 BYTE PTR vrdc$[rsp+12], 0

; 1331 :     vrdc.vrdcrdaf=0x00;

  001f8	c6 44 24 6d 00	 mov	 BYTE PTR vrdc$[rsp+13], 0

; 1332 : 
; 1333 :     /* Create device dependent mappings */
; 1334 :     if (vrdc.vrdcvdat.vdevcls == DC_DASD)

  001fd	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  00202	83 f8 04	 cmp	 eax, 4
  00205	0f 85 ed 00 00
	00		 jne	 $LN15@s370_devic

; 1335 :     {
; 1336 :         memcpy(&vrdc.vrdcrdc,dev->devchar,42);

  0020b	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  00210	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00215	48 8b f8	 mov	 rdi, rax
  00218	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  0021f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00224	f3 a4		 rep movsb

; 1337 :         switch (dev->devtype)

  00226	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0022b	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0022f	89 44 24 44	 mov	 DWORD PTR tv183[rsp], eax
  00233	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13104 ; 00003330H
  0023b	7f 2a		 jg	 SHORT $LN27@s370_devic
  0023d	81 7c 24 44 30
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13104 ; 00003330H
  00245	74 36		 je	 SHORT $LN20@s370_devic
  00247	81 7c 24 44 05
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8965 ; 00002305H
  0024f	74 2c		 je	 SHORT $LN19@s370_devic
  00251	81 7c 24 44 11
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8977 ; 00002311H
  00259	74 22		 je	 SHORT $LN17@s370_devic
  0025b	81 7c 24 44 14
	23 00 00	 cmp	 DWORD PTR tv183[rsp], 8980 ; 00002314H
  00263	74 18		 je	 SHORT $LN18@s370_devic
  00265	eb 6c		 jmp	 SHORT $LN8@s370_devic
$LN27@s370_devic:
  00267	81 7c 24 44 40
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13120 ; 00003340H
  0026f	74 0c		 je	 SHORT $LN21@s370_devic
  00271	81 7c 24 44 50
	33 00 00	 cmp	 DWORD PTR tv183[rsp], 13136 ; 00003350H
  00279	74 02		 je	 SHORT $LN22@s370_devic
  0027b	eb 56		 jmp	 SHORT $LN8@s370_devic
$LN17@s370_devic:
$LN18@s370_devic:
$LN19@s370_devic:
$LN20@s370_devic:
$LN21@s370_devic:
$LN22@s370_devic:

; 1338 :         {
; 1339 :              case 0x2311:
; 1340 :              case 0x2314:
; 1341 :              case 0x2305:
; 1342 :              case 0x3330:
; 1343 :              case 0x3340:
; 1344 :              case 0x3350:
; 1345 :                   /* Set non-keyed overhead */
; 1346 :                   STORE_HW(&vrdc.vrdcrdc[0x18],dev->ckdtab->f2);

  0027d	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00282	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  00289	0f b7 48 24	 movzx	 ecx, WORD PTR [rax+36]
  0028d	e8 00 00 00 00	 call	 _byteswap_ushort
  00292	b9 01 00 00 00	 mov	 ecx, 1
  00297	48 6b c9 18	 imul	 rcx, rcx, 24
  0029b	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002a0	0f b7 d0	 movzx	 edx, ax
  002a3	e8 00 00 00 00	 call	 store_hw_noswap

; 1347 :                   /* Set keyed overhead */
; 1348 :                   STORE_HW(&vrdc.vrdcrdc[0x1A],dev->ckdtab->f1);

  002a8	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002ad	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  002b4	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	b9 01 00 00 00	 mov	 ecx, 1
  002c2	48 6b c9 1a	 imul	 rcx, rcx, 26
  002c6	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR vrdc$[rsp+rcx+16]
  002cb	0f b7 d0	 movzx	 edx, ax
  002ce	e8 00 00 00 00	 call	 store_hw_noswap
$LN8@s370_devic:

; 1349 :              /* Note: for all other DASD devices these fields contain bytes 24-27 of the RDC */
; 1350 :         }
; 1351 :         /* Set Control Unit ID */
; 1352 :         vrdc.vrdcrdc[0x2A]=dev->devchar[56];

  002d3	b8 01 00 00 00	 mov	 eax, 1
  002d8	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  002dc	b9 01 00 00 00	 mov	 ecx, 1
  002e1	48 6b c9 2a	 imul	 rcx, rcx, 42		; 0000002aH
  002e5	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  002ea	0f b6 84 02 6c
	05 00 00	 movzx	 eax, BYTE PTR [rdx+rax+1388]
  002f2	88 44 0c 70	 mov	 BYTE PTR vrdc$[rsp+rcx+16], al

; 1353 :     }

  002f6	eb 25		 jmp	 SHORT $LN16@s370_devic
$LN15@s370_devic:

; 1354 :     else if (vrdc.vrdcvdat.vdevcls == DC_FBA)

  002f8	0f b6 44 24 64	 movzx	 eax, BYTE PTR vrdc$[rsp+4]
  002fd	83 f8 01	 cmp	 eax, 1
  00300	75 1b		 jne	 SHORT $LN23@s370_devic

; 1355 :         memcpy(&vrdc.vrdcrdc,dev->devchar,32);

  00302	48 8d 44 24 70	 lea	 rax, QWORD PTR vrdc$[rsp+16]
  00307	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0030c	48 8b f8	 mov	 rdi, rax
  0030f	48 8d b1 6c 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1388]
  00316	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0031b	f3 a4		 rep movsb
$LN23@s370_devic:
$LN16@s370_devic:

; 1356 : 
; 1357 :     /* Set Path Group ID */
; 1358 :     memcpy(&vrdc.vrdcpgid,dev->pgid,11);

  0031d	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR vrdc$[rsp+80]
  00325	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0032a	48 8b f8	 mov	 rdi, rax
  0032d	48 8d b1 ad 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1453]
  00334	b9 0b 00 00 00	 mov	 ecx, 11
  00339	f3 a4		 rep movsb

; 1359 : 
; 1360 :     /* Set version */
; 1361 :     if (bloklen>0x60)

  0033b	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  00340	83 f8 60	 cmp	 eax, 96			; 00000060H
  00343	7e 08		 jle	 SHORT $LN24@s370_devic

; 1362 :        vrdc.vrdcvers=0x01;

  00345	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR vrdc$[rsp+96], 1
$LN24@s370_devic:

; 1363 : 
; 1364 :     /* Set underlying real device */
; 1365 :     if (!(vrdc.vrdcrdaf & VRDCEMRD))

  0034d	0f b6 44 24 6d	 movzx	 eax, BYTE PTR vrdc$[rsp+13]
  00352	83 e0 02	 and	 eax, 2
  00355	85 c0		 test	 eax, eax
  00357	75 0d		 jne	 SHORT $LN25@s370_devic

; 1366 :        memcpy(&vrdc.vrdcrdev,&vrdc.vrdcdvno,2);

  00359	0f b7 44 24 60	 movzx	 eax, WORD PTR vrdc$[rsp]
  0035e	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR vrdc$[rsp+128], ax
$LN25@s370_devic:

; 1367 : 
; 1368 :     /* Update the VRDC in main storage */
; 1369 :     ARCH_DEP(vstorec) (&vrdc, bloklen-1, blokaddr, USE_REAL_ADDR, regs);

  00366	0f b7 44 24 40	 movzx	 eax, WORD PTR bloklen$[rsp]
  0036b	ff c8		 dec	 eax
  0036d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00375	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0037a	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00380	44 8b 44 24 58	 mov	 r8d, DWORD PTR blokaddr$[rsp]
  00385	0f b6 d0	 movzx	 edx, al
  00388	48 8d 4c 24 60	 lea	 rcx, QWORD PTR vrdc$[rsp]
  0038d	e8 00 00 00 00	 call	 s370_vstorec

; 1370 : 
; 1371 :     /* Return condition code 0 for success */
; 1372 :     return 0;

  00392	33 c0		 xor	 eax, eax
$LN1@s370_devic:

; 1373 : 
; 1374 : } /* end function device_info */

  00394	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039c	48 33 cc	 xor	 rcx, rsp
  0039f	e8 00 00 00 00	 call	 __security_check_cookie
  003a4	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  003ab	5f		 pop	 rdi
  003ac	5e		 pop	 rsi
  003ad	c3		 ret	 0
s370_device_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
tv69 = 36
dev$ = 40
r1$ = 64
r2$ = 72
regs$ = 80
s370_vm_info PROC

; 1382 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1383 : DEVBLK  *dev;                          /* -> Device block            */
; 1384 : U16     devnum;                        /* Device number              */
; 1385 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1386 : RADR    stgarea;                       /* Storage extent area        */
; 1387 : S64     stglen;                        /* Storage extent area length */
; 1388 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1389 : 
; 1390 :     /* Ry contains the subcode */
; 1391 :     switch(regs->GR_L(r2))

  00011	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00022	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
  00026	83 7c 24 24 00	 cmp	 DWORD PTR tv69[rsp], 0
  0002b	74 13		 je	 SHORT $LN4@s370_vm_in
  0002d	83 7c 24 24 04	 cmp	 DWORD PTR tv69[rsp], 4
  00032	74 2d		 je	 SHORT $LN5@s370_vm_in
  00034	83 7c 24 24 08	 cmp	 DWORD PTR tv69[rsp], 8
  00039	74 7f		 je	 SHORT $LN8@s370_vm_in
  0003b	e9 2d 01 00 00	 jmp	 $LN12@s370_vm_in
$LN4@s370_vm_in:

; 1392 :     {
; 1393 :     case 0x00000000: /* Highest addressable byte */
; 1394 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1395 : 
; 1396 :         /* Program check if running in z/Architecture mode and */
; 1397 :         /* 64-bit addressing is being used.                    */
; 1398 :         if (regs->psw.amode64)
; 1399 :         {
; 1400 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1401 :         }
; 1402 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1403 :         regs->GR_L(r1) = regs->mainlim; /* provide highest addressable byte */

  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0004f	8b 92 58 08 00
	00		 mov	 edx, DWORD PTR [rdx+2136]
  00055	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1404 :         return;

  0005c	e9 1b 01 00 00	 jmp	 $LN1@s370_vm_in
$LN5@s370_vm_in:

; 1405 : 
; 1406 :     case 0x00000004: /* Provide BYUSER ID value */
; 1407 : 
; 1408 :         /* Program check if Rx and Ry are the same registers or        */
; 1409 :         /* or Ry is not an even register or the address provided       */
; 1410 :         /* in Rx is not on a doubleword boundary or if running         */
; 1411 :         /* in z/Architecture mode and 64-bit addressing is being used. */
; 1412 :         if ( r1 == r2 || r2 & 0x1 || regs->GR_L(r1) & 0x7

  00061	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  00065	39 44 24 40	 cmp	 DWORD PTR r1$[rsp], eax
  00069	74 23		 je	 SHORT $LN7@s370_vm_in
  0006b	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  0006f	83 e0 01	 and	 eax, 1
  00072	85 c0		 test	 eax, eax
  00074	75 18		 jne	 SHORT $LN7@s370_vm_in
  00076	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00087	83 e0 07	 and	 eax, 7
  0008a	85 c0		 test	 eax, eax
  0008c	74 0f		 je	 SHORT $LN6@s370_vm_in
$LN7@s370_vm_in:

; 1413 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1414 :              || (regs->psw.amode64)
; 1415 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1416 :            )
; 1417 :         {
; 1418 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0008e	ba 06 00 00 00	 mov	 edx, 6
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_vm_in:

; 1419 :         }
; 1420 :         regs->GR_L(r2+1)=0x4; /* Indicate no BYUSER ID for Hercules */

  0009d	8b 44 24 48	 mov	 eax, DWORD PTR r2$[rsp]
  000a1	ff c0		 inc	 eax
  000a3	48 98		 cdqe
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4

; 1421 :         return;

  000b5	e9 c2 00 00 00	 jmp	 $LN1@s370_vm_in
$LN8@s370_vm_in:

; 1422 : 
; 1423 :     case 0x00000008: /* Return number of lines per page */
; 1424 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1425 : 
; 1426 :         /* Program check if running in z/Architecture mode and */
; 1427 :         /* 64-bit addressing is being used.                    */
; 1428 :         if (regs->psw.amode64)
; 1429 :         {
; 1430 :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1431 :         }
; 1432 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1433 : 
; 1434 :         /* Get the device number from the Rx register */
; 1435 :         devnum=regs->GR_LHL(r1);

  000ba	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000cc	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 1436 : 
; 1437 :         /* Locate the device block */
; 1438 :         dev = find_device_by_devnum(0,devnum);

  000d1	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  000d6	33 c9		 xor	 ecx, ecx
  000d8	e8 00 00 00 00	 call	 find_device_by_devnum
  000dd	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 1439 : 
; 1440 :         /* Set 0 lines per page for a valid printer or console (meaning SPOOL is OFF) */
; 1441 :         if (dev != NULL &&

  000e2	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000e8	74 6c		 je	 SHORT $LN9@s370_vm_in
  000ea	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  000f3	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  000f8	74 30		 je	 SHORT $LN11@s370_vm_in
  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00103	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00108	74 20		 je	 SHORT $LN11@s370_vm_in
  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0010f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00113	3d 52 10 00 00	 cmp	 eax, 4178		; 00001052H
  00118	74 10		 je	 SHORT $LN11@s370_vm_in
  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0011f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00123	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00128	75 2c		 jne	 SHORT $LN9@s370_vm_in
$LN11@s370_vm_in:

; 1442 :               (dev->devtype == 0x1403 ||
; 1443 :                dev->devtype == 0x3211 ||
; 1444 :                dev->devtype == 0x1052 ||
; 1445 :                dev->devtype == 0x3215 )
; 1446 :             )
; 1447 :         {
; 1448 :            regs->GR_L(r1) = 0; /* Set zero lines per page */

  0012a	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1449 :            regs->GR_L(r2) = 0; /* Set return code to indicate a valid device */

  0013f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1450 :         }

  00154	eb 15		 jmp	 SHORT $LN10@s370_vm_in
$LN9@s370_vm_in:

; 1451 :         else
; 1452 :         {
; 1453 :            regs->GR_L(r2) = 4; /* Set return code to indicate an invalid device */

  00156	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN10@s370_vm_in:

; 1454 :         }
; 1455 :         return;

  0016b	eb 0f		 jmp	 SHORT $LN1@s370_vm_in
$LN12@s370_vm_in:

; 1456 : 
; 1457 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1458 :     case 0x0000000C: /* Return highest addressable byte for z/Architecture machine */
; 1459 :          regs->GR_G(r1) = regs->mainlim;
; 1460 :          regs->GR_G(r2) = regs->mainlim;
; 1461 :          return;
; 1462 : 
; 1463 :     case 0x00000010: /* Set storage extent */
; 1464 : 
; 1465 :          /* Obtain the storage extent area real address from Rx */
; 1466 :          /* and its length from Rx+1                            */
; 1467 :          stgarea=regs->GR_G(r1);
; 1468 :          stglen=regs->GR_G(r1+1); /* Length is treated as a signed value */
; 1469 : 
; 1470 :          /* Program check if Rx is not an even register or the address */
; 1471 :          /* provided in Rx is not on a quadword boundary or the length */
; 1472 :          /* provided in Rx+1 is not positive or not a multiple of 16   */
; 1473 :          if ( r1 & 1 || stgarea & 0xF || stglen <= 0 || stglen & 0xF )
; 1474 :          {
; 1475 :              ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 1476 :          }
; 1477 : 
; 1478 :          /* Convert real address to absolute address */
; 1479 :          stgarea=APPLY_PREFIXING(stgarea,regs->PX );
; 1480 : 
; 1481 :          /* Check to ensure extent information can be stored */
; 1482 :          if (stgarea > regs->mainlim - 16)
; 1483 :          {
; 1484 :              regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);
; 1485 :          }
; 1486 :          /* Set start of storage extent to zero */
; 1487 :          ARCH_DEP(store_doubleword_absolute)(0,stgarea,regs);
; 1488 :          /* Set end of storage extent to last addressable byte of main storage */
; 1489 :          ARCH_DEP(store_doubleword_absolute)(regs->mainlim,stgarea+8,regs);
; 1490 :          /* Set number of extents to 1 in Ry */
; 1491 :          regs->GR_G(r2) = 1;
; 1492 :          /* Indicate all extents returned */
; 1493 :          regs->psw.cc = 0;
; 1494 :          return;
; 1495 : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 1496 : 
; 1497 :     default: /* Invalid subcode */
; 1498 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0016d	ba 06 00 00 00	 mov	 edx, 6
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 s370_program_interrupt
$LN1@s370_vm_in:

; 1499 :     }
; 1500 : }

  0017c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00180	c3		 ret	 0
s370_vm_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
func$ = 32
skey$ = 33
refchg$1 = 34
abs$ = 36
tv130 = 40
end$ = 44
start$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
s370_diag_ppagerel PROC

; 1614 : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1615 : U32     abs, start, end;                /* Absolute frame addresses  */
; 1616 : BYTE    skey;                           /* Specified storage key     */
; 1617 : BYTE    func;                           /* Function code...          */
; 1618 : #define DIAG214_EPR             0x00    /* Establish pending release */
; 1619 : #define DIAG214_CPR             0x01    /* Cancel pending release    */
; 1620 : #define DIAG214_CAPR            0x02    /* Cancel all pending release*/
; 1621 : #define DIAG214_CPRV            0x03    /* Cancel and validate       */
; 1622 : 
; 1623 :     /* Program check if R1 is not an even-numbered register */
; 1624 :     if (r1 & 1)

  00011	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	74 0f		 je	 SHORT $LN7@s370_diag_

; 1625 :     {
; 1626 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0001c	ba 06 00 00 00	 mov	 edx, 6
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	e8 00 00 00 00	 call	 s370_program_interrupt
$LN7@s370_diag_:

; 1627 :     }
; 1628 : 
; 1629 :     /* Extract the function code from R1+1 register bits 24-31 */
; 1630 :     func = regs->GR_L(r1+1) & 0xFF;

  0002b	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0002f	ff c0		 inc	 eax
  00031	48 98		 cdqe
  00033	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	88 44 24 20	 mov	 BYTE PTR func$[rsp], al

; 1631 : 
; 1632 :     /* Extract the start/end addresses from R1 and R1+1 registers */
; 1633 :     start = regs->GR_L(r1) & STORAGE_KEY_PAGEMASK;

  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0005e	89 44 24 30	 mov	 DWORD PTR start$[rsp], eax

; 1634 :     end = regs->GR_L(r1+1) & STORAGE_KEY_PAGEMASK;

  00062	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00066	ff c0		 inc	 eax
  00068	48 98		 cdqe
  0006a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00076	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0007b	89 44 24 2c	 mov	 DWORD PTR end$[rsp], eax

; 1635 : 
; 1636 :     /* Validate start/end addresses if function is not CAPR */
; 1637 :     if (func != DIAG214_CAPR
; 1638 :         && (start > end || end > regs->mainlim))

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  00084	83 f8 02	 cmp	 eax, 2
  00087	74 2b		 je	 SHORT $LN8@s370_diag_
  00089	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  0008d	39 44 24 30	 cmp	 DWORD PTR start$[rsp], eax
  00091	77 12		 ja	 SHORT $LN9@s370_diag_
  00093	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000a3	76 0f		 jbe	 SHORT $LN8@s370_diag_
$LN9@s370_diag_:

; 1639 :     {
; 1640 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000a5	ba 06 00 00 00	 mov	 edx, 6
  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_diag_:

; 1641 :     }
; 1642 : 
; 1643 :     /* Process depending on function code */
; 1644 :     switch (func)

  000b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR func$[rsp]
  000b9	88 44 24 28	 mov	 BYTE PTR tv130[rsp], al
  000bd	80 7c 24 28 00	 cmp	 BYTE PTR tv130[rsp], 0
  000c2	74 1b		 je	 SHORT $LN10@s370_diag_
  000c4	80 7c 24 28 01	 cmp	 BYTE PTR tv130[rsp], 1
  000c9	74 19		 je	 SHORT $LN11@s370_diag_
  000cb	80 7c 24 28 02	 cmp	 BYTE PTR tv130[rsp], 2
  000d0	0f 84 83 00 00
	00		 je	 $LN14@s370_diag_
  000d6	80 7c 24 28 03	 cmp	 BYTE PTR tv130[rsp], 3
  000db	74 07		 je	 SHORT $LN12@s370_diag_
  000dd	eb 7c		 jmp	 SHORT $LN15@s370_diag_
$LN10@s370_diag_:

; 1645 :     {
; 1646 :     case DIAG214_EPR:  /* Establish Pending Release */
; 1647 :         break;

  000df	e9 86 00 00 00	 jmp	 $LN2@s370_diag_
$LN11@s370_diag_:
$LN12@s370_diag_:

; 1648 : 
; 1649 :     case DIAG214_CPR:  /* Cancel Pending Release */
; 1650 :     case DIAG214_CPRV: /* Cancel Pending Release and Validate */
; 1651 : 
; 1652 :         /* Do not set storage keys if R2 is register 0 */
; 1653 :         if (r2 == 0) break;

  000e4	83 7c 24 58 00	 cmp	 DWORD PTR r2$[rsp], 0
  000e9	75 02		 jne	 SHORT $LN13@s370_diag_
  000eb	eb 7d		 jmp	 SHORT $LN2@s370_diag_
$LN13@s370_diag_:

; 1654 : 
; 1655 :         /* Obtain key from R2 register bits 24-28 */
; 1656 :         skey = regs->GR_L(r2) & (STORKEY_KEY | STORKEY_FETCH);

  000ed	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000fe	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00103	88 44 24 21	 mov	 BYTE PTR skey$[rsp], al

; 1657 : 
; 1658 :         /* Set storage key for each frame within specified range
; 1659 :            without changing existing reference and change bits.
; 1660 :         */
; 1661 :         for (abs = start; abs <= end; abs += STORAGE_KEY_PAGESIZE)

  00107	8b 44 24 30	 mov	 eax, DWORD PTR start$[rsp]
  0010b	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
  0010f	eb 0d		 jmp	 SHORT $LN6@s370_diag_
$LN4@s370_diag_:
  00111	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  00115	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  0011a	89 44 24 24	 mov	 DWORD PTR abs$[rsp], eax
$LN6@s370_diag_:
  0011e	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00122	39 44 24 24	 cmp	 DWORD PTR abs$[rsp], eax
  00126	77 2f		 ja	 SHORT $LN5@s370_diag_

; 1662 :         {
; 1663 :             BYTE refchg = ARCH_DEP( get_storage_key )( abs ) & (STORKEY_REF | STORKEY_CHANGE);

  00128	8b 44 24 24	 mov	 eax, DWORD PTR abs$[rsp]
  0012c	8b c8		 mov	 ecx, eax
  0012e	e8 00 00 00 00	 call	 s370_get_storage_key
  00133	0f b6 c0	 movzx	 eax, al
  00136	83 e0 06	 and	 eax, 6
  00139	88 44 24 22	 mov	 BYTE PTR refchg$1[rsp], al

; 1664 :             ARCH_DEP( put_storage_key )( abs, skey | refchg );

  0013d	0f b6 44 24 21	 movzx	 eax, BYTE PTR skey$[rsp]
  00142	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR refchg$1[rsp]
  00147	0b c1		 or	 eax, ecx
  00149	8b 4c 24 24	 mov	 ecx, DWORD PTR abs$[rsp]
  0014d	0f b6 d0	 movzx	 edx, al
  00150	e8 00 00 00 00	 call	 s370_put_storage_key

; 1665 :         }

  00155	eb ba		 jmp	 SHORT $LN4@s370_diag_
$LN5@s370_diag_:

; 1666 : 
; 1667 :         break;

  00157	eb 11		 jmp	 SHORT $LN2@s370_diag_
$LN14@s370_diag_:

; 1668 : 
; 1669 :     case DIAG214_CAPR:  /* Cancel All Pending Releases */
; 1670 :         break;

  00159	eb 0f		 jmp	 SHORT $LN2@s370_diag_
$LN15@s370_diag_:

; 1671 : 
; 1672 :     default:            /* Invalid function code */
; 1673 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015b	ba 06 00 00 00	 mov	 edx, 6
  00160	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@s370_diag_:

; 1674 :     } /* end switch(func) */
; 1675 : 
; 1676 :     /* Return condition code zero */
; 1677 :     return 0;

  0016a	33 c0		 xor	 eax, eax

; 1678 : 
; 1679 : } /* end function diag_ppagerel */

  0016c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00170	c3		 ret	 0
s370_diag_ppagerel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
cmdflags$ = 80
i$ = 84
resplen$1 = 88
rem$2 = 92
chunk$3 = 96
cmdlen$ = 100
maxrlen$ = 104
resp$ = 112
cc$ = 120
tv250 = 124
freeresp$ = 128
cmdaddr$ = 132
respadr$ = 136
$T4 = 144
tv181 = 152
tv207 = 160
tv264 = 168
cmd$ = 176
msg$ = 448
__$ArrayPad$ = 704
r1$ = 736
r2$ = 744
regs$ = 752
s370_cpcmd_call PROC

; 1057 : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1058 : U32     i;                              /* Array subscript           */
; 1059 : U32     cc;                             /* Condition code            */
; 1060 : U32     cmdaddr;                        /* Address of command string */
; 1061 : U32     cmdlen;                         /* Length of command string  */
; 1062 : U32     respadr;                        /* Address of response buffer*/
; 1063 : U32     maxrlen;                        /* Length of response buffer */
; 1064 : BYTE    cmdflags;                       /* Command flags             */
; 1065 : 
; 1066 : #define CMDFLAGS_REJPASSW     0x80      /* Reject password in command*/
; 1067 : #define CMDFLAGS_RESPONSE     0x40      /* Return response in buffer */
; 1068 : #define CMDFLAGS_REQPASSW     0x20      /* Prompt for password       */
; 1069 : #define CMDFLAGS_RESERVED     0x1F      /* Reserved bits, must be 0  */
; 1070 : 
; 1071 : char    msg[256];                       /* Message work area         */
; 1072 : char    cmd[256+1];                     /* Input command +1 for NULL */
; 1073 : char*   resp;                           /* Output response           */
; 1074 : int     freeresp;                       /* Flag to free resp         */
; 1075 : 
; 1076 :     /* Obtain address of command from R1 register
; 1077 :        and command length and flags from R2 register
; 1078 :     */
; 1079 :     cmdaddr  = regs->GR_L( r1 );

  00026	48 63 84 24 e0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 84 24 84 00
	00 00		 mov	 DWORD PTR cmdaddr$[rsp], eax

; 1080 :     cmdflags = regs->GR_L( r2 ) >> 24;

  00044	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0004c	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0005b	c1 e8 18	 shr	 eax, 24
  0005e	88 44 24 50	 mov	 BYTE PTR cmdflags$[rsp], al

; 1081 :     cmdlen   = regs->GR_L( r2 ) & 0x00FFFFFF;

  00062	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0006a	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0007e	89 44 24 64	 mov	 DWORD PTR cmdlen$[rsp], eax

; 1082 : 
; 1083 :     /* Program check if invalid flags, or if command string
; 1084 :        is too long, or if response buffer is specified and
; 1085 :        registers are consecutive or either register specifies
; 1086 :        register 15
; 1087 :     */
; 1088 :     if (0
; 1089 :         || (cmdflags & CMDFLAGS_RESERVED)
; 1090 :         || (cmdlen > (sizeof(cmd)-1))   // (room for NULL terminator!)
; 1091 :         || (1

  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 69		 jne	 SHORT $LN15@s370_cpcmd
  00088	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  0008d	83 e0 1f	 and	 eax, 31
  00090	85 c0		 test	 eax, eax
  00092	75 5d		 jne	 SHORT $LN15@s370_cpcmd
  00094	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  00098	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  0009e	77 51		 ja	 SHORT $LN15@s370_cpcmd
  000a0	33 c0		 xor	 eax, eax
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	74 5c		 je	 SHORT $LN14@s370_cpcmd
  000a7	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  000ac	83 e0 40	 and	 eax, 64			; 00000040H
  000af	85 c0		 test	 eax, eax
  000b1	74 50		 je	 SHORT $LN14@s370_cpcmd
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 38		 jne	 SHORT $LN16@s370_cpcmd
  000b9	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000c0	ff c0		 inc	 eax
  000c2	39 84 24 e0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  000c9	74 26		 je	 SHORT $LN16@s370_cpcmd
  000cb	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	39 84 24 e8 02
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  000db	74 14		 je	 SHORT $LN16@s370_cpcmd
  000dd	83 bc 24 e0 02
	00 00 0f	 cmp	 DWORD PTR r1$[rsp], 15
  000e5	74 0a		 je	 SHORT $LN16@s370_cpcmd
  000e7	83 bc 24 e8 02
	00 00 0f	 cmp	 DWORD PTR r2$[rsp], 15
  000ef	75 12		 jne	 SHORT $LN14@s370_cpcmd
$LN16@s370_cpcmd:
$LN15@s370_cpcmd:

; 1092 :             && (cmdflags & CMDFLAGS_RESPONSE)
; 1093 :             && (0
; 1094 :                 || r1 == r2 + 1
; 1095 :                 || r2 == r1 + 1
; 1096 :                 || r1 == 15
; 1097 :                 || r2 == 15
; 1098 :                )
; 1099 :            )
; 1100 :     )
; 1101 :     {
; 1102 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000f1	ba 06 00 00 00	 mov	 edx, 6
  000f6	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_cpcmd:

; 1103 :     }
; 1104 : 
; 1105 :     /* Put machine into stopped state if command length is zero */
; 1106 :     if (cmdlen == 0)

  00103	83 7c 24 64 00	 cmp	 DWORD PTR cmdlen$[rsp], 0
  00108	75 52		 jne	 SHORT $LN17@s370_cpcmd

; 1107 :     {
; 1108 :         regs->opinterv = 0;

  0010a	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00118	83 e0 ef	 and	 eax, -17		; ffffffefH
  0011b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1109 :         regs->cpustate = CPUSTATE_STOPPED;

  00129	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN4@s370_cpcmd:

; 1110 :         ON_IC_INTERRUPT( regs );

  00135	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00140	0f ba e8 1f	 bts	 eax, 31
  00144	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 e0		 jne	 SHORT $LN4@s370_cpcmd

; 1111 :         return 0;

  00155	33 c0		 xor	 eax, eax
  00157	e9 a5 04 00 00	 jmp	 $LN1@s370_cpcmd
$LN17@s370_cpcmd:

; 1112 :     }
; 1113 : 
; 1114 :     /* Obtain the EBCDIC command string from guest storage */
; 1115 :     ARCH_DEP( vfetchc )( cmd, cmdlen-1, cmdaddr, USE_REAL_ADDR, regs );

  0015c	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  00160	ff c8		 dec	 eax
  00162	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0016f	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00175	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR cmdaddr$[rsp]
  0017d	0f b6 d0	 movzx	 edx, al
  00180	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00188	e8 00 00 00 00	 call	 s370_vfetchc

; 1116 : 
; 1117 :     /* Translate guest EBCDIC command to host ASCII format */
; 1118 :     for (i=0; i < cmdlen; i++)

  0018d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00195	eb 0a		 jmp	 SHORT $LN7@s370_cpcmd
$LN5@s370_cpcmd:
  00197	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0019b	ff c0		 inc	 eax
  0019d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_cpcmd:
  001a1	8b 44 24 64	 mov	 eax, DWORD PTR cmdlen$[rsp]
  001a5	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  001a9	73 1f		 jae	 SHORT $LN6@s370_cpcmd

; 1119 :         cmd[i] = guest_to_host( cmd[i] );

  001ab	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001af	0f b6 8c 04 b0
	00 00 00	 movzx	 ecx, BYTE PTR cmd$[rsp+rax]
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  001bd	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  001c1	88 84 0c b0 00
	00 00		 mov	 BYTE PTR cmd$[rsp+rcx], al
  001c8	eb cd		 jmp	 SHORT $LN5@s370_cpcmd
$LN6@s370_cpcmd:

; 1120 :     cmd[i] = 0; // (null terminate!)

  001ca	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  001ce	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  001d6	48 81 bc 24 90
	00 00 00 01 01
	00 00		 cmp	 QWORD PTR $T4[rsp], 257	; 00000101H
  001e2	73 02		 jae	 SHORT $LN33@s370_cpcmd
  001e4	eb 05		 jmp	 SHORT $LN34@s370_cpcmd
$LN33@s370_cpcmd:
  001e6	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@s370_cpcmd:
  001eb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  001f3	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR cmd$[rsp+rax], 0

; 1121 : 
; 1122 :     /* Execute the Hercules emulator (hypervisor) command */
; 1123 :     resp = "";

  001fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169994
  00202	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1124 :     freeresp = 0;

  00207	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 0

; 1125 : 
; 1126 : #if !defined( FEATURE_HERCULES_DIAGCALLS )
; 1127 :         // "Hercules-specific DIAG instructions support not included in engine build"
; 1128 :         MSGBUF( msg, MSG( HHC01954, "E" ));
; 1129 :         resp = &msg[0];
; 1130 : #else
; 1131 :     /************************************************************
; 1132 :      *  SECURITY CHECK: Reject attempts to issue "shell" type
; 1133 :      *  commands unless specifically allowed by SHCMDOPT option.
; 1134 :      ************************************************************/
; 1135 :     if (1
; 1136 :         && is_shell_command( cmd )
; 1137 :         && (sysblk.shcmdopt & (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8))

  00212	33 c0		 xor	 eax, eax
  00214	83 f8 01	 cmp	 eax, 1
  00217	74 66		 je	 SHORT $LN18@s370_cpcmd
  00219	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00221	e8 00 00 00 00	 call	 is_shell_command
  00226	0f b6 c0	 movzx	 eax, al
  00229	85 c0		 test	 eax, eax
  0022b	74 52		 je	 SHORT $LN18@s370_cpcmd
  0022d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00234	0f b6 80 2f 11
	00 00		 movzx	 eax, BYTE PTR [rax+4399]
  0023b	83 e0 03	 and	 eax, 3
  0023e	83 f8 03	 cmp	 eax, 3
  00241	74 3c		 je	 SHORT $LN18@s370_cpcmd

; 1138 :                            != (SHCMDOPT_ENABLE + SHCMDOPT_DIAG8)
; 1139 :     )
; 1140 :     {
; 1141 :         // "DIAG8 access to shell disallowed by SHCMDOPT setting"
; 1142 :         MSGBUF( msg, MSG( HHC01953, "E" ));

  00243	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169997
  0024a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169998
  00251	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00256	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR msg$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1143 :         resp = &msg[0];

  00264	b8 01 00 00 00	 mov	 eax, 1
  00269	48 6b c0 00	 imul	 rax, rax, 0
  0026d	48 8d 84 04 c0
	01 00 00	 lea	 rax, QWORD PTR msg$[rsp+rax]
  00275	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax

; 1144 :     }

  0027a	e9 7e 01 00 00	 jmp	 $LN19@s370_cpcmd
$LN18@s370_cpcmd:

; 1145 :     else
; 1146 :     {
; 1147 :         /* It's either not a "shell" type command or the
; 1148 :            SHCMDOPT option is allowing them to be issued
; 1149 :            so we can go ahead and execute the command. */
; 1150 : 
; 1151 :         // "%s guest issued panel command: %s"
; 1152 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  0027f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00286	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0028d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00292	85 c0		 test	 eax, eax
  00294	74 7d		 je	 SHORT $LN20@s370_cpcmd

; 1153 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Starting", RTRIM( cmd ));

  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170000
  0029d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  002ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv181[rsp], rax
  002b3	b9 01 00 00 00	 mov	 ecx, 1
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv181[rsp]
  002c6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170001
  002d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170002
  002de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170003
  002ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f4	41 b9 02 00 00
	00		 mov	 r9d, 2
  002fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170004
  00301	ba 81 04 00 00	 mov	 edx, 1153		; 00000481H
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170005
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@s370_cpcmd:

; 1154 : 
; 1155 :         /* Issue the command and capture the response */
; 1156 :         if (cmdflags & CMDFLAGS_RESPONSE)

  00313	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  00318	83 e0 40	 and	 eax, 64			; 00000040H
  0031b	85 c0		 test	 eax, eax
  0031d	74 39		 je	 SHORT $LN21@s370_cpcmd

; 1157 :         {
; 1158 :             panel_command_capture( cmd, &resp, false );

  0031f	45 33 c0	 xor	 r8d, r8d
  00322	48 8d 54 24 70	 lea	 rdx, QWORD PTR resp$[rsp]
  00327	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_panel_command_capture

; 1159 : 
; 1160 :             if (resp)

  00335	48 83 7c 24 70
	00		 cmp	 QWORD PTR resp$[rsp], 0
  0033b	74 0d		 je	 SHORT $LN23@s370_cpcmd

; 1161 :                 freeresp = 1;

  0033d	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR freeresp$[rsp], 1
  00348	eb 0c		 jmp	 SHORT $LN24@s370_cpcmd
$LN23@s370_cpcmd:

; 1162 :             else
; 1163 :                 resp = "";

  0034a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170010
  00351	48 89 44 24 70	 mov	 QWORD PTR resp$[rsp], rax
$LN24@s370_cpcmd:

; 1164 :         }

  00356	eb 11		 jmp	 SHORT $LN22@s370_cpcmd
$LN21@s370_cpcmd:

; 1165 :         else /* Issue command normally (no response wanted) */
; 1166 :         {
; 1167 :             panel_command( cmd );

  00358	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00360	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  00367	ff 10		 call	 QWORD PTR [rax]
$LN22@s370_cpcmd:

; 1168 :         }
; 1169 : 
; 1170 :         // "%s guest issued panel command: %s"
; 1171 :         if (sysblk.diag8opt & DIAG8CMD_ECHO)

  00369	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00370	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00377	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0037c	85 c0		 test	 eax, eax
  0037e	74 7d		 je	 SHORT $LN25@s370_cpcmd

; 1172 :             PWRMSG( WRMSG_PANEL, HHC01950, "I", "Completed", RTRIM( cmd ));

  00380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170012
  00387	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  00395	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  0039d	b9 01 00 00 00	 mov	 ecx, 1
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  003b0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170013
  003bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170014
  003c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170015
  003d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003de	41 b9 02 00 00
	00		 mov	 r9d, 2
  003e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170016
  003eb	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170017
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@s370_cpcmd:
$LN19@s370_cpcmd:

; 1173 :     }
; 1174 : #endif // defined( FEATURE_HERCULES_DIAGCALLS )
; 1175 : 
; 1176 :     /* Copy response to guest storage if response requested */
; 1177 :     if (cmdflags & CMDFLAGS_RESPONSE)

  003fd	0f b6 44 24 50	 movzx	 eax, BYTE PTR cmdflags$[rsp]
  00402	83 e0 40	 and	 eax, 64			; 00000040H
  00405	85 c0		 test	 eax, eax
  00407	0f 84 b8 01 00
	00		 je	 $LN26@s370_cpcmd

; 1178 :     {
; 1179 :         U32 resplen, chunk, rem;
; 1180 : 
; 1181 :         /* Translate host ASCII response to guest EBCDIC format */
; 1182 :         for (i=0, resplen = (U32) strlen( resp ); i < resplen; i++)

  0040d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00415	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  0041a	e8 00 00 00 00	 call	 strlen
  0041f	89 44 24 58	 mov	 DWORD PTR resplen$1[rsp], eax
  00423	eb 0a		 jmp	 SHORT $LN10@s370_cpcmd
$LN8@s370_cpcmd:
  00425	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00429	ff c0		 inc	 eax
  0042b	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_cpcmd:
  0042f	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  00433	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00437	73 21		 jae	 SHORT $LN9@s370_cpcmd

; 1183 :             resp[i] = host_to_guest( resp[i] );

  00439	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0043d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  00442	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00446	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0044c	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00450	48 8b 54 24 70	 mov	 rdx, QWORD PTR resp$[rsp]
  00455	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00458	eb cb		 jmp	 SHORT $LN8@s370_cpcmd
$LN9@s370_cpcmd:

; 1184 : 
; 1185 :         /* Retrieve guest's response parameters */
; 1186 :         respadr = regs->GR_L( r1+1 );

  0045a	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00461	ff c0		 inc	 eax
  00463	48 98		 cdqe
  00465	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00474	89 84 24 88 00
	00 00		 mov	 DWORD PTR respadr$[rsp], eax

; 1187 :         maxrlen = regs->GR_L( r2+1 );

  0047b	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00482	ff c0		 inc	 eax
  00484	48 98		 cdqe
  00486	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00495	89 44 24 68	 mov	 DWORD PTR maxrlen$[rsp], eax

; 1188 : 
; 1189 :         /* Copy the response to guest storage in 256 byte chunks */
; 1190 :         for (i=0, chunk=256, rem = MIN( resplen, maxrlen ); rem; rem -= chunk, i += chunk)

  00499	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004a1	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR chunk$3[rsp], 256 ; 00000100H
  004a9	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004ad	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  004b1	73 0a		 jae	 SHORT $LN35@s370_cpcmd
  004b3	8b 44 24 58	 mov	 eax, DWORD PTR resplen$1[rsp]
  004b7	89 44 24 7c	 mov	 DWORD PTR tv250[rsp], eax
  004bb	eb 08		 jmp	 SHORT $LN36@s370_cpcmd
$LN35@s370_cpcmd:
  004bd	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  004c1	89 44 24 7c	 mov	 DWORD PTR tv250[rsp], eax
$LN36@s370_cpcmd:
  004c5	8b 44 24 7c	 mov	 eax, DWORD PTR tv250[rsp]
  004c9	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004cd	eb 20		 jmp	 SHORT $LN13@s370_cpcmd
$LN11@s370_cpcmd:
  004cf	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004d3	8b 4c 24 5c	 mov	 ecx, DWORD PTR rem$2[rsp]
  004d7	2b c8		 sub	 ecx, eax
  004d9	8b c1		 mov	 eax, ecx
  004db	89 44 24 5c	 mov	 DWORD PTR rem$2[rsp], eax
  004df	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004e3	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  004e7	03 c8		 add	 ecx, eax
  004e9	8b c1		 mov	 eax, ecx
  004eb	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_cpcmd:
  004ef	83 7c 24 5c 00	 cmp	 DWORD PTR rem$2[rsp], 0
  004f4	74 6c		 je	 SHORT $LN12@s370_cpcmd

; 1191 :         {
; 1192 :             if (rem < chunk) chunk = rem;

  004f6	8b 44 24 60	 mov	 eax, DWORD PTR chunk$3[rsp]
  004fa	39 44 24 5c	 cmp	 DWORD PTR rem$2[rsp], eax
  004fe	73 08		 jae	 SHORT $LN28@s370_cpcmd
  00500	8b 44 24 5c	 mov	 eax, DWORD PTR rem$2[rsp]
  00504	89 44 24 60	 mov	 DWORD PTR chunk$3[rsp], eax
$LN28@s370_cpcmd:

; 1193 :             ARCH_DEP( vstorec )( &resp[i], chunk-1, respadr+i, USE_REAL_ADDR, regs );

  00508	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0050c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR respadr$[rsp]
  00513	03 c8		 add	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	8b 4c 24 60	 mov	 ecx, DWORD PTR chunk$3[rsp]
  0051b	ff c9		 dec	 ecx
  0051d	8b 54 24 54	 mov	 edx, DWORD PTR i$[rsp]
  00521	4c 8b 44 24 70	 mov	 r8, QWORD PTR resp$[rsp]
  00526	4c 03 c2	 add	 r8, rdx
  00529	49 8b d0	 mov	 rdx, r8
  0052c	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv264[rsp], rdx
  00534	4c 8b 84 24 f0
	02 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0053c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00541	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00547	44 8b c0	 mov	 r8d, eax
  0054a	0f b6 d1	 movzx	 edx, cl
  0054d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv264[rsp]
  00555	48 8b c8	 mov	 rcx, rax
  00558	e8 00 00 00 00	 call	 s370_vstorec

; 1194 :         }

  0055d	e9 6d ff ff ff	 jmp	 $LN11@s370_cpcmd
$LN12@s370_cpcmd:

; 1195 : 
; 1196 :         /* Update guest response register and set condition code */
; 1197 :         if (resplen <= maxrlen)

  00562	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  00566	39 44 24 58	 cmp	 DWORD PTR resplen$1[rsp], eax
  0056a	77 28		 ja	 SHORT $LN29@s370_cpcmd

; 1198 :         {
; 1199 :             /* They have the complete response */
; 1200 :             regs->GR_L( r2+1 ) = resplen;

  0056c	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00573	ff c0		 inc	 eax
  00575	48 98		 cdqe
  00577	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057f	8b 54 24 58	 mov	 edx, DWORD PTR resplen$1[rsp]
  00583	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1201 :             cc = 0;

  0058a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1202 :         }

  00592	eb 2f		 jmp	 SHORT $LN30@s370_cpcmd
$LN29@s370_cpcmd:

; 1203 :         else
; 1204 :         {
; 1205 :             /* Their response buffer is too small */
; 1206 :             regs->GR_L( r2+1 ) = (resplen - maxrlen);

  00594	8b 44 24 68	 mov	 eax, DWORD PTR maxrlen$[rsp]
  00598	8b 4c 24 58	 mov	 ecx, DWORD PTR resplen$1[rsp]
  0059c	2b c8		 sub	 ecx, eax
  0059e	8b c1		 mov	 eax, ecx
  005a0	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005a7	ff c1		 inc	 ecx
  005a9	48 63 c9	 movsxd	 rcx, ecx
  005ac	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1207 :             cc = 1;

  005bb	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN30@s370_cpcmd:

; 1208 :         }
; 1209 :     }

  005c3	eb 08		 jmp	 SHORT $LN27@s370_cpcmd
$LN26@s370_cpcmd:

; 1210 :     else
; 1211 :         cc = 0;

  005c5	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN27@s370_cpcmd:

; 1212 : 
; 1213 :     /* Set R2 register to CP completion code */
; 1214 :     regs->GR_L( r2 ) = 0;

  005cd	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005d5	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1215 : 
; 1216 :     /* Free memory malloc'ed by panel_command_capture */
; 1217 :     if (freeresp)

  005e8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR freeresp$[rsp], 0
  005f0	74 0b		 je	 SHORT $LN31@s370_cpcmd

; 1218 :         free( resp );

  005f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR resp$[rsp]
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN31@s370_cpcmd:

; 1219 : 
; 1220 :     /* Return condition code */
; 1221 :     return cc;

  005fd	8b 44 24 78	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@s370_cpcmd:
$LN32@s370_cpcmd:

; 1222 : 
; 1223 : } /* end function cpcmd_call */

  00601	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00609	48 33 cc	 xor	 rcx, rsp
  0060c	e8 00 00 00 00	 call	 __security_check_cookie
  00611	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  00618	c3		 ret	 0
s370_cpcmd_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
c$ = 48
idlen$ = 52
i$ = 56
tzdiff$ = 60
tv161 = 64
ver$ = 68
idaddr$ = 72
puser$ = 80
tv183 = 88
rel$ = 92
$T1 = 96
$T2 = 104
$T3 = 112
$T4 = 120
buf$ = 128
__$ArrayPad$ = 168
r1$ = 192
r2$ = 200
regs$ = 208
s370_extid_call PROC

; 936  : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 937  : int        i;                           /* Array subscript           */
; 938  : int        ver, rel;                    /* Version and release number*/
; 939  : int        tzdiff;                      /* Time zone differential    */
; 940  : U32        idaddr;                      /* Address of storage operand*/
; 941  : U32        idlen;                       /* Length of storage operand */
; 942  : BYTE       buf[40];                     /* Extended identification   */
; 943  : #if defined( HAVE_GETLOGIN_R )
; 944  :   #if !defined(LOGIN_NAME_MAX)
; 945  :     #define LOGIN_NAME_MAX 100
; 946  :   #endif
; 947  : char       unam[LOGIN_NAME_MAX+1];      /* User name                 */
; 948  : #endif
; 949  : char      *puser;                       /* Pointer to user name      */
; 950  : BYTE       c;                           /* Character work area       */
; 951  : 
; 952  :     /* Load storage operand address from R1 register */
; 953  :     idaddr = regs->GR_L(r1);

  00026	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0002e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003d	89 44 24 48	 mov	 DWORD PTR idaddr$[rsp], eax

; 954  : 
; 955  :     /* Program check if operand is not on a doubleword boundary */
; 956  :     if (idaddr & 0x00000007)

  00041	8b 44 24 48	 mov	 eax, DWORD PTR idaddr$[rsp]
  00045	83 e0 07	 and	 eax, 7
  00048	85 c0		 test	 eax, eax
  0004a	74 12		 je	 SHORT $LN5@s370_extid

; 957  :     {
; 958  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0004c	ba 06 00 00 00	 mov	 edx, 6
  00051	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 s370_program_interrupt
$LN5@s370_extid:

; 959  :     }
; 960  : 
; 961  :     /* Load storage operand length from R2 register */
; 962  :     idlen = regs->GR_L(r2);

  0005e	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00066	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00075	89 44 24 34	 mov	 DWORD PTR idlen$[rsp], eax

; 963  : 
; 964  :     /* Program check if operand length is invalid */
; 965  :     if (idlen < 1)

  00079	83 7c 24 34 01	 cmp	 DWORD PTR idlen$[rsp], 1
  0007e	73 12		 jae	 SHORT $LN6@s370_extid

; 966  :     {
; 967  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00080	ba 06 00 00 00	 mov	 edx, 6
  00085	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_extid:

; 968  :     }
; 969  : 
; 970  :     /* Bytes 0-7 contain the system name ("HERCULES" in EBCDIC) */
; 971  :     get_lparname(buf);

  00092	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0009a	e8 00 00 00 00	 call	 get_lparname

; 972  : 
; 973  :     /* Bytes 8-9 contain the execution environment bits */
; 974  :     buf[8] = 0x00;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 08	 imul	 rax, rax, 8
  000a8	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  000ad	48 83 7c 24 60
	28		 cmp	 QWORD PTR $T1[rsp], 40	; 00000028H
  000b3	73 02		 jae	 SHORT $LN9@s370_extid
  000b5	eb 05		 jmp	 SHORT $LN10@s370_extid
$LN9@s370_extid:
  000b7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@s370_extid:
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000c1	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 975  :     buf[9] = 0x00;

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	48 6b c0 09	 imul	 rax, rax, 9
  000d2	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  000d7	48 83 7c 24 68
	28		 cmp	 QWORD PTR $T2[rsp], 40	; 00000028H
  000dd	73 02		 jae	 SHORT $LN11@s370_extid
  000df	eb 05		 jmp	 SHORT $LN12@s370_extid
$LN11@s370_extid:
  000e1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@s370_extid:
  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  000eb	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 976  : 
; 977  :     /* Byte 10 contains the system product version number */
; 978  :     sscanf (QSTR(VERSION), "%d.%d", &ver, &rel);

  000f3	4c 8d 4c 24 5c	 lea	 r9, QWORD PTR rel$[rsp]
  000f8	4c 8d 44 24 44	 lea	 r8, QWORD PTR ver$[rsp]
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169948
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169949
  0010b	e8 00 00 00 00	 call	 sscanf

; 979  :     buf[10] = ver & 0xff;

  00110	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  00114	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 0a	 imul	 rcx, rcx, 10
  00122	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 980  : 
; 981  :     /* Byte 11 contains version number from STIDP */
; 982  :     buf[11] = regs->cpuversion;

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 0b	 imul	 rax, rax, 11
  00132	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	0f b6 49 3e	 movzx	 ecx, BYTE PTR [rcx+62]
  0013e	88 8c 04 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl

; 983  : 
; 984  :     /* Bytes 12-13 contain MCEL length from STIDP */
; 985  :     buf[12] = (regs->cpuid >> 8) & 0xFF;

  00145	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00151	48 c1 e8 08	 shr	 rax, 8
  00155	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0015b	b9 01 00 00 00	 mov	 ecx, 1
  00160	48 6b c9 0c	 imul	 rcx, rcx, 12
  00164	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 986  :     buf[13] = regs->cpuid & 0xFF;

  0016b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00177	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 0d	 imul	 rcx, rcx, 13
  00186	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 987  : 
; 988  :     /* Bytes 14-15 contain the CP address */
; 989  :     buf[14] = (regs->cpuad >> 8) & 0xFF;

  0018d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0019c	c1 f8 08	 sar	 eax, 8
  0019f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001a4	b9 01 00 00 00	 mov	 ecx, 1
  001a9	48 6b c9 0e	 imul	 rcx, rcx, 14
  001ad	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 990  :     buf[15] = regs->cpuad & 0xFF;

  001b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	48 6b c9 0f	 imul	 rcx, rcx, 15
  001d1	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 991  : 
; 992  :     /* Bytes 16-23 contain the userid in EBCDIC */
; 993  : #if defined( HAVE_GETLOGIN_R )
; 994  :     memset( unam, 0, sizeof(unam) );
; 995  :     VERIFY( getlogin_r ( unam, sizeof(unam) ) == 0 );
; 996  :     puser = unam;
; 997  : #else
; 998  :     puser = "";

  001d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169950
  001df	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax

; 999  : #endif
; 1000 :     for (i = 0; i < 8; i++)

  001e4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ec	eb 0a		 jmp	 SHORT $LN4@s370_extid
$LN2@s370_extid:
  001ee	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  001f2	ff c0		 inc	 eax
  001f4	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_extid:
  001f8	83 7c 24 38 08	 cmp	 DWORD PTR i$[rsp], 8
  001fd	7d 61		 jge	 SHORT $LN3@s370_extid

; 1001 :     {
; 1002 :         c = (*puser == '\0' ? SPACE : *(puser++));

  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00204	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00207	85 c0		 test	 eax, eax
  00209	75 0a		 jne	 SHORT $LN13@s370_extid
  0020b	c7 44 24 40 20
	00 00 00	 mov	 DWORD PTR tv161[rsp], 32 ; 00000020H
  00213	eb 19		 jmp	 SHORT $LN14@s370_extid
$LN13@s370_extid:
  00215	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  0021a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0021d	89 44 24 40	 mov	 DWORD PTR tv161[rsp], eax
  00221	48 8b 44 24 50	 mov	 rax, QWORD PTR puser$[rsp]
  00226	48 ff c0	 inc	 rax
  00229	48 89 44 24 50	 mov	 QWORD PTR puser$[rsp], rax
$LN14@s370_extid:
  0022e	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv161[rsp]
  00233	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 1003 :         buf[16+i] = host_to_guest(toupper(c));

  00237	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0023c	8b c8		 mov	 ecx, eax
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00244	0f b6 c8	 movzx	 ecx, al
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0024d	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00251	83 c1 10	 add	 ecx, 16
  00254	48 63 c9	 movsxd	 rcx, ecx
  00257	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1004 :     }

  0025e	eb 8e		 jmp	 SHORT $LN2@s370_extid
$LN3@s370_extid:

; 1005 : 
; 1006 :     /* Bytes 24-31 contain the program product bitmap */
; 1007 :     memcpy (buf+24, "\x7F\xFE\x00\x00\x00\x00\x00\x00", 8);

  00260	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR $SG169951
  00267	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR buf$[rsp+24], rax

; 1008 : 
; 1009 :     /* Bytes 32-35 contain the time zone differential */
; 1010 :     tzdiff = query_tzoffset();   /* returns +/-HHMM as an integer */

  0026f	e8 00 00 00 00	 call	 query_tzoffset
  00274	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1011 :     tzdiff = ((tzdiff/100)*3600)+((tzdiff%100)*60);

  00278	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  0027c	99		 cdq
  0027d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00282	f7 f9		 idiv	 ecx
  00284	69 c0 10 0e 00
	00		 imul	 eax, eax, 3600		; 00000e10H
  0028a	89 44 24 58	 mov	 DWORD PTR tv183[rsp], eax
  0028e	8b 44 24 3c	 mov	 eax, DWORD PTR tzdiff$[rsp]
  00292	99		 cdq
  00293	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00298	f7 f9		 idiv	 ecx
  0029a	8b c2		 mov	 eax, edx
  0029c	6b c0 3c	 imul	 eax, eax, 60		; 0000003cH
  0029f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv183[rsp]
  002a3	03 c8		 add	 ecx, eax
  002a5	8b c1		 mov	 eax, ecx
  002a7	89 44 24 3c	 mov	 DWORD PTR tzdiff$[rsp], eax

; 1012 :     STORE_FW(buf+32,tzdiff);

  002ab	8b 4c 24 3c	 mov	 ecx, DWORD PTR tzdiff$[rsp]
  002af	e8 00 00 00 00	 call	 _byteswap_ulong
  002b4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+32]
  002bc	8b d0		 mov	 edx, eax
  002be	e8 00 00 00 00	 call	 store_fw_noswap

; 1013 : 
; 1014 :     /* Bytes 36-39 contain version, level, and service level */
; 1015 :     buf[36] = ver & 0xff;

  002c3	8b 44 24 44	 mov	 eax, DWORD PTR ver$[rsp]
  002c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002cc	b9 01 00 00 00	 mov	 ecx, 1
  002d1	48 6b c9 24	 imul	 rcx, rcx, 36		; 00000024H
  002d5	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1016 :     buf[37] = rel & 0xff;

  002dc	8b 44 24 5c	 mov	 eax, DWORD PTR rel$[rsp]
  002e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	48 6b c9 25	 imul	 rcx, rcx, 37		; 00000025H
  002ee	88 84 0c 80 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al

; 1017 :     buf[38] = 0x00;

  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 26	 imul	 rax, rax, 38		; 00000026H
  002fe	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00303	48 83 7c 24 70
	28		 cmp	 QWORD PTR $T3[rsp], 40	; 00000028H
  00309	73 02		 jae	 SHORT $LN15@s370_extid
  0030b	eb 05		 jmp	 SHORT $LN16@s370_extid
$LN15@s370_extid:
  0030d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@s370_extid:
  00312	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  00317	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1018 :     buf[39] = 0x00;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  00328	48 89 44 24 78	 mov	 QWORD PTR $T4[rsp], rax
  0032d	48 83 7c 24 78
	28		 cmp	 QWORD PTR $T4[rsp], 40	; 00000028H
  00333	73 02		 jae	 SHORT $LN17@s370_extid
  00335	eb 05		 jmp	 SHORT $LN18@s370_extid
$LN17@s370_extid:
  00337	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN18@s370_extid:
  0033c	48 8b 44 24 78	 mov	 rax, QWORD PTR $T4[rsp]
  00341	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 1019 : 
; 1020 : #if 0 // debug
; 1021 :     LOGMSG( "Diagnose X'000':"
; 1022 : 
; 1023 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1024 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1025 : 
; 1026 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1027 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n\t\t"
; 1028 : 
; 1029 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X\n"
; 1030 : 
; 1031 :             , buf[ 0], buf[ 1], buf[ 2], buf[ 3], buf[ 4], buf[ 5], buf[ 6], buf[ 7]
; 1032 :             , buf[ 8], buf[ 9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]
; 1033 : 
; 1034 :             , buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]
; 1035 :             , buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]
; 1036 : 
; 1037 :             , buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]
; 1038 :         );
; 1039 : #endif
; 1040 : 
; 1041 :     /* Enforce maximum length to store */
; 1042 :     if (idlen > sizeof(buf))

  00349	8b 44 24 34	 mov	 eax, DWORD PTR idlen$[rsp]
  0034d	48 83 f8 28	 cmp	 rax, 40			; 00000028H
  00351	76 08		 jbe	 SHORT $LN7@s370_extid

; 1043 :         idlen = sizeof(buf);

  00353	c7 44 24 34 28
	00 00 00	 mov	 DWORD PTR idlen$[rsp], 40 ; 00000028H
$LN7@s370_extid:

; 1044 : 
; 1045 :     /* Store the extended identification code at operand address */
; 1046 :     ARCH_DEP(vstorec) (buf, idlen-1, idaddr, USE_REAL_ADDR, regs);

  0035b	8b 44 24 34	 mov	 eax, DWORD PTR idlen$[rsp]
  0035f	ff c8		 dec	 eax
  00361	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0036e	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00374	44 8b 44 24 48	 mov	 r8d, DWORD PTR idaddr$[rsp]
  00379	0f b6 d0	 movzx	 edx, al
  0037c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00384	e8 00 00 00 00	 call	 s370_vstorec

; 1047 : 
; 1048 :     /* Deduct number of bytes from the R2 register */
; 1049 :     regs->GR_L(r2) -= idlen;

  00389	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00391	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	8b 54 24 34	 mov	 edx, DWORD PTR idlen$[rsp]
  0039d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a4	2b c2		 sub	 eax, edx
  003a6	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003ae	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003b6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN8@s370_extid:

; 1050 : 
; 1051 : } /* end function extid_call */

  003bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c5	48 33 cc	 xor	 rcx, rsp
  003c8	e8 00 00 00 00	 call	 __security_check_cookie
  003cd	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003d4	c3		 ret	 0
s370_extid_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
accum$ = 48
unitstat$ = 49
i$ = 52
dev$ = 56
chanstat$ = 64
residual$ = 68
numsense$ = 72
lastccw$ = 76
iopaddr$ = 80
devnum$ = 84
ccwaddr$ = 88
tv169 = 92
ioparm$ = 96
__$ArrayPad$ = 192
r1$ = 240
r2$ = 248
regs$ = 256
s370_syncgen_io PROC

; 749  : {

$LN36:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 750  : U32             i;                      /* Array subscript           */
; 751  : U32             numsense;               /* Number of sense bytes     */
; 752  : U32             iopaddr;                /* Address of HCPSGIOP       */
; 753  : HCPSGIOP        ioparm;                 /* I/O parameter list        */
; 754  : DEVBLK         *dev;                    /* -> Device block           */
; 755  : U16             devnum;                 /* Device number             */
; 756  : U16             residual;               /* Residual byte count       */
; 757  : U32             ccwaddr;                /* Address of channel program*/
; 758  : U32             lastccw;                /* CCW address at interrupt  */
; 759  : BYTE            accum;                  /* Work area                 */
; 760  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 31 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 761  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 40 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@s370_syncg:

; 762  : 
; 763  : //FIXME: code not right for shared devices
; 764  : 
; 765  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@s370_syncg

; 766  : 
; 767  :     /* Register R1 contains the real address of the parameter list */
; 768  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 44 24 50	 mov	 DWORD PTR iopaddr$[rsp], eax

; 769  : 
; 770  :     /* Program check if parameter list not on fullword boundary */
; 771  :     if (iopaddr & 0x00000003)

  00053	8b 44 24 50	 mov	 eax, DWORD PTR iopaddr$[rsp]
  00057	83 e0 03	 and	 eax, 3
  0005a	85 c0		 test	 eax, eax
  0005c	74 12		 je	 SHORT $LN17@s370_syncg

; 772  :     {
; 773  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0005e	ba 06 00 00 00	 mov	 edx, 6
  00063	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN17@s370_syncg:

; 774  :     }
; 775  : 
; 776  :     /* Ensure that parameter list operand is addressable */
; 777  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00070	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	41 b9 02 00 00
	00		 mov	 r9d, 2
  00083	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  00089	ba fe ff ff ff	 mov	 edx, -2
  0008e	8b 4c 24 50	 mov	 ecx, DWORD PTR iopaddr$[rsp]
  00092	e8 00 00 00 00	 call	 s370_validate_operand

; 778  :                         ACCTYPE_WRITE, regs);
; 779  : 
; 780  :     /* Fetch the parameter list from real storage */
; 781  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00097	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000aa	44 8b 44 24 50	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  000af	b2 57		 mov	 dl, 87			; 00000057H
  000b1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000b6	e8 00 00 00 00	 call	 s370_vfetchc

; 782  : 
; 783  :     /* Load numeric fields from the parameter list */
; 784  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 00	 imul	 rax, rax, 0
  000c4	0f b6 44 04 60	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000c9	c1 e0 08	 shl	 eax, 8
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	48 6b c9 01	 imul	 rcx, rcx, 1
  000d5	0f b6 4c 0c 60	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000da	0b c1		 or	 eax, ecx
  000dc	66 89 44 24 54	 mov	 WORD PTR devnum$[rsp], ax

; 785  :     ccwaddr = (ioparm.ccwaddr[0] << 24)

  000e1	b8 01 00 00 00	 mov	 eax, 1
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	0f b6 44 04 68	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  000ef	c1 e0 18	 shl	 eax, 24
  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	48 6b c9 01	 imul	 rcx, rcx, 1
  000fb	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00100	c1 e1 10	 shl	 ecx, 16
  00103	0b c1		 or	 eax, ecx
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 02	 imul	 rcx, rcx, 2
  0010e	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00113	c1 e1 08	 shl	 ecx, 8
  00116	0b c1		 or	 eax, ecx
  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	48 6b c9 03	 imul	 rcx, rcx, 3
  00121	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00126	0b c1		 or	 eax, ecx
  00128	89 44 24 58	 mov	 DWORD PTR ccwaddr$[rsp], eax

; 786  :                 | (ioparm.ccwaddr[1] << 16)
; 787  :                 | (ioparm.ccwaddr[2] << 8)
; 788  :                 | ioparm.ccwaddr[3];
; 789  : 
; 790  :     /* Locate the device block */
; 791  :     dev = find_device_by_devnum (0,devnum);

  0012c	0f b7 54 24 54	 movzx	 edx, WORD PTR devnum$[rsp]
  00131	33 c9		 xor	 ecx, ecx
  00133	e8 00 00 00 00	 call	 find_device_by_devnum
  00138	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 792  : 
; 793  :     /* Set return code 1 and cond code 1 if device does not exist */
; 794  :     if (dev == NULL)

  0013d	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00143	75 26		 jne	 SHORT $LN18@s370_syncg

; 795  :     {
; 796  :         regs->GR_L(15) = 1;

  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 0f	 imul	 rax, rax, 15
  0014e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	c7 84 01 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 1

; 797  :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 b8 05 00 00	 jmp	 $LN1@s370_syncg
$LN18@s370_syncg:

; 798  :     }
; 799  : 
; 800  :     /* Program check if protect key bits 4-7 are not zero
; 801  :        or if the reserved bits in the flag byte are not zero */
; 802  :     if ((ioparm.akey & 0x0F) || (ioparm.flag & HCPSGIOP_FLAG_RESV))

  0016b	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00170	83 e0 0f	 and	 eax, 15
  00173	85 c0		 test	 eax, eax
  00175	75 0c		 jne	 SHORT $LN20@s370_syncg
  00177	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0017c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0017f	85 c0		 test	 eax, eax
  00181	74 12		 je	 SHORT $LN19@s370_syncg
$LN20@s370_syncg:

; 803  :     {
; 804  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00183	ba 15 00 00 00	 mov	 edx, 21
  00188	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00190	e8 00 00 00 00	 call	 s370_program_interrupt
$LN19@s370_syncg:

; 805  :     }
; 806  : 
; 807  : #ifdef FEATURE_S370_CHANNEL
; 808  :     /* Program check if flag byte specifies format-1 CCW */
; 809  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)

  00195	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0019a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0019f	85 c0		 test	 eax, eax
  001a1	74 12		 je	 SHORT $LN21@s370_syncg

; 810  :     {
; 811  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001a3	ba 15 00 00 00	 mov	 edx, 21
  001a8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	e8 00 00 00 00	 call	 s370_program_interrupt
$LN21@s370_syncg:

; 812  :     }
; 813  : #endif /*FEATURE_S370_CHANNEL*/
; 814  : 
; 815  :     /* Program check if CCW is not on a doubleword boundary,
; 816  :        or if CCW address exceeds maximum according to CCW format */
; 817  :     if ((ccwaddr & 0x00000007) || ccwaddr >

  001b5	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  001b9	83 e0 07	 and	 eax, 7
  001bc	85 c0		 test	 eax, eax
  001be	75 2a		 jne	 SHORT $LN23@s370_syncg
  001c0	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  001c5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ca	85 c0		 test	 eax, eax
  001cc	74 0a		 je	 SHORT $LN34@s370_syncg
  001ce	c7 44 24 5c ff
	ff ff 7f	 mov	 DWORD PTR tv169[rsp], 2147483647 ; 7fffffffH
  001d6	eb 08		 jmp	 SHORT $LN35@s370_syncg
$LN34@s370_syncg:
  001d8	c7 44 24 5c ff
	ff ff 00	 mov	 DWORD PTR tv169[rsp], 16777215 ; 00ffffffH
$LN35@s370_syncg:
  001e0	8b 44 24 5c	 mov	 eax, DWORD PTR tv169[rsp]
  001e4	39 44 24 58	 cmp	 DWORD PTR ccwaddr$[rsp], eax
  001e8	76 12		 jbe	 SHORT $LN22@s370_syncg
$LN23@s370_syncg:

; 818  :            ((ioparm.flag & HCPSGIOP_FORMAT1_CCW) ?
; 819  :                         (U32)0x7FFFFFFF : (U32)0x00FFFFFF))
; 820  :     {
; 821  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001ea	ba 15 00 00 00	 mov	 edx, 21
  001ef	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f7	e8 00 00 00 00	 call	 s370_program_interrupt
$LN22@s370_syncg:

; 822  :     }
; 823  : 
; 824  :     /* Program check if reserved fields are not zero */
; 825  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  001fc	c6 44 24 30 00	 mov	 BYTE PTR accum$[rsp], 0
  00201	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00209	eb 0a		 jmp	 SHORT $LN7@s370_syncg
$LN5@s370_syncg:
  0020b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0020f	ff c0		 inc	 eax
  00211	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_syncg:
  00215	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00219	48 83 f8 04	 cmp	 rax, 4
  0021d	73 18		 jae	 SHORT $LN6@s370_syncg

; 826  :         accum |= ioparm.resv1[i];

  0021f	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00223	0f b6 44 04 64	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  00228	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  0022d	0b c8		 or	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  00235	eb d4		 jmp	 SHORT $LN5@s370_syncg
$LN6@s370_syncg:

; 827  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  00237	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0023f	eb 0a		 jmp	 SHORT $LN10@s370_syncg
$LN8@s370_syncg:
  00241	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00245	ff c0		 inc	 eax
  00247	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_syncg:
  0024b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0024f	48 83 f8 04	 cmp	 rax, 4
  00253	73 18		 jae	 SHORT $LN9@s370_syncg

; 828  :         accum |= ioparm.resv2[i];

  00255	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00259	0f b6 44 04 6c	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  0025e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00263	0b c8		 or	 ecx, eax
  00265	8b c1		 mov	 eax, ecx
  00267	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  0026b	eb d4		 jmp	 SHORT $LN8@s370_syncg
$LN9@s370_syncg:

; 829  :     for (i = 0; i < sizeof(ioparm.resv3); i++)

  0026d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00275	eb 0a		 jmp	 SHORT $LN13@s370_syncg
$LN11@s370_syncg:
  00277	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0027b	ff c0		 inc	 eax
  0027d	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_syncg:
  00281	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00285	48 83 f8 05	 cmp	 rax, 5
  00289	73 18		 jae	 SHORT $LN12@s370_syncg

; 830  :         accum |= ioparm.resv3[i];

  0028b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0028f	0f b6 44 04 79	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  00294	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  00299	0b c8		 or	 ecx, eax
  0029b	8b c1		 mov	 eax, ecx
  0029d	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  002a1	eb d4		 jmp	 SHORT $LN11@s370_syncg
$LN12@s370_syncg:

; 831  :     for (i = 0; i < sizeof(ioparm.resv4); i++)

  002a3	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002ab	eb 0a		 jmp	 SHORT $LN16@s370_syncg
$LN14@s370_syncg:
  002ad	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002b1	ff c0		 inc	 eax
  002b3	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN16@s370_syncg:
  002b7	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002bb	48 83 f8 18	 cmp	 rax, 24
  002bf	73 1b		 jae	 SHORT $LN15@s370_syncg

; 832  :         accum |= ioparm.resv4[i];

  002c1	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002c5	0f b6 84 04 80
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  002cd	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR accum$[rsp]
  002d2	0b c8		 or	 ecx, eax
  002d4	8b c1		 mov	 eax, ecx
  002d6	88 44 24 30	 mov	 BYTE PTR accum$[rsp], al
  002da	eb d1		 jmp	 SHORT $LN14@s370_syncg
$LN15@s370_syncg:

; 833  :     if (accum != 0)

  002dc	0f b6 44 24 30	 movzx	 eax, BYTE PTR accum$[rsp]
  002e1	85 c0		 test	 eax, eax
  002e3	74 12		 je	 SHORT $LN24@s370_syncg

; 834  :     {
; 835  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002e5	ba 15 00 00 00	 mov	 edx, 21
  002ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	e8 00 00 00 00	 call	 s370_program_interrupt
$LN24@s370_syncg:

; 836  :     }
; 837  : 
; 838  :     /* Obtain the interrupt lock */
; 839  :     obtain_lock (&dev->lock);

  002f7	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002fc	48 83 c0 38	 add	 rax, 56			; 00000038H
  00300	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169910
  00307	48 8b c8	 mov	 rcx, rax
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 840  : 
; 841  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 842  :     /* Return code 5 and condition code 1 if status pending */
; 843  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 844  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))
; 845  :     {
; 846  :         release_lock (&dev->lock);
; 847  :         regs->GR_L(15) = 5;
; 848  :         return 1;
; 849  :     }
; 850  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 851  : 
; 852  :     /* Return code 5 and condition code 1 if device is busy */
; 853  :     if (dev->busy || IOPENDING(dev))

  00310	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00315	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0031b	c1 e8 13	 shr	 eax, 19
  0031e	83 e0 01	 and	 eax, 1
  00321	85 c0		 test	 eax, eax
  00323	75 54		 jne	 SHORT $LN26@s370_syncg
  00325	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0032a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00330	c1 e8 16	 shr	 eax, 22
  00333	83 e0 01	 and	 eax, 1
  00336	85 c0		 test	 eax, eax
  00338	75 3f		 jne	 SHORT $LN27@s370_syncg
  0033a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0033f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00345	c1 e8 17	 shr	 eax, 23
  00348	83 e0 01	 and	 eax, 1
  0034b	85 c0		 test	 eax, eax
  0034d	75 2a		 jne	 SHORT $LN27@s370_syncg
  0034f	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00354	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0035a	c1 e8 18	 shr	 eax, 24
  0035d	83 e0 01	 and	 eax, 1
  00360	85 c0		 test	 eax, eax
  00362	75 15		 jne	 SHORT $LN27@s370_syncg
  00364	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00369	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0036f	c1 e8 1b	 shr	 eax, 27
  00372	83 e0 01	 and	 eax, 1
  00375	85 c0		 test	 eax, eax
  00377	74 3f		 je	 SHORT $LN25@s370_syncg
$LN27@s370_syncg:
$LN26@s370_syncg:

; 854  :     {
; 855  :         release_lock (&dev->lock);

  00379	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0037e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169914
  00389	48 8b c8	 mov	 rcx, rax
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 856  :         regs->GR_L(15) = 5;

  00392	b8 08 00 00 00	 mov	 eax, 8
  00397	48 6b c0 0f	 imul	 rax, rax, 15
  0039b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 857  :         return 1;

  003ae	b8 01 00 00 00	 mov	 eax, 1
  003b3	e9 6b 03 00 00	 jmp	 $LN1@s370_syncg
$LN25@s370_syncg:

; 858  :     }
; 859  : 
; 860  :     /* Set the device busy indicator */
; 861  :     dev->busy = 1;

  003b8	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003bd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003c3	0f ba e8 13	 bts	 eax, 19
  003c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  003cc	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 862  : 
; 863  :     /* Release the device lock */
; 864  :     release_lock (&dev->lock);

  003d2	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003d7	48 83 c0 38	 add	 rax, 56			; 00000038H
  003db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169915
  003e2	48 8b c8	 mov	 rcx, rax
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 865  : 
; 866  :     /* Build the operation request block */
; 867  :     memset (&dev->orb, 0, sizeof(ORB));

  003eb	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003f0	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  003f6	48 8b f8	 mov	 rdi, rax
  003f9	33 c0		 xor	 eax, eax
  003fb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00400	f3 aa		 rep stosb

; 868  :     STORE_FW(dev->orb.ccwaddr, ccwaddr);

  00402	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  00406	e8 00 00 00 00	 call	 _byteswap_ulong
  0040b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00410	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  00417	8b d0		 mov	 edx, eax
  00419	e8 00 00 00 00	 call	 store_fw_noswap

; 869  :     dev->orb.flag4 = ioparm.akey & ORB4_KEY;

  0041e	0f b6 44 24 62	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00423	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00428	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0042d	88 81 d0 02 00
	00		 mov	 BYTE PTR [rcx+720], al

; 870  :     if (ioparm.flag & HCPSGIOP_FORMAT1_CCW)

  00433	0f b6 44 24 63	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00438	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0043d	85 c0		 test	 eax, eax
  0043f	74 1b		 je	 SHORT $LN28@s370_syncg

; 871  :         dev->orb.flag5 |= ORB5_F;

  00441	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00446	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0044d	0f ba e8 07	 bts	 eax, 7
  00451	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00456	88 81 d1 02 00
	00		 mov	 BYTE PTR [rcx+721], al
$LN28@s370_syncg:

; 872  : 
; 873  :     /* Execute the channel program synchronously */
; 874  :     ARCH_DEP(execute_ccw_chain) (dev);

  0045c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00461	e8 00 00 00 00	 call	 s370_execute_ccw_chain

; 875  : 
; 876  :     /* Obtain status, CCW address, and residual byte count */
; 877  :     lastccw = (dev->scsw.ccwaddr[0] << 24)

  00466	b8 01 00 00 00	 mov	 eax, 1
  0046b	48 6b c0 00	 imul	 rax, rax, 0
  0046f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00474	0f b6 84 01 0c
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+780]
  0047c	c1 e0 18	 shl	 eax, 24
  0047f	b9 01 00 00 00	 mov	 ecx, 1
  00484	48 6b c9 01	 imul	 rcx, rcx, 1
  00488	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  0048d	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  00495	c1 e1 10	 shl	 ecx, 16
  00498	0b c1		 or	 eax, ecx
  0049a	b9 01 00 00 00	 mov	 ecx, 1
  0049f	48 6b c9 02	 imul	 rcx, rcx, 2
  004a3	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004a8	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004b0	c1 e1 08	 shl	 ecx, 8
  004b3	0b c1		 or	 eax, ecx
  004b5	b9 01 00 00 00	 mov	 ecx, 1
  004ba	48 6b c9 03	 imul	 rcx, rcx, 3
  004be	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  004c3	0f b6 8c 0a 0c
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+780]
  004cb	0b c1		 or	 eax, ecx
  004cd	89 44 24 4c	 mov	 DWORD PTR lastccw$[rsp], eax

; 878  :                 | (dev->scsw.ccwaddr[1] << 16)
; 879  :                 | (dev->scsw.ccwaddr[2] << 8)
; 880  :                 | dev->scsw.ccwaddr[3];
; 881  :     unitstat = dev->scsw.unitstat;

  004d1	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  004d6	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  004dd	88 44 24 31	 mov	 BYTE PTR unitstat$[rsp], al

; 882  :     chanstat = dev->scsw.chanstat;

  004e1	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  004e6	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  004ed	88 44 24 40	 mov	 BYTE PTR chanstat$[rsp], al

; 883  :     residual = (dev->scsw.count[0] << 8) | dev->scsw.count[1];

  004f1	b8 01 00 00 00	 mov	 eax, 1
  004f6	48 6b c0 00	 imul	 rax, rax, 0
  004fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  004ff	0f b6 84 01 12
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+786]
  00507	c1 e0 08	 shl	 eax, 8
  0050a	b9 01 00 00 00	 mov	 ecx, 1
  0050f	48 6b c9 01	 imul	 rcx, rcx, 1
  00513	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  00518	0f b6 8c 0a 12
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+786]
  00520	0b c1		 or	 eax, ecx
  00522	66 89 44 24 44	 mov	 WORD PTR residual$[rsp], ax

; 884  : 
; 885  :     /* Clear the interrupt pending and device busy conditions */
; 886  :     obtain_lock (&dev->lock);

  00527	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0052c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169917
  00537	48 8b c8	 mov	 rcx, rax
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 887  :     dev->busy = dev->pending = 0;

  00540	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00545	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0054b	0f ba f0 16	 btr	 eax, 22
  0054f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00554	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  0055a	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0055f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00565	0f ba f0 13	 btr	 eax, 19
  00569	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0056e	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 888  :     dev->scsw.flag2 = 0;

  00574	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00579	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 889  :     dev->scsw.flag3 = 0;

  00580	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00585	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 890  :     release_lock (&dev->lock);

  0058c	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00591	48 83 c0 38	 add	 rax, 56			; 00000038H
  00595	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169918
  0059c	48 8b c8	 mov	 rcx, rax
  0059f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 891  : 
; 892  :     /* Store the last CCW address in the parameter list */
; 893  :     ioparm.lastccw[0] = (lastccw >> 24) & 0xFF;

  005a5	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005a9	c1 e8 18	 shr	 eax, 24
  005ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005b1	b9 01 00 00 00	 mov	 ecx, 1
  005b6	48 6b c9 00	 imul	 rcx, rcx, 0
  005ba	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 894  :     ioparm.lastccw[1] = (lastccw >> 16) & 0xFF;

  005be	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005c2	c1 e8 10	 shr	 eax, 16
  005c5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005ca	b9 01 00 00 00	 mov	 ecx, 1
  005cf	48 6b c9 01	 imul	 rcx, rcx, 1
  005d3	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 895  :     ioparm.lastccw[2] = (lastccw >> 8) & 0xFF;

  005d7	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005db	c1 e8 08	 shr	 eax, 8
  005de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005e3	b9 01 00 00 00	 mov	 ecx, 1
  005e8	48 6b c9 02	 imul	 rcx, rcx, 2
  005ec	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 896  :     ioparm.lastccw[3] = lastccw & 0xFF;

  005f0	8b 44 24 4c	 mov	 eax, DWORD PTR lastccw$[rsp]
  005f4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005f9	b9 01 00 00 00	 mov	 ecx, 1
  005fe	48 6b c9 03	 imul	 rcx, rcx, 3
  00602	88 44 0c 70	 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 897  : 
; 898  :     /* Store the device and subchannel status in the parameter list */
; 899  :     ioparm.unitstat = unitstat;

  00606	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0060b	88 44 24 74	 mov	 BYTE PTR ioparm$[rsp+20], al

; 900  :     ioparm.chanstat = chanstat;

  0060f	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00614	88 44 24 75	 mov	 BYTE PTR ioparm$[rsp+21], al

; 901  : 
; 902  :     /* Store the residual byte count in the parameter list */
; 903  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  00618	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  0061d	c1 f8 08	 sar	 eax, 8
  00620	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00625	b9 01 00 00 00	 mov	 ecx, 1
  0062a	48 6b c9 00	 imul	 rcx, rcx, 0
  0062e	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 904  :     ioparm.residual[1] = residual & 0xFF;

  00632	0f b7 44 24 44	 movzx	 eax, WORD PTR residual$[rsp]
  00637	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0063c	b9 01 00 00 00	 mov	 ecx, 1
  00641	48 6b c9 01	 imul	 rcx, rcx, 1
  00645	88 44 0c 76	 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 905  : 
; 906  :     /* Return sense data if unit check occurred */
; 907  :     if (unitstat & CSW_UC)

  00649	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0064e	83 e0 02	 and	 eax, 2
  00651	85 c0		 test	 eax, eax
  00653	74 72		 je	 SHORT $LN29@s370_syncg

; 908  :     {
; 909  :         numsense = dev->numsense;

  00655	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0065a	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00660	89 44 24 48	 mov	 DWORD PTR numsense$[rsp], eax

; 910  :         if (numsense > sizeof(ioparm.sense))

  00664	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  00668	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  0066c	76 08		 jbe	 SHORT $LN30@s370_syncg

; 911  :             numsense = sizeof(ioparm.sense);

  0066e	c7 44 24 48 20
	00 00 00	 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN30@s370_syncg:

; 912  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  00676	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  0067a	c1 e8 08	 shr	 eax, 8
  0067d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00682	b9 01 00 00 00	 mov	 ecx, 1
  00687	48 6b c9 00	 imul	 rcx, rcx, 0
  0068b	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 913  :         ioparm.sensecount[1] = numsense & 0xFF;

  0068f	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  00693	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00698	b9 01 00 00 00	 mov	 ecx, 1
  0069d	48 6b c9 01	 imul	 rcx, rcx, 1
  006a1	88 44 0c 7e	 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 914  :         memcpy (ioparm.sense, dev->sense, numsense);

  006a5	8b 44 24 48	 mov	 eax, DWORD PTR numsense$[rsp]
  006a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  006ae	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  006b5	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  006bd	48 8b fa	 mov	 rdi, rdx
  006c0	48 8b f1	 mov	 rsi, rcx
  006c3	8b c8		 mov	 ecx, eax
  006c5	f3 a4		 rep movsb
$LN29@s370_syncg:

; 915  :     }
; 916  : 
; 917  :     /* Store the updated parameter list in real storage */
; 918  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  006c7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006d4	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  006da	44 8b 44 24 50	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  006df	b2 57		 mov	 dl, 87			; 00000057H
  006e1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR ioparm$[rsp]
  006e6	e8 00 00 00 00	 call	 s370_vstorec

; 919  : 
; 920  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 921  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  006eb	0f b6 44 24 31	 movzx	 eax, BYTE PTR unitstat$[rsp]
  006f0	83 f8 0c	 cmp	 eax, 12
  006f3	75 09		 jne	 SHORT $LN32@s370_syncg
  006f5	0f b6 44 24 40	 movzx	 eax, BYTE PTR chanstat$[rsp]
  006fa	85 c0		 test	 eax, eax
  006fc	74 23		 je	 SHORT $LN31@s370_syncg
$LN32@s370_syncg:

; 922  :     {
; 923  :         regs->GR_L(15) = 13;

  006fe	b8 08 00 00 00	 mov	 eax, 8
  00703	48 6b c0 0f	 imul	 rax, rax, 15
  00707	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070f	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 924  :         return 3;

  0071a	b8 03 00 00 00	 mov	 eax, 3
  0071f	eb 02		 jmp	 SHORT $LN1@s370_syncg
$LN31@s370_syncg:

; 925  :     }
; 926  : 
; 927  :     /* Return with condition code 0 and register 15 unchanged */
; 928  :     return 0;

  00721	33 c0		 xor	 eax, eax
$LN1@s370_syncg:

; 929  : 
; 930  : } /* end function syncgen_io */

  00723	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0072b	48 33 cc	 xor	 rcx, rsp
  0072e	e8 00 00 00 00	 call	 __security_check_cookie
  00733	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0073a	5f		 pop	 rdi
  0073b	5e		 pop	 rsi
  0073c	c3		 ret	 0
s370_syncgen_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
chanstat$ = 112
accum$ = 113
unitstat$ = 114
skey1$ = 115
skey2$ = 116
dev$ = 120
i$ = 128
blksize$ = 132
sbiaddr$ = 136
blkcount$ = 140
absadr$ = 144
numsense$ = 148
iopaddr$ = 152
devnum$ = 156
sbicount$ = 160
residual$ = 164
tv324 = 168
tv330 = 172
blknum$ = 176
tv319 = 184
ioparm$ = 192
__$ArrayPad$ = 288
r1$ = 336
r2$ = 344
regs$ = 352
s370_syncblk_io PROC

; 491  : {

$LN49:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 492  : U32             i;                      /* Array subscript           */
; 493  : U32             numsense;               /* Number of sense bytes     */
; 494  : U32             iopaddr;                /* Address of HCPSBIOP       */
; 495  : HCPSBIOP        ioparm;                 /* I/O parameter list        */
; 496  : DEVBLK         *dev;                    /* -> Device block           */
; 497  : U16             devnum;                 /* Device number             */
; 498  : U32             residual;               /* Residual byte count       */
; 499  : U32             blksize;                /* Fixed block size          */
; 500  : U32             sbiaddr;                /* Addr of SBILIST           */
; 501  : U32             sbicount;               /* Number of SBILIST entries */
; 502  : U32             blkcount;               /* Number of blocks processed*/
; 503  : U32             blknum;                 /* Block number              */
; 504  : U32             absadr;                 /* Absolute storage address  */
; 505  : BYTE            accum;                  /* Work area                 */
; 506  : BYTE            unitstat = 0;           /* Device status             */

  00028	c6 44 24 72 00	 mov	 BYTE PTR unitstat$[rsp], 0

; 507  : BYTE            chanstat = 0;           /* Subchannel status         */

  0002d	c6 44 24 70 00	 mov	 BYTE PTR chanstat$[rsp], 0
$LN4@s370_syncb:

; 508  : BYTE            skey1, skey2;           /* Storage keys of first and
; 509  :                                            last byte of I/O buffer   */
; 510  : //FIXME: code not right for shared devices
; 511  : 
; 512  :     UNREFERENCED(r2);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@s370_syncb

; 513  : 
; 514  :     /* Register R1 contains the real address of the parameter list */
; 515  :     iopaddr = regs->GR_L(r1);

  00038	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00040	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004f	89 84 24 98 00
	00 00		 mov	 DWORD PTR iopaddr$[rsp], eax

; 516  : 
; 517  :     /* Program check if parameter list not on fullword boundary */
; 518  :     if (iopaddr & 0x00000003)

  00056	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR iopaddr$[rsp]
  0005d	83 e0 03	 and	 eax, 3
  00060	85 c0		 test	 eax, eax
  00062	74 12		 je	 SHORT $LN14@s370_syncb

; 519  :     {
; 520  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00064	ba 06 00 00 00	 mov	 edx, 6
  00069	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_syncb:

; 521  :     }
; 522  : 
; 523  :     /* Ensure that parameter list operand is addressable */
; 524  :     ARCH_DEP(validate_operand) (iopaddr, USE_REAL_ADDR, sizeof(ioparm)-1,

  00076	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00083	41 b9 02 00 00
	00		 mov	 r9d, 2
  00089	41 b8 57 00 00
	00		 mov	 r8d, 87			; 00000057H
  0008f	ba fe ff ff ff	 mov	 edx, -2
  00094	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR iopaddr$[rsp]
  0009b	e8 00 00 00 00	 call	 s370_validate_operand

; 525  :                         ACCTYPE_WRITE, regs);
; 526  : 
; 527  :     /* Fetch the parameter list from real storage */
; 528  :     ARCH_DEP(vfetchc) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  000a0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ad	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000b3	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  000bb	b2 57		 mov	 dl, 87			; 00000057H
  000bd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  000c5	e8 00 00 00 00	 call	 s370_vfetchc

; 529  : 
; 530  :     /* Load numeric fields from the parameter list */
; 531  :     devnum = (ioparm.devnum[0] << 8) | ioparm.devnum[1];

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 00	 imul	 rax, rax, 0
  000d3	0f b6 84 04 c0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax]
  000db	c1 e0 08	 shl	 eax, 8
  000de	b9 01 00 00 00	 mov	 ecx, 1
  000e3	48 6b c9 01	 imul	 rcx, rcx, 1
  000e7	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx]
  000ef	0b c1		 or	 eax, ecx
  000f1	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax

; 532  :     blksize = (ioparm.blksize[0] << 24)

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	0f b6 84 04 c4
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+4]
  0010a	c1 e0 18	 shl	 eax, 24
  0010d	b9 01 00 00 00	 mov	 ecx, 1
  00112	48 6b c9 01	 imul	 rcx, rcx, 1
  00116	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  0011e	c1 e1 10	 shl	 ecx, 16
  00121	0b c1		 or	 eax, ecx
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	48 6b c9 02	 imul	 rcx, rcx, 2
  0012c	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  00134	c1 e1 08	 shl	 ecx, 8
  00137	0b c1		 or	 eax, ecx
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	48 6b c9 03	 imul	 rcx, rcx, 3
  00142	0f b6 8c 0c c4
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+4]
  0014a	0b c1		 or	 eax, ecx
  0014c	89 84 24 84 00
	00 00		 mov	 DWORD PTR blksize$[rsp], eax

; 533  :                 | (ioparm.blksize[1] << 16)
; 534  :                 | (ioparm.blksize[2] << 8)
; 535  :                 | ioparm.blksize[3];
; 536  :     sbiaddr = (ioparm.sbiaddr[0] << 24)

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	48 6b c0 00	 imul	 rax, rax, 0
  0015c	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+8]
  00164	c1 e0 18	 shl	 eax, 24
  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	48 6b c9 01	 imul	 rcx, rcx, 1
  00170	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  00178	c1 e1 10	 shl	 ecx, 16
  0017b	0b c1		 or	 eax, ecx
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 02	 imul	 rcx, rcx, 2
  00186	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  0018e	c1 e1 08	 shl	 ecx, 8
  00191	0b c1		 or	 eax, ecx
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	48 6b c9 03	 imul	 rcx, rcx, 3
  0019c	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+8]
  001a4	0b c1		 or	 eax, ecx
  001a6	89 84 24 88 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 537  :                 | (ioparm.sbiaddr[1] << 16)
; 538  :                 | (ioparm.sbiaddr[2] << 8)
; 539  :                 | ioparm.sbiaddr[3];
; 540  :     sbicount = (ioparm.sbicount[0] << 24)

  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	48 6b c0 00	 imul	 rax, rax, 0
  001b6	0f b6 84 04 cc
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+12]
  001be	c1 e0 18	 shl	 eax, 24
  001c1	b9 01 00 00 00	 mov	 ecx, 1
  001c6	48 6b c9 01	 imul	 rcx, rcx, 1
  001ca	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001d2	c1 e1 10	 shl	 ecx, 16
  001d5	0b c1		 or	 eax, ecx
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	48 6b c9 02	 imul	 rcx, rcx, 2
  001e0	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001e8	c1 e1 08	 shl	 ecx, 8
  001eb	0b c1		 or	 eax, ecx
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	48 6b c9 03	 imul	 rcx, rcx, 3
  001f6	0f b6 8c 0c cc
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+rcx+12]
  001fe	0b c1		 or	 eax, ecx
  00200	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sbicount$[rsp], eax

; 541  :                 | (ioparm.sbicount[1] << 16)
; 542  :                 | (ioparm.sbicount[2] << 8)
; 543  :                 | ioparm.sbicount[3];
; 544  : 
; 545  :     /* Locate the device block */
; 546  :     dev = find_device_by_devnum (0,devnum);

  00207	0f b7 94 24 9c
	00 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  0020f	33 c9		 xor	 ecx, ecx
  00211	e8 00 00 00 00	 call	 find_device_by_devnum
  00216	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax

; 547  : 
; 548  :     /* Set return code 2 and cond code 1 if device does not exist
; 549  :        or does not support the synchronous I/O call */
; 550  :     if (dev == NULL || dev->devtype != 0x3370)

  0021b	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00221	74 10		 je	 SHORT $LN16@s370_syncb
  00223	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00228	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0022c	3d 70 33 00 00	 cmp	 eax, 13168		; 00003370H
  00231	74 26		 je	 SHORT $LN15@s370_syncb
$LN16@s370_syncb:

; 551  :     {
; 552  :         regs->GR_L(15) = 2;

  00233	b8 08 00 00 00	 mov	 eax, 8
  00238	48 6b c0 0f	 imul	 rax, rax, 15
  0023c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	c7 84 01 80 02
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 2

; 553  :         return 1;

  0024f	b8 01 00 00 00	 mov	 eax, 1
  00254	e9 35 08 00 00	 jmp	 $LN1@s370_syncb
$LN15@s370_syncb:

; 554  :     }
; 555  : 
; 556  :     /* Program check if protect key bits 4-7 are not zero
; 557  :        or if I/O request type is not read or write */
; 558  :     if ((ioparm.akey & 0x0F)
; 559  :         || !(ioparm.type == HCPSBIOP_WRITE

  00259	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00261	83 e0 0f	 and	 eax, 15
  00264	85 c0		 test	 eax, eax
  00266	75 1a		 jne	 SHORT $LN18@s370_syncb
  00268	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00270	83 f8 01	 cmp	 eax, 1
  00273	74 1f		 je	 SHORT $LN17@s370_syncb
  00275	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  0027d	83 f8 02	 cmp	 eax, 2
  00280	74 12		 je	 SHORT $LN17@s370_syncb
$LN18@s370_syncb:

; 560  :             || ioparm.type == HCPSBIOP_READ))
; 561  :     {
; 562  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00282	ba 15 00 00 00	 mov	 edx, 21
  00287	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN17@s370_syncb:

; 563  :     }
; 564  : 
; 565  :     /* Set return code 8 and cond code 2 if blocksize is invalid */
; 566  :     if (!(blksize == 512 || blksize == 1024

  00294	81 bc 24 84 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR blksize$[rsp], 512 ; 00000200H
  0029f	74 4d		 je	 SHORT $LN19@s370_syncb
  002a1	81 bc 24 84 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR blksize$[rsp], 1024 ; 00000400H
  002ac	74 40		 je	 SHORT $LN19@s370_syncb
  002ae	81 bc 24 84 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR blksize$[rsp], 2048 ; 00000800H
  002b9	74 33		 je	 SHORT $LN19@s370_syncb
  002bb	81 bc 24 84 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR blksize$[rsp], 4096 ; 00001000H
  002c6	74 26		 je	 SHORT $LN19@s370_syncb

; 567  :             || blksize == 2048 || blksize == 4096))
; 568  :     {
; 569  :         regs->GR_L(15) = 8;

  002c8	b8 08 00 00 00	 mov	 eax, 8
  002cd	48 6b c0 0f	 imul	 rax, rax, 15
  002d1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	c7 84 01 80 02
	00 00 08 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 8

; 570  :         return 2;

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 a0 07 00 00	 jmp	 $LN1@s370_syncb
$LN19@s370_syncb:

; 571  :     }
; 572  : 
; 573  :     /* Program check if SBILIST is not on a doubleword boundary */
; 574  :     if (sbiaddr & 0x00000007)

  002ee	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  002f5	83 e0 07	 and	 eax, 7
  002f8	85 c0		 test	 eax, eax
  002fa	74 12		 je	 SHORT $LN20@s370_syncb

; 575  :     {
; 576  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002fc	ba 15 00 00 00	 mov	 edx, 21
  00301	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	e8 00 00 00 00	 call	 s370_program_interrupt
$LN20@s370_syncb:

; 577  :     }
; 578  : 
; 579  :     /* Program check if reserved fields are not zero */
; 580  :     for (accum = 0, i = 0; i < sizeof(ioparm.resv1); i++)

  0030e	c6 44 24 71 00	 mov	 BYTE PTR accum$[rsp], 0
  00313	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0031e	eb 10		 jmp	 SHORT $LN7@s370_syncb
$LN5@s370_syncb:
  00320	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00327	ff c0		 inc	 eax
  00329	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_syncb:
  00330	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00337	48 83 f8 05	 cmp	 rax, 5
  0033b	73 1e		 jae	 SHORT $LN6@s370_syncb

; 581  :         accum |= ioparm.resv1[i];

  0033d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00344	0f b6 84 04 d9
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+25]
  0034c	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  00351	0b c8		 or	 ecx, eax
  00353	8b c1		 mov	 eax, ecx
  00355	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  00359	eb c5		 jmp	 SHORT $LN5@s370_syncb
$LN6@s370_syncb:

; 582  :     for (i = 0; i < sizeof(ioparm.resv2); i++)

  0035b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00366	eb 10		 jmp	 SHORT $LN10@s370_syncb
$LN8@s370_syncb:
  00368	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0036f	ff c0		 inc	 eax
  00371	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_syncb:
  00378	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0037f	48 83 f8 18	 cmp	 rax, 24
  00383	73 1e		 jae	 SHORT $LN9@s370_syncb

; 583  :         accum |= ioparm.resv2[i];

  00385	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0038c	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+rax+32]
  00394	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR accum$[rsp]
  00399	0b c8		 or	 ecx, eax
  0039b	8b c1		 mov	 eax, ecx
  0039d	88 44 24 71	 mov	 BYTE PTR accum$[rsp], al
  003a1	eb c5		 jmp	 SHORT $LN8@s370_syncb
$LN9@s370_syncb:

; 584  :     if (accum != 0)

  003a3	0f b6 44 24 71	 movzx	 eax, BYTE PTR accum$[rsp]
  003a8	85 c0		 test	 eax, eax
  003aa	74 12		 je	 SHORT $LN21@s370_syncb

; 585  :     {
; 586  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  003ac	ba 15 00 00 00	 mov	 edx, 21
  003b1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	e8 00 00 00 00	 call	 s370_program_interrupt
$LN21@s370_syncb:

; 587  :     }
; 588  : 
; 589  :     /* Set return code 11 and cond code 2 if SBI count is invalid */
; 590  :     if (sbicount < 1 || sbicount > 500)

  003be	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR sbicount$[rsp], 1
  003c6	72 0d		 jb	 SHORT $LN23@s370_syncb
  003c8	81 bc 24 a0 00
	00 00 f4 01 00
	00		 cmp	 DWORD PTR sbicount$[rsp], 500 ; 000001f4H
  003d3	76 26		 jbe	 SHORT $LN22@s370_syncb
$LN23@s370_syncb:

; 591  :     {
; 592  :         regs->GR_L(15) = 11;

  003d5	b8 08 00 00 00	 mov	 eax, 8
  003da	48 6b c0 0f	 imul	 rax, rax, 15
  003de	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e6	c7 84 01 80 02
	00 00 0b 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 11

; 593  :         return 2;

  003f1	b8 02 00 00 00	 mov	 eax, 2
  003f6	e9 93 06 00 00	 jmp	 $LN1@s370_syncb
$LN22@s370_syncb:

; 594  :     }
; 595  : 
; 596  :     /* Obtain the device lock */
; 597  :     obtain_lock (&dev->lock);

  003fb	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00400	48 83 c0 38	 add	 rax, 56			; 00000038H
  00404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169837
  0040b	48 8b c8	 mov	 rcx, rax
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 598  : 
; 599  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 600  :     /* Return code 5 and condition code 1 if status pending */
; 601  :     if ((dev->scsw.flag3 & SCSW3_SC_PEND)
; 602  :         || (dev->pciscsw.flag3 & SCSW3_SC_PEND))
; 603  :     {
; 604  :         release_lock (&dev->lock);
; 605  :         regs->GR_L(15) = 5;
; 606  :         return 1;
; 607  :     }
; 608  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 609  : 
; 610  :     /* Return code 5 and condition code 1 if device is busy */
; 611  :     if (dev->busy || IOPENDING(dev))

  00414	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00419	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0041f	c1 e8 13	 shr	 eax, 19
  00422	83 e0 01	 and	 eax, 1
  00425	85 c0		 test	 eax, eax
  00427	75 54		 jne	 SHORT $LN25@s370_syncb
  00429	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0042e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00434	c1 e8 16	 shr	 eax, 22
  00437	83 e0 01	 and	 eax, 1
  0043a	85 c0		 test	 eax, eax
  0043c	75 3f		 jne	 SHORT $LN26@s370_syncb
  0043e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00443	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00449	c1 e8 17	 shr	 eax, 23
  0044c	83 e0 01	 and	 eax, 1
  0044f	85 c0		 test	 eax, eax
  00451	75 2a		 jne	 SHORT $LN26@s370_syncb
  00453	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00458	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0045e	c1 e8 18	 shr	 eax, 24
  00461	83 e0 01	 and	 eax, 1
  00464	85 c0		 test	 eax, eax
  00466	75 15		 jne	 SHORT $LN26@s370_syncb
  00468	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0046d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00473	c1 e8 1b	 shr	 eax, 27
  00476	83 e0 01	 and	 eax, 1
  00479	85 c0		 test	 eax, eax
  0047b	74 3f		 je	 SHORT $LN24@s370_syncb
$LN26@s370_syncb:
$LN25@s370_syncb:

; 612  :     {
; 613  :         release_lock (&dev->lock);

  0047d	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00482	48 83 c0 38	 add	 rax, 56			; 00000038H
  00486	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169841
  0048d	48 8b c8	 mov	 rcx, rax
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 614  :         regs->GR_L(15) = 5;

  00496	b8 08 00 00 00	 mov	 eax, 8
  0049b	48 6b c0 0f	 imul	 rax, rax, 15
  0049f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a7	c7 84 01 80 02
	00 00 05 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 5

; 615  :         return 1;

  004b2	b8 01 00 00 00	 mov	 eax, 1
  004b7	e9 d2 05 00 00	 jmp	 $LN1@s370_syncb
$LN24@s370_syncb:

; 616  :     }
; 617  : 
; 618  :     /* Set the device busy indicator */
; 619  :     dev->busy = 1;

  004bc	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004c1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004c7	0f ba e8 13	 bts	 eax, 19
  004cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  004d0	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 620  : 
; 621  :     /* Release the device lock */
; 622  :     release_lock (&dev->lock);

  004d6	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  004db	48 83 c0 38	 add	 rax, 56			; 00000038H
  004df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169842
  004e6	48 8b c8	 mov	 rcx, rax
  004e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 623  : 
; 624  :     /* Process each entry in the SBILIST */
; 625  :     for (blkcount = 0; blkcount < sbicount; blkcount++)

  004ef	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR blkcount$[rsp], 0
  004fa	eb 10		 jmp	 SHORT $LN13@s370_syncb
$LN11@s370_syncb:
  004fc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  00503	ff c0		 inc	 eax
  00505	89 84 24 8c 00
	00 00		 mov	 DWORD PTR blkcount$[rsp], eax
$LN13@s370_syncb:
  0050c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sbicount$[rsp]
  00513	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR blkcount$[rsp], eax
  0051a	0f 83 70 03 00
	00		 jae	 $LN12@s370_syncb

; 626  :     {
; 627  :         /* Return code 10 and cond code 2 if SBILIST entry
; 628  :            is outside main storage or is fetch protected.
; 629  :            Note that the SBI address is an absolute address
; 630  :            and is not subject to fetch-protection override
; 631  :            or storage-protection override mechanisms, and
; 632  :            an SBILIST entry cannot cross a page boundary */
; 633  :         if (sbiaddr > regs->mainlim
; 634  :             || ((ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_FETCH)

  00520	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00527	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052f	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00536	77 46		 ja	 SHORT $LN28@s370_syncb
  00538	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  0053f	8b c8		 mov	 ecx, eax
  00541	e8 00 00 00 00	 call	 s370_get_storage_key
  00546	0f b6 c0	 movzx	 eax, al
  00549	83 e0 08	 and	 eax, 8
  0054c	85 c0		 test	 eax, eax
  0054e	74 54		 je	 SHORT $LN27@s370_syncb
  00550	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00557	8b c8		 mov	 ecx, eax
  00559	e8 00 00 00 00	 call	 s370_get_storage_key
  0055e	0f b6 c0	 movzx	 eax, al
  00561	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00566	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  0056e	3b c1		 cmp	 eax, ecx
  00570	74 32		 je	 SHORT $LN27@s370_syncb
  00572	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  0057a	85 c0		 test	 eax, eax
  0057c	74 26		 je	 SHORT $LN27@s370_syncb
$LN28@s370_syncb:

; 635  :                 && (ARCH_DEP( get_storage_key )( sbiaddr ) & STORKEY_KEY) != ioparm.akey
; 636  :                 && ioparm.akey != 0))
; 637  :         {
; 638  :             regs->GR_L(15) = 10;

  0057e	b8 08 00 00 00	 mov	 eax, 8
  00583	48 6b c0 0f	 imul	 rax, rax, 15
  00587	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0058f	c7 84 01 80 02
	00 00 0a 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 10

; 639  :             return 2;

  0059a	b8 02 00 00 00	 mov	 eax, 2
  0059f	e9 ea 04 00 00	 jmp	 $LN1@s370_syncb
$LN27@s370_syncb:

; 640  :         }
; 641  : 
; 642  :         /* Load block number and data address from SBILIST */
; 643  :         blknum = ARCH_DEP(fetch_fullword_absolute)(sbiaddr, regs);

  005a4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005ab	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b3	8b c8		 mov	 ecx, eax
  005b5	e8 00 00 00 00	 call	 s370_fetch_fullword_absolute
  005ba	89 84 24 b0 00
	00 00		 mov	 DWORD PTR blknum$[rsp], eax

; 644  :         absadr = ARCH_DEP(fetch_fullword_absolute)(sbiaddr+4, regs);

  005c1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  005c8	83 c0 04	 add	 eax, 4
  005cb	8b c0		 mov	 eax, eax
  005cd	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005d5	8b c8		 mov	 ecx, eax
  005d7	e8 00 00 00 00	 call	 s370_fetch_fullword_absolute
  005dc	89 84 24 90 00
	00 00		 mov	 DWORD PTR absadr$[rsp], eax

; 645  : 
; 646  :         if (dev->ccwtrace)

  005e3	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  005e8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ee	c1 e8 0f	 shr	 eax, 15
  005f1	83 e0 01	 and	 eax, 1
  005f4	85 c0		 test	 eax, eax
  005f6	0f 84 04 01 00
	00		 je	 $LN29@s370_syncb

; 647  :         {
; 648  :             WRMSG(HHC01952, "I",

  005fc	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  00604	83 f8 01	 cmp	 eax, 1
  00607	75 11		 jne	 SHORT $LN43@s370_syncb
  00609	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169846
  00610	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv319[rsp], rax
  00618	eb 0f		 jmp	 SHORT $LN44@s370_syncb
$LN43@s370_syncb:
  0061a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169847
  00621	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv319[rsp], rax
$LN44@s370_syncb:
  00629	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0062f	74 12		 je	 SHORT $LN45@s370_syncb
  00631	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00636	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0063a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv324[rsp], eax
  00641	eb 0b		 jmp	 SHORT $LN46@s370_syncb
$LN45@s370_syncb:
  00643	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv324[rsp], 0
$LN46@s370_syncb:
  0064e	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00654	74 14		 je	 SHORT $LN47@s370_syncb
  00656	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0065b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0065f	d1 f8		 sar	 eax, 1
  00661	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv330[rsp], eax
  00668	eb 0b		 jmp	 SHORT $LN48@s370_syncb
$LN47@s370_syncb:
  0066a	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv330[rsp], 0
$LN48@s370_syncb:
  00675	b9 01 00 00 00	 mov	 ecx, 1
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00680	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  00687	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0068b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR absadr$[rsp]
  00692	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00696	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR blknum$[rsp]
  0069d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  006a1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv319[rsp]
  006a9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006ae	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv324[rsp]
  006b5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006b9	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv330[rsp]
  006c0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169848
  006cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169849
  006d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169850
  006ee	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  006f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169851
  006fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@s370_syncb:

; 649  :                     LCSS_DEVNUM,
; 650  :                     (ioparm.type == HCPSBIOP_WRITE ? "WRITE" : "READ"),
; 651  :                     blknum, absadr, blksize);
; 652  :         }
; 653  : 
; 654  :         /* Return code 12 and cond code 2 if buffer exceeds storage */
; 655  :         if (absadr > regs->mainlim - blksize)

  00700	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00707	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  0070e	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00716	48 8b 92 58 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2136]
  0071d	48 2b d1	 sub	 rdx, rcx
  00720	48 8b ca	 mov	 rcx, rdx
  00723	48 3b c1	 cmp	 rax, rcx
  00726	76 26		 jbe	 SHORT $LN30@s370_syncb

; 656  :         {
; 657  :             regs->GR_L(15) = 12;

  00728	b8 08 00 00 00	 mov	 eax, 8
  0072d	48 6b c0 0f	 imul	 rax, rax, 15
  00731	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00739	c7 84 01 80 02
	00 00 0c 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 12

; 658  :             return 2;

  00744	b8 02 00 00 00	 mov	 eax, 2
  00749	e9 40 03 00 00	 jmp	 $LN1@s370_syncb
$LN30@s370_syncb:

; 659  :         }
; 660  : 
; 661  :         /* Channel protection check if access key does not match
; 662  :            storage keys of buffer.  Note that the buffer address is
; 663  :            an absolute address, the buffer cannot span more than two
; 664  :            pages, and the access is not subject to fetch-protection
; 665  :            override, storage-protection override, or low-address
; 666  :            protection */
; 667  :         skey1 = ARCH_DEP( get_storage_key )( absadr );

  0074e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00755	8b c8		 mov	 ecx, eax
  00757	e8 00 00 00 00	 call	 s370_get_storage_key
  0075c	88 44 24 73	 mov	 BYTE PTR skey1$[rsp], al

; 668  :         skey2 = ARCH_DEP( get_storage_key )( absadr + blksize - 1 );

  00760	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00767	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  0076e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00772	8b c0		 mov	 eax, eax
  00774	8b c8		 mov	 ecx, eax
  00776	e8 00 00 00 00	 call	 s370_get_storage_key
  0077b	88 44 24 74	 mov	 BYTE PTR skey2$[rsp], al

; 669  :         if (ioparm.akey != 0
; 670  :             && (

  0077f	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+2]
  00787	85 c0		 test	 eax, eax
  00789	74 6f		 je	 SHORT $LN31@s370_syncb
  0078b	0f b6 44 24 73	 movzx	 eax, BYTE PTR skey1$[rsp]
  00790	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00795	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  0079d	3b c1		 cmp	 eax, ecx
  0079f	74 19		 je	 SHORT $LN33@s370_syncb
  007a1	0f b6 44 24 73	 movzx	 eax, BYTE PTR skey1$[rsp]
  007a6	83 e0 08	 and	 eax, 8
  007a9	85 c0		 test	 eax, eax
  007ab	75 3c		 jne	 SHORT $LN32@s370_syncb
  007ad	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  007b5	83 f8 02	 cmp	 eax, 2
  007b8	74 2f		 je	 SHORT $LN32@s370_syncb
$LN33@s370_syncb:
  007ba	0f b6 44 24 74	 movzx	 eax, BYTE PTR skey2$[rsp]
  007bf	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  007c4	0f b6 8c 24 c2
	00 00 00	 movzx	 ecx, BYTE PTR ioparm$[rsp+2]
  007cc	3b c1		 cmp	 eax, ecx
  007ce	74 2a		 je	 SHORT $LN31@s370_syncb
  007d0	0f b6 44 24 74	 movzx	 eax, BYTE PTR skey2$[rsp]
  007d5	83 e0 08	 and	 eax, 8
  007d8	85 c0		 test	 eax, eax
  007da	75 0d		 jne	 SHORT $LN34@s370_syncb
  007dc	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR ioparm$[rsp+3]
  007e4	83 f8 02	 cmp	 eax, 2
  007e7	75 11		 jne	 SHORT $LN31@s370_syncb
$LN34@s370_syncb:
$LN32@s370_syncb:

; 671  :                    ((skey1 & STORKEY_KEY) != ioparm.akey
; 672  :                     && ((skey1 & STORKEY_FETCH)
; 673  :                         || ioparm.type == HCPSBIOP_READ))
; 674  :                 || ((skey2 & STORKEY_KEY) != ioparm.akey
; 675  :                     && ((skey2 & STORKEY_FETCH)
; 676  :                         || ioparm.type == HCPSBIOP_READ))
; 677  :             ))
; 678  :         {
; 679  :             chanstat |= CSW_PROTC;

  007e9	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  007ee	83 c8 10	 or	 eax, 16
  007f1	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al

; 680  :             break;

  007f5	e9 96 00 00 00	 jmp	 $LN12@s370_syncb
$LN31@s370_syncb:

; 681  :         }
; 682  : 
; 683  :         /* Call device handler to read or write one block */
; 684  :         fbadasd_syncblk_io (dev, ioparm.type, blknum, blksize,

  007fa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR absadr$[rsp]
  00801	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00809	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00810	48 8d 8c 24 a4
	00 00 00	 lea	 rcx, QWORD PTR residual$[rsp]
  00818	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0081d	48 8d 4c 24 72	 lea	 rcx, QWORD PTR unitstat$[rsp]
  00822	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00827	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082c	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR blksize$[rsp]
  00834	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR blknum$[rsp]
  0083c	0f b6 94 24 c3
	00 00 00	 movzx	 edx, BYTE PTR ioparm$[rsp+3]
  00844	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00849	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fbadasd_syncblk_io

; 685  :                             regs->mainstor + absadr,
; 686  :                             &unitstat, &residual);
; 687  : 
; 688  :         /* Set incorrect length if residual count is non-zero */
; 689  :         if (residual != 0)

  0084f	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR residual$[rsp], 0
  00857	74 0c		 je	 SHORT $LN35@s370_syncb

; 690  :             chanstat |= CSW_IL;

  00859	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0085e	83 c8 40	 or	 eax, 64			; 00000040H
  00861	88 44 24 70	 mov	 BYTE PTR chanstat$[rsp], al
$LN35@s370_syncb:

; 691  : 
; 692  :         /* Exit if any unusual status */
; 693  :         if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00865	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0086a	83 f8 0c	 cmp	 eax, 12
  0086d	75 09		 jne	 SHORT $LN37@s370_syncb
  0086f	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00874	85 c0		 test	 eax, eax
  00876	74 02		 je	 SHORT $LN36@s370_syncb
$LN37@s370_syncb:

; 694  :             break;

  00878	eb 16		 jmp	 SHORT $LN12@s370_syncb
$LN36@s370_syncb:

; 695  : 
; 696  :         /* Point to next SBILIST entry */
; 697  :         sbiaddr += 8;

  0087a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sbiaddr$[rsp]
  00881	83 c0 08	 add	 eax, 8
  00884	89 84 24 88 00
	00 00		 mov	 DWORD PTR sbiaddr$[rsp], eax

; 698  : 
; 699  :     } /* end for(blkcount) */

  0088b	e9 6c fc ff ff	 jmp	 $LN11@s370_syncb
$LN12@s370_syncb:

; 700  : 
; 701  :     /* Reset the device busy indicator */
; 702  :     dev->busy = 0;

  00890	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00895	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0089b	0f ba f0 13	 btr	 eax, 19
  0089f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  008a4	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 703  : 
; 704  :     /* Store the block count in the parameter list */
; 705  :     ioparm.blkcount[0] = (blkcount >> 24) & 0xFF;

  008aa	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  008b1	c1 e8 18	 shr	 eax, 24
  008b4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008b9	b9 01 00 00 00	 mov	 ecx, 1
  008be	48 6b c9 00	 imul	 rcx, rcx, 0
  008c2	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 706  :     ioparm.blkcount[1] = (blkcount >> 16) & 0xFF;

  008c9	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  008d0	c1 e8 10	 shr	 eax, 16
  008d3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008d8	b9 01 00 00 00	 mov	 ecx, 1
  008dd	48 6b c9 01	 imul	 rcx, rcx, 1
  008e1	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 707  :     ioparm.blkcount[2] = (blkcount >> 8) & 0xFF;

  008e8	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  008ef	c1 e8 08	 shr	 eax, 8
  008f2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008f7	b9 01 00 00 00	 mov	 ecx, 1
  008fc	48 6b c9 02	 imul	 rcx, rcx, 2
  00900	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 708  :     ioparm.blkcount[3] = blkcount & 0xFF;

  00907	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR blkcount$[rsp]
  0090e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00913	b9 01 00 00 00	 mov	 ecx, 1
  00918	48 6b c9 03	 imul	 rcx, rcx, 3
  0091c	88 84 0c d0 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+16], al

; 709  : 
; 710  :     /* Store the device and subchannel status in the parameter list */
; 711  :     ioparm.unitstat = unitstat;

  00923	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00928	88 84 24 d4 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+20], al

; 712  :     ioparm.chanstat = chanstat;

  0092f	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00934	88 84 24 d5 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+21], al

; 713  : 
; 714  :     /* Store the residual byte count in the parameter list */
; 715  :     ioparm.residual[0] = (residual >> 8) & 0xFF;

  0093b	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  00942	c1 e8 08	 shr	 eax, 8
  00945	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0094a	b9 01 00 00 00	 mov	 ecx, 1
  0094f	48 6b c9 00	 imul	 rcx, rcx, 0
  00953	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 716  :     ioparm.residual[1] = residual & 0xFF;

  0095a	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR residual$[rsp]
  00961	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00966	b9 01 00 00 00	 mov	 ecx, 1
  0096b	48 6b c9 01	 imul	 rcx, rcx, 1
  0096f	88 84 0c d6 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+22], al

; 717  : 
; 718  :     /* Return sense data if unit check occurred */
; 719  :     if (unitstat & CSW_UC)

  00976	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0097b	83 e0 02	 and	 eax, 2
  0097e	85 c0		 test	 eax, eax
  00980	0f 84 8a 00 00
	00		 je	 $LN38@s370_syncb

; 720  :     {
; 721  :         numsense = dev->numsense;

  00986	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0098b	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00991	89 84 24 94 00
	00 00		 mov	 DWORD PTR numsense$[rsp], eax

; 722  :         if (numsense > sizeof(ioparm.sense))

  00998	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  0099f	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  009a3	76 0b		 jbe	 SHORT $LN39@s370_syncb

; 723  :             numsense = sizeof(ioparm.sense);

  009a5	c7 84 24 94 00
	00 00 20 00 00
	00		 mov	 DWORD PTR numsense$[rsp], 32 ; 00000020H
$LN39@s370_syncb:

; 724  :         ioparm.sensecount[0] = (numsense >> 8) & 0xFF;

  009b0	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  009b7	c1 e8 08	 shr	 eax, 8
  009ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009bf	b9 01 00 00 00	 mov	 ecx, 1
  009c4	48 6b c9 00	 imul	 rcx, rcx, 0
  009c8	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 725  :         ioparm.sensecount[1] = numsense & 0xFF;

  009cf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  009d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009db	b9 01 00 00 00	 mov	 ecx, 1
  009e0	48 6b c9 01	 imul	 rcx, rcx, 1
  009e4	88 84 0c de 00
	00 00		 mov	 BYTE PTR ioparm$[rsp+rcx+30], al

; 726  :         memcpy (ioparm.sense, dev->sense, numsense);

  009eb	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numsense$[rsp]
  009f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  009f7	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  009fe	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR ioparm$[rsp+56]
  00a06	48 8b fa	 mov	 rdi, rdx
  00a09	48 8b f1	 mov	 rsi, rcx
  00a0c	8b c8		 mov	 ecx, eax
  00a0e	f3 a4		 rep movsb
$LN38@s370_syncb:

; 727  :     }
; 728  : 
; 729  :     /* Store the updated parameter list in real storage */
; 730  :     ARCH_DEP(vstorec) (&ioparm, sizeof(ioparm)-1, iopaddr, USE_REAL_ADDR, regs);

  00a10	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a1d	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00a23	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR iopaddr$[rsp]
  00a2b	b2 57		 mov	 dl, 87			; 00000057H
  00a2d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ioparm$[rsp]
  00a35	e8 00 00 00 00	 call	 s370_vstorec

; 731  : 
; 732  :     /* If I/O error occurred, set return code 13 and cond code 3 */
; 733  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  00a3a	0f b6 44 24 72	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00a3f	83 f8 0c	 cmp	 eax, 12
  00a42	75 09		 jne	 SHORT $LN41@s370_syncb
  00a44	0f b6 44 24 70	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00a49	85 c0		 test	 eax, eax
  00a4b	74 23		 je	 SHORT $LN40@s370_syncb
$LN41@s370_syncb:

; 734  :     {
; 735  :         regs->GR_L(15) = 13;

  00a4d	b8 08 00 00 00	 mov	 eax, 8
  00a52	48 6b c0 0f	 imul	 rax, rax, 15
  00a56	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a5e	c7 84 01 80 02
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 13

; 736  :         return 3;

  00a69	b8 03 00 00 00	 mov	 eax, 3
  00a6e	eb 1e		 jmp	 SHORT $LN1@s370_syncb
$LN40@s370_syncb:

; 737  :     }
; 738  : 
; 739  :     /* Set return code 0 and cond code 0 */
; 740  :     regs->GR_L(15) = 0;

  00a70	b8 08 00 00 00	 mov	 eax, 8
  00a75	48 6b c0 0f	 imul	 rax, rax, 15
  00a79	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a81	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 741  :     return 0;

  00a8c	33 c0		 xor	 eax, eax
$LN1@s370_syncb:

; 742  : 
; 743  : } /* end function syncblk_io */

  00a8e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a96	48 33 cc	 xor	 rcx, rsp
  00a99	e8 00 00 00 00	 call	 __security_check_cookie
  00a9e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00aa5	5f		 pop	 rdi
  00aa6	5e		 pop	 rsi
  00aa7	c3		 ret	 0
s370_syncblk_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vm.c
_TEXT	SEGMENT
devnum$ = 32
vdat$ = 36
rdat$ = 40
dev$ = 48
r1$ = 80
r2$ = 88
regs$ = 96
s370_diag_devtype PROC

; 434  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 435  : DEVBLK         *dev;                    /* -> Device block           */
; 436  : U16             devnum;                 /* Device number             */
; 437  : VRDCVDAT        vdat;                   /* Virtual device data       */
; 438  : VRDCRCDT        rdat;                   /* Real device data          */
; 439  : 
; 440  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 441  :      /* Program check if 64-bit addressing is being used. */
; 442  :      if (regs->psw.amode64)
; 443  :      {
; 444  :          ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 445  :      }
; 446  : #endif /* FEATURE_001_ZARCH_INSTALLED_FACILITY */
; 447  : 
; 448  :     /* Return console information if R1 register is all ones */
; 449  :     if (regs->GR_L(r1) == 0xFFFFFFFF)

  00011	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00016	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	83 bc c1 80 02
	00 00 ff	 cmp	 DWORD PTR [rcx+rax*8+640], -1 ; ffffffffH
  00023	75 74		 jne	 SHORT $LN5@s370_diag_

; 450  :     {
; 451  :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00033	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  00038	eb 0e		 jmp	 SHORT $LN4@s370_diag_
$LN2@s370_diag_:
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00043	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@s370_diag_:
  00048	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0004e	74 49		 je	 SHORT $LN3@s370_diag_

; 452  :             if ( dev->allocated
; 453  :                  && ( dev->devtype == 0x3215 || dev->devtype == 0x1503 )

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00055	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00059	74 3c		 je	 SHORT $LN6@s370_diag_
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00060	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00064	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00069	74 10		 je	 SHORT $LN7@s370_diag_
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00070	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00074	3d 03 15 00 00	 cmp	 eax, 5379		; 00001503H
  00079	75 1c		 jne	 SHORT $LN6@s370_diag_
$LN7@s370_diag_:

; 454  :                )
; 455  :             {
; 456  :                 regs->GR_L(r1) = dev->devnum;

  0007b	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00080	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00085	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00089	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0008e	89 8c c2 80 02
	00 00		 mov	 DWORD PTR [rdx+rax*8+640], ecx

; 457  :                 break;

  00095	eb 02		 jmp	 SHORT $LN3@s370_diag_
$LN6@s370_diag_:

; 458  :             }

  00097	eb a1		 jmp	 SHORT $LN2@s370_diag_
$LN3@s370_diag_:
$LN5@s370_diag_:

; 459  :     }
; 460  : 
; 461  :     /* Extract the device number from the R1 register */
; 462  :     devnum = regs->GR_L(r1);

  00099	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000ab	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax

; 463  : 
; 464  :     /* Locate the device block and set the virtual and real device information */
; 465  :     dev = ARCH_DEP(vmdevice_data) (0x24,devnum,&vdat,&rdat);

  000b0	4c 8d 4c 24 28	 lea	 r9, QWORD PTR rdat$[rsp]
  000b5	4c 8d 44 24 24	 lea	 r8, QWORD PTR vdat$[rsp]
  000ba	0f b7 54 24 20	 movzx	 edx, WORD PTR devnum$[rsp]
  000bf	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  000c4	e8 00 00 00 00	 call	 s370_vmdevice_data
  000c9	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 466  : 
; 467  :     /* Return condition code 3 if device does not exist */
; 468  :     if (!dev)

  000ce	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000d4	75 07		 jne	 SHORT $LN8@s370_diag_

; 469  :         return 3;

  000d6	b8 03 00 00 00	 mov	 eax, 3
  000db	eb 51		 jmp	 SHORT $LN1@s370_diag_
$LN8@s370_diag_:

; 470  : 
; 471  :     /* Return virtual device information in the R2 register */
; 472  :     FETCH_FW(regs->GR_L(r2),&vdat);

  000dd	48 8d 4c 24 24	 lea	 rcx, QWORD PTR vdat$[rsp]
  000e2	e8 00 00 00 00	 call	 fetch_fw_noswap
  000e7	8b c8		 mov	 ecx, eax
  000e9	e8 00 00 00 00	 call	 _byteswap_ulong
  000ee	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000f3	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  000f8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 473  : 
; 474  :     /* Return real device information in the R2+1 register */
; 475  :     if (r2 != 15)

  000ff	83 7c 24 58 0f	 cmp	 DWORD PTR r2$[rsp], 15
  00104	74 26		 je	 SHORT $LN9@s370_diag_

; 476  :         FETCH_FW(regs->GR_L(r2+1),&rdat);

  00106	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rdat$[rsp]
  0010b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00110	8b c8		 mov	 ecx, eax
  00112	e8 00 00 00 00	 call	 _byteswap_ulong
  00117	8b 4c 24 58	 mov	 ecx, DWORD PTR r2$[rsp]
  0011b	ff c1		 inc	 ecx
  0011d	48 63 c9	 movsxd	 rcx, ecx
  00120	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00125	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN9@s370_diag_:

; 477  : #if 0 // debug
; 478  :     LOGMSG( "Diagnose X'024':devnum=%4.4X VRDCVDAT=%8.8X VRDCRCDT=%8.8X\n",
; 479  :             devnum, vdat, rdat );
; 480  : #endif
; 481  : 
; 482  :     /* Return condition code 0 */
; 483  :     return 0;

  0012c	33 c0		 xor	 eax, eax
$LN1@s370_diag_:

; 484  : 
; 485  : } /* end function diag_devtype */

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
s370_diag_devtype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
