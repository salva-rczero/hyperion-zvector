; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	store_hw_noswap
PUBLIC	syntax
PUBLIC	status
PUBLIC	nulltrk
PUBLIC	main
PUBLIC	__real@4059000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_open_fba_image:PROC
EXTRN	__imp_open_ckd64_image:PROC
EXTRN	__imp_open_fba64_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_create_ckd:PROC
EXTRN	__imp_create_ckd64:PROC
EXTRN	__imp_create_fba:PROC
EXTRN	__imp_create_fba64:PROC
EXTRN	__imp_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG168959 DB	01H DUP (?)
$SG168960 DB	01H DUP (?)
$SG168963 DB	01H DUP (?)
$SG168964 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$syntax DD imagerel $LN34
	DD	imagerel $LN34+1684
	DD	imagerel $unwind$syntax
$pdata$status DD imagerel $LN13
	DD	imagerel $LN13+198
	DD	imagerel $unwind$status
$pdata$nulltrk DD imagerel $LN9
	DD	imagerel $LN9+667
	DD	imagerel $unwind$nulltrk
$pdata$main DD	imagerel $LN202
	DD	imagerel $LN202+8332
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
_DATA	SEGMENT
$SG168736 DB	'64-bit DASD copy/convert', 00H
	ORG $+7
$SG168737 DB	'dasdcopy64', 00H
	ORG $+1
$SG168752 DB	'-h', 00H
	ORG $+1
$SG168740 DB	'ckd2cckd64', 00H
	ORG $+1
$SG168756 DB	'-q', 00H
	ORG $+1
$SG168743 DB	'cckd642ckd', 00H
	ORG $+1
$SG168760 DB	'-r', 00H
	ORG $+1
$SG168746 DB	'fba2cfba64', 00H
	ORG $+1
$SG168763 DB	'-z', 00H
	ORG $+1
$SG168748 DB	'cfba642fba', 00H
	ORG $+1
$SG168757 DB	'-quiet', 00H
	ORG $+1
$SG168766 DB	'-bz2', 00H
	ORG $+3
$SG168769 DB	'-0', 00H
	ORG $+1
$SG168773 DB	'-cyl', 00H
	ORG $+3
$SG168774 DB	'-cyls', 00H
	ORG $+2
$SG168777 DB	'(missing)', 00H
	ORG $+2
$SG168778 DB	'-cyls', 00H
	ORG $+2
$SG168793 DB	'-a', 00H
	ORG $+1
$SG168779 DB	'invalid %s argument: %s', 00H
$SG168783 DB	'-blk', 00H
	ORG $+3
$SG168784 DB	'-blks', 00H
	ORG $+2
$SG168787 DB	'(missing)', 00H
	ORG $+2
$SG168788 DB	'-blks', 00H
	ORG $+2
$SG168801 DB	'-o', 00H
	ORG $+1
$SG168789 DB	'invalid %s argument: %s', 00H
$SG168794 DB	'-alt', 00H
	ORG $+3
$SG168795 DB	'-alts', 00H
	ORG $+2
$SG168798 DB	'-lfs', 00H
	ORG $+3
$SG168803 DB	'(missing)', 00H
	ORG $+2
$SG168804 DB	'-o', 00H
	ORG $+1
$SG168805 DB	'invalid %s argument: %s', 00H
$SG168807 DB	'already previously specified', 00H
	ORG $+3
$SG168808 DB	'-o', 00H
	ORG $+1
$SG168812 DB	'ckd', 00H
$SG168809 DB	'invalid %s argument: %s', 00H
$SG168815 DB	'cckd', 00H
	ORG $+3
$SG168818 DB	'fba', 00H
$SG168821 DB	'cfba', 00H
	ORG $+3
$SG168824 DB	'ckd64', 00H
	ORG $+2
$SG168827 DB	'cckd64', 00H
	ORG $+1
$SG168830 DB	'fba64', 00H
	ORG $+2
$SG168833 DB	'cfba64', 00H
	ORG $+1
$SG168834 DB	'-o', 00H
	ORG $+1
$SG168835 DB	'invalid %s argument: %s', 00H
$SG168836 DB	'unrecognized/unsupported option: %s', 00H
$SG168839 DB	'%s', 00H
	ORG $+1
$SG168838 DB	'missing input-file specification', 00H
	ORG $+3
$SG168846 DB	'sf=', 00H
$SG168841 DB	'extraneous parameter: %s', 00H
	ORG $+3
$SG168850 DB	'open()', 00H
	ORG $+1
$SG168851 DB	'E', 00H
	ORG $+2
$SG168847 DB	'invalid shadow file specification: %s', 00H
	ORG $+2
$SG168852 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168853 DB	'main', 00H
	ORG $+3
$SG168854 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168856 DB	'read()', 00H
	ORG $+1
$SG168857 DB	'E', 00H
	ORG $+2
$SG168877 DB	'E', 00H
	ORG $+2
$SG168858 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168859 DB	'main', 00H
	ORG $+3
$SG168860 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168878 DB	'HHC02424%s Dasd image file format unsupported or unrecog'
	DB	'nized: %s', 0aH, 00H
	ORG $+1
$SG168879 DB	'main', 00H
	ORG $+3
$SG168901 DB	'%s', 00H
	ORG $+1
$SG168880 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168900 DB	'shadow files invalid if input not compressed', 00H
	ORG $+3
$SG168903 DB	'compress type invalid for uncompressed output', 00H
	ORG $+2
$SG168904 DB	'%s', 00H
	ORG $+1
$SG168907 DB	'%s', 00H
	ORG $+1
$SG168906 DB	'-lfs invalid if output is compressed', 00H
	ORG $+3
$SG168909 DB	'-cyls invalid for fba input', 00H
$SG168910 DB	'%s', 00H
	ORG $+1
$SG168912 DB	'-blks invalid for ckd input', 00H
$SG168913 DB	'%s', 00H
	ORG $+1
$SG168915 DB	'-a invalid for fba input', 00H
	ORG $+3
$SG168916 DB	'%s', 00H
	ORG $+1
$SG168920 DB	'cannot copy ckd to fba or vice versa', 00H
	ORG $+3
$SG168921 DB	'%s', 00H
	ORG $+1
$SG168929 DB	'E', 00H
	ORG $+2
$SG168930 DB	'HHC02403%s Failed opening %s', 0aH, 00H
	ORG $+2
$SG168931 DB	'main', 00H
	ORG $+3
$SG168932 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168940 DB	'E', 00H
	ORG $+2
$SG168950 DB	'E', 00H
	ORG $+2
$SG168941 DB	'HHC02430%s CKD lookup failed: device type %04X cyls %d', 0aH
	DB	00H
$SG168942 DB	'main', 00H
	ORG $+3
$SG168943 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168951 DB	'HHC02431%s FBA lookup failed: blks %d', 0aH, 00H
	ORG $+1
$SG168952 DB	'main', 00H
	ORG $+3
$SG168953 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168966 DB	'E', 00H
	ORG $+2
$SG168977 DB	'E', 00H
	ORG $+2
$SG168967 DB	'HHC02432%s Failed creating %s', 0aH, 00H
	ORG $+1
$SG168968 DB	'main', 00H
	ORG $+3
$SG168969 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168978 DB	'HHC02403%s Failed opening %s', 0aH, 00H
	ORG $+2
$SG168979 DB	'main', 00H
	ORG $+3
$SG168980 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG168982 DB	'TRKS=%d', 0aH, 00H
	ORG $+3
$SG168993 DB	'track', 00H
	ORG $+2
$SG168997 DB	'E', 00H
	ORG $+2
$SG168985 DB	'  %3d%% %7d of %d', 00H
	ORG $+2
$SG168994 DB	'block', 00H
	ORG $+2
$SG168995 DB	'track', 00H
	ORG $+2
$SG168996 DB	'block', 00H
	ORG $+6
$SG168998 DB	'HHC02433%s Read error on file %s: %s %d stat=%2.2X, null'
	DB	' %s substituted', 0aH, 00H
	ORG $+3
$SG168999 DB	'main', 00H
	ORG $+3
$SG169021 DB	'track', 00H
	ORG $+2
$SG169023 DB	'E', 00H
	ORG $+2
$SG169000 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169005 DB	'  %3d%% %7d of %d', 00H
	ORG $+2
$SG169012 DB	'main', 00H
	ORG $+3
$SG169022 DB	'block', 00H
	ORG $+2
$SG169030 DB	0dH, 00H
	ORG $+2
$SG169013 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169016 DB	'main', 00H
	ORG $+3
$SG169014 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169017 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169024 DB	'HHC02434%s Write error on file %s: %s %d stat=%2.2X', 0aH
	DB	00H
	ORG $+3
$SG169018 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169025 DB	'main', 00H
	ORG $+3
$SG169026 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169032 DB	'I', 00H
	ORG $+2
$SG169036 DB	'I', 00H
	ORG $+2
$SG169033 DB	'HHC02595%s Shadow file data successfully merged into out'
	DB	'put', 0aH, 00H
	ORG $+3
$SG169034 DB	'main', 00H
	ORG $+3
$SG169035 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169037 DB	'HHC02423%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG169038 DB	'main', 00H
	ORG $+3
$SG169039 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169116 DB	'E', 00H
	ORG $+2
$SG169118 DB	'syntax', 00H
	ORG $+1
$SG169132 DB	'I', 00H
	ORG $+2
$SG169117 DB	'HHC02594%s Syntax error: %s', 0aH, 00H
	ORG $+3
$SG169119 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169123 DB	'ckd2cckd64', 00H
	ORG $+1
$SG169143 DB	'I', 00H
	ORG $+2
$SG169125 DB	'  -z       compress using zlib [default]', 00H
	ORG $+3
$SG169127 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169134 DB	'syntax', 00H
	ORG $+1
$SG169158 DB	'I', 00H
	ORG $+2
$SG169126 DB	'HHC02435I ', 00H
	ORG $+1
$SG169169 DB	'I', 00H
	ORG $+2
$SG169129 DB	'  -bz2     compress using bzip2', 00H
$SG169130 DB	'HHC02435I ', 00H
	ORG $+1
$SG169131 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169135 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169142 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169133 DB	'HHC02435%s Usage: ckd2cckd [-options] ifile ofile', 0aH, 'H'
	DB	'HC02435I Copy a ckd dasd file to a compressed ckd dasd file', 0aH
	DB	'HHC02435I   ifile    input ckd dasd file', 0aH, 'HHC02435I   '
	DB	'ofile    output compressed ckd dasd file', 0aH, 'HHC02435I op'
	DB	'tions:', 0aH, 'HHC02435I   -h       display this help and qui'
	DB	't', 0aH, 'HHC02435I   -q       quiet mode, don''t display sta'
	DB	'tus', 0aH, 'HHC02435I   -r       replace the output file if i'
	DB	't exists', 0aH, '%s%sHHC02435I   -0       don''t compress tra'
	DB	'ck images', 0aH, 'HHC02435I   -cyls n  size of output file', 0aH
	DB	'HHC02435I   -a       output file will have alt cyls', 0aH, 00H
	ORG $+1
$SG169186 DB	'I', 00H
	ORG $+2
$SG169138 DB	'cckd642ckd', 00H
	ORG $+5
$SG169140 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169141 DB	'HHC02436I ', 00H
	ORG $+1
$SG169145 DB	'syntax', 00H
	ORG $+5
$SG169144 DB	'HHC02436%s Usage: cckd2ckd [-options] ifile [sf=sfile] o'
	DB	'file', 0aH, 'HHC02436I Copy a compressed ckd file to a ckd fi'
	DB	'le', 0aH, 'HHC02436I   ifile    input compressed ckd dasd fil'
	DB	'e', 0aH, 'HHC02436I   sfile    input compressed ckd shadow fi'
	DB	'le (optional)', 0aH, 'HHC02436I   ofile    output ckd dasd fi'
	DB	'le', 0aH, 'HHC02436I options:', 0aH, 'HHC02436I   -h       di'
	DB	'splay this help and quit', 0aH, 'HHC02436I   -q       quiet m'
	DB	'ode, don''t display status', 0aH, 'HHC02436I   -r       repla'
	DB	'ce the output file if it exists', 0aH, '%sHHC02436I   -cyls n'
	DB	'  size of output file', 0aH, 'HHC02436I   -a       output fil'
	DB	'e will have alt cyls', 0aH, 00H
	ORG $+6
$SG169146 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169149 DB	'fba2cfba64', 00H
	ORG $+5
$SG169151 DB	'  -z       compress using zlib [default]', 00H
	ORG $+7
$SG169152 DB	'HHC02437I ', 00H
	ORG $+1
$SG169153 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169155 DB	'  -bz2     compress using bzip2', 00H
$SG169156 DB	'HHC02437I ', 00H
	ORG $+1
$SG169157 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169160 DB	'syntax', 00H
	ORG $+5
$SG169159 DB	'HHC02437%s Usage: fba2cfba [-options] ifile ofile', 0aH, 'H'
	DB	'HC02437I Copy a fba dasd file to a compressed fba dasd file', 0aH
	DB	'HHC02437I   ifile    input fba dasd file', 0aH, 'HHC02437I   '
	DB	'ofile    output compressed fba dasd file', 0aH, 'HHC02437I op'
	DB	'tions:', 0aH, 'HHC02437I   -h       display this help and qui'
	DB	't', 0aH, 'HHC02437I   -q       quiet mode, don''t display sta'
	DB	'tus', 0aH, 'HHC02437I   -r       replace the output file if i'
	DB	't exists', 0aH, '%s%sHHC02437I   -0       don''t compress tra'
	DB	'ck images', 0aH, 'HHC02437I   -blks n  size of output file', 0aH
	DB	00H
	ORG $+1
$SG169161 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169164 DB	'cfba642fba', 00H
	ORG $+5
$SG169166 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169167 DB	'HHC02438I ', 00H
	ORG $+1
$SG169168 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG169171 DB	'syntax', 00H
	ORG $+5
$SG169170 DB	'HHC02438%s Usage: cfba2fba [-options] ifile [sf=sfile] o'
	DB	'file', 0aH, 'HHC02438I Copy a compressed fba file to a fba fi'
	DB	'le', 0aH, 'HHC02438I   ifile    input compressed fba dasd fil'
	DB	'e', 0aH, 'HHC02438I   sfile    input compressed fba shadow fi'
	DB	'le (optional)', 0aH, 'HHC02438I   ofile    output fba dasd fi'
	DB	'le', 0aH, 'HHC02438I options:', 0aH, 'HHC02438I   -h       di'
	DB	'splay this help and quit', 0aH, 'HHC02438I   -q       quiet m'
	DB	'ode, don''t display status', 0aH, 'HHC02438I   -r       repla'
	DB	'ce the output file if it exists', 0aH, '%sHHC02438I   -blks n'
	DB	'  size of output file', 0aH, 00H
	ORG $+2
$SG169172 DB	'dasdcopy64.c', 00H
	ORG $+3
$SG169174 DB	'  -z       compress using zlib [default]', 00H
	ORG $+7
$SG169175 DB	'HHC02439I ', 00H
	ORG $+1
$SG169176 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169178 DB	'  -bz2     compress using bzip2', 00H
$SG169179 DB	'HHC02439I ', 00H
	ORG $+1
$SG169180 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169182 DB	'  -lfs     create single large output file', 00H
	ORG $+5
$SG169183 DB	'HHC02439I ', 00H
	ORG $+1
$SG169184 DB	'%s%s', 0aH, 00H
	ORG $+6
$SG169185 DB	'CKD, CKD64, CCKD, CCKD64, FBA, FBA64, CFBA, CFBA64', 00H
	ORG $+5
$SG169187 DB	'HHC02439%s Usage: %s [-options] ifile [sf=sfile] ofile', 0aH
	DB	'HHC02439I Copy a dasd file to another dasd file', 0aH, 'HHC02'
	DB	'439I   ifile    input dasd file   (required)', 0aH, 'HHC02439'
	DB	'I   sfile    input shadow file (optional) (see note)', 0aH, 'H'
	DB	'HC02439I   ofile    output dasd file  (required)', 0aH, 'HHC0'
	DB	'2439I Options:', 0aH, 'HHC02439I   -h       display this help'
	DB	' and quit', 0aH, 'HHC02439I   -q       quiet mode, don''t dis'
	DB	'play status', 0aH, 'HHC02439I   -r       replace the output f'
	DB	'ile if it exists', 0aH, '%s%sHHC02439I   -0       don''t comp'
	DB	'ress output', 0aH, 'HHC02439I   -blks n  size of output fba f'
	DB	'ile', 0aH, 'HHC02439I   -cyls n  size of output ckd file', 0aH
	DB	'HHC02439I   -a       output ckd file will have alt cyls', 0aH
	DB	'%sHHC02439I   -o type  output file type (%s)', 0aH, 'HHC02439'
	DB	'I', 0aH, 'HHC02439I Note: input shadow files will, as part of'
	DB	' the copy', 0aH, 'HHC02439I operation, have their data automa'
	DB	'tically merged into', 0aH, 'HHC02439I the resulting output fi'
	DB	'le.', 0aH, 00H
	ORG $+3
$SG169188 DB	'syntax', 00H
	ORG $+1
$SG169189 DB	'dasdcopy64.c', 00H
	ORG $+3
?indic@?5??status@@9@9 DB '|/-\', 00H			; `status'::`6'::indic
	ORG $+3
$SG169208 DB	'TRK=%d', 0aH, 00H
$SG169209 DB	0dH, '%c %3d%% %7d', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01bH
	DD	01fcdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:syntax
	DD	025H
	DD	067cH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$syntax DD 022d19H
	DD	037011bH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$status DD 010c01H
	DD	0620cH
$unwind$nulltrk DD 011701H
	DD	0a217H
$unwind$main DD	032319H
	DD	0540111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0290H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy64.c
_TEXT	SEGMENT
out$ = 112
unitstat$ = 116
in$ = 120
idev$ = 128
i$ = 136
rc$ = 140
cyls$ = 144
n$ = 148
comp$ = 152
blks$ = 156
ckddasd$ = 160
pgm$ = 168
max$ = 176
imgtyp$ = 180
lfs$ = 184
ofile$ = 192
r$ = 200
nullfmt$ = 204
quiet$ = 208
icif$ = 216
fd$ = 224
tv487 = 228
ifile$ = 232
alt$ = 240
ckd$ = 248
fba_bytes_remaining$ = 256
ocif$ = 264
sfile$ = 272
odev$ = 280
fba$ = 288
tv644 = 296
tv980 = 300
tv1073 = 304
tv196 = 312
tv226 = 320
tv978 = 328
tv984 = 336
tv1077 = 344
tv420 = 352
tv439 = 360
tv953 = 368
buf$1 = 376
pathname$ = 384
__$ArrayPad$ = 656
argc$ = 688
argv$ = 696
main	PROC

; 61   : {

$LN202:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 62   : char           *pgm;                    /* less any extension (.ext) */
; 63   : int             ckddasd=-1;             /* 1=CKD  0=FBA              */

  00023	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ckddasd$[rsp], -1

; 64   : int             rc;                     /* Return code               */
; 65   : int             quiet=0;                /* 1=Don't display status    */

  0002e	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 0

; 66   : int             comp=255;               /* Compression algorithm     */

  00039	c7 84 24 98 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR comp$[rsp], 255 ; 000000ffH

; 67   : int             cyls=-1, blks=-1;       /* Size of output file       */

  00044	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR cyls$[rsp], -1
  0004f	c7 84 24 9c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR blks$[rsp], -1

; 68   : int             lfs=0;                  /* 1=Create 1 large file     */

  0005a	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 69   : int             alt=0;                  /* 1=Create alt cyls         */

  00065	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR alt$[rsp], 0

; 70   : int             r=0;                    /* 1=Replace output file     */

  00070	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR r$[rsp], 0

; 71   : int             in=0, out=0;            /* Input/Output file types   */

  0007b	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR in$[rsp], 0
  00083	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR out$[rsp], 0

; 72   : int             fd;                     /* Input file descriptor     */
; 73   : char           *ifile, *ofile;          /* -> Input/Output file names*/
; 74   : char           *sfile=NULL;             /* -> Input shadow file name */

  0008b	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR sfile$[rsp], 0

; 75   : CIFBLK         *icif, *ocif;            /* -> Input/Output CIFBLK    */
; 76   : DEVBLK         *idev, *odev;            /* -> Input/Output DEVBLK    */
; 77   : 
; 78   : CKDDEV         *ckd=NULL;               /* -> CKD device table entry */

  00097	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ckd$[rsp], 0

; 79   : FBADEV         *fba=NULL;               /* -> FBA device table entry */

  000a3	48 c7 84 24 20
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba$[rsp], 0

; 80   : int             i, n, max;              /* Loop index, limits        */
; 81   : BYTE            unitstat;               /* Device unit status        */
; 82   : U32             imgtyp;                 /* Dasd file image type      */
; 83   : U64             fba_bytes_remaining=0;  /* FBA bytes to be copied    */

  000af	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba_bytes_remaining$[rsp], 0

; 84   : int             nullfmt = CKD_NULLTRK_FMT0; /* Null track format     */

  000bb	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 0

; 85   : char            pathname[MAX_PATH];     /* file path in host format  */
; 86   : 
; 87   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  000c6	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168736
  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168737
  000e1	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000e9	8b 8c 24 b0 02
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  000f6	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 88   : 
; 89   :     if (strcasecmp(pgm, "ckd2cckd64") == 0)

  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168740
  00104	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00112	85 c0		 test	 eax, eax
  00114	75 12		 jne	 SHORT $LN19@main

; 90   :     {
; 91   :         in  = CKD64;

  00116	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR in$[rsp], 16

; 92   :         out = CCKD64;

  0011e	c7 44 24 70 20
	00 00 00	 mov	 DWORD PTR out$[rsp], 32	; 00000020H

; 93   :     }

  00126	eb 7f		 jmp	 SHORT $LN20@main
$LN19@main:

; 94   :     else if (strcasecmp(pgm, "cckd642ckd") == 0)

  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168743
  0012f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0013d	85 c0		 test	 eax, eax
  0013f	75 12		 jne	 SHORT $LN21@main

; 95   :     {
; 96   :         in  = CCKD64;

  00141	c7 44 24 78 20
	00 00 00	 mov	 DWORD PTR in$[rsp], 32	; 00000020H

; 97   :         out = CKD64;

  00149	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR out$[rsp], 16

; 98   :     }

  00151	eb 54		 jmp	 SHORT $LN22@main
$LN21@main:

; 99   :     else if (strcasecmp(pgm, "fba2cfba64") == 0)

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168746
  0015a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00168	85 c0		 test	 eax, eax
  0016a	75 12		 jne	 SHORT $LN23@main

; 100  :     {
; 101  :         in  = FBA64;

  0016c	c7 44 24 78 40
	00 00 00	 mov	 DWORD PTR in$[rsp], 64	; 00000040H

; 102  :         out = CFBA64;

  00174	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR out$[rsp], 128 ; 00000080H

; 103  :     }

  0017c	eb 29		 jmp	 SHORT $LN24@main
$LN23@main:

; 104  :     else if (strcasecmp(pgm, "cfba642fba") == 0)

  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168748
  00185	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00193	85 c0		 test	 eax, eax
  00195	75 10		 jne	 SHORT $LN25@main

; 105  :     {
; 106  :         in  = CFBA64;

  00197	c7 44 24 78 80
	00 00 00	 mov	 DWORD PTR in$[rsp], 128	; 00000080H

; 107  :         out = FBA64;

  0019f	c7 44 24 70 40
	00 00 00	 mov	 DWORD PTR out$[rsp], 64	; 00000040H
$LN25@main:
$LN24@main:
$LN22@main:
$LN20@main:

; 108  :     }
; 109  : 
; 110  :     /* Process the arguments */
; 111  :     for (argc--, argv++ ; argc > 0 ; argc--, argv++)

  001a7	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  001ae	ff c8		 dec	 eax
  001b0	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  001b7	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001bf	48 83 c0 08	 add	 rax, 8
  001c3	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
  001cb	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  001cd	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  001d4	ff c8		 dec	 eax
  001d6	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  001dd	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001e5	48 83 c0 08	 add	 rax, 8
  001e9	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  001f1	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  001f9	0f 8e 37 07 00
	00		 jle	 $LN3@main

; 112  :     {
; 113  :         if (argv[0][0] != '-') break;

  001ff	b8 08 00 00 00	 mov	 eax, 8
  00204	48 6b c0 00	 imul	 rax, rax, 0
  00208	b9 01 00 00 00	 mov	 ecx, 1
  0020d	48 6b c9 00	 imul	 rcx, rcx, 0
  00211	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00219	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0021d	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00221	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00224	74 05		 je	 SHORT $LN26@main
  00226	e9 0b 07 00 00	 jmp	 $LN3@main
$LN26@main:

; 114  :         if (strcmp(argv[0], "-h") == 0)

  0022b	b8 08 00 00 00	 mov	 eax, 8
  00230	48 6b c0 00	 imul	 rax, rax, 0
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168752
  0023b	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00243	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00247	e8 00 00 00 00	 call	 strcmp
  0024c	85 c0		 test	 eax, eax
  0024e	75 1b		 jne	 SHORT $LN27@main

; 115  :         {
; 116  :             syntax( pgm, NULL );

  00250	33 d2		 xor	 edx, edx
  00252	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0025a	e8 00 00 00 00	 call	 syntax

; 117  :             return 0;

  0025f	33 c0		 xor	 eax, eax
  00261	e9 67 1d 00 00	 jmp	 $LN1@main

; 118  :         }

  00266	e9 c6 06 00 00	 jmp	 $LN28@main
$LN27@main:

; 119  :         else if (strcmp(argv[0], "-q") == 0
; 120  :               || strcmp(argv[0], "-quiet") == 0)

  0026b	b8 08 00 00 00	 mov	 eax, 8
  00270	48 6b c0 00	 imul	 rax, rax, 0
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168756
  0027b	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00283	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00287	e8 00 00 00 00	 call	 strcmp
  0028c	85 c0		 test	 eax, eax
  0028e	74 25		 je	 SHORT $LN31@main
  00290	b8 08 00 00 00	 mov	 eax, 8
  00295	48 6b c0 00	 imul	 rax, rax, 0
  00299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168757
  002a0	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a8	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002ac	e8 00 00 00 00	 call	 strcmp
  002b1	85 c0		 test	 eax, eax
  002b3	75 10		 jne	 SHORT $LN29@main
$LN31@main:

; 121  :             quiet = 1;

  002b5	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 1
  002c0	e9 6c 06 00 00	 jmp	 $LN30@main
$LN29@main:

; 122  :         else if (strcmp(argv[0], "-r") == 0)

  002c5	b8 08 00 00 00	 mov	 eax, 8
  002ca	48 6b c0 00	 imul	 rax, rax, 0
  002ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168760
  002d5	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002dd	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002e1	e8 00 00 00 00	 call	 strcmp
  002e6	85 c0		 test	 eax, eax
  002e8	75 10		 jne	 SHORT $LN32@main

; 123  :             r = 1;

  002ea	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR r$[rsp], 1
  002f5	e9 37 06 00 00	 jmp	 $LN33@main
$LN32@main:

; 124  : #ifdef CCKD_COMPRESS_ZLIB
; 125  :         else if (strcmp(argv[0], "-z") == 0)

  002fa	b8 08 00 00 00	 mov	 eax, 8
  002ff	48 6b c0 00	 imul	 rax, rax, 0
  00303	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168763
  0030a	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00312	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00316	e8 00 00 00 00	 call	 strcmp
  0031b	85 c0		 test	 eax, eax
  0031d	75 10		 jne	 SHORT $LN34@main

; 126  :             comp = CCKD_COMPRESS_ZLIB;

  0031f	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR comp$[rsp], 1
  0032a	e9 02 06 00 00	 jmp	 $LN35@main
$LN34@main:

; 127  : #endif
; 128  : #ifdef CCKD_COMPRESS_BZIP2
; 129  :         else if (strcmp(argv[0], "-bz2") == 0)

  0032f	b8 08 00 00 00	 mov	 eax, 8
  00334	48 6b c0 00	 imul	 rax, rax, 0
  00338	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168766
  0033f	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00347	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0034b	e8 00 00 00 00	 call	 strcmp
  00350	85 c0		 test	 eax, eax
  00352	75 10		 jne	 SHORT $LN36@main

; 130  :             comp = CCKD_COMPRESS_BZIP2;

  00354	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR comp$[rsp], 2
  0035f	e9 cd 05 00 00	 jmp	 $LN37@main
$LN36@main:

; 131  : #endif
; 132  :         else if (strcmp(argv[0], "-0") == 0)

  00364	b8 08 00 00 00	 mov	 eax, 8
  00369	48 6b c0 00	 imul	 rax, rax, 0
  0036d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168769
  00374	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0037c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00380	e8 00 00 00 00	 call	 strcmp
  00385	85 c0		 test	 eax, eax
  00387	75 10		 jne	 SHORT $LN38@main

; 133  :             comp = CCKD_COMPRESS_NONE;

  00389	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR comp$[rsp], 0
  00394	e9 98 05 00 00	 jmp	 $LN39@main
$LN38@main:

; 134  :         else if ((strcmp(argv[0], "-cyl") == 0
; 135  :                || strcmp(argv[0], "-cyls") == 0) && cyls < 0)

  00399	b8 08 00 00 00	 mov	 eax, 8
  0039e	48 6b c0 00	 imul	 rax, rax, 0
  003a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168773
  003a9	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003b1	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003b5	e8 00 00 00 00	 call	 strcmp
  003ba	85 c0		 test	 eax, eax
  003bc	74 29		 je	 SHORT $LN42@main
  003be	b8 08 00 00 00	 mov	 eax, 8
  003c3	48 6b c0 00	 imul	 rax, rax, 0
  003c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168774
  003ce	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003d6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003da	e8 00 00 00 00	 call	 strcmp
  003df	85 c0		 test	 eax, eax
  003e1	0f 85 cd 00 00
	00		 jne	 $LN40@main
$LN42@main:
  003e7	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  003ef	0f 8d bf 00 00
	00		 jge	 $LN40@main

; 136  :         {
; 137  :             if (argc < 2 || (cyls = atoi(argv[1])) < 0)

  003f5	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  003fd	7c 2c		 jl	 SHORT $LN44@main
  003ff	b8 08 00 00 00	 mov	 eax, 8
  00404	48 6b c0 01	 imul	 rax, rax, 1
  00408	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00410	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0041a	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
  00421	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  00429	7d 60		 jge	 SHORT $LN43@main
$LN44@main:

; 138  :                 return syntax( pgm, "invalid %s argument: %s",

  0042b	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00433	7d 11		 jge	 SHORT $LN190@main
  00435	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168777
  0043c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
  00444	eb 1d		 jmp	 SHORT $LN191@main
$LN190@main:
  00446	b8 08 00 00 00	 mov	 eax, 8
  0044b	48 6b c0 01	 imul	 rax, rax, 1
  0044f	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00457	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0045b	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
$LN191@main:
  00463	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR tv196[rsp]
  0046b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168778
  00472	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168779
  00479	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00481	e8 00 00 00 00	 call	 syntax
  00486	e9 42 1b 00 00	 jmp	 $LN1@main
$LN43@main:

; 139  :                     "-cyls", argc < 2 ? "(missing)" : argv[1] );
; 140  :             argc--; argv++;

  0048b	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00492	ff c8		 dec	 eax
  00494	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0049b	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004a3	48 83 c0 08	 add	 rax, 8
  004a7	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 141  :         }

  004af	e9 7d 04 00 00	 jmp	 $LN41@main
$LN40@main:

; 142  :         else if ((strcmp(argv[0], "-blk") == 0
; 143  :                || strcmp(argv[0], "-blks") == 0) && blks < 0)

  004b4	b8 08 00 00 00	 mov	 eax, 8
  004b9	48 6b c0 00	 imul	 rax, rax, 0
  004bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168783
  004c4	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004cc	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  004d0	e8 00 00 00 00	 call	 strcmp
  004d5	85 c0		 test	 eax, eax
  004d7	74 29		 je	 SHORT $LN47@main
  004d9	b8 08 00 00 00	 mov	 eax, 8
  004de	48 6b c0 00	 imul	 rax, rax, 0
  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168784
  004e9	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004f1	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  004f5	e8 00 00 00 00	 call	 strcmp
  004fa	85 c0		 test	 eax, eax
  004fc	0f 85 cd 00 00
	00		 jne	 $LN45@main
$LN47@main:
  00502	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  0050a	0f 8d bf 00 00
	00		 jge	 $LN45@main

; 144  :         {
; 145  :             if (argc < 2 || (blks = atoi(argv[1])) < 0)

  00510	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00518	7c 2c		 jl	 SHORT $LN49@main
  0051a	b8 08 00 00 00	 mov	 eax, 8
  0051f	48 6b c0 01	 imul	 rax, rax, 1
  00523	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0052b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0052f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00535	89 84 24 9c 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
  0053c	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  00544	7d 60		 jge	 SHORT $LN48@main
$LN49@main:

; 146  :                 return syntax( pgm, "invalid %s argument: %s",

  00546	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0054e	7d 11		 jge	 SHORT $LN192@main
  00550	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168787
  00557	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
  0055f	eb 1d		 jmp	 SHORT $LN193@main
$LN192@main:
  00561	b8 08 00 00 00	 mov	 eax, 8
  00566	48 6b c0 01	 imul	 rax, rax, 1
  0056a	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00572	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00576	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
$LN193@main:
  0057e	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR tv226[rsp]
  00586	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168788
  0058d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168789
  00594	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0059c	e8 00 00 00 00	 call	 syntax
  005a1	e9 27 1a 00 00	 jmp	 $LN1@main
$LN48@main:

; 147  :                     "-blks", argc < 2 ? "(missing)" : argv[1] );
; 148  :             argc--; argv++;

  005a6	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  005ad	ff c8		 dec	 eax
  005af	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  005b6	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005be	48 83 c0 08	 add	 rax, 8
  005c2	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 149  :         }

  005ca	e9 62 03 00 00	 jmp	 $LN46@main
$LN45@main:

; 150  :         else if (strcmp(argv[0], "-a") == 0
; 151  :               || strcmp(argv[0], "-alt") == 0
; 152  :               || strcmp(argv[0], "-alts") == 0)

  005cf	b8 08 00 00 00	 mov	 eax, 8
  005d4	48 6b c0 00	 imul	 rax, rax, 0
  005d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168793
  005df	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005e7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  005eb	e8 00 00 00 00	 call	 strcmp
  005f0	85 c0		 test	 eax, eax
  005f2	74 4a		 je	 SHORT $LN52@main
  005f4	b8 08 00 00 00	 mov	 eax, 8
  005f9	48 6b c0 00	 imul	 rax, rax, 0
  005fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168794
  00604	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0060c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00610	e8 00 00 00 00	 call	 strcmp
  00615	85 c0		 test	 eax, eax
  00617	74 25		 je	 SHORT $LN52@main
  00619	b8 08 00 00 00	 mov	 eax, 8
  0061e	48 6b c0 00	 imul	 rax, rax, 0
  00622	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168795
  00629	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00631	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00635	e8 00 00 00 00	 call	 strcmp
  0063a	85 c0		 test	 eax, eax
  0063c	75 10		 jne	 SHORT $LN50@main
$LN52@main:

; 153  :             alt = 1;

  0063e	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR alt$[rsp], 1
  00649	e9 e3 02 00 00	 jmp	 $LN51@main
$LN50@main:

; 154  :         else if (strcmp(argv[0], "-lfs") == 0)

  0064e	b8 08 00 00 00	 mov	 eax, 8
  00653	48 6b c0 00	 imul	 rax, rax, 0
  00657	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168798
  0065e	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00666	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0066a	e8 00 00 00 00	 call	 strcmp
  0066f	85 c0		 test	 eax, eax
  00671	75 10		 jne	 SHORT $LN53@main

; 155  :             lfs = 1;

  00673	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  0067e	e9 ae 02 00 00	 jmp	 $LN54@main
$LN53@main:

; 156  :         else if (out == 0 && strcmp(argv[0], "-o") == 0)

  00683	83 7c 24 70 00	 cmp	 DWORD PTR out$[rsp], 0
  00688	0f 85 75 02 00
	00		 jne	 $LN55@main
  0068e	b8 08 00 00 00	 mov	 eax, 8
  00693	48 6b c0 00	 imul	 rax, rax, 0
  00697	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168801
  0069e	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006a6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  006aa	e8 00 00 00 00	 call	 strcmp
  006af	85 c0		 test	 eax, eax
  006b1	0f 85 4c 02 00
	00		 jne	 $LN55@main

; 157  :         {
; 158  :             if (argc < 2)

  006b7	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  006bf	7d 27		 jge	 SHORT $LN57@main

; 159  :                 return syntax( pgm, "invalid %s argument: %s",

  006c1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168803
  006c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168804
  006cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168805
  006d6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  006de	e8 00 00 00 00	 call	 syntax
  006e3	e9 e5 18 00 00	 jmp	 $LN1@main
$LN57@main:

; 160  :                     "-o", "(missing)" );
; 161  :             if (out != 0)

  006e8	83 7c 24 70 00	 cmp	 DWORD PTR out$[rsp], 0
  006ed	74 27		 je	 SHORT $LN58@main

; 162  :                 return syntax( pgm, "invalid %s argument: %s",

  006ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168807
  006f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168808
  006fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168809
  00704	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0070c	e8 00 00 00 00	 call	 syntax
  00711	e9 b7 18 00 00	 jmp	 $LN1@main
$LN58@main:

; 163  :                     "-o", "already previously specified" );
; 164  : 
; 165  :                  if (strcasecmp( argv[1], "ckd"    ) == 0) out = CKD;

  00716	b8 08 00 00 00	 mov	 eax, 8
  0071b	48 6b c0 01	 imul	 rax, rax, 1
  0071f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168812
  00726	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0072e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00732	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00738	85 c0		 test	 eax, eax
  0073a	75 0d		 jne	 SHORT $LN59@main
  0073c	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR out$[rsp], 1
  00744	e9 94 01 00 00	 jmp	 $LN60@main
$LN59@main:

; 166  :             else if (strcasecmp( argv[1], "cckd"   ) == 0) out = CCKD;

  00749	b8 08 00 00 00	 mov	 eax, 8
  0074e	48 6b c0 01	 imul	 rax, rax, 1
  00752	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168815
  00759	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00761	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00765	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0076b	85 c0		 test	 eax, eax
  0076d	75 0d		 jne	 SHORT $LN61@main
  0076f	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR out$[rsp], 2
  00777	e9 61 01 00 00	 jmp	 $LN62@main
$LN61@main:

; 167  :             else if (strcasecmp( argv[1], "fba"    ) == 0) out = FBA;

  0077c	b8 08 00 00 00	 mov	 eax, 8
  00781	48 6b c0 01	 imul	 rax, rax, 1
  00785	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168818
  0078c	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00794	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0079e	85 c0		 test	 eax, eax
  007a0	75 0d		 jne	 SHORT $LN63@main
  007a2	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR out$[rsp], 4
  007aa	e9 2e 01 00 00	 jmp	 $LN64@main
$LN63@main:

; 168  :             else if (strcasecmp( argv[1], "cfba"   ) == 0) out = CFBA;

  007af	b8 08 00 00 00	 mov	 eax, 8
  007b4	48 6b c0 01	 imul	 rax, rax, 1
  007b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168821
  007bf	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007c7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  007cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007d1	85 c0		 test	 eax, eax
  007d3	75 0d		 jne	 SHORT $LN65@main
  007d5	c7 44 24 70 08
	00 00 00	 mov	 DWORD PTR out$[rsp], 8
  007dd	e9 fb 00 00 00	 jmp	 $LN66@main
$LN65@main:

; 169  :             else if (strcasecmp( argv[1], "ckd64"  ) == 0) out = CKD64;

  007e2	b8 08 00 00 00	 mov	 eax, 8
  007e7	48 6b c0 01	 imul	 rax, rax, 1
  007eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168824
  007f2	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007fa	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  007fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00804	85 c0		 test	 eax, eax
  00806	75 0d		 jne	 SHORT $LN67@main
  00808	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR out$[rsp], 16
  00810	e9 c8 00 00 00	 jmp	 $LN68@main
$LN67@main:

; 170  :             else if (strcasecmp( argv[1], "cckd64" ) == 0) out = CCKD64;

  00815	b8 08 00 00 00	 mov	 eax, 8
  0081a	48 6b c0 01	 imul	 rax, rax, 1
  0081e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168827
  00825	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0082d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00831	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00837	85 c0		 test	 eax, eax
  00839	75 0d		 jne	 SHORT $LN69@main
  0083b	c7 44 24 70 20
	00 00 00	 mov	 DWORD PTR out$[rsp], 32	; 00000020H
  00843	e9 95 00 00 00	 jmp	 $LN70@main
$LN69@main:

; 171  :             else if (strcasecmp( argv[1], "fba64"  ) == 0) out = FBA64;

  00848	b8 08 00 00 00	 mov	 eax, 8
  0084d	48 6b c0 01	 imul	 rax, rax, 1
  00851	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168830
  00858	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00860	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00864	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0086a	85 c0		 test	 eax, eax
  0086c	75 0a		 jne	 SHORT $LN71@main
  0086e	c7 44 24 70 40
	00 00 00	 mov	 DWORD PTR out$[rsp], 64	; 00000040H
  00876	eb 65		 jmp	 SHORT $LN72@main
$LN71@main:

; 172  :             else if (strcasecmp( argv[1], "cfba64" ) == 0) out = CFBA64;

  00878	b8 08 00 00 00	 mov	 eax, 8
  0087d	48 6b c0 01	 imul	 rax, rax, 1
  00881	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168833
  00888	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00890	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00894	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0089a	85 c0		 test	 eax, eax
  0089c	75 0a		 jne	 SHORT $LN73@main
  0089e	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR out$[rsp], 128 ; 00000080H
  008a6	eb 35		 jmp	 SHORT $LN74@main
$LN73@main:

; 173  :             else
; 174  :                 return syntax( pgm, "invalid %s argument: %s",

  008a8	b8 08 00 00 00	 mov	 eax, 8
  008ad	48 6b c0 01	 imul	 rax, rax, 1
  008b1	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008b9	4c 8b 0c 01	 mov	 r9, QWORD PTR [rcx+rax]
  008bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168834
  008c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168835
  008cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  008d3	e8 00 00 00 00	 call	 syntax
  008d8	e9 f0 16 00 00	 jmp	 $LN1@main
$LN74@main:
$LN72@main:
$LN70@main:
$LN68@main:
$LN66@main:
$LN64@main:
$LN62@main:
$LN60@main:

; 175  :                     "-o", argv[1] );
; 176  : 
; 177  :             argc--; argv++;

  008dd	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  008e4	ff c8		 dec	 eax
  008e6	89 84 24 b0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  008ed	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  008f5	48 83 c0 08	 add	 rax, 8
  008f9	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 178  :         }

  00901	eb 2e		 jmp	 SHORT $LN56@main
$LN55@main:

; 179  :         else
; 180  :             return syntax( pgm, "unrecognized/unsupported option: %s",

  00903	b8 08 00 00 00	 mov	 eax, 8
  00908	48 6b c0 00	 imul	 rax, rax, 0
  0090c	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00914	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00918	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168836
  0091f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00927	e8 00 00 00 00	 call	 syntax
  0092c	e9 9c 16 00 00	 jmp	 $LN1@main
$LN56@main:
$LN54@main:
$LN51@main:
$LN46@main:
$LN41@main:
$LN39@main:
$LN37@main:
$LN35@main:
$LN33@main:
$LN30@main:
$LN28@main:

; 181  :                 argv[0] );
; 182  :     }

  00931	e9 97 f8 ff ff	 jmp	 $LN2@main
$LN3@main:

; 183  : 
; 184  :     /* Get the file names:
; 185  :        input-file [sf=shadow-file] output-file   */
; 186  :     if (argc < 2)

  00936	83 bc 24 b0 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0093e	7d 20		 jge	 SHORT $LN75@main

; 187  :         return syntax( pgm, "%s", "missing input-file specification" );

  00940	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168838
  00947	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168839
  0094e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00956	e8 00 00 00 00	 call	 syntax
  0095b	e9 6d 16 00 00	 jmp	 $LN1@main
$LN75@main:

; 188  :     if (argc > 3)

  00960	83 bc 24 b0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00968	7e 2e		 jle	 SHORT $LN76@main

; 189  :         return syntax( pgm, "extraneous parameter: %s", argv[2] );

  0096a	b8 08 00 00 00	 mov	 eax, 8
  0096f	48 6b c0 02	 imul	 rax, rax, 2
  00973	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0097b	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  0097f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168841
  00986	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0098e	e8 00 00 00 00	 call	 syntax
  00993	e9 35 16 00 00	 jmp	 $LN1@main
$LN76@main:

; 190  :     ifile = argv[0];

  00998	b8 08 00 00 00	 mov	 eax, 8
  0099d	48 6b c0 00	 imul	 rax, rax, 0
  009a1	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009a9	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  009ad	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ifile$[rsp], rax

; 191  :     if (argc < 3)

  009b5	83 bc 24 b0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  009bd	7d 22		 jge	 SHORT $LN77@main

; 192  :         ofile = argv[1];

  009bf	b8 08 00 00 00	 mov	 eax, 8
  009c4	48 6b c0 01	 imul	 rax, rax, 1
  009c8	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009d0	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  009d4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR ofile$[rsp], rax
  009dc	e9 b3 00 00 00	 jmp	 $LN78@main
$LN77@main:

; 193  :     else
; 194  :     {
; 195  :         if (strlen(argv[1]) < 4 || memcmp(argv[1], "sf=", 3) != 0)

  009e1	b8 08 00 00 00	 mov	 eax, 8
  009e6	48 6b c0 01	 imul	 rax, rax, 1
  009ea	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009f2	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  009f6	e8 00 00 00 00	 call	 strlen
  009fb	48 83 f8 04	 cmp	 rax, 4
  009ff	72 2b		 jb	 SHORT $LN80@main
  00a01	b8 08 00 00 00	 mov	 eax, 8
  00a06	48 6b c0 01	 imul	 rax, rax, 1
  00a0a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00a10	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168846
  00a17	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a1f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00a23	e8 00 00 00 00	 call	 memcmp
  00a28	85 c0		 test	 eax, eax
  00a2a	74 2e		 je	 SHORT $LN79@main
$LN80@main:

; 196  :             return syntax( pgm, "invalid shadow file specification: %s",

  00a2c	b8 08 00 00 00	 mov	 eax, 8
  00a31	48 6b c0 01	 imul	 rax, rax, 1
  00a35	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a3d	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00a41	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168847
  00a48	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00a50	e8 00 00 00 00	 call	 syntax
  00a55	e9 73 15 00 00	 jmp	 $LN1@main
$LN79@main:

; 197  :                 argv[1] );
; 198  : 
; 199  :         sfile = argv[1];

  00a5a	b8 08 00 00 00	 mov	 eax, 8
  00a5f	48 6b c0 01	 imul	 rax, rax, 1
  00a63	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a6b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00a6f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR sfile$[rsp], rax

; 200  :         ofile = argv[2];

  00a77	b8 08 00 00 00	 mov	 eax, 8
  00a7c	48 6b c0 02	 imul	 rax, rax, 2
  00a80	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a88	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00a8c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR ofile$[rsp], rax
$LN78@main:

; 201  :     }
; 202  : 
; 203  :     /* If we don't know what the input file is then find out */
; 204  :     if (!in)

  00a94	83 7c 24 78 00	 cmp	 DWORD PTR in$[rsp], 0
  00a99	0f 85 ee 02 00
	00		 jne	 $LN81@main

; 205  :     {
; 206  :         BYTE buf[8];
; 207  : 
; 208  :         hostpath( pathname, ifile, sizeof( pathname ));

  00a9f	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00aa5	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ifile$[rsp]
  00aad	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00ab5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 209  : 
; 210  :         if ((fd = HOPEN( pathname, O_RDONLY | O_BINARY )) < 0)

  00abb	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00ac0	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00ac8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00ace	89 84 24 e0 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax
  00ad5	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  00add	0f 8d 80 00 00
	00		 jge	 $LN82@main

; 211  :         {
; 212  :             // "Error in function %s: %s"
; 213  :             FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  00ae3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ae9	8b 08		 mov	 ecx, DWORD PTR [rax]
  00aeb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00af1	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv420[rsp], rax
  00af9	b9 02 00 00 00	 mov	 ecx, 2
  00afe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b04	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv420[rsp]
  00b0c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168850
  00b18	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168851
  00b24	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168852
  00b30	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b35	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b3a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b40	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168853
  00b47	ba d5 00 00 00	 mov	 edx, 213		; 000000d5H
  00b4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168854
  00b53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 214  :             return -1;

  00b59	b8 ff ff ff ff	 mov	 eax, -1
  00b5e	e9 6a 14 00 00	 jmp	 $LN1@main
$LN82@main:

; 215  :         }
; 216  : 
; 217  :         if ((rc = read( fd, buf, 8 )) < 8)

  00b63	41 b8 08 00 00
	00		 mov	 r8d, 8
  00b69	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR buf$1[rsp]
  00b71	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00b78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00b7e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00b85	83 bc 24 8c 00
	00 00 08	 cmp	 DWORD PTR rc$[rsp], 8
  00b8d	0f 8d 80 00 00
	00		 jge	 $LN83@main

; 218  :         {
; 219  :             // "Error in function %s: %s"
; 220  :             FWRMSG( stderr, HHC02412, "E", "read()", strerror( errno ));

  00b93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b99	8b 08		 mov	 ecx, DWORD PTR [rax]
  00b9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ba1	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv439[rsp], rax
  00ba9	b9 02 00 00 00	 mov	 ecx, 2
  00bae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bb4	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv439[rsp]
  00bbc	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00bc1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168856
  00bc8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bcd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168857
  00bd4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bd9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168858
  00be0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00be5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bea	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bf0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168859
  00bf7	ba dc 00 00 00	 mov	 edx, 220		; 000000dcH
  00bfc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168860
  00c03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 221  :             return -1;

  00c09	b8 ff ff ff ff	 mov	 eax, -1
  00c0e	e9 ba 13 00 00	 jmp	 $LN1@main
$LN83@main:

; 222  :         }
; 223  : 
; 224  :         imgtyp = dh_devid_typ( buf );

  00c13	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00c1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_typ
  00c21	89 84 24 b4 00
	00 00		 mov	 DWORD PTR imgtyp$[rsp], eax

; 225  : 
; 226  :              if (imgtyp & CKD_P370_TYP) in = CKD;

  00c28	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00c2f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00c34	85 c0		 test	 eax, eax
  00c36	74 0d		 je	 SHORT $LN84@main
  00c38	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR in$[rsp], 1
  00c40	e9 3b 01 00 00	 jmp	 $LN85@main
$LN84@main:

; 227  :         else if (imgtyp & CKD_C370_TYP) in = CCKD;

  00c45	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00c4c	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00c51	85 c0		 test	 eax, eax
  00c53	74 0d		 je	 SHORT $LN86@main
  00c55	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR in$[rsp], 2
  00c5d	e9 1e 01 00 00	 jmp	 $LN87@main
$LN86@main:

; 228  :         else if (imgtyp & FBA_P370_TYP) in = FBA;

  00c62	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00c69	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00c6e	85 c0		 test	 eax, eax
  00c70	74 0d		 je	 SHORT $LN88@main
  00c72	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR in$[rsp], 4
  00c7a	e9 01 01 00 00	 jmp	 $LN89@main
$LN88@main:

; 229  :         else if (imgtyp & FBA_C370_TYP) in = CFBA;

  00c7f	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00c86	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00c8b	85 c0		 test	 eax, eax
  00c8d	74 0d		 je	 SHORT $LN90@main
  00c8f	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR in$[rsp], 8
  00c97	e9 e4 00 00 00	 jmp	 $LN91@main
$LN90@main:

; 230  :         else if (imgtyp & CKD_P064_TYP) in = CKD64;

  00c9c	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00ca3	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00ca8	85 c0		 test	 eax, eax
  00caa	74 0d		 je	 SHORT $LN92@main
  00cac	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR in$[rsp], 16
  00cb4	e9 c7 00 00 00	 jmp	 $LN93@main
$LN92@main:

; 231  :         else if (imgtyp & CKD_C064_TYP) in = CCKD64;

  00cb9	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00cc0	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00cc5	85 c0		 test	 eax, eax
  00cc7	74 0d		 je	 SHORT $LN94@main
  00cc9	c7 44 24 78 20
	00 00 00	 mov	 DWORD PTR in$[rsp], 32	; 00000020H
  00cd1	e9 aa 00 00 00	 jmp	 $LN95@main
$LN94@main:

; 232  :         else if (imgtyp & FBA_P064_TYP) in = FBA64;

  00cd6	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00cdd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ce2	85 c0		 test	 eax, eax
  00ce4	74 0d		 je	 SHORT $LN96@main
  00ce6	c7 44 24 78 40
	00 00 00	 mov	 DWORD PTR in$[rsp], 64	; 00000040H
  00cee	e9 8d 00 00 00	 jmp	 $LN97@main
$LN96@main:

; 233  :         else if (imgtyp & FBA_C064_TYP) in = CFBA64;

  00cf3	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00cfa	83 e0 40	 and	 eax, 64			; 00000040H
  00cfd	85 c0		 test	 eax, eax
  00cff	74 0a		 je	 SHORT $LN98@main
  00d01	c7 44 24 78 80
	00 00 00	 mov	 DWORD PTR in$[rsp], 128	; 00000080H
  00d09	eb 75		 jmp	 SHORT $LN99@main
$LN98@main:

; 234  :         else
; 235  :         {
; 236  :             // "Dasd image file format unsupported or unrecognized: %s"
; 237  :             FWRMSG( stderr, HHC02424, "E", ifile );

  00d0b	b9 02 00 00 00	 mov	 ecx, 2
  00d10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d16	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  00d1e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d23	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168877
  00d2a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168878
  00d36	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d3b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d40	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d46	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168879
  00d4d	ba ed 00 00 00	 mov	 edx, 237		; 000000edH
  00d52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168880
  00d59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 238  :             close( fd );

  00d5f	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00d66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 239  :             return syntax( pgm, NULL );

  00d6c	33 d2		 xor	 edx, edx
  00d6e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00d76	e8 00 00 00 00	 call	 syntax
  00d7b	e9 4d 12 00 00	 jmp	 $LN1@main
$LN99@main:
$LN97@main:
$LN95@main:
$LN93@main:
$LN91@main:
$LN89@main:
$LN87@main:
$LN85@main:

; 240  :         }
; 241  : 
; 242  :         close( fd );

  00d80	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00d87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN81@main:

; 243  :     }
; 244  : 
; 245  :     /* If we don't know what the output file type is
; 246  :        then derive it from the input file type */
; 247  :     if (out == 0)

  00d8d	83 7c 24 70 00	 cmp	 DWORD PTR out$[rsp], 0
  00d92	0f 85 c8 00 00
	00		 jne	 $LN100@main

; 248  :     {
; 249  :         switch (in) {

  00d98	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00d9c	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv487[rsp], eax
  00da3	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv487[rsp]
  00daa	ff c8		 dec	 eax
  00dac	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv487[rsp], eax
  00db3	83 bc 24 e4 00
	00 00 7f	 cmp	 DWORD PTR tv487[rsp], 127 ; 0000007fH
  00dbb	0f 87 9f 00 00
	00		 ja	 $LN5@main
  00dc1	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR tv487[rsp]
  00dc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00dd0	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN200@main[rcx+rax]
  00dd8	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN201@main[rcx+rax*4]
  00ddf	48 03 c1	 add	 rax, rcx
  00de2	ff e0		 jmp	 rax
$LN101@main:
$LN102@main:

; 250  :                 case CKD:
; 251  :                 case CKD64:
; 252  :                     if (!lfs)

  00de4	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00dec	75 0a		 jne	 SHORT $LN103@main

; 253  :                     {
; 254  :                         out = CCKD64;

  00dee	c7 44 24 70 20
	00 00 00	 mov	 DWORD PTR out$[rsp], 32	; 00000020H

; 255  :                     }

  00df6	eb 08		 jmp	 SHORT $LN104@main
$LN103@main:

; 256  :                     else
; 257  :                     {
; 258  :                         out = CKD64;

  00df8	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR out$[rsp], 16
$LN104@main:

; 259  :                     }
; 260  :                     break;

  00e00	eb 5e		 jmp	 SHORT $LN5@main
$LN105@main:
$LN106@main:

; 261  :                 case CCKD:
; 262  :                 case CCKD64:
; 263  :                     if (comp == 255)

  00e02	81 bc 24 98 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00e0d	75 0a		 jne	 SHORT $LN107@main

; 264  :                     {
; 265  :                          out = CKD64;

  00e0f	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR out$[rsp], 16

; 266  :                     }

  00e17	eb 08		 jmp	 SHORT $LN108@main
$LN107@main:

; 267  :                     else
; 268  :                     {
; 269  :                         out = CCKD64;

  00e19	c7 44 24 70 20
	00 00 00	 mov	 DWORD PTR out$[rsp], 32	; 00000020H
$LN108@main:

; 270  :                     }
; 271  :                     break;

  00e21	eb 3d		 jmp	 SHORT $LN5@main
$LN109@main:
$LN110@main:

; 272  :                 case FBA:
; 273  :                 case FBA64:
; 274  :                     if (!lfs)

  00e23	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00e2b	75 0a		 jne	 SHORT $LN111@main

; 275  :                     {
; 276  :                         out = CFBA64;

  00e2d	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR out$[rsp], 128 ; 00000080H

; 277  :                     }

  00e35	eb 08		 jmp	 SHORT $LN112@main
$LN111@main:

; 278  :                     else
; 279  :                     {
; 280  :                         out = FBA64;

  00e37	c7 44 24 70 40
	00 00 00	 mov	 DWORD PTR out$[rsp], 64	; 00000040H
$LN112@main:

; 281  :                     }
; 282  :                     break;

  00e3f	eb 1f		 jmp	 SHORT $LN5@main
$LN113@main:
$LN114@main:

; 283  :                 case CFBA:
; 284  :                 case CFBA64:
; 285  :                     if (comp == 255)

  00e41	81 bc 24 98 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00e4c	75 0a		 jne	 SHORT $LN115@main

; 286  :                     {
; 287  :                         out = FBA64;

  00e4e	c7 44 24 70 40
	00 00 00	 mov	 DWORD PTR out$[rsp], 64	; 00000040H

; 288  :                     }

  00e56	eb 08		 jmp	 SHORT $LN116@main
$LN115@main:

; 289  :                     else
; 290  :                     {
; 291  :                         out = CFBA64;

  00e58	c7 44 24 70 80
	00 00 00	 mov	 DWORD PTR out$[rsp], 128 ; 00000080H
$LN116@main:
$LN5@main:
$LN100@main:

; 292  :                     }
; 293  :                     break;
; 294  :         }
; 295  :     }
; 296  : 
; 297  :     /* Set default compression if out file is to be compressed */
; 298  :     if (comp == 255 && (out & COMPMASK))

  00e60	81 bc 24 98 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00e6b	75 18		 jne	 SHORT $LN117@main
  00e6d	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  00e71	25 aa 00 00 00	 and	 eax, 170		; 000000aaH
  00e76	85 c0		 test	 eax, eax
  00e78	74 0b		 je	 SHORT $LN117@main

; 299  : #ifdef CCKD_COMPRESS_ZLIB
; 300  :         comp = CCKD_COMPRESS_ZLIB;

  00e7a	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR comp$[rsp], 1
$LN117@main:

; 301  : #else
; 302  :         comp = CCKD_COMPRESS_NONE;
; 303  : #endif
; 304  : 
; 305  :     /* Perform sanity checks on the options... */
; 306  : 
; 307  :     if (sfile && !(in & COMPMASK))        return syntax( pgm, "%s",

  00e85	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR sfile$[rsp], 0
  00e8e	74 2d		 je	 SHORT $LN118@main
  00e90	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00e94	25 aa 00 00 00	 and	 eax, 170		; 000000aaH
  00e99	85 c0		 test	 eax, eax
  00e9b	75 20		 jne	 SHORT $LN118@main
  00e9d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168900
  00ea4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168901
  00eab	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00eb3	e8 00 00 00 00	 call	 syntax
  00eb8	e9 10 11 00 00	 jmp	 $LN1@main
$LN118@main:

; 308  :         "shadow files invalid if input not compressed" );
; 309  : 
; 310  :     if (comp != 255 && !(out & COMPMASK)) return syntax( pgm, "%s",

  00ebd	81 bc 24 98 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR comp$[rsp], 255 ; 000000ffH
  00ec8	74 2d		 je	 SHORT $LN119@main
  00eca	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  00ece	25 aa 00 00 00	 and	 eax, 170		; 000000aaH
  00ed3	85 c0		 test	 eax, eax
  00ed5	75 20		 jne	 SHORT $LN119@main
  00ed7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168903
  00ede	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168904
  00ee5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00eed	e8 00 00 00 00	 call	 syntax
  00ef2	e9 d6 10 00 00	 jmp	 $LN1@main
$LN119@main:

; 311  :         "compress type invalid for uncompressed output" );
; 312  : 
; 313  :     if (lfs && (out & COMPMASK))          return syntax( pgm, "%s",

  00ef7	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00eff	74 2d		 je	 SHORT $LN120@main
  00f01	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  00f05	25 aa 00 00 00	 and	 eax, 170		; 000000aaH
  00f0a	85 c0		 test	 eax, eax
  00f0c	74 20		 je	 SHORT $LN120@main
  00f0e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168906
  00f15	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168907
  00f1c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00f24	e8 00 00 00 00	 call	 syntax
  00f29	e9 9f 10 00 00	 jmp	 $LN1@main
$LN120@main:

; 314  :         "-lfs invalid if output is compressed" );
; 315  : 
; 316  :     if (cyls >= 0 && (in & FBAMASK ))     return syntax( pgm, "%s",

  00f2e	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  00f36	7c 2d		 jl	 SHORT $LN121@main
  00f38	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00f3c	25 cc 00 00 00	 and	 eax, 204		; 000000ccH
  00f41	85 c0		 test	 eax, eax
  00f43	74 20		 je	 SHORT $LN121@main
  00f45	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168909
  00f4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168910
  00f53	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00f5b	e8 00 00 00 00	 call	 syntax
  00f60	e9 68 10 00 00	 jmp	 $LN1@main
$LN121@main:

; 317  :         "-cyls invalid for fba input" );
; 318  : 
; 319  :     if (blks >= 0 && (in & CKDMASK ))     return syntax( pgm, "%s",

  00f65	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  00f6d	7c 2b		 jl	 SHORT $LN122@main
  00f6f	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00f73	83 e0 33	 and	 eax, 51			; 00000033H
  00f76	85 c0		 test	 eax, eax
  00f78	74 20		 je	 SHORT $LN122@main
  00f7a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168912
  00f81	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168913
  00f88	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00f90	e8 00 00 00 00	 call	 syntax
  00f95	e9 33 10 00 00	 jmp	 $LN1@main
$LN122@main:

; 320  :         "-blks invalid for ckd input" );
; 321  : 
; 322  :     if (alt && (in & FBAMASK ))           return syntax( pgm, "%s",

  00f9a	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR alt$[rsp], 0
  00fa2	74 2d		 je	 SHORT $LN123@main
  00fa4	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00fa8	25 cc 00 00 00	 and	 eax, 204		; 000000ccH
  00fad	85 c0		 test	 eax, eax
  00faf	74 20		 je	 SHORT $LN123@main
  00fb1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168915
  00fb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168916
  00fbf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00fc7	e8 00 00 00 00	 call	 syntax
  00fcc	e9 fc 0f 00 00	 jmp	 $LN1@main
$LN123@main:

; 323  :         "-a invalid for fba input" );
; 324  : 
; 325  :     if (0
; 326  :         || ((in & CKDMASK) && !(out & CKDMASK ))
; 327  :         || ((in & FBAMASK) && !(out & FBAMASK ))

  00fd1	33 c0		 xor	 eax, eax
  00fd3	85 c0		 test	 eax, eax
  00fd5	75 30		 jne	 SHORT $LN125@main
  00fd7	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00fdb	83 e0 33	 and	 eax, 51			; 00000033H
  00fde	85 c0		 test	 eax, eax
  00fe0	74 0b		 je	 SHORT $LN126@main
  00fe2	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  00fe6	83 e0 33	 and	 eax, 51			; 00000033H
  00fe9	85 c0		 test	 eax, eax
  00feb	74 1a		 je	 SHORT $LN125@main
$LN126@main:
  00fed	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  00ff1	25 cc 00 00 00	 and	 eax, 204		; 000000ccH
  00ff6	85 c0		 test	 eax, eax
  00ff8	74 2d		 je	 SHORT $LN124@main
  00ffa	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  00ffe	25 cc 00 00 00	 and	 eax, 204		; 000000ccH
  01003	85 c0		 test	 eax, eax
  01005	75 20		 jne	 SHORT $LN124@main
$LN125@main:

; 328  :     )
; 329  :         return syntax( pgm, "%s",

  01007	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168920
  0100e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168921
  01015	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0101d	e8 00 00 00 00	 call	 syntax
  01022	e9 a6 0f 00 00	 jmp	 $LN1@main
$LN124@main:

; 330  :             "cannot copy ckd to fba or vice versa" );
; 331  : 
; 332  :     /* Set the type of processing (ckd or fba) */
; 333  :     ckddasd = (in & CKDMASK);

  01027	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  0102b	83 e0 33	 and	 eax, 51			; 00000033H
  0102e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR ckddasd$[rsp], eax

; 334  : 
; 335  :     /* Open the input file */
; 336  :     if (ckddasd)

  01035	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  0103d	74 5f		 je	 SHORT $LN127@main

; 337  :     {
; 338  :         if (in & MASK64)

  0103f	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  01043	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01048	85 c0		 test	 eax, eax
  0104a	74 29		 je	 SHORT $LN129@main

; 339  :             icif = open_ckd64_image( ifile, sfile, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL );

  0104c	45 33 c9	 xor	 r9d, r9d
  0104f	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  01055	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  0105d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  01065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd64_image
  0106b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax
  01073	eb 27		 jmp	 SHORT $LN130@main
$LN129@main:

; 340  :         else
; 341  :             icif = open_ckd_image  ( ifile, sfile, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL );

  01075	45 33 c9	 xor	 r9d, r9d
  01078	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0107e	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  01086	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  0108e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  01094	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax
$LN130@main:

; 342  :     }

  0109c	eb 5d		 jmp	 SHORT $LN128@main
$LN127@main:

; 343  :     else // fba
; 344  :     {
; 345  :         if (in & MASK64)

  0109e	8b 44 24 78	 mov	 eax, DWORD PTR in$[rsp]
  010a2	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  010a7	85 c0		 test	 eax, eax
  010a9	74 29		 je	 SHORT $LN131@main

; 346  :             icif = open_fba64_image( ifile, sfile, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL );

  010ab	45 33 c9	 xor	 r9d, r9d
  010ae	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  010b4	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  010bc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  010c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba64_image
  010ca	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax
  010d2	eb 27		 jmp	 SHORT $LN132@main
$LN131@main:

; 347  :         else
; 348  :             icif = open_fba_image  ( ifile, sfile, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL );

  010d4	45 33 c9	 xor	 r9d, r9d
  010d7	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  010dd	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR sfile$[rsp]
  010e5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  010ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba_image
  010f3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR icif$[rsp], rax
$LN132@main:
$LN128@main:

; 349  :     }
; 350  :     if (icif == NULL)

  010fb	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR icif$[rsp], 0
  01104	75 5e		 jne	 SHORT $LN133@main

; 351  :     {
; 352  :         // "Failed opening %s"
; 353  :         FWRMSG( stderr, HHC02403, "E", ifile );

  01106	b9 02 00 00 00	 mov	 ecx, 2
  0110b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01111	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  01119	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0111e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168929
  01125	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0112a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168930
  01131	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01136	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0113b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01141	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168931
  01148	ba 61 01 00 00	 mov	 edx, 353		; 00000161H
  0114d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168932
  01154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 354  :         return -1;

  0115a	b8 ff ff ff ff	 mov	 eax, -1
  0115f	e9 69 0e 00 00	 jmp	 $LN1@main
$LN133@main:

; 355  :     }
; 356  :     idev = &icif->devblk;

  01164	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR icif$[rsp]
  0116c	48 83 c0 30	 add	 rax, 48			; 00000030H
  01170	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR idev$[rsp], rax

; 357  :     if (idev->oslinux) nullfmt = CKD_NULLTRK_FMT2;

  01178	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01180	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01186	c1 e8 0d	 shr	 eax, 13
  01189	83 e0 01	 and	 eax, 1
  0118c	85 c0		 test	 eax, eax
  0118e	74 0b		 je	 SHORT $LN134@main
  01190	c7 84 24 cc 00
	00 00 02 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 2
$LN134@main:

; 358  : 
; 359  :     /* Calculate the number of tracks or blocks to copy */
; 360  :     if (ckddasd)

  0119b	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  011a3	0f 84 a8 01 00
	00		 je	 $LN135@main

; 361  :     {
; 362  :         if (cyls < 0) cyls = idev->ckdcyls;

  011a9	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  011b1	7d 17		 jge	 SHORT $LN137@main
  011b3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  011bb	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  011c1	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
  011c8	eb 2b		 jmp	 SHORT $LN138@main
$LN137@main:

; 363  :         else if (cyls == 0) cyls = (idev->hnd->used)(idev);

  011ca	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyls$[rsp], 0
  011d2	75 21		 jne	 SHORT $LN139@main
  011d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  011dc	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  011e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  011eb	ff 50 60	 call	 QWORD PTR [rax+96]
  011ee	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
$LN139@main:
$LN138@main:

; 364  :         ckd = dasd_lookup (DASD_CKDDEV, NULL, idev->devtype, 0);

  011f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  011fd	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01201	45 33 c9	 xor	 r9d, r9d
  01204	44 8b c0	 mov	 r8d, eax
  01207	33 d2		 xor	 edx, edx
  01209	b9 01 00 00 00	 mov	 ecx, 1
  0120e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  01214	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 365  :         if (ckd == NULL)

  0121c	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  01225	0f 85 88 00 00
	00		 jne	 $LN140@main

; 366  :         {
; 367  :             // "CKD lookup failed: device type %04X cyls %d"
; 368  :             FWRMSG( stderr, HHC02430, "E",

  0122b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01233	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01237	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv644[rsp], eax
  0123e	b9 02 00 00 00	 mov	 ecx, 2
  01243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01249	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  01250	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01254	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv644[rsp]
  0125b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0125f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168940
  01266	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0126b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168941
  01272	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01277	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0127c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01282	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168942
  01289	ba 71 01 00 00	 mov	 edx, 369		; 00000171H
  0128e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168943
  01295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 369  :                      idev->devtype, cyls );
; 370  :             close_image_file (icif);

  0129b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  012a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 371  :             return -1;

  012a9	b8 ff ff ff ff	 mov	 eax, -1
  012ae	e9 1a 0d 00 00	 jmp	 $LN1@main
$LN140@main:

; 372  :         }
; 373  :         if (cyls <= ckd->cyls && alt) cyls = ckd->cyls + ckd->altcyls;

  012b3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  012bb	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  012bf	39 84 24 90 00
	00 00		 cmp	 DWORD PTR cyls$[rsp], eax
  012c6	7f 2b		 jg	 SHORT $LN141@main
  012c8	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR alt$[rsp], 0
  012d0	74 21		 je	 SHORT $LN141@main
  012d2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  012da	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  012de	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  012e6	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  012ea	03 c1		 add	 eax, ecx
  012ec	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax
$LN141@main:

; 374  :         n = cyls * idev->ckdheads;

  012f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  012fb	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  01302	0f af 88 c0 12
	00 00		 imul	 ecx, DWORD PTR [rax+4800]
  01309	8b c1		 mov	 eax, ecx
  0130b	89 84 24 94 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 375  :         max = idev->ckdtrks;

  01312	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  0131a	8b 80 bc 12 00
	00		 mov	 eax, DWORD PTR [rax+4796]
  01320	89 84 24 b0 00
	00 00		 mov	 DWORD PTR max$[rsp], eax

; 376  :         if (max < n && out == CCKD) n = max;

  01327	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0132e	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR max$[rsp], eax
  01335	7d 15		 jge	 SHORT $LN142@main
  01337	83 7c 24 70 02	 cmp	 DWORD PTR out$[rsp], 2
  0133c	75 0e		 jne	 SHORT $LN142@main
  0133e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  01345	89 84 24 94 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN142@main:

; 377  :     }

  0134c	e9 8c 01 00 00	 jmp	 $LN136@main
$LN135@main:

; 378  :     else // fba
; 379  :     {
; 380  :         fba_bytes_remaining = (U64)((S64)idev->fbanumblk * idev->fbablksiz);

  01351	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01359	48 63 80 88 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4488]
  01360	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01368	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  0136f	48 0f af c1	 imul	 rax, rcx
  01373	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR fba_bytes_remaining$[rsp], rax

; 381  :         if (blks < 0) blks = idev->fbanumblk;

  0137b	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  01383	7d 17		 jge	 SHORT $LN143@main
  01385	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  0138d	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  01393	89 84 24 9c 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
  0139a	eb 2b		 jmp	 SHORT $LN144@main
$LN143@main:

; 382  :         else if (blks == 0) blks = (idev->hnd->used)(idev);

  0139c	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR blks$[rsp], 0
  013a4	75 21		 jne	 SHORT $LN145@main
  013a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  013ae	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  013b5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  013bd	ff 50 60	 call	 QWORD PTR [rax+96]
  013c0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR blks$[rsp], eax
$LN145@main:
$LN144@main:

; 383  :         fba = dasd_lookup (DASD_FBADEV, NULL, idev->devtype, 0);

  013c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  013cf	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  013d3	45 33 c9	 xor	 r9d, r9d
  013d6	44 8b c0	 mov	 r8d, eax
  013d9	33 d2		 xor	 edx, edx
  013db	b9 03 00 00 00	 mov	 ecx, 3
  013e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  013e6	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 384  :         if (fba == NULL)

  013ee	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  013f7	75 6a		 jne	 SHORT $LN146@main

; 385  :         {
; 386  :             // "FBA lookup failed: blks %d"
; 387  :             FWRMSG( stderr, HHC02431, "E", blks );

  013f9	b9 02 00 00 00	 mov	 ecx, 2
  013fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01404	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR blks$[rsp]
  0140b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0140f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168950
  01416	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0141b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168951
  01422	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01427	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0142c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01432	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168952
  01439	ba 83 01 00 00	 mov	 edx, 387		; 00000183H
  0143e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168953
  01445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 388  :             close_image_file (icif);

  0144b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 389  :             return -1;

  01459	b8 ff ff ff ff	 mov	 eax, -1
  0145e	e9 6a 0b 00 00	 jmp	 $LN1@main
$LN146@main:

; 390  :         }
; 391  : 
; 392  :         n = blks;

  01463	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR blks$[rsp]
  0146a	89 84 24 94 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 393  :         max = idev->fbanumblk;

  01471	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01479	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  0147f	89 84 24 b0 00
	00 00		 mov	 DWORD PTR max$[rsp], eax

; 394  : 
; 395  :         if (max < n && out == CFBA)

  01486	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0148d	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR max$[rsp], eax
  01494	7d 15		 jge	 SHORT $LN147@main
  01496	83 7c 24 70 08	 cmp	 DWORD PTR out$[rsp], 8
  0149b	75 0e		 jne	 SHORT $LN147@main

; 396  :             n = max;

  0149d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  014a4	89 84 24 94 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN147@main:

; 397  : 
; 398  :         n =   (n   + CFBA_BLKS_PER_GRP - 1) / CFBA_BLKS_PER_GRP;

  014ab	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  014b2	83 c0 77	 add	 eax, 119		; 00000077H
  014b5	99		 cdq
  014b6	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  014bb	f7 f9		 idiv	 ecx
  014bd	89 84 24 94 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 399  :         max = (max + CFBA_BLKS_PER_GRP - 1) / CFBA_BLKS_PER_GRP;

  014c4	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  014cb	83 c0 77	 add	 eax, 119		; 00000077H
  014ce	99		 cdq
  014cf	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  014d4	f7 f9		 idiv	 ecx
  014d6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN136@main:

; 400  :     }
; 401  : 
; 402  :     /* Create the output file */
; 403  :     if (ckddasd)

  014dd	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  014e5	0f 84 47 01 00
	00		 je	 $LN148@main

; 404  :     {
; 405  :         if (out & MASK64)

  014eb	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  014ef	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  014f4	85 c0		 test	 eax, eax
  014f6	0f 84 9b 00 00
	00		 je	 $LN150@main

; 406  :             rc = create_ckd64( ofile, idev->devtype, idev->ckdheads,

  014fc	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  01503	ff c0		 inc	 eax
  01505	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  0150d	0f b7 49 16	 movzx	 ecx, WORD PTR [rcx+22]
  01511	c6 44 24 60 00	 mov	 BYTE PTR [rsp+96], 0
  01516	c6 44 24 58 01	 mov	 BYTE PTR [rsp+88], 1
  0151b	c6 44 24 50 00	 mov	 BYTE PTR [rsp+80], 0
  01520	0f b6 94 24 cc
	00 00 00	 movzx	 edx, BYTE PTR nullfmt$[rsp]
  01528	88 54 24 48	 mov	 BYTE PTR [rsp+72], dl
  0152c	88 44 24 40	 mov	 BYTE PTR [rsp+64], al
  01530	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  01538	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  0153c	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01544	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  01548	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168959
  0154f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01554	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  0155b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0155f	44 8b c9	 mov	 r9d, ecx
  01562	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  0156a	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  01571	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01579	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  0157d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_ckd64
  0158b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  01592	e9 96 00 00 00	 jmp	 $LN151@main
$LN150@main:

; 407  :                                ckd->r1, cyls, "", (BYTE)comp, (BYTE)lfs,
; 408  :                                (BYTE)(1+r), (BYTE)nullfmt, 0, 1, 0 );
; 409  :         else
; 410  :             rc = create_ckd  ( ofile, idev->devtype, idev->ckdheads,

  01597	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  0159e	ff c0		 inc	 eax
  015a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  015a8	0f b7 49 16	 movzx	 ecx, WORD PTR [rcx+22]
  015ac	c6 44 24 60 00	 mov	 BYTE PTR [rsp+96], 0
  015b1	c6 44 24 58 01	 mov	 BYTE PTR [rsp+88], 1
  015b6	c6 44 24 50 00	 mov	 BYTE PTR [rsp+80], 0
  015bb	0f b6 94 24 cc
	00 00 00	 movzx	 edx, BYTE PTR nullfmt$[rsp]
  015c3	88 54 24 48	 mov	 BYTE PTR [rsp+72], dl
  015c7	88 44 24 40	 mov	 BYTE PTR [rsp+64], al
  015cb	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  015d3	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  015d7	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  015df	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  015e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168960
  015ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  015ef	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  015f6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  015fa	44 8b c9	 mov	 r9d, ecx
  015fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01605	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  0160c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01614	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  01618	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01620	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_ckd
  01626	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN151@main:

; 411  :                                ckd->r1, cyls, "", (BYTE)comp, (BYTE)lfs,
; 412  :                                (BYTE)(1+r), (BYTE)nullfmt, 0, 1, 0 );
; 413  :     }

  0162d	e9 e9 00 00 00	 jmp	 $LN149@main
$LN148@main:

; 414  :     else // fba
; 415  :     {
; 416  :         if (out & MASK64)

  01632	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  01636	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0163b	85 c0		 test	 eax, eax
  0163d	74 6f		 je	 SHORT $LN152@main

; 417  :             rc = create_fba64( ofile, idev->devtype, fba->size,

  0163f	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  01646	ff c0		 inc	 eax
  01648	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  01650	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  01654	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  0165b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0165f	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01667	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0166b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168963
  01672	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01677	44 8b 8c 24 9c
	00 00 00	 mov	 r9d, DWORD PTR blks$[rsp]
  0167f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  01687	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  0168b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01693	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  01697	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  0169f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_fba64
  016a5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  016ac	eb 6d		 jmp	 SHORT $LN153@main
$LN152@main:

; 418  :                                blks, "", (BYTE) comp, lfs, 1+r, 0 );
; 419  :         else
; 420  :             rc = create_fba  ( ofile, idev->devtype, fba->size,

  016ae	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  016b5	ff c0		 inc	 eax
  016b7	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  016bf	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  016c3	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  016ca	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  016ce	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  016d6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  016da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168964
  016e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016e6	44 8b 8c 24 9c
	00 00 00	 mov	 r9d, DWORD PTR blks$[rsp]
  016ee	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  016f6	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  016fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01702	0f b7 50 4a	 movzx	 edx, WORD PTR [rax+74]
  01706	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  0170e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_fba
  01714	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN153@main:
$LN149@main:

; 421  :                                blks, "", (BYTE) comp, lfs, 1+r, 0 );
; 422  :     }
; 423  :     if (rc < 0)

  0171b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01723	7d 6c		 jge	 SHORT $LN154@main

; 424  :     {
; 425  :         // "Failed creating %s"
; 426  :         FWRMSG( stderr, HHC02432, "E", ofile );

  01725	b9 02 00 00 00	 mov	 ecx, 2
  0172a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01730	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01738	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0173d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168966
  01744	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168967
  01750	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01755	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0175a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01760	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168968
  01767	ba aa 01 00 00	 mov	 edx, 426		; 000001aaH
  0176c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168969
  01773	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 427  :         close_image_file (icif);

  01779	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 428  :         return -1;

  01787	b8 ff ff ff ff	 mov	 eax, -1
  0178c	e9 3c 08 00 00	 jmp	 $LN1@main
$LN154@main:

; 429  :     }
; 430  : 
; 431  :     /* Open the output file */
; 432  :     if (ckddasd)

  01791	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01799	74 59		 je	 SHORT $LN155@main

; 433  :     {
; 434  :         if (out & MASK64)

  0179b	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  0179f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  017a4	85 c0		 test	 eax, eax
  017a6	74 26		 je	 SHORT $LN157@main

; 435  :             ocif = open_ckd64_image( ofile, NULL, O_RDWR | O_BINARY, IMAGE_OPEN_DASDCOPY );

  017a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  017ae	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  017b4	33 d2		 xor	 edx, edx
  017b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  017be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd64_image
  017c4	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax
  017cc	eb 24		 jmp	 SHORT $LN158@main
$LN157@main:

; 436  :         else
; 437  :             ocif = open_ckd_image  ( ofile, NULL, O_RDWR | O_BINARY, IMAGE_OPEN_DASDCOPY );

  017ce	41 b9 01 00 00
	00		 mov	 r9d, 1
  017d4	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  017da	33 d2		 xor	 edx, edx
  017dc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  017e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  017ea	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax
$LN158@main:

; 438  :     }

  017f2	eb 57		 jmp	 SHORT $LN156@main
$LN155@main:

; 439  :     else // fba
; 440  :     {
; 441  :         if (out & MASK64)

  017f4	8b 44 24 70	 mov	 eax, DWORD PTR out$[rsp]
  017f8	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  017fd	85 c0		 test	 eax, eax
  017ff	74 26		 je	 SHORT $LN159@main

; 442  :             ocif = open_fba64_image( ofile, NULL, O_RDWR | O_BINARY, IMAGE_OPEN_DASDCOPY );

  01801	41 b9 01 00 00
	00		 mov	 r9d, 1
  01807	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  0180d	33 d2		 xor	 edx, edx
  0180f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01817	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba64_image
  0181d	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax
  01825	eb 24		 jmp	 SHORT $LN160@main
$LN159@main:

; 443  :         else
; 444  :             ocif = open_fba_image  ( ofile, NULL, O_RDWR | O_BINARY, IMAGE_OPEN_DASDCOPY );

  01827	41 b9 01 00 00
	00		 mov	 r9d, 1
  0182d	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  01833	33 d2		 xor	 edx, edx
  01835	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  0183d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_fba_image
  01843	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ocif$[rsp], rax
$LN160@main:
$LN156@main:

; 445  :     }
; 446  :     if (ocif == NULL)

  0184b	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR ocif$[rsp], 0
  01854	75 6c		 jne	 SHORT $LN161@main

; 447  :     {
; 448  :         // "Failed opening %s"
; 449  :         FWRMSG( stderr, HHC02403, "E", ofile );

  01856	b9 02 00 00 00	 mov	 ecx, 2
  0185b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01861	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01869	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0186e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168977
  01875	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0187a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168978
  01881	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01886	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0188b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01891	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168979
  01898	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  0189d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168980
  018a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 450  :         close_image_file (icif);

  018aa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  018b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 451  :         return -1;

  018b8	b8 ff ff ff ff	 mov	 eax, -1
  018bd	e9 0b 07 00 00	 jmp	 $LN1@main
$LN161@main:

; 452  :     }
; 453  :     odev = &ocif->devblk;

  018c2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ocif$[rsp]
  018ca	48 83 c0 30	 add	 rax, 48			; 00000030H
  018ce	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR odev$[rsp], rax
$LN9@main:

; 454  : 
; 455  :     /* Notify GUI of total #of tracks or blocks being copied... */
; 456  :     EXTGUIMSG( "TRKS=%d\n", n );

  018d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  018dd	83 38 00	 cmp	 DWORD PTR [rax], 0
  018e0	74 23		 je	 SHORT $LN162@main
  018e2	b9 02 00 00 00	 mov	 ecx, 2
  018e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018ed	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  018f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168982
  018fc	48 8b c8	 mov	 rcx, rax
  018ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN162@main:
  01905	33 c0		 xor	 eax, eax
  01907	85 c0		 test	 eax, eax
  01909	75 cb		 jne	 SHORT $LN9@main

; 457  : 
; 458  :     /* Copy the files */
; 459  : 
; 460  :     if (!extgui)

  0190b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  01912	83 38 00	 cmp	 DWORD PTR [rax], 0
  01915	75 23		 jne	 SHORT $LN163@main

; 461  :         if (!quiet)

  01917	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  0191f	75 19		 jne	 SHORT $LN164@main

; 462  :             printf ( "  %3d%% %7d of %d", 0, 0, n );

  01921	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR n$[rsp]
  01929	45 33 c0	 xor	 r8d, r8d
  0192c	33 d2		 xor	 edx, edx
  0192e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  01935	e8 00 00 00 00	 call	 printf
$LN164@main:
$LN163@main:

; 463  : 
; 464  :     for (i = 0; i < n; i++)

  0193a	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01945	eb 10		 jmp	 SHORT $LN12@main
$LN10@main:
  01947	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0194e	ff c0		 inc	 eax
  01950	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN12@main:
  01957	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0195e	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01965	0f 8d 89 05 00
	00		 jge	 $LN11@main

; 465  :     {
; 466  :         /* Read a track or block */
; 467  :         if (ckddasd)

  0196b	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01973	0f 84 ac 00 00
	00		 je	 $LN165@main

; 468  :         {
; 469  :             if (i < max)

  01979	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  01980	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01987	7d 2f		 jge	 SHORT $LN167@main

; 470  :                 rc = (idev->hnd->read)(idev, i, &unitstat);

  01989	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01991	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01998	4c 8d 44 24 74	 lea	 r8, QWORD PTR unitstat$[rsp]
  0199d	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  019a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  019ac	ff 50 50	 call	 QWORD PTR [rax+80]
  019af	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  019b6	eb 6b		 jmp	 SHORT $LN168@main
$LN167@main:

; 471  :             else
; 472  :             {
; 473  :                 memset (idev->buf, 0, idev->ckdtrksz);

  019b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  019c0	48 63 80 c4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4804]
  019c7	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv953[rsp], rax
  019cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  019d7	48 8b b9 c8 01
	00 00		 mov	 rdi, QWORD PTR [rcx+456]
  019de	33 c0		 xor	 eax, eax
  019e0	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv953[rsp]
  019e8	f3 aa		 rep stosb

; 474  :                 rc = nulltrk(idev->buf, i, idev->ckdheads, nullfmt);

  019ea	44 8b 8c 24 cc
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  019f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  019fa	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  01a01	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01a08	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01a10	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  01a17	e8 00 00 00 00	 call	 nulltrk
  01a1c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN168@main:

; 475  :             }
; 476  :         }

  01a23	eb 62		 jmp	 SHORT $LN166@main
$LN165@main:

; 477  :         else
; 478  :         {
; 479  :             if (i < max)

  01a25	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  01a2c	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01a33	7d 2f		 jge	 SHORT $LN169@main

; 480  :                 rc = (idev->hnd->read)(idev, i, &unitstat);

  01a35	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01a3d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01a44	4c 8d 44 24 74	 lea	 r8, QWORD PTR unitstat$[rsp]
  01a49	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01a50	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01a58	ff 50 50	 call	 QWORD PTR [rax+80]
  01a5b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  01a62	eb 23		 jmp	 SHORT $LN170@main
$LN169@main:

; 481  :             else
; 482  :             {
; 483  :                 memset (idev->buf, 0, CFBA_BLKGRP_SIZE);

  01a64	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01a6c	48 8b b8 c8 01
	00 00		 mov	 rdi, QWORD PTR [rax+456]
  01a73	33 c0		 xor	 eax, eax
  01a75	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  01a7a	f3 aa		 rep stosb

; 484  :                 rc = 0;

  01a7c	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0
$LN170@main:
$LN166@main:

; 485  :             }
; 486  :         }
; 487  :         if (rc < 0)

  01a87	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01a8f	0f 8d 7c 01 00
	00		 jge	 $LN171@main

; 488  :         {
; 489  :             // "Read error on file %s: %s %d stat=%2.2X, null %s substituted"
; 490  :             FWRMSG( stderr, HHC02433, "E",

  01a95	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01a9d	74 11		 je	 SHORT $LN194@main
  01a9f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168993
  01aa6	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv978[rsp], rax
  01aae	eb 0f		 jmp	 SHORT $LN195@main
$LN194@main:
  01ab0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168994
  01ab7	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv978[rsp], rax
$LN195@main:
  01abf	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01ac7	74 11		 je	 SHORT $LN196@main
  01ac9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168995
  01ad0	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv984[rsp], rax
  01ad8	eb 0f		 jmp	 SHORT $LN197@main
$LN196@main:
  01ada	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168996
  01ae1	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv984[rsp], rax
$LN197@main:
  01ae9	0f b6 44 24 74	 movzx	 eax, BYTE PTR unitstat$[rsp]
  01aee	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv980[rsp], eax
  01af5	b9 02 00 00 00	 mov	 ecx, 2
  01afa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b00	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv978[rsp]
  01b08	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01b0d	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv980[rsp]
  01b14	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01b18	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01b1f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01b23	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv984[rsp]
  01b2b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01b30	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ifile$[rsp]
  01b38	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  01b44	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168998
  01b50	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b55	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b5a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b60	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168999
  01b67	ba ec 01 00 00	 mov	 edx, 492		; 000001ecH
  01b6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169000
  01b73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 491  :                      ifile, ckddasd ? "track" : "block", i, unitstat,
; 492  :                      ckddasd ? "track" : "block" );
; 493  :             if (ckddasd)

  01b79	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01b81	74 34		 je	 SHORT $LN172@main

; 494  :                 nulltrk(idev->buf, i, idev->ckdheads, nullfmt);

  01b83	44 8b 8c 24 cc
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  01b8b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01b93	44 8b 80 c0 12
	00 00		 mov	 r8d, DWORD PTR [rax+4800]
  01b9a	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01ba1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01ba9	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  01bb0	e8 00 00 00 00	 call	 nulltrk
  01bb5	eb 18		 jmp	 SHORT $LN173@main
$LN172@main:

; 495  :             else
; 496  :                 memset (idev->buf, 0, CFBA_BLKGRP_SIZE);

  01bb7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01bbf	48 8b b8 c8 01
	00 00		 mov	 rdi, QWORD PTR [rax+456]
  01bc6	33 c0		 xor	 eax, eax
  01bc8	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  01bcd	f3 aa		 rep stosb
$LN173@main:

; 497  :             if (!quiet)

  01bcf	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01bd7	75 38		 jne	 SHORT $LN174@main

; 498  :             {
; 499  :                 if (!extgui)

  01bd9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  01be0	83 38 00	 cmp	 DWORD PTR [rax], 0
  01be3	75 19		 jne	 SHORT $LN175@main

; 500  :                     printf ( "  %3d%% %7d of %d", 0, 0, n );

  01be5	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR n$[rsp]
  01bed	45 33 c0	 xor	 r8d, r8d
  01bf0	33 d2		 xor	 edx, edx
  01bf2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169005
  01bf9	e8 00 00 00 00	 call	 printf
$LN175@main:

; 501  :                 status (i, n);

  01bfe	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR n$[rsp]
  01c05	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01c0c	e8 00 00 00 00	 call	 status
$LN174@main:
$LN171@main:

; 502  :             }
; 503  :         }
; 504  : 
; 505  :         /* Write the track or block just read... */
; 506  : 
; 507  :         if (ckddasd)

  01c11	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01c19	74 5b		 je	 SHORT $LN176@main

; 508  :         {
; 509  :             rc = (odev->hnd->write)(odev, i, 0, idev->buf,

  01c1b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  01c23	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01c2a	48 8d 4c 24 74	 lea	 rcx, QWORD PTR unitstat$[rsp]
  01c2f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c34	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01c3c	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  01c42	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01c46	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01c4e	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  01c55	45 33 c0	 xor	 r8d, r8d
  01c58	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01c5f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  01c67	ff 50 58	 call	 QWORD PTR [rax+88]
  01c6a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 510  :                       idev->ckdtrksz, &unitstat);
; 511  :         }

  01c71	e9 77 01 00 00	 jmp	 $LN177@main
$LN176@main:

; 512  :         else
; 513  :         {
; 514  :             if (fba_bytes_remaining >= (U64)idev->buflen)

  01c76	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01c7e	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  01c85	48 39 84 24 00
	01 00 00	 cmp	 QWORD PTR fba_bytes_remaining$[rsp], rax
  01c8d	0f 82 80 00 00
	00		 jb	 $LN178@main

; 515  :             {
; 516  :                 rc = (odev->hnd->write)(odev,  i, 0, idev->buf,

  01c93	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  01c9b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01ca2	48 8d 4c 24 74	 lea	 rcx, QWORD PTR unitstat$[rsp]
  01ca7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01cac	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01cb4	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  01cba	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01cbe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01cc6	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  01ccd	45 33 c0	 xor	 r8d, r8d
  01cd0	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01cd7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  01cdf	ff 50 58	 call	 QWORD PTR [rax+88]
  01ce2	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 517  :                           idev->buflen, &unitstat);
; 518  :                 fba_bytes_remaining -= (U64)idev->buflen;

  01ce9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idev$[rsp]
  01cf1	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  01cf8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR fba_bytes_remaining$[rsp]
  01d00	48 2b c8	 sub	 rcx, rax
  01d03	48 8b c1	 mov	 rax, rcx
  01d06	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR fba_bytes_remaining$[rsp], rax

; 519  :             }

  01d0e	e9 da 00 00 00	 jmp	 $LN179@main
$LN178@main:
$LN15@main:

; 520  :             else
; 521  :             {
; 522  :                 ASSERT(fba_bytes_remaining > 0 && (i+1) >= n);

  01d13	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR fba_bytes_remaining$[rsp], 0
  01d1c	76 12		 jbe	 SHORT $LN181@main
  01d1e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01d25	ff c0		 inc	 eax
  01d27	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR n$[rsp]
  01d2e	7d 5c		 jge	 SHORT $LN180@main
$LN181@main:
$LN18@main:
  01d30	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169012
  01d37	41 b8 0a 02 00
	00		 mov	 r8d, 522		; 0000020aH
  01d3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169013
  01d44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169014
  01d4b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01d51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01d57	85 c0		 test	 eax, eax
  01d59	74 20		 je	 SHORT $LN182@main
  01d5b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169016
  01d62	41 b8 0a 02 00
	00		 mov	 r8d, 522		; 0000020aH
  01d68	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169017
  01d6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169018
  01d76	e8 00 00 00 00	 call	 DebuggerTrace
$LN182@main:
  01d7b	33 c0		 xor	 eax, eax
  01d7d	85 c0		 test	 eax, eax
  01d7f	75 af		 jne	 SHORT $LN18@main
  01d81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01d87	85 c0		 test	 eax, eax
  01d89	74 01		 je	 SHORT $LN183@main
  01d8b	cc		 int	 3
$LN183@main:
$LN180@main:
  01d8c	33 c0		 xor	 eax, eax
  01d8e	85 c0		 test	 eax, eax
  01d90	75 81		 jne	 SHORT $LN15@main

; 523  :                 rc = (odev->hnd->write)(odev,  i, 0, idev->buf,

  01d92	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR odev$[rsp]
  01d9a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01da1	48 8d 4c 24 74	 lea	 rcx, QWORD PTR unitstat$[rsp]
  01da6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01dab	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR fba_bytes_remaining$[rsp]
  01db2	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01db6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR idev$[rsp]
  01dbe	4c 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [rcx+456]
  01dc5	45 33 c0	 xor	 r8d, r8d
  01dc8	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  01dcf	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR odev$[rsp]
  01dd7	ff 50 58	 call	 QWORD PTR [rax+88]
  01dda	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 524  :                           (int)fba_bytes_remaining, &unitstat);
; 525  :                 fba_bytes_remaining = 0;

  01de1	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba_bytes_remaining$[rsp], 0
$LN179@main:
$LN177@main:

; 526  :             }
; 527  :         }
; 528  :         if (rc < 0)

  01ded	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01df5	0f 8d d3 00 00
	00		 jge	 $LN184@main

; 529  :         {
; 530  :             // "Write error on file %s: %s %d stat=%2.2X"
; 531  :             FWRMSG( stderr, HHC02434, "E",

  01dfb	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ckddasd$[rsp], 0
  01e03	74 11		 je	 SHORT $LN198@main
  01e05	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169021
  01e0c	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv1077[rsp], rax
  01e14	eb 0f		 jmp	 SHORT $LN199@main
$LN198@main:
  01e16	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169022
  01e1d	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv1077[rsp], rax
$LN199@main:
  01e25	0f b6 44 24 74	 movzx	 eax, BYTE PTR unitstat$[rsp]
  01e2a	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv1073[rsp], eax
  01e31	b9 02 00 00 00	 mov	 ecx, 2
  01e36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e3c	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv1073[rsp]
  01e43	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01e47	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01e4e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01e52	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv1077[rsp]
  01e5a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01e5f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  01e67	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01e6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169023
  01e73	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169024
  01e7f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e84	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e89	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e8f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169025
  01e96	ba 14 02 00 00	 mov	 edx, 532		; 00000214H
  01e9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169026
  01ea2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 532  :                      ofile, ckddasd ? "track" : "block", i, unitstat );
; 533  :             /* IMPORTANT PROGRAMMING NOTE: please note that the output
; 534  :                file's track is written directly from the INPUT's device
; 535  :                buffer. This means when we are done, we must close the
; 536  :                output file first, which flushes the output of the last
; 537  :                track that was written, which as explained, requires that
; 538  :                the INPUT file's device buffer to still be valid.
; 539  :             */
; 540  :             close_image_file( ocif );   /* Close output file FIRST! */

  01ea8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ocif$[rsp]
  01eb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 541  :             close_image_file( icif );   /* Close input file SECOND! */

  01eb6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01ebe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 542  :             return -1;

  01ec4	b8 ff ff ff ff	 mov	 eax, -1
  01ec9	e9 ff 00 00 00	 jmp	 $LN1@main
$LN184@main:

; 543  :         }
; 544  : 
; 545  :         /* Update the status indicator */
; 546  :         if (!quiet) status (i+1, n);

  01ece	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01ed6	75 17		 jne	 SHORT $LN185@main
  01ed8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01edf	ff c0		 inc	 eax
  01ee1	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR n$[rsp]
  01ee8	8b c8		 mov	 ecx, eax
  01eea	e8 00 00 00 00	 call	 status
$LN185@main:

; 547  :     }

  01eef	e9 53 fa ff ff	 jmp	 $LN10@main
$LN11@main:

; 548  : 
; 549  :     /* IMPORTANT PROGRAMMING NOTE: please note that the output
; 550  :        file's track is written directly from the INPUT's device
; 551  :        buffer. This means when we are done, we must close the
; 552  :        output file first, which flushes the output of the last
; 553  :        track that was written, which as explained, requires that
; 554  :        the INPUT file's device buffer to still be valid.
; 555  :     */
; 556  :     close_image_file( ocif );   /* Close output file FIRST! */

  01ef4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ocif$[rsp]
  01efc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 557  :     close_image_file( icif );   /* Close input file SECOND! */

  01f02	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR icif$[rsp]
  01f0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 558  : 
; 559  :     if (!extgui)

  01f10	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  01f17	83 38 00	 cmp	 DWORD PTR [rax], 0
  01f1a	75 16		 jne	 SHORT $LN186@main

; 560  :         if (!quiet)

  01f1c	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  01f24	75 0c		 jne	 SHORT $LN187@main

; 561  :             printf ( "\r" );

  01f26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169030
  01f2d	e8 00 00 00 00	 call	 printf
$LN187@main:
$LN186@main:

; 562  : 
; 563  :     if (sfile)

  01f32	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR sfile$[rsp], 0
  01f3b	74 47		 je	 SHORT $LN188@main

; 564  :         // "Shadow file data successfully merged into output"
; 565  :         WRMSG( HHC02595, "I" );

  01f3d	b9 01 00 00 00	 mov	 ecx, 1
  01f42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01f48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169032
  01f4f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169033
  01f5b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f60	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f65	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f6b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169034
  01f72	ba 35 02 00 00	 mov	 edx, 565		; 00000235H
  01f77	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169035
  01f7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN188@main:

; 566  : 
; 567  :     // "DASD operation completed"
; 568  :     WRMSG( HHC02423, "I" );

  01f84	b9 01 00 00 00	 mov	 ecx, 1
  01f89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01f8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169036
  01f96	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169037
  01fa2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01fa7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01fac	41 b9 03 00 00
	00		 mov	 r9d, 3
  01fb2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169038
  01fb9	ba 38 02 00 00	 mov	 edx, 568		; 00000238H
  01fbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169039
  01fc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 569  :     return 0;

  01fcb	33 c0		 xor	 eax, eax
$LN1@main:

; 570  : }

  01fcd	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01fd5	48 33 cc	 xor	 rcx, rsp
  01fd8	e8 00 00 00 00	 call	 __security_check_cookie
  01fdd	48 81 c4 a0 02
	00 00		 add	 rsp, 672		; 000002a0H
  01fe4	5f		 pop	 rdi
  01fe5	c3		 ret	 0
  01fe6	66 90		 npad	 2
$LN201@main:
  01fe8	00 00 00 00	 DD	 $LN101@main
  01fec	00 00 00 00	 DD	 $LN105@main
  01ff0	00 00 00 00	 DD	 $LN109@main
  01ff4	00 00 00 00	 DD	 $LN113@main
  01ff8	00 00 00 00	 DD	 $LN102@main
  01ffc	00 00 00 00	 DD	 $LN106@main
  02000	00 00 00 00	 DD	 $LN110@main
  02004	00 00 00 00	 DD	 $LN114@main
  02008	00 00 00 00	 DD	 $LN5@main
$LN200@main:
  0200c	00		 DB	 0
  0200d	01		 DB	 1
  0200e	08		 DB	 8
  0200f	02		 DB	 2
  02010	08		 DB	 8
  02011	08		 DB	 8
  02012	08		 DB	 8
  02013	03		 DB	 3
  02014	08		 DB	 8
  02015	08		 DB	 8
  02016	08		 DB	 8
  02017	08		 DB	 8
  02018	08		 DB	 8
  02019	08		 DB	 8
  0201a	08		 DB	 8
  0201b	04		 DB	 4
  0201c	08		 DB	 8
  0201d	08		 DB	 8
  0201e	08		 DB	 8
  0201f	08		 DB	 8
  02020	08		 DB	 8
  02021	08		 DB	 8
  02022	08		 DB	 8
  02023	08		 DB	 8
  02024	08		 DB	 8
  02025	08		 DB	 8
  02026	08		 DB	 8
  02027	08		 DB	 8
  02028	08		 DB	 8
  02029	08		 DB	 8
  0202a	08		 DB	 8
  0202b	05		 DB	 5
  0202c	08		 DB	 8
  0202d	08		 DB	 8
  0202e	08		 DB	 8
  0202f	08		 DB	 8
  02030	08		 DB	 8
  02031	08		 DB	 8
  02032	08		 DB	 8
  02033	08		 DB	 8
  02034	08		 DB	 8
  02035	08		 DB	 8
  02036	08		 DB	 8
  02037	08		 DB	 8
  02038	08		 DB	 8
  02039	08		 DB	 8
  0203a	08		 DB	 8
  0203b	08		 DB	 8
  0203c	08		 DB	 8
  0203d	08		 DB	 8
  0203e	08		 DB	 8
  0203f	08		 DB	 8
  02040	08		 DB	 8
  02041	08		 DB	 8
  02042	08		 DB	 8
  02043	08		 DB	 8
  02044	08		 DB	 8
  02045	08		 DB	 8
  02046	08		 DB	 8
  02047	08		 DB	 8
  02048	08		 DB	 8
  02049	08		 DB	 8
  0204a	08		 DB	 8
  0204b	06		 DB	 6
  0204c	08		 DB	 8
  0204d	08		 DB	 8
  0204e	08		 DB	 8
  0204f	08		 DB	 8
  02050	08		 DB	 8
  02051	08		 DB	 8
  02052	08		 DB	 8
  02053	08		 DB	 8
  02054	08		 DB	 8
  02055	08		 DB	 8
  02056	08		 DB	 8
  02057	08		 DB	 8
  02058	08		 DB	 8
  02059	08		 DB	 8
  0205a	08		 DB	 8
  0205b	08		 DB	 8
  0205c	08		 DB	 8
  0205d	08		 DB	 8
  0205e	08		 DB	 8
  0205f	08		 DB	 8
  02060	08		 DB	 8
  02061	08		 DB	 8
  02062	08		 DB	 8
  02063	08		 DB	 8
  02064	08		 DB	 8
  02065	08		 DB	 8
  02066	08		 DB	 8
  02067	08		 DB	 8
  02068	08		 DB	 8
  02069	08		 DB	 8
  0206a	08		 DB	 8
  0206b	08		 DB	 8
  0206c	08		 DB	 8
  0206d	08		 DB	 8
  0206e	08		 DB	 8
  0206f	08		 DB	 8
  02070	08		 DB	 8
  02071	08		 DB	 8
  02072	08		 DB	 8
  02073	08		 DB	 8
  02074	08		 DB	 8
  02075	08		 DB	 8
  02076	08		 DB	 8
  02077	08		 DB	 8
  02078	08		 DB	 8
  02079	08		 DB	 8
  0207a	08		 DB	 8
  0207b	08		 DB	 8
  0207c	08		 DB	 8
  0207d	08		 DB	 8
  0207e	08		 DB	 8
  0207f	08		 DB	 8
  02080	08		 DB	 8
  02081	08		 DB	 8
  02082	08		 DB	 8
  02083	08		 DB	 8
  02084	08		 DB	 8
  02085	08		 DB	 8
  02086	08		 DB	 8
  02087	08		 DB	 8
  02088	08		 DB	 8
  02089	08		 DB	 8
  0208a	08		 DB	 8
  0208b	07		 DB	 7
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy64.c
_TEXT	SEGMENT
r$ = 32
cyl$ = 36
head$ = 40
i$ = 44
rechdr$ = 48
pos$ = 56
trkhdr$ = 64
buf$ = 96
trk$ = 104
heads$ = 112
nullfmt$ = 120
nulltrk	PROC

; 576  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 577  : int             i;                      /* Loop counter              */
; 578  : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 579  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 580  : U32             cyl;                    /* Cylinder number           */
; 581  : U32             head;                   /* Head number               */
; 582  : BYTE            r;                      /* Record number             */
; 583  : BYTE           *pos;                    /* -> Next position in buffer*/
; 584  : 
; 585  :     /* cylinder and head calculations */
; 586  :     cyl = trk / heads;

  00017	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  0001b	99		 cdq
  0001c	f7 7c 24 70	 idiv	 DWORD PTR heads$[rsp]
  00020	89 44 24 24	 mov	 DWORD PTR cyl$[rsp], eax

; 587  :     head = trk % heads;

  00024	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00028	99		 cdq
  00029	f7 7c 24 70	 idiv	 DWORD PTR heads$[rsp]
  0002d	8b c2		 mov	 eax, edx
  0002f	89 44 24 28	 mov	 DWORD PTR head$[rsp], eax

; 588  : 
; 589  :     /* Build the track header */
; 590  :     trkhdr = (CKD_TRKHDR*)buf;

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  00038	48 89 44 24 40	 mov	 QWORD PTR trkhdr$[rsp], rax

; 591  :     trkhdr->bin = 0;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR trkhdr$[rsp]
  00042	c6 00 00	 mov	 BYTE PTR [rax], 0

; 592  :     store_hw(&trkhdr->cyl,  (U16) cyl);

  00045	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  0004a	e8 00 00 00 00	 call	 _byteswap_ushort
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00054	48 ff c1	 inc	 rcx
  00057	0f b7 d0	 movzx	 edx, ax
  0005a	e8 00 00 00 00	 call	 store_hw_noswap

; 593  :     store_hw(&trkhdr->head, (U16) head);

  0005f	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  00064	e8 00 00 00 00	 call	 _byteswap_ushort
  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0006e	48 83 c1 03	 add	 rcx, 3
  00072	0f b7 d0	 movzx	 edx, ax
  00075	e8 00 00 00 00	 call	 store_hw_noswap

; 594  :     pos = buf + CKD_TRKHDR_SIZE;

  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR buf$[rsp]
  0007f	48 83 c0 05	 add	 rax, 5
  00083	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 595  : 
; 596  :     /* Build record zero */
; 597  :     r = 0;

  00088	c6 44 24 20 00	 mov	 BYTE PTR r$[rsp], 0

; 598  :     rechdr = (CKD_RECHDR*)pos;

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00092	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 599  :     pos += CKD_RECHDR_SIZE;

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0009c	48 83 c0 08	 add	 rax, 8
  000a0	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 600  :     store_hw(&rechdr->cyl,  (U16) cyl);

  000a5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  000aa	e8 00 00 00 00	 call	 _byteswap_ushort
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000b4	0f b7 d0	 movzx	 edx, ax
  000b7	e8 00 00 00 00	 call	 store_hw_noswap

; 601  :     store_hw(&rechdr->head, (U16) head);

  000bc	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  000c1	e8 00 00 00 00	 call	 _byteswap_ushort
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000cb	48 83 c1 02	 add	 rcx, 2
  000cf	0f b7 d0	 movzx	 edx, ax
  000d2	e8 00 00 00 00	 call	 store_hw_noswap

; 602  :     rechdr->rec = r;

  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  000dc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  000e1	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 603  :     rechdr->klen = 0;

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  000e9	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 604  :     store_hw(&rechdr->dlen, CKD_R0_DLEN);

  000ed	66 b9 08 00	 mov	 cx, 8
  000f1	e8 00 00 00 00	 call	 _byteswap_ushort
  000f6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000fb	48 83 c1 06	 add	 rcx, 6
  000ff	0f b7 d0	 movzx	 edx, ax
  00102	e8 00 00 00 00	 call	 store_hw_noswap

; 605  :     pos +=                  CKD_R0_DLEN;

  00107	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0010c	48 83 c0 08	 add	 rax, 8
  00110	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 606  :     r++;

  00115	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  0011a	fe c0		 inc	 al
  0011c	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 607  : 
; 608  :     /* Specific null track formatting */
; 609  :     if (nullfmt == CKD_NULLTRK_FMT0)

  00120	83 7c 24 78 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  00125	0f 85 88 00 00
	00		 jne	 $LN5@nulltrk

; 610  :     {
; 611  :         rechdr = (CKD_RECHDR*)pos;

  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00130	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 612  :         pos += CKD_RECHDR_SIZE;

  00135	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0013a	48 83 c0 08	 add	 rax, 8
  0013e	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 613  : 
; 614  :         store_hw(&rechdr->cyl,  (U16) cyl);

  00143	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  00148	e8 00 00 00 00	 call	 _byteswap_ushort
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00152	0f b7 d0	 movzx	 edx, ax
  00155	e8 00 00 00 00	 call	 store_hw_noswap

; 615  :         store_hw(&rechdr->head, (U16) head);

  0015a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  0015f	e8 00 00 00 00	 call	 _byteswap_ushort
  00164	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00169	48 83 c1 02	 add	 rcx, 2
  0016d	0f b7 d0	 movzx	 edx, ax
  00170	e8 00 00 00 00	 call	 store_hw_noswap

; 616  :         rechdr->rec = r;

  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  0017a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  0017f	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 617  :         rechdr->klen = 0;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  00187	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 618  :         store_hw(&rechdr->dlen, 0);

  0018b	33 c9		 xor	 ecx, ecx
  0018d	e8 00 00 00 00	 call	 _byteswap_ushort
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00197	48 83 c1 06	 add	 rcx, 6
  0019b	0f b7 d0	 movzx	 edx, ax
  0019e	e8 00 00 00 00	 call	 store_hw_noswap

; 619  :         r++;

  001a3	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  001a8	fe c0		 inc	 al
  001aa	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 620  :     }

  001ae	e9 c4 00 00 00	 jmp	 $LN6@nulltrk
$LN5@nulltrk:

; 621  :     else if (nullfmt == CKD_NULLTRK_FMT2)

  001b3	83 7c 24 78 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  001b8	0f 85 b9 00 00
	00		 jne	 $LN7@nulltrk

; 622  :     {
; 623  :         for (i = 0; i < 12; i++)

  001be	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN4@nulltrk
$LN2@nulltrk:
  001c8	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@nulltrk:
  001d2	83 7c 24 2c 0c	 cmp	 DWORD PTR i$[rsp], 12
  001d7	0f 8d 9a 00 00
	00		 jge	 $LN3@nulltrk

; 624  :         {
; 625  :             rechdr = (CKD_RECHDR*)pos;

  001dd	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  001e2	48 89 44 24 30	 mov	 QWORD PTR rechdr$[rsp], rax

; 626  :             pos += CKD_RECHDR_SIZE;

  001e7	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  001ec	48 83 c0 08	 add	 rax, 8
  001f0	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 627  : 
; 628  :             store_hw(&rechdr->cyl,  (U16) cyl);

  001f5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR cyl$[rsp]
  001fa	e8 00 00 00 00	 call	 _byteswap_ushort
  001ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00204	0f b7 d0	 movzx	 edx, ax
  00207	e8 00 00 00 00	 call	 store_hw_noswap

; 629  :             store_hw(&rechdr->head, (U16) head);

  0020c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR head$[rsp]
  00211	e8 00 00 00 00	 call	 _byteswap_ushort
  00216	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0021b	48 83 c1 02	 add	 rcx, 2
  0021f	0f b7 d0	 movzx	 edx, ax
  00222	e8 00 00 00 00	 call	 store_hw_noswap

; 630  :             rechdr->rec = r;

  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  0022c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR r$[rsp]
  00231	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 631  :             rechdr->klen = 0;

  00234	48 8b 44 24 30	 mov	 rax, QWORD PTR rechdr$[rsp]
  00239	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 632  :             store_hw(&rechdr->dlen, CKD_NULL_FMT2_DLEN );

  0023d	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  00241	e8 00 00 00 00	 call	 _byteswap_ushort
  00246	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0024b	48 83 c1 06	 add	 rcx, 6
  0024f	0f b7 d0	 movzx	 edx, ax
  00252	e8 00 00 00 00	 call	 store_hw_noswap

; 633  :             r++;

  00257	0f b6 44 24 20	 movzx	 eax, BYTE PTR r$[rsp]
  0025c	fe c0		 inc	 al
  0025e	88 44 24 20	 mov	 BYTE PTR r$[rsp], al

; 634  :             pos +=                  CKD_NULL_FMT2_DLEN;

  00262	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  00267	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0026d	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 635  :         }

  00272	e9 51 ff ff ff	 jmp	 $LN2@nulltrk
$LN3@nulltrk:
$LN7@nulltrk:
$LN6@nulltrk:

; 636  :     }
; 637  : 
; 638  :     /* Build the end of track marker */
; 639  :     memcpy (pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE);

  00277	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0027c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  00283	48 89 08	 mov	 QWORD PTR [rax], rcx

; 640  :     pos +=                    CKD_ENDTRK_SIZE;

  00286	48 8b 44 24 38	 mov	 rax, QWORD PTR pos$[rsp]
  0028b	48 83 c0 08	 add	 rax, 8
  0028f	48 89 44 24 38	 mov	 QWORD PTR pos$[rsp], rax

; 641  : 
; 642  :     return 0;

  00294	33 c0		 xor	 eax, eax

; 643  : }

  00296	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0029a	c3		 ret	 0
nulltrk	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy64.c
_TEXT	SEGMENT
tv83 = 32
i$ = 64
n$ = 72
status	PROC

; 750  : {

$LN13:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 751  :     if (extgui)

  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	74 53		 je	 SHORT $LN8@status
$LN4@status:

; 752  :     {
; 753  :         UNREFERENCED( n );

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@status

; 754  :         if (i % 100)

  0001e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00022	99		 cdq
  00023	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00028	f7 f9		 idiv	 ecx
  0002a	8b c2		 mov	 eax, edx
  0002c	85 c0		 test	 eax, eax
  0002e	74 05		 je	 SHORT $LN10@status

; 755  :             return;

  00030	e9 8c 00 00 00	 jmp	 $LN1@status
$LN10@status:
$LN7@status:

; 756  :         EXTGUIMSG( "TRK=%d\n", i );

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0003c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003f	74 20		 je	 SHORT $LN11@status
  00041	b9 02 00 00 00	 mov	 ecx, 2
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004c	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$[rsp]
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169208
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN11@status:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 ce		 jne	 SHORT $LN7@status

; 757  :         return;

  00067	eb 58		 jmp	 SHORT $LN1@status

; 758  :     }

  00069	eb 56		 jmp	 SHORT $LN9@status
$LN8@status:

; 759  :     else
; 760  :     {
; 761  :         static char indic[] = "|/-\\";
; 762  : //      if (i % 101 != 1)
; 763  : //          return;
; 764  :         printf ("\r%c %3d%% %7d", indic[i%4], (int)((i*100.0)/n), i);

  0006b	f2 0f 2a 44 24
	40		 cvtsi2sd xmm0, DWORD PTR i$[rsp]
  00071	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4059000000000000
  00079	f2 0f 2a 4c 24
	48		 cvtsi2sd xmm1, DWORD PTR n$[rsp]
  0007f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00083	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00087	89 44 24 20	 mov	 DWORD PTR tv83[rsp], eax
  0008b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0008f	99		 cdq
  00090	83 e2 03	 and	 edx, 3
  00093	03 c2		 add	 eax, edx
  00095	83 e0 03	 and	 eax, 3
  00098	2b c2		 sub	 eax, edx
  0009a	48 98		 cdqe
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?indic@?5??status@@9@9
  000a3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a7	44 8b 4c 24 40	 mov	 r9d, DWORD PTR i$[rsp]
  000ac	8b 4c 24 20	 mov	 ecx, DWORD PTR tv83[rsp]
  000b0	44 8b c1	 mov	 r8d, ecx
  000b3	8b d0		 mov	 edx, eax
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169209
  000bc	e8 00 00 00 00	 call	 printf
$LN9@status:
$LN1@status:

; 765  :     }
; 766  : }

  000c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c5	c3		 ret	 0
status	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcopy64.c
_TEXT	SEGMENT
buffsize$1 = 96
zlib$ = 100
bzip2$ = 104
lfs$ = 108
rc$2 = 112
msgbuf$3 = 120
chunksize$4 = 128
$T5 = 136
$T6 = 144
$T7 = 152
vargs$8 = 160
lfsbuf$ = 176
bzbuf$ = 256
zbuf$ = 336
__$ArrayPad$ = 416
pgm$ = 448
msgfmt$ = 456
syntax	PROC

; 649  : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 650  :     int zlib  = 0;

  0002d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR zlib$[rsp], 0

; 651  :     int bzip2 = 0;

  00035	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR bzip2$[rsp], 0

; 652  :     int lfs   = 0;

  0003d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR lfs$[rsp], 0

; 653  : 
; 654  :     char zbuf  [80];
; 655  :     char bzbuf [80];
; 656  :     char lfsbuf[80];
; 657  : 
; 658  :     zbuf  [0] = 0;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	48 6b c0 00	 imul	 rax, rax, 0
  0004e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  00056	48 83 bc 24 88
	00 00 00 50	 cmp	 QWORD PTR $T5[rsp], 80	; 00000050H
  0005f	73 02		 jae	 SHORT $LN27@syntax
  00061	eb 05		 jmp	 SHORT $LN28@syntax
$LN27@syntax:
  00063	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN28@syntax:
  00068	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  00070	c6 84 04 50 01
	00 00 00	 mov	 BYTE PTR zbuf$[rsp+rax], 0

; 659  :     bzbuf [0] = 0;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	48 6b c0 00	 imul	 rax, rax, 0
  00081	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  00089	48 83 bc 24 90
	00 00 00 50	 cmp	 QWORD PTR $T6[rsp], 80	; 00000050H
  00092	73 02		 jae	 SHORT $LN29@syntax
  00094	eb 05		 jmp	 SHORT $LN30@syntax
$LN29@syntax:
  00096	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN30@syntax:
  0009b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  000a3	c6 84 04 00 01
	00 00 00	 mov	 BYTE PTR bzbuf$[rsp+rax], 0

; 660  :     lfsbuf[0] = 0;

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T7[rsp], rax
  000bc	48 83 bc 24 98
	00 00 00 50	 cmp	 QWORD PTR $T7[rsp], 80	; 00000050H
  000c5	73 02		 jae	 SHORT $LN31@syntax
  000c7	eb 05		 jmp	 SHORT $LN32@syntax
$LN31@syntax:
  000c9	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN32@syntax:
  000ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  000d6	c6 84 04 b0 00
	00 00 00	 mov	 BYTE PTR lfsbuf$[rsp+rax], 0

; 661  : 
; 662  :     /* Show them their syntax error... */
; 663  :     if (msgfmt)

  000de	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR msgfmt$[rsp], 0
  000e7	0f 84 1e 01 00
	00		 je	 $LN5@syntax

; 664  :     {
; 665  :         const int  chunksize  = 128;

  000ed	c7 84 24 80 00
	00 00 80 00 00
	00		 mov	 DWORD PTR chunksize$4[rsp], 128 ; 00000080H

; 666  :         int        rc         = -1;

  000f8	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR rc$2[rsp], -1

; 667  :         int        buffsize   =  0;

  00100	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR buffsize$1[rsp], 0

; 668  :         char*      msgbuf     = NULL;

  00108	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR msgbuf$3[rsp], 0
$LN33@syntax:
$LN4@syntax:

; 669  :         va_list    vargs;
; 670  : 
; 671  :         do
; 672  :         {
; 673  :             if (msgbuf) free( msgbuf );

  00111	48 83 7c 24 78
	00		 cmp	 QWORD PTR msgbuf$3[rsp], 0
  00117	74 0b		 je	 SHORT $LN6@syntax
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@syntax:

; 674  :             if (!(msgbuf = malloc( buffsize += chunksize )))

  00124	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR chunksize$4[rsp]
  0012b	8b 4c 24 60	 mov	 ecx, DWORD PTR buffsize$1[rsp]
  0012f	03 c8		 add	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 60	 mov	 DWORD PTR buffsize$1[rsp], eax
  00137	48 63 44 24 60	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00145	48 89 44 24 78	 mov	 QWORD PTR msgbuf$3[rsp], rax
  0014a	48 83 7c 24 78
	00		 cmp	 QWORD PTR msgbuf$3[rsp], 0
  00150	75 01		 jne	 SHORT $LN7@syntax

; 675  :                 BREAK_INTO_DEBUGGER();

  00152	cc		 int	 3
$LN7@syntax:

; 676  : 
; 677  :             va_end(   vargs );

  00153	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vargs$8[rsp], 0

; 678  :             va_start( vargs, msgfmt );

  0015f	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR msgfmt$[rsp+8]
  00167	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR vargs$8[rsp], rax

; 679  : 
; 680  :             rc = vsnprintf( msgbuf, buffsize, msgfmt, vargs );

  0016f	48 63 44 24 60	 movsxd	 rax, DWORD PTR buffsize$1[rsp]
  00174	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR vargs$8[rsp]
  0017c	4c 8b 84 24 c8
	01 00 00	 mov	 r8, QWORD PTR msgfmt$[rsp]
  00184	48 8b d0	 mov	 rdx, rax
  00187	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  00192	89 44 24 70	 mov	 DWORD PTR rc$2[rsp], eax

; 681  :         }
; 682  :         while (rc < 0 || rc >= buffsize);

  00196	83 7c 24 70 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0019b	0f 8c 70 ff ff
	ff		 jl	 $LN4@syntax
  001a1	8b 44 24 60	 mov	 eax, DWORD PTR buffsize$1[rsp]
  001a5	39 44 24 70	 cmp	 DWORD PTR rc$2[rsp], eax
  001a9	0f 8d 62 ff ff
	ff		 jge	 $LN33@syntax

; 683  : 
; 684  :         // "Syntax error: %s"
; 685  :         FWRMSG( stderr, HHC02594, "E", msgbuf );

  001af	b9 02 00 00 00	 mov	 ecx, 2
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  001bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169116
  001cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169117
  001d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169118
  001ee	ba ad 02 00 00	 mov	 edx, 685		; 000002adH
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169119
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 686  :         free( msgbuf );

  00200	48 8b 4c 24 78	 mov	 rcx, QWORD PTR msgbuf$3[rsp]
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@syntax:

; 687  :     }
; 688  : 
; 689  : #ifdef CCKD_COMPRESS_ZLIB
; 690  :     zlib = 1;

  0020b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR zlib$[rsp], 1

; 691  : #endif
; 692  : 
; 693  : #ifdef CCKD_COMPRESS_BZIP2
; 694  :     bzip2 = 1;

  00213	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR bzip2$[rsp], 1

; 695  : #endif
; 696  : 
; 697  :     if (sizeof(off_t) > 4)

  0021b	33 c0		 xor	 eax, eax
  0021d	83 f8 01	 cmp	 eax, 1
  00220	74 08		 je	 SHORT $LN8@syntax

; 698  :         lfs = 1;

  00222	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR lfs$[rsp], 1
$LN8@syntax:

; 699  : 
; 700  : #define HHC02435I  "HHC02435I "     // ckd2cckd64
; 701  : #define HHC02436I  "HHC02436I "     // cckd642ckd
; 702  : #define HHC02437I  "HHC02437I "     // fba2cfba64
; 703  : #define HHC02438I  "HHC02438I "     // cfba642fba
; 704  : #define HHC02439I  "HHC02439I "     // dasdcopy64
; 705  : 
; 706  : #define Z_HELP     "  -z       compress using zlib [default]"
; 707  : #define BZ_HELP    "  -bz2     compress using bzip2"
; 708  : #define LFS_HELP   "  -lfs     create single large output file"
; 709  : 
; 710  :     /* Display help information... */
; 711  :     if (strcasecmp( pgm,                   "ckd2cckd64"  ) == 0)

  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169123
  00231	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0023f	85 c0		 test	 eax, eax
  00241	0f 85 ce 00 00
	00		 jne	 $LN9@syntax

; 712  :     {
; 713  :         if (zlib)  MSGBUF(  zbuf, "%s%s\n", HHC02435I,  Z_HELP );

  00247	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  0024c	74 2d		 je	 SHORT $LN11@syntax
  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169125
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169126
  00261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169127
  00268	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0026d	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN11@syntax:

; 714  :         if (bzip2) MSGBUF( bzbuf, "%s%s\n", HHC02435I, BZ_HELP );

  0027b	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  00280	74 2d		 je	 SHORT $LN12@syntax
  00282	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169129
  00289	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169130
  00295	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169131
  0029c	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  002a1	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN12@syntax:

; 715  :         WRMSG(                              HHC02435, "I", zbuf, bzbuf );

  002af	b9 01 00 00 00	 mov	 ecx, 1
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ba	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  002c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c7	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  002cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169132
  002db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169133
  002e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169134
  002fe	ba cb 02 00 00	 mov	 edx, 715		; 000002cbH
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169135
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 716  :     }

  00310	e9 62 03 00 00	 jmp	 $LN10@syntax
$LN9@syntax:

; 717  :     else if (strcasecmp( pgm,             "cckd642ckd"   ) == 0)

  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169138
  0031c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00324	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0032a	85 c0		 test	 eax, eax
  0032c	0f 85 8d 00 00
	00		 jne	 $LN13@syntax

; 718  :     {
; 719  :         if (lfs) MSGBUF( lfsbuf, "%s%s\n", HHC02436I, LFS_HELP );

  00332	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00337	74 2d		 je	 SHORT $LN15@syntax
  00339	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169140
  00340	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00345	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169141
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169142
  00353	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00358	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN15@syntax:

; 720  :         WRMSG(                             HHC02436, "I", lfsbuf );

  00366	b9 01 00 00 00	 mov	 ecx, 1
  0036b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00371	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  00379	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169143
  00385	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169144
  00391	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00396	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039b	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169145
  003a8	ba d0 02 00 00	 mov	 edx, 720		; 000002d0H
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169146
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 721  :     }

  003ba	e9 b8 02 00 00	 jmp	 $LN14@syntax
$LN13@syntax:

; 722  :     else if (strcasecmp( pgm,              "fba2cfba64"  ) == 0)

  003bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169149
  003c6	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  003ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003d4	85 c0		 test	 eax, eax
  003d6	0f 85 ce 00 00
	00		 jne	 $LN16@syntax

; 723  :     {
; 724  :         if (zlib)  MSGBUF(  zbuf, "%s%s\n", HHC02437I,  Z_HELP );

  003dc	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  003e1	74 2d		 je	 SHORT $LN18@syntax
  003e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169151
  003ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169152
  003f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169153
  003fd	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00402	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN18@syntax:

; 725  :         if (bzip2) MSGBUF( bzbuf, "%s%s\n", HHC02437I, BZ_HELP );

  00410	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  00415	74 2d		 je	 SHORT $LN19@syntax
  00417	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169155
  0041e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00423	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169156
  0042a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169157
  00431	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00436	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN19@syntax:

; 726  :         WRMSG(                              HHC02437, "I", zbuf, bzbuf );

  00444	b9 01 00 00 00	 mov	 ecx, 1
  00449	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  00457	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0045c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00464	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169158
  00470	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00475	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169159
  0047c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00481	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00486	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169160
  00493	ba d6 02 00 00	 mov	 edx, 726		; 000002d6H
  00498	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 727  :     }

  004a5	e9 cd 01 00 00	 jmp	 $LN17@syntax
$LN16@syntax:

; 728  :     else if (strcasecmp( pgm,             "cfba642fba"   ) == 0)

  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169164
  004b1	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004bf	85 c0		 test	 eax, eax
  004c1	0f 85 8d 00 00
	00		 jne	 $LN20@syntax

; 729  :     {
; 730  :         if (lfs) MSGBUF( lfsbuf, "%s%s\n", HHC02438I, LFS_HELP );

  004c7	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  004cc	74 2d		 je	 SHORT $LN22@syntax
  004ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169166
  004d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169167
  004e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169168
  004e8	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  004ed	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN22@syntax:

; 731  :         WRMSG(                             HHC02438, "I", lfsbuf );

  004fb	b9 01 00 00 00	 mov	 ecx, 1
  00500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00506	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  0050e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169169
  0051a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0051f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169170
  00526	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00530	41 b9 03 00 00
	00		 mov	 r9d, 3
  00536	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169171
  0053d	ba db 02 00 00	 mov	 edx, 731		; 000002dbH
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169172
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 732  :     }

  0054f	e9 23 01 00 00	 jmp	 $LN21@syntax
$LN20@syntax:

; 733  :     else
; 734  :     {
; 735  :         if (zlib)  MSGBUF(   zbuf, "%s%s\n", HHC02439I,   Z_HELP );

  00554	83 7c 24 64 00	 cmp	 DWORD PTR zlib$[rsp], 0
  00559	74 2d		 je	 SHORT $LN23@syntax
  0055b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169174
  00562	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00567	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169175
  0056e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169176
  00575	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0057a	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN23@syntax:

; 736  :         if (bzip2) MSGBUF(  bzbuf, "%s%s\n", HHC02439I,  BZ_HELP );

  00588	83 7c 24 68 00	 cmp	 DWORD PTR bzip2$[rsp], 0
  0058d	74 2d		 je	 SHORT $LN24@syntax
  0058f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169178
  00596	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169179
  005a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169180
  005a9	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  005ae	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  005b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN24@syntax:

; 737  :         if (lfs)   MSGBUF( lfsbuf, "%s%s\n", HHC02439I, LFS_HELP );

  005bc	83 7c 24 6c 00	 cmp	 DWORD PTR lfs$[rsp], 0
  005c1	74 2d		 je	 SHORT $LN25@syntax
  005c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169182
  005ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005cf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169183
  005d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169184
  005dd	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  005e2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  005ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN25@syntax:

; 738  :         WRMSG(                               HHC02439, "I", pgm, zbuf, bzbuf, lfsbuf,

  005f0	b9 01 00 00 00	 mov	 ecx, 1
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169185
  00602	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00607	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR lfsbuf$[rsp]
  0060f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00614	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR bzbuf$[rsp]
  0061c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00621	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR zbuf$[rsp]
  00629	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0062e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00636	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0063b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169186
  00642	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169187
  0064e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00653	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00658	41 b9 03 00 00
	00		 mov	 r9d, 3
  0065e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169188
  00665	ba e3 02 00 00	 mov	 edx, 739		; 000002e3H
  0066a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169189
  00671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@syntax:
$LN17@syntax:
$LN14@syntax:
$LN10@syntax:

; 739  :             "CKD, CKD64, CCKD, CCKD64, FBA, FBA64, CFBA, CFBA64" );
; 740  :     }
; 741  : 
; 742  :     return -1;

  00677	b8 ff ff ff ff	 mov	 eax, -1
$LN26@syntax:

; 743  : 
; 744  : }

  0067c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00684	48 33 cc	 xor	 rcx, rsp
  00687	e8 00 00 00 00	 call	 __security_check_cookie
  0068c	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00693	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
