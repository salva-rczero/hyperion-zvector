; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	timer_thread
PUBLIC	rubato_thread
PUBLIC	update_cpu_timer
PUBLIC	__real@4059000000000000
PUBLIC	__real@4069000000000000
PUBLIC	__real@4109e6a000000000
PUBLIC	__real@411174c000000000
EXTRN	log:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	__imp_usleep:PROC
EXTRN	update_tod_clock:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	chk_int_timer:PROC
EXTRN	update_maxrates_hwm:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	tod_value:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
pdata	SEGMENT
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+169
	DD	imagerel $unwind$host_tod
$pdata$timer_thread DD imagerel $LN24
	DD	imagerel $LN24+1656
	DD	imagerel $unwind$timer_thread
$pdata$rubato_thread DD imagerel $LN23
	DD	imagerel $LN23+1179
	DD	imagerel $unwind$rubato_thread
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$update_cpu_timer DD imagerel $LN60
	DD	imagerel $LN60+1290
	DD	imagerel $unwind$update_cpu_timer
pdata	ENDS
;	COMDAT __real@411174c000000000
CONST	SEGMENT
__real@411174c000000000 DQ 0411174c000000000r	; 286000
CONST	ENDS
;	COMDAT __real@4109e6a000000000
CONST	SEGMENT
__real@4109e6a000000000 DQ 04109e6a000000000r	; 212180
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
_DATA	SEGMENT
$SG168177 DB	'timer.c:45', 00H
	ORG $+5
$SG168207 DB	'timer.c:151', 00H
$SG168244 DB	'I', 00H
	ORG $+2
$SG168208 DB	'timer.c:153', 00H
$SG168265 DB	'I', 00H
	ORG $+2
$SG168241 DB	'timer.c:193', 00H
$SG168297 DB	'I', 00H
	ORG $+2
$SG168242 DB	'timer_thread', 00H
	ORG $+3
$SG168243 DB	'timer.c:196', 00H
$SG168308 DB	'I', 00H
	ORG $+2
$SG168245 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG168246 DB	'timer_thread', 00H
	ORG $+3
$SG168247 DB	'timer.c', 00H
$SG168249 DB	'timer.c:223', 00H
	ORG $+4
$SG168251 DB	'timer.c:227', 00H
	ORG $+4
$SG168253 DB	'timer.c:237', 00H
	ORG $+4
$SG168260 DB	'timer.c:312', 00H
	ORG $+4
$SG168263 DB	'timer_thread', 00H
	ORG $+3
$SG168264 DB	'timer.c:341', 00H
	ORG $+4
$SG168266 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG168267 DB	'timer_thread', 00H
	ORG $+3
$SG168268 DB	'timer.c', 00H
$SG168294 DB	'timer.c:369', 00H
	ORG $+4
$SG168295 DB	'rubato_thread', 00H
	ORG $+2
$SG168296 DB	'timer.c:372', 00H
	ORG $+4
$SG168298 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG168299 DB	'rubato_thread', 00H
	ORG $+2
$SG168300 DB	'timer.c', 00H
$SG168301 DB	'timer.c:378', 00H
	ORG $+4
$SG168303 DB	'timer.c:430', 00H
	ORG $+4
$SG168304 DB	'timer.c:434', 00H
	ORG $+4
$SG168305 DB	'timer.c:440', 00H
	ORG $+4
$SG168306 DB	'rubato_thread', 00H
	ORG $+2
$SG168307 DB	'timer.c:443', 00H
	ORG $+4
$SG168309 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG168310 DB	'rubato_thread', 00H
	ORG $+2
$SG168311 DB	'timer.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:rubato_thread
	DD	016H
	DD	0483H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	097H
voltbl	ENDS
xdata	SEGMENT
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$timer_thread DD 020c01H
	DD	01d010cH
$unwind$rubato_thread DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$update_cpu_timer DD 010401H
	DD	08204H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\timer.c
_TEXT	SEGMENT
cpu$ = 32
regs$ = 40
intmask$ = 48
update_cpu_timer PROC

; 35   : {

$LN60:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 36   : int             cpu;                    /* CPU counter               */
; 37   : REGS           *regs;                   /* -> CPU register context   */
; 38   : CPU_BITMAP      intmask = 0;            /* Interrupt CPU mask        */

  00004	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR intmask$[rsp], 0

; 39   : 
; 40   :     /* If no CPUs are available, just return (device server mode) */
; 41   :     if (!sysblk.hicpu)

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0001b	75 05		 jne	 SHORT $LN29@update_cpu

; 42   :       return;

  0001d	e9 e3 04 00 00	 jmp	 $LN1@update_cpu
$LN29@update_cpu:

; 43   : 
; 44   :     /* Access the diffent register contexts with the intlock held */
; 45   :     OBTAIN_INTLOCK(NULL);

  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168177
  00029	33 c9		 xor	 ecx, ecx
  0002b	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 46   : 
; 47   :     /* Check for [1] clock comparator, [2] cpu timer, and
; 48   :      * [3] interval timer interrupts for each CPU.
; 49   :      */
; 50   :     for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00030	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00038	eb 0a		 jmp	 SHORT $LN4@update_cpu
$LN2@update_cpu:
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@update_cpu:
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00051	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00055	0f 8d 8b 04 00
	00		 jge	 $LN3@update_cpu

; 51   :     {
; 52   :         /* Ignore this CPU if it is not started */
; 53   :         if (!IS_CPU_ONLINE(cpu)
; 54   :          || CPUSTATE_STOPPED == sysblk.regs[cpu]->cpustate)

  0005b	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00067	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00070	74 1d		 je	 SHORT $LN31@update_cpu
  00072	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00086	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0008a	83 f8 03	 cmp	 eax, 3
  0008d	75 02		 jne	 SHORT $LN30@update_cpu
$LN31@update_cpu:

; 55   :             continue;

  0008f	eb a9		 jmp	 SHORT $LN2@update_cpu
$LN30@update_cpu:

; 56   : 
; 57   :         /* Point to the CPU register context */
; 58   :         regs = sysblk.regs[cpu];

  00091	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009d	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000a5	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax

; 59   : 
; 60   :         /*-------------------------------------------*
; 61   :          * [1] Check for clock comparator interrupt  *
; 62   :          *-------------------------------------------*/
; 63   :         if (TOD_CLOCK(regs) > regs->clkc)

  000aa	48 b8 ff ff ff
	ff ff ff ff 00	 mov	 rax, 72057594037927935	; 00ffffffffffffffH
  000b4	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  000bb	48 23 c8	 and	 rcx, rax
  000be	48 8b c1	 mov	 rax, rcx
  000c1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  000cd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  000d9	76 6e		 jbe	 SHORT $LN32@update_cpu

; 64   :         {
; 65   :             if (!IS_IC_CLKC(regs))

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000e3	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  000e8	85 c0		 test	 eax, eax
  000ea	75 5b		 jne	 SHORT $LN34@update_cpu
$LN7@update_cpu:

; 66   :             {
; 67   :                 ON_IC_CLKC(regs);

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000f4	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  000f9	85 c0		 test	 eax, eax
  000fb	74 17		 je	 SHORT $LN35@update_cpu
  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00102	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00105	0d 00 08 00 80	 or	 eax, -2147481600	; 80000800H
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00112	eb 14		 jmp	 SHORT $LN36@update_cpu
$LN35@update_cpu:
  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00119	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0011c	0f ba e8 0b	 bts	 eax, 11
  00120	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN36@update_cpu:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 be		 jne	 SHORT $LN7@update_cpu

; 68   :                 intmask |= regs->cpubit;

  0012e	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00137	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  0013c	48 0b c8	 or	 rcx, rax
  0013f	48 8b c1	 mov	 rax, rcx
  00142	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax
$LN34@update_cpu:

; 69   :             }
; 70   :         }

  00147	eb 2b		 jmp	 SHORT $LN33@update_cpu
$LN32@update_cpu:

; 71   :         else if (IS_IC_CLKC(regs))

  00149	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00151	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00156	85 c0		 test	 eax, eax
  00158	74 1a		 je	 SHORT $LN37@update_cpu
$LN10@update_cpu:

; 72   :             OFF_IC_CLKC(regs);

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00162	0f ba f0 0b	 btr	 eax, 11
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0016e	33 c0		 xor	 eax, eax
  00170	85 c0		 test	 eax, eax
  00172	75 e6		 jne	 SHORT $LN10@update_cpu
$LN37@update_cpu:
$LN33@update_cpu:

; 73   : 
; 74   : #if defined(_FEATURE_SIE)
; 75   :         /* If running under SIE also check the SIE copy */
; 76   :         if(regs->sie_active)

  00174	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017f	83 e0 01	 and	 eax, 1
  00182	85 c0		 test	 eax, eax
  00184	0f 84 eb 00 00
	00		 je	 $LN38@update_cpu

; 77   :         {
; 78   :         /* Signal clock comparator interrupt if needed */
; 79   :             if(TOD_CLOCK(GUESTREGS) > GUESTREGS->clkc)

  0018a	48 b8 ff ff ff
	ff ff ff ff 00	 mov	 rax, 72057594037927935	; 00ffffffffffffffH
  00194	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  0019b	48 23 c8	 and	 rcx, rax
  0019e	48 8b c1	 mov	 rax, rcx
  001a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001ad	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  001b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001c0	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  001c7	0f 86 80 00 00
	00		 jbe	 $LN39@update_cpu
$LN13@update_cpu:

; 80   :             {
; 81   :                 ON_IC_CLKC(GUESTREGS);

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001d9	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  001dc	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  001e1	85 c0		 test	 eax, eax
  001e3	74 25		 je	 SHORT $LN41@update_cpu
  001e5	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001f1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001f4	0d 00 08 00 80	 or	 eax, -2147481600	; 80000800H
  001f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00205	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00208	eb 22		 jmp	 SHORT $LN42@update_cpu
$LN41@update_cpu:
  0020a	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0020f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00216	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00219	0f ba e8 0b	 bts	 eax, 11
  0021d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00229	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN42@update_cpu:
  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	75 9b		 jne	 SHORT $LN13@update_cpu

; 82   :                 intmask |= regs->cpubit;

  00232	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00237	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0023b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  00240	48 0b c8	 or	 rcx, rax
  00243	48 8b c1	 mov	 rax, rcx
  00246	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax

; 83   :             }

  0024b	eb 28		 jmp	 SHORT $LN40@update_cpu
$LN39@update_cpu:
$LN16@update_cpu:

; 84   :             else
; 85   :                 OFF_IC_CLKC(GUESTREGS);

  0024d	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00252	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00259	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0025c	0f ba f0 0b	 btr	 eax, 11
  00260	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0026c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0026f	33 c0		 xor	 eax, eax
  00271	85 c0		 test	 eax, eax
  00273	75 d8		 jne	 SHORT $LN16@update_cpu
$LN40@update_cpu:
$LN38@update_cpu:

; 86   :         }
; 87   : #endif /*defined(_FEATURE_SIE)*/
; 88   : 
; 89   :         /*-------------------------------------------*
; 90   :          * [2] Decrement the CPU timer for each CPU  *
; 91   :          *-------------------------------------------*/
; 92   : 
; 93   :         /* Set interrupt flag if the CPU timer is negative */
; 94   :         if (CPU_TIMER(regs) < 0)

  00275	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	e8 00 00 00 00	 call	 get_cpu_timer
  0027f	48 85 c0	 test	 rax, rax
  00282	7d 6e		 jge	 SHORT $LN43@update_cpu

; 95   :         {
; 96   :             if (!IS_IC_PTIMER(regs))

  00284	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00289	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0028c	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00291	85 c0		 test	 eax, eax
  00293	75 5b		 jne	 SHORT $LN45@update_cpu
$LN19@update_cpu:

; 97   :             {
; 98   :                 ON_IC_PTIMER(regs);

  00295	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0029d	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  002a2	85 c0		 test	 eax, eax
  002a4	74 17		 je	 SHORT $LN46@update_cpu
  002a6	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  002ab	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002ae	0d 00 04 00 80	 or	 eax, -2147482624	; 80000400H
  002b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  002bb	eb 14		 jmp	 SHORT $LN47@update_cpu
$LN46@update_cpu:
  002bd	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  002c2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002c5	0f ba e8 0a	 bts	 eax, 10
  002c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN47@update_cpu:
  002d1	33 c0		 xor	 eax, eax
  002d3	85 c0		 test	 eax, eax
  002d5	75 be		 jne	 SHORT $LN19@update_cpu

; 99   :                 intmask |= regs->cpubit;

  002d7	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  002e5	48 0b c8	 or	 rcx, rax
  002e8	48 8b c1	 mov	 rax, rcx
  002eb	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax
$LN45@update_cpu:

; 100  :             }
; 101  :         }

  002f0	eb 2b		 jmp	 SHORT $LN44@update_cpu
$LN43@update_cpu:

; 102  :         else if(IS_IC_PTIMER(regs))

  002f2	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  002f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002fa	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  002ff	85 c0		 test	 eax, eax
  00301	74 1a		 je	 SHORT $LN48@update_cpu
$LN22@update_cpu:

; 103  :             OFF_IC_PTIMER(regs);

  00303	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00308	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0030b	0f ba f0 0a	 btr	 eax, 10
  0030f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00317	33 c0		 xor	 eax, eax
  00319	85 c0		 test	 eax, eax
  0031b	75 e6		 jne	 SHORT $LN22@update_cpu
$LN48@update_cpu:
$LN44@update_cpu:

; 104  : 
; 105  : #if defined(_FEATURE_SIE)
; 106  :         /* When running under SIE also update the SIE copy */
; 107  :         if(regs->sie_active)

  0031d	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00328	83 e0 01	 and	 eax, 1
  0032b	85 c0		 test	 eax, eax
  0032d	0f 84 c2 00 00
	00		 je	 $LN49@update_cpu

; 108  :         {
; 109  :             /* Set interrupt flag if the CPU timer is negative */
; 110  :             if (CPU_TIMER(GUESTREGS) < 0)

  00333	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00338	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0033f	e8 00 00 00 00	 call	 get_cpu_timer
  00344	48 85 c0	 test	 rax, rax
  00347	0f 8d 80 00 00
	00		 jge	 $LN50@update_cpu
$LN25@update_cpu:

; 111  :             {
; 112  :                 ON_IC_PTIMER(GUESTREGS);

  0034d	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00352	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00359	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0035c	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00361	85 c0		 test	 eax, eax
  00363	74 25		 je	 SHORT $LN52@update_cpu
  00365	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0036a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00371	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00374	0d 00 04 00 80	 or	 eax, -2147482624	; 80000400H
  00379	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00385	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00388	eb 22		 jmp	 SHORT $LN53@update_cpu
$LN52@update_cpu:
  0038a	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0038f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00396	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00399	0f ba e8 0a	 bts	 eax, 10
  0039d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003a9	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN53@update_cpu:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	75 9b		 jne	 SHORT $LN25@update_cpu

; 113  :                 intmask |= regs->cpubit;

  003b2	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  003b7	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  003bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  003c0	48 0b c8	 or	 rcx, rax
  003c3	48 8b c1	 mov	 rax, rcx
  003c6	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax

; 114  :             }

  003cb	eb 28		 jmp	 SHORT $LN51@update_cpu
$LN50@update_cpu:
$LN28@update_cpu:

; 115  :             else
; 116  :                 OFF_IC_PTIMER(GUESTREGS);

  003cd	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  003d2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003d9	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003dc	0f ba f0 0a	 btr	 eax, 10
  003e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  003e5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003ec	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003ef	33 c0		 xor	 eax, eax
  003f1	85 c0		 test	 eax, eax
  003f3	75 d8		 jne	 SHORT $LN28@update_cpu
$LN51@update_cpu:
$LN49@update_cpu:

; 117  :         }
; 118  : #endif /*defined(_FEATURE_SIE)*/
; 119  : 
; 120  : #if defined(_FEATURE_INTERVAL_TIMER)
; 121  :         /*-------------------------------------------*
; 122  :          * [3] Check for interval timer interrupt    *
; 123  :          *-------------------------------------------*/
; 124  : 
; 125  :         if(regs->arch_mode == ARCH_370_IDX)

  003f5	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  003fa	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  003fe	75 27		 jne	 SHORT $LN54@update_cpu

; 126  :         {
; 127  :             if( chk_int_timer(regs) )

  00400	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00405	e8 00 00 00 00	 call	 chk_int_timer
  0040a	85 c0		 test	 eax, eax
  0040c	74 19		 je	 SHORT $LN55@update_cpu

; 128  :                 intmask |= regs->cpubit;

  0040e	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00413	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00417	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  0041c	48 0b c8	 or	 rcx, rax
  0041f	48 8b c1	 mov	 rax, rcx
  00422	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax
$LN55@update_cpu:
$LN54@update_cpu:

; 129  :         }
; 130  : 
; 131  : 
; 132  : #if defined(_FEATURE_SIE)
; 133  :         /* When running under SIE also update the SIE copy */
; 134  :         if(regs->sie_active)

  00427	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0042c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00432	83 e0 01	 and	 eax, 1
  00435	85 c0		 test	 eax, eax
  00437	0f 84 a4 00 00
	00		 je	 $LN56@update_cpu

; 135  :         {
; 136  :             if(SIE_STATE_BIT_ON(GUESTREGS, M, 370)
; 137  :               && SIE_STATE_BIT_OFF(GUESTREGS, M, ITMOF))

  0043d	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00442	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00449	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0044f	d1 e8		 shr	 eax, 1
  00451	83 e0 01	 and	 eax, 1
  00454	85 c0		 test	 eax, eax
  00456	0f 84 85 00 00
	00		 je	 $LN57@update_cpu
  0045c	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00461	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00468	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0046f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00473	83 e0 10	 and	 eax, 16
  00476	85 c0		 test	 eax, eax
  00478	74 67		 je	 SHORT $LN57@update_cpu
  0047a	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00486	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0048c	d1 e8		 shr	 eax, 1
  0048e	83 e0 01	 and	 eax, 1
  00491	85 c0		 test	 eax, eax
  00493	74 4c		 je	 SHORT $LN57@update_cpu
  00495	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0049a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004a1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004a8	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  004ac	83 e0 04	 and	 eax, 4
  004af	85 c0		 test	 eax, eax
  004b1	75 2e		 jne	 SHORT $LN57@update_cpu

; 138  :             {
; 139  :                 if( chk_int_timer(GUESTREGS) )

  004b3	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  004b8	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  004bf	e8 00 00 00 00	 call	 chk_int_timer
  004c4	85 c0		 test	 eax, eax
  004c6	74 19		 je	 SHORT $LN58@update_cpu

; 140  :                     intmask |= regs->cpubit;

  004c8	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  004cd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  004d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  004d6	48 0b c8	 or	 rcx, rax
  004d9	48 8b c1	 mov	 rax, rcx
  004dc	48 89 44 24 30	 mov	 QWORD PTR intmask$[rsp], rax
$LN58@update_cpu:
$LN57@update_cpu:
$LN56@update_cpu:

; 141  :             }
; 142  :         }
; 143  : #endif /*defined(_FEATURE_SIE)*/
; 144  : 
; 145  : #endif /*defined(_FEATURE_INTERVAL_TIMER)*/
; 146  : 
; 147  :     } /* end for(cpu) */

  004e1	e9 54 fb ff ff	 jmp	 $LN2@update_cpu
$LN3@update_cpu:

; 148  : 
; 149  :     /* If a timer interrupt condition was detected for any CPU
; 150  :        then wake up those CPUs if they are waiting */
; 151  :     WAKEUP_CPUS_MASK (intmask);

  004e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168207
  004ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intmask$[rsp]
  004f2	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 152  : 
; 153  :     RELEASE_INTLOCK(NULL);

  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168208
  004fe	33 c9		 xor	 ecx, ecx
  00500	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN1@update_cpu:

; 154  : 
; 155  : } /* end function check_timer_event */

  00505	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00509	c3		 ret	 0
update_cpu_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\timer.c
_TEXT	SEGMENT
i$ = 80
max_tps_rate$ = 84
new_timerint_usecs$ = 88
starting_timerint$ = 92
intervals_per_second$ = 96
tv159 = 100
tv172 = 104
tv175 = 108
tv176 = 112
tv71 = 116
tv76 = 120
tv195 = 124
tv200 = 128
count$ = 136
__$ArrayPad$ = 160
argp$ = 192
rubato_thread PROC

; 357  : {

$LN23:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 358  :     int    starting_timerint;           /* Starting sysblk.timerint  */
; 359  :     int    new_timerint_usecs;          /* Adjusted interval usecs   */
; 360  :     int    intervals_per_second;        /* Intervals in one second   */
; 361  :     int    i;                           /* Loop index                */
; 362  :     U32    count[5] = {0,0,0,0,0};      /* Transactions executed     */

  0001e	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp], 0
  00029	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp+4], 0
  00034	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp+8], 0
  0003f	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp+12], 0
  0004a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp+16], 0

; 363  :                                         /* during past 5 intervals   */
; 364  :     U32    max_tps_rate = 0;            /* Transactions per second   */

  00055	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR max_tps_rate$[rsp], 0
$LN4@rubato_thr:

; 365  : 
; 366  :     UNREFERENCED( argp );

  0005d	33 c0		 xor	 eax, eax
  0005f	85 c0		 test	 eax, eax
  00061	75 fa		 jne	 SHORT $LN4@rubato_thr

; 367  : 
; 368  :     /* Set our thread priority to be the same as that of CPU threads */
; 369  :     set_thread_priority( sysblk.cpuprio );

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168294
  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00077	8b 91 6c 13 00
	00		 mov	 edx, DWORD PTR [rcx+4972]
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 370  : 
; 371  :     // "Thread id "TIDPAT", prio %2d, name %s started"
; 372  :     LOG_THREAD_BEGIN( RUBATO_THREAD_NAME );

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168296
  00092	8b c8		 mov	 ecx, eax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0009a	89 44 24 74	 mov	 DWORD PTR tv71[rsp], eax
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000a4	89 44 24 78	 mov	 DWORD PTR tv76[rsp], eax
  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168295
  000ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000bf	8b 4c 24 74	 mov	 ecx, DWORD PTR tv71[rsp]
  000c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c7	8b 4c 24 78	 mov	 ecx, DWORD PTR tv76[rsp]
  000cb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168297
  000d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168298
  000e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168299
  000f9	ba 74 01 00 00	 mov	 edx, 372		; 00000174H
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168300
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 373  : 
; 374  :     sysblk.txf_counter   = 0;

  0010b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00112	c7 80 70 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1392], 0

; 375  :     starting_timerint    = 0;

  0011c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR starting_timerint$[rsp], 0

; 376  :     intervals_per_second = MAX_TOD_UPDATE_USECS / sysblk.txf_timerint;

  00124	b8 40 42 0f 00	 mov	 eax, 1000000		; 000f4240H
  00129	99		 cdq
  0012a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00131	f7 b9 74 05 00
	00		 idiv	 DWORD PTR [rcx+1396]
  00137	89 44 24 60	 mov	 DWORD PTR intervals_per_second$[rsp], eax

; 377  : 
; 378  :     obtain_lock( &sysblk.rublock );

  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00142	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168301
  0014f	48 8b c8	 mov	 rcx, rax
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN5@rubato_thr:

; 379  :     {
; 380  :         while (!sysblk.shutfini && sysblk.rubtid)

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00165	c1 e8 0c	 shr	 eax, 12
  00168	83 e0 01	 and	 eax, 1
  0016b	85 c0		 test	 eax, eax
  0016d	0f 85 3a 02 00
	00		 jne	 $LN6@rubato_thr
  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017a	83 b8 64 05 00
	00 00		 cmp	 DWORD PTR [rax+1380], 0
  00181	0f 84 26 02 00
	00		 je	 $LN6@rubato_thr

; 381  :         {
; 382  :             /* Detect change to starting timerint value */
; 383  :             if (sysblk.timerint != starting_timerint)

  00187	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0018e	8b 4c 24 5c	 mov	 ecx, DWORD PTR starting_timerint$[rsp]
  00192	39 88 60 11 00
	00		 cmp	 DWORD PTR [rax+4448], ecx
  00198	74 39		 je	 SHORT $LN13@rubato_thr

; 384  :             {
; 385  :                 sysblk.txf_timerint = starting_timerint = sysblk.timerint;

  0019a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a1	8b 80 60 11 00
	00		 mov	 eax, DWORD PTR [rax+4448]
  001a7	89 44 24 5c	 mov	 DWORD PTR starting_timerint$[rsp], eax
  001ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b2	8b 4c 24 5c	 mov	 ecx, DWORD PTR starting_timerint$[rsp]
  001b6	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 386  :                 intervals_per_second = MAX_TOD_UPDATE_USECS / sysblk.txf_timerint;

  001bc	b8 40 42 0f 00	 mov	 eax, 1000000		; 000f4240H
  001c1	99		 cdq
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c9	f7 b9 74 05 00
	00		 idiv	 DWORD PTR [rcx+1396]
  001cf	89 44 24 60	 mov	 DWORD PTR intervals_per_second$[rsp], eax
$LN13@rubato_thr:

; 387  :             }
; 388  : 
; 389  :             /* Create room for a new transactions count */
; 390  :             for (i=1; i < 5; i++)

  001d3	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  001db	eb 0a		 jmp	 SHORT $LN9@rubato_thr
$LN7@rubato_thr:
  001dd	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  001e1	ff c0		 inc	 eax
  001e3	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN9@rubato_thr:
  001e7	83 7c 24 50 05	 cmp	 DWORD PTR i$[rsp], 5
  001ec	7d 1e		 jge	 SHORT $LN8@rubato_thr

; 391  :                 count[i-1] = count[i];

  001ee	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001f3	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  001f7	ff c9		 dec	 ecx
  001f9	48 63 c9	 movsxd	 rcx, ecx
  001fc	8b 84 84 88 00
	00 00		 mov	 eax, DWORD PTR count$[rsp+rax*4]
  00203	89 84 8c 88 00
	00 00		 mov	 DWORD PTR count$[rsp+rcx*4], eax
  0020a	eb d1		 jmp	 SHORT $LN7@rubato_thr
$LN8@rubato_thr:

; 392  : 
; 393  :             /* Insert new transactions count into array */
; 394  :             count[4] = sysblk.txf_counter;

  0020c	b8 04 00 00 00	 mov	 eax, 4
  00211	48 6b c0 04	 imul	 rax, rax, 4
  00215	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0021c	8b 89 70 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1392]
  00222	89 8c 04 88 00
	00 00		 mov	 DWORD PTR count$[rsp+rax], ecx

; 395  :             sysblk.txf_counter = 0;

  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00230	c7 80 70 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1392], 0

; 396  : 
; 397  :             /* Calculate a maximum transactions-per-second rate
; 398  :                based on our past transactions count history.
; 399  :             */
; 400  :             max_tps_rate = 0;

  0023a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR max_tps_rate$[rsp], 0

; 401  :             for (i=0; i < 5; i++)

  00242	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0024a	eb 0a		 jmp	 SHORT $LN12@rubato_thr
$LN10@rubato_thr:
  0024c	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00250	ff c0		 inc	 eax
  00252	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN12@rubato_thr:
  00256	83 7c 24 50 05	 cmp	 DWORD PTR i$[rsp], 5
  0025b	7d 36		 jge	 SHORT $LN11@rubato_thr

; 402  :                 max_tps_rate = MAX( max_tps_rate, count[i] );

  0025d	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00262	8b 84 84 88 00
	00 00		 mov	 eax, DWORD PTR count$[rsp+rax*4]
  00269	39 44 24 54	 cmp	 DWORD PTR max_tps_rate$[rsp], eax
  0026d	76 0a		 jbe	 SHORT $LN15@rubato_thr
  0026f	8b 44 24 54	 mov	 eax, DWORD PTR max_tps_rate$[rsp]
  00273	89 44 24 64	 mov	 DWORD PTR tv159[rsp], eax
  00277	eb 10		 jmp	 SHORT $LN16@rubato_thr
$LN15@rubato_thr:
  00279	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0027e	8b 84 84 88 00
	00 00		 mov	 eax, DWORD PTR count$[rsp+rax*4]
  00285	89 44 24 64	 mov	 DWORD PTR tv159[rsp], eax
$LN16@rubato_thr:
  00289	8b 44 24 64	 mov	 eax, DWORD PTR tv159[rsp]
  0028d	89 44 24 54	 mov	 DWORD PTR max_tps_rate$[rsp], eax
  00291	eb b9		 jmp	 SHORT $LN10@rubato_thr
$LN11@rubato_thr:

; 403  :             max_tps_rate *= intervals_per_second;

  00293	8b 44 24 54	 mov	 eax, DWORD PTR max_tps_rate$[rsp]
  00297	0f af 44 24 60	 imul	 eax, DWORD PTR intervals_per_second$[rsp]
  0029c	89 44 24 54	 mov	 DWORD PTR max_tps_rate$[rsp], eax

; 404  : 
; 405  :             /* Now adjust the timer interrupt interval correspondingly...
; 406  :                The goal is to reduce the frequency of timer interrupts
; 407  :                during periods of high transaction rates by slightly
; 408  :                increasing the interval between timer interrupts
; 409  :                (thus causing timer interrupts to occur less frequently)
; 410  :                or reducing the interval (so that they occur slightly more
; 411  :                frequently), with the minimum interval (maximum frequency)
; 412  :                being the original user specified TIMERINT value and the
; 413  :                maximum interval (minimum frequency) being one second.
; 414  :             */
; 415  : 
; 416  :             /* Calculate new timer update interval based on past 5 rates */
; 417  :             new_timerint_usecs = (int) (286000.0 * log( ((double) max_tps_rate + 200.0) / 100.0 ) - 212180.0);

  002a0	8b 44 24 54	 mov	 eax, DWORD PTR max_tps_rate$[rsp]
  002a4	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  002a9	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4069000000000000
  002b1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  002b9	e8 00 00 00 00	 call	 log
  002be	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@411174c000000000
  002c6	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  002ca	0f 28 c1	 movaps	 xmm0, xmm1
  002cd	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@4109e6a000000000
  002d5	f2 0f 2c c0	 cvttsd2si eax, xmm0
  002d9	89 44 24 58	 mov	 DWORD PTR new_timerint_usecs$[rsp], eax

; 418  : 
; 419  :             /* MINMAX(x,y,z): ensure x remains within range y to z */
; 420  :             MINMAX( new_timerint_usecs, MIN_TOD_UPDATE_USECS, MAX_TOD_UPDATE_USECS );

  002dd	83 7c 24 58 32	 cmp	 DWORD PTR new_timerint_usecs$[rsp], 50 ; 00000032H
  002e2	7e 0a		 jle	 SHORT $LN17@rubato_thr
  002e4	8b 44 24 58	 mov	 eax, DWORD PTR new_timerint_usecs$[rsp]
  002e8	89 44 24 68	 mov	 DWORD PTR tv172[rsp], eax
  002ec	eb 08		 jmp	 SHORT $LN18@rubato_thr
$LN17@rubato_thr:
  002ee	c7 44 24 68 32
	00 00 00	 mov	 DWORD PTR tv172[rsp], 50 ; 00000032H
$LN18@rubato_thr:
  002f6	81 7c 24 68 40
	42 0f 00	 cmp	 DWORD PTR tv172[rsp], 1000000 ; 000f4240H
  002fe	7d 23		 jge	 SHORT $LN21@rubato_thr
  00300	83 7c 24 58 32	 cmp	 DWORD PTR new_timerint_usecs$[rsp], 50 ; 00000032H
  00305	7e 0a		 jle	 SHORT $LN19@rubato_thr
  00307	8b 44 24 58	 mov	 eax, DWORD PTR new_timerint_usecs$[rsp]
  0030b	89 44 24 6c	 mov	 DWORD PTR tv175[rsp], eax
  0030f	eb 08		 jmp	 SHORT $LN20@rubato_thr
$LN19@rubato_thr:
  00311	c7 44 24 6c 32
	00 00 00	 mov	 DWORD PTR tv175[rsp], 50 ; 00000032H
$LN20@rubato_thr:
  00319	8b 44 24 6c	 mov	 eax, DWORD PTR tv175[rsp]
  0031d	89 44 24 70	 mov	 DWORD PTR tv176[rsp], eax
  00321	eb 08		 jmp	 SHORT $LN22@rubato_thr
$LN21@rubato_thr:
  00323	c7 44 24 70 40
	42 0f 00	 mov	 DWORD PTR tv176[rsp], 1000000 ; 000f4240H
$LN22@rubato_thr:
  0032b	8b 44 24 70	 mov	 eax, DWORD PTR tv176[rsp]
  0032f	89 44 24 58	 mov	 DWORD PTR new_timerint_usecs$[rsp], eax

; 421  : 
; 422  :             sysblk.txf_timerint = new_timerint_usecs;

  00333	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0033a	8b 4c 24 58	 mov	 ecx, DWORD PTR new_timerint_usecs$[rsp]
  0033e	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 423  :             intervals_per_second = MAX_TOD_UPDATE_USECS / sysblk.txf_timerint;

  00344	b8 40 42 0f 00	 mov	 eax, 1000000		; 000f4240H
  00349	99		 cdq
  0034a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00351	f7 b9 74 05 00
	00		 idiv	 DWORD PTR [rcx+1396]
  00357	89 44 24 60	 mov	 DWORD PTR intervals_per_second$[rsp], eax

; 424  : 
; 425  :             /* Now go back to sleep and wake up a little bit LATER than
; 426  :                before, or a little bit SOONER than before, before checking
; 427  :                again to see whether the period of high transaction rate
; 428  :                has finally subsided or not.
; 429  :             */
; 430  :             release_lock( &sysblk.rublock );

  0035b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00362	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168303
  0036f	48 8b c8	 mov	 rcx, rax
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 431  :             {
; 432  :                 usleep( sysblk.txf_timerint );

  00378	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0037f	8b 88 74 05 00
	00		 mov	 ecx, DWORD PTR [rax+1396]
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 433  :             }
; 434  :             obtain_lock( &sysblk.rublock );

  0038b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00392	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168304
  0039f	48 8b c8	 mov	 rcx, rax
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 435  :         }

  003a8	e9 ab fd ff ff	 jmp	 $LN5@rubato_thr
$LN6@rubato_thr:

; 436  : 
; 437  :         sysblk.rubtid = 0;

  003ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b4	c7 80 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1380], 0

; 438  :         sysblk.txf_timerint = sysblk.timerint;

  003be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003cc	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  003d2	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 439  :     }
; 440  :     release_lock( &sysblk.rublock );

  003d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003df	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  003e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168305
  003ec	48 8b c8	 mov	 rcx, rax
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 441  : 
; 442  :     // "Thread id "TIDPAT", prio %2d, name %s ended"
; 443  :     LOG_THREAD_END( RUBATO_THREAD_NAME );

  003f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  003fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168307
  00402	8b c8		 mov	 ecx, eax
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0040a	89 44 24 7c	 mov	 DWORD PTR tv195[rsp], eax
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00414	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv200[rsp], eax
  0041b	b9 01 00 00 00	 mov	 ecx, 1
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168306
  0042d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00432	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv195[rsp]
  00436	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0043a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  00441	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00445	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168308
  0044c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168309
  00458	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00462	41 b9 03 00 00
	00		 mov	 r9d, 3
  00468	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168310
  0046f	ba bb 01 00 00	 mov	 edx, 443		; 000001bbH
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168311
  0047b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 444  : 
; 445  :     return NULL;

  00481	33 c0		 xor	 eax, eax

; 446  : 
; 447  : } /* end function rubato_thread */

  00483	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048b	48 33 cc	 xor	 rcx, rsp
  0048e	e8 00 00 00 00	 call	 __security_check_cookie
  00493	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0049a	c3		 ret	 0
rubato_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\timer.c
_TEXT	SEGMENT
regs$ = 80
txf_PPA$ = 88
i$ = 92
intv_secs$ = 96
cpupct$1 = 104
tv209 = 108
mipsrate$ = 112
siosrate$ = 120
wait_secs$ = 128
total_sios$ = 136
now$ = 144
tv71 = 152
tv76 = 156
tv237 = 160
tv242 = 164
then$ = 168
one_sec$ = 176
half_intv$ = 184
total_mips$ = 192
saved_then$ = 200
busy_secs$2 = 208
argp$ = 240
timer_thread PROC

; 168  : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 169  : int     i;                              /* Loop index                */
; 170  : REGS   *regs;                           /* -> REGS                   */
; 171  : U64     mipsrate;                       /* Calculated MIPS rate      */
; 172  : U64     siosrate;                       /* Calculated SIO rate       */
; 173  : U64     total_mips;                     /* Total MIPS rate           */
; 174  : U64     total_sios;                     /* Total SIO rate            */
; 175  : 
; 176  : /* Clock times use the top 64-bits of the ETOD clock                 */
; 177  : U64     now;                            /* Current  TOD              */
; 178  : U64     then;                           /* Previous TOD              */
; 179  : U64     saved_then;                     /* (saved original value)    */
; 180  : U64     intv_secs;                      /* Interval                  */
; 181  : U64     half_intv;                      /* One-half interval         */
; 182  : U64     wait_secs;                      /* Wait time                 */
; 183  : const U64   one_sec  = ETOD_SEC;        /* MIPS calculation period   */

  0000c	48 c7 84 24 b0
	00 00 00 00 24
	f4 00		 mov	 QWORD PTR one_sec$[rsp], 16000000 ; 00f42400H
$LN4@timer_thre:

; 184  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 185  : bool    txf_PPA;                        /* true == PPA assist needed */
; 186  : #endif
; 187  : // (helper macro)
; 188  : #define diffrate( x, y )        ((((x) * (y)) + half_intv) / intv_secs)
; 189  : 
; 190  :     UNREFERENCED( argp );

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@timer_thre

; 191  : 
; 192  :     /* Set timer thread priority */
; 193  :     set_thread_priority( sysblk.todprio );

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168241
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00032	8b 91 68 13 00
	00		 mov	 edx, DWORD PTR [rcx+4968]
  00038	8b c8		 mov	 ecx, eax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 194  : 
; 195  :     // "Thread id "TIDPAT", prio %2d, name %s started"
; 196  :     LOG_THREAD_BEGIN( TIMER_THREAD_NAME  );

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168243
  0004d	8b c8		 mov	 ecx, eax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00055	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00062	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00069	b9 01 00 00 00	 mov	 ecx, 1
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168242
  0007b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00080	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  00087	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008b	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv76[rsp]
  00092	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168244
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168245
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168246
  000c0	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168247
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 197  : 
; 198  :     then = host_tod();

  000d2	e8 00 00 00 00	 call	 host_tod
  000d7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR then$[rsp], rax
$LN5@timer_thre:

; 199  : 
; 200  :     while (!sysblk.shutfini)

  000df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000ec	c1 e8 0c	 shr	 eax, 12
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 d1 04 00
	00		 jne	 $LN6@timer_thre

; 201  :     {
; 202  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 203  :         txf_PPA = false;                /* default until we learn otherwise */

  000fa	c6 44 24 58 00	 mov	 BYTE PTR txf_PPA$[rsp], 0

; 204  : #endif
; 205  :         /* Update TOD clock and save TOD clock value */
; 206  :         now = update_tod_clock();

  000ff	e8 00 00 00 00	 call	 update_tod_clock
  00104	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR now$[rsp], rax

; 207  : 
; 208  :         intv_secs = now - then;

  0010c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR then$[rsp]
  00114	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR now$[rsp]
  0011c	48 2b c8	 sub	 rcx, rax
  0011f	48 8b c1	 mov	 rax, rcx
  00122	48 89 44 24 60	 mov	 QWORD PTR intv_secs$[rsp], rax

; 209  : 
; 210  :         if (intv_secs >= one_sec)             /* Period expired? */

  00127	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR one_sec$[rsp]
  0012f	48 39 44 24 60	 cmp	 QWORD PTR intv_secs$[rsp], rax
  00134	0f 82 5b 04 00
	00		 jb	 $LN10@timer_thre

; 211  :         {
; 212  :             half_intv = intv_secs / 2;        /* One-half interval for rounding */

  0013a	33 d2		 xor	 edx, edx
  0013c	48 8b 44 24 60	 mov	 rax, QWORD PTR intv_secs$[rsp]
  00141	b9 02 00 00 00	 mov	 ecx, 2
  00146	48 f7 f1	 div	 rcx
  00149	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR half_intv$[rsp], rax

; 213  :             saved_then = then;                /* Save value before updating */

  00151	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR then$[rsp]
  00159	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR saved_then$[rsp], rax

; 214  :             then = now;

  00161	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR now$[rsp]
  00169	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR then$[rsp], rax

; 215  :             total_mips = total_sios = 0;

  00171	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR total_sios$[rsp], 0
  0017d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR total_sios$[rsp]
  00185	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR total_mips$[rsp], rax

; 216  : 
; 217  : #if defined( OPTION_SHARED_DEVICES )
; 218  :             total_sios = sysblk.shrdcount;

  0018d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00194	8b 80 b0 13 00
	00		 mov	 eax, DWORD PTR [rax+5040]
  0019a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR total_sios$[rsp], rax

; 219  :             sysblk.shrdcount = 0;

  001a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a9	c7 80 b0 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5040], 0

; 220  : #endif
; 221  :             for (i=0; i < sysblk.hicpu; i++)

  001b3	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001bb	eb 0a		 jmp	 SHORT $LN9@timer_thre
$LN7@timer_thre:
  001bd	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  001c1	ff c0		 inc	 eax
  001c3	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN9@timer_thre:
  001c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ce	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  001d4	39 44 24 5c	 cmp	 DWORD PTR i$[rsp], eax
  001d8	0f 8d 8a 03 00
	00		 jge	 $LN8@timer_thre

; 222  :             {
; 223  :                 obtain_lock( &sysblk.cpulock[ i ]);

  001de	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  001e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ea	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168249
  001f9	48 8b c8	 mov	 rcx, rax
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 224  :                 {
; 225  :                     if (!IS_CPU_ONLINE( i ))

  00202	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00207	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020e	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00217	75 29		 jne	 SHORT $LN11@timer_thre

; 226  :                     {
; 227  :                         release_lock( &sysblk.cpulock[ i ]);

  00219	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  0021e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00225	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168251
  00234	48 8b c8	 mov	 rcx, rax
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 228  :                         continue;

  0023d	e9 7b ff ff ff	 jmp	 $LN7@timer_thre
$LN11@timer_thre:

; 229  :                     }
; 230  : 
; 231  :                     regs = sysblk.regs[i];

  00242	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00247	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00256	48 89 44 24 50	 mov	 QWORD PTR regs$[rsp], rax

; 232  : 
; 233  :                     /* 0% if CPU is STOPPED */
; 234  :                     if (regs->cpustate == CPUSTATE_STOPPED)

  0025b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00260	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00264	83 f8 03	 cmp	 eax, 3
  00267	75 56		 jne	 SHORT $LN12@timer_thre

; 235  :                     {
; 236  :                         regs->mipsrate = regs->siosrate = regs->cpupct = 0;

  00269	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	c7 80 b0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1968], 0
  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	c7 80 a4 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1956], 0
  00287	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0028c	c7 80 9c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1948], 0

; 237  :                         release_lock( &sysblk.cpulock[ i ]);

  00296	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  0029b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002a2	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168253
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 238  :                         continue;

  002ba	e9 fe fe ff ff	 jmp	 $LN7@timer_thre
$LN12@timer_thre:

; 239  :                     }
; 240  : 
; 241  :                     /* Calculate instructions per second */
; 242  :                     mipsrate = regs->instcount;

  002bf	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  002ca	48 89 44 24 70	 mov	 QWORD PTR mipsrate$[rsp], rax

; 243  :                     regs->instcount   =  0;

  002cf	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002d4	c7 80 98 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1944], 0

; 244  :                     regs->prevcount += mipsrate;

  002de	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	48 8b 80 90 07
	00 00		 mov	 rax, QWORD PTR [rax+1936]
  002ea	48 03 44 24 70	 add	 rax, QWORD PTR mipsrate$[rsp]
  002ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002f4	48 89 81 90 07
	00 00		 mov	 QWORD PTR [rcx+1936], rax

; 245  :                     mipsrate = diffrate(mipsrate, one_sec);

  002fb	48 8b 44 24 70	 mov	 rax, QWORD PTR mipsrate$[rsp]
  00300	48 0f af 84 24
	b0 00 00 00	 imul	 rax, QWORD PTR one_sec$[rsp]
  00309	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR half_intv$[rsp]
  00311	33 d2		 xor	 edx, edx
  00313	48 f7 74 24 60	 div	 QWORD PTR intv_secs$[rsp]
  00318	48 89 44 24 70	 mov	 QWORD PTR mipsrate$[rsp], rax

; 246  :                     regs->mipsrate = mipsrate;

  0031d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 4c 24 70	 mov	 ecx, DWORD PTR mipsrate$[rsp]
  00326	89 88 9c 07 00
	00		 mov	 DWORD PTR [rax+1948], ecx

; 247  :                     total_mips += mipsrate;

  0032c	48 8b 44 24 70	 mov	 rax, QWORD PTR mipsrate$[rsp]
  00331	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR total_mips$[rsp]
  00339	48 03 c8	 add	 rcx, rax
  0033c	48 8b c1	 mov	 rax, rcx
  0033f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR total_mips$[rsp], rax

; 248  : 
; 249  :                     /* Calculate SIOs per second */
; 250  :                     siosrate = regs->siocount;

  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0034c	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  00352	48 89 44 24 78	 mov	 QWORD PTR siosrate$[rsp], rax

; 251  :                     regs->siocount = 0;

  00357	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0035c	c7 80 a0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1952], 0

; 252  :                     regs->siototal += siosrate;

  00366	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0036b	48 8b 80 a8 07
	00 00		 mov	 rax, QWORD PTR [rax+1960]
  00372	48 03 44 24 78	 add	 rax, QWORD PTR siosrate$[rsp]
  00377	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	48 89 81 a8 07
	00 00		 mov	 QWORD PTR [rcx+1960], rax

; 253  :                     siosrate = diffrate(siosrate, one_sec);

  00383	48 8b 44 24 78	 mov	 rax, QWORD PTR siosrate$[rsp]
  00388	48 0f af 84 24
	b0 00 00 00	 imul	 rax, QWORD PTR one_sec$[rsp]
  00391	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR half_intv$[rsp]
  00399	33 d2		 xor	 edx, edx
  0039b	48 f7 74 24 60	 div	 QWORD PTR intv_secs$[rsp]
  003a0	48 89 44 24 78	 mov	 QWORD PTR siosrate$[rsp], rax

; 254  :                     regs->siosrate = siosrate;

  003a5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003aa	8b 4c 24 78	 mov	 ecx, DWORD PTR siosrate$[rsp]
  003ae	89 88 a4 07 00
	00		 mov	 DWORD PTR [rax+1956], ecx

; 255  :                     total_sios += siosrate;

  003b4	48 8b 44 24 78	 mov	 rax, QWORD PTR siosrate$[rsp]
  003b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR total_sios$[rsp]
  003c1	48 03 c8	 add	 rcx, rax
  003c4	48 8b c1	 mov	 rax, rcx
  003c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR total_sios$[rsp], rax

; 256  : 
; 257  :                     /* Calculate CPU busy percentage */
; 258  :                     wait_secs = regs->waittime;

  003cf	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	48 8b 80 c0 07
	00 00		 mov	 rax, QWORD PTR [rax+1984]
  003db	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR wait_secs$[rsp], rax

; 259  :                     regs->waittime_accumulated += wait_secs;

  003e3	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003e8	48 8b 80 c8 07
	00 00		 mov	 rax, QWORD PTR [rax+1992]
  003ef	48 03 84 24 80
	00 00 00	 add	 rax, QWORD PTR wait_secs$[rsp]
  003f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003fc	48 89 81 c8 07
	00 00		 mov	 QWORD PTR [rcx+1992], rax

; 260  :                     regs->waittime = 0;

  00403	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00408	48 c7 80 c0 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1984], 0

; 261  : 
; 262  :                     /* Are we currently waiting? */
; 263  :                     if (regs->waittod >= saved_then)

  00413	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00418	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR saved_then$[rsp]
  00420	48 39 88 b8 07
	00 00		 cmp	 QWORD PTR [rax+1976], rcx
  00427	72 44		 jb	 SHORT $LN13@timer_thre

; 264  :                     {
; 265  :                         /* Add time spent waiting during this interval too */
; 266  :                         wait_secs += (now - regs->waittod);

  00429	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0042e	48 8b 80 b8 07
	00 00		 mov	 rax, QWORD PTR [rax+1976]
  00435	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR now$[rsp]
  0043d	48 2b c8	 sub	 rcx, rax
  00440	48 8b c1	 mov	 rax, rcx
  00443	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR wait_secs$[rsp]
  0044b	48 03 c8	 add	 rcx, rax
  0044e	48 8b c1	 mov	 rax, rcx
  00451	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR wait_secs$[rsp], rax

; 267  :                         regs->waittod = now;

  00459	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0045e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR now$[rsp]
  00466	48 89 88 b8 07
	00 00		 mov	 QWORD PTR [rax+1976], rcx
$LN13@timer_thre:

; 268  :                     }
; 269  : 
; 270  :                     /* Were we idle the entire interval? */
; 271  :                     if (wait_secs >= intv_secs)

  0046d	48 8b 44 24 60	 mov	 rax, QWORD PTR intv_secs$[rsp]
  00472	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR wait_secs$[rsp], rax
  0047a	72 11		 jb	 SHORT $LN14@timer_thre

; 272  :                         regs->cpupct = 0;   /* Yes, 100% idle = 0% CPU */

  0047c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00481	c7 80 b0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1968], 0
  0048b	eb 5f		 jmp	 SHORT $LN15@timer_thre
$LN14@timer_thre:

; 273  :                     else
; 274  :                     {
; 275  :                         /* No, we were busy at least part of the time */
; 276  : 
; 277  :                         U64  busy_secs  =  intv_secs - wait_secs;

  0048d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR wait_secs$[rsp]
  00495	48 8b 4c 24 60	 mov	 rcx, QWORD PTR intv_secs$[rsp]
  0049a	48 2b c8	 sub	 rcx, rax
  0049d	48 8b c1	 mov	 rax, rcx
  004a0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR busy_secs$2[rsp], rax

; 278  :                         int  cpupct     =  (int)(diffrate( busy_secs, 100 ));

  004a8	48 6b 84 24 d0
	00 00 00 64	 imul	 rax, QWORD PTR busy_secs$2[rsp], 100 ; 00000064H
  004b1	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR half_intv$[rsp]
  004b9	33 d2		 xor	 edx, edx
  004bb	48 f7 74 24 60	 div	 QWORD PTR intv_secs$[rsp]
  004c0	89 44 24 68	 mov	 DWORD PTR cpupct$1[rsp], eax

; 279  :                         regs->cpupct    =  min( cpupct, 100 );

  004c4	83 7c 24 68 64	 cmp	 DWORD PTR cpupct$1[rsp], 100 ; 00000064H
  004c9	7d 0a		 jge	 SHORT $LN22@timer_thre
  004cb	8b 44 24 68	 mov	 eax, DWORD PTR cpupct$1[rsp]
  004cf	89 44 24 6c	 mov	 DWORD PTR tv209[rsp], eax
  004d3	eb 08		 jmp	 SHORT $LN23@timer_thre
$LN22@timer_thre:
  004d5	c7 44 24 6c 64
	00 00 00	 mov	 DWORD PTR tv209[rsp], 100 ; 00000064H
$LN23@timer_thre:
  004dd	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  004e2	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv209[rsp]
  004e6	89 88 b0 07 00
	00		 mov	 DWORD PTR [rax+1968], ecx
$LN15@timer_thre:

; 280  :                     }
; 281  : 
; 282  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 283  :                     /*
; 284  :                                      PROGRAMMING NOTE
; 285  : 
; 286  :                        We are purposely NOT taking the current "txf_tnd"
; 287  :                        value into consideration here in our decision
; 288  :                        whether the "sysblk.txf_timerint" value should be
; 289  :                        used or not (as indicated by our "txf_PPA" flag)
; 290  :                        because the fact that "regs->txf_PPA" is greater
; 291  :                        than our "some help" threshold indicates that a
; 292  :                        transaction DID recently fail and thus will very
; 293  :                        likely be retried very soon!
; 294  : 
; 295  :                        Thus we DON'T want to negate our whole purpose
; 296  :                        of trying to MINIMIZE timer interrupts whenever
; 297  :                        there are transactions failing and being retried!
; 298  : 
; 299  :                        (Which is what WOULD happen if we caused "txf_PPA"
; 300  :                        flag to NOT get set simply because "regs->txf_tnd"
; 301  :                        happened to be false during the very brief period
; 302  :                        between when the transaction failed but before it
; 303  :                        has had a chance to be retried.)
; 304  :                     */
; 305  :                     if (0
; 306  :                         || (HOSTREGS  && HOSTREGS ->txf_PPA >= PPA_SOME_HELP_THRESHOLD)
; 307  :                         || (GUESTREGS && GUESTREGS->txf_PPA >= PPA_SOME_HELP_THRESHOLD)

  004ec	33 c0		 xor	 eax, eax
  004ee	85 c0		 test	 eax, eax
  004f0	75 48		 jne	 SHORT $LN17@timer_thre
  004f2	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  004f7	48 83 b8 68 08
	00 00 00	 cmp	 QWORD PTR [rax+2152], 0
  004ff	74 15		 je	 SHORT $LN18@timer_thre
  00501	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00506	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0050d	83 b8 54 0e 00
	00 01		 cmp	 DWORD PTR [rax+3668], 1
  00514	7d 24		 jge	 SHORT $LN17@timer_thre
$LN18@timer_thre:
  00516	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0051b	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00523	74 1a		 je	 SHORT $LN16@timer_thre
  00525	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0052a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00531	83 b8 54 0e 00
	00 01		 cmp	 DWORD PTR [rax+3668], 1
  00538	7c 05		 jl	 SHORT $LN16@timer_thre
$LN17@timer_thre:

; 308  :                     )
; 309  :                         txf_PPA = true; // (use rubato thread timerint)

  0053a	c6 44 24 58 01	 mov	 BYTE PTR txf_PPA$[rsp], 1
$LN16@timer_thre:

; 310  : #endif
; 311  :                 }
; 312  :                 release_lock( &sysblk.cpulock[ i ]);

  0053f	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00544	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0054b	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00553	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168260
  0055a	48 8b c8	 mov	 rcx, rax
  0055d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 313  : 
; 314  :             } /* end for(cpu) */

  00563	e9 55 fc ff ff	 jmp	 $LN7@timer_thre
$LN8@timer_thre:

; 315  : 
; 316  :             /* Total for ALL CPUs together */
; 317  :             sysblk.mipsrate = total_mips;

  00568	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0056f	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR total_mips$[rsp]
  00576	89 88 88 14 00
	00		 mov	 DWORD PTR [rax+5256], ecx

; 318  :             sysblk.siosrate = total_sios;

  0057c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00583	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR total_sios$[rsp]
  0058a	89 88 8c 14 00
	00		 mov	 DWORD PTR [rax+5260], ecx

; 319  : 
; 320  :             update_maxrates_hwm(); // (update high-water-mark values)

  00590	e8 00 00 00 00	 call	 update_maxrates_hwm
$LN10@timer_thre:

; 321  : 
; 322  :         } /* end if (intv_secs >= one_sec) */
; 323  : 
; 324  :         /* Sleep for another timer update interval... */
; 325  : 
; 326  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 327  :         /* Do we need to temporarily reduce the frequency of timer
; 328  :            interrupts? (By waiting slightly longer than normal?)
; 329  :         */
; 330  :         if (txf_PPA)

  00595	0f b6 44 24 58	 movzx	 eax, BYTE PTR txf_PPA$[rsp]
  0059a	85 c0		 test	 eax, eax
  0059c	74 15		 je	 SHORT $LN19@timer_thre

; 331  :             usleep( sysblk.txf_timerint );

  0059e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005a5	8b 88 74 05 00
	00		 mov	 ecx, DWORD PTR [rax+1396]
  005ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
  005b1	eb 13		 jmp	 SHORT $LN20@timer_thre
$LN19@timer_thre:

; 332  :         else
; 333  : #endif
; 334  :             usleep ( sysblk.timerint );

  005b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ba	8b 88 60 11 00
	00		 mov	 ecx, DWORD PTR [rax+4448]
  005c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN20@timer_thre:

; 335  : 
; 336  :     } /* end while */

  005c6	e9 14 fb ff ff	 jmp	 $LN5@timer_thre
$LN6@timer_thre:

; 337  : 
; 338  :     sysblk.todtid = 0;

  005cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d2	c7 80 90 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2960], 0

; 339  : 
; 340  :     // "Thread id "TIDPAT", prio %2d, name %s ended"
; 341  :     LOG_THREAD_END( TIMER_THREAD_NAME  );

  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  005e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168264
  005e9	8b c8		 mov	 ecx, eax
  005eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  005f1	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  005fe	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv242[rsp], eax
  00605	b9 01 00 00 00	 mov	 ecx, 1
  0060a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168263
  00617	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0061c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  00623	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00627	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv242[rsp]
  0062e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168265
  00639	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0063e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168266
  00645	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0064a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0064f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00655	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168267
  0065c	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  00661	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168268
  00668	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 342  : 
; 343  :     return NULL;

  0066e	33 c0		 xor	 eax, eax

; 344  : 
; 345  : } /* end function timer_thread */

  00670	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00677	c3		 ret	 0
timer_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  00020	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00037	33 d2		 xor	 edx, edx
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003e	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00043	48 f7 f1	 div	 rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  00050	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00055	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005e	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00078	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a8	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
END
