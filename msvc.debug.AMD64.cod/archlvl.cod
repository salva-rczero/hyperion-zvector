; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG188863 DB	'z/Arch', 00H
	ORG $+1
$SG188864 DB	'ESA/390', 00H
$SG188865 DB	'S/370', 00H
	ORG $+2
$SG188866 DB	'S370', 00H
	ORG $+3
$SG188867 DB	'370', 00H
$SG188868 DB	'ESA390', 00H
	ORG $+1
$SG188869 DB	'E390', 00H
	ORG $+3
$SG188870 DB	'E/390', 00H
	ORG $+2
$SG188871 DB	'ESA', 00H
$SG188872 DB	'S/390', 00H
	ORG $+2
$SG188873 DB	'OS/390', 00H
	ORG $+1
$SG188874 DB	'S390', 00H
	ORG $+3
$SG188875 DB	'OS390', 00H
	ORG $+2
$SG188876 DB	'390', 00H
$SG188877 DB	'zArch', 00H
	ORG $+2
$SG188878 DB	'z', 00H
	ORG $+2
$SG188879 DB	'900', 00H
$SG188880 DB	'Z900', 00H
	ORG $+3
$SG188881 DB	'z/900', 00H
	ORG $+2
$SG188882 DB	'ESAME', 00H
	ORG $+2
$SG188883 DB	'ESA/ME', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?clear@?9??archlvl_cmd@@9@9 DB 00H			; `archlvl_cmd'::`10'::clear
?ipl@?9??archlvl_cmd@@9@9 DB 00H			; `archlvl_cmd'::`10'::ipl
CONST	ENDS
PUBLIC	init_default_archmode
PUBLIC	get_arch_name
PUBLIC	get_arch_name_by_arch
PUBLIC	get_archtab_by_arch
PUBLIC	get_archtab_by_name
PUBLIC	archlvl_cmd
EXTRN	__imp__stricmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_fmt_memsize_KB:PROC
EXTRN	system_reset:PROC
EXTRN	initial_cpu_reset_all:PROC
EXTRN	configure_storage:PROC
EXTRN	adjust_mainsize:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$strupper DD imagerel strupper
	DD	imagerel strupper+114
	DD	imagerel $unwind$strupper
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$are_all_cpus_stopped_intlock_held DD imagerel are_all_cpus_stopped_intlock_held
	DD	imagerel are_all_cpus_stopped_intlock_held+118
	DD	imagerel $unwind$are_all_cpus_stopped_intlock_held
$pdata$are_all_cpus_stopped DD imagerel are_all_cpus_stopped
	DD	imagerel are_all_cpus_stopped+51
	DD	imagerel $unwind$are_all_cpus_stopped
$pdata$get_arch_name DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$get_arch_name
$pdata$get_arch_name_by_arch DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$get_arch_name_by_arch
$pdata$get_archtab_by_arch DD imagerel $LN7
	DD	imagerel $LN7+87
	DD	imagerel $unwind$get_archtab_by_arch
$pdata$get_archtab_by_name DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$get_archtab_by_name
$pdata$get_archmode_by_name DD imagerel get_archmode_by_name
	DD	imagerel get_archmode_by_name+63
	DD	imagerel $unwind$get_archmode_by_name
$pdata$archlvl_cmd DD imagerel $LN29
	DD	imagerel $LN29+1519
	DD	imagerel $unwind$archlvl_cmd
pdata	ENDS
_DATA	SEGMENT
	ORG $+5
$SG158973 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:549', 00H
	ORG $+2
$SG158974 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:553', 00H
	ORG $+2
$SG188946 DB	'ARCHLVL', 00H
archtab	DQ	FLAT:$SG188863
	DD	02H
	DD	020H
	DQ	FLAT:$SG188864
	DD	01H
	DD	040H
	DQ	FLAT:$SG188865
	DD	00H
	DD	080H
	DQ	FLAT:$SG188866
	DD	00H
	DD	080H
	DQ	FLAT:$SG188867
	DD	00H
	DD	080H
	DQ	FLAT:$SG188868
	DD	01H
	DD	040H
	DQ	FLAT:$SG188869
	DD	01H
	DD	040H
	DQ	FLAT:$SG188870
	DD	01H
	DD	040H
	DQ	FLAT:$SG188871
	DD	01H
	DD	040H
	DQ	FLAT:$SG188872
	DD	01H
	DD	040H
	DQ	FLAT:$SG188873
	DD	01H
	DD	040H
	DQ	FLAT:$SG188874
	DD	01H
	DD	040H
	DQ	FLAT:$SG188875
	DD	01H
	DD	040H
	DQ	FLAT:$SG188876
	DD	01H
	DD	040H
	DQ	FLAT:$SG188877
	DD	02H
	DD	020H
	DQ	FLAT:$SG188878
	DD	02H
	DD	020H
	DQ	FLAT:$SG188879
	DD	02H
	DD	020H
	DQ	FLAT:$SG188880
	DD	02H
	DD	020H
	DQ	FLAT:$SG188881
	DD	02H
	DD	020H
	DQ	FLAT:$SG188882
	DD	02H
	DD	020H
	DQ	FLAT:$SG188883
	DD	02H
	DD	020H
$SG188947 DB	'I', 00H
	ORG $+2
$SG188952 DB	'E', 00H
	ORG $+2
$SG188948 DB	'HHC02203%s %-14s: %s', 0aH, 00H
	ORG $+2
$SG188949 DB	'archlvl_cmd', 00H
$SG188958 DB	'E', 00H
	ORG $+2
$SG188950 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+7
$SG188953 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG188963 DB	'E', 00H
	ORG $+2
$SG188954 DB	'archlvl_cmd', 00H
$SG188973 DB	'I', 00H
	ORG $+2
$SG188955 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+3
$SG188978 DB	'min', 00H
$SG188957 DB	'to switch architectures', 00H
$SG188959 DB	'HHC02253%s All CPU''s must be stopped %s', 0aH, 00H
	ORG $+3
$SG188979 DB	'max', 00H
$SG188960 DB	'archlvl_cmd', 00H
$SG188980 DB	'in', 00H
	ORG $+1
$SG188961 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+3
$SG188981 DB	'de', 00H
	ORG $+1
$SG188964 DB	'HHC00895%s ARCHLVL ''%s'' is invalid', 0aH, 00H
$SG188982 DB	'W', 00H
	ORG $+2
$SG188965 DB	'archlvl_cmd', 00H
	ORG $+4
$SG188966 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+7
$SG188969 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c:248', 00H
	ORG $+3
$SG188970 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c:257', 00H
	ORG $+3
$SG188972 DB	'ARCHLVL', 00H
$SG188974 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
	ORG $+4
$SG188975 DB	'archlvl_cmd', 00H
	ORG $+4
$SG188976 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+7
$SG188983 DB	'HHC17006%s MAINSIZE %screased to %s architectural %simum'
	DB	0aH, 00H
	ORG $+6
$SG188984 DB	'archlvl_cmd', 00H
	ORG $+4
$SG188985 DB	'C:\papa\MyGit\hyperion-zvector\archlvl.c', 00H
	ORG $+7
$SG188988 DB	'-LPARNUM BASIC', 00H
	ORG $+1
$SG188990 DB	'-LPARNUM 1', 00H
	ORG $+5
$SG188991 DB	'-CPUIDFMT 0', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:archlvl_cmd
	DD	01fH
	DD	05d7H
voltbl	ENDS
xdata	SEGMENT
$unwind$strupper DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$are_all_cpus_stopped_intlock_held DD 010401H
	DD	02204H
$unwind$are_all_cpus_stopped DD 010401H
	DD	06204H
$unwind$get_arch_name DD 010901H
	DD	06209H
$unwind$get_arch_name_by_arch DD 010801H
	DD	06208H
$unwind$get_archtab_by_arch DD 010801H
	DD	02208H
$unwind$get_archtab_by_name DD 010901H
	DD	06209H
$unwind$get_archmode_by_name DD 010901H
	DD	06209H
$unwind$archlvl_cmd DD 022719H
	DD	0210115H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
increased$1 = 80
new_arch_mode$ = 84
tv208 = 88
tv210 = 92
new_mainsize$ = 96
old_arch_mode$ = 104
old_mainsize$ = 112
tv219 = 120
tv256 = 128
tv81 = 136
tv95 = 144
tv157 = 152
tv192 = 160
memsize$2 = 176
__$ArrayPad$ = 240
argc$ = 272
argv$ = 280
cmdline$ = 288
archlvl_cmd PROC

; 191  : {

$LN29:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 192  :     U64   old_mainsize  = sysblk.mainsize;

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00035	48 89 44 24 70	 mov	 QWORD PTR old_mainsize$[rsp], rax

; 193  :     U64   new_mainsize  = sysblk.mainsize;

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00041	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00048	48 89 44 24 60	 mov	 QWORD PTR new_mainsize$[rsp], rax

; 194  :     int   old_arch_mode = sysblk.arch_mode;

  0004d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00054	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0005a	89 44 24 68	 mov	 DWORD PTR old_arch_mode$[rsp], eax

; 195  :     int   new_arch_mode = sysblk.arch_mode;

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00065	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0006b	89 44 24 54	 mov	 DWORD PTR new_arch_mode$[rsp], eax
$LN4@archlvl_cm:

; 196  : 
; 197  :     UNREFERENCED( cmdline );

  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 fa		 jne	 SHORT $LN4@archlvl_cm
$LN7@archlvl_cm:

; 198  : 
; 199  :     UPPER_ARGV_0( argv );

  00075	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  0007e	74 47		 je	 SHORT $LN8@archlvl_cm
  00080	b8 08 00 00 00	 mov	 eax, 8
  00085	48 6b c0 00	 imul	 rax, rax, 0
  00089	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00091	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00096	74 2f		 je	 SHORT $LN8@archlvl_cm
  00098	b8 08 00 00 00	 mov	 eax, 8
  0009d	48 6b c0 00	 imul	 rax, rax, 0
  000a1	b9 08 00 00 00	 mov	 ecx, 8
  000a6	48 6b c9 00	 imul	 rcx, rcx, 0
  000aa	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000b2	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  000b6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000be	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  000c2	e8 00 00 00 00	 call	 strupper
$LN8@archlvl_cm:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 a8		 jne	 SHORT $LN7@archlvl_cm

; 200  : 
; 201  :     /*-----------------------------------------------------*/
; 202  :     /*             Display Architecture Mode?              */
; 203  :     /*-----------------------------------------------------*/
; 204  : 
; 205  :     if (argc < 2)

  000cd	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000d5	7d 76		 jge	 SHORT $LN9@archlvl_cm

; 206  :     {
; 207  :         // "%-14s: %s"
; 208  :         WRMSG( HHC02203, "I", "ARCHLVL", get_arch_name( NULL ));

  000d7	33 c9		 xor	 ecx, ecx
  000d9	e8 00 00 00 00	 call	 get_arch_name
  000de	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv81[rsp], rax
  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv81[rsp]
  000f9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188946
  00105	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188947
  00111	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188948
  0011d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188949
  00134	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188950
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 209  :         return 0;

  00146	33 c0		 xor	 eax, eax
  00148	e9 8a 04 00 00	 jmp	 $LN1@archlvl_cm
$LN9@archlvl_cm:

; 210  :     }
; 211  : 
; 212  :     /* Too many arguments? */
; 213  :     if (argc > 2)

  0014d	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00155	7e 7b		 jle	 SHORT $LN10@archlvl_cm

; 214  :     {
; 215  :         // "Invalid command usage. Type 'help %s' for assistance."
; 216  :         WRMSG( HHC02299, "E", argv[0] );

  00157	b8 08 00 00 00	 mov	 eax, 8
  0015c	48 6b c0 00	 imul	 rax, rax, 0
  00160	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00173	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0017b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv95[rsp]
  00183	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00187	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188952
  00193	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188953
  0019f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188954
  001b6	ba d8 00 00 00	 mov	 edx, 216		; 000000d8H
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188955
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 217  :         return -1;

  001c8	b8 ff ff ff ff	 mov	 eax, -1
  001cd	e9 05 04 00 00	 jmp	 $LN1@archlvl_cm
$LN10@archlvl_cm:

; 218  :     }
; 219  : 
; 220  :     /*-----------------------------------------------------*/
; 221  :     /*                Set Architecture                     */
; 222  :     /*-----------------------------------------------------*/
; 223  : 
; 224  :     /* Make sure all CPUs are deconfigured or stopped */
; 225  :     if (!are_all_cpus_stopped())

  001d2	e8 00 00 00 00	 call	 are_all_cpus_stopped
  001d7	0f b6 c0	 movzx	 eax, al
  001da	85 c0		 test	 eax, eax
  001dc	75 5d		 jne	 SHORT $LN11@archlvl_cm

; 226  :     {
; 227  :         // "All CPU's must be stopped %s"
; 228  :         WRMSG( HHC02253, "E", "to switch architectures" );

  001de	b9 01 00 00 00	 mov	 ecx, 1
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188957
  001f0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188958
  001fc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188959
  00208	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00212	41 b9 03 00 00
	00		 mov	 r9d, 3
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188960
  0021f	ba e4 00 00 00	 mov	 edx, 228		; 000000e4H
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188961
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 229  :         return HERRCPUONL;

  00231	b8 fd ff ff ff	 mov	 eax, -3
  00236	e9 9c 03 00 00	 jmp	 $LN1@archlvl_cm
$LN11@archlvl_cm:

; 230  :     }
; 231  : 
; 232  :     /* Determine new architecture mode */
; 233  :     if ((new_arch_mode = get_archmode_by_name( argv[1] )) < 0)

  0023b	b8 08 00 00 00	 mov	 eax, 8
  00240	48 6b c0 01	 imul	 rax, rax, 1
  00244	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0024c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00250	e8 00 00 00 00	 call	 get_archmode_by_name
  00255	89 44 24 54	 mov	 DWORD PTR new_arch_mode$[rsp], eax
  00259	83 7c 24 54 00	 cmp	 DWORD PTR new_arch_mode$[rsp], 0
  0025e	7d 7b		 jge	 SHORT $LN12@archlvl_cm

; 234  :     {
; 235  :         // "ARCHLVL '%s' is invalid"
; 236  :         WRMSG( HHC00895, "E", argv[1] );

  00260	b8 08 00 00 00	 mov	 eax, 8
  00265	48 6b c0 01	 imul	 rax, rax, 1
  00269	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  00271	b9 01 00 00 00	 mov	 ecx, 1
  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00284	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv157[rsp]
  0028c	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00290	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188963
  0029c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188964
  002a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188965
  002bf	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188966
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 237  :         return -1;

  002d1	b8 ff ff ff ff	 mov	 eax, -1
  002d6	e9 fc 02 00 00	 jmp	 $LN1@archlvl_cm
$LN12@archlvl_cm:

; 238  :     }
; 239  : 
; 240  :     /* Nothing for us to do unless the architecture changed */
; 241  :     if (new_arch_mode != old_arch_mode )

  002db	8b 44 24 68	 mov	 eax, DWORD PTR old_arch_mode$[rsp]
  002df	39 44 24 54	 cmp	 DWORD PTR new_arch_mode$[rsp], eax
  002e3	0f 84 95 00 00
	00		 je	 $LN13@archlvl_cm

; 242  :     {
; 243  :         /* Re-configure storage if MAINSIZE needs to be adjusted */
; 244  :         if ((new_mainsize = adjust_mainsize( new_arch_mode, sysblk.mainsize )) != old_mainsize)

  002e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f0	48 8b 90 90 00
	00 00		 mov	 rdx, QWORD PTR [rax+144]
  002f7	8b 4c 24 54	 mov	 ecx, DWORD PTR new_arch_mode$[rsp]
  002fb	e8 00 00 00 00	 call	 adjust_mainsize
  00300	48 89 44 24 60	 mov	 QWORD PTR new_mainsize$[rsp], rax
  00305	48 8b 44 24 70	 mov	 rax, QWORD PTR old_mainsize$[rsp]
  0030a	48 39 44 24 60	 cmp	 QWORD PTR new_mainsize$[rsp], rax
  0030f	74 11		 je	 SHORT $LN14@archlvl_cm

; 245  :             configure_storage( new_mainsize >> SHIFT_4K );

  00311	48 8b 44 24 60	 mov	 rax, QWORD PTR new_mainsize$[rsp]
  00316	48 c1 e8 0c	 shr	 rax, 12
  0031a	48 8b c8	 mov	 rcx, rax
  0031d	e8 00 00 00 00	 call	 configure_storage
$LN14@archlvl_cm:

; 246  : 
; 247  :         /* Switch to the new architecture mode as requested */
; 248  :         OBTAIN_INTLOCK( NULL );

  00322	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188969
  00329	33 c9		 xor	 ecx, ecx
  0032b	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 249  :         {
; 250  :             /* Perform system reset to switch architecture mode */
; 251  :             static const bool clear = false, ipl = false;
; 252  :             system_reset( new_arch_mode, clear, ipl, sysblk.pcpu );

  00330	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00337	44 8b 88 54 13
	00 00		 mov	 r9d, DWORD PTR [rax+4948]
  0033e	44 0f b6 05 00
	00 00 00	 movzx	 r8d, BYTE PTR ?ipl@?9??archlvl_cmd@@9@9
  00346	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?clear@?9??archlvl_cmd@@9@9
  0034d	8b 4c 24 54	 mov	 ecx, DWORD PTR new_arch_mode$[rsp]
  00351	e8 00 00 00 00	 call	 system_reset

; 253  : 
; 254  :             /* (ensure dummyregs matches new architecture) */
; 255  :             sysblk.dummyregs.arch_mode = sysblk.arch_mode;

  00356	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00364	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0036a	89 88 64 15 00
	00		 mov	 DWORD PTR [rax+5476], ecx

; 256  :         }
; 257  :         RELEASE_INTLOCK( NULL );

  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188970
  00377	33 c9		 xor	 ecx, ecx
  00379	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN13@archlvl_cm:

; 258  :     }
; 259  : 
; 260  :     /* ALWAYS do an "initial_cpu_reset()" for all processors */
; 261  :     initial_cpu_reset_all();

  0037e	e8 00 00 00 00	 call	 initial_cpu_reset_all

; 262  : 
; 263  :     /* Display results */
; 264  :     if (argc > 1 && MLVL( VERBOSE ))

  00383	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0038b	0f 8e c4 01 00
	00		 jle	 $LN15@archlvl_cm
  00391	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00398	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0039e	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 aa 01 00
	00		 je	 $LN15@archlvl_cm

; 265  :     {
; 266  :         // "%-14s set to %s"
; 267  :         WRMSG( HHC02204, "I", "ARCHLVL", get_arch_name_by_arch( sysblk.arch_mode ));

  003ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b2	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  003b8	e8 00 00 00 00	 call	 get_arch_name_by_arch
  003bd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
  003c5	b9 01 00 00 00	 mov	 ecx, 1
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv192[rsp]
  003d8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188972
  003e4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188973
  003f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188974
  003fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00401	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00406	41 b9 03 00 00
	00		 mov	 r9d, 3
  0040c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188975
  00413	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188976
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 268  : 
; 269  :         if (new_mainsize != old_mainsize)

  00425	48 8b 44 24 70	 mov	 rax, QWORD PTR old_mainsize$[rsp]
  0042a	48 39 44 24 60	 cmp	 QWORD PTR new_mainsize$[rsp], rax
  0042f	0f 84 20 01 00
	00		 je	 $LN16@archlvl_cm

; 270  :         {
; 271  :             char memsize[64];
; 272  :             bool increased = (new_mainsize > old_mainsize);

  00435	48 8b 44 24 70	 mov	 rax, QWORD PTR old_mainsize$[rsp]
  0043a	48 39 44 24 60	 cmp	 QWORD PTR new_mainsize$[rsp], rax
  0043f	76 0a		 jbe	 SHORT $LN21@archlvl_cm
  00441	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  00449	eb 08		 jmp	 SHORT $LN22@archlvl_cm
$LN21@archlvl_cm:
  0044b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN22@archlvl_cm:
  00453	83 7c 24 58 00	 cmp	 DWORD PTR tv208[rsp], 0
  00458	75 0a		 jne	 SHORT $LN23@archlvl_cm
  0045a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
  00462	eb 08		 jmp	 SHORT $LN24@archlvl_cm
$LN23@archlvl_cm:
  00464	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
$LN24@archlvl_cm:
  0046c	0f b6 44 24 5c	 movzx	 eax, BYTE PTR tv210[rsp]
  00471	88 44 24 50	 mov	 BYTE PTR increased$1[rsp], al

; 273  :             fmt_memsize_KB( sysblk.mainsize >> SHIFT_KIBIBYTE, memsize, sizeof( memsize ));

  00475	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0047c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00483	48 c1 e8 0a	 shr	 rax, 10
  00487	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0048d	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR memsize$2[rsp]
  00495	48 8b c8	 mov	 rcx, rax
  00498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize_KB

; 274  : 
; 275  :             // "MAINSIZE %screased to %s architectural %simum"
; 276  :             WRMSG( HHC17006, "W", increased ? "in" : "de", memsize,

  0049e	0f b6 44 24 50	 movzx	 eax, BYTE PTR increased$1[rsp]
  004a3	85 c0		 test	 eax, eax
  004a5	74 0e		 je	 SHORT $LN25@archlvl_cm
  004a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG188978
  004ae	48 89 44 24 78	 mov	 QWORD PTR tv219[rsp], rax
  004b3	eb 0c		 jmp	 SHORT $LN26@archlvl_cm
$LN25@archlvl_cm:
  004b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG188979
  004bc	48 89 44 24 78	 mov	 QWORD PTR tv219[rsp], rax
$LN26@archlvl_cm:
  004c1	0f b6 44 24 50	 movzx	 eax, BYTE PTR increased$1[rsp]
  004c6	85 c0		 test	 eax, eax
  004c8	74 11		 je	 SHORT $LN27@archlvl_cm
  004ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG188980
  004d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  004d9	eb 0f		 jmp	 SHORT $LN28@archlvl_cm
$LN27@archlvl_cm:
  004db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG188981
  004e2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
$LN28@archlvl_cm:
  004ea	b9 01 00 00 00	 mov	 ecx, 1
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv219[rsp]
  004fa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004ff	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR memsize$2[rsp]
  00507	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0050c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  00514	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00519	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188982
  00520	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00525	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188983
  0052c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00531	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00536	41 b9 03 00 00
	00		 mov	 r9d, 3
  0053c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188984
  00543	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  00548	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188985
  0054f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@archlvl_cm:
$LN15@archlvl_cm:

; 277  :                 increased ? "min" : "max" );
; 278  :         }
; 279  :     }
; 280  : 
; 281  :     /* If S/370 archmode was just set, force LPARNUM to BASIC.
; 282  :        Else if LPARNUM is BASIC, change it back to LPARNUM 1
; 283  :        if archmode is z/Arch. Else (ARCH_390_IDX) leave it alone.
; 284  :        The user can override this automatic LPARNUM switching
; 285  :        via their own subsequent LPARNUM stmt/cmd if such auto-
; 286  :        matic behavior is not desired.
; 287  :     */
; 288  :     if (1
; 289  :         && ARCH_370_IDX == sysblk.arch_mode
; 290  :         && om_basic != sysblk.operation_mode

  00555	33 c0		 xor	 eax, eax
  00557	83 f8 01	 cmp	 eax, 1
  0055a	74 32		 je	 SHORT $LN17@archlvl_cm
  0055c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00563	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0056a	75 22		 jne	 SHORT $LN17@archlvl_cm
  0056c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00573	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [rax+232], 0
  0057a	74 12		 je	 SHORT $LN17@archlvl_cm

; 291  :     )
; 292  :         panel_command( "-LPARNUM BASIC" );

  0057c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188988
  00583	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0058a	ff 10		 call	 QWORD PTR [rax]
  0058c	eb 47		 jmp	 SHORT $LN18@archlvl_cm
$LN17@archlvl_cm:

; 293  :     else if (1
; 294  :         && ARCH_900_IDX == sysblk.arch_mode
; 295  :         && om_basic == sysblk.operation_mode

  0058e	33 c0		 xor	 eax, eax
  00590	83 f8 01	 cmp	 eax, 1
  00593	74 40		 je	 SHORT $LN19@archlvl_cm
  00595	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0059c	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  005a3	75 30		 jne	 SHORT $LN19@archlvl_cm
  005a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ac	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [rax+232], 0
  005b3	75 20		 jne	 SHORT $LN19@archlvl_cm

; 296  :     )
; 297  :     {
; 298  :         panel_command( "-LPARNUM 1" );

  005b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188990
  005bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  005c3	ff 10		 call	 QWORD PTR [rax]

; 299  :         panel_command( "-CPUIDFMT 0" );

  005c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188991
  005cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  005d3	ff 10		 call	 QWORD PTR [rax]
$LN19@archlvl_cm:
$LN18@archlvl_cm:

; 300  :     }
; 301  : 
; 302  :     return 0;

  005d5	33 c0		 xor	 eax, eax
$LN1@archlvl_cm:

; 303  : }

  005d7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005df	48 33 cc	 xor	 rcx, rsp
  005e2	e8 00 00 00 00	 call	 __security_check_cookie
  005e7	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  005ee	c3		 ret	 0
archlvl_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
tv68 = 32
at$ = 40
archname$ = 64
get_archmode_by_name PROC

; 178  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 179  :     const ARCHTAB* at = get_archtab_by_name( archname );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR archname$[rsp]
  0000e	e8 00 00 00 00	 call	 get_archtab_by_name
  00013	48 89 44 24 28	 mov	 QWORD PTR at$[rsp], rax

; 180  :     return at ? at->num : -1;

  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR at$[rsp], 0
  0001e	74 0e		 je	 SHORT $LN3@get_archmo
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR at$[rsp]
  00025	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00028	89 44 24 20	 mov	 DWORD PTR tv68[rsp], eax
  0002c	eb 08		 jmp	 SHORT $LN4@get_archmo
$LN3@get_archmo:
  0002e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@get_archmo:
  00036	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 181  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
get_archmode_by_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
i$ = 32
name$ = 64
get_archtab_by_name PROC

; 148  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 149  :     size_t i;
; 150  :     for (i=0; i < _countof( archtab ); i++)

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00012	eb 0d		 jmp	 SHORT $LN4@get_archta
$LN2@get_archta:
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00019	48 ff c0	 inc	 rax
  0001c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@get_archta:
  00021	48 83 7c 24 20
	15		 cmp	 QWORD PTR i$[rsp], 21
  00027	73 37		 jae	 SHORT $LN3@get_archta

; 151  :         if (strcasecmp( archtab[i].name, name ) == 0)

  00029	48 6b 44 24 20
	10		 imul	 rax, QWORD PTR i$[rsp], 16
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:archtab
  00036	48 8b 54 24 40	 mov	 rdx, QWORD PTR name$[rsp]
  0003b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00045	85 c0		 test	 eax, eax
  00047	75 15		 jne	 SHORT $LN5@get_archta

; 152  :             return &archtab[i];

  00049	48 6b 44 24 20
	10		 imul	 rax, QWORD PTR i$[rsp], 16
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:archtab
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	eb 04		 jmp	 SHORT $LN1@get_archta
$LN5@get_archta:
  0005e	eb b4		 jmp	 SHORT $LN2@get_archta
$LN3@get_archta:

; 153  :     return NULL;

  00060	33 c0		 xor	 eax, eax
$LN1@get_archta:

; 154  : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
get_archtab_by_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
i$ = 0
archnum$ = 32
get_archtab_by_arch PROC

; 128  : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 129  :     // An "Architecture mode" (archmode, arch_mode) is the same
; 130  :     // thing as an "Architecture number" (archnum, arch_num),
; 131  :     // which is simply an index value determined at build time
; 132  :     // depending on which architectures that Hercules was built
; 133  :     // with support for (ARCH_nnn_IDX #defined by featchk.h) and
; 134  :     // is used to index into architecture dependent tables such as
; 135  :     // the sysblk.facility_list and the opcode tables in opcode.c
; 136  : 
; 137  :     size_t i;
; 138  :     for (i=0; i < _countof( archtab ); i++)

  00008	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00010	eb 0b		 jmp	 SHORT $LN4@get_archta
$LN2@get_archta:
  00012	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00016	48 ff c0	 inc	 rax
  00019	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN4@get_archta:
  0001d	48 83 3c 24 15	 cmp	 QWORD PTR i$[rsp], 21
  00022	73 2c		 jae	 SHORT $LN3@get_archta

; 139  :         if (archtab[i].num == archnum)

  00024	48 6b 04 24 10	 imul	 rax, QWORD PTR i$[rsp], 16
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:archtab
  00030	8b 54 24 20	 mov	 edx, DWORD PTR archnum$[rsp]
  00034	39 54 01 08	 cmp	 DWORD PTR [rcx+rax+8], edx
  00038	75 14		 jne	 SHORT $LN5@get_archta

; 140  :             return &archtab[i];

  0003a	48 6b 04 24 10	 imul	 rax, QWORD PTR i$[rsp], 16
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:archtab
  00046	48 03 c8	 add	 rcx, rax
  00049	48 8b c1	 mov	 rax, rcx
  0004c	eb 04		 jmp	 SHORT $LN1@get_archta
$LN5@get_archta:
  0004e	eb c2		 jmp	 SHORT $LN2@get_archta
$LN3@get_archta:

; 141  :     return NULL;

  00050	33 c0		 xor	 eax, eax
$LN1@get_archta:

; 142  : }

  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
get_archtab_by_arch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
at$ = 32
tv68 = 40
archnum$ = 64
get_arch_name_by_arch PROC

; 160  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 161  :     const ARCHTAB* at = get_archtab_by_arch( archnum );

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR archnum$[rsp]
  0000c	e8 00 00 00 00	 call	 get_archtab_by_arch
  00011	48 89 44 24 20	 mov	 QWORD PTR at$[rsp], rax

; 162  :     return at ? at->name : NULL;

  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR at$[rsp], 0
  0001c	74 0f		 je	 SHORT $LN3@get_arch_n
  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR at$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
  0002b	eb 09		 jmp	 SHORT $LN4@get_arch_n
$LN3@get_arch_n:
  0002d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
$LN4@get_arch_n:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv68[rsp]

; 163  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
get_arch_name_by_arch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
tv67 = 32
archnum$ = 36
regs$ = 64
get_arch_name PROC

; 169  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 170  :     int archnum = regs ? regs->arch_mode : sysblk.arch_mode;

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0000f	74 0e		 je	 SHORT $LN3@get_arch_n
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00016	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00019	89 44 24 20	 mov	 DWORD PTR tv67[rsp], eax
  0001d	eb 11		 jmp	 SHORT $LN4@get_arch_n
$LN3@get_arch_n:
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002c	89 44 24 20	 mov	 DWORD PTR tv67[rsp], eax
$LN4@get_arch_n:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]
  00034	89 44 24 24	 mov	 DWORD PTR archnum$[rsp], eax

; 171  :     return get_arch_name_by_arch( archnum );

  00038	8b 4c 24 24	 mov	 ecx, DWORD PTR archnum$[rsp]
  0003c	e8 00 00 00 00	 call	 get_arch_name_by_arch

; 172  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
get_arch_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\archlvl.c
_TEXT	SEGMENT
init_default_archmode PROC

; 119  :     // Called ONCE by bldcfg.c 'build_config' during system startup.
; 120  : 
; 121  :     sysblk.arch_mode = archtab[0].num;  // (always the first entry)

  00000	b8 10 00 00 00	 mov	 eax, 16
  00005	48 6b c0 00	 imul	 rax, rax, 0
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:archtab
  00010	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00017	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  0001b	89 82 88 00 00
	00		 mov	 DWORD PTR [rdx+136], eax

; 122  : }

  00021	c3		 ret	 0
init_default_archmode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
all_stopped$ = 32
are_all_cpus_stopped PROC

; 546  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 547  :     bool all_stopped;
; 548  : 
; 549  :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158973
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 550  :     {
; 551  :         all_stopped = are_all_cpus_stopped_intlock_held();

  00012	e8 00 00 00 00	 call	 are_all_cpus_stopped_intlock_held
  00017	88 44 24 20	 mov	 BYTE PTR all_stopped$[rsp], al

; 552  :     }
; 553  :     RELEASE_INTLOCK( NULL );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158974
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 554  :     return all_stopped;

  00029	0f b6 44 24 20	 movzx	 eax, BYTE PTR all_stopped$[rsp]

; 555  : }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
are_all_cpus_stopped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_all_cpus_stopped_intlock_held PROC

; 516  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 517  :     int cpu;
; 518  : 
; 519  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_all_cp

; 520  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_all_cp
$LN2@are_all_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_all_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_all_cp

; 521  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_all_cp

; 522  :                 if (sysblk.regs[ cpu ]->cpustate != CPUSTATE_STOPPED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 03	 cmp	 eax, 3
  00067	74 04		 je	 SHORT $LN7@are_all_cp

; 523  :                     return false;

  00069	32 c0		 xor	 al, al
  0006b	eb 04		 jmp	 SHORT $LN1@are_all_cp
$LN7@are_all_cp:
$LN6@are_all_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_all_cp
$LN3@are_all_cp:
$LN5@are_all_cp:

; 524  :     return true;

  0006f	b0 01		 mov	 al, 1
$LN1@are_all_cp:

; 525  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_all_cpus_stopped_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
s$ = 32
r$ = 40
result$ = 64
string$ = 72
strupper PROC

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     register char *r = result;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 159  :     register char *s = string;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 160  :     for (; *s; r++, s++)

  00022	eb 1a		 jmp	 SHORT $LN4@strupper
$LN2@strupper:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 ff c0	 inc	 rax
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@strupper:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	85 c0		 test	 eax, eax
  00048	74 16		 je	 SHORT $LN3@strupper

; 161  :     {
; 162  :         *r = asciitoupper(*s);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00052	e8 00 00 00 00	 call	 asciitoupper
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$[rsp]
  0005c	88 01		 mov	 BYTE PTR [rcx], al

; 163  :     }

  0005e	eb c4		 jmp	 SHORT $LN2@strupper
$LN3@strupper:

; 164  :     *r = 0;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 165  :     return result;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 166  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
END
