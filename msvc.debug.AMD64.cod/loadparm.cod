; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
dflt_lparname DB 0c8H
	DB	0c5H
	DB	0d9H
	DB	0c3H
	DB	0e4H
	DB	0d3H
	DB	0c5H
	DB	0e2H
dflt_model DB	0c5H
	DB	0d4H
	DB	0e4H
	DB	0d3H
	DB	0c1H
	DB	0e3H
	DB	0d6H
	DB	0d9H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
default_manufact DB 0c8H
	DB	0d9H
	DB	0c3H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
default_plant DB 0e9H
	DB	0e9H
	DB	040H
	DB	040H
	ORG $+4
dflt_cpid DB	0c8H
	DB	0c5H
	DB	0d9H
	DB	0c3H
	DB	0e4H
	DB	0d3H
	DB	0c5H
	DB	0e2H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
dflt_vmid DB	0c8H
	DB	0c5H
	DB	0d9H
	DB	0c3H
	DB	0e4H
	DB	0d3H
	DB	0c5H
	DB	0e2H
CONST	ENDS
PUBLIC	store_hw_noswap
PUBLIC	set_loadparm
PUBLIC	get_loadparm
PUBLIC	str_loadparm
PUBLIC	set_lparname
PUBLIC	get_lparname
PUBLIC	str_lparname
PUBLIC	set_manufacturer
PUBLIC	str_manufacturer
PUBLIC	set_plant
PUBLIC	str_plant
PUBLIC	set_model
PUBLIC	str_modelhard
PUBLIC	str_modelcapa
PUBLIC	str_modelperm
PUBLIC	str_modeltemp
PUBLIC	get_manufacturer
PUBLIC	get_plant
PUBLIC	get_model
PUBLIC	get_modelcapa
PUBLIC	get_modelperm
PUBLIC	get_modeltemp
PUBLIC	get_RealCPCount
PUBLIC	get_sysname
PUBLIC	get_systype
PUBLIC	get_sysplex
PUBLIC	set_sysname
PUBLIC	set_systype
PUBLIC	set_sysplex
PUBLIC	str_sysname
PUBLIC	str_sysplex
PUBLIC	str_systype
PUBLIC	get_vmid
PUBLIC	set_vmid
PUBLIC	str_vmid
PUBLIC	get_cpid
PUBLIC	str_cpid
PUBLIC	bld_sysib_sequence
PUBLIC	get_mpfactors
PUBLIC	set_cpid
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp_toupper:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_hostinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
gsysinfo_init_flg DD 01H DUP (?)
gsysinfo DB	094H DUP (?)
?result@?2??str_loadparm@@9@9 DB 09H DUP (?)		; `str_loadparm'::`3'::result
	ALIGN	4

?result@?2??str_lparname@@9@9 DB 09H DUP (?)		; `str_lparname'::`3'::result
	ALIGN	4

?result@?2??str_manufacturer@@9@9 DB 011H DUP (?)	; `str_manufacturer'::`3'::result
	ALIGN	4

?result@?2??str_plant@@9@9 DB 05H DUP (?)		; `str_plant'::`3'::result
	ALIGN	4

?result@?2??str_modelhard@@9@9 DB 011H DUP (?)		; `str_modelhard'::`3'::result
	ALIGN	4

?result@?2??str_modelcapa@@9@9 DB 011H DUP (?)		; `str_modelcapa'::`3'::result
	ALIGN	4

?result@?2??str_modelperm@@9@9 DB 011H DUP (?)		; `str_modelperm'::`3'::result
	ALIGN	4

?result@?2??str_modeltemp@@9@9 DB 011H DUP (?)		; `str_modeltemp'::`3'::result
	ALIGN	4

?result@?2??str_systype@@9@9 DB 09H DUP (?)		; `str_systype'::`3'::result
	ALIGN	4

?result@?2??str_sysname@@9@9 DB 09H DUP (?)		; `str_sysname'::`3'::result
	ALIGN	4

?result@?2??str_sysplex@@9@9 DB 09H DUP (?)		; `str_sysplex'::`3'::result
	ALIGN	4

?result@?2??str_vmid@@9@9 DB 09H DUP (?)		; `str_vmid'::`3'::result
	ALIGN	4

?result@?2??str_cpid@@9@9 DB 011H DUP (?)		; `str_cpid'::`3'::result
	ALIGN	4

?mpfactors@?1??get_mpfactors@@9@9 DW 03fH DUP (?)	; `get_mpfactors'::`2'::mpfactors
	ALIGN	4

?didthis@?1??get_mpfactors@@9@9 DB 01H DUP (?)		; `get_mpfactors'::`2'::didthis
_BSS	ENDS
pdata	SEGMENT
$pdata$set_loadparm DD imagerel $LN15
	DD	imagerel $LN15+273
	DD	imagerel $unwind$set_loadparm
$pdata$get_loadparm DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_loadparm
$pdata$str_loadparm DD imagerel $LN14
	DD	imagerel $LN14+226
	DD	imagerel $unwind$str_loadparm
$pdata$set_lparname DD imagerel $LN15
	DD	imagerel $LN15+273
	DD	imagerel $unwind$set_lparname
$pdata$get_lparname DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_lparname
$pdata$str_lparname DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_lparname
$pdata$set_manufacturer DD imagerel $LN11
	DD	imagerel $LN11+312
	DD	imagerel $unwind$set_manufacturer
$pdata$str_manufacturer DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_manufacturer
$pdata$set_plant DD imagerel $LN11
	DD	imagerel $LN11+252
	DD	imagerel $unwind$set_plant
$pdata$str_plant DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_plant
$pdata$set_model DD imagerel $LN35
	DD	imagerel $LN35+755
	DD	imagerel $unwind$set_model
$pdata$str_modelhard DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_modelhard
$pdata$str_modelcapa DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_modelcapa
$pdata$str_modelperm DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_modelperm
$pdata$str_modeltemp DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_modeltemp
$pdata$get_manufacturer DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_manufacturer
$pdata$get_plant DD imagerel $LN4
	DD	imagerel $LN4+43
	DD	imagerel $unwind$get_plant
$pdata$get_model DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_model
$pdata$get_modelcapa DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_modelcapa
$pdata$get_modelperm DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_modelperm
$pdata$get_modeltemp DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_modeltemp
$pdata$get_RealCPCount DD imagerel $LN17
	DD	imagerel $LN17+327
	DD	imagerel $unwind$get_RealCPCount
$pdata$get_sysname DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_sysname
$pdata$get_systype DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_systype
$pdata$get_sysplex DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_sysplex
$pdata$set_sysname DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$set_sysname
$pdata$set_systype DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$set_systype
$pdata$set_sysplex DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$set_sysplex
$pdata$str_sysname DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_sysname
$pdata$str_sysplex DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_sysplex
$pdata$str_systype DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_systype
$pdata$get_vmid DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$get_vmid
$pdata$set_vmid DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$set_vmid
$pdata$str_vmid DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_vmid
$pdata$get_cpid DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$get_cpid
$pdata$str_cpid DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$str_cpid
$pdata$bld_sysib_sequence DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$bld_sysib_sequence
$pdata$get_mpfactors DD imagerel $LN16
	DD	imagerel $LN16+344
	DD	imagerel $unwind$get_mpfactors
$pdata$get_gsysinfo DD imagerel get_gsysinfo
	DD	imagerel get_gsysinfo+264
	DD	imagerel $unwind$get_gsysinfo
$pdata$copy_stringz_to_ebcdic DD imagerel copy_stringz_to_ebcdic
	DD	imagerel copy_stringz_to_ebcdic+378
	DD	imagerel $unwind$copy_stringz_to_ebcdic
$pdata$copy_ebcdic_to_stringz DD imagerel copy_ebcdic_to_stringz
	DD	imagerel copy_ebcdic_to_stringz+250
	DD	imagerel $unwind$copy_ebcdic_to_stringz
$pdata$set_cpid DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$set_cpid
pdata	ENDS
_DATA	SEGMENT
$SG159253 DB	'=', 00H
	ORG $+2
$SG159261 DB	'=', 00H
	ORG $+2
$SG159270 DB	'=', 00H
	ORG $+2
$SG159278 DB	'=', 00H
	ORG $+2
?hexebcdic@?1??bld_sysib_sequence@@9@9 DB 0f0H		; `bld_sysib_sequence'::`2'::hexebcdic
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:set_manufacturer
	DD	015H
	DD	0124H
voltbl	ENDS
xdata	SEGMENT
$unwind$set_loadparm DD 010901H
	DD	08209H
$unwind$get_loadparm DD 010901H
	DD	04209H
$unwind$str_loadparm DD 010401H
	DD	08204H
$unwind$set_lparname DD 010901H
	DD	08209H
$unwind$get_lparname DD 010901H
	DD	04209H
$unwind$str_lparname DD 010401H
	DD	04204H
$unwind$set_manufacturer DD 031a19H
	DD	07007a20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$str_manufacturer DD 010401H
	DD	04204H
$unwind$set_plant DD 020a01H
	DD	07006520aH
$unwind$str_plant DD 010401H
	DD	04204H
$unwind$set_model DD 031a01H
	DD	07016621aH
	DD	06015H
$unwind$str_modelhard DD 010401H
	DD	04204H
$unwind$str_modelcapa DD 010401H
	DD	04204H
$unwind$str_modelperm DD 010401H
	DD	04204H
$unwind$str_modeltemp DD 010401H
	DD	04204H
$unwind$get_manufacturer DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$get_plant DD 010901H
	DD	04209H
$unwind$get_model DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$get_modelcapa DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$get_modelperm DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$get_modeltemp DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$get_RealCPCount DD 010401H
	DD	04204H
$unwind$get_sysname DD 010901H
	DD	04209H
$unwind$get_systype DD 010901H
	DD	04209H
$unwind$get_sysplex DD 010901H
	DD	04209H
$unwind$set_sysname DD 010901H
	DD	04209H
$unwind$set_systype DD 010901H
	DD	04209H
$unwind$set_sysplex DD 010901H
	DD	04209H
$unwind$str_sysname DD 010401H
	DD	04204H
$unwind$str_sysplex DD 010401H
	DD	04204H
$unwind$str_systype DD 010401H
	DD	04204H
$unwind$get_vmid DD 010901H
	DD	04209H
$unwind$set_vmid DD 010901H
	DD	04209H
$unwind$str_vmid DD 010401H
	DD	04204H
$unwind$get_cpid DD 030b01H
	DD	07007420bH
	DD	06006H
$unwind$str_cpid DD 010401H
	DD	04204H
$unwind$bld_sysib_sequence DD 020a01H
	DD	07006320aH
$unwind$get_mpfactors DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$get_gsysinfo DD 020701H
	DD	060067007H
$unwind$copy_stringz_to_ebcdic DD 031501H
	DD	07011a215H
	DD	06010H
$unwind$copy_ebcdic_to_stringz DD 021901H
	DD	070157219H
$unwind$set_cpid DD 030b01H
	DD	07007420bH
	DD	06006H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
src$ = 64
set_cpid PROC

; 632  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 633  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@set_cpid

; 634  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_cpid:

; 635  : 
; 636  :     memcpy(gsysinfo.cpid, src, sizeof(gsysinfo.cpid));

  0001b	48 8d 05 7c 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+124
  00022	48 8b f8	 mov	 rdi, rax
  00025	48 8b 74 24 40	 mov	 rsi, QWORD PTR src$[rsp]
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 637  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
set_cpid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
c$ = 32
i$ = 40
tv74 = 48
copylen$ = 56
name$ = 80
nlen$ = 88
fld$ = 96
flen$ = 104
copy_ebcdic_to_stringz PROC

; 206  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 207  :     size_t  i;
; 208  :     size_t  copylen;
; 209  :     char    c;
; 210  : 
; 211  :     if ( name == NULL || nlen == 0 || flen == 0 ) return -1;

  00019	48 83 7c 24 50
	00		 cmp	 QWORD PTR name$[rsp], 0
  0001f	74 10		 je	 SHORT $LN6@copy_ebcdi
  00021	48 83 7c 24 58
	00		 cmp	 QWORD PTR nlen$[rsp], 0
  00027	74 08		 je	 SHORT $LN6@copy_ebcdi
  00029	48 83 7c 24 68
	00		 cmp	 QWORD PTR flen$[rsp], 0
  0002f	75 0a		 jne	 SHORT $LN5@copy_ebcdi
$LN6@copy_ebcdi:
  00031	b8 ff ff ff ff	 mov	 eax, -1
  00036	e9 b9 00 00 00	 jmp	 $LN1@copy_ebcdi
$LN5@copy_ebcdi:

; 212  : 
; 213  :     memset(name, 0, nlen);

  0003b	48 8b 7c 24 50	 mov	 rdi, QWORD PTR name$[rsp]
  00040	33 c0		 xor	 eax, eax
  00042	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nlen$[rsp]
  00047	f3 aa		 rep stosb

; 214  :     copylen = MIN(nlen-1, flen);

  00049	48 8b 44 24 58	 mov	 rax, QWORD PTR nlen$[rsp]
  0004e	48 ff c8	 dec	 rax
  00051	48 3b 44 24 68	 cmp	 rax, QWORD PTR flen$[rsp]
  00056	73 0f		 jae	 SHORT $LN10@copy_ebcdi
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR nlen$[rsp]
  0005d	48 ff c8	 dec	 rax
  00060	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00065	eb 0a		 jmp	 SHORT $LN11@copy_ebcdi
$LN10@copy_ebcdi:
  00067	48 8b 44 24 68	 mov	 rax, QWORD PTR flen$[rsp]
  0006c	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
$LN11@copy_ebcdi:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00076	48 89 44 24 38	 mov	 QWORD PTR copylen$[rsp], rax

; 215  : 
; 216  :     for ( i = 0; i < copylen; i++ )

  0007b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00084	eb 0d		 jmp	 SHORT $LN4@copy_ebcdi
$LN2@copy_ebcdi:
  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0008b	48 ff c0	 inc	 rax
  0008e	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@copy_ebcdi:
  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR copylen$[rsp]
  00098	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0009d	73 53		 jae	 SHORT $LN3@copy_ebcdi

; 217  :     {
; 218  :         c = guest_to_host(fld[i]);

  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fld$[rsp]
  000a9	48 03 c8	 add	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000b8	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 219  : 
; 220  :         if ( c == SPACE || !isalnum(c) )

  000bc	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  000c1	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c4	74 11		 je	 SHORT $LN8@copy_ebcdi
  000c6	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  000cb	8b c8		 mov	 ecx, eax
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  000d3	85 c0		 test	 eax, eax
  000d5	75 02		 jne	 SHORT $LN7@copy_ebcdi
$LN8@copy_ebcdi:

; 221  :             break; /* there should not be any embedded blanks */

  000d7	eb 19		 jmp	 SHORT $LN3@copy_ebcdi
$LN7@copy_ebcdi:

; 222  : 
; 223  :         name[i] = c;

  000d9	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  000ee	88 08		 mov	 BYTE PTR [rax], cl

; 224  :     }

  000f0	eb 94		 jmp	 SHORT $LN2@copy_ebcdi
$LN3@copy_ebcdi:

; 225  : 
; 226  :     return 0;

  000f2	33 c0		 xor	 eax, eax
$LN1@copy_ebcdi:

; 227  : 
; 228  : }

  000f4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
copy_ebcdic_to_stringz ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
n$ = 32
i$ = 40
temp_fld$ = 48
tv87 = 56
copylen$ = 64
fld$ = 112
len$ = 120
name$ = 128
copy_stringz_to_ebcdic PROC

; 166  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 167  :     size_t  i;
; 168  :     size_t  copylen;
; 169  :     int     n;
; 170  :     BYTE    *temp_fld;
; 171  : 
; 172  :     if ( name == NULL || strlen(name) == 0 )

  00015	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR name$[rsp], 0
  0001e	74 12		 je	 SHORT $LN6@copy_strin
  00020	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00028	e8 00 00 00 00	 call	 strlen
  0002d	48 85 c0	 test	 rax, rax
  00030	75 15		 jne	 SHORT $LN5@copy_strin
$LN6@copy_strin:

; 173  :     {
; 174  :         memset(fld, 0, len);

  00032	48 8b 7c 24 70	 mov	 rdi, QWORD PTR fld$[rsp]
  00037	33 c0		 xor	 eax, eax
  00039	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  0003e	f3 aa		 rep stosb

; 175  :         return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 2c 01 00 00	 jmp	 $LN1@copy_strin
$LN5@copy_strin:

; 176  :     }
; 177  : 
; 178  :     temp_fld = (BYTE *)malloc(len+1);

  00047	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  0004c	48 ff c0	 inc	 rax
  0004f	48 8b c8	 mov	 rcx, rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00058	48 89 44 24 30	 mov	 QWORD PTR temp_fld$[rsp], rax

; 179  :     memset(temp_fld, 0x40, len);

  0005d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp_fld$[rsp]
  00062	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00067	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  0006c	f3 aa		 rep stosb

; 180  :     copylen = MIN(strlen(name), len);

  0006e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00076	e8 00 00 00 00	 call	 strlen
  0007b	48 3b 44 24 78	 cmp	 rax, QWORD PTR len$[rsp]
  00080	73 14		 jae	 SHORT $LN11@copy_strin
  00082	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  0008a	e8 00 00 00 00	 call	 strlen
  0008f	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
  00094	eb 0a		 jmp	 SHORT $LN12@copy_strin
$LN11@copy_strin:
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  0009b	48 89 44 24 38	 mov	 QWORD PTR tv87[rsp], rax
$LN12@copy_strin:
  000a0	48 8b 44 24 38	 mov	 rax, QWORD PTR tv87[rsp]
  000a5	48 89 44 24 40	 mov	 QWORD PTR copylen$[rsp], rax

; 181  : 
; 182  :     for ( i = 0, n = 0; i < copylen; i++ )

  000aa	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  000bb	eb 0d		 jmp	 SHORT $LN4@copy_strin
$LN2@copy_strin:
  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000c2	48 ff c0	 inc	 rax
  000c5	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@copy_strin:
  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR copylen$[rsp]
  000cf	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000d4	73 76		 jae	 SHORT $LN3@copy_strin

; 183  :         if ( isalnum(name[i]) )

  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ec	8b c8		 mov	 ecx, eax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  000f4	85 c0		 test	 eax, eax
  000f6	74 45		 je	 SHORT $LN7@copy_strin

; 184  :         {
; 185  :             temp_fld[i] = host_to_guest((int)toupper(name[i]));

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00105	48 03 c8	 add	 rcx, rax
  00108	48 8b c1	 mov	 rax, rcx
  0010b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010e	8b c8		 mov	 ecx, eax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00116	0f b6 c8	 movzx	 ecx, al
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0011f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00124	48 8b 54 24 30	 mov	 rdx, QWORD PTR temp_fld$[rsp]
  00129	48 03 d1	 add	 rdx, rcx
  0012c	48 8b ca	 mov	 rcx, rdx
  0012f	88 01		 mov	 BYTE PTR [rcx], al

; 186  :             n++;

  00131	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00135	ff c0		 inc	 eax
  00137	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 187  :         }

  0013b	eb 0a		 jmp	 SHORT $LN8@copy_strin
$LN7@copy_strin:

; 188  :         else
; 189  :         {
; 190  :             n = -1;

  0013d	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR n$[rsp], -1

; 191  :             break;

  00145	eb 05		 jmp	 SHORT $LN3@copy_strin
$LN8@copy_strin:

; 192  :         }

  00147	e9 71 ff ff ff	 jmp	 $LN2@copy_strin
$LN3@copy_strin:

; 193  : 
; 194  :     if ( n > 0 )

  0014c	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00151	7e 11		 jle	 SHORT $LN9@copy_strin

; 195  :         memcpy(fld,temp_fld,len);

  00153	48 8b 7c 24 70	 mov	 rdi, QWORD PTR fld$[rsp]
  00158	48 8b 74 24 30	 mov	 rsi, QWORD PTR temp_fld$[rsp]
  0015d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  00162	f3 a4		 rep movsb
$LN9@copy_strin:

; 196  : 
; 197  :     free(temp_fld);

  00164	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp_fld$[rsp]
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 198  : 
; 199  :     return n;

  0016f	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
$LN1@copy_strin:

; 200  : }

  00173	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00177	5f		 pop	 rdi
  00178	5e		 pop	 rsi
  00179	c3		 ret	 0
copy_stringz_to_ebcdic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 24
get_gsysinfo PROC

; 139  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi

; 140  :     if ( dest == NULL )

  00007	48 83 7c 24 18
	00		 cmp	 QWORD PTR dest$[rsp], 0
  0000d	0f 85 dc 00 00
	00		 jne	 $LN2@get_gsysin

; 141  :     {
; 142  :         gsysinfo_init_flg = TRUE;

  00013	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gsysinfo_init_flg, 1

; 143  :         memset(&gsysinfo, 0x40, sizeof(GSYSINFO));

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo
  00024	48 8b f8	 mov	 rdi, rax
  00027	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0002c	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00031	f3 aa		 rep stosb

; 144  : 
; 145  :         memcpy(gsysinfo.lparname,  dflt_lparname,       sizeof(gsysinfo.lparname));

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dflt_lparname
  0003a	48 89 05 08 00
	00 00		 mov	 QWORD PTR gsysinfo+8, rax

; 146  :         memcpy(gsysinfo.manufact,  default_manufact,    sizeof(gsysinfo.manufact));

  00041	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+16
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:default_manufact
  0004f	48 8b f8	 mov	 rdi, rax
  00052	48 8b f1	 mov	 rsi, rcx
  00055	b9 10 00 00 00	 mov	 ecx, 16
  0005a	f3 a4		 rep movsb

; 147  :         memcpy(gsysinfo.plant,     default_plant,       sizeof(gsysinfo.plant));

  0005c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_plant
  00062	89 05 20 00 00
	00		 mov	 DWORD PTR gsysinfo+32, eax

; 148  :         memcpy(gsysinfo.model,     dflt_model,          sizeof(gsysinfo.model));

  00068	48 8d 05 24 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+36
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dflt_model
  00076	48 8b f8	 mov	 rdi, rax
  00079	48 8b f1	 mov	 rsi, rcx
  0007c	b9 10 00 00 00	 mov	 ecx, 16
  00081	f3 a4		 rep movsb

; 149  :         memcpy(gsysinfo.modelcapa, dflt_model,          sizeof(gsysinfo.modelcapa));

  00083	48 8d 05 34 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+52
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dflt_model
  00091	48 8b f8	 mov	 rdi, rax
  00094	48 8b f1	 mov	 rsi, rcx
  00097	b9 10 00 00 00	 mov	 ecx, 16
  0009c	f3 a4		 rep movsb

; 150  :         memcpy(gsysinfo.cpid,      dflt_cpid,           sizeof(gsysinfo.cpid));

  0009e	48 8d 05 7c 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+124
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dflt_cpid
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b f1	 mov	 rsi, rcx
  000b2	b9 10 00 00 00	 mov	 ecx, 16
  000b7	f3 a4		 rep movsb

; 151  :         memcpy(gsysinfo.vmid,      dflt_vmid,           sizeof(gsysinfo.vmid));

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dflt_vmid
  000c0	48 89 05 8c 00
	00 00		 mov	 QWORD PTR gsysinfo+140, rax

; 152  : 
; 153  :         memset(gsysinfo.modelperm, 0, sizeof(gsysinfo.modelperm));

  000c7	48 8d 05 44 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+68
  000ce	48 8b f8	 mov	 rdi, rax
  000d1	33 c0		 xor	 eax, eax
  000d3	b9 10 00 00 00	 mov	 ecx, 16
  000d8	f3 aa		 rep stosb

; 154  :         memset(gsysinfo.modeltemp, 0, sizeof(gsysinfo.modeltemp));

  000da	48 8d 05 54 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+84
  000e1	48 8b f8	 mov	 rdi, rax
  000e4	33 c0		 xor	 eax, eax
  000e6	b9 10 00 00 00	 mov	 ecx, 16
  000eb	f3 aa		 rep stosb

; 155  :     }

  000ed	eb 16		 jmp	 SHORT $LN3@get_gsysin
$LN2@get_gsysin:

; 156  :     else
; 157  :         memcpy( dest, &gsysinfo, sizeof(GSYSINFO) );

  000ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo
  000f6	48 8b 7c 24 18	 mov	 rdi, QWORD PTR dest$[rsp]
  000fb	48 8b f0	 mov	 rsi, rax
  000fe	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00103	f3 a4		 rep movsb
$LN3@get_gsysin:

; 158  :     return;
; 159  : }

  00105	5f		 pop	 rdi
  00106	5e		 pop	 rsi
  00107	c3		 ret	 0
get_gsysinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
resmin$1 = 32
result$2 = 36
tv68 = 40
mpfactor$3 = 44
tv85 = 48
i$4 = 56
limit$5 = 64
dest$ = 112
get_mpfactors PROC

; 711  : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 712  : /*-------------------------------------------------------------------*/
; 713  : /* The new z10 machine will use a denominator of 65535 for better    */
; 714  : /* granularity. But this will mess up old software. We will stick    */
; 715  : /* to the old value of 100. Bernard Feb 26, 2010.                    */
; 716  : /*                                                                   */
; 717  : /* Calculations will be done in a higher precision to prevent early  */
; 718  : /* truncation and degradation of the factors. To achieve this, the   */
; 719  : /* factors are calculated * 256. When storing the values, the        */
; 720  : /* individual values are rounded up by 128 and then divided by 256   */
; 721  : /* for the store operation.                                          */
; 722  : /*                                                                   */
; 723  : /* Once the number of host logical CPUs is reached, subsequent MP    */
; 724  : /* factors are no longer adjusted.                                   */
; 725  : /*                                                                   */
; 726  : /* MPFACTOR_DENOMINATOR must be 100, 255, or 65535.                  */
; 727  : /*                                                                   */
; 728  : /* It is recommended that MPFACTOR_PERCENT remain at 95 (95%).       */
; 729  : /*-------------------------------------------------------------------*/
; 730  : #define  MPFACTOR_DENOMINATOR     100
; 731  : #define  MPFACTOR_PERCENT          95
; 732  : 
; 733  :     static U16 mpfactors[ MAX_CPU_ENGS - 1 ] = {0};
; 734  :     static BYTE didthis = 0;
; 735  : 
; 736  :     if (!didthis)

  0000b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?didthis@?1??get_mpfactors@@9@9
  00012	85 c0		 test	 eax, eax
  00014	0f 85 17 01 00
	00		 jne	 $LN7@get_mpfact

; 737  :     {
; 738  :         /* First time: initialize array... */
; 739  :         size_t  limit = get_RealCPCount();

  0001a	e8 00 00 00 00	 call	 get_RealCPCount
  0001f	8b c0		 mov	 eax, eax
  00021	48 89 44 24 40	 mov	 QWORD PTR limit$5[rsp], rax

; 740  :         size_t  i;
; 741  :         U32     mpfactor = MPFACTOR_DENOMINATOR << 8;

  00026	c7 44 24 2c 00
	64 00 00	 mov	 DWORD PTR mpfactor$3[rsp], 25600 ; 00006400H

; 742  :         U16     result = 0;

  0002e	33 c0		 xor	 eax, eax
  00030	66 89 44 24 24	 mov	 WORD PTR result$2[rsp], ax

; 743  :         U16     resmin = 1;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	66 89 44 24 20	 mov	 WORD PTR resmin$1[rsp], ax

; 744  : 
; 745  :         switch (MPFACTOR_DENOMINATOR)

  0003f	c7 44 24 28 64
	00 00 00	 mov	 DWORD PTR tv68[rsp], 100 ; 00000064H
  00047	83 7c 24 28 64	 cmp	 DWORD PTR tv68[rsp], 100 ; 00000064H
  0004c	74 14		 je	 SHORT $LN9@get_mpfact
  0004e	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR tv68[rsp], 255 ; 000000ffH
  00056	74 16		 je	 SHORT $LN10@get_mpfact
  00058	81 7c 24 28 ff
	ff 00 00	 cmp	 DWORD PTR tv68[rsp], 65535 ; 0000ffffH
  00060	74 18		 je	 SHORT $LN11@get_mpfact
$LN9@get_mpfact:

; 746  :         {
; 747  :             default: /* resmin =   1; break; */
; 748  :             case   100: resmin =   1; break;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	66 89 44 24 20	 mov	 WORD PTR resmin$1[rsp], ax
  0006c	eb 16		 jmp	 SHORT $LN2@get_mpfact
$LN10@get_mpfact:

; 749  :             case   255: resmin = 101; break;

  0006e	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
  00073	66 89 44 24 20	 mov	 WORD PTR resmin$1[rsp], ax
  00078	eb 0a		 jmp	 SHORT $LN2@get_mpfact
$LN11@get_mpfact:

; 750  :             case 65535: resmin = 256; break;

  0007a	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0007f	66 89 44 24 20	 mov	 WORD PTR resmin$1[rsp], ax
$LN2@get_mpfact:

; 751  :         }
; 752  : 
; 753  :         for (i=0; i < _countof( mpfactors ); i++)

  00084	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$4[rsp], 0
  0008d	eb 0d		 jmp	 SHORT $LN6@get_mpfact
$LN4@get_mpfact:
  0008f	48 8b 44 24 38	 mov	 rax, QWORD PTR i$4[rsp]
  00094	48 ff c0	 inc	 rax
  00097	48 89 44 24 38	 mov	 QWORD PTR i$4[rsp], rax
$LN6@get_mpfact:
  0009c	48 83 7c 24 38
	3f		 cmp	 QWORD PTR i$4[rsp], 63	; 0000003fH
  000a2	0f 83 82 00 00
	00		 jae	 $LN5@get_mpfact

; 754  :         {
; 755  :             /* Calculate the value of each subsequent entry as a
; 756  :              * percentage of the previous entry's value for the real
; 757  :              * defined CPU entries.
; 758  :              */
; 759  :             if (i < limit)

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR limit$5[rsp]
  000ad	48 39 44 24 38	 cmp	 QWORD PTR i$4[rsp], rax
  000b2	73 4f		 jae	 SHORT $LN12@get_mpfact

; 760  :             {
; 761  :                 mpfactor = (mpfactor * MPFACTOR_PERCENT) / 100;

  000b4	6b 44 24 2c 5f	 imul	 eax, DWORD PTR mpfactor$3[rsp], 95 ; 0000005fH
  000b9	33 d2		 xor	 edx, edx
  000bb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000c0	f7 f1		 div	 ecx
  000c2	89 44 24 2c	 mov	 DWORD PTR mpfactor$3[rsp], eax

; 762  :                 result = (mpfactor + 128) >> 8;

  000c6	8b 44 24 2c	 mov	 eax, DWORD PTR mpfactor$3[rsp]
  000ca	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000cf	c1 e8 08	 shr	 eax, 8
  000d2	66 89 44 24 24	 mov	 WORD PTR result$2[rsp], ax

; 763  :                 result = MAX(result, resmin);

  000d7	0f b7 44 24 24	 movzx	 eax, WORD PTR result$2[rsp]
  000dc	0f b7 4c 24 20	 movzx	 ecx, WORD PTR resmin$1[rsp]
  000e1	3b c1		 cmp	 eax, ecx
  000e3	7e 0b		 jle	 SHORT $LN14@get_mpfact
  000e5	0f b7 44 24 24	 movzx	 eax, WORD PTR result$2[rsp]
  000ea	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
  000ee	eb 09		 jmp	 SHORT $LN15@get_mpfact
$LN14@get_mpfact:
  000f0	0f b7 44 24 20	 movzx	 eax, WORD PTR resmin$1[rsp]
  000f5	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
$LN15@get_mpfact:
  000f9	0f b7 44 24 30	 movzx	 eax, WORD PTR tv85[rsp]
  000fe	66 89 44 24 24	 mov	 WORD PTR result$2[rsp], ax
$LN12@get_mpfact:

; 764  :             }
; 765  :             STORE_HW( &mpfactors[i], result );

  00103	0f b7 4c 24 24	 movzx	 ecx, WORD PTR result$2[rsp]
  00108	e8 00 00 00 00	 call	 _byteswap_ushort
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mpfactors@?1??get_mpfactors@@9@9
  00114	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$4[rsp]
  00119	48 8d 0c 51	 lea	 rcx, QWORD PTR [rcx+rdx*2]
  0011d	0f b7 d0	 movzx	 edx, ax
  00120	e8 00 00 00 00	 call	 store_hw_noswap

; 766  :         }

  00125	e9 65 ff ff ff	 jmp	 $LN4@get_mpfact
$LN5@get_mpfact:

; 767  :         didthis = 1;

  0012a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?didthis@?1??get_mpfactors@@9@9, 1
$LN7@get_mpfact:

; 768  :     }
; 769  : 
; 770  :     /* Return the requested information... */
; 771  :     memcpy( dest, &mpfactors[0], (MAX_CPU_ENGS - 1) * sizeof( U16 ));

  00131	b8 02 00 00 00	 mov	 eax, 2
  00136	48 6b c0 00	 imul	 rax, rax, 0
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mpfactors@?1??get_mpfactors@@9@9
  00141	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00146	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0014a	b9 7e 00 00 00	 mov	 ecx, 126		; 0000007eH
  0014f	f3 a4		 rep movsb

; 772  : }

  00151	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00155	5f		 pop	 rdi
  00156	5e		 pop	 rsi
  00157	c3		 ret	 0
get_mpfactors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
i$ = 0
serial_shift$ = 1
hexebcdic_idx$ = 2
tv131 = 8
seqc_idx$ = 16
seqc$ = 48
bld_sysib_sequence PROC

; 674  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 675  :     static BYTE hexebcdic[16] = {
; 676  :         0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,  // "01234567"
; 677  :         0xF8, 0xF9, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6   // "89ABCDEF"
; 678  :     };
; 679  :     size_t  seqc_idx;
; 680  :     BYTE    serial_shift, hexebcdic_idx, i;
; 681  : 
; 682  :     memset( seqc, 0xF0, 16 );

  0000a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR seqc$[rsp]
  0000f	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H
  00014	b9 10 00 00 00	 mov	 ecx, 16
  00019	f3 aa		 rep stosb

; 683  : 
; 684  :     for (i=0; i < 6; i++)

  0001b	c6 04 24 00	 mov	 BYTE PTR i$[rsp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@bld_sysib_
$LN2@bld_sysib_:
  00021	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00025	fe c0		 inc	 al
  00027	88 04 24	 mov	 BYTE PTR i$[rsp], al
$LN4@bld_sysib_:
  0002a	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  0002e	83 f8 06	 cmp	 eax, 6
  00031	7d 6e		 jge	 SHORT $LN3@bld_sysib_

; 685  :     {
; 686  :         seqc_idx         = 16 - 6 + i;

  00033	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00037	83 c0 0a	 add	 eax, 10
  0003a	48 98		 cdqe
  0003c	48 89 44 24 10	 mov	 QWORD PTR seqc_idx$[rsp], rax

; 687  :         serial_shift     = (32 - (3 * 4)) - (i * 4);

  00041	0f b6 04 24	 movzx	 eax, BYTE PTR i$[rsp]
  00045	c1 e0 02	 shl	 eax, 2
  00048	b9 14 00 00 00	 mov	 ecx, 20
  0004d	2b c8		 sub	 ecx, eax
  0004f	8b c1		 mov	 eax, ecx
  00051	88 44 24 01	 mov	 BYTE PTR serial_shift$[rsp], al

; 688  :         hexebcdic_idx    = (sysblk.cpuserial >> serial_shift) & 0x0F;

  00055	0f b6 44 24 01	 movzx	 eax, BYTE PTR serial_shift$[rsp]
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00061	48 89 4c 24 08	 mov	 QWORD PTR tv131[rsp], rcx
  00066	0f b6 c8	 movzx	 ecx, al
  00069	48 8b 44 24 08	 mov	 rax, QWORD PTR tv131[rsp]
  0006e	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [rax+208]
  00074	d3 e8		 shr	 eax, cl
  00076	83 e0 0f	 and	 eax, 15
  00079	88 44 24 02	 mov	 BYTE PTR hexebcdic_idx$[rsp], al

; 689  :         seqc[ seqc_idx ] = hexebcdic[ hexebcdic_idx ];

  0007d	0f b6 44 24 02	 movzx	 eax, BYTE PTR hexebcdic_idx$[rsp]
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?hexebcdic@?1??bld_sysib_sequence@@9@9
  00089	48 8b 54 24 10	 mov	 rdx, QWORD PTR seqc_idx$[rsp]
  0008e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR seqc$[rsp]
  00093	48 03 fa	 add	 rdi, rdx
  00096	48 8b d7	 mov	 rdx, rdi
  00099	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009d	88 02		 mov	 BYTE PTR [rdx], al

; 690  :     }

  0009f	eb 80		 jmp	 SHORT $LN2@bld_sysib_
$LN3@bld_sysib_:

; 691  : }

  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
bld_sysib_sequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_cpid PROC

; 649  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 650  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_cpid

; 651  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_cpid:

; 652  : 
; 653  :     ebcdic_to_stringz_return(gsysinfo.cpid);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 7c 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+124
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_cpid@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_cpid@@9@9

; 654  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_cpid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dst$ = 64
get_cpid PROC

; 640  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 641  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_cpid

; 642  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_cpid:

; 643  : 
; 644  :     memcpy(dst, gsysinfo.cpid, sizeof(gsysinfo.cpid));

  0001b	48 8d 05 7c 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+124
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dst$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 645  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_cpid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_vmid PROC

; 617  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 618  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_vmid

; 619  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_vmid:

; 620  : 
; 621  :     ebcdic_to_stringz_return(gsysinfo.vmid);

  00014	41 b9 08 00 00
	00		 mov	 r9d, 8
  0001a	4c 8d 05 8c 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+140
  00021	ba 09 00 00 00	 mov	 edx, 9
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_vmid@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_vmid@@9@9

; 622  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_vmid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
src$ = 48
set_vmid PROC

; 600  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 601  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@set_vmid

; 602  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_vmid:

; 603  : 
; 604  :     memcpy(gsysinfo.vmid, src, sizeof(gsysinfo.vmid));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR src$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 05 8c 00
	00 00		 mov	 QWORD PTR gsysinfo+140, rax

; 605  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
set_vmid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dst$ = 48
get_vmid PROC

; 608  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 609  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_vmid

; 610  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_vmid:

; 611  : 
; 612  :     memcpy(dst, gsysinfo.vmid, sizeof(gsysinfo.vmid));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dst$[rsp]
  0001e	48 8b 0d 8c 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo+140
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 613  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_vmid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_systype PROC

; 521  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_systyp

; 523  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_systyp:

; 524  : 
; 525  :     ebcdic_to_stringz_return(gsysinfo.systype);

  00014	41 b9 08 00 00
	00		 mov	 r9d, 8
  0001a	4c 8d 05 64 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+100
  00021	ba 09 00 00 00	 mov	 edx, 9
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_systype@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_systype@@9@9

; 526  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_systype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_sysplex PROC

; 585  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 586  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_sysple

; 587  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_sysple:

; 588  : 
; 589  :     ebcdic_to_stringz_return(gsysinfo.sysplex);

  00014	41 b9 08 00 00
	00		 mov	 r9d, 8
  0001a	4c 8d 05 74 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+116
  00021	ba 09 00 00 00	 mov	 edx, 9
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_sysplex@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_sysplex@@9@9

; 590  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_sysplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_sysname PROC

; 553  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 554  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_sysnam

; 555  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_sysnam:

; 556  : 
; 557  :     ebcdic_to_stringz_return(gsysinfo.sysname);

  00014	41 b9 08 00 00
	00		 mov	 r9d, 8
  0001a	4c 8d 05 6c 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+108
  00021	ba 09 00 00 00	 mov	 edx, 9
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_sysname@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_sysname@@9@9

; 558  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_sysname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
src$ = 48
set_sysplex PROC

; 568  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 569  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@set_sysple

; 570  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_sysple:

; 571  : 
; 572  :     memcpy(gsysinfo.sysplex, src, sizeof(gsysinfo.sysplex));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR src$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 05 74 00
	00 00		 mov	 QWORD PTR gsysinfo+116, rax

; 573  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
set_sysplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
src$ = 48
set_systype PROC

; 504  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 505  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@set_systyp

; 506  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_systyp:

; 507  : 
; 508  :     memcpy(gsysinfo.systype, src, sizeof(gsysinfo.systype));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR src$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 05 64 00
	00 00		 mov	 QWORD PTR gsysinfo+100, rax

; 509  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
set_systype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
src$ = 48
set_sysname PROC

; 536  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 537  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@set_sysnam

; 538  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_sysnam:

; 539  : 
; 540  :     memcpy(gsysinfo.sysname, src, sizeof(gsysinfo.sysname));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR src$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 89 05 6c 00
	00 00		 mov	 QWORD PTR gsysinfo+108, rax

; 541  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
set_sysname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dst$ = 48
get_sysplex PROC

; 576  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 577  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_sysple

; 578  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_sysple:

; 579  : 
; 580  :     memcpy(dst, gsysinfo.sysplex, sizeof(gsysinfo.sysplex));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dst$[rsp]
  0001e	48 8b 0d 74 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo+116
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 581  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_sysplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dst$ = 48
get_systype PROC

; 512  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 513  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_systyp

; 514  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_systyp:

; 515  : 
; 516  :     memcpy(dst, gsysinfo.systype, sizeof(gsysinfo.systype));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dst$[rsp]
  0001e	48 8b 0d 64 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo+100
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 517  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_systype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dst$ = 48
get_sysname PROC

; 544  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 545  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_sysnam

; 546  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_sysnam:

; 547  : 
; 548  :     memcpy(dst, gsysinfo.sysname, sizeof(gsysinfo.sysname));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dst$[rsp]
  0001e	48 8b 0d 6c 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo+108
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 549  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_sysname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
possible$ = 0
cpu$ = 4
cp$ = 8
reserved$ = 12
tv128 = 16
result$ = 20
get_RealCPCount PROC

; 781  : {

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 782  :     unsigned int    possible;
; 783  :     unsigned int    reserved;
; 784  :     unsigned int    cp = 0;

  00004	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR cp$[rsp], 0

; 785  :     unsigned int    cpu;
; 786  :     unsigned int    result;
; 787  : 
; 788  :     /* Initialize the number of possible concurrently dispatchable CP
; 789  :      * engines, taking into account that any of the hostinfo fields
; 790  :      * may be zero when not reported by the host OS.
; 791  :      */
; 792  :     if (hostinfo.num_logical_cpu)

  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00013	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0001a	74 12		 je	 SHORT $LN5@get_RealCP

; 793  :         possible = hostinfo.num_logical_cpu;

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00023	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00029	89 04 24	 mov	 DWORD PTR possible$[rsp], eax
  0002c	eb 59		 jmp	 SHORT $LN6@get_RealCP
$LN5@get_RealCP:

; 794  :     else if (hostinfo.num_procs)

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00035	83 b8 b8 01 00
	00 00		 cmp	 DWORD PTR [rax+440], 0
  0003c	74 42		 je	 SHORT $LN7@get_RealCP

; 795  :     {
; 796  :         if (hostinfo.num_physical_cpu)

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00045	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [rax+444], 0
  0004c	74 20		 je	 SHORT $LN9@get_RealCP

; 797  :             possible = hostinfo.num_procs * hostinfo.num_physical_cpu;

  0004e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_hostinfo
  0005c	8b 80 b8 01 00
	00		 mov	 eax, DWORD PTR [rax+440]
  00062	0f af 81 bc 01
	00 00		 imul	 eax, DWORD PTR [rcx+444]
  00069	89 04 24	 mov	 DWORD PTR possible$[rsp], eax
  0006c	eb 10		 jmp	 SHORT $LN10@get_RealCP
$LN9@get_RealCP:

; 798  :         else
; 799  :             possible = hostinfo.num_procs;

  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00075	8b 80 b8 01 00
	00		 mov	 eax, DWORD PTR [rax+440]
  0007b	89 04 24	 mov	 DWORD PTR possible$[rsp], eax
$LN10@get_RealCP:

; 800  :     }

  0007e	eb 07		 jmp	 SHORT $LN8@get_RealCP
$LN7@get_RealCP:

; 801  :     else
; 802  :         possible = MAX_CPU_ENGS;

  00080	c7 04 24 40 00
	00 00		 mov	 DWORD PTR possible$[rsp], 64 ; 00000040H
$LN8@get_RealCP:
$LN6@get_RealCP:

; 803  : 
; 804  :     /* Limit to the maximum number of Hercules CPU engines */
; 805  :     if (possible > MAX_CPU_ENGS)

  00087	83 3c 24 40	 cmp	 DWORD PTR possible$[rsp], 64 ; 00000040H
  0008b	76 07		 jbe	 SHORT $LN11@get_RealCP

; 806  :         possible = MAX_CPU_ENGS;

  0008d	c7 04 24 40 00
	00 00		 mov	 DWORD PTR possible$[rsp], 64 ; 00000040H
$LN11@get_RealCP:

; 807  : 
; 808  :     /* Set number of reserved processors */
; 809  :     reserved = possible - sysblk.cpus;

  00094	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009b	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [rax+260]
  000a1	8b 0c 24	 mov	 ecx, DWORD PTR possible$[rsp]
  000a4	2b c8		 sub	 ecx, eax
  000a6	8b c1		 mov	 eax, ecx
  000a8	89 44 24 0c	 mov	 DWORD PTR reserved$[rsp], eax

; 810  : 
; 811  :     /* Count the number of defined CP processors */
; 812  :     for ( cpu = 0; cpu < (unsigned) sysblk.hicpu; ++cpu )

  000ac	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  000b4	eb 0a		 jmp	 SHORT $LN4@get_RealCP
$LN2@get_RealCP:
  000b6	8b 44 24 04	 mov	 eax, DWORD PTR cpu$[rsp]
  000ba	ff c0		 inc	 eax
  000bc	89 44 24 04	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@get_RealCP:
  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c7	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  000cd	39 44 24 04	 cmp	 DWORD PTR cpu$[rsp], eax
  000d1	73 39		 jae	 SHORT $LN3@get_RealCP

; 813  :     {
; 814  :         /* Loop through online CP CPUs */
; 815  :         if ( IS_CPU_ONLINE(cpu) )

  000d3	8b 44 24 04	 mov	 eax, DWORD PTR cpu$[rsp]
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000de	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000e7	74 21		 je	 SHORT $LN12@get_RealCP

; 816  :         {
; 817  :             if ( sysblk.ptyp[cpu] == SCCB_PTYP_CP )

  000e9	8b 44 24 04	 mov	 eax, DWORD PTR cpu$[rsp]
  000ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f4	0f b6 84 01 48
	0b 00 00	 movzx	 eax, BYTE PTR [rcx+rax+2888]
  000fc	85 c0		 test	 eax, eax
  000fe	75 0a		 jne	 SHORT $LN13@get_RealCP

; 818  :                 ++cp;

  00100	8b 44 24 08	 mov	 eax, DWORD PTR cp$[rsp]
  00104	ff c0		 inc	 eax
  00106	89 44 24 08	 mov	 DWORD PTR cp$[rsp], eax
$LN13@get_RealCP:
$LN12@get_RealCP:

; 819  :         }
; 820  :     }

  0010a	eb aa		 jmp	 SHORT $LN2@get_RealCP
$LN3@get_RealCP:

; 821  : 
; 822  :     /* The result is the number of CP processors plus the number of
; 823  :      * reserved processors that may become CP processors, limited by the
; 824  :      * number of possible physical/logical processors.
; 825  :      */
; 826  :     result = MIN(cp + reserved, possible);

  0010c	8b 44 24 0c	 mov	 eax, DWORD PTR reserved$[rsp]
  00110	8b 4c 24 08	 mov	 ecx, DWORD PTR cp$[rsp]
  00114	03 c8		 add	 ecx, eax
  00116	8b c1		 mov	 eax, ecx
  00118	3b 04 24	 cmp	 eax, DWORD PTR possible$[rsp]
  0011b	73 12		 jae	 SHORT $LN15@get_RealCP
  0011d	8b 44 24 0c	 mov	 eax, DWORD PTR reserved$[rsp]
  00121	8b 4c 24 08	 mov	 ecx, DWORD PTR cp$[rsp]
  00125	03 c8		 add	 ecx, eax
  00127	8b c1		 mov	 eax, ecx
  00129	89 44 24 10	 mov	 DWORD PTR tv128[rsp], eax
  0012d	eb 07		 jmp	 SHORT $LN16@get_RealCP
$LN15@get_RealCP:
  0012f	8b 04 24	 mov	 eax, DWORD PTR possible$[rsp]
  00132	89 44 24 10	 mov	 DWORD PTR tv128[rsp], eax
$LN16@get_RealCP:
  00136	8b 44 24 10	 mov	 eax, DWORD PTR tv128[rsp]
  0013a	89 44 24 14	 mov	 DWORD PTR result$[rsp], eax

; 827  : 
; 828  :     return (result);

  0013e	8b 44 24 14	 mov	 eax, DWORD PTR result$[rsp]

; 829  : }

  00142	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00146	c3		 ret	 0
get_RealCPCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 64
get_modeltemp PROC

; 457  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 458  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_modelt

; 459  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_modelt:

; 460  : 
; 461  :     memcpy(dest, gsysinfo.modeltemp, sizeof(gsysinfo.modeltemp));

  0001b	48 8d 05 54 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+84
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dest$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 462  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_modeltemp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 64
get_modelperm PROC

; 449  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 450  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_modelp

; 451  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_modelp:

; 452  : 
; 453  :     memcpy(dest, gsysinfo.modelperm, sizeof(gsysinfo.modelperm));

  0001b	48 8d 05 44 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+68
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dest$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 454  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_modelperm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 64
get_modelcapa PROC

; 441  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 442  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_modelc

; 443  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_modelc:

; 444  : 
; 445  :     memcpy(dest, gsysinfo.modelcapa, sizeof(gsysinfo.modelcapa));

  0001b	48 8d 05 34 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+52
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dest$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 446  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_modelcapa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 64
get_model PROC

; 433  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 434  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_model

; 435  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_model:

; 436  : 
; 437  :     memcpy(dest, gsysinfo.model, sizeof(gsysinfo.model));

  0001b	48 8d 05 24 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+36
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dest$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 438  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_model ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 48
get_plant PROC

; 343  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 344  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_plant

; 345  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_plant:

; 346  : 
; 347  :     memcpy(dest, gsysinfo.plant, sizeof(gsysinfo.plant));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$[rsp]
  0001e	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR gsysinfo+32
  00024	89 08		 mov	 DWORD PTR [rax], ecx

; 348  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
get_plant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 64
get_manufacturer PROC

; 312  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 313  :     if (gsysinfo_init_flg == FALSE )

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00012	75 07		 jne	 SHORT $LN2@get_manufa

; 314  :         get_gsysinfo(NULL);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_manufa:

; 315  : 
; 316  :     memcpy(dest, gsysinfo.manufact, sizeof(gsysinfo.manufact));

  0001b	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+16
  00022	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dest$[rsp]
  00027	48 8b f0	 mov	 rsi, rax
  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	f3 a4		 rep movsb

; 317  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
get_manufacturer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_modeltemp PROC

; 489  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 490  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_modelt

; 491  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_modelt:

; 492  : 
; 493  :     ebcdic_to_stringz_return(gsysinfo.modeltemp);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 54 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+84
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_modeltemp@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_modeltemp@@9@9

; 494  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_modeltemp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_modelperm PROC

; 481  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 482  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_modelp

; 483  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_modelp:

; 484  : 
; 485  :     ebcdic_to_stringz_return(gsysinfo.modelperm);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 44 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+68
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_modelperm@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_modelperm@@9@9

; 486  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_modelperm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_modelcapa PROC

; 473  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 474  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_modelc

; 475  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_modelc:

; 476  : 
; 477  :     ebcdic_to_stringz_return(gsysinfo.modelcapa);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 34 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+52
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_modelcapa@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_modelcapa@@9@9

; 478  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_modelcapa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_modelhard PROC

; 465  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 466  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_modelh

; 467  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_modelh:

; 468  : 
; 469  :     ebcdic_to_stringz_return(gsysinfo.model);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 24 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+36
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_modelhard@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_modelhard@@9@9

; 470  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_modelhard ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
tv147 = 32
m1$ = 80
m2$ = 88
m3$ = 96
m4$ = 104
set_model PROC

; 377  : {

$LN35:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 378  :     if (gsysinfo_init_flg == FALSE )

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00021	75 07		 jne	 SHORT $LN2@set_model

; 379  :         get_gsysinfo(NULL);

  00023	33 c9		 xor	 ecx, ecx
  00025	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@set_model:

; 380  : 
; 381  :     /* Model may be binary zero */
; 382  :     if ( m1 != NULL && m1[0] != '*' )

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR m1$[rsp], 0
  00030	0f 84 93 00 00
	00		 je	 $LN3@set_model
  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	48 6b c0 00	 imul	 rax, rax, 0
  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m1$[rsp]
  00044	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00048	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0004b	74 7c		 je	 SHORT $LN3@set_model

; 383  :     {
; 384  :         if ( strlen(m1) == 0 )

  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m1$[rsp]
  00052	e8 00 00 00 00	 call	 strlen
  00057	48 85 c0	 test	 rax, rax
  0005a	75 15		 jne	 SHORT $LN5@set_model

; 385  :             memset(gsysinfo.model, 0, sizeof(gsysinfo.model));

  0005c	48 8d 05 24 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+36
  00063	48 8b f8	 mov	 rdi, rax
  00066	33 c0		 xor	 eax, eax
  00068	b9 10 00 00 00	 mov	 ecx, 16
  0006d	f3 aa		 rep stosb
  0006f	eb 56		 jmp	 SHORT $LN6@set_model
$LN5@set_model:

; 386  :         else if ( strcmp(m1, "=") == 0)

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159253
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m1$[rsp]
  0007d	e8 00 00 00 00	 call	 strcmp
  00082	85 c0		 test	 eax, eax
  00084	75 1d		 jne	 SHORT $LN7@set_model

; 387  :             memcpy(gsysinfo.model, dflt_model, sizeof(gsysinfo.model));

  00086	48 8d 05 24 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+36
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dflt_model
  00094	48 8b f8	 mov	 rdi, rax
  00097	48 8b f1	 mov	 rsi, rcx
  0009a	b9 10 00 00 00	 mov	 ecx, 16
  0009f	f3 a4		 rep movsb
  000a1	eb 24		 jmp	 SHORT $LN8@set_model
$LN7@set_model:

; 388  :         else if ( copy_stringz_to_ebcdic(gsysinfo.model, sizeof(gsysinfo.model), m1) <= 0 ) return 1;

  000a3	4c 8b 44 24 50	 mov	 r8, QWORD PTR m1$[rsp]
  000a8	ba 10 00 00 00	 mov	 edx, 16
  000ad	48 8d 0d 24 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+36
  000b4	e8 00 00 00 00	 call	 copy_stringz_to_ebcdic
  000b9	85 c0		 test	 eax, eax
  000bb	7f 0a		 jg	 SHORT $LN9@set_model
  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	e9 25 02 00 00	 jmp	 $LN1@set_model
$LN9@set_model:
$LN8@set_model:
$LN6@set_model:

; 389  :     }

  000c7	eb 0f		 jmp	 SHORT $LN4@set_model
$LN3@set_model:

; 390  :     else if ( m1 == NULL )

  000c9	48 83 7c 24 50
	00		 cmp	 QWORD PTR m1$[rsp], 0
  000cf	75 07		 jne	 SHORT $LN10@set_model

; 391  :         return 0;

  000d1	33 c0		 xor	 eax, eax
  000d3	e9 14 02 00 00	 jmp	 $LN1@set_model
$LN10@set_model:
$LN4@set_model:

; 392  : 
; 393  :     /* model-capa may NEVER be binary zero, if "" then default to
; 394  :        the same value as the Model field if not binary zero. Otherwise
; 395  :        if the Model field is binary zero the value 'EMULATOR' is used */
; 396  :     if ( m2 != NULL && m2[0] != '*' )

  000d8	48 83 7c 24 58
	00		 cmp	 QWORD PTR m2$[rsp], 0
  000de	0f 84 af 00 00
	00		 je	 $LN11@set_model
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR m2$[rsp]
  000f2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000f6	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000f9	0f 84 94 00 00
	00		 je	 $LN11@set_model

; 397  :     {
; 398  :         if ( strlen(m2) == 0 || strcmp(m2, "=") == 0)

  000ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR m2$[rsp]
  00104	e8 00 00 00 00	 call	 strlen
  00109	48 85 c0	 test	 rax, rax
  0010c	74 15		 je	 SHORT $LN15@set_model
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159261
  00115	48 8b 4c 24 58	 mov	 rcx, QWORD PTR m2$[rsp]
  0011a	e8 00 00 00 00	 call	 strcmp
  0011f	85 c0		 test	 eax, eax
  00121	75 4a		 jne	 SHORT $LN13@set_model
$LN15@set_model:

; 399  :             memcpy(gsysinfo.modelcapa, gsysinfo.model[0] ? gsysinfo.model : dflt_model, sizeof(gsysinfo.modelcapa));

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	48 6b c0 00	 imul	 rax, rax, 0
  0012c	48 8d 0d 24 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+36
  00133	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00137	85 c0		 test	 eax, eax
  00139	74 0e		 je	 SHORT $LN33@set_model
  0013b	48 8d 05 24 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+36
  00142	48 89 44 24 20	 mov	 QWORD PTR tv147[rsp], rax
  00147	eb 0c		 jmp	 SHORT $LN34@set_model
$LN33@set_model:
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dflt_model
  00150	48 89 44 24 20	 mov	 QWORD PTR tv147[rsp], rax
$LN34@set_model:
  00155	48 8d 05 34 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+52
  0015c	48 8b f8	 mov	 rdi, rax
  0015f	48 8b 74 24 20	 mov	 rsi, QWORD PTR tv147[rsp]
  00164	b9 10 00 00 00	 mov	 ecx, 16
  00169	f3 a4		 rep movsb
  0016b	eb 24		 jmp	 SHORT $LN14@set_model
$LN13@set_model:

; 400  :         else if ( copy_stringz_to_ebcdic(gsysinfo.modelcapa, sizeof(gsysinfo.modelcapa), m2) <= 0) return 2;

  0016d	4c 8b 44 24 58	 mov	 r8, QWORD PTR m2$[rsp]
  00172	ba 10 00 00 00	 mov	 edx, 16
  00177	48 8d 0d 34 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+52
  0017e	e8 00 00 00 00	 call	 copy_stringz_to_ebcdic
  00183	85 c0		 test	 eax, eax
  00185	7f 0a		 jg	 SHORT $LN16@set_model
  00187	b8 02 00 00 00	 mov	 eax, 2
  0018c	e9 5b 01 00 00	 jmp	 $LN1@set_model
$LN16@set_model:
$LN14@set_model:

; 401  :     }

  00191	eb 0f		 jmp	 SHORT $LN12@set_model
$LN11@set_model:

; 402  :     else if ( m2 == NULL )

  00193	48 83 7c 24 58
	00		 cmp	 QWORD PTR m2$[rsp], 0
  00199	75 07		 jne	 SHORT $LN17@set_model

; 403  :         return 0;

  0019b	33 c0		 xor	 eax, eax
  0019d	e9 4a 01 00 00	 jmp	 $LN1@set_model
$LN17@set_model:
$LN12@set_model:

; 404  : 
; 405  :     /* model-perm may be binary zero */
; 406  :     if ( m3 != NULL && m3[0] != '*' )

  001a2	48 83 7c 24 60
	00		 cmp	 QWORD PTR m3$[rsp], 0
  001a8	0f 84 93 00 00
	00		 je	 $LN18@set_model
  001ae	b8 01 00 00 00	 mov	 eax, 1
  001b3	48 6b c0 00	 imul	 rax, rax, 0
  001b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR m3$[rsp]
  001bc	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  001c0	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  001c3	74 7c		 je	 SHORT $LN18@set_model

; 407  :     {
; 408  :         if ( strlen(m3) == 0 )

  001c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR m3$[rsp]
  001ca	e8 00 00 00 00	 call	 strlen
  001cf	48 85 c0	 test	 rax, rax
  001d2	75 15		 jne	 SHORT $LN20@set_model

; 409  :             memset(gsysinfo.modelperm, 0, sizeof(gsysinfo.modelperm));

  001d4	48 8d 05 44 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+68
  001db	48 8b f8	 mov	 rdi, rax
  001de	33 c0		 xor	 eax, eax
  001e0	b9 10 00 00 00	 mov	 ecx, 16
  001e5	f3 aa		 rep stosb
  001e7	eb 56		 jmp	 SHORT $LN21@set_model
$LN20@set_model:

; 410  :         else if ( strcmp(m3, "=") == 0)

  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159270
  001f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR m3$[rsp]
  001f5	e8 00 00 00 00	 call	 strcmp
  001fa	85 c0		 test	 eax, eax
  001fc	75 1d		 jne	 SHORT $LN22@set_model

; 411  :             memcpy(gsysinfo.modelperm, gsysinfo.modelcapa, sizeof(gsysinfo.modelperm));

  001fe	48 8d 05 44 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+68
  00205	48 8d 0d 34 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+52
  0020c	48 8b f8	 mov	 rdi, rax
  0020f	48 8b f1	 mov	 rsi, rcx
  00212	b9 10 00 00 00	 mov	 ecx, 16
  00217	f3 a4		 rep movsb
  00219	eb 24		 jmp	 SHORT $LN23@set_model
$LN22@set_model:

; 412  :         else if ( copy_stringz_to_ebcdic(gsysinfo.modelperm, sizeof(gsysinfo.modelperm), m3) <= 0 ) return 3;

  0021b	4c 8b 44 24 60	 mov	 r8, QWORD PTR m3$[rsp]
  00220	ba 10 00 00 00	 mov	 edx, 16
  00225	48 8d 0d 44 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+68
  0022c	e8 00 00 00 00	 call	 copy_stringz_to_ebcdic
  00231	85 c0		 test	 eax, eax
  00233	7f 0a		 jg	 SHORT $LN24@set_model
  00235	b8 03 00 00 00	 mov	 eax, 3
  0023a	e9 ad 00 00 00	 jmp	 $LN1@set_model
$LN24@set_model:
$LN23@set_model:
$LN21@set_model:

; 413  :     }

  0023f	eb 0f		 jmp	 SHORT $LN19@set_model
$LN18@set_model:

; 414  :     else if ( m3 == NULL )

  00241	48 83 7c 24 60
	00		 cmp	 QWORD PTR m3$[rsp], 0
  00247	75 07		 jne	 SHORT $LN25@set_model

; 415  :         return 0;

  00249	33 c0		 xor	 eax, eax
  0024b	e9 9c 00 00 00	 jmp	 $LN1@set_model
$LN25@set_model:
$LN19@set_model:

; 416  : 
; 417  :     /* model-temp may be binary zero */
; 418  :     if ( m4 != NULL && m4[0] != '*' )

  00250	48 83 7c 24 68
	00		 cmp	 QWORD PTR m4$[rsp], 0
  00256	0f 84 8e 00 00
	00		 je	 $LN26@set_model
  0025c	b8 01 00 00 00	 mov	 eax, 1
  00261	48 6b c0 00	 imul	 rax, rax, 0
  00265	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m4$[rsp]
  0026a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0026e	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00271	74 77		 je	 SHORT $LN26@set_model

; 419  :     {
; 420  :         if ( strlen(m4) == 0 )

  00273	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m4$[rsp]
  00278	e8 00 00 00 00	 call	 strlen
  0027d	48 85 c0	 test	 rax, rax
  00280	75 15		 jne	 SHORT $LN27@set_model

; 421  :             memset(gsysinfo.modeltemp, 0, sizeof(gsysinfo.modeltemp));

  00282	48 8d 05 54 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+84
  00289	48 8b f8	 mov	 rdi, rax
  0028c	33 c0		 xor	 eax, eax
  0028e	b9 10 00 00 00	 mov	 ecx, 16
  00293	f3 aa		 rep stosb
  00295	eb 53		 jmp	 SHORT $LN28@set_model
$LN27@set_model:

; 422  :         else if ( strcmp(m4, "=") == 0)

  00297	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159278
  0029e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m4$[rsp]
  002a3	e8 00 00 00 00	 call	 strcmp
  002a8	85 c0		 test	 eax, eax
  002aa	75 1d		 jne	 SHORT $LN29@set_model

; 423  :             memcpy(gsysinfo.modeltemp, gsysinfo.modelperm, sizeof(gsysinfo.modeltemp));

  002ac	48 8d 05 54 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+84
  002b3	48 8d 0d 44 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+68
  002ba	48 8b f8	 mov	 rdi, rax
  002bd	48 8b f1	 mov	 rsi, rcx
  002c0	b9 10 00 00 00	 mov	 ecx, 16
  002c5	f3 a4		 rep movsb
  002c7	eb 21		 jmp	 SHORT $LN30@set_model
$LN29@set_model:

; 424  :         else if ( copy_stringz_to_ebcdic(gsysinfo.modeltemp, sizeof(gsysinfo.modeltemp), m4) <= 0 ) return 4;

  002c9	4c 8b 44 24 68	 mov	 r8, QWORD PTR m4$[rsp]
  002ce	ba 10 00 00 00	 mov	 edx, 16
  002d3	48 8d 0d 54 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+84
  002da	e8 00 00 00 00	 call	 copy_stringz_to_ebcdic
  002df	85 c0		 test	 eax, eax
  002e1	7f 07		 jg	 SHORT $LN31@set_model
  002e3	b8 04 00 00 00	 mov	 eax, 4
  002e8	eb 02		 jmp	 SHORT $LN1@set_model
$LN31@set_model:
$LN30@set_model:
$LN28@set_model:
$LN26@set_model:

; 425  :     }
; 426  : //  else if ( m4 == NULL )      // uncomment test if anything else is done
; 427  : //      return 0;
; 428  : 
; 429  :     return 0;

  002ea	33 c0		 xor	 eax, eax
$LN1@set_model:

; 430  : }

  002ec	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002f0	5f		 pop	 rdi
  002f1	5e		 pop	 rsi
  002f2	c3		 ret	 0
set_model ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_plant PROC

; 352  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 353  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_plant

; 354  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_plant:

; 355  : 
; 356  :     ebcdic_to_stringz_return(gsysinfo.plant);

  00014	41 b9 04 00 00
	00		 mov	 r9d, 4
  0001a	4c 8d 05 20 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+32
  00021	ba 05 00 00 00	 mov	 edx, 5
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_plant@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_plant@@9@9

; 357  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_plant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
n$1 = 32
temp$2 = 36
i$3 = 40
name$ = 64
set_plant PROC

; 335  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 336  :     if (gsysinfo_init_flg == FALSE )

  0000a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00011	75 07		 jne	 SHORT $LN5@set_plant

; 337  :         get_gsysinfo(NULL);

  00013	33 c9		 xor	 ecx, ecx
  00015	e8 00 00 00 00	 call	 get_gsysinfo
$LN5@set_plant:

; 338  : 
; 339  :     set_stsi_and_return(gsysinfo.plant, name, default_plant);

  0001a	48 8d 44 24 24	 lea	 rax, QWORD PTR temp$2[rsp]
  0001f	48 8b f8	 mov	 rdi, rax
  00022	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00027	b9 04 00 00 00	 mov	 ecx, 4
  0002c	f3 aa		 rep stosb
  0002e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$3[rsp], 0
  00037	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  0003f	eb 0d		 jmp	 SHORT $LN4@set_plant
$LN2@set_plant:
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR i$3[rsp]
  00046	48 ff c0	 inc	 rax
  00049	48 89 44 24 28	 mov	 QWORD PTR i$3[rsp], rax
$LN4@set_plant:
  0004e	48 83 7c 24 40
	00		 cmp	 QWORD PTR name$[rsp], 0
  00054	74 7d		 je	 SHORT $LN3@set_plant
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  0005b	e8 00 00 00 00	 call	 strlen
  00060	48 39 44 24 28	 cmp	 QWORD PTR i$3[rsp], rax
  00065	73 6c		 jae	 SHORT $LN3@set_plant
  00067	48 83 7c 24 28
	04		 cmp	 QWORD PTR i$3[rsp], 4
  0006d	73 64		 jae	 SHORT $LN3@set_plant
  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$3[rsp]
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00082	8b c8		 mov	 ecx, eax
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0008a	85 c0		 test	 eax, eax
  0008c	74 39		 je	 SHORT $LN6@set_plant
  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$3[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00098	48 03 c8	 add	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a1	8b c8		 mov	 ecx, eax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000a9	0f b6 c8	 movzx	 ecx, al
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  000b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$3[rsp]
  000b7	88 44 0c 24	 mov	 BYTE PTR temp$2[rsp+rcx], al
  000bb	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  000bf	ff c0		 inc	 eax
  000c1	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
  000c5	eb 07		 jmp	 SHORT $LN7@set_plant
$LN6@set_plant:
  000c7	b8 ff ff ff ff	 mov	 eax, -1
  000cc	eb 28		 jmp	 SHORT $LN1@set_plant
$LN7@set_plant:
  000ce	e9 6e ff ff ff	 jmp	 $LN2@set_plant
$LN3@set_plant:
  000d3	83 7c 24 20 00	 cmp	 DWORD PTR n$1[rsp], 0
  000d8	7e 0c		 jle	 SHORT $LN8@set_plant
  000da	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  000de	89 05 20 00 00
	00		 mov	 DWORD PTR gsysinfo+32, eax
  000e4	eb 0c		 jmp	 SHORT $LN9@set_plant
$LN8@set_plant:
  000e6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_plant
  000ec	89 05 20 00 00
	00		 mov	 DWORD PTR gsysinfo+32, eax
$LN9@set_plant:
  000f2	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
$LN1@set_plant:

; 340  : }

  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
set_plant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_manufacturer PROC

; 321  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 322  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_manufa

; 323  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_manufa:

; 324  : 
; 325  :     ebcdic_to_stringz_return(gsysinfo.manufact);

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	4c 8d 05 10 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+16
  00021	ba 11 00 00 00	 mov	 edx, 17
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_manufacturer@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_manufacturer@@9@9

; 326  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_manufacturer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
n$1 = 32
i$2 = 40
temp$3 = 48
__$ArrayPad$ = 64
name$ = 112
set_manufacturer PROC

; 303  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 304  :     if (gsysinfo_init_flg == FALSE )

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00021	75 07		 jne	 SHORT $LN5@set_manufa

; 305  :         get_gsysinfo(NULL);

  00023	33 c9		 xor	 ecx, ecx
  00025	e8 00 00 00 00	 call	 get_gsysinfo
$LN5@set_manufa:

; 306  : 
; 307  :     set_stsi_and_return(gsysinfo.manufact, name, default_manufact);

  0002a	48 8d 44 24 30	 lea	 rax, QWORD PTR temp$3[rsp]
  0002f	48 8b f8	 mov	 rdi, rax
  00032	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00037	b9 10 00 00 00	 mov	 ecx, 16
  0003c	f3 aa		 rep stosb
  0003e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$2[rsp], 0
  00047	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  0004f	eb 0d		 jmp	 SHORT $LN4@set_manufa
$LN2@set_manufa:
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR i$2[rsp]
  00056	48 ff c0	 inc	 rax
  00059	48 89 44 24 28	 mov	 QWORD PTR i$2[rsp], rax
$LN4@set_manufa:
  0005e	48 83 7c 24 70
	00		 cmp	 QWORD PTR name$[rsp], 0
  00064	74 7d		 je	 SHORT $LN3@set_manufa
  00066	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  0006b	e8 00 00 00 00	 call	 strlen
  00070	48 39 44 24 28	 cmp	 QWORD PTR i$2[rsp], rax
  00075	73 6c		 jae	 SHORT $LN3@set_manufa
  00077	48 83 7c 24 28
	10		 cmp	 QWORD PTR i$2[rsp], 16
  0007d	73 64		 jae	 SHORT $LN3@set_manufa
  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$2[rsp]
  00084	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  00089	48 03 c8	 add	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00092	8b c8		 mov	 ecx, eax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0009a	85 c0		 test	 eax, eax
  0009c	74 39		 je	 SHORT $LN6@set_manufa
  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR i$2[rsp]
  000a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b1	8b c8		 mov	 ecx, eax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000b9	0f b6 c8	 movzx	 ecx, al
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$2[rsp]
  000c7	88 44 0c 30	 mov	 BYTE PTR temp$3[rsp+rcx], al
  000cb	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  000cf	ff c0		 inc	 eax
  000d1	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
  000d5	eb 07		 jmp	 SHORT $LN7@set_manufa
$LN6@set_manufa:
  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	eb 46		 jmp	 SHORT $LN1@set_manufa
$LN7@set_manufa:
  000de	e9 6e ff ff ff	 jmp	 $LN2@set_manufa
$LN3@set_manufa:
  000e3	83 7c 24 20 00	 cmp	 DWORD PTR n$1[rsp], 0
  000e8	7e 1b		 jle	 SHORT $LN8@set_manufa
  000ea	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+16
  000f1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR temp$3[rsp]
  000f6	48 8b f8	 mov	 rdi, rax
  000f9	48 8b f1	 mov	 rsi, rcx
  000fc	b9 10 00 00 00	 mov	 ecx, 16
  00101	f3 a4		 rep movsb
  00103	eb 1b		 jmp	 SHORT $LN9@set_manufa
$LN8@set_manufa:
  00105	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+16
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:default_manufact
  00113	48 8b f8	 mov	 rdi, rax
  00116	48 8b f1	 mov	 rsi, rcx
  00119	b9 10 00 00 00	 mov	 ecx, 16
  0011e	f3 a4		 rep movsb
$LN9@set_manufa:
  00120	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
$LN1@set_manufa:

; 308  : }

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00129	48 33 cc	 xor	 rcx, rsp
  0012c	e8 00 00 00 00	 call	 __security_check_cookie
  00131	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00135	5f		 pop	 rdi
  00136	5e		 pop	 rsi
  00137	c3		 ret	 0
set_manufacturer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
str_lparname PROC

; 288  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 289  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN2@str_lparna

; 290  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@str_lparna:

; 291  : 
; 292  :     ebcdic_to_stringz_return(gsysinfo.lparname);

  00014	41 b9 08 00 00
	00		 mov	 r9d, 8
  0001a	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:gsysinfo+8
  00021	ba 09 00 00 00	 mov	 edx, 9
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?result@?2??str_lparname@@9@9
  0002d	e8 00 00 00 00	 call	 copy_ebcdic_to_stringz
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_lparname@@9@9

; 293  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
str_lparname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 48
get_lparname PROC

; 278  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 279  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_lparna

; 280  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_lparna:

; 281  : 
; 282  :     memcpy(dest, gsysinfo.lparname, sizeof(gsysinfo.lparname));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$[rsp]
  0001e	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo+8
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 283  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_lparname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
i$1 = 32
tv71 = 40
n$2 = 48
name$ = 80
set_lparname PROC

; 269  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 270  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN8@set_lparna

; 271  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN8@set_lparna:

; 272  : 
; 273  :     set_static(gsysinfo.lparname, name);

  00019	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$1[rsp], 0
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00027	e8 00 00 00 00	 call	 strlen
  0002c	48 83 f8 08	 cmp	 rax, 8
  00030	73 11		 jae	 SHORT $LN13@set_lparna
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00037	e8 00 00 00 00	 call	 strlen
  0003c	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  00041	eb 09		 jmp	 SHORT $LN14@set_lparna
$LN13@set_lparna:
  00043	48 c7 44 24 28
	08 00 00 00	 mov	 QWORD PTR tv71[rsp], 8
$LN14@set_lparna:
  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR tv71[rsp]
  00051	48 89 44 24 30	 mov	 QWORD PTR n$2[rsp], rax
  00056	48 83 7c 24 50
	00		 cmp	 QWORD PTR name$[rsp], 0
  0005c	0f 84 81 00 00
	00		 je	 $LN9@set_lparna
  00062	eb 0d		 jmp	 SHORT $LN4@set_lparna
$LN2@set_lparna:
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  00069	48 ff c0	 inc	 rax
  0006c	48 89 44 24 20	 mov	 QWORD PTR i$1[rsp], rax
$LN4@set_lparna:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR n$2[rsp]
  00076	48 39 44 24 20	 cmp	 QWORD PTR i$1[rsp], rax
  0007b	73 66		 jae	 SHORT $LN3@set_lparna
  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00090	8b c8		 mov	 ecx, eax
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00098	85 c0		 test	 eax, eax
  0009a	74 35		 je	 SHORT $LN10@set_lparna
  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  000a6	48 03 c8	 add	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000af	8b c8		 mov	 ecx, eax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000b7	0f b6 c8	 movzx	 ecx, al
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  000c0	48 8d 0d 08 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo+8
  000c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$1[rsp]
  000cc	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  000cf	eb 10		 jmp	 SHORT $LN11@set_lparna
$LN10@set_lparna:
  000d1	48 8d 05 08 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+8
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$1[rsp]
  000dd	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
$LN11@set_lparna:
  000e1	eb 81		 jmp	 SHORT $LN2@set_lparna
$LN3@set_lparna:
$LN9@set_lparna:
  000e3	eb 0d		 jmp	 SHORT $LN7@set_lparna
$LN5@set_lparna:
  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  000ea	48 ff c0	 inc	 rax
  000ed	48 89 44 24 20	 mov	 QWORD PTR i$1[rsp], rax
$LN7@set_lparna:
  000f2	48 83 7c 24 20
	08		 cmp	 QWORD PTR i$1[rsp], 8
  000f8	73 12		 jae	 SHORT $LN6@set_lparna
  000fa	48 8d 05 08 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo+8
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$1[rsp]
  00106	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
  0010a	eb d9		 jmp	 SHORT $LN5@set_lparna
$LN6@set_lparna:

; 274  : }

  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
set_lparname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
i$1 = 32
$T2 = 40
$T3 = 48
str_loadparm PROC

; 254  : {

$LN14:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 255  :     if (gsysinfo_init_flg == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  0000b	75 07		 jne	 SHORT $LN8@str_loadpa

; 256  :         get_gsysinfo(NULL);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 get_gsysinfo
$LN8@str_loadpa:

; 257  : 
; 258  :     ebcdic_to_stringz_allow_return(gsysinfo.loadparm);

  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	48 6b c0 08	 imul	 rax, rax, 8
  0001d	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00022	48 83 7c 24 28
	09		 cmp	 QWORD PTR $T2[rsp], 9
  00028	73 02		 jae	 SHORT $LN10@str_loadpa
  0002a	eb 05		 jmp	 SHORT $LN11@str_loadpa
$LN10@str_loadpa:
  0002c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@str_loadpa:
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_loadparm@@9@9
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  0003d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  00041	c7 44 24 20 07
	00 00 00	 mov	 DWORD PTR i$1[rsp], 7
  00049	eb 0a		 jmp	 SHORT $LN4@str_loadpa
$LN2@str_loadpa:
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004f	ff c8		 dec	 eax
  00051	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@str_loadpa:
  00055	83 7c 24 20 00	 cmp	 DWORD PTR i$1[rsp], 0
  0005a	7c 40		 jl	 SHORT $LN3@str_loadpa
  0005c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo
  00068	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0006f	75 2b		 jne	 SHORT $LN3@str_loadpa
  00071	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00076	48 89 44 24 30	 mov	 QWORD PTR $T3[rsp], rax
  0007b	48 83 7c 24 30
	09		 cmp	 QWORD PTR $T3[rsp], 9
  00081	73 02		 jae	 SHORT $LN12@str_loadpa
  00083	eb 05		 jmp	 SHORT $LN13@str_loadpa
$LN12@str_loadpa:
  00085	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@str_loadpa:
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_loadparm@@9@9
  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T3[rsp]
  00096	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  0009a	eb af		 jmp	 SHORT $LN2@str_loadpa
$LN3@str_loadpa:
  0009c	eb 0a		 jmp	 SHORT $LN7@str_loadpa
$LN5@str_loadpa:
  0009e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000a2	ff c8		 dec	 eax
  000a4	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@str_loadpa:
  000a8	83 7c 24 20 00	 cmp	 DWORD PTR i$1[rsp], 0
  000ad	7c 27		 jl	 SHORT $LN6@str_loadpa
  000af	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo
  000bb	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000c5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?result@?2??str_loadparm@@9@9
  000d1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000d4	eb c8		 jmp	 SHORT $LN5@str_loadpa
$LN6@str_loadpa:
  000d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?result@?2??str_loadparm@@9@9
$LN9@str_loadpa:

; 259  : }

  000dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e1	c3		 ret	 0
str_loadparm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
dest$ = 48
get_loadparm PROC

; 245  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 246  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN2@get_loadpa

; 247  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN2@get_loadpa:

; 248  : 
; 249  :     memcpy(dest, gsysinfo.loadparm, sizeof(gsysinfo.loadparm));

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$[rsp]
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gsysinfo
  00025	48 89 08	 mov	 QWORD PTR [rax], rcx

; 250  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
get_loadparm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadparm.c
_TEXT	SEGMENT
i$1 = 32
tv71 = 40
n$2 = 48
name$ = 80
set_loadparm PROC

; 236  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 237  :     if (gsysinfo_init_flg == FALSE )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gsysinfo_init_flg, 0
  00010	75 07		 jne	 SHORT $LN8@set_loadpa

; 238  :         get_gsysinfo(NULL);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 get_gsysinfo
$LN8@set_loadpa:

; 239  : 
; 240  :     set_static(gsysinfo.loadparm, name);

  00019	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$1[rsp], 0
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00027	e8 00 00 00 00	 call	 strlen
  0002c	48 83 f8 08	 cmp	 rax, 8
  00030	73 11		 jae	 SHORT $LN13@set_loadpa
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00037	e8 00 00 00 00	 call	 strlen
  0003c	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  00041	eb 09		 jmp	 SHORT $LN14@set_loadpa
$LN13@set_loadpa:
  00043	48 c7 44 24 28
	08 00 00 00	 mov	 QWORD PTR tv71[rsp], 8
$LN14@set_loadpa:
  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR tv71[rsp]
  00051	48 89 44 24 30	 mov	 QWORD PTR n$2[rsp], rax
  00056	48 83 7c 24 50
	00		 cmp	 QWORD PTR name$[rsp], 0
  0005c	0f 84 81 00 00
	00		 je	 $LN9@set_loadpa
  00062	eb 0d		 jmp	 SHORT $LN4@set_loadpa
$LN2@set_loadpa:
  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  00069	48 ff c0	 inc	 rax
  0006c	48 89 44 24 20	 mov	 QWORD PTR i$1[rsp], rax
$LN4@set_loadpa:
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR n$2[rsp]
  00076	48 39 44 24 20	 cmp	 QWORD PTR i$1[rsp], rax
  0007b	73 66		 jae	 SHORT $LN3@set_loadpa
  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00090	8b c8		 mov	 ecx, eax
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00098	85 c0		 test	 eax, eax
  0009a	74 35		 je	 SHORT $LN10@set_loadpa
  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR name$[rsp]
  000a6	48 03 c8	 add	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000af	8b c8		 mov	 ecx, eax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000b7	0f b6 c8	 movzx	 ecx, al
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gsysinfo
  000c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$1[rsp]
  000cc	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  000cf	eb 10		 jmp	 SHORT $LN11@set_loadpa
$LN10@set_loadpa:
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$1[rsp]
  000dd	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
$LN11@set_loadpa:
  000e1	eb 81		 jmp	 SHORT $LN2@set_loadpa
$LN3@set_loadpa:
$LN9@set_loadpa:
  000e3	eb 0d		 jmp	 SHORT $LN7@set_loadpa
$LN5@set_loadpa:
  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR i$1[rsp]
  000ea	48 ff c0	 inc	 rax
  000ed	48 89 44 24 20	 mov	 QWORD PTR i$1[rsp], rax
$LN7@set_loadpa:
  000f2	48 83 7c 24 20
	08		 cmp	 QWORD PTR i$1[rsp], 8
  000f8	73 12		 jae	 SHORT $LN6@set_loadpa
  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gsysinfo
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$1[rsp]
  00106	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
  0010a	eb d9		 jmp	 SHORT $LN5@set_loadpa
$LN6@set_loadpa:

; 241  : }

  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
set_loadparm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
END
