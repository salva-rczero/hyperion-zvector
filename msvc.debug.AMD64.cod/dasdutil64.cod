; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	open_ckd64_image
PUBLIC	open_fba64_image
PUBLIC	create_ckd64
PUBLIC	create_fba64
PUBLIC	create_compressed_fba64
EXTRN	__imp_isdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_convert_to_ebcdic:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	dasd_lookup:PROC
EXTRN	cckd_def_opt_bigend:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	gen_dasd_serial:PROC
EXTRN	build_vol1:PROC
EXTRN	open_ckd_image:PROC
EXTRN	is_verbose_util:PROC
EXTRN	next_util_devnum:PROC
EXTRN	dh_devid_str:PROC
EXTRN	dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	ckd_dasd_device_hndinfo:BYTE
EXTRN	fba_dasd_device_hndinfo:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG169234 DB	01H DUP (?)
$SG169260 DB	01H DUP (?)
$SG169338 DB	01H DUP (?)
$SG169512 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$open_ckd64_image DD imagerel $LN38
	DD	imagerel $LN38+3203
	DD	imagerel $unwind$open_ckd64_image
$pdata$open_fba64_image DD imagerel $LN15
	DD	imagerel $LN15+1488
	DD	imagerel $unwind$open_fba64_image
$pdata$create_ckd64 DD imagerel $LN33
	DD	imagerel $LN33+2364
	DD	imagerel $unwind$create_ckd64
$pdata$create_fba64 DD imagerel $LN28
	DD	imagerel $LN28+2423
	DD	imagerel $unwind$create_fba64
$pdata$create_compressed_fba64 DD imagerel $LN37
	DD	imagerel $LN37+3917
	DD	imagerel $unwind$create_compressed_fba64
$pdata$create_ckd64_file DD imagerel create_ckd64_file
	DD	imagerel create_ckd64_file+8045
	DD	imagerel $unwind$create_ckd64_file
pdata	ENDS
_DATA	SEGMENT
$SG168700 DB	'calloc(1,%d)', 00H
	ORG $+3
$SG168701 DB	'E', 00H
	ORG $+2
$SG168715 DB	'_1', 00H
	ORG $+1
$SG168702 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG168718 DB	'_1', 00H
	ORG $+1
$SG168703 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168721 DB	'open()', 00H
	ORG $+1
$SG168722 DB	'E', 00H
	ORG $+2
$SG168704 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168723 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG168730 DB	'E', 00H
	ORG $+2
$SG168724 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168729 DB	'read()', 00H
	ORG $+1
$SG168737 DB	'E', 00H
	ORG $+2
$SG168725 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168731 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG168742 DB	'E', 00H
	ORG $+2
$SG168732 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168746 DB	'%4.4X', 00H
	ORG $+2
$SG168749 DB	'(null)', 00H
	ORG $+1
$SG168750 DB	'E', 00H
	ORG $+2
$SG168733 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168738 DB	'HHC00406%s %1d:%04X CKD file %s: ckd header invalid', 0aH
	DB	00H
	ORG $+3
$SG168739 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168756 DB	'I', 00H
	ORG $+2
$SG168740 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168743 DB	'HHC00451%s %1d:%04X CKD file %s: DASD table entry not fo'
	DB	'und for devtype 0x%2.2X', 0aH, 00H
	ORG $+3
$SG168791 DB	'E', 00H
	ORG $+2
$SG168744 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168797 DB	'E', 00H
	ORG $+2
$SG168745 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168751 DB	'HHC00452%s %1d:%04X CKD file %s: initialization failed', 0aH
	DB	00H
$SG168752 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168803 DB	'(null)', 00H
	ORG $+1
$SG168804 DB	'E', 00H
	ORG $+2
$SG168753 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168757 DB	'HHC00453%s %1d:%04X CKD file %s: heads %d trklen %d', 0aH
	DB	00H
	ORG $+3
$SG168758 DB	'open_ckd64_image', 00H
	ORG $+3
$SG168809 DB	'I', 00H
	ORG $+2
$SG168759 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168790 DB	'calloc(1,%d)', 00H
	ORG $+3
$SG168792 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169035 DB	'E', 00H
	ORG $+2
$SG168793 DB	'open_fba64_image', 00H
	ORG $+3
$SG169047 DB	'open()', 00H
	ORG $+1
$SG169048 DB	'E', 00H
	ORG $+2
$SG168794 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168799 DB	'open_fba64_image', 00H
	ORG $+7
$SG168798 DB	'HHC00451%s %1d:%04X CKD file %s: DASD table entry not fo'
	DB	'und for devtype 0x%2.2X', 0aH, 00H
	ORG $+3
$SG169057 DB	'E', 00H
	ORG $+2
$SG168800 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168805 DB	'HHC00452%s %1d:%04X CKD file %s: initialization failed', 0aH
	DB	00H
$SG168806 DB	'open_fba64_image', 00H
	ORG $+3
$SG169066 DB	'E', 00H
	ORG $+2
$SG168807 DB	'dasdutil64.c', 00H
	ORG $+3
$SG168810 DB	'HHC00454%s %1d:%04X FBA file %s: sectors %d size %d', 0aH
	DB	00H
	ORG $+3
$SG168811 DB	'open_fba64_image', 00H
	ORG $+3
$SG169072 DB	'E', 00H
	ORG $+2
$SG168812 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169037 DB	'create_ckd64_file', 00H
	ORG $+6
$SG169036 DB	'HHC00415%s %1d:%04X CKD file %s: device type %4.4X not f'
	DB	'ound in dasd table', 0aH, 00H
$SG169079 DB	'E', 00H
	ORG $+2
$SG169038 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169049 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169086 DB	'E', 00H
	ORG $+2
$SG169050 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169114 DB	'E', 00H
	ORG $+2
$SG169051 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169055 DB	'incomplete', 00H
	ORG $+1
$SG169123 DB	'E', 00H
	ORG $+2
$SG169056 DB	'write()', 00H
$SG169058 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169130 DB	'E', 00H
	ORG $+2
$SG169059 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169136 DB	'E', 00H
	ORG $+2
$SG169060 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169064 DB	'incomplete', 00H
	ORG $+1
$SG169143 DB	'E', 00H
	ORG $+2
$SG169065 DB	'write()', 00H
$SG169067 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169149 DB	'E', 00H
	ORG $+2
$SG169068 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169154 DB	'I', 00H
	ORG $+2
$SG169069 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169071 DB	'calloc(%d,%d)', 00H
	ORG $+2
$SG169073 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169227 DB	'W', 00H
	ORG $+2
$SG169074 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169236 DB	'W', 00H
	ORG $+2
$SG169075 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169077 DB	'incomplete', 00H
	ORG $+1
$SG169245 DB	'I', 00H
	ORG $+2
$SG169078 DB	'write()', 00H
$SG169080 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169250 DB	'E', 00H
	ORG $+2
$SG169081 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169243 DB	'option', 00H
	ORG $+1
$SG169256 DB	'E', 00H
	ORG $+2
$SG169082 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169084 DB	'incomplete', 00H
	ORG $+1
$SG169261 DB	'I', 00H
	ORG $+2
$SG169085 DB	'write()', 00H
$SG169087 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169271 DB	'_1', 00H
	ORG $+1
$SG169088 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169274 DB	'_1', 00H
	ORG $+1
$SG169089 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169095 DB	'CYL=%u', 0aH, 00H
$SG169096 DB	'Writing cylinder %u', 0dH, 00H
	ORG $+3
$SG169112 DB	'incomplete', 00H
	ORG $+1
$SG169323 DB	'W', 00H
	ORG $+2
$SG169113 DB	'write()', 00H
$SG169115 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169328 DB	'E', 00H
	ORG $+2
$SG169116 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169327 DB	'sector', 00H
	ORG $+1
$SG169334 DB	'E', 00H
	ORG $+2
$SG169117 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169122 DB	'lseek()', 00H
$SG169124 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169339 DB	'I', 00H
	ORG $+2
$SG169125 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169345 DB	'open()', 00H
	ORG $+1
$SG169346 DB	'E', 00H
	ORG $+2
$SG169126 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169128 DB	'incomplete', 00H
	ORG $+1
$SG169352 DB	'I', 00H
	ORG $+2
$SG169129 DB	'write()', 00H
$SG169131 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169358 DB	'E', 00H
	ORG $+2
$SG169132 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169371 DB	'E', 00H
	ORG $+2
$SG169133 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169135 DB	'lseek()', 00H
$SG169137 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169377 DB	'E', 00H
	ORG $+2
$SG169138 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169382 DB	'I', 00H
	ORG $+2
$SG169139 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169141 DB	'incomplete', 00H
	ORG $+1
$SG169501 DB	'E', 00H
	ORG $+2
$SG169142 DB	'write()', 00H
$SG169144 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169508 DB	'E', 00H
	ORG $+2
$SG169145 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169507 DB	'open()', 00H
	ORG $+1
$SG169513 DB	'I', 00H
	ORG $+2
$SG169146 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169148 DB	'close()', 00H
$SG169150 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169520 DB	'E', 00H
	ORG $+2
$SG169151 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169528 DB	'E', 00H
	ORG $+2
$SG169152 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169153 DB	'cylinders', 00H
	ORG $+2
$SG169535 DB	'E', 00H
	ORG $+2
$SG169155 DB	'HHC00471%s %1d:%04X CKD64 file %s: %u %s successfully wr'
	DB	'itten', 0aH, 00H
	ORG $+1
$SG169156 DB	'create_ckd64_file', 00H
	ORG $+2
$SG169542 DB	'E', 00H
	ORG $+2
$SG169157 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169226 DB	'cylinders', 00H
	ORG $+2
$SG169550 DB	'E', 00H
	ORG $+2
$SG169228 DB	'HHC00467%s Maximum %s supported is %u', 0aH, 00H
	ORG $+1
$SG169229 DB	'create_ckd64', 00H
	ORG $+3
$SG169230 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169235 DB	'cylinders', 00H
	ORG $+2
$SG169556 DB	'E', 00H
	ORG $+2
$SG169237 DB	'HHC00466%s Maximum of %u %s in %u 2GB file(s) is support'
	DB	'ed', 0aH, 00H
$SG169563 DB	'E', 00H
	ORG $+2
$SG169238 DB	'create_ckd64', 00H
	ORG $+3
$SG169239 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169242 DB	'related options', 00H
$SG169244 DB	'-lfs%s %s', 00H
	ORG $+2
$SG169569 DB	'E', 00H
	ORG $+2
$SG169246 DB	'HHC00468%s For larger capacity DASD volumes, use %s', 0aH
	DB	00H
	ORG $+3
$SG169247 DB	'create_ckd64', 00H
	ORG $+3
$SG169248 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169249 DB	'cylinder', 00H
	ORG $+7
$SG169252 DB	'create_ckd64', 00H
	ORG $+3
$SG169322 DB	'sectors', 00H
$SG169251 DB	'HHC00461%s %1d:%04X CKD file %s: %s count %u is outside '
	DB	'range %u-%u', 0aH, 00H
	ORG $+3
$SG169253 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169255 DB	'malloc(%u)', 00H
	ORG $+1
$SG169576 DB	'E', 00H
	ORG $+2
$SG169257 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169582 DB	'E', 00H
	ORG $+2
$SG169258 DB	'create_ckd64', 00H
	ORG $+3
$SG169259 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169353 DB	'HHC00475%s This might take a while... Please wait...', 0aH
	DB	00H
	ORG $+2
$SG169262 DB	'HHC00472%s %1d:%04X CKD64 file %s: creating %4.4X volume'
	DB	' %s: %u cyls, %u trks/cyl, %u bytes/track', 0aH, 00H
	ORG $+1
$SG169587 DB	'I', 00H
	ORG $+2
$SG169263 DB	'create_ckd64', 00H
	ORG $+3
$SG169264 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169324 DB	'HHC00521%s Maximum of %u %s in a 2GB file', 0aH, 00H
	ORG $+5
$SG169325 DB	'create_fba64', 00H
	ORG $+3
$SG169326 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169366 DB	'BLK=%u', 0aH, 00H
$SG169329 DB	'HHC00461%s %1d:%04X CKD file %s: %s count %u is outside '
	DB	'range %u-%u', 0aH, 00H
	ORG $+3
$SG169330 DB	'create_fba64', 00H
	ORG $+3
$SG169331 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169333 DB	'malloc(%u)', 00H
	ORG $+5
$SG169335 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169336 DB	'create_fba64', 00H
	ORG $+3
$SG169337 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169367 DB	'Writing sector %u', 0dH, 00H
	ORG $+5
$SG169340 DB	'HHC00473%s %1d:%04X FBA64 file %s: creating %4.4X volume'
	DB	' %s: %u sectors, %u bytes/sector', 0aH, 00H
	ORG $+6
$SG169341 DB	'create_fba64', 00H
	ORG $+3
$SG169342 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169347 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169348 DB	'create_fba64', 00H
	ORG $+3
$SG169349 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169354 DB	'create_fba64', 00H
	ORG $+3
$SG169355 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169357 DB	'ftruncate()', 00H
	ORG $+4
$SG169359 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169360 DB	'create_fba64', 00H
	ORG $+3
$SG169361 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169369 DB	'incomplete', 00H
	ORG $+5
$SG169370 DB	'write()', 00H
$SG169372 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169373 DB	'create_fba64', 00H
	ORG $+3
$SG169374 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169376 DB	'close()', 00H
$SG169378 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169379 DB	'create_fba64', 00H
	ORG $+3
$SG169380 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169381 DB	'sectors', 00H
$SG169383 DB	'HHC00471%s %1d:%04X CKD64 file %s: %u %s successfully wr'
	DB	'itten', 0aH, 00H
	ORG $+1
$SG169384 DB	'create_fba64', 00H
	ORG $+3
$SG169385 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169503 DB	'create_compressed_fba64', 00H
$SG169502 DB	'HHC00464%s %1d:%04X CKD file %s: file size too large: %l'
	DB	'lu [%d]', 0aH, 00H
	ORG $+7
$SG169504 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169509 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169510 DB	'create_compressed_fba64', 00H
$SG169511 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169514 DB	'HHC00474%s %1d:%04X FBA64 file %s: creating %4.4X compre'
	DB	'ssed volume %s: %u sectors, %u bytes/sector', 0aH, 00H
	ORG $+3
$SG169515 DB	'create_compressed_fba64', 00H
$SG169516 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169518 DB	'incomplete', 00H
	ORG $+5
$SG169519 DB	'write()', 00H
$SG169521 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169522 DB	'create_compressed_fba64', 00H
$SG169523 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169526 DB	'incomplete', 00H
	ORG $+5
$SG169527 DB	'write()', 00H
$SG169529 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169530 DB	'create_compressed_fba64', 00H
$SG169531 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169533 DB	'incomplete', 00H
	ORG $+5
$SG169534 DB	'write()', 00H
$SG169536 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169537 DB	'create_compressed_fba64', 00H
$SG169538 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169540 DB	'incomplete', 00H
	ORG $+5
$SG169541 DB	'write()', 00H
$SG169543 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169544 DB	'create_compressed_fba64', 00H
$SG169545 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169548 DB	'incomplete', 00H
	ORG $+5
$SG169549 DB	'write()', 00H
$SG169551 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169552 DB	'create_compressed_fba64', 00H
$SG169553 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169555 DB	'lseek()', 00H
$SG169557 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169558 DB	'create_compressed_fba64', 00H
$SG169559 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169561 DB	'incomplete', 00H
	ORG $+5
$SG169562 DB	'write()', 00H
$SG169564 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169565 DB	'create_compressed_fba64', 00H
$SG169566 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169568 DB	'lseek()', 00H
$SG169570 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169571 DB	'create_compressed_fba64', 00H
$SG169572 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169574 DB	'incomplete', 00H
	ORG $+5
$SG169575 DB	'write()', 00H
$SG169577 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169578 DB	'create_compressed_fba64', 00H
$SG169579 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169581 DB	'close()', 00H
$SG169583 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169584 DB	'create_compressed_fba64', 00H
$SG169585 DB	'dasdutil64.c', 00H
	ORG $+3
$SG169586 DB	'sectors', 00H
$SG169588 DB	'HHC00471%s %1d:%04X CKD64 file %s: %u %s successfully wr'
	DB	'itten', 0aH, 00H
	ORG $+1
$SG169589 DB	'create_compressed_fba64', 00H
$SG169590 DB	'dasdutil64.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_ckd64_file
	DD	02dH
	DD	01f53H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_compressed_fba64
	DD	02cH
	DD	0f34H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_fba64
	DD	026H
	DD	095eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:create_ckd64
	DD	026H
	DD	0923H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_fba64_image
	DD	025H
	DD	05b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_ckd64_image
	DD	025H
	DD	0c6bH
voltbl	ENDS
xdata	SEGMENT
$unwind$open_ckd64_image DD 022d19H
	DD	0db011bH
	DD	imagerel __GSHandlerCheck
	DD	06c0H
$unwind$open_fba64_image DD 022d19H
	DD	021011bH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$create_ckd64 DD 032e19H
	DD	05c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$create_fba64 DD 032e19H
	DD	046011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$create_compressed_fba64 DD 033419H
	DD	022ca0122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	011640H
$unwind$create_ckd64_file DD 043519H
	DD	02db0123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	016c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
r$ = 96
pos$ = 104
rechdr$ = 112
cyl$ = 120
rc$ = 124
fileseq$ = 128
head$ = 132
fd$ = 136
i$ = 140
trk$ = 144
highcyl$ = 148
trks$ = 152
len$ = 156
keylen$ = 160
l1$ = 168
x$ = 176
tv735 = 180
tv768 = 184
tv773 = 188
tv778 = 192
cpos$ = 200
tv71 = 208
n$ = 212
tv1165 = 216
trkhdr$ = 224
rcoff$ = 232
tv255 = 240
tv309 = 248
tv375 = 256
tv404 = 264
ipl1len$ = 272
ipl2len$ = 280
vol1len$ = 288
ckdtab$ = 296
tv988 = 304
tv1044 = 312
tv1125 = 320
tv176 = 328
tv332 = 336
tv476 = 344
tv1017 = 352
tv1098 = 360
tv1147 = 368
cdevhdr$ = 384
devhdr$ = 896
l2$ = 1408
buf$1 = 5504
pathname$ = 5552
__$ArrayPad$ = 5824
fname$ = 5872
fseqn$ = 5880
devtype$ = 5888
heads$ = 5896
trksize$ = 5904
buf$ = 5912
start$ = 5920
end$ = 5928
volcyls$ = 5936
serial$ = 5944
volser$ = 5952
comp$ = 5960
dasdcopy$ = 5968
nullfmt$ = 5976
rawflag$ = 5984
flagECmode$ = 5992
flagMachinecheck$ = 6000
create_ckd64_file PROC

; 377  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 d8 16 00 00	 mov	 eax, 5848		; 000016d8H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 c0
	16 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 378  : int             rc;                     /* Return code               */
; 379  : U64             rcoff;                  /* Return value from lseek() */
; 380  : int             fd;                     /* File descriptor           */
; 381  : int             i;                      /* Loop counter              */
; 382  : int             n;                      /* Loop delimiter            */
; 383  : CKD_DEVHDR      devhdr;                 /* Device header             */
; 384  : CCKD64_DEVHDR   cdevhdr;                /* Compressed device header  */
; 385  : CCKD64_L1ENT   *l1=NULL;                /* -> Primary lookup table   */

  00035	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR l1$[rsp], 0

; 386  : CCKD64_L2ENT    l2[256];                /* Secondary lookup table    */
; 387  : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 388  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 389  : U32             cyl;                    /* Cylinder number           */
; 390  : U32             head;                   /* Head number               */
; 391  : U32             trk = 0;                /* Track number              */

  00041	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR trk$[rsp], 0

; 392  : U32             trks;                   /* Total number tracks       */
; 393  : BYTE            r;                      /* Record number             */
; 394  : BYTE           *pos;                    /* -> Next position in buffer*/
; 395  : U64             cpos = 0;               /* Offset into cckd file     */

  0004c	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR cpos$[rsp], 0

; 396  : u_int           len = 0;                /* Length used in track      */

  00058	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 397  : U64             keylen;                 /* Length of keys            */
; 398  : U64             ipl1len;                /* Length of IPL1 data       */
; 399  : U64             ipl2len;                /* Length of IPL2 data       */
; 400  : U64             vol1len;                /* Length of VOL1 data       */
; 401  : BYTE            fileseq;                /* CKD header sequence number*/
; 402  : U16             highcyl;                /* CKD header high cyl number*/
; 403  : int             x=O_EXCL;               /* Open option               */

  00063	c7 84 24 b0 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H

; 404  : CKDDEV         *ckdtab;                 /* -> CKD table entry        */
; 405  : char            pathname[MAX_PATH];     /* file path in host format  */
; 406  : 
; 407  :     keylen  = IPL1_KEYLEN;              /* (all are the same length) */

  0006e	48 c7 84 24 a0
	00 00 00 04 00
	00 00		 mov	 QWORD PTR keylen$[rsp], 4

; 408  :     ipl1len = IPL1_DATALEN;

  0007a	48 c7 84 24 10
	01 00 00 18 00
	00 00		 mov	 QWORD PTR ipl1len$[rsp], 24

; 409  :     ipl2len = IPL2_DATALEN;

  00086	48 c7 84 24 18
	01 00 00 90 00
	00 00		 mov	 QWORD PTR ipl2len$[rsp], 144 ; 00000090H

; 410  :     vol1len = VOL1_DATALEN;

  00092	48 c7 84 24 20
	01 00 00 50 00
	00 00		 mov	 QWORD PTR vol1len$[rsp], 80 ; 00000050H

; 411  : 
; 412  :     /* Locate the CKD dasd table entry */
; 413  :     ckdtab = dasd_lookup (DASD_CKDDEV, NULL, devtype, 0);

  0009e	0f b7 84 24 00
	17 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	44 8b c0	 mov	 r8d, eax
  000ac	33 d2		 xor	 edx, edx
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	e8 00 00 00 00	 call	 dasd_lookup
  000b8	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR ckdtab$[rsp], rax

; 414  :     if (ckdtab == NULL)

  000c0	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR ckdtab$[rsp], 0
  000c9	0f 85 8a 00 00
	00		 jne	 $LN17@create_ckd

; 415  :     {
; 416  :         FWRMSG( stderr, HHC00415, "E", 0, 0, fname, devtype );

  000cf	0f b7 84 24 00
	17 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  000d7	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  000de	b9 02 00 00 00	 mov	 ecx, 2
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e9	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  000f0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000f4	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00101	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0010a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169035
  0011a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169036
  00126	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00130	41 b9 03 00 00
	00		 mov	 r9d, 3
  00136	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169037
  0013d	ba a0 01 00 00	 mov	 edx, 416		; 000001a0H
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169038
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 417  :         return -1;

  0014f	b8 ff ff ff ff	 mov	 eax, -1
  00154	e9 fa 1d 00 00	 jmp	 $LN1@create_ckd
$LN17@create_ckd:

; 418  :     }
; 419  : 
; 420  :     /* Set file sequence number to zero if this is the only file */
; 421  :     if (fseqn == 1 && end + 1 == volcyls)

  00159	0f b6 84 24 f8
	16 00 00	 movzx	 eax, BYTE PTR fseqn$[rsp]
  00161	83 f8 01	 cmp	 eax, 1
  00164	75 1c		 jne	 SHORT $LN18@create_ckd
  00166	8b 84 24 28 17
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  0016d	ff c0		 inc	 eax
  0016f	3b 84 24 30 17
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00176	75 0a		 jne	 SHORT $LN18@create_ckd

; 422  :         fileseq = 0;

  00178	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR fileseq$[rsp], 0
  00180	eb 0f		 jmp	 SHORT $LN19@create_ckd
$LN18@create_ckd:

; 423  :     else
; 424  :         fileseq = fseqn;

  00182	0f b6 84 24 f8
	16 00 00	 movzx	 eax, BYTE PTR fseqn$[rsp]
  0018a	88 84 24 80 00
	00 00		 mov	 BYTE PTR fileseq$[rsp], al
$LN19@create_ckd:

; 425  : 
; 426  :     /* Set high cylinder number to zero if this is the last file */
; 427  :     if (end + 1 == volcyls)

  00191	8b 84 24 28 17
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00198	ff c0		 inc	 eax
  0019a	3b 84 24 30 17
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  001a1	75 0c		 jne	 SHORT $LN20@create_ckd

; 428  :         highcyl = 0;

  001a3	33 c0		 xor	 eax, eax
  001a5	66 89 84 24 94
	00 00 00	 mov	 WORD PTR highcyl$[rsp], ax
  001ad	eb 10		 jmp	 SHORT $LN21@create_ckd
$LN20@create_ckd:

; 429  :     else
; 430  :         highcyl = (U16) end;

  001af	0f b7 84 24 28
	17 00 00	 movzx	 eax, WORD PTR end$[rsp]
  001b7	66 89 84 24 94
	00 00 00	 mov	 WORD PTR highcyl$[rsp], ax
$LN21@create_ckd:

; 431  :     cyl = end - start + 1;

  001bf	8b 84 24 20 17
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  001c6	8b 8c 24 28 17
	00 00		 mov	 ecx, DWORD PTR end$[rsp]
  001cd	2b c8		 sub	 ecx, eax
  001cf	8b c1		 mov	 eax, ecx
  001d1	ff c0		 inc	 eax
  001d3	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax

; 432  : 
; 433  :     /* Special processing for ckd and dasdcopy */
; 434  :     if (comp == 0xFF && dasdcopy)

  001d7	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  001df	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e4	75 36		 jne	 SHORT $LN22@create_ckd
  001e6	0f b6 84 24 50
	17 00 00	 movzx	 eax, BYTE PTR dasdcopy$[rsp]
  001ee	85 c0		 test	 eax, eax
  001f0	74 2a		 je	 SHORT $LN22@create_ckd

; 435  :     {
; 436  :         highcyl = (U16) end;

  001f2	0f b7 84 24 28
	17 00 00	 movzx	 eax, WORD PTR end$[rsp]
  001fa	66 89 84 24 94
	00 00 00	 mov	 WORD PTR highcyl$[rsp], ax

; 437  :         if (end + 1 == volcyls)

  00202	8b 84 24 28 17
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00209	ff c0		 inc	 eax
  0020b	3b 84 24 30 17
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00212	75 08		 jne	 SHORT $LN23@create_ckd

; 438  :             fileseq = 0xff;

  00214	c6 84 24 80 00
	00 00 ff	 mov	 BYTE PTR fileseq$[rsp], 255 ; 000000ffH
$LN23@create_ckd:
$LN22@create_ckd:

; 439  :     }
; 440  : 
; 441  :     trks = volcyls * heads;

  0021c	8b 84 24 30 17
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00223	0f af 84 24 08
	17 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  0022b	89 84 24 98 00
	00 00		 mov	 DWORD PTR trks$[rsp], eax

; 442  : 
; 443  :     /* if `dasdcopy' > 1 then we can replace the existing file */
; 444  :     if (dasdcopy > 1) x = 0;

  00232	0f b6 84 24 50
	17 00 00	 movzx	 eax, BYTE PTR dasdcopy$[rsp]
  0023a	83 f8 01	 cmp	 eax, 1
  0023d	7e 0b		 jle	 SHORT $LN24@create_ckd
  0023f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN24@create_ckd:

; 445  : 
; 446  :     /* Create the DASD image file */
; 447  :     hostpath(pathname, fname, sizeof(pathname));

  0024a	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00250	48 8b 94 24 f0
	16 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00258	48 8d 8c 24 b0
	15 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 448  :     fd = HOPEN (pathname, O_WRONLY | O_CREAT | x | O_BINARY,

  00266	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0026d	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  00272	0f ba e8 0f	 bts	 eax, 15
  00276	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  0027c	8b d0		 mov	 edx, eax
  0027e	48 8d 8c 24 b0
	15 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0028c	89 84 24 88 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax

; 449  :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 450  :     if (fd < 0)

  00293	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  0029b	0f 8d 9f 00 00
	00		 jge	 $LN25@create_ckd

; 451  :     {
; 452  :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname, "open()", strerror( errno ));

  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a7	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002af	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002b7	b9 02 00 00 00	 mov	 ecx, 2
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c2	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002ca	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169047
  002d6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002db	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002e3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  002f1	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169048
  00301	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169049
  0030d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00312	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00317	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169050
  00324	ba c4 01 00 00	 mov	 edx, 452		; 000001c4H
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169051
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 453  :         return -1;

  00336	b8 ff ff ff ff	 mov	 eax, -1
  0033b	e9 13 1c 00 00	 jmp	 $LN1@create_ckd
$LN25@create_ckd:

; 454  :     }
; 455  : 
; 456  :     /* Create the device header */
; 457  :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  00340	48 8d 84 24 80
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00348	48 8b f8	 mov	 rdi, rax
  0034b	33 c0		 xor	 eax, eax
  0034d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00352	f3 aa		 rep stosb

; 458  :     memcpy( devhdr.dh_serial, serial, sizeof( devhdr.dh_serial ));

  00354	48 8d 84 24 94
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp+20]
  0035c	48 8b f8	 mov	 rdi, rax
  0035f	48 8b b4 24 38
	17 00 00	 mov	 rsi, QWORD PTR serial$[rsp]
  00367	b9 0c 00 00 00	 mov	 ecx, 12
  0036c	f3 a4		 rep movsb

; 459  : 
; 460  :     if (comp == 0xff) memcpy( devhdr.dh_devid, dh_devid_str( CKD_P064_TYP ), 8 );

  0036e	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00376	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0037b	75 17		 jne	 SHORT $LN26@create_ckd
  0037d	b9 00 00 80 00	 mov	 ecx, 8388608		; 00800000H
  00382	e8 00 00 00 00	 call	 dh_devid_str
  00387	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038a	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
  00392	eb 15		 jmp	 SHORT $LN27@create_ckd
$LN26@create_ckd:

; 461  :     else              memcpy( devhdr.dh_devid, dh_devid_str( CKD_C064_TYP ), 8 );

  00394	b9 00 00 40 00	 mov	 ecx, 4194304		; 00400000H
  00399	e8 00 00 00 00	 call	 dh_devid_str
  0039e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a1	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax
$LN27@create_ckd:

; 462  : 
; 463  :     STORE_LE_FW( devhdr.dh_heads,   heads   );

  003a9	8b 8c 24 08 17
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  003b0	e8 00 00 00 00	 call	 _byteswap_ulong
  003b5	8b c8		 mov	 ecx, eax
  003b7	e8 00 00 00 00	 call	 _byteswap_ulong
  003bc	8b d0		 mov	 edx, eax
  003be	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  003c6	e8 00 00 00 00	 call	 store_fw_noswap

; 464  :     STORE_LE_FW( devhdr.dh_trksize, trksize );

  003cb	8b 8c 24 10 17
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  003d2	e8 00 00 00 00	 call	 _byteswap_ulong
  003d7	8b c8		 mov	 ecx, eax
  003d9	e8 00 00 00 00	 call	 _byteswap_ulong
  003de	8b d0		 mov	 edx, eax
  003e0	48 8d 8c 24 8c
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  003e8	e8 00 00 00 00	 call	 store_fw_noswap

; 465  : 
; 466  :     devhdr.dh_devtyp  = devtype & 0xFF;

  003ed	0f b7 84 24 00
	17 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  003f5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003fa	88 84 24 90 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 467  :     devhdr.dh_fileseq = fileseq;

  00401	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  00409	88 84 24 91 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+17], al

; 468  : 
; 469  :     STORE_LE_HW( devhdr.dh_highcyl, highcyl );

  00410	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR highcyl$[rsp]
  00418	e8 00 00 00 00	 call	 _byteswap_ushort
  0041d	0f b7 c8	 movzx	 ecx, ax
  00420	e8 00 00 00 00	 call	 _byteswap_ushort
  00425	0f b7 d0	 movzx	 edx, ax
  00428	48 8d 8c 24 92
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  00430	e8 00 00 00 00	 call	 store_hw_noswap

; 470  : 
; 471  :     /* Write the device header */
; 472  :     rc = write (fd, &devhdr, CKD_DEVHDR_SIZE);

  00435	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0043b	48 8d 94 24 80
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  00443	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0044a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00450	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 473  :     if (rc < (int)CKD_DEVHDR_SIZE)

  00454	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  0045c	0f 8d bb 00 00
	00		 jge	 $LN28@create_ckd

; 474  :     {
; 475  :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname, "write()",

  00462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00468	83 38 00	 cmp	 DWORD PTR [rax], 0
  0046b	74 18		 je	 SHORT $LN64@create_ckd
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00473	8b 08		 mov	 ecx, DWORD PTR [rax]
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0047b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv255[rsp], rax
  00483	eb 0f		 jmp	 SHORT $LN65@create_ckd
$LN64@create_ckd:
  00485	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169055
  0048c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv255[rsp], rax
$LN65@create_ckd:
  00494	b9 02 00 00 00	 mov	 ecx, 2
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0049f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv255[rsp]
  004a7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169056
  004b3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004b8	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  004c0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004c5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004ce	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169057
  004de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169058
  004ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  004fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169059
  00501	ba dc 01 00 00	 mov	 edx, 476		; 000001dcH
  00506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169060
  0050d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 476  :                 errno ? strerror( errno ) : "incomplete" );
; 477  :         return -1;

  00513	b8 ff ff ff ff	 mov	 eax, -1
  00518	e9 36 1a 00 00	 jmp	 $LN1@create_ckd
$LN28@create_ckd:

; 478  :     }
; 479  : 
; 480  :     /* Build a compressed CKD file */
; 481  :     if (comp != 0xff)

  0051d	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00525	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0052a	0f 84 0c 05 00
	00		 je	 $LN29@create_ckd

; 482  :     {
; 483  :         /* Create the compressed device header */
; 484  :         memset( &cdevhdr, 0, CCKD64_DEVHDR_SIZE );

  00530	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR cdevhdr$[rsp]
  00538	48 8b f8	 mov	 rdi, rax
  0053b	33 c0		 xor	 eax, eax
  0053d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00542	f3 aa		 rep stosb

; 485  : 
; 486  :         cdevhdr.cdh_vrm[0] = CCKD_VERSION;

  00544	b8 01 00 00 00	 mov	 eax, 1
  00549	48 6b c0 00	 imul	 rax, rax, 0
  0054d	c6 84 04 80 01
	00 00 00	 mov	 BYTE PTR cdevhdr$[rsp+rax], 0

; 487  :         cdevhdr.cdh_vrm[1] = CCKD_RELEASE;

  00555	b8 01 00 00 00	 mov	 eax, 1
  0055a	48 6b c0 01	 imul	 rax, rax, 1
  0055e	c6 84 04 80 01
	00 00 03	 mov	 BYTE PTR cdevhdr$[rsp+rax], 3

; 488  :         cdevhdr.cdh_vrm[2] = CCKD_MODLVL;

  00566	b8 01 00 00 00	 mov	 eax, 1
  0056b	48 6b c0 02	 imul	 rax, rax, 2
  0056f	c6 84 04 80 01
	00 00 01	 mov	 BYTE PTR cdevhdr$[rsp+rax], 1

; 489  : 
; 490  :         if (cckd_def_opt_bigend())

  00577	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  0057c	85 c0		 test	 eax, eax
  0057e	74 12		 je	 SHORT $LN30@create_ckd

; 491  :             cdevhdr.cdh_opts |= CCKD_OPT_BIGEND;

  00580	0f b6 84 24 83
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00588	83 c8 02	 or	 eax, 2
  0058b	88 84 24 83 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al
$LN30@create_ckd:

; 492  : 
; 493  :         cdevhdr.cdh_opts     |= CCKD_OPT_OPENRW;

  00592	0f b6 84 24 83
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  0059a	83 c8 40	 or	 eax, 64			; 00000040H
  0059d	88 84 24 83 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al

; 494  :         cdevhdr.num_L1tab = (volcyls * heads + 255) / 256;

  005a4	8b 84 24 30 17
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  005ab	0f af 84 24 08
	17 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  005b3	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  005b8	33 d2		 xor	 edx, edx
  005ba	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  005bf	f7 f1		 div	 ecx
  005c1	89 84 24 84 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+4], eax

; 495  :         cdevhdr.num_L2tab = 256;

  005c8	c7 84 24 88 01
	00 00 00 01 00
	00		 mov	 DWORD PTR cdevhdr$[rsp+8], 256 ; 00000100H

; 496  : 
; 497  :         STORE_LE_FW( cdevhdr.cdh_cyls, volcyls );

  005d3	8b 8c 24 30 17
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  005da	e8 00 00 00 00	 call	 _byteswap_ulong
  005df	8b c8		 mov	 ecx, eax
  005e1	e8 00 00 00 00	 call	 _byteswap_ulong
  005e6	8b d0		 mov	 edx, eax
  005e8	48 8d 8c 24 8c
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+12]
  005f0	e8 00 00 00 00	 call	 store_fw_noswap

; 498  : 
; 499  :         cdevhdr.cmp_algo    = comp;

  005f5	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  005fd	88 84 24 c9 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+73], al

; 500  :         cdevhdr.cmp_parm    = -1;

  00604	b8 ff ff ff ff	 mov	 eax, -1
  00609	66 89 84 24 ca
	01 00 00	 mov	 WORD PTR cdevhdr$[rsp+74], ax

; 501  :         cdevhdr.cdh_nullfmt = nullfmt;

  00611	0f b6 84 24 58
	17 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  00619	88 84 24 c8 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+72], al

; 502  : 
; 503  :         /* Write the compressed device header */
; 504  :         rc = write (fd, &cdevhdr, CCKD64_DEVHDR_SIZE);

  00620	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00626	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  0062e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00635	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0063b	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 505  :         if (rc < (int)            CCKD64_DEVHDR_SIZE)

  0063f	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00647	0f 8d bb 00 00
	00		 jge	 $LN31@create_ckd

; 506  :         {
; 507  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0064d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00653	83 38 00	 cmp	 DWORD PTR [rax], 0
  00656	74 18		 je	 SHORT $LN66@create_ckd
  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0065e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00660	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00666	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv309[rsp], rax
  0066e	eb 0f		 jmp	 SHORT $LN67@create_ckd
$LN66@create_ckd:
  00670	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169064
  00677	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv309[rsp], rax
$LN67@create_ckd:
  0067f	b9 02 00 00 00	 mov	 ecx, 2
  00684	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0068a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv309[rsp]
  00692	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00697	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169065
  0069e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006a3	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  006ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006b0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  006b9	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  006c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169066
  006c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169067
  006d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006df	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169068
  006ec	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  006f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169069
  006f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 508  :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 509  :             return -1;

  006fe	b8 ff ff ff ff	 mov	 eax, -1
  00703	e9 4b 18 00 00	 jmp	 $LN1@create_ckd
$LN31@create_ckd:

; 510  :         }
; 511  : 
; 512  :         /* Create the primary lookup table */
; 513  :         l1 = calloc (cdevhdr.num_L1tab, CCKD64_L1ENT_SIZE);

  00708	48 63 84 24 84
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  00710	ba 08 00 00 00	 mov	 edx, 8
  00715	48 8b c8	 mov	 rcx, rax
  00718	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0071e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR l1$[rsp], rax

; 514  :         if (l1 == NULL)

  00726	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR l1$[rsp], 0
  0072f	0f 85 ca 00 00
	00		 jne	 $LN32@create_ckd

; 515  :         {
; 516  :             char buf[40];
; 517  :             MSGBUF( buf, "calloc(%d,%d)", (int)cdevhdr.num_L1tab, (int)CCKD64_L1ENT_SIZE);

  00735	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0073d	44 8b 8c 24 84
	01 00 00	 mov	 r9d, DWORD PTR cdevhdr$[rsp+4]
  00745	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169071
  0074c	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00751	48 8d 8c 24 80
	15 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00759	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 518  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname, buf, strerror( errno ));

  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00765	8b 08		 mov	 ecx, DWORD PTR [rax]
  00767	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0076d	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv332[rsp], rax
  00775	b9 02 00 00 00	 mov	 ecx, 2
  0077a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00780	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv332[rsp]
  00788	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0078d	48 8d 8c 24 80
	15 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00795	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0079a	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  007a2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007b0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  007b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169072
  007c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169073
  007cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  007dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169074
  007e3	ba 06 02 00 00	 mov	 edx, 518		; 00000206H
  007e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169075
  007ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 519  :             return -1;

  007f5	b8 ff ff ff ff	 mov	 eax, -1
  007fa	e9 54 17 00 00	 jmp	 $LN1@create_ckd
$LN32@create_ckd:

; 520  :         }
; 521  :         l1[0] = CCKD64_L1TAB_POS + cdevhdr.num_L1tab * CCKD64_L1ENT_SIZE;

  007ff	48 63 84 24 84
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  00807	48 8d 04 c5 00
	04 00 00	 lea	 rax, QWORD PTR [rax*8+1024]
  0080f	b9 08 00 00 00	 mov	 ecx, 8
  00814	48 6b c9 00	 imul	 rcx, rcx, 0
  00818	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  00820	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 522  : 
; 523  :         /* Write the primary lookup table */
; 524  :         rc = write (fd, l1, cdevhdr.num_L1tab * CCKD64_L1ENT_SIZE);

  00824	48 63 84 24 84
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  0082c	48 c1 e0 03	 shl	 rax, 3
  00830	44 8b c0	 mov	 r8d, eax
  00833	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  0083b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00842	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00848	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 525  :         if (rc < (int)     (cdevhdr.num_L1tab * CCKD64_L1ENT_SIZE))

  0084c	48 63 84 24 84
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+4]
  00854	48 c1 e0 03	 shl	 rax, 3
  00858	39 44 24 7c	 cmp	 DWORD PTR rc$[rsp], eax
  0085c	0f 8d bb 00 00
	00		 jge	 $LN33@create_ckd

; 526  :         {
; 527  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00862	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00868	83 38 00	 cmp	 DWORD PTR [rax], 0
  0086b	74 18		 je	 SHORT $LN68@create_ckd
  0086d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00873	8b 08		 mov	 ecx, DWORD PTR [rax]
  00875	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0087b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv375[rsp], rax
  00883	eb 0f		 jmp	 SHORT $LN69@create_ckd
$LN68@create_ckd:
  00885	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169077
  0088c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv375[rsp], rax
$LN69@create_ckd:
  00894	b9 02 00 00 00	 mov	 ecx, 2
  00899	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0089f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv375[rsp]
  008a7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  008ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169078
  008b3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008b8	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  008c0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008c5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  008ce	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  008d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169079
  008de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169080
  008ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  008fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169081
  00901	ba 10 02 00 00	 mov	 edx, 528		; 00000210H
  00906	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169082
  0090d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 528  :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 529  :             return -1;

  00913	b8 ff ff ff ff	 mov	 eax, -1
  00918	e9 36 16 00 00	 jmp	 $LN1@create_ckd
$LN33@create_ckd:

; 530  :         }
; 531  : 
; 532  :         /* Create the secondary lookup table */
; 533  :         memset (&l2, 0, CCKD64_L2TAB_SIZE);

  0091d	48 8d 84 24 80
	05 00 00	 lea	 rax, QWORD PTR l2$[rsp]
  00925	48 8b f8	 mov	 rdi, rax
  00928	33 c0		 xor	 eax, eax
  0092a	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0092f	f3 aa		 rep stosb

; 534  : 
; 535  :         /* Write the seondary lookup table */
; 536  :         rc = write (fd, &l2, CCKD64_L2TAB_SIZE);

  00931	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00937	48 8d 94 24 80
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  0093f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00946	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0094c	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 537  :         if (rc < (int)       CCKD64_L2TAB_SIZE)

  00950	81 7c 24 7c 00
	10 00 00	 cmp	 DWORD PTR rc$[rsp], 4096 ; 00001000H
  00958	0f 8d bb 00 00
	00		 jge	 $LN34@create_ckd

; 538  :         {
; 539  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0095e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00964	83 38 00	 cmp	 DWORD PTR [rax], 0
  00967	74 18		 je	 SHORT $LN70@create_ckd
  00969	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0096f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00971	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00977	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv404[rsp], rax
  0097f	eb 0f		 jmp	 SHORT $LN71@create_ckd
$LN70@create_ckd:
  00981	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169084
  00988	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN71@create_ckd:
  00990	b9 02 00 00 00	 mov	 ecx, 2
  00995	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0099b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv404[rsp]
  009a3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169085
  009af	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009b4	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  009bc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009c1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  009ca	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  009d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169086
  009da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169087
  009e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  009f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169088
  009fd	ba 1c 02 00 00	 mov	 edx, 540		; 0000021cH
  00a02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169089
  00a09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 540  :                     "write()", errno ? strerror( errno ) : "incomplete" );
; 541  :             return -1;

  00a0f	b8 ff ff ff ff	 mov	 eax, -1
  00a14	e9 3a 15 00 00	 jmp	 $LN1@create_ckd
$LN34@create_ckd:

; 542  :         }
; 543  : 
; 544  :         cpos = l1[0] + CCKD64_L2TAB_SIZE;

  00a19	b8 08 00 00 00	 mov	 eax, 8
  00a1e	48 6b c0 00	 imul	 rax, rax, 0
  00a22	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  00a2a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00a2e	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00a34	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR cpos$[rsp], rax
$LN29@create_ckd:

; 545  :     }
; 546  : 
; 547  :     if (!dasdcopy)

  00a3c	0f b6 84 24 50
	17 00 00	 movzx	 eax, BYTE PTR dasdcopy$[rsp]
  00a44	85 c0		 test	 eax, eax
  00a46	0f 85 cf 0f 00
	00		 jne	 $LN35@create_ckd

; 548  :     {
; 549  :         /* Write each cylinder */
; 550  :         for (cyl = start; cyl <= end; cyl++)

  00a4c	8b 84 24 20 17
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00a53	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
  00a57	eb 0a		 jmp	 SHORT $LN4@create_ckd
$LN2@create_ckd:
  00a59	8b 44 24 78	 mov	 eax, DWORD PTR cyl$[rsp]
  00a5d	ff c0		 inc	 eax
  00a5f	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN4@create_ckd:
  00a63	8b 84 24 28 17
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00a6a	39 44 24 78	 cmp	 DWORD PTR cyl$[rsp], eax
  00a6e	0f 87 a5 0f 00
	00		 ja	 $LN3@create_ckd

; 551  :         {
; 552  :             /* Display progress message every 10 cylinders */
; 553  :             if (cyl && !(cyl % 10))

  00a74	83 7c 24 78 00	 cmp	 DWORD PTR cyl$[rsp], 0
  00a79	74 61		 je	 SHORT $LN37@create_ckd
  00a7b	33 d2		 xor	 edx, edx
  00a7d	8b 44 24 78	 mov	 eax, DWORD PTR cyl$[rsp]
  00a81	b9 0a 00 00 00	 mov	 ecx, 10
  00a86	f7 f1		 div	 ecx
  00a88	8b c2		 mov	 eax, edx
  00a8a	85 c0		 test	 eax, eax
  00a8c	75 4e		 jne	 SHORT $LN37@create_ckd

; 554  :             {
; 555  :                 if (extgui)

  00a8e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00a95	83 38 00	 cmp	 DWORD PTR [rax], 0
  00a98	74 22		 je	 SHORT $LN38@create_ckd

; 556  :                     fprintf( stderr, "CYL=%u\n", cyl );

  00a9a	b9 02 00 00 00	 mov	 ecx, 2
  00a9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00aa5	44 8b 44 24 78	 mov	 r8d, DWORD PTR cyl$[rsp]
  00aaa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169095
  00ab1	48 8b c8	 mov	 rcx, rax
  00ab4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
  00aba	eb 20		 jmp	 SHORT $LN39@create_ckd
$LN38@create_ckd:

; 557  :                 else
; 558  :                     fprintf( stderr, "Writing cylinder %u\r", cyl );

  00abc	b9 02 00 00 00	 mov	 ecx, 2
  00ac1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ac7	44 8b 44 24 78	 mov	 r8d, DWORD PTR cyl$[rsp]
  00acc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169096
  00ad3	48 8b c8	 mov	 rcx, rax
  00ad6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN39@create_ckd:
$LN37@create_ckd:

; 559  :             }
; 560  : 
; 561  :             for (head = 0; head < heads; head++)

  00adc	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR head$[rsp], 0
  00ae7	eb 10		 jmp	 SHORT $LN7@create_ckd
$LN5@create_ckd:
  00ae9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00af0	ff c0		 inc	 eax
  00af2	89 84 24 84 00
	00 00		 mov	 DWORD PTR head$[rsp], eax
$LN7@create_ckd:
  00af9	8b 84 24 08 17
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00b00	39 84 24 84 00
	00 00		 cmp	 DWORD PTR head$[rsp], eax
  00b07	0f 83 f6 0e 00
	00		 jae	 $LN6@create_ckd

; 562  :             {
; 563  :                 /* Clear the track to zeroes */
; 564  :                 memset (buf, 0, trksize);

  00b0d	8b 84 24 10 17
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00b14	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv476[rsp], rax
  00b1c	48 8b bc 24 18
	17 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00b24	33 c0		 xor	 eax, eax
  00b26	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv476[rsp]
  00b2e	f3 aa		 rep stosb

; 565  : 
; 566  :                 /* Build the track header */
; 567  :                 trkhdr = (CKD_TRKHDR*) buf;

  00b30	48 8b 84 24 18
	17 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b38	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 568  :                 trkhdr->bin = 0;

  00b40	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  00b48	c6 00 00	 mov	 BYTE PTR [rax], 0

; 569  :                 store_hw( trkhdr->cyl,  (U16) cyl  );

  00b4b	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00b50	e8 00 00 00 00	 call	 _byteswap_ushort
  00b55	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00b5d	48 ff c1	 inc	 rcx
  00b60	0f b7 d0	 movzx	 edx, ax
  00b63	e8 00 00 00 00	 call	 store_hw_noswap

; 570  :                 store_hw( trkhdr->head, (U16) head );

  00b68	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00b70	e8 00 00 00 00	 call	 _byteswap_ushort
  00b75	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00b7d	48 83 c1 03	 add	 rcx, 3
  00b81	0f b7 d0	 movzx	 edx, ax
  00b84	e8 00 00 00 00	 call	 store_hw_noswap

; 571  :                 pos = buf + CKD_TRKHDR_SIZE;

  00b89	48 8b 84 24 18
	17 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b91	48 83 c0 05	 add	 rax, 5
  00b95	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 572  : 
; 573  :                 /* Build record zero */
; 574  :                 r = 0;

  00b9a	c6 44 24 60 00	 mov	 BYTE PTR r$[rsp], 0

; 575  :                 rechdr = (CKD_RECHDR*) pos;

  00b9f	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00ba4	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 576  :                 pos += CKD_RECHDR_SIZE;

  00ba9	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00bae	48 83 c0 08	 add	 rax, 8
  00bb2	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 577  :                 store_hw( rechdr->cyl,  (U16) cyl  );

  00bb7	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00bbc	e8 00 00 00 00	 call	 _byteswap_ushort
  00bc1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00bc6	0f b7 d0	 movzx	 edx, ax
  00bc9	e8 00 00 00 00	 call	 store_hw_noswap

; 578  :                 store_hw( rechdr->head, (U16) head );

  00bce	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00bd6	e8 00 00 00 00	 call	 _byteswap_ushort
  00bdb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00be0	48 83 c1 02	 add	 rcx, 2
  00be4	0f b7 d0	 movzx	 edx, ax
  00be7	e8 00 00 00 00	 call	 store_hw_noswap

; 579  :                           rechdr->rec  = r;

  00bec	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00bf1	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00bf6	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 580  :                           rechdr->klen = 0;

  00bf9	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00bfe	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 581  :                 store_hw( rechdr->dlen, CKD_R0_DLEN );

  00c02	66 b9 08 00	 mov	 cx, 8
  00c06	e8 00 00 00 00	 call	 _byteswap_ushort
  00c0b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00c10	48 83 c1 06	 add	 rcx, 6
  00c14	0f b7 d0	 movzx	 edx, ax
  00c17	e8 00 00 00 00	 call	 store_hw_noswap

; 582  :                 pos += CKD_R0_DLEN;

  00c1c	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00c21	48 83 c0 08	 add	 rax, 8
  00c25	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 583  :                 r++;

  00c2a	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00c2f	fe c0		 inc	 al
  00c31	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 584  : 
; 585  :                 /* Track 0 contains IPL records and volume label */
; 586  :                 if (!rawflag && fseqn == 1 && trk == 0)

  00c35	0f b6 84 24 60
	17 00 00	 movzx	 eax, BYTE PTR rawflag$[rsp]
  00c3d	85 c0		 test	 eax, eax
  00c3f	0f 85 18 04 00
	00		 jne	 $LN40@create_ckd
  00c45	0f b6 84 24 f8
	16 00 00	 movzx	 eax, BYTE PTR fseqn$[rsp]
  00c4d	83 f8 01	 cmp	 eax, 1
  00c50	0f 85 07 04 00
	00		 jne	 $LN40@create_ckd
  00c56	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  00c5e	0f 85 f9 03 00
	00		 jne	 $LN40@create_ckd

; 587  :                 {
; 588  :                     /* Build the IPL1 record */
; 589  :                     rechdr = (CKD_RECHDR*) pos;

  00c64	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00c69	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 590  :                     pos += CKD_RECHDR_SIZE;

  00c6e	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00c73	48 83 c0 08	 add	 rax, 8
  00c77	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 591  : 
; 592  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  00c7c	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00c81	e8 00 00 00 00	 call	 _byteswap_ushort
  00c86	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00c8b	0f b7 d0	 movzx	 edx, ax
  00c8e	e8 00 00 00 00	 call	 store_hw_noswap

; 593  :                     store_hw( rechdr->head, (U16) head );

  00c93	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00c9b	e8 00 00 00 00	 call	 _byteswap_ushort
  00ca0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ca5	48 83 c1 02	 add	 rcx, 2
  00ca9	0f b7 d0	 movzx	 edx, ax
  00cac	e8 00 00 00 00	 call	 store_hw_noswap

; 594  :                               rechdr->rec  = r;

  00cb1	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00cb6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00cbb	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 595  :                               rechdr->klen = (BYTE) keylen;

  00cbe	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00cc3	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00ccb	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 596  :                     store_hw( rechdr->dlen,  (U16) ipl1len );

  00cce	0f b7 8c 24 10
	01 00 00	 movzx	 ecx, WORD PTR ipl1len$[rsp]
  00cd6	e8 00 00 00 00	 call	 _byteswap_ushort
  00cdb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ce0	48 83 c1 06	 add	 rcx, 6
  00ce4	0f b7 d0	 movzx	 edx, ax
  00ce7	e8 00 00 00 00	 call	 store_hw_noswap

; 597  :                     r++;

  00cec	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00cf1	fe c0		 inc	 al
  00cf3	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 598  : 
; 599  :                     memcpy( pos, IPL1_KEY, (size_t)keylen );

  00cf7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:IPL1_KEY
  00cfe	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  00d03	48 8b f0	 mov	 rsi, rax
  00d06	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR keylen$[rsp]
  00d0e	f3 a4		 rep movsb

; 600  :                     pos += keylen;

  00d10	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR keylen$[rsp]
  00d18	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d1d	48 03 c8	 add	 rcx, rax
  00d20	48 8b c1	 mov	 rax, rcx
  00d23	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 601  : 
; 602  :                     /* Copy model IPL PSW and CCWs */
; 603  :                     memcpy( pos,                                            noiplpsw,  sizeof( noiplpsw  ));

  00d28	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d2d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplpsw
  00d34	48 89 08	 mov	 QWORD PTR [rax], rcx

; 604  :                     memcpy( pos + sizeof( noiplpsw ),                       noiplccw1, sizeof( noiplccw1 ));

  00d37	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d3c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw1
  00d43	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 605  :                     memcpy( pos + sizeof( noiplpsw ) + sizeof( noiplccw1 ), noiplccw2, sizeof( noiplccw2 ));

  00d47	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d4c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw2
  00d53	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 606  : 
; 607  :                     /* Set EC mode flag in wait PSW if requested */
; 608  :                     if (flagECmode)

  00d57	0f b6 84 24 68
	17 00 00	 movzx	 eax, BYTE PTR flagECmode$[rsp]
  00d5f	85 c0		 test	 eax, eax
  00d61	74 14		 je	 SHORT $LN42@create_ckd

; 609  :                         *(pos+1) = 0x08 | *(pos+1);

  00d63	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d68	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00d6c	83 c8 08	 or	 eax, 8
  00d6f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d74	88 41 01	 mov	 BYTE PTR [rcx+1], al
$LN42@create_ckd:

; 610  : 
; 611  :                     /* Set machine-check-enabled mask in PSW if requested */
; 612  :                     if (flagMachinecheck)

  00d77	0f b6 84 24 70
	17 00 00	 movzx	 eax, BYTE PTR flagMachinecheck$[rsp]
  00d7f	85 c0		 test	 eax, eax
  00d81	74 14		 je	 SHORT $LN43@create_ckd

; 613  :                         *(pos+1) = 0x04 | *(pos+1);

  00d83	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00d88	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00d8c	83 c8 04	 or	 eax, 4
  00d8f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00d94	88 41 01	 mov	 BYTE PTR [rcx+1], al
$LN43@create_ckd:

; 614  : 
; 615  :                     pos += ipl1len;

  00d97	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ipl1len$[rsp]
  00d9f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00da4	48 03 c8	 add	 rcx, rax
  00da7	48 8b c1	 mov	 rax, rcx
  00daa	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 616  : 
; 617  :                     /* Build the IPL2 record */
; 618  :                     rechdr = (CKD_RECHDR*) pos;

  00daf	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00db4	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 619  :                     pos += CKD_RECHDR_SIZE;

  00db9	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00dbe	48 83 c0 08	 add	 rax, 8
  00dc2	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 620  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  00dc7	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00dcc	e8 00 00 00 00	 call	 _byteswap_ushort
  00dd1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00dd6	0f b7 d0	 movzx	 edx, ax
  00dd9	e8 00 00 00 00	 call	 store_hw_noswap

; 621  :                     store_hw( rechdr->head, (U16) head );

  00dde	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00de6	e8 00 00 00 00	 call	 _byteswap_ushort
  00deb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00df0	48 83 c1 02	 add	 rcx, 2
  00df4	0f b7 d0	 movzx	 edx, ax
  00df7	e8 00 00 00 00	 call	 store_hw_noswap

; 622  :                               rechdr->rec  = r;

  00dfc	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00e01	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00e06	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 623  :                               rechdr->klen = (BYTE) keylen;

  00e09	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00e0e	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00e16	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 624  :                     store_hw( rechdr->dlen,  (U16) ipl2len );

  00e19	0f b7 8c 24 18
	01 00 00	 movzx	 ecx, WORD PTR ipl2len$[rsp]
  00e21	e8 00 00 00 00	 call	 _byteswap_ushort
  00e26	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00e2b	48 83 c1 06	 add	 rcx, 6
  00e2f	0f b7 d0	 movzx	 edx, ax
  00e32	e8 00 00 00 00	 call	 store_hw_noswap

; 625  :                     r++;

  00e37	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00e3c	fe c0		 inc	 al
  00e3e	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 626  : 
; 627  :                     memcpy( pos, IPL2_KEY, (size_t)keylen );

  00e42	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:IPL2_KEY
  00e49	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  00e4e	48 8b f0	 mov	 rsi, rax
  00e51	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR keylen$[rsp]
  00e59	f3 a4		 rep movsb

; 628  :                     pos += keylen;

  00e5b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR keylen$[rsp]
  00e63	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00e68	48 03 c8	 add	 rcx, rax
  00e6b	48 8b c1	 mov	 rax, rcx
  00e6e	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 629  :                     pos += ipl2len;

  00e73	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR ipl2len$[rsp]
  00e7b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00e80	48 03 c8	 add	 rcx, rax
  00e83	48 8b c1	 mov	 rax, rcx
  00e86	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 630  : 
; 631  :                     /* Build the VOL1 record */
; 632  :                     rechdr = (CKD_RECHDR*) pos;

  00e8b	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00e90	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 633  :                     pos += CKD_RECHDR_SIZE;

  00e95	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00e9a	48 83 c0 08	 add	 rax, 8
  00e9e	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 634  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  00ea3	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00ea8	e8 00 00 00 00	 call	 _byteswap_ushort
  00ead	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00eb2	0f b7 d0	 movzx	 edx, ax
  00eb5	e8 00 00 00 00	 call	 store_hw_noswap

; 635  :                     store_hw( rechdr->head, (U16) head );

  00eba	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00ec2	e8 00 00 00 00	 call	 _byteswap_ushort
  00ec7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ecc	48 83 c1 02	 add	 rcx, 2
  00ed0	0f b7 d0	 movzx	 edx, ax
  00ed3	e8 00 00 00 00	 call	 store_hw_noswap

; 636  :                               rechdr->rec  = r;

  00ed8	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00edd	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  00ee2	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 637  :                               rechdr->klen = (BYTE) keylen;

  00ee5	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  00eea	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  00ef2	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 638  :                     store_hw( rechdr->dlen,  (U16) vol1len );

  00ef5	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR vol1len$[rsp]
  00efd	e8 00 00 00 00	 call	 _byteswap_ushort
  00f02	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00f07	48 83 c1 06	 add	 rcx, 6
  00f0b	0f b7 d0	 movzx	 edx, ax
  00f0e	e8 00 00 00 00	 call	 store_hw_noswap

; 639  :                     r++;

  00f13	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  00f18	fe c0		 inc	 al
  00f1a	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 640  : 
; 641  :                     memcpy( pos, VOL1_KEY, (size_t)keylen );

  00f1e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:VOL1_KEY
  00f25	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  00f2a	48 8b f0	 mov	 rsi, rax
  00f2d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR keylen$[rsp]
  00f35	f3 a4		 rep movsb

; 642  :                     pos += keylen;

  00f37	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR keylen$[rsp]
  00f3f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f44	48 03 c8	 add	 rcx, rax
  00f47	48 8b c1	 mov	 rax, rcx
  00f4a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 643  : 
; 644  :                     /* Build the VOL1 label */
; 645  :                     build_vol1( pos, volser, NULL, true );

  00f4f	41 b1 01	 mov	 r9b, 1
  00f52	45 33 c0	 xor	 r8d, r8d
  00f55	48 8b 94 24 40
	17 00 00	 mov	 rdx, QWORD PTR volser$[rsp]
  00f5d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f62	e8 00 00 00 00	 call	 build_vol1

; 646  :                     pos += vol1len;

  00f67	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR vol1len$[rsp]
  00f6f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  00f74	48 03 c8	 add	 rcx, rax
  00f77	48 8b c1	 mov	 rax, rcx
  00f7a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 647  : 
; 648  :                     /* 9 4096 data blocks for linux volume */
; 649  :                     if (nullfmt == CKD_NULLTRK_FMT2)

  00f7f	0f b6 84 24 58
	17 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  00f87	83 f8 02	 cmp	 eax, 2
  00f8a	0f 85 c8 00 00
	00		 jne	 $LN44@create_ckd

; 650  :                     {
; 651  :                         for (i = 0; i < 9; i++)

  00f90	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00f9b	eb 10		 jmp	 SHORT $LN10@create_ckd
$LN8@create_ckd:
  00f9d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00fa4	ff c0		 inc	 eax
  00fa6	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@create_ckd:
  00fad	83 bc 24 8c 00
	00 00 09	 cmp	 DWORD PTR i$[rsp], 9
  00fb5	0f 8d 9d 00 00
	00		 jge	 $LN9@create_ckd

; 652  :                         {
; 653  :                             rechdr = (CKD_RECHDR*)pos;

  00fbb	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00fc0	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 654  :                             pos += CKD_RECHDR_SIZE;

  00fc5	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  00fca	48 83 c0 08	 add	 rax, 8
  00fce	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 655  : 
; 656  :                             store_hw( rechdr->cyl,  (U16) cyl  );

  00fd3	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  00fd8	e8 00 00 00 00	 call	 _byteswap_ushort
  00fdd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00fe2	0f b7 d0	 movzx	 edx, ax
  00fe5	e8 00 00 00 00	 call	 store_hw_noswap

; 657  :                             store_hw( rechdr->head, (U16) head );

  00fea	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00ff2	e8 00 00 00 00	 call	 _byteswap_ushort
  00ff7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00ffc	48 83 c1 02	 add	 rcx, 2
  01000	0f b7 d0	 movzx	 edx, ax
  01003	e8 00 00 00 00	 call	 store_hw_noswap

; 658  :                                       rechdr->rec  = r;

  01008	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0100d	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  01012	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 659  :                                       rechdr->klen = 0;

  01015	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0101a	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 660  :                             store_hw( rechdr->dlen, CKD_NULL_FMT2_DLEN );

  0101e	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  01022	e8 00 00 00 00	 call	 _byteswap_ushort
  01027	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0102c	48 83 c1 06	 add	 rcx, 6
  01030	0f b7 d0	 movzx	 edx, ax
  01033	e8 00 00 00 00	 call	 store_hw_noswap

; 661  :                             pos +=                  CKD_NULL_FMT2_DLEN;

  01038	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0103d	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01043	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 662  :                             r++;

  01048	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0104d	fe c0		 inc	 al
  0104f	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 663  :                         }

  01053	e9 45 ff ff ff	 jmp	 $LN8@create_ckd
$LN9@create_ckd:
$LN44@create_ckd:

; 664  :                     }
; 665  :                 } /* end if(trk == 0) */

  01058	e9 c2 07 00 00	 jmp	 $LN41@create_ckd
$LN40@create_ckd:

; 666  : 
; 667  :                 /* Track 1 for linux contains an empty VTOC */
; 668  :                 else if (fseqn == 1 && trk == 1 && nullfmt == CKD_NULLTRK_FMT2)

  0105d	0f b6 84 24 f8
	16 00 00	 movzx	 eax, BYTE PTR fseqn$[rsp]
  01065	83 f8 01	 cmp	 eax, 1
  01068	0f 85 3d 06 00
	00		 jne	 $LN45@create_ckd
  0106e	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR trk$[rsp], 1
  01076	0f 85 2f 06 00
	00		 jne	 $LN45@create_ckd
  0107c	0f b6 84 24 58
	17 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  01084	83 f8 02	 cmp	 eax, 2
  01087	0f 85 1e 06 00
	00		 jne	 $LN45@create_ckd

; 669  :                 {
; 670  :                     /* build format 4 dscb */
; 671  :                     rechdr = (CKD_RECHDR*) pos;

  0108d	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01092	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 672  :                     pos += CKD_RECHDR_SIZE;

  01097	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0109c	48 83 c0 08	 add	 rax, 8
  010a0	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 673  : 
; 674  :                     /* track 1 record 1 count */
; 675  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  010a5	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  010aa	e8 00 00 00 00	 call	 _byteswap_ushort
  010af	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  010b4	0f b7 d0	 movzx	 edx, ax
  010b7	e8 00 00 00 00	 call	 store_hw_noswap

; 676  :                     store_hw( rechdr->head, (U16) head );

  010bc	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  010c4	e8 00 00 00 00	 call	 _byteswap_ushort
  010c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  010ce	48 83 c1 02	 add	 rcx, 2
  010d2	0f b7 d0	 movzx	 edx, ax
  010d5	e8 00 00 00 00	 call	 store_hw_noswap

; 677  :                               rechdr->rec  = r;

  010da	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  010df	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  010e4	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 678  :                               rechdr->klen = 44;

  010e7	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  010ec	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 679  :                     store_hw( rechdr->dlen, 96 );

  010f0	66 b9 60 00	 mov	 cx, 96			; 00000060H
  010f4	e8 00 00 00 00	 call	 _byteswap_ushort
  010f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  010fe	48 83 c1 06	 add	 rcx, 6
  01102	0f b7 d0	 movzx	 edx, ax
  01105	e8 00 00 00 00	 call	 store_hw_noswap

; 680  :                     r++;

  0110a	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0110f	fe c0		 inc	 al
  01111	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 681  : 
; 682  :                     /* track 1 record 1 key */
; 683  :                     memset (pos, 0x04, 44);

  01115	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  0111a	b8 04 00 00 00	 mov	 eax, 4
  0111f	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  01124	f3 aa		 rep stosb

; 684  :                     pos += 44;

  01126	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0112b	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0112f	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 685  : 
; 686  :                     /* track 1 record 1 data */
; 687  :                     memset (pos, 0, 96);

  01134	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01139	33 c0		 xor	 eax, eax
  0113b	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  01140	f3 aa		 rep stosb

; 688  :                     pos[0] = 0xf4;                            // DS4IDFMT

  01142	b8 01 00 00 00	 mov	 eax, 1
  01147	48 6b c0 00	 imul	 rax, rax, 0
  0114b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01150	c6 04 01 f4	 mov	 BYTE PTR [rcx+rax], 244	; 000000f4H

; 689  :                     store_hw(pos + 6, 10);                    // DS4DSREC

  01154	66 b9 0a 00	 mov	 cx, 10
  01158	e8 00 00 00 00	 call	 _byteswap_ushort
  0115d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01162	48 83 c1 06	 add	 rcx, 6
  01166	0f b7 d0	 movzx	 edx, ax
  01169	e8 00 00 00 00	 call	 store_hw_noswap

; 690  :                     pos[14] = trks > 65535 ? 0xa0 : 0;        // DS4VTOCI

  0116e	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  01179	76 0d		 jbe	 SHORT $LN72@create_ckd
  0117b	c7 84 24 b4 00
	00 00 a0 00 00
	00		 mov	 DWORD PTR tv735[rsp], 160 ; 000000a0H
  01186	eb 0b		 jmp	 SHORT $LN73@create_ckd
$LN72@create_ckd:
  01188	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv735[rsp], 0
$LN73@create_ckd:
  01193	b8 01 00 00 00	 mov	 eax, 1
  01198	48 6b c0 0e	 imul	 rax, rax, 14
  0119c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011a1	0f b6 94 24 b4
	00 00 00	 movzx	 edx, BYTE PTR tv735[rsp]
  011a9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 691  :                     pos[15] = 1;                              // DS4NOEXT

  011ac	b8 01 00 00 00	 mov	 eax, 1
  011b1	48 6b c0 0f	 imul	 rax, rax, 15
  011b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011ba	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 692  :                     store_hw(pos+18, (U16) volcyls);          // DS4DSCYL

  011be	0f b7 8c 24 30
	17 00 00	 movzx	 ecx, WORD PTR volcyls$[rsp]
  011c6	e8 00 00 00 00	 call	 _byteswap_ushort
  011cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011d0	48 83 c1 12	 add	 rcx, 18
  011d4	0f b7 d0	 movzx	 edx, ax
  011d7	e8 00 00 00 00	 call	 store_hw_noswap

; 693  :                     store_hw(pos+20, (U16) heads);            // DS4DSTRK

  011dc	0f b7 8c 24 08
	17 00 00	 movzx	 ecx, WORD PTR heads$[rsp]
  011e4	e8 00 00 00 00	 call	 _byteswap_ushort
  011e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  011ee	48 83 c1 14	 add	 rcx, 20
  011f2	0f b7 d0	 movzx	 edx, ax
  011f5	e8 00 00 00 00	 call	 store_hw_noswap

; 694  :                     store_hw(pos+22, ckdtab->len);            // DS4DEVTK

  011fa	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ckdtab$[rsp]
  01202	0f b7 48 1a	 movzx	 ecx, WORD PTR [rax+26]
  01206	e8 00 00 00 00	 call	 _byteswap_ushort
  0120b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01210	48 83 c1 16	 add	 rcx, 22
  01214	0f b7 d0	 movzx	 edx, ax
  01217	e8 00 00 00 00	 call	 store_hw_noswap

; 695  :                     pos[27] = 0x30;                           // DS4DEVFG

  0121c	b8 01 00 00 00	 mov	 eax, 1
  01221	48 6b c0 1b	 imul	 rax, rax, 27
  01225	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0122a	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H

; 696  :                     pos[30] = 0x0c;                           // DS4DEVDT

  0122e	b8 01 00 00 00	 mov	 eax, 1
  01233	48 6b c0 1e	 imul	 rax, rax, 30
  01237	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0123c	c6 04 01 0c	 mov	 BYTE PTR [rcx+rax], 12

; 697  :                     pos[61] = 0x01;                           // DS4VTOCE + 00

  01240	b8 01 00 00 00	 mov	 eax, 1
  01245	48 6b c0 3d	 imul	 rax, rax, 61		; 0000003dH
  01249	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0124e	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 698  :                     pos[66] = 0x01;                           // DS4VTOCE + 05

  01252	b8 01 00 00 00	 mov	 eax, 1
  01257	48 6b c0 42	 imul	 rax, rax, 66		; 00000042H
  0125b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01260	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 699  :                     pos[70] = 0x01;                           // DS4VTOCE + 09

  01264	b8 01 00 00 00	 mov	 eax, 1
  01269	48 6b c0 46	 imul	 rax, rax, 70		; 00000046H
  0126d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01272	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 700  :                     pos[81] = trks > 65535 ? 7 : 0;           // DS4EFLVL

  01276	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  01281	76 0d		 jbe	 SHORT $LN74@create_ckd
  01283	c7 84 24 b8 00
	00 00 07 00 00
	00		 mov	 DWORD PTR tv768[rsp], 7
  0128e	eb 0b		 jmp	 SHORT $LN75@create_ckd
$LN74@create_ckd:
  01290	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv768[rsp], 0
$LN75@create_ckd:
  0129b	b8 01 00 00 00	 mov	 eax, 1
  012a0	48 6b c0 51	 imul	 rax, rax, 81		; 00000051H
  012a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  012a9	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR tv768[rsp]
  012b1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 701  :                     pos[85] = trks > 65535 ? 1 : 0;           // DS4EFPTR + 03

  012b4	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  012bf	76 0d		 jbe	 SHORT $LN76@create_ckd
  012c1	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv773[rsp], 1
  012cc	eb 0b		 jmp	 SHORT $LN77@create_ckd
$LN76@create_ckd:
  012ce	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv773[rsp], 0
$LN77@create_ckd:
  012d9	b8 01 00 00 00	 mov	 eax, 1
  012de	48 6b c0 55	 imul	 rax, rax, 85		; 00000055H
  012e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  012e7	0f b6 94 24 bc
	00 00 00	 movzx	 edx, BYTE PTR tv773[rsp]
  012ef	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 702  :                     pos[86] = trks > 65535 ? 3 : 0;           // DS4EFPTR + 04

  012f2	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  012fd	76 0d		 jbe	 SHORT $LN78@create_ckd
  012ff	c7 84 24 c0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv778[rsp], 3
  0130a	eb 0b		 jmp	 SHORT $LN79@create_ckd
$LN78@create_ckd:
  0130c	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv778[rsp], 0
$LN79@create_ckd:
  01317	b8 01 00 00 00	 mov	 eax, 1
  0131c	48 6b c0 56	 imul	 rax, rax, 86		; 00000056H
  01320	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01325	0f b6 94 24 c0
	00 00 00	 movzx	 edx, BYTE PTR tv778[rsp]
  0132d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 703  :                     pos += 96;

  01330	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01335	48 83 c0 60	 add	 rax, 96			; 00000060H
  01339	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 704  : 
; 705  :                     /* build format 5 dscb */
; 706  :                     rechdr = (CKD_RECHDR*)pos;

  0133e	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01343	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 707  :                     pos += CKD_RECHDR_SIZE;

  01348	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0134d	48 83 c0 08	 add	 rax, 8
  01351	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 708  : 
; 709  :                     /* track 1 record 1 count */
; 710  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  01356	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  0135b	e8 00 00 00 00	 call	 _byteswap_ushort
  01360	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01365	0f b7 d0	 movzx	 edx, ax
  01368	e8 00 00 00 00	 call	 store_hw_noswap

; 711  :                     store_hw( rechdr->head, (U16) head );

  0136d	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  01375	e8 00 00 00 00	 call	 _byteswap_ushort
  0137a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0137f	48 83 c1 02	 add	 rcx, 2
  01383	0f b7 d0	 movzx	 edx, ax
  01386	e8 00 00 00 00	 call	 store_hw_noswap

; 712  :                               rechdr->rec  = r;

  0138b	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01390	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  01395	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 713  :                               rechdr->klen = 44;

  01398	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0139d	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 714  :                     store_hw( rechdr->dlen, 96 );

  013a1	66 b9 60 00	 mov	 cx, 96			; 00000060H
  013a5	e8 00 00 00 00	 call	 _byteswap_ushort
  013aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  013af	48 83 c1 06	 add	 rcx, 6
  013b3	0f b7 d0	 movzx	 edx, ax
  013b6	e8 00 00 00 00	 call	 store_hw_noswap

; 715  :                     r++;

  013bb	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  013c0	fe c0		 inc	 al
  013c2	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 716  : 
; 717  :                     /* track 1 record 2 key */
; 718  :                     memset (pos, 0x05, 4);                    // DS5KEYID

  013c6	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  013cb	b8 05 00 00 00	 mov	 eax, 5
  013d0	b9 04 00 00 00	 mov	 ecx, 4
  013d5	f3 aa		 rep stosb

; 719  :                     memset (pos+4, 0, 40);

  013d7	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  013dc	48 83 c0 04	 add	 rax, 4
  013e0	48 8b f8	 mov	 rdi, rax
  013e3	33 c0		 xor	 eax, eax
  013e5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  013ea	f3 aa		 rep stosb

; 720  :                     if (trks <= 65535)

  013ec	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  013f7	77 57		 ja	 SHORT $LN47@create_ckd

; 721  :                     {
; 722  :                         store_hw(pos+4, 2);                   // DS5AVEXT + 00

  013f9	66 b9 02 00	 mov	 cx, 2
  013fd	e8 00 00 00 00	 call	 _byteswap_ushort
  01402	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01407	48 83 c1 04	 add	 rcx, 4
  0140b	0f b7 d0	 movzx	 edx, ax
  0140e	e8 00 00 00 00	 call	 store_hw_noswap

; 723  :                         store_hw(pos+6, (U16)(volcyls - 1));  // DS5AVEXT + 02

  01413	8b 84 24 30 17
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0141a	ff c8		 dec	 eax
  0141c	0f b7 c8	 movzx	 ecx, ax
  0141f	e8 00 00 00 00	 call	 _byteswap_ushort
  01424	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  01429	48 83 c1 06	 add	 rcx, 6
  0142d	0f b7 d0	 movzx	 edx, ax
  01430	e8 00 00 00 00	 call	 store_hw_noswap

; 724  :                         pos[8] = (BYTE)(heads - 2);           // DS5AVEXT + 04

  01435	8b 84 24 08 17
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  0143c	83 e8 02	 sub	 eax, 2
  0143f	b9 01 00 00 00	 mov	 ecx, 1
  01444	48 6b c9 08	 imul	 rcx, rcx, 8
  01448	48 8b 54 24 68	 mov	 rdx, QWORD PTR pos$[rsp]
  0144d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN47@create_ckd:

; 725  :                     }
; 726  :                     pos += 44;

  01450	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01455	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  01459	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 727  : 
; 728  :                     /* track 1 record 2 data */
; 729  :                     memset (pos, 0, 96);

  0145e	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01463	33 c0		 xor	 eax, eax
  01465	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0146a	f3 aa		 rep stosb

; 730  :                     pos[0] = 0xf5;                            // DS5FMTID

  0146c	b8 01 00 00 00	 mov	 eax, 1
  01471	48 6b c0 00	 imul	 rax, rax, 0
  01475	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0147a	c6 04 01 f5	 mov	 BYTE PTR [rcx+rax], 245	; 000000f5H

; 731  :                     pos += 96;

  0147e	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01483	48 83 c0 60	 add	 rax, 96			; 00000060H
  01487	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 732  : 
; 733  :                     /* build format 7 dscb */
; 734  :                     if (trks > 65535)

  0148c	81 bc 24 98 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR trks$[rsp], 65535 ; 0000ffffH
  01497	0f 86 24 01 00
	00		 jbe	 $LN48@create_ckd

; 735  :                     {
; 736  :                         rechdr = (CKD_RECHDR*) pos;

  0149d	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  014a2	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 737  :                         pos += CKD_RECHDR_SIZE;

  014a7	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  014ac	48 83 c0 08	 add	 rax, 8
  014b0	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 738  : 
; 739  :                         /* track 1 record 3 count */
; 740  :                         store_hw( rechdr->cyl,  (U16) cyl  );

  014b5	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  014ba	e8 00 00 00 00	 call	 _byteswap_ushort
  014bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  014c4	0f b7 d0	 movzx	 edx, ax
  014c7	e8 00 00 00 00	 call	 store_hw_noswap

; 741  :                         store_hw( rechdr->head, (U16) head );

  014cc	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  014d4	e8 00 00 00 00	 call	 _byteswap_ushort
  014d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  014de	48 83 c1 02	 add	 rcx, 2
  014e2	0f b7 d0	 movzx	 edx, ax
  014e5	e8 00 00 00 00	 call	 store_hw_noswap

; 742  :                                   rechdr->rec  = r;

  014ea	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  014ef	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  014f4	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 743  :                                   rechdr->klen = 44;

  014f7	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  014fc	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 744  :                         store_hw( rechdr->dlen, 96 );

  01500	66 b9 60 00	 mov	 cx, 96			; 00000060H
  01504	e8 00 00 00 00	 call	 _byteswap_ushort
  01509	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0150e	48 83 c1 06	 add	 rcx, 6
  01512	0f b7 d0	 movzx	 edx, ax
  01515	e8 00 00 00 00	 call	 store_hw_noswap

; 745  :                         r++;

  0151a	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0151f	fe c0		 inc	 al
  01521	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 746  : 
; 747  :                         /* track 1 record 2 key */
; 748  :                         memset (pos, 0x07, 4);                // DS7KEYID

  01525	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  0152a	b8 07 00 00 00	 mov	 eax, 7
  0152f	b9 04 00 00 00	 mov	 ecx, 4
  01534	f3 aa		 rep stosb

; 749  :                         memset (pos+4, 0, 40);

  01536	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0153b	48 83 c0 04	 add	 rax, 4
  0153f	48 8b f8	 mov	 rdi, rax
  01542	33 c0		 xor	 eax, eax
  01544	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  01549	f3 aa		 rep stosb

; 750  :                         store_fw(pos+4, 2);                   // DS7EXTNT + 00

  0154b	b9 02 00 00 00	 mov	 ecx, 2
  01550	e8 00 00 00 00	 call	 _byteswap_ulong
  01555	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0155a	48 83 c1 04	 add	 rcx, 4
  0155e	8b d0		 mov	 edx, eax
  01560	e8 00 00 00 00	 call	 store_fw_noswap

; 751  :                         store_fw(pos+8, trks - 1);            // DS7EXTNT + 04

  01565	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR trks$[rsp]
  0156c	ff c8		 dec	 eax
  0156e	8b c8		 mov	 ecx, eax
  01570	e8 00 00 00 00	 call	 _byteswap_ulong
  01575	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0157a	48 83 c1 08	 add	 rcx, 8
  0157e	8b d0		 mov	 edx, eax
  01580	e8 00 00 00 00	 call	 store_fw_noswap

; 752  :                         pos += 44;

  01585	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0158a	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0158e	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 753  : 
; 754  :                         /* track 1 record 2 data */
; 755  :                         memset (pos, 0, 96);

  01593	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pos$[rsp]
  01598	33 c0		 xor	 eax, eax
  0159a	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0159f	f3 aa		 rep stosb

; 756  :                         pos[0] = 0xf7;                        // DS7FMTID

  015a1	b8 01 00 00 00	 mov	 eax, 1
  015a6	48 6b c0 00	 imul	 rax, rax, 0
  015aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  015af	c6 04 01 f7	 mov	 BYTE PTR [rcx+rax], 247	; 000000f7H

; 757  :                         pos += 96;

  015b3	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  015b8	48 83 c0 60	 add	 rax, 96			; 00000060H
  015bc	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax
$LN48@create_ckd:

; 758  :                     }
; 759  : 
; 760  :                     n = 12 - r + 1;

  015c1	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  015c6	b9 0c 00 00 00	 mov	 ecx, 12
  015cb	2b c8		 sub	 ecx, eax
  015cd	8b c1		 mov	 eax, ecx
  015cf	ff c0		 inc	 eax
  015d1	89 84 24 d4 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 761  :                     for (i = 0; i < n; i++)

  015d8	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  015e3	eb 10		 jmp	 SHORT $LN13@create_ckd
$LN11@create_ckd:
  015e5	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  015ec	ff c0		 inc	 eax
  015ee	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN13@create_ckd:
  015f5	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  015fc	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01603	0f 8d 9d 00 00
	00		 jge	 $LN12@create_ckd

; 762  :                     {
; 763  :                         rechdr = (CKD_RECHDR*) pos;

  01609	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0160e	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 764  :                         pos += CKD_RECHDR_SIZE;

  01613	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01618	48 83 c0 08	 add	 rax, 8
  0161c	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 765  :                         store_hw( rechdr->cyl,  (U16) cyl  );

  01621	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  01626	e8 00 00 00 00	 call	 _byteswap_ushort
  0162b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  01630	0f b7 d0	 movzx	 edx, ax
  01633	e8 00 00 00 00	 call	 store_hw_noswap

; 766  :                         store_hw( rechdr->head, (U16) head );

  01638	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  01640	e8 00 00 00 00	 call	 _byteswap_ushort
  01645	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0164a	48 83 c1 02	 add	 rcx, 2
  0164e	0f b7 d0	 movzx	 edx, ax
  01651	e8 00 00 00 00	 call	 store_hw_noswap

; 767  :                                   rechdr->rec  = r;

  01656	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0165b	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  01660	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 768  :                                   rechdr->klen = 44;

  01663	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  01668	c6 40 05 2c	 mov	 BYTE PTR [rax+5], 44	; 0000002cH

; 769  :                         store_hw( rechdr->dlen, 96 );

  0166c	66 b9 60 00	 mov	 cx, 96			; 00000060H
  01670	e8 00 00 00 00	 call	 _byteswap_ushort
  01675	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0167a	48 83 c1 06	 add	 rcx, 6
  0167e	0f b7 d0	 movzx	 edx, ax
  01681	e8 00 00 00 00	 call	 store_hw_noswap

; 770  :                         pos += 140;

  01686	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  0168b	48 05 8c 00 00
	00		 add	 rax, 140		; 0000008cH
  01691	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 771  :                         r++;

  01696	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0169b	fe c0		 inc	 al
  0169d	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 772  :                     }

  016a1	e9 3f ff ff ff	 jmp	 $LN11@create_ckd
$LN12@create_ckd:

; 773  :                 }

  016a6	e9 74 01 00 00	 jmp	 $LN46@create_ckd
$LN45@create_ckd:

; 774  : 
; 775  :                 /* Specific null track formatting */
; 776  :                 else if (nullfmt == CKD_NULLTRK_FMT0)

  016ab	0f b6 84 24 58
	17 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  016b3	85 c0		 test	 eax, eax
  016b5	0f 85 8b 00 00
	00		 jne	 $LN49@create_ckd

; 777  :                 {
; 778  :                     rechdr = (CKD_RECHDR*) pos;

  016bb	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  016c0	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 779  :                     pos += CKD_RECHDR_SIZE;

  016c5	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  016ca	48 83 c0 08	 add	 rax, 8
  016ce	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 780  :                     store_hw( rechdr->cyl,  (U16) cyl  );

  016d3	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  016d8	e8 00 00 00 00	 call	 _byteswap_ushort
  016dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  016e2	0f b7 d0	 movzx	 edx, ax
  016e5	e8 00 00 00 00	 call	 store_hw_noswap

; 781  :                     store_hw( rechdr->head, (U16) head );

  016ea	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  016f2	e8 00 00 00 00	 call	 _byteswap_ushort
  016f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  016fc	48 83 c1 02	 add	 rcx, 2
  01700	0f b7 d0	 movzx	 edx, ax
  01703	e8 00 00 00 00	 call	 store_hw_noswap

; 782  :                               rechdr->rec  = r;

  01708	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0170d	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  01712	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 783  :                               rechdr->klen = 0;

  01715	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  0171a	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 784  :                     store_hw( rechdr->dlen, 0 );

  0171e	33 c9		 xor	 ecx, ecx
  01720	e8 00 00 00 00	 call	 _byteswap_ushort
  01725	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0172a	48 83 c1 06	 add	 rcx, 6
  0172e	0f b7 d0	 movzx	 edx, ax
  01731	e8 00 00 00 00	 call	 store_hw_noswap

; 785  :                     r++;

  01736	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  0173b	fe c0		 inc	 al
  0173d	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 786  :                 }

  01741	e9 d9 00 00 00	 jmp	 $LN50@create_ckd
$LN49@create_ckd:

; 787  :                 else if (nullfmt == CKD_NULLTRK_FMT2)

  01746	0f b6 84 24 58
	17 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  0174e	83 f8 02	 cmp	 eax, 2
  01751	0f 85 c8 00 00
	00		 jne	 $LN51@create_ckd

; 788  :                 {
; 789  :                     /* Other linux tracks have 12 4096 data records */
; 790  :                     for (i = 0; i < 12; i++)

  01757	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01762	eb 10		 jmp	 SHORT $LN16@create_ckd
$LN14@create_ckd:
  01764	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0176b	ff c0		 inc	 eax
  0176d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@create_ckd:
  01774	83 bc 24 8c 00
	00 00 0c	 cmp	 DWORD PTR i$[rsp], 12
  0177c	0f 8d 9d 00 00
	00		 jge	 $LN15@create_ckd

; 791  :                     {
; 792  :                         rechdr = (CKD_RECHDR*) pos;

  01782	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01787	48 89 44 24 70	 mov	 QWORD PTR rechdr$[rsp], rax

; 793  :                         pos += CKD_RECHDR_SIZE;

  0178c	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01791	48 83 c0 08	 add	 rax, 8
  01795	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 794  :                         store_hw( rechdr->cyl,  (U16) cyl  );

  0179a	0f b7 4c 24 78	 movzx	 ecx, WORD PTR cyl$[rsp]
  0179f	e8 00 00 00 00	 call	 _byteswap_ushort
  017a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  017a9	0f b7 d0	 movzx	 edx, ax
  017ac	e8 00 00 00 00	 call	 store_hw_noswap

; 795  :                         store_hw( rechdr->head, (U16) head );

  017b1	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  017b9	e8 00 00 00 00	 call	 _byteswap_ushort
  017be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  017c3	48 83 c1 02	 add	 rcx, 2
  017c7	0f b7 d0	 movzx	 edx, ax
  017ca	e8 00 00 00 00	 call	 store_hw_noswap

; 796  :                                   rechdr->rec  = r;

  017cf	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  017d4	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR r$[rsp]
  017d9	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 797  :                                   rechdr->klen = 0;

  017dc	48 8b 44 24 70	 mov	 rax, QWORD PTR rechdr$[rsp]
  017e1	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 798  :                         store_hw( rechdr->dlen, CKD_NULL_FMT2_DLEN );

  017e5	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  017e9	e8 00 00 00 00	 call	 _byteswap_ushort
  017ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rechdr$[rsp]
  017f3	48 83 c1 06	 add	 rcx, 6
  017f7	0f b7 d0	 movzx	 edx, ax
  017fa	e8 00 00 00 00	 call	 store_hw_noswap

; 799  :                         pos +=                  CKD_NULL_FMT2_DLEN;

  017ff	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01804	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0180a	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 800  :                         r++;

  0180f	0f b6 44 24 60	 movzx	 eax, BYTE PTR r$[rsp]
  01814	fe c0		 inc	 al
  01816	88 44 24 60	 mov	 BYTE PTR r$[rsp], al

; 801  :                     }

  0181a	e9 45 ff ff ff	 jmp	 $LN14@create_ckd
$LN15@create_ckd:
$LN51@create_ckd:
$LN50@create_ckd:
$LN46@create_ckd:
$LN41@create_ckd:

; 802  :                 }
; 803  : 
; 804  :                 /* End-of-track marker */
; 805  :                 memcpy( pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  0181f	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01824	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  0182b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 806  :                 pos +=                    CKD_ENDTRK_SIZE;

  0182e	48 8b 44 24 68	 mov	 rax, QWORD PTR pos$[rsp]
  01833	48 83 c0 08	 add	 rax, 8
  01837	48 89 44 24 68	 mov	 QWORD PTR pos$[rsp], rax

; 807  : 
; 808  :                 /* Calculate length to write */
; 809  :                 if (comp == 0xff)

  0183c	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01844	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01849	75 13		 jne	 SHORT $LN52@create_ckd

; 810  :                     len = (int)trksize;

  0184b	8b 84 24 10 17
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  01852	89 84 24 9c 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  01859	e9 88 00 00 00	 jmp	 $LN53@create_ckd
$LN52@create_ckd:

; 811  :                 else
; 812  :                 {
; 813  :                     len = (int)(pos - buf);

  0185e	48 8b 84 24 18
	17 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  01866	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pos$[rsp]
  0186b	48 2b c8	 sub	 rcx, rax
  0186e	48 8b c1	 mov	 rax, rcx
  01871	89 84 24 9c 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 814  :                     l2[trk].L2_trkoff = cpos;

  01878	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0187f	48 6b c0 10	 imul	 rax, rax, 16
  01883	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR cpos$[rsp]
  0188b	48 89 8c 04 80
	05 00 00	 mov	 QWORD PTR l2$[rsp+rax], rcx

; 815  :                     l2[trk].L2_len    = l2[trk].L2_size  = (U16) len;

  01893	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0189a	48 6b c0 10	 imul	 rax, rax, 16
  0189e	0f b7 8c 24 9c
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  018a6	66 89 8c 04 8a
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+10], cx
  018ae	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  018b5	48 6b c0 10	 imul	 rax, rax, 16
  018b9	0f b7 8c 24 9c
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  018c1	66 89 8c 04 88
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+8], cx

; 816  :                     cpos += len;

  018c9	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  018d0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR cpos$[rsp]
  018d8	48 03 c8	 add	 rcx, rax
  018db	48 8b c1	 mov	 rax, rcx
  018de	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR cpos$[rsp], rax
$LN53@create_ckd:

; 817  :                 }
; 818  : 
; 819  :                 /* Write the track to the file */
; 820  :                 rc = write (fd, buf, len);

  018e6	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  018ee	48 8b 94 24 18
	17 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  018f6	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  018fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01903	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 821  :                 if (rc != (int)len)

  01907	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0190e	39 44 24 7c	 cmp	 DWORD PTR rc$[rsp], eax
  01912	0f 84 bb 00 00
	00		 je	 $LN54@create_ckd

; 822  :                 {
; 823  :                     FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0191e	83 38 00	 cmp	 DWORD PTR [rax], 0
  01921	74 18		 je	 SHORT $LN80@create_ckd
  01923	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01929	8b 08		 mov	 ecx, DWORD PTR [rax]
  0192b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01931	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv988[rsp], rax
  01939	eb 0f		 jmp	 SHORT $LN81@create_ckd
$LN80@create_ckd:
  0193b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169112
  01942	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv988[rsp], rax
$LN81@create_ckd:
  0194a	b9 02 00 00 00	 mov	 ecx, 2
  0194f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01955	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv988[rsp]
  0195d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01962	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169113
  01969	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0196e	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01976	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0197b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01984	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0198d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169114
  01994	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01999	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  019a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  019b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169116
  019b7	ba 38 03 00 00	 mov	 edx, 824		; 00000338H
  019bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169117
  019c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 824  :                             "write()", errno ? strerror( errno ) : "incomplete" );
; 825  :                     return -1;

  019c9	b8 ff ff ff ff	 mov	 eax, -1
  019ce	e9 80 05 00 00	 jmp	 $LN1@create_ckd
$LN54@create_ckd:

; 826  :                 }
; 827  : 
; 828  :                 /* Exit if compressed disk and current track is 1 */
; 829  :                 if (comp != 0xff && trk == 1) break;

  019d3	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  019db	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  019e0	74 0c		 je	 SHORT $LN55@create_ckd
  019e2	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR trk$[rsp], 1
  019ea	75 02		 jne	 SHORT $LN55@create_ckd
  019ec	eb 15		 jmp	 SHORT $LN6@create_ckd
$LN55@create_ckd:

; 830  : 
; 831  :                 trk++;

  019ee	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  019f5	ff c0		 inc	 eax
  019f7	89 84 24 90 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 832  : 
; 833  :             } /* end for(head) */

  019fe	e9 e6 f0 ff ff	 jmp	 $LN5@create_ckd
$LN6@create_ckd:

; 834  : 
; 835  :             /* Exit if compressed disk */
; 836  :             if (comp != 0xff) break;

  01a03	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01a0b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01a10	74 02		 je	 SHORT $LN56@create_ckd
  01a12	eb 05		 jmp	 SHORT $LN3@create_ckd
$LN56@create_ckd:

; 837  : 
; 838  :         } /* end for(cyl) */

  01a14	e9 40 f0 ff ff	 jmp	 $LN2@create_ckd
$LN3@create_ckd:

; 839  : 
; 840  :     } /* `dasdcopy' bit is off */

  01a19	eb 0d		 jmp	 SHORT $LN36@create_ckd
$LN35@create_ckd:

; 841  :     else
; 842  :         cyl = end + 1;

  01a1b	8b 84 24 28 17
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  01a22	ff c0		 inc	 eax
  01a24	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN36@create_ckd:

; 843  : 
; 844  :     /* Complete building the compressed file */
; 845  :     if (comp != 0xff)

  01a28	0f b6 84 24 48
	17 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  01a30	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01a35	0f 84 c8 03 00
	00		 je	 $LN57@create_ckd

; 846  :     {
; 847  :         cdevhdr.cdh_size = cdevhdr.cdh_used = cpos;

  01a3b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR cpos$[rsp]
  01a43	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR cdevhdr$[rsp+24], rax
  01a4b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR cdevhdr$[rsp+24]
  01a53	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR cdevhdr$[rsp+16], rax

; 848  : 
; 849  :         /* Rewrite the compressed device header */
; 850  :         rcoff = lseek (fd, CKD_DEVHDR_SIZE, SEEK_SET);

  01a5b	45 33 c0	 xor	 r8d, r8d
  01a5e	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  01a63	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01a6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01a70	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax

; 851  :         if ((S64)rcoff == -1)

  01a78	48 83 bc 24 e8
	00 00 00 ff	 cmp	 QWORD PTR rcoff$[rsp], -1
  01a81	0f 85 9f 00 00
	00		 jne	 $LN58@create_ckd

; 852  :         {
; 853  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01a87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01a8d	8b 08		 mov	 ecx, DWORD PTR [rax]
  01a8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01a95	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv1017[rsp], rax
  01a9d	b9 02 00 00 00	 mov	 ecx, 2
  01aa2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01aa8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv1017[rsp]
  01ab0	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01ab5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169122
  01abc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01ac1	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01ac9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01ace	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01ad7	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01ae0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169123
  01ae7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01aec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169124
  01af3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01af8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01afd	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b03	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169125
  01b0a	ba 56 03 00 00	 mov	 edx, 854		; 00000356H
  01b0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169126
  01b16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 854  :                     "lseek()", strerror( errno ));
; 855  :             return -1;

  01b1c	b8 ff ff ff ff	 mov	 eax, -1
  01b21	e9 2d 04 00 00	 jmp	 $LN1@create_ckd
$LN58@create_ckd:

; 856  :         }
; 857  :         rc = write (fd, &cdevhdr, CCKD64_DEVHDR_SIZE);

  01b26	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01b2c	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  01b34	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01b3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01b41	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 858  :         if (rc < (int)            CCKD64_DEVHDR_SIZE)

  01b45	81 7c 24 7c 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  01b4d	0f 8d bb 00 00
	00		 jge	 $LN59@create_ckd

; 859  :         {
; 860  :           FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01b53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b59	83 38 00	 cmp	 DWORD PTR [rax], 0
  01b5c	74 18		 je	 SHORT $LN82@create_ckd
  01b5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b64	8b 08		 mov	 ecx, DWORD PTR [rax]
  01b66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01b6c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv1044[rsp], rax
  01b74	eb 0f		 jmp	 SHORT $LN83@create_ckd
$LN82@create_ckd:
  01b76	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169128
  01b7d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv1044[rsp], rax
$LN83@create_ckd:
  01b85	b9 02 00 00 00	 mov	 ecx, 2
  01b8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b90	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv1044[rsp]
  01b98	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01b9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169129
  01ba4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01ba9	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01bb1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01bb6	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01bbf	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01bc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169130
  01bcf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169131
  01bdb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01be0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01be5	41 b9 03 00 00
	00		 mov	 r9d, 3
  01beb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169132
  01bf2	ba 5d 03 00 00	 mov	 edx, 861		; 0000035dH
  01bf7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169133
  01bfe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 861  :                   "write()", errno ? strerror( errno ) : "incomplete" );
; 862  :             return -1;

  01c04	b8 ff ff ff ff	 mov	 eax, -1
  01c09	e9 45 03 00 00	 jmp	 $LN1@create_ckd
$LN59@create_ckd:

; 863  :         }
; 864  : 
; 865  :         /* Rewrite the secondary lookup table */
; 866  :         rcoff = lseek (fd, l1[0], SEEK_SET);

  01c0e	b8 08 00 00 00	 mov	 eax, 8
  01c13	48 6b c0 00	 imul	 rax, rax, 0
  01c17	45 33 c0	 xor	 r8d, r8d
  01c1a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  01c22	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  01c26	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01c2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01c33	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax

; 867  :         if ((S64)rcoff == -1)

  01c3b	48 83 bc 24 e8
	00 00 00 ff	 cmp	 QWORD PTR rcoff$[rsp], -1
  01c44	0f 85 9f 00 00
	00		 jne	 $LN60@create_ckd

; 868  :         {
; 869  :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01c4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01c50	8b 08		 mov	 ecx, DWORD PTR [rax]
  01c52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01c58	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv1098[rsp], rax
  01c60	b9 02 00 00 00	 mov	 ecx, 2
  01c65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c6b	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv1098[rsp]
  01c73	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01c78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169135
  01c7f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01c84	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01c8c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01c91	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01c9a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01ca3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169136
  01caa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01caf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169137
  01cb6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01cbb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01cc0	41 b9 03 00 00
	00		 mov	 r9d, 3
  01cc6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169138
  01ccd	ba 66 03 00 00	 mov	 edx, 870		; 00000366H
  01cd2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  01cd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 870  :                     "lseek()", strerror( errno ));
; 871  :             return -1;

  01cdf	b8 ff ff ff ff	 mov	 eax, -1
  01ce4	e9 6a 02 00 00	 jmp	 $LN1@create_ckd
$LN60@create_ckd:

; 872  :         }
; 873  :         rc = write (fd, &l2, CCKD64_L2TAB_SIZE);

  01ce9	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  01cef	48 8d 94 24 80
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  01cf7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01cfe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01d04	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 874  :         if (rc < (int)       CCKD64_L2TAB_SIZE)

  01d08	81 7c 24 7c 00
	10 00 00	 cmp	 DWORD PTR rc$[rsp], 4096 ; 00001000H
  01d10	0f 8d bb 00 00
	00		 jge	 $LN61@create_ckd

; 875  :         {
; 876  :           FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01d16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01d1c	83 38 00	 cmp	 DWORD PTR [rax], 0
  01d1f	74 18		 je	 SHORT $LN84@create_ckd
  01d21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01d27	8b 08		 mov	 ecx, DWORD PTR [rax]
  01d29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01d2f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv1125[rsp], rax
  01d37	eb 0f		 jmp	 SHORT $LN85@create_ckd
$LN84@create_ckd:
  01d39	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169141
  01d40	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv1125[rsp], rax
$LN85@create_ckd:
  01d48	b9 02 00 00 00	 mov	 ecx, 2
  01d4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d53	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv1125[rsp]
  01d5b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01d60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169142
  01d67	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01d6c	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01d74	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01d79	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01d82	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01d8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169143
  01d92	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169144
  01d9e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01da3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01da8	41 b9 03 00 00
	00		 mov	 r9d, 3
  01dae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169145
  01db5	ba 6d 03 00 00	 mov	 edx, 877		; 0000036dH
  01dba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169146
  01dc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 877  :                   "write()", errno ? strerror( errno ) : "incomplete" );
; 878  :             return -1;

  01dc7	b8 ff ff ff ff	 mov	 eax, -1
  01dcc	e9 82 01 00 00	 jmp	 $LN1@create_ckd
$LN61@create_ckd:

; 879  :         }
; 880  :         rc = ftruncate(fd, cdevhdr.cdh_size);

  01dd1	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR cdevhdr$[rsp+16]
  01dd9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01de0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  01de6	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 881  : 
; 882  :         free (l1);

  01dea	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l1$[rsp]
  01df2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 883  :         cyl = volcyls;

  01df8	8b 84 24 30 17
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  01dff	89 44 24 78	 mov	 DWORD PTR cyl$[rsp], eax
$LN57@create_ckd:

; 884  :     }
; 885  : 
; 886  :     /* Close the DASD image file */
; 887  :     rc = close (fd);

  01e03	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01e0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  01e10	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 888  :     if (rc < 0)

  01e14	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  01e19	0f 8d 9f 00 00
	00		 jge	 $LN62@create_ckd

; 889  :     {
; 890  :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  01e1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01e25	8b 08		 mov	 ecx, DWORD PTR [rax]
  01e27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01e2d	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv1147[rsp], rax
  01e35	b9 02 00 00 00	 mov	 ecx, 2
  01e3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e40	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv1147[rsp]
  01e48	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01e4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169148
  01e54	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01e59	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01e61	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01e66	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01e6f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01e78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169149
  01e7f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169150
  01e8b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e90	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e95	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e9b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169151
  01ea2	ba 7b 03 00 00	 mov	 edx, 891		; 0000037bH
  01ea7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169152
  01eae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 891  :                 "close()", strerror( errno ));
; 892  :         return -1;

  01eb4	b8 ff ff ff ff	 mov	 eax, -1
  01eb9	e9 95 00 00 00	 jmp	 $LN1@create_ckd
$LN62@create_ckd:

; 893  :     }
; 894  : 
; 895  :     /* Display completion message */
; 896  :     // "%1d:%04X CKD64 file %s: %u %s successfully written"
; 897  :     FWRMSG( stdout, HHC00471, "I", 0, 0, fname,

  01ebe	8b 84 24 20 17
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  01ec5	8b 4c 24 78	 mov	 ecx, DWORD PTR cyl$[rsp]
  01ec9	2b c8		 sub	 ecx, eax
  01ecb	8b c1		 mov	 eax, ecx
  01ecd	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv1165[rsp], eax
  01ed4	b9 01 00 00 00	 mov	 ecx, 1
  01ed9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01edf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169153
  01ee6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01eeb	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv1165[rsp]
  01ef2	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01ef6	48 8b 8c 24 f0
	16 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  01efe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01f03	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01f0c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  01f15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169154
  01f1c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169155
  01f28	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f2d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f32	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f38	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169156
  01f3f	ba 82 03 00 00	 mov	 edx, 898		; 00000382H
  01f44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169157
  01f4b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 898  :             cyl - start, "cylinders" );
; 899  :     return 0;

  01f51	33 c0		 xor	 eax, eax
$LN1@create_ckd:

; 900  : 
; 901  : } /* end function create_ckd64_file */

  01f53	48 8b 8c 24 c0
	16 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01f5b	48 33 cc	 xor	 rcx, rsp
  01f5e	e8 00 00 00 00	 call	 __security_check_cookie
  01f63	48 81 c4 d8 16
	00 00		 add	 rsp, 5848		; 000016d8H
  01f6a	5f		 pop	 rdi
  01f6b	5e		 pop	 rsi
  01f6c	c3		 ret	 0
create_ckd64_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
rc$ = 112
fd$ = 116
l1tabsz$ = 120
len2$ = 124
num_L1tab$ = 128
x$ = 132
blkgrps$ = 136
tv155 = 140
l1$ = 144
blkghdr$ = 152
rcoff$ = 160
tv153 = 168
tv214 = 176
tv295 = 184
tv329 = 192
tv364 = 200
tv449 = 208
tv471 = 216
tv511 = 224
tv560 = 232
tv76 = 240
tv133 = 248
tv312 = 256
fbavol1$1 = 264
tv484 = 272
tv533 = 280
tv610 = 288
cdevhdr$ = 304
devhdr$ = 816
l2$ = 1328
pathname$ = 5424
buf$ = 5696
__$ArrayPad$ = 71232
fname$ = 71264
devtype$ = 71272
sectsz$ = 71280
sectors$ = 71288
volser$ = 71296
comp$ = 71304
lfs$ = 71312
dasdcopy$ = 71320
rawflag$ = 71328
create_compressed_fba64 PROC

; 1263 : {

$LN37:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 50 16 01 00	 mov	 eax, 71248		; 00011650H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 40
	16 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1264 :     int              rc;                /* Return code               */
; 1265 :     U64              rcoff;             /* Return value from lseek() */
; 1266 :     int              fd;                /* File descriptor           */
; 1267 :     CKD_DEVHDR       devhdr;            /* Device header             */
; 1268 :     CCKD64_DEVHDR    cdevhdr;           /* Compressed device header  */
; 1269 :     FBA_BKGHDR*      blkghdr;           /* Block Group Header        */
; 1270 :     int              blkgrps;           /* Number block groups       */
; 1271 :     int              num_L1tab, l1tabsz;/* Level 1 entries, size     */
; 1272 :     CCKD64_L1ENT*    l1;                /* Level 1 table pointer     */
; 1273 :     CCKD64_L2ENT     l2[256];           /* Level 2 table             */
; 1274 :     unsigned long    len2;              /* Compressed buffer length  */
; 1275 : #if defined( HAVE_ZLIB )
; 1276 :     BYTE             buf2[256];         /* Compressed buffer         */
; 1277 : #endif
; 1278 :     BYTE             buf[65536];        /* Buffer                    */
; 1279 :     int              x = O_EXCL;        /* Open option               */

  00034	c7 84 24 84 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H
$LN4@create_com:

; 1280 :     char             pathname[MAX_PATH];/* file path in host format  */
; 1281 : 
; 1282 :     UNREFERENCED( lfs );

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 fa		 jne	 SHORT $LN4@create_com

; 1283 : 
; 1284 :     /* Calculate the size of the level 1 table */
; 1285 :     blkgrps   = (sectors / CFBA_BLKS_PER_GRP) + 1;

  00045	33 d2		 xor	 edx, edx
  00047	8b 84 24 78 16
	01 00		 mov	 eax, DWORD PTR sectors$[rsp]
  0004e	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00053	f7 f1		 div	 ecx
  00055	ff c0		 inc	 eax
  00057	89 84 24 88 00
	00 00		 mov	 DWORD PTR blkgrps$[rsp], eax

; 1286 :     num_L1tab = (blkgrps + 255) / 256;

  0005e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR blkgrps$[rsp]
  00065	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  0006a	99		 cdq
  0006b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00071	03 c2		 add	 eax, edx
  00073	c1 f8 08	 sar	 eax, 8
  00076	89 84 24 80 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax

; 1287 :     l1tabsz   = num_L1tab * CCKD64_L1ENT_SIZE;

  0007d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00085	48 c1 e0 03	 shl	 rax, 3
  00089	89 44 24 78	 mov	 DWORD PTR l1tabsz$[rsp], eax

; 1288 : 
; 1289 :     if (l1tabsz > 65536)

  0008d	81 7c 24 78 00
	00 01 00	 cmp	 DWORD PTR l1tabsz$[rsp], 65536 ; 00010000H
  00095	0f 8e a2 00 00
	00		 jle	 $LN5@create_com

; 1290 :     {
; 1291 :         // "%1d:%04X CKD file %s: file size too large: %"PRIu64" [%d]"
; 1292 :         FWRMSG( stderr, HHC00464, "E", 0, 0, fname,

  0009b	8b 84 24 78 16
	01 00		 mov	 eax, DWORD PTR sectors$[rsp]
  000a2	8b 8c 24 70 16
	01 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  000a9	48 0f af c1	 imul	 rax, rcx
  000ad	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
  000b5	b9 02 00 00 00	 mov	 ecx, 2
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR num_L1tab$[rsp]
  000c7	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000d3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d8	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000e0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000ee	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169501
  000fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169502
  0010a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00114	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169503
  00121	ba 0d 05 00 00	 mov	 edx, 1293		; 0000050dH
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169504
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1293 :                 ((U64)sectors * sectsz), num_L1tab );
; 1294 :         return -1;

  00133	b8 ff ff ff ff	 mov	 eax, -1
  00138	e9 f7 0d 00 00	 jmp	 $LN1@create_com
$LN5@create_com:

; 1295 :     }
; 1296 : 
; 1297 :     /* if 'dasdcopy' > 1 then we can replace the existing file */
; 1298 :     if (dasdcopy > 1)

  0013d	83 bc 24 98 16
	01 00 01	 cmp	 DWORD PTR dasdcopy$[rsp], 1
  00145	7e 0b		 jle	 SHORT $LN6@create_com

; 1299 :         x = 0;

  00147	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN6@create_com:

; 1300 : 
; 1301 :     /* Create the DASD image file */
; 1302 :     hostpath( pathname, fname, sizeof( pathname ));

  00152	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00158	48 8b 94 24 60
	16 01 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00160	48 8d 8c 24 30
	15 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1303 :     fd = HOPEN( pathname,

  0016e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00175	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  0017a	0f ba e8 0f	 bts	 eax, 15
  0017e	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00184	8b d0		 mov	 edx, eax
  00186	48 8d 8c 24 30
	15 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00194	89 44 24 74	 mov	 DWORD PTR fd$[rsp], eax

; 1304 :         0
; 1305 :             | O_WRONLY
; 1306 :             | O_CREAT
; 1307 :             | x
; 1308 :             | O_BINARY
; 1309 :         ,
; 1310 :         0
; 1311 :             | S_IRUSR
; 1312 :             | S_IWUSR
; 1313 :             | S_IRGRP
; 1314 :     );
; 1315 : 
; 1316 :     if (fd < 0)

  00198	83 7c 24 74 00	 cmp	 DWORD PTR fd$[rsp], 0
  0019d	0f 8d 9f 00 00
	00		 jge	 $LN7@create_com

; 1317 :     {
; 1318 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1319 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a9	8b 08		 mov	 ecx, DWORD PTR [rax]
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b1	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001b9	b9 02 00 00 00	 mov	 ecx, 2
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001cc	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169507
  001d8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001dd	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001e5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ea	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  001f3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169508
  00203	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169509
  0020f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169510
  00226	ba 28 05 00 00	 mov	 edx, 1320		; 00000528H
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169511
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1320 :             "open()", strerror( errno ));
; 1321 :         return -1;

  00238	b8 ff ff ff ff	 mov	 eax, -1
  0023d	e9 f2 0c 00 00	 jmp	 $LN1@create_com
$LN7@create_com:

; 1322 :     }
; 1323 : 
; 1324 :     /* Display progress message */
; 1325 :     // "%1d:%04X FBA64 file %s: creating %4.4X compressed volume %s: %u sectors, %u bytes/sector"
; 1326 :     FWRMSG( stdout, HHC00474, "I", 0, 0, fname,

  00242	83 bc 24 a0 16
	01 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  0024a	74 11		 je	 SHORT $LN21@create_com
  0024c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169512
  00253	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  0025b	eb 10		 jmp	 SHORT $LN22@create_com
$LN21@create_com:
  0025d	48 8b 84 24 80
	16 01 00	 mov	 rax, QWORD PTR volser$[rsp]
  00265	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
$LN22@create_com:
  0026d	0f b7 84 24 68
	16 01 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00275	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  0027c	b9 01 00 00 00	 mov	 ecx, 1
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00287	8b 8c 24 70 16
	01 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  0028e	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00292	8b 8c 24 78 16
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  00299	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0029d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  002a5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002aa	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  002b1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b5	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002bd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  002cb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169513
  002db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169514
  002e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169515
  002fe	ba 2f 05 00 00	 mov	 edx, 1327		; 0000052fH
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169516
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1327 :         devtype, rawflag ? "" : volser, sectors, sectsz );
; 1328 : 
; 1329 :     /* Create the device header */
; 1330 :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  00310	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00318	48 8b f8	 mov	 rdi, rax
  0031b	33 c0		 xor	 eax, eax
  0031d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00322	f3 aa		 rep stosb

; 1331 :     gen_dasd_serial( devhdr.dh_serial );

  00324	48 8d 8c 24 44
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+20]
  0032c	e8 00 00 00 00	 call	 gen_dasd_serial

; 1332 :     memcpy(  devhdr.dh_devid, dh_devid_str( FBA_C064_TYP ), 8 );

  00331	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00336	e8 00 00 00 00	 call	 dh_devid_str
  0033b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033e	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR devhdr$[rsp], rax

; 1333 : 
; 1334 :     STORE_LE_FW( devhdr.dh_heads,   sectors );

  00346	8b 8c 24 78 16
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0034d	e8 00 00 00 00	 call	 _byteswap_ulong
  00352	8b c8		 mov	 ecx, eax
  00354	e8 00 00 00 00	 call	 _byteswap_ulong
  00359	8b d0		 mov	 edx, eax
  0035b	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  00363	e8 00 00 00 00	 call	 store_fw_noswap

; 1335 :     STORE_LE_FW( devhdr.dh_trksize, sectsz  );

  00368	8b 8c 24 70 16
	01 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  0036f	e8 00 00 00 00	 call	 _byteswap_ulong
  00374	8b c8		 mov	 ecx, eax
  00376	e8 00 00 00 00	 call	 _byteswap_ulong
  0037b	8b d0		 mov	 edx, eax
  0037d	48 8d 8c 24 3c
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  00385	e8 00 00 00 00	 call	 store_fw_noswap

; 1336 : 
; 1337 :     devhdr.dh_devtyp  = devtype & 0xFF;

  0038a	0f b7 84 24 68
	16 01 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00392	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00397	88 84 24 40 03
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 1338 :     devhdr.dh_fileseq = 0;

  0039e	c6 84 24 41 03
	00 00 00	 mov	 BYTE PTR devhdr$[rsp+17], 0

; 1339 : 
; 1340 :     STORE_LE_HW( devhdr.dh_highcyl, 0 );

  003a6	33 c9		 xor	 ecx, ecx
  003a8	e8 00 00 00 00	 call	 _byteswap_ushort
  003ad	0f b7 c8	 movzx	 ecx, ax
  003b0	e8 00 00 00 00	 call	 _byteswap_ushort
  003b5	0f b7 d0	 movzx	 edx, ax
  003b8	48 8d 8c 24 42
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  003c0	e8 00 00 00 00	 call	 store_hw_noswap

; 1341 : 
; 1342 :     /* Write the device header */
; 1343 :     rc = write( fd, &devhdr, CKD_DEVHDR_SIZE );

  003c5	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  003cb	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  003d3	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  003dd	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1344 :     if (rc < (int) CKD_DEVHDR_SIZE)

  003e1	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  003e9	0f 8d bb 00 00
	00		 jge	 $LN8@create_com

; 1345 :     {
; 1346 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1347 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003f5	83 38 00	 cmp	 DWORD PTR [rax], 0
  003f8	74 18		 je	 SHORT $LN23@create_com
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00400	8b 08		 mov	 ecx, DWORD PTR [rax]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00408	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  00410	eb 0f		 jmp	 SHORT $LN24@create_com
$LN23@create_com:
  00412	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169518
  00419	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
$LN24@create_com:
  00421	b9 02 00 00 00	 mov	 ecx, 2
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv214[rsp]
  00434	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169519
  00440	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00445	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0044d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00452	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0045b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00464	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169520
  0046b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00470	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169521
  00477	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00481	41 b9 03 00 00
	00		 mov	 r9d, 3
  00487	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169522
  0048e	ba 44 05 00 00	 mov	 edx, 1348		; 00000544H
  00493	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169523
  0049a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1348 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1349 :         return -1;

  004a0	b8 ff ff ff ff	 mov	 eax, -1
  004a5	e9 8a 0a 00 00	 jmp	 $LN1@create_com
$LN8@create_com:

; 1350 :     }
; 1351 : 
; 1352 :     /* Build and Write the compressed device header */
; 1353 :     memset( &cdevhdr, 0, CCKD64_DEVHDR_SIZE );

  004aa	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR cdevhdr$[rsp]
  004b2	48 8b f8	 mov	 rdi, rax
  004b5	33 c0		 xor	 eax, eax
  004b7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  004bc	f3 aa		 rep stosb

; 1354 : 
; 1355 :     cdevhdr.cdh_vrm[0] = CCKD_VERSION;

  004be	b8 01 00 00 00	 mov	 eax, 1
  004c3	48 6b c0 00	 imul	 rax, rax, 0
  004c7	c6 84 04 30 01
	00 00 00	 mov	 BYTE PTR cdevhdr$[rsp+rax], 0

; 1356 :     cdevhdr.cdh_vrm[1] = CCKD_RELEASE;

  004cf	b8 01 00 00 00	 mov	 eax, 1
  004d4	48 6b c0 01	 imul	 rax, rax, 1
  004d8	c6 84 04 30 01
	00 00 03	 mov	 BYTE PTR cdevhdr$[rsp+rax], 3

; 1357 :     cdevhdr.cdh_vrm[2] = CCKD_MODLVL;

  004e0	b8 01 00 00 00	 mov	 eax, 1
  004e5	48 6b c0 02	 imul	 rax, rax, 2
  004e9	c6 84 04 30 01
	00 00 01	 mov	 BYTE PTR cdevhdr$[rsp+rax], 1

; 1358 : 
; 1359 :     if (cckd_def_opt_bigend())

  004f1	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  004f6	85 c0		 test	 eax, eax
  004f8	74 12		 je	 SHORT $LN9@create_com

; 1360 :         cdevhdr.cdh_opts |= CCKD_OPT_BIGEND;

  004fa	0f b6 84 24 33
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00502	83 c8 02	 or	 eax, 2
  00505	88 84 24 33 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al
$LN9@create_com:

; 1361 : 
; 1362 :     cdevhdr.cdh_opts     |= CCKD_OPT_OPENRW;

  0050c	0f b6 84 24 33
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00514	83 c8 40	 or	 eax, 64			; 00000040H
  00517	88 84 24 33 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+3], al

; 1363 :     cdevhdr.num_L1tab = num_L1tab;

  0051e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR num_L1tab$[rsp]
  00525	89 84 24 34 01
	00 00		 mov	 DWORD PTR cdevhdr$[rsp+4], eax

; 1364 :     cdevhdr.num_L2tab = 256;

  0052c	c7 84 24 38 01
	00 00 00 01 00
	00		 mov	 DWORD PTR cdevhdr$[rsp+8], 256 ; 00000100H

; 1365 : 
; 1366 :     STORE_LE_FW( cdevhdr.cdh_cyls, sectors );

  00537	8b 8c 24 78 16
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0053e	e8 00 00 00 00	 call	 _byteswap_ulong
  00543	8b c8		 mov	 ecx, eax
  00545	e8 00 00 00 00	 call	 _byteswap_ulong
  0054a	8b d0		 mov	 edx, eax
  0054c	48 8d 8c 24 3c
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+12]
  00554	e8 00 00 00 00	 call	 store_fw_noswap

; 1367 : 
; 1368 :     cdevhdr.cmp_algo  = comp;

  00559	0f b6 84 24 88
	16 01 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00561	88 84 24 79 01
	00 00		 mov	 BYTE PTR cdevhdr$[rsp+73], al

; 1369 :     cdevhdr.cmp_parm  = -1;

  00568	b8 ff ff ff ff	 mov	 eax, -1
  0056d	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR cdevhdr$[rsp+74], ax

; 1370 : 
; 1371 :     rc = write( fd, &cdevhdr, CCKD64_DEVHDR_SIZE);

  00575	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0057b	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00583	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0058d	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1372 :     if (rc < (int)            CCKD64_DEVHDR_SIZE)

  00591	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00599	0f 8d bb 00 00
	00		 jge	 $LN10@create_com

; 1373 :     {
; 1374 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1375 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0059f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005a5	83 38 00	 cmp	 DWORD PTR [rax], 0
  005a8	74 18		 je	 SHORT $LN25@create_com
  005aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005b0	8b 08		 mov	 ecx, DWORD PTR [rax]
  005b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005b8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
  005c0	eb 0f		 jmp	 SHORT $LN26@create_com
$LN25@create_com:
  005c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169526
  005c9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
$LN26@create_com:
  005d1	b9 02 00 00 00	 mov	 ecx, 2
  005d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005dc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv295[rsp]
  005e4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169527
  005f0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005f5	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005fd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00602	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0060b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169528
  0061b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00620	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169529
  00627	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0062c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00631	41 b9 03 00 00
	00		 mov	 r9d, 3
  00637	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169530
  0063e	ba 60 05 00 00	 mov	 edx, 1376		; 00000560H
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169531
  0064a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1376 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1377 :         return -1;

  00650	b8 ff ff ff ff	 mov	 eax, -1
  00655	e9 da 08 00 00	 jmp	 $LN1@create_com
$LN10@create_com:

; 1378 :     }
; 1379 : 
; 1380 :     /* Build and Write the level 1 table */
; 1381 :     l1 = (CCKD64_L1ENT*) &buf;

  0065a	48 8d 84 24 40
	16 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00662	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR l1$[rsp], rax

; 1382 :     memset( l1, 0, l1tabsz );

  0066a	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  0066f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv312[rsp], rax
  00677	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR l1$[rsp]
  0067f	33 c0		 xor	 eax, eax
  00681	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv312[rsp]
  00689	f3 aa		 rep stosb

; 1383 :     l1[0] = CKD_DEVHDR_SIZE + CCKD64_DEVHDR_SIZE + l1tabsz;

  0068b	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  00690	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00696	b9 08 00 00 00	 mov	 ecx, 8
  0069b	48 6b c9 00	 imul	 rcx, rcx, 0
  0069f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  006a7	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1384 :     rc = write( fd, l1, l1tabsz );

  006ab	44 8b 44 24 78	 mov	 r8d, DWORD PTR l1tabsz$[rsp]
  006b0	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR l1$[rsp]
  006b8	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  006bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  006c2	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1385 :     if (rc < l1tabsz)

  006c6	8b 44 24 78	 mov	 eax, DWORD PTR l1tabsz$[rsp]
  006ca	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  006ce	0f 8d bb 00 00
	00		 jge	 $LN11@create_com

; 1386 :     {
; 1387 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1388 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006da	83 38 00	 cmp	 DWORD PTR [rax], 0
  006dd	74 18		 je	 SHORT $LN27@create_com
  006df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006e5	8b 08		 mov	 ecx, DWORD PTR [rax]
  006e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006ed	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
  006f5	eb 0f		 jmp	 SHORT $LN28@create_com
$LN27@create_com:
  006f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169533
  006fe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
$LN28@create_com:
  00706	b9 02 00 00 00	 mov	 ecx, 2
  0070b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00711	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv329[rsp]
  00719	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0071e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169534
  00725	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0072a	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00732	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00737	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00740	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169535
  00750	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00755	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169536
  0075c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00761	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00766	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169537
  00773	ba 6d 05 00 00	 mov	 edx, 1389		; 0000056dH
  00778	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169538
  0077f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1389 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1390 :         return -1;

  00785	b8 ff ff ff ff	 mov	 eax, -1
  0078a	e9 a5 07 00 00	 jmp	 $LN1@create_com
$LN11@create_com:

; 1391 :     }
; 1392 : 
; 1393 :     /* Build and Write the 1st level 2 table */
; 1394 :     memset( &l2, 0, CCKD64_L2TAB_SIZE );

  0078f	48 8d 84 24 30
	05 00 00	 lea	 rax, QWORD PTR l2$[rsp]
  00797	48 8b f8	 mov	 rdi, rax
  0079a	33 c0		 xor	 eax, eax
  0079c	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  007a1	f3 aa		 rep stosb

; 1395 :     l2[0].L2_trkoff = CKD_DEVHDR_SIZE + CCKD64_DEVHDR_SIZE

  007a3	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  007a8	48 05 00 14 00
	00		 add	 rax, 5120		; 00001400H
  007ae	b9 10 00 00 00	 mov	 ecx, 16
  007b3	48 6b c9 00	 imul	 rcx, rcx, 0
  007b7	48 89 84 0c 30
	05 00 00	 mov	 QWORD PTR l2$[rsp+rcx], rax

; 1396 :         + l1tabsz + CCKD64_L2TAB_SIZE;
; 1397 :     rc = write( fd, &l2, CCKD64_L2TAB_SIZE);

  007bf	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  007c5	48 8d 94 24 30
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  007cd	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  007d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  007d7	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1398 :     if (rc < (int)       CCKD64_L2TAB_SIZE)

  007db	81 7c 24 70 00
	10 00 00	 cmp	 DWORD PTR rc$[rsp], 4096 ; 00001000H
  007e3	0f 8d bb 00 00
	00		 jge	 $LN12@create_com

; 1399 :     {
; 1400 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1401 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  007e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007ef	83 38 00	 cmp	 DWORD PTR [rax], 0
  007f2	74 18		 je	 SHORT $LN29@create_com
  007f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007fa	8b 08		 mov	 ecx, DWORD PTR [rax]
  007fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00802	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv364[rsp], rax
  0080a	eb 0f		 jmp	 SHORT $LN30@create_com
$LN29@create_com:
  0080c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169540
  00813	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv364[rsp], rax
$LN30@create_com:
  0081b	b9 02 00 00 00	 mov	 ecx, 2
  00820	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00826	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv364[rsp]
  0082e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00833	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169541
  0083a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0083f	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00847	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0084c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00855	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0085e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169542
  00865	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0086a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169543
  00871	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00876	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0087b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00881	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169544
  00888	ba 7a 05 00 00	 mov	 edx, 1402		; 0000057aH
  0088d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169545
  00894	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1402 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1403 :         return -1;

  0089a	b8 ff ff ff ff	 mov	 eax, -1
  0089f	e9 90 06 00 00	 jmp	 $LN1@create_com
$LN12@create_com:

; 1404 :     }
; 1405 : 
; 1406 :     /* Clear the first block group's image data to binary zeros */
; 1407 :     memset( &buf, 0, FBA_BKGHDR_SIZE + CFBA_BLKGRP_SIZE );

  008a4	48 8d 84 24 40
	16 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  008ac	48 8b f8	 mov	 rdi, rax
  008af	33 c0		 xor	 eax, eax
  008b1	b9 05 f0 00 00	 mov	 ecx, 61445		; 0000f005H
  008b6	f3 aa		 rep stosb

; 1408 : 
; 1409 :     /* Build the "Track Header" (FBA Block Group Header) */
; 1410 :     blkghdr = (FBA_BKGHDR*) &buf[0]; /* (--> block group header) */

  008b8	b8 01 00 00 00	 mov	 eax, 1
  008bd	48 6b c0 00	 imul	 rax, rax, 0
  008c1	48 8d 84 04 40
	16 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  008c9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR blkghdr$[rsp], rax

; 1411 :     blkghdr->cmp = CCKD_COMPRESS_NONE;   /* (until we know for sure) */

  008d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR blkghdr$[rsp]
  008d9	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1412 :     store_fw( blkghdr->blknum, 0 );      /* (group's starting block) */

  008dc	33 c9		 xor	 ecx, ecx
  008de	e8 00 00 00 00	 call	 _byteswap_ulong
  008e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR blkghdr$[rsp]
  008eb	48 ff c1	 inc	 rcx
  008ee	8b d0		 mov	 edx, eax
  008f0	e8 00 00 00 00	 call	 store_fw_noswap

; 1413 : 
; 1414 :     /* Build the VOL1 label if requested */
; 1415 :     if (!rawflag)

  008f5	83 bc 24 a0 16
	01 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  008fd	75 32		 jne	 SHORT $LN13@create_com

; 1416 :     {
; 1417 :         /* The VOL1 label is at physical sector number 1 */
; 1418 :         VOL1_FBA* fbavol1 = (VOL1_FBA*) &buf[ FBA_BKGHDR_SIZE + sectsz ];

  008ff	8b 84 24 70 16
	01 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  00906	48 8d 84 04 45
	16 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax+5]
  0090e	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR fbavol1$1[rsp], rax

; 1419 :         build_vol1( fbavol1, volser, NULL, false );

  00916	45 33 c9	 xor	 r9d, r9d
  00919	45 33 c0	 xor	 r8d, r8d
  0091c	48 8b 94 24 80
	16 01 00	 mov	 rdx, QWORD PTR volser$[rsp]
  00924	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR fbavol1$1[rsp]
  0092c	e8 00 00 00 00	 call	 build_vol1
$LN13@create_com:

; 1420 :     }
; 1421 : 
; 1422 :     /* Write the 1st block group */
; 1423 : #if defined( HAVE_ZLIB )
; 1424 :     len2 = sizeof( buf2 );
; 1425 :     if (1
; 1426 :         && CCKD_COMPRESS_ZLIB == (comp & CCKD_COMPRESS_MASK)
; 1427 :         && Z_OK == (rc = compress2( &buf2[0], &len2, &buf[ FBA_BKGHDR_SIZE ],
; 1428 :                                     CFBA_BLKGRP_SIZE, Z_DEFAULT_COMPRESSION ))
; 1429 :     )
; 1430 :     {
; 1431 :         blkghdr->cmp = CCKD_COMPRESS_ZLIB;
; 1432 : 
; 1433 :         /* Write out the FBA Block Group Header separately (since it
; 1434 :            was NOT compressed) followed by the compressed block group
; 1435 :            data (which WAS compressed)
; 1436 :         */
; 1437 :         rc = write( fd, &buf, FBA_BKGHDR_SIZE );
; 1438 :         if (rc < (int) FBA_BKGHDR_SIZE)
; 1439 :         {
; 1440 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 1441 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,
; 1442 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 1443 :             return -1;
; 1444 :         }
; 1445 : 
; 1446 :         /* Now write out the compressed block group data (the sectors) */
; 1447 :         rc = write( fd, &buf2, len2 );
; 1448 :         if (rc < (int) len2)
; 1449 :         {
; 1450 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 1451 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,
; 1452 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 1453 :             return -1;
; 1454 :         }
; 1455 :     }
; 1456 :     else
; 1457 : #endif // defined( HAVE_ZLIB )
; 1458 :     {
; 1459 :         len2 = CFBA_BLKGRP_SIZE;

  00931	c7 44 24 7c 00
	f0 00 00	 mov	 DWORD PTR len2$[rsp], 61440 ; 0000f000H

; 1460 :         blkghdr->cmp = CCKD_COMPRESS_NONE;

  00939	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR blkghdr$[rsp]
  00941	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1461 : 
; 1462 :         /* Write out both the FBA Block Group Header and the Block Group
; 1463 :            Data itself (i.e. all of the block group sectors) in one I/O.
; 1464 :         */
; 1465 :         rc = write( fd, &buf, FBA_BKGHDR_SIZE + len2 );

  00944	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00948	48 83 c0 05	 add	 rax, 5
  0094c	44 8b c0	 mov	 r8d, eax
  0094f	48 8d 94 24 40
	16 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00957	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  0095b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00961	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1466 :         if (rc < (int)(FBA_BKGHDR_SIZE + len2))

  00965	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00969	48 83 c0 05	 add	 rax, 5
  0096d	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  00971	0f 8d bb 00 00
	00		 jge	 $LN14@create_com

; 1467 :         {
; 1468 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 1469 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00977	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0097d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00980	74 18		 je	 SHORT $LN31@create_com
  00982	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00988	8b 08		 mov	 ecx, DWORD PTR [rax]
  0098a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00990	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv449[rsp], rax
  00998	eb 0f		 jmp	 SHORT $LN32@create_com
$LN31@create_com:
  0099a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169548
  009a1	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv449[rsp], rax
$LN32@create_com:
  009a9	b9 02 00 00 00	 mov	 ecx, 2
  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv449[rsp]
  009bc	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169549
  009c8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009cd	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  009d5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009da	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  009e3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  009ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169550
  009f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169551
  009ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a04	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a09	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a0f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169552
  00a16	ba be 05 00 00	 mov	 edx, 1470		; 000005beH
  00a1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169553
  00a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1470 :                 "write()", errno ? strerror( errno ) : "incomplete" );
; 1471 :             return -1;

  00a28	b8 ff ff ff ff	 mov	 eax, -1
  00a2d	e9 02 05 00 00	 jmp	 $LN1@create_com
$LN14@create_com:

; 1472 :         }
; 1473 :     }
; 1474 : 
; 1475 :     /* Update the L2 table entry for this block group */
; 1476 :     l2[0].L2_len = l2[0].L2_size = (U16)(FBA_BKGHDR_SIZE + len2);

  00a32	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  00a36	48 83 c0 05	 add	 rax, 5
  00a3a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv471[rsp], rax
  00a42	b8 10 00 00 00	 mov	 eax, 16
  00a47	48 6b c0 00	 imul	 rax, rax, 0
  00a4b	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR tv471[rsp]
  00a53	66 89 8c 04 3a
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+10], cx
  00a5b	b8 10 00 00 00	 mov	 eax, 16
  00a60	48 6b c0 00	 imul	 rax, rax, 0
  00a64	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR tv471[rsp]
  00a6c	66 89 8c 04 38
	05 00 00	 mov	 WORD PTR l2$[rsp+rax+8], cx

; 1477 : 
; 1478 :     /* Update compressed device header too */
; 1479 :     cdevhdr.cdh_size = cdevhdr.cdh_used = CKD_DEVHDR_SIZE +

  00a74	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  00a79	8b 4c 24 7c	 mov	 ecx, DWORD PTR len2$[rsp]
  00a7d	48 8d 84 08 05
	14 00 00	 lea	 rax, QWORD PTR [rax+rcx+5125]
  00a85	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR cdevhdr$[rsp+24], rax
  00a8d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR cdevhdr$[rsp+24]
  00a95	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR cdevhdr$[rsp+16], rax

; 1480 :                    CCKD64_DEVHDR_SIZE + l1tabsz + CCKD64_L2TAB_SIZE +
; 1481 :                    FBA_BKGHDR_SIZE + len2;
; 1482 : 
; 1483 :     /* Re-write the compressed device header */
; 1484 :     if ((S64)(rcoff = lseek( fd, CKD_DEVHDR_SIZE, SEEK_SET )) < 0)

  00a9d	45 33 c0	 xor	 r8d, r8d
  00aa0	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00aa5	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00aa9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00aaf	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax
  00ab7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rcoff$[rsp], 0
  00ac0	0f 8d 9f 00 00
	00		 jge	 $LN15@create_com

; 1485 :     {
; 1486 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1487 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00ac6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00acc	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ace	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ad4	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv484[rsp], rax
  00adc	b9 02 00 00 00	 mov	 ecx, 2
  00ae1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ae7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv484[rsp]
  00aef	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00af4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169555
  00afb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b00	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00b08	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b0d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00b16	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00b1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169556
  00b26	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169557
  00b32	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b37	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b3c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b42	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169558
  00b49	ba d0 05 00 00	 mov	 edx, 1488		; 000005d0H
  00b4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169559
  00b55	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1488 :                 "lseek()", strerror( errno ));
; 1489 :         return -1;

  00b5b	b8 ff ff ff ff	 mov	 eax, -1
  00b60	e9 cf 03 00 00	 jmp	 $LN1@create_com
$LN15@create_com:

; 1490 :     }
; 1491 :     rc = write( fd, &cdevhdr, CCKD64_DEVHDR_SIZE);

  00b65	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00b6b	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00b73	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00b77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00b7d	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1492 :     if (rc < (int)            CCKD64_DEVHDR_SIZE)

  00b81	81 7c 24 70 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00b89	0f 8d bb 00 00
	00		 jge	 $LN16@create_com

; 1493 :     {
; 1494 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1495 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00b8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b95	83 38 00	 cmp	 DWORD PTR [rax], 0
  00b98	74 18		 je	 SHORT $LN33@create_com
  00b9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ba0	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ba2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ba8	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
  00bb0	eb 0f		 jmp	 SHORT $LN34@create_com
$LN33@create_com:
  00bb2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169561
  00bb9	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
$LN34@create_com:
  00bc1	b9 02 00 00 00	 mov	 ecx, 2
  00bc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bcc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv511[rsp]
  00bd4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bd9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169562
  00be0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00be5	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00bed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bf2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00bfb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00c04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169563
  00c0b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169564
  00c17	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c1c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c21	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c27	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169565
  00c2e	ba d8 05 00 00	 mov	 edx, 1496		; 000005d8H
  00c33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169566
  00c3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1496 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1497 :         return -1;

  00c40	b8 ff ff ff ff	 mov	 eax, -1
  00c45	e9 ea 02 00 00	 jmp	 $LN1@create_com
$LN16@create_com:

; 1498 :     }
; 1499 : 
; 1500 :     /* Re-write the 1st level 2 table */
; 1501 :     if ((S64)(rcoff = lseek( fd, CKD_DEVHDR_SIZE + CCKD64_DEVHDR_SIZE + l1tabsz, SEEK_SET )) < 0)

  00c4a	48 63 44 24 78	 movsxd	 rax, DWORD PTR l1tabsz$[rsp]
  00c4f	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  00c55	45 33 c0	 xor	 r8d, r8d
  00c58	48 8b d0	 mov	 rdx, rax
  00c5b	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00c5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00c65	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rcoff$[rsp], rax
  00c6d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rcoff$[rsp], 0
  00c76	0f 8d 9f 00 00
	00		 jge	 $LN17@create_com

; 1502 :     {
; 1503 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1504 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00c7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00c82	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00c8a	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv533[rsp], rax
  00c92	b9 02 00 00 00	 mov	 ecx, 2
  00c97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c9d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv533[rsp]
  00ca5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00caa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169568
  00cb1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cb6	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00cbe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cc3	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00ccc	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00cd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169569
  00cdc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ce1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169570
  00ce8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ced	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cf2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cf8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169571
  00cff	ba e1 05 00 00	 mov	 edx, 1505		; 000005e1H
  00d04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169572
  00d0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1505 :             "lseek()", strerror( errno ));
; 1506 :         return -1;

  00d11	b8 ff ff ff ff	 mov	 eax, -1
  00d16	e9 19 02 00 00	 jmp	 $LN1@create_com
$LN17@create_com:

; 1507 :     }
; 1508 :     rc = write( fd, &l2, CCKD64_L2TAB_SIZE);

  00d1b	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00d21	48 8d 94 24 30
	05 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  00d29	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00d2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00d33	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1509 :     if (rc < (int)       CCKD64_L2TAB_SIZE)

  00d37	81 7c 24 70 00
	10 00 00	 cmp	 DWORD PTR rc$[rsp], 4096 ; 00001000H
  00d3f	0f 8d bb 00 00
	00		 jge	 $LN18@create_com

; 1510 :     {
; 1511 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1512 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00d45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d4b	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d4e	74 18		 je	 SHORT $LN35@create_com
  00d50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d56	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00d5e	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv560[rsp], rax
  00d66	eb 0f		 jmp	 SHORT $LN36@create_com
$LN35@create_com:
  00d68	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169574
  00d6f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv560[rsp], rax
$LN36@create_com:
  00d77	b9 02 00 00 00	 mov	 ecx, 2
  00d7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d82	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv560[rsp]
  00d8a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00d8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169575
  00d96	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d9b	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00da3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00da8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00db1	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00dba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169576
  00dc1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dc6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169577
  00dcd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dd2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ddd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169578
  00de4	ba e9 05 00 00	 mov	 edx, 1513		; 000005e9H
  00de9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169579
  00df0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1513 :             "write()", errno ? strerror( errno ) : "incomplete" );
; 1514 :         return -1;

  00df6	b8 ff ff ff ff	 mov	 eax, -1
  00dfb	e9 34 01 00 00	 jmp	 $LN1@create_com
$LN18@create_com:

; 1515 :     }
; 1516 : 
; 1517 :     /* Close the DASD image file */
; 1518 :     if ((rc = close( fd )) < 0)

  00e00	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$[rsp]
  00e04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  00e0a	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00e0e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e13	0f 8d 9c 00 00
	00		 jge	 $LN19@create_com

; 1519 :     {
; 1520 :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 1521 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00e19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e1f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e27	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv610[rsp], rax
  00e2f	b9 02 00 00 00	 mov	 ecx, 2
  00e34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e3a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv610[rsp]
  00e42	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169581
  00e4e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e53	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00e5b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e60	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00e69	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00e72	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169582
  00e79	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e7e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169583
  00e85	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e8a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e8f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e95	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169584
  00e9c	ba f2 05 00 00	 mov	 edx, 1522		; 000005f2H
  00ea1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169585
  00ea8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1522 :             "close()", strerror( errno ));
; 1523 :         return -1;

  00eae	b8 ff ff ff ff	 mov	 eax, -1
  00eb3	eb 7f		 jmp	 SHORT $LN1@create_com
$LN19@create_com:

; 1524 :     }
; 1525 : 
; 1526 :     /* Display completion message */
; 1527 :     // "%1d:%04X CKD64 file %s: %u %s successfully written"
; 1528 :     FWRMSG( stdout, HHC00471, "I", 0, 0, fname,

  00eb5	b9 01 00 00 00	 mov	 ecx, 1
  00eba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ec0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169586
  00ec7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ecc	8b 8c 24 78 16
	01 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  00ed3	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00ed7	48 8b 8c 24 60
	16 01 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00edf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ee4	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00eed	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00ef6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169587
  00efd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169588
  00f09	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f0e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f13	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f19	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169589
  00f20	ba f9 05 00 00	 mov	 edx, 1529		; 000005f9H
  00f25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169590
  00f2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1529 :         sectors, "sectors" );
; 1530 :     return 0;

  00f32	33 c0		 xor	 eax, eax
$LN1@create_com:

; 1531 : } /* end function create_compressed_fba64 */

  00f34	48 8b 8c 24 40
	16 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00f3c	48 33 cc	 xor	 rcx, rsp
  00f3f	e8 00 00 00 00	 call	 __security_check_cookie
  00f44	48 81 c4 50 16
	01 00		 add	 rsp, 71248		; 00011650H
  00f4b	5f		 pop	 rdi
  00f4c	c3		 ret	 0
create_compressed_fba64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
sectnum$ = 112
rc$ = 116
fd$ = 120
maxsect$ = 124
buf$ = 128
minsect$ = 136
x$ = 140
sz$1 = 144
tv173 = 152
tv171 = 160
tv223 = 168
tv329 = 176
tv147 = 184
tv198 = 192
tv237 = 200
tv290 = 208
tv347 = 216
buf$2 = 224
pathname$ = 272
__$ArrayPad$ = 544
fname$ = 576
devtype$ = 584
sectsz$ = 592
sectors$ = 600
volser$ = 608
comp$ = 616
lfs$ = 624
dasdcopy$ = 632
rawflag$ = 640
create_fba64 PROC

; 1115 : {

$LN28:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1116 : int             rc;                     /* Return code               */
; 1117 : int             fd;                     /* File descriptor           */
; 1118 : U32             sectnum;                /* Sector number             */
; 1119 : BYTE           *buf;                    /* -> Sector data buffer     */
; 1120 : U32             minsect;                /* Minimum sector count      */
; 1121 : U32             maxsect;                /* Maximum sector count      */
; 1122 : int             x=O_EXCL;               /* Open option               */

  0002e	c7 84 24 8c 00
	00 00 00 04 00
	00		 mov	 DWORD PTR x$[rsp], 1024	; 00000400H

; 1123 : char            pathname[MAX_PATH];     /* file path in host format  */
; 1124 : 
; 1125 :     /* Special processing for compressed fba */
; 1126 :     if (comp != 0xff)

  00039	0f b6 84 24 68
	02 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00041	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00046	74 6c		 je	 SHORT $LN5@create_fba

; 1127 :     {
; 1128 :         rc = create_compressed_fba64( fname, devtype, sectsz, sectors,

  00048	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR rawflag$[rsp]
  0004f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00053	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR dasdcopy$[rsp]
  0005a	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0005e	8b 84 24 70 02
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  00065	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00069	0f b6 84 24 68
	02 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00071	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00075	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  0007d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00082	44 8b 8c 24 58
	02 00 00	 mov	 r9d, DWORD PTR sectors$[rsp]
  0008a	44 8b 84 24 50
	02 00 00	 mov	 r8d, DWORD PTR sectsz$[rsp]
  00092	0f b7 94 24 48
	02 00 00	 movzx	 edx, WORD PTR devtype$[rsp]
  0009a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000a2	e8 00 00 00 00	 call	 create_compressed_fba64
  000a7	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 1129 :                                       volser, comp, lfs, dasdcopy, rawflag );
; 1130 :         return rc;

  000ab	8b 44 24 74	 mov	 eax, DWORD PTR rc$[rsp]
  000af	e9 aa 08 00 00	 jmp	 $LN1@create_fba
$LN5@create_fba:

; 1131 :     }
; 1132 : 
; 1133 :     /* Compute minimum and maximum number of sectors */
; 1134 :     minsect = 64;

  000b4	c7 84 24 88 00
	00 00 40 00 00
	00		 mov	 DWORD PTR minsect$[rsp], 64 ; 00000040H

; 1135 :     maxsect = 0x80000000 / sectsz;

  000bf	33 d2		 xor	 edx, edx
  000c1	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000c6	f7 b4 24 50 02
	00 00		 div	 DWORD PTR sectsz$[rsp]
  000cd	89 44 24 7c	 mov	 DWORD PTR maxsect$[rsp], eax

; 1136 : 
; 1137 :     /* Check for valid number of sectors */
; 1138 :     if (sectors < minsect || (!lfs && sectors > maxsect))

  000d1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR minsect$[rsp]
  000d8	39 84 24 58 02
	00 00		 cmp	 DWORD PTR sectors$[rsp], eax
  000df	72 1f		 jb	 SHORT $LN7@create_fba
  000e1	83 bc 24 70 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  000e9	0f 85 10 01 00
	00		 jne	 $LN6@create_fba
  000ef	8b 44 24 7c	 mov	 eax, DWORD PTR maxsect$[rsp]
  000f3	39 84 24 58 02
	00 00		 cmp	 DWORD PTR sectors$[rsp], eax
  000fa	0f 86 ff 00 00
	00		 jbe	 $LN6@create_fba
$LN7@create_fba:

; 1139 :     {
; 1140 :         if (!lfs)

  00100	83 bc 24 70 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  00108	75 5b		 jne	 SHORT $LN8@create_fba

; 1141 :             FWRMSG( stderr, HHC00521, "W", maxsect, "sectors" );

  0010a	b9 02 00 00 00	 mov	 ecx, 2
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169322
  0011c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00121	8b 4c 24 7c	 mov	 ecx, DWORD PTR maxsect$[rsp]
  00125	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169323
  00130	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169324
  0013c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00141	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00146	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169325
  00153	ba 75 04 00 00	 mov	 edx, 1141		; 00000475H
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169326
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@create_fba:

; 1142 : 
; 1143 :         FWRMSG( stderr, HHC00461, "E", 0, 0, fname,

  00165	b9 02 00 00 00	 mov	 ecx, 2
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00170	8b 4c 24 7c	 mov	 ecx, DWORD PTR maxsect$[rsp]
  00174	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00178	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR minsect$[rsp]
  0017f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00183	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0018a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169327
  00195	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0019a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001a2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  001b0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169328
  001c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169329
  001cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169330
  001e3	ba 78 04 00 00	 mov	 edx, 1144		; 00000478H
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1144 :                 "sector", sectors, minsect, maxsect );
; 1145 :         return -1;

  001f5	b8 ff ff ff ff	 mov	 eax, -1
  001fa	e9 5f 07 00 00	 jmp	 $LN1@create_fba
$LN6@create_fba:

; 1146 :     }
; 1147 : 
; 1148 :     /* Obtain sector data buffer */
; 1149 :     buf = malloc(sectsz);

  001ff	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  00206	8b c8		 mov	 ecx, eax
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0020e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1150 :     if (buf == NULL)

  00216	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0021f	0f 85 c2 00 00
	00		 jne	 $LN9@create_fba

; 1151 :     {
; 1152 :         char buf[40];
; 1153 :         MSGBUF( buf, "malloc(%u)", sectsz);

  00225	44 8b 8c 24 50
	02 00 00	 mov	 r9d, DWORD PTR sectsz$[rsp]
  0022d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169333
  00234	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00239	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1154 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0024d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00255	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  0025d	b9 02 00 00 00	 mov	 ecx, 2
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00268	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  00270	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00275	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0027d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00282	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0028a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0028f	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00298	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169334
  002a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169335
  002b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002be	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169336
  002cb	ba 83 04 00 00	 mov	 edx, 1155		; 00000483H
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169337
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1155 :                 buf, strerror( errno ));
; 1156 :         return -1;

  002dd	b8 ff ff ff ff	 mov	 eax, -1
  002e2	e9 77 06 00 00	 jmp	 $LN1@create_fba
$LN9@create_fba:

; 1157 :     }
; 1158 : 
; 1159 :     /* Display progress message */
; 1160 :     // "%1d:%04X FBA64 file %s: creating %4.4X volume %s: %u sectors, %u bytes/sector"
; 1161 :     FWRMSG( stdout, HHC00473, "I", 0, 0, fname,

  002e7	83 bc 24 80 02
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  002ef	74 11		 je	 SHORT $LN22@create_fba
  002f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169338
  002f8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  00300	eb 10		 jmp	 SHORT $LN23@create_fba
$LN22@create_fba:
  00302	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  0030a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN23@create_fba:
  00312	0f b7 84 24 48
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  0031a	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv173[rsp], eax
  00321	b9 01 00 00 00	 mov	 ecx, 1
  00326	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0032c	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  00333	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00337	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  0033e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00342	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv171[rsp]
  0034a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0034f	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  00356	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0035a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00362	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00367	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00370	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00379	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169339
  00380	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169340
  0038c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00391	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00396	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169341
  003a3	ba 8a 04 00 00	 mov	 edx, 1162		; 0000048aH
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169342
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1162 :             devtype, rawflag ? "" : volser, sectors, sectsz );
; 1163 : 
; 1164 :     /* if `dasdcopy' > 1 then we can replace the existing file */
; 1165 :     if (dasdcopy > 1) x = 0;

  003b5	83 bc 24 78 02
	00 00 01	 cmp	 DWORD PTR dasdcopy$[rsp], 1
  003bd	7e 0b		 jle	 SHORT $LN10@create_fba
  003bf	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$[rsp], 0
$LN10@create_fba:

; 1166 : 
; 1167 :     /* Create the DASD image file */
; 1168 :     hostpath(pathname, fname, sizeof(pathname));

  003ca	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  003d0	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  003d8	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1169 :     fd = HOPEN (pathname, O_WRONLY | O_CREAT | x | O_BINARY,

  003e6	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003ed	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  003f2	0f ba e8 0f	 bts	 eax, 15
  003f6	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  003fc	8b d0		 mov	 edx, eax
  003fe	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0040c	89 44 24 78	 mov	 DWORD PTR fd$[rsp], eax

; 1170 :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 1171 :     if (fd < 0)

  00410	83 7c 24 78 00	 cmp	 DWORD PTR fd$[rsp], 0
  00415	0f 8d 9f 00 00
	00		 jge	 $LN11@create_fba

; 1172 :     {
; 1173 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00421	8b 08		 mov	 ecx, DWORD PTR [rax]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00429	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00431	b9 02 00 00 00	 mov	 ecx, 2
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0043c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00444	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00449	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169345
  00450	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00455	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0045d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00462	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0046b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169346
  0047b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00480	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169347
  00487	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0048c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00491	41 b9 03 00 00
	00		 mov	 r9d, 3
  00497	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169348
  0049e	ba 96 04 00 00	 mov	 edx, 1174		; 00000496H
  004a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169349
  004aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1174 :                 "open()", strerror( errno ));
; 1175 :         return -1;

  004b0	b8 ff ff ff ff	 mov	 eax, -1
  004b5	e9 a4 04 00 00	 jmp	 $LN1@create_fba
$LN11@create_fba:

; 1176 :     }
; 1177 : 
; 1178 :     /* If the `dasdcopy' bit is on then simply allocate the space */
; 1179 :     if (dasdcopy)

  004ba	83 bc 24 78 02
	00 00 00	 cmp	 DWORD PTR dasdcopy$[rsp], 0
  004c2	0f 84 76 01 00
	00		 je	 $LN12@create_fba

; 1180 :     {
; 1181 :         U64 sz = (U64)((S64)sectors * sectsz);

  004c8	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR sectors$[rsp]
  004cf	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR sectsz$[rsp]
  004d6	48 0f af c1	 imul	 rax, rcx
  004da	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sz$1[rsp], rax

; 1182 :         sz = ROUND_UP( sz, CFBA_BLKGRP_SIZE );

  004e2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sz$1[rsp], 0
  004eb	74 29		 je	 SHORT $LN24@create_fba
  004ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sz$1[rsp]
  004f5	48 05 ff ef 00
	00		 add	 rax, 61439		; 0000efffH
  004fb	33 d2		 xor	 edx, edx
  004fd	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  00502	48 f7 f1	 div	 rcx
  00505	48 69 c0 00 f0
	00 00		 imul	 rax, rax, 61440		; 0000f000H
  0050c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00514	eb 0c		 jmp	 SHORT $LN25@create_fba
$LN24@create_fba:
  00516	48 c7 84 24 a8
	00 00 00 00 f0
	00 00		 mov	 QWORD PTR tv223[rsp], 61440 ; 0000f000H
$LN25@create_fba:
  00522	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  0052a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sz$1[rsp], rax

; 1183 :         // "This might take a while... Please wait..."
; 1184 :         FWRMSG( stdout, HHC00475, "I" );

  00532	b9 01 00 00 00	 mov	 ecx, 1
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169352
  00544	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00549	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169353
  00550	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00555	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0055a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00560	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169354
  00567	ba a0 04 00 00	 mov	 edx, 1184		; 000004a0H
  0056c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169355
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1185 :         rc = ftruncate (fd, sz);

  00579	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sz$1[rsp]
  00581	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  00585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0058b	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 1186 :         if (rc < 0)

  0058f	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  00594	0f 8d 9f 00 00
	00		 jge	 $LN14@create_fba

; 1187 :         {
; 1188 :             FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  0059a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
  005b0	b9 02 00 00 00	 mov	 ecx, 2
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv237[rsp]
  005c3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169357
  005cf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005d4	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005e1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  005ea	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169358
  005fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169359
  00606	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00610	41 b9 03 00 00
	00		 mov	 r9d, 3
  00616	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169360
  0061d	ba a5 04 00 00	 mov	 edx, 1189		; 000004a5H
  00622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169361
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1189 :                 "ftruncate()", strerror( errno ));
; 1190 :             return -1;

  0062f	b8 ff ff ff ff	 mov	 eax, -1
  00634	e9 25 03 00 00	 jmp	 $LN1@create_fba
$LN14@create_fba:

; 1191 :         }
; 1192 :     }

  00639	e9 db 01 00 00	 jmp	 $LN13@create_fba
$LN12@create_fba:

; 1193 :     /* Write each sector */
; 1194 :     else
; 1195 :     {
; 1196 :         for (sectnum = 0; sectnum < sectors; sectnum++)

  0063e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR sectnum$[rsp], 0
  00646	eb 0a		 jmp	 SHORT $LN4@create_fba
$LN2@create_fba:
  00648	8b 44 24 70	 mov	 eax, DWORD PTR sectnum$[rsp]
  0064c	ff c0		 inc	 eax
  0064e	89 44 24 70	 mov	 DWORD PTR sectnum$[rsp], eax
$LN4@create_fba:
  00652	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR sectors$[rsp]
  00659	39 44 24 70	 cmp	 DWORD PTR sectnum$[rsp], eax
  0065d	0f 83 b6 01 00
	00		 jae	 $LN3@create_fba

; 1197 :         {
; 1198 :             /* Clear the sector to zeroes */
; 1199 :             memset (buf, 0, sectsz);

  00663	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  0066a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
  00672	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  0067a	33 c0		 xor	 eax, eax
  0067c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv290[rsp]
  00684	f3 aa		 rep stosb

; 1200 : 
; 1201 :             /* Sector 1 contains the volume label */
; 1202 :             if (!rawflag && sectnum == 1)

  00686	83 bc 24 80 02
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  0068e	75 39		 jne	 SHORT $LN15@create_fba
  00690	83 7c 24 70 01	 cmp	 DWORD PTR sectnum$[rsp], 1
  00695	75 32		 jne	 SHORT $LN15@create_fba

; 1203 :             {
; 1204 :                 memcpy( buf, VOL1_KEY, sizeof( VOL1_KEY ));

  00697	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0069f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR VOL1_KEY
  006a5	89 08		 mov	 DWORD PTR [rax], ecx

; 1205 :                 convert_to_ebcdic (buf+4, 6, volser);

  006a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  006af	48 83 c0 04	 add	 rax, 4
  006b3	4c 8b 84 24 60
	02 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  006bb	ba 06 00 00 00	 mov	 edx, 6
  006c0	48 8b c8	 mov	 rcx, rax
  006c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic
$LN15@create_fba:

; 1206 :             } /* end if(sectnum==1) */
; 1207 : 
; 1208 :             /* Display progress message every 100 sectors */
; 1209 :             if ((sectnum % 100) == 0)

  006c9	33 d2		 xor	 edx, edx
  006cb	8b 44 24 70	 mov	 eax, DWORD PTR sectnum$[rsp]
  006cf	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  006d4	f7 f1		 div	 ecx
  006d6	8b c2		 mov	 eax, edx
  006d8	85 c0		 test	 eax, eax
  006da	75 4e		 jne	 SHORT $LN16@create_fba

; 1210 :             {
; 1211 :                 if (extgui)

  006dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  006e3	83 38 00	 cmp	 DWORD PTR [rax], 0
  006e6	74 22		 je	 SHORT $LN17@create_fba

; 1212 :                     fprintf( stderr, "BLK=%u\n", sectnum );

  006e8	b9 02 00 00 00	 mov	 ecx, 2
  006ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f3	44 8b 44 24 70	 mov	 r8d, DWORD PTR sectnum$[rsp]
  006f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169366
  006ff	48 8b c8	 mov	 rcx, rax
  00702	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
  00708	eb 20		 jmp	 SHORT $LN18@create_fba
$LN17@create_fba:

; 1213 :                 else
; 1214 :                     fprintf( stderr, "Writing sector %u\r", sectnum );

  0070a	b9 02 00 00 00	 mov	 ecx, 2
  0070f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00715	44 8b 44 24 70	 mov	 r8d, DWORD PTR sectnum$[rsp]
  0071a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169367
  00721	48 8b c8	 mov	 rcx, rax
  00724	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN18@create_fba:
$LN16@create_fba:

; 1215 :             }
; 1216 : 
; 1217 :             /* Write the sector to the file */
; 1218 :             rc = write (fd, buf, sectsz);

  0072a	44 8b 84 24 50
	02 00 00	 mov	 r8d, DWORD PTR sectsz$[rsp]
  00732	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0073a	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  0073e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00744	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 1219 :             if (rc < (int)sectsz)

  00748	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR sectsz$[rsp]
  0074f	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  00753	0f 8d bb 00 00
	00		 jge	 $LN19@create_fba

; 1220 :             {
; 1221 :                 FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00759	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0075f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00762	74 18		 je	 SHORT $LN26@create_fba
  00764	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0076a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0076c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00772	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
  0077a	eb 0f		 jmp	 SHORT $LN27@create_fba
$LN26@create_fba:
  0077c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169369
  00783	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
$LN27@create_fba:
  0078b	b9 02 00 00 00	 mov	 ecx, 2
  00790	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00796	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv329[rsp]
  0079e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169370
  007aa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007af	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  007b7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007bc	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  007c5	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  007ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169371
  007d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169372
  007e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169373
  007f8	ba c6 04 00 00	 mov	 edx, 1222		; 000004c6H
  007fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169374
  00804	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1222 :                         "write()", errno ? strerror( errno ) : "incomplete" );
; 1223 :                 return -1;

  0080a	b8 ff ff ff ff	 mov	 eax, -1
  0080f	e9 4a 01 00 00	 jmp	 $LN1@create_fba
$LN19@create_fba:

; 1224 :             }
; 1225 :         } /* end for(sectnum) */

  00814	e9 2f fe ff ff	 jmp	 $LN2@create_fba
$LN3@create_fba:
$LN13@create_fba:

; 1226 :     } /* `dasdcopy' bit is off */
; 1227 : 
; 1228 :     /* Close the DASD image file */
; 1229 :     rc = close (fd);

  00819	8b 4c 24 78	 mov	 ecx, DWORD PTR fd$[rsp]
  0081d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  00823	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 1230 :     if (rc < 0)

  00827	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  0082c	0f 8d 9f 00 00
	00		 jge	 $LN20@create_fba

; 1231 :     {
; 1232 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  00832	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00838	8b 08		 mov	 ecx, DWORD PTR [rax]
  0083a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00840	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
  00848	b9 02 00 00 00	 mov	 ecx, 2
  0084d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00853	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv347[rsp]
  0085b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00860	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  00867	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0086c	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00874	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00879	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00882	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0088b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169377
  00892	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00897	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169378
  0089e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  008ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169379
  008b5	ba d1 04 00 00	 mov	 edx, 1233		; 000004d1H
  008ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169380
  008c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1233 :                 "close()", strerror( errno ));
; 1234 :         return -1;

  008c7	b8 ff ff ff ff	 mov	 eax, -1
  008cc	e9 8d 00 00 00	 jmp	 $LN1@create_fba
$LN20@create_fba:

; 1235 :     }
; 1236 : 
; 1237 :     /* Release data buffer */
; 1238 :     free (buf);

  008d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  008d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1239 : 
; 1240 :     /* Display completion message */
; 1241 :     // "%1d:%04X CKD64 file %s: %u %s successfully written"
; 1242 :     FWRMSG( stdout, HHC00471, "I", 0, 0, fname, sectors, "sectors" );

  008df	b9 01 00 00 00	 mov	 ecx, 1
  008e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169381
  008f1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  008f6	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR sectors$[rsp]
  008fd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00901	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00909	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0090e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00917	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00920	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169382
  00927	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0092c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169383
  00933	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00938	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0093d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00943	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169384
  0094a	ba da 04 00 00	 mov	 edx, 1242		; 000004daH
  0094f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169385
  00956	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1243 : 
; 1244 :     return 0;

  0095c	33 c0		 xor	 eax, eax
$LN1@create_fba:

; 1245 : } /* end function create_fba64 */

  0095e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00966	48 33 cc	 xor	 rcx, rsp
  00969	e8 00 00 00 00	 call	 __security_check_cookie
  0096e	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00975	5f		 pop	 rdi
  00976	c3		 ret	 0
create_fba64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
fileseq$ = 144
maxcyls$ = 148
trksize$ = 152
maxcpif$ = 156
cyl$ = 160
i$1 = 168
s$ = 176
suffix$ = 184
tv76 = 192
mincyls$ = 196
endcyl$ = 200
cylsize$ = 204
tv217 = 208
rc$ = 212
buf$ = 216
pszopt$2 = 224
pszcomp$3 = 232
tv215 = 240
tv82 = 248
tv189 = 256
serial$ = 264
buf$4 = 280
sfname$ = 320
msgbuf$5 = 592
__$ArrayPad$ = 720
fname$ = 752
devtype$ = 760
heads$ = 768
maxdlen$ = 776
volcyls$ = 784
volser$ = 792
comp$ = 800
lfs$ = 808
dasdcopy$ = 816
nullfmt$ = 824
rawflag$ = 832
flagECmode$ = 840
flagMachinecheck$ = 848
create_ckd64 PROC

; 935  : {

$LN33:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 02
	00 00		 sub	 rsp, 736		; 000002e0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 936  : int             rc;                     /* Return code               */
; 937  : char            *s;                     /* String pointer            */
; 938  : BYTE            fileseq;                /* File sequence number      */
; 939  : char            sfname[FILENAME_MAX];   /* Suffixed name of this file*/
; 940  : char            *suffix;                /* -> Suffix character       */
; 941  : U32             endcyl;                 /* Last cylinder of this file*/
; 942  : U32             cyl;                    /* Cylinder number           */
; 943  : U32             cylsize;                /* Cylinder size in bytes    */
; 944  : BYTE           *buf;                    /* -> Track data buffer      */
; 945  : U32             mincyls;                /* Minimum cylinder count    */
; 946  : U32             maxcyls;                /* Maximum cylinder count    */
; 947  : U32             maxcpif;                /* Maximum number of cylinders
; 948  :                                            in each CKD image file    */
; 949  : U32             trksize;                /* DASD image track length   */
; 950  : char            serial[ sizeof_member( CKD_DEVHDR, dh_serial ) + 1 ] = {0};

  0002e	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR serial$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 0d 00 00 00	 mov	 ecx, 13
  00040	f3 aa		 rep stosb

; 951  : 
; 952  :     /* Compute the DASD image track length */
; 953  :     trksize = CKD_TRKHDR_SIZE

  00042	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR maxdlen$[rsp]
  00049	48 83 c0 25	 add	 rax, 37			; 00000025H
  0004d	89 84 24 98 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 954  :             + CKD_RECHDR_SIZE + CKD_R0_DLEN
; 955  :             + CKD_RECHDR_SIZE + maxdlen
; 956  :             + CKD_ENDTRK_SIZE;
; 957  :     trksize = ROUND_UP( trksize, 512 );

  00054	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR trksize$[rsp], 0
  0005c	74 24		 je	 SHORT $LN29@create_ckd
  0005e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00065	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  0006a	33 d2		 xor	 edx, edx
  0006c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00071	f7 f1		 div	 ecx
  00073	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  00079	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00080	eb 0b		 jmp	 SHORT $LN30@create_ckd
$LN29@create_ckd:
  00082	c7 84 24 c0 00
	00 00 00 02 00
	00		 mov	 DWORD PTR tv76[rsp], 512 ; 00000200H
$LN30@create_ckd:
  0008d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv76[rsp]
  00094	89 84 24 98 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 958  : 
; 959  :     /* Compute minimum and maximum number of cylinders */
; 960  :     cylsize = trksize * heads;

  0009b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  000a2	0f af 84 24 00
	03 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  000aa	89 84 24 cc 00
	00 00		 mov	 DWORD PTR cylsize$[rsp], eax

; 961  :     mincyls = 1;

  000b1	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mincyls$[rsp], 1

; 962  :     if (comp == 0xff && !lfs)

  000bc	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  000c4	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c9	75 45		 jne	 SHORT $LN5@create_ckd
  000cb	0f b6 84 24 28
	03 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  000d3	85 c0		 test	 eax, eax
  000d5	75 39		 jne	 SHORT $LN5@create_ckd

; 963  :     {
; 964  :         maxcpif = (0x7fffffff - CKD_DEVHDR_SIZE + 1) / cylsize;

  000d7	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR cylsize$[rsp]
  000de	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000e6	b8 00 fe ff 7f	 mov	 eax, 2147483136		; 7ffffe00H
  000eb	48 99		 cdq
  000ed	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  000f5	48 f7 f9	 idiv	 rcx
  000f8	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax

; 965  :         maxcyls = maxcpif * CKD_MAXFILES;

  000ff	6b 84 24 9c 00
	00 00 1b	 imul	 eax, DWORD PTR maxcpif$[rsp], 27
  00107	89 84 24 94 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax

; 966  :     }

  0010e	eb 1c		 jmp	 SHORT $LN6@create_ckd
$LN5@create_ckd:

; 967  :     else
; 968  :         maxcpif = maxcyls = volcyls;

  00110	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00117	89 84 24 94 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax
  0011e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  00125	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax
$LN6@create_ckd:

; 969  : 
; 970  :     if (maxcyls > 65536)

  0012c	81 bc 24 94 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
  00137	76 69		 jbe	 SHORT $LN7@create_ckd

; 971  :     {
; 972  :         maxcyls = 65536;

  00139	c7 84 24 94 00
	00 00 00 00 01
	00		 mov	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H

; 973  :         FWRMSG( stderr, HHC00467, "W", "cylinders", maxcyls );

  00144	b9 02 00 00 00	 mov	 ecx, 2
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  00156	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169226
  00161	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169227
  0016d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169228
  00179	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00183	41 b9 03 00 00
	00		 mov	 r9d, 3
  00189	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169229
  00190	ba cd 03 00 00	 mov	 edx, 973		; 000003cdH
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169230
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@create_ckd:

; 974  :     }
; 975  : 
; 976  :     /* Check for valid number of cylinders */
; 977  :     if (volcyls < mincyls || volcyls > maxcyls)

  001a2	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR mincyls$[rsp]
  001a9	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  001b0	72 14		 jb	 SHORT $LN9@create_ckd
  001b2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  001b9	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  001c0	0f 86 ea 01 00
	00		 jbe	 $LN8@create_ckd
$LN9@create_ckd:

; 978  :     {
; 979  :         if (comp == 0xff && !lfs)

  001c6	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  001ce	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001d3	0f 85 3a 01 00
	00		 jne	 $LN10@create_ckd
  001d9	0f b6 84 24 28
	03 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  001e1	85 c0		 test	 eax, eax
  001e3	0f 85 2a 01 00
	00		 jne	 $LN10@create_ckd

; 980  :         {
; 981  :             char    msgbuf[128];
; 982  : 
; 983  : #if defined( HAVE_ZLIB ) && defined( CCKD_BZIP2 )
; 984  :             char   *pszcomp     = " or zlib/bzip2 compression";
; 985  : #elif defined( HAVE_ZLIB )
; 986  :             char   *pszcomp     = " or zlib compression";
; 987  : #elif defined( CCKD_BZIP2 )
; 988  :             char   *pszcomp     = " or bzip2 compression";
; 989  : #else
; 990  :             char   *pszcomp     = "";

  001e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169234
  001f0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pszcomp$3[rsp], rax

; 991  : #endif
; 992  :             char   *pszopt;
; 993  : 
; 994  :             FWRMSG( stderr, HHC00466, "W", maxcyls, "cylinders", CKD_MAXFILES );

  001f8	b9 02 00 00 00	 mov	 ecx, 2
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00203	c7 44 24 48 1b
	00 00 00	 mov	 DWORD PTR [rsp+72], 27
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169235
  00212	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00217	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  0021e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169236
  00229	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169237
  00235	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00245	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169238
  0024c	ba e2 03 00 00	 mov	 edx, 994		; 000003e2H
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169239
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 995  : 
; 996  :             if ( strlen(pszcomp) > 0 )

  0025e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pszcomp$3[rsp]
  00266	e8 00 00 00 00	 call	 strlen
  0026b	48 85 c0	 test	 rax, rax
  0026e	76 11		 jbe	 SHORT $LN11@create_ckd

; 997  :                 pszopt = "related options";

  00270	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169242
  00277	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pszopt$2[rsp], rax
  0027f	eb 0f		 jmp	 SHORT $LN12@create_ckd
$LN11@create_ckd:

; 998  :             else
; 999  :                 pszopt = "option";

  00281	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169243
  00288	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pszopt$2[rsp], rax
$LN12@create_ckd:

; 1000 : 
; 1001 :             MSGBUF(msgbuf, "-lfs%s %s", pszcomp, pszopt );

  00290	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pszopt$2[rsp]
  00298	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029d	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR pszcomp$3[rsp]
  002a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169244
  002ac	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002b1	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1002 :             FWRMSG( stderr, HHC00468, "I", msgbuf );

  002bf	b9 02 00 00 00	 mov	 ecx, 2
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ca	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  002d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169245
  002de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169246
  002ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169247
  00301	ba ea 03 00 00	 mov	 edx, 1002		; 000003eaH
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169248
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@create_ckd:

; 1003 :         }
; 1004 : 
; 1005 :         FWRMSG( stderr, HHC00461, "E", 0, 0, fname,

  00313	b9 02 00 00 00	 mov	 ecx, 2
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0031e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  00325	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00329	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR mincyls$[rsp]
  00330	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00334	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  0033b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0033f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169249
  00346	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0034b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00353	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00358	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00361	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169250
  00371	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169251
  0037d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00382	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00387	41 b9 03 00 00
	00		 mov	 r9d, 3
  0038d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169252
  00394	ba ee 03 00 00	 mov	 edx, 1006		; 000003eeH
  00399	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169253
  003a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1006 :                 "cylinder", volcyls, mincyls, maxcyls );
; 1007 :         return -1;

  003a6	b8 ff ff ff ff	 mov	 eax, -1
  003ab	e9 73 05 00 00	 jmp	 $LN1@create_ckd
$LN8@create_ckd:

; 1008 :     }
; 1009 : 
; 1010 :     /* Obtain track data buffer */
; 1011 :     buf = malloc(trksize);

  003b0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  003b7	8b c8		 mov	 ecx, eax
  003b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003bf	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1012 :     if (buf == NULL)

  003c7	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  003d0	0f 85 c2 00 00
	00		 jne	 $LN13@create_ckd

; 1013 :     {
; 1014 :         char buf[40];
; 1015 :         MSGBUF( buf, "malloc(%u)", trksize);

  003d6	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR trksize$[rsp]
  003de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169255
  003e5	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  003ea	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1016 :         FWRMSG( stderr, HHC00404, "E", 0, 0, fname,

  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003fe	8b 08		 mov	 ecx, DWORD PTR [rax]
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00406	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv189[rsp], rax
  0040e	b9 02 00 00 00	 mov	 ecx, 2
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00419	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv189[rsp]
  00421	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00426	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  0042e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00433	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0043b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00440	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00449	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169256
  00459	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169257
  00465	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0046f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00475	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169258
  0047c	ba f9 03 00 00	 mov	 edx, 1017		; 000003f9H
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169259
  00488	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1017 :                 buf, strerror( errno ));
; 1018 :         return -1;

  0048e	b8 ff ff ff ff	 mov	 eax, -1
  00493	e9 8b 04 00 00	 jmp	 $LN1@create_ckd
$LN13@create_ckd:

; 1019 :     }
; 1020 : 
; 1021 :     /* Display progress message */
; 1022 :     // "%1d:%04X CKD64 file %s: creating %4.4X volume %s: %u cyls, %u trks/cyl, %u bytes/track"
; 1023 :     FWRMSG( stdout, HHC00472, "I", 0, 0, fname,

  00498	0f b6 84 24 40
	03 00 00	 movzx	 eax, BYTE PTR rawflag$[rsp]
  004a0	85 c0		 test	 eax, eax
  004a2	74 11		 je	 SHORT $LN31@create_ckd
  004a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169260
  004ab	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  004b3	eb 10		 jmp	 SHORT $LN32@create_ckd
$LN31@create_ckd:
  004b5	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  004bd	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN32@create_ckd:
  004c5	0f b7 84 24 f8
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  004cd	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv217[rsp], eax
  004d4	b9 01 00 00 00	 mov	 ecx, 1
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004df	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  004e6	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  004ea	8b 8c 24 00 03
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  004f1	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  004f5	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  004fc	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00500	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  00508	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0050d	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv217[rsp]
  00514	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00518	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00520	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00525	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0052e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00537	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169261
  0053e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169262
  0054a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00554	41 b9 03 00 00
	00		 mov	 r9d, 3
  0055a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169263
  00561	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169264
  0056d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1024 :             devtype, rawflag ? "" : volser, volcyls, heads, trksize );
; 1025 : 
; 1026 :     /* Copy the unsuffixed DASD image file name */
; 1027 :     STRLCPY( sfname, fname );

  00573	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00579	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00581	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1028 :     suffix = NULL;

  0058f	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR suffix$[rsp], 0

; 1029 : 
; 1030 :     /* Create the suffixed file name if volume will exceed 2GB */
; 1031 :     if (volcyls > maxcpif)

  0059b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  005a2	39 84 24 10 03
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  005a9	0f 86 99 01 00
	00		 jbe	 $LN14@create_ckd

; 1032 :     {
; 1033 :         /* Look for last slash marking end of directory name */
; 1034 :         s = strrchr( fname, PATHSEPC);

  005af	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  005b4	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  005bc	e8 00 00 00 00	 call	 strrchr
  005c1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1035 :         if (s == NULL) s = fname;

  005c9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  005d2	75 10		 jne	 SHORT $LN15@create_ckd
  005d4	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  005dc	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN15@create_ckd:

; 1036 : 
; 1037 :         /* Insert suffix before first dot in file name, or
; 1038 :            append suffix to file name if there is no dot.
; 1039 :            If the filename already has a place for the suffix
; 1040 :            then use that. */
; 1041 :         s = strchr (s, '.');

  005e4	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  005e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005f1	e8 00 00 00 00	 call	 strchr
  005f6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1042 :         if (s != NULL)

  005fe	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  00607	0f 84 d6 00 00
	00		 je	 $LN16@create_ckd

; 1043 :         {
; 1044 :             ptrdiff_t i = (s - fname);

  0060d	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  00615	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0061d	48 2b c8	 sub	 rcx, rax
  00620	48 8b c1	 mov	 rax, rcx
  00623	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR i$1[rsp], rax

; 1045 :             if (i > 2 && fname[i-2] == '_')

  0062b	48 83 bc 24 a8
	00 00 00 02	 cmp	 QWORD PTR i$1[rsp], 2
  00634	7e 39		 jle	 SHORT $LN18@create_ckd
  00636	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i$1[rsp]
  0063e	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00646	48 03 c8	 add	 rcx, rax
  00649	48 8b c1	 mov	 rax, rcx
  0064c	0f be 40 fe	 movsx	 eax, BYTE PTR [rax-2]
  00650	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00653	75 1a		 jne	 SHORT $LN18@create_ckd

; 1046 :                 suffix = sfname + i - 1;

  00655	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i$1[rsp]
  0065d	48 8d 84 04 3f
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  00665	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
  0066d	eb 72		 jmp	 SHORT $LN19@create_ckd
$LN18@create_ckd:

; 1047 :             else
; 1048 :             {
; 1049 :                 strlcpy( sfname + i, "_1", sizeof(sfname)-(size_t)i );

  0066f	b8 04 01 00 00	 mov	 eax, 260		; 00000104H
  00674	48 2b 84 24 a8
	00 00 00	 sub	 rax, QWORD PTR i$1[rsp]
  0067c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR i$1[rsp]
  00684	48 8d 8c 0c 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp+rcx]
  0068c	4c 8b c0	 mov	 r8, rax
  0068f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169271
  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1050 :                 STRLCAT( sfname, fname + i );

  0069c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i$1[rsp]
  006a4	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  006ac	48 03 c8	 add	 rcx, rax
  006af	48 8b c1	 mov	 rax, rcx
  006b2	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  006b8	48 8b d0	 mov	 rdx, rax
  006bb	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  006c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 1051 :                 suffix = sfname + i + 1;

  006c9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR i$1[rsp]
  006d1	48 8d 84 04 41
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax+1]
  006d9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN19@create_ckd:

; 1052 :             }
; 1053 :         }

  006e1	eb 65		 jmp	 SHORT $LN17@create_ckd
$LN16@create_ckd:

; 1054 :         else
; 1055 :         {
; 1056 :             if (strlen(sfname) < 2 || sfname[strlen(sfname)-2] == '_')

  006e3	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  006eb	e8 00 00 00 00	 call	 strlen
  006f0	48 83 f8 02	 cmp	 rax, 2
  006f4	72 1a		 jb	 SHORT $LN21@create_ckd
  006f6	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  006fe	e8 00 00 00 00	 call	 strlen
  00703	0f be 84 04 3e
	01 00 00	 movsx	 eax, BYTE PTR sfname$[rsp+rax-2]
  0070b	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0070e	75 1b		 jne	 SHORT $LN20@create_ckd
$LN21@create_ckd:

; 1057 :                 STRLCAT( sfname, "_1" );

  00710	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00716	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169274
  0071d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN20@create_ckd:

; 1058 :             suffix = sfname + strlen(sfname) - 1;

  0072b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00733	e8 00 00 00 00	 call	 strlen
  00738	48 8d 84 04 3f
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  00740	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN17@create_ckd:
$LN14@create_ckd:

; 1059 :         }
; 1060 :     }
; 1061 : 
; 1062 :     /* Generate a random serial number for this new dasd */
; 1063 :     gen_dasd_serial( serial );

  00748	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR serial$[rsp]
  00750	e8 00 00 00 00	 call	 gen_dasd_serial

; 1064 : 
; 1065 :     /* Create the DASD image files */
; 1066 :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  00755	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0
  00760	c6 84 24 90 00
	00 00 01	 mov	 BYTE PTR fileseq$[rsp], 1
  00768	eb 2a		 jmp	 SHORT $LN4@create_ckd
$LN2@create_ckd:

; 1067 :             cyl += maxcpif, fileseq++)

  0076a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  00771	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00778	03 c8		 add	 ecx, eax
  0077a	8b c1		 mov	 eax, ecx
  0077c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax
  00783	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  0078b	fe c0		 inc	 al
  0078d	88 84 24 90 00
	00 00		 mov	 BYTE PTR fileseq$[rsp], al
$LN4@create_ckd:

; 1064 : 
; 1065 :     /* Create the DASD image files */
; 1066 :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  00794	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0079b	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR cyl$[rsp], eax
  007a2	0f 83 6b 01 00
	00		 jae	 $LN3@create_ckd

; 1068 :     {
; 1069 :         /* Insert the file sequence number in the file name */
; 1070 :         if (suffix)

  007a8	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR suffix$[rsp], 0
  007b1	74 39		 je	 SHORT $LN22@create_ckd

; 1071 :         {
; 1072 :             if ( fileseq <= 9 )

  007b3	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  007bb	83 f8 09	 cmp	 eax, 9
  007be	7f 17		 jg	 SHORT $LN23@create_ckd

; 1073 :                 *suffix = '0' + fileseq;

  007c0	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  007c8	83 c0 30	 add	 eax, 48			; 00000030H
  007cb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  007d3	88 01		 mov	 BYTE PTR [rcx], al
  007d5	eb 15		 jmp	 SHORT $LN24@create_ckd
$LN23@create_ckd:

; 1074 :             else
; 1075 :                 *suffix = 'A' - 10 + fileseq;

  007d7	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR fileseq$[rsp]
  007df	83 c0 37	 add	 eax, 55			; 00000037H
  007e2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  007ea	88 01		 mov	 BYTE PTR [rcx], al
$LN24@create_ckd:
$LN22@create_ckd:

; 1076 :         }
; 1077 : 
; 1078 :         /* Calculate the ending cylinder for this file */
; 1079 :         if (cyl + maxcpif < volcyls)

  007ec	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  007f3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  007fa	03 c8		 add	 ecx, eax
  007fc	8b c1		 mov	 eax, ecx
  007fe	3b 84 24 10 03
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00805	73 1b		 jae	 SHORT $LN25@create_ckd

; 1080 :             endcyl = cyl + maxcpif - 1;

  00807	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0080e	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR maxcpif$[rsp]
  00815	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00819	89 84 24 c8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
  00820	eb 10		 jmp	 SHORT $LN26@create_ckd
$LN25@create_ckd:

; 1081 :         else
; 1082 :             endcyl = volcyls - 1;

  00822	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00829	ff c8		 dec	 eax
  0082b	89 84 24 c8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
$LN26@create_ckd:

; 1083 : 
; 1084 :         /* Create a CKD DASD image file */
; 1085 :         rc = create_ckd64_file (sfname, fileseq, devtype, heads,

  00832	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flagMachinecheck$[rsp]
  0083a	88 84 24 80 00
	00 00		 mov	 BYTE PTR [rsp+128], al
  00841	0f b6 84 24 48
	03 00 00	 movzx	 eax, BYTE PTR flagECmode$[rsp]
  00849	88 44 24 78	 mov	 BYTE PTR [rsp+120], al
  0084d	0f b6 84 24 40
	03 00 00	 movzx	 eax, BYTE PTR rawflag$[rsp]
  00855	88 44 24 70	 mov	 BYTE PTR [rsp+112], al
  00859	0f b6 84 24 38
	03 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  00861	88 44 24 68	 mov	 BYTE PTR [rsp+104], al
  00865	0f b6 84 24 30
	03 00 00	 movzx	 eax, BYTE PTR dasdcopy$[rsp]
  0086d	88 44 24 60	 mov	 BYTE PTR [rsp+96], al
  00871	0f b6 84 24 20
	03 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  00879	88 44 24 58	 mov	 BYTE PTR [rsp+88], al
  0087d	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  00885	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0088a	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR serial$[rsp]
  00892	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00897	8b 84 24 10 03
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0089e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  008a2	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  008a9	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  008ad	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  008b4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008b8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008c5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  008cc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008d0	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR heads$[rsp]
  008d8	44 0f b7 84 24
	f8 02 00 00	 movzx	 r8d, WORD PTR devtype$[rsp]
  008e1	0f b6 94 24 90
	00 00 00	 movzx	 edx, BYTE PTR fileseq$[rsp]
  008e9	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  008f1	e8 00 00 00 00	 call	 create_ckd64_file
  008f6	89 84 24 d4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1086 :                     trksize, buf, cyl, endcyl, volcyls, serial, volser,
; 1087 :                     comp, dasdcopy, nullfmt, rawflag,
; 1088 :                     flagECmode, flagMachinecheck);
; 1089 :         if (rc < 0) return -1;

  008fd	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00905	7d 07		 jge	 SHORT $LN27@create_ckd
  00907	b8 ff ff ff ff	 mov	 eax, -1
  0090c	eb 15		 jmp	 SHORT $LN1@create_ckd
$LN27@create_ckd:

; 1090 :     }

  0090e	e9 57 fe ff ff	 jmp	 $LN2@create_ckd
$LN3@create_ckd:

; 1091 : 
; 1092 :     /* Release data buffer */
; 1093 :     free (buf);

  00913	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0091b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1094 : 
; 1095 :     return 0;

  00921	33 c0		 xor	 eax, eax
$LN1@create_ckd:

; 1096 : } /* end function create_ckd64 */

  00923	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0092b	48 33 cc	 xor	 rcx, rsp
  0092e	e8 00 00 00 00	 call	 __security_check_cookie
  00933	48 81 c4 e0 02
	00 00		 add	 rsp, 736		; 000002e0H
  0093a	5f		 pop	 rdi
  0093b	c3		 ret	 0
create_ckd64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
cif$ = 96
dev$ = 104
argc$ = 112
tv145 = 116
tv154 = 120
tv82 = 124
tv86 = 128
tv169 = 132
tv173 = 136
rc$ = 140
tv209 = 144
tv213 = 148
tv241 = 152
tv245 = 156
fba$ = 160
tv206 = 168
tv71 = 176
argv$ = 184
buf$1 = 200
__$ArrayPad$ = 240
fname$ = 272
sfname$ = 280
omode$ = 288
option$ = 296
open_fba64_image PROC

; 259  : {

$LN15:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 260  : int             rc;                     /* Return code               */
; 261  : CIFBLK         *cif;                    /* FBA image file descriptor */
; 262  : DEVBLK         *dev;                    /* FBA device block          */
; 263  : FBADEV         *fba;                    /* FBA DASD table entry      */
; 264  : char           *argv[2];                /* Arguments to              */
; 265  : int             argc=0;                 /*  device open              */

  0002d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR argc$[rsp], 0

; 266  : 
; 267  :     /* Obtain storage for the file descriptor structure */
; 268  :     cif = (CIFBLK*) calloc( 1, sizeof(CIFBLK) );

  00035	ba d0 1b 00 00	 mov	 edx, 7120		; 00001bd0H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00045	48 89 44 24 60	 mov	 QWORD PTR cif$[rsp], rax

; 269  :     if (cif == NULL)

  0004a	48 83 7c 24 60
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00050	0f 85 dd 00 00
	00		 jne	 $LN2@open_fba64

; 270  :     {
; 271  :         char buf[40];
; 272  :         MSGBUF(buf, "calloc(1,%d)", (int)sizeof(CIFBLK));

  00056	41 b9 d0 1b 00
	00		 mov	 r9d, 7120		; 00001bd0H
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168790
  00063	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00068	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 273  :         FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00084	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  0008c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00091	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00095	89 4c 24 7c	 mov	 DWORD PTR tv82[rsp], ecx
  00099	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  0009e	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  000a2	d1 fa		 sar	 edx, 1
  000a4	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv86[rsp], edx
  000ab	b9 02 00 00 00	 mov	 ecx, 2
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  000be	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000c3	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000cb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000dd	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv82[rsp]
  000e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  000ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168791
  000f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168792
  00103	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00108	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168793
  0011a	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168794
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 274  :             cif->devblk.devnum, fname, buf, strerror( errno ));
; 275  :         return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 85 04 00 00	 jmp	 $LN1@open_fba64
$LN2@open_fba64:

; 276  :     }
; 277  : 
; 278  :     /* Initialize the devblk */
; 279  :     dev = &cif->devblk;

  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00138	48 83 c0 30	 add	 rax, 48			; 00000030H
  0013c	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 280  :     dev->fd = -1;

  00141	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00146	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 281  :     dev->cckd64 = 1;

  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00155	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0015c	0c 01		 or	 al, 1
  0015e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00163	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 282  :     if ((omode & O_RDWR) == 0) dev->ckdrdonly = 1;

  00169	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR omode$[rsp]
  00170	83 e0 02	 and	 eax, 2
  00173	85 c0		 test	 eax, eax
  00175	75 1a		 jne	 SHORT $LN3@open_fba64
  00177	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0017c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00182	0f ba e8 12	 bts	 eax, 18
  00186	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0018b	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN3@open_fba64:

; 283  :     dev->batch = 1;

  00191	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00196	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0019c	0f ba e8 0a	 bts	 eax, 10
  001a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001a5	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 284  :     dev->dasdcopy  = (option & IMAGE_OPEN_DASDCOPY) ? 1 : 0;

  001ab	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001b2	83 e0 01	 and	 eax, 1
  001b5	85 c0		 test	 eax, eax
  001b7	74 0a		 je	 SHORT $LN9@open_fba64
  001b9	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  001c1	eb 08		 jmp	 SHORT $LN10@open_fba64
$LN9@open_fba64:
  001c3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN10@open_fba64:
  001cb	8b 44 24 74	 mov	 eax, DWORD PTR tv145[rsp]
  001cf	83 e0 01	 and	 eax, 1
  001d2	c1 e0 0b	 shl	 eax, 11
  001d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001da	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  001e0	0f ba f1 0b	 btr	 ecx, 11
  001e4	0b c8		 or	 ecx, eax
  001e6	8b c1		 mov	 eax, ecx
  001e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001ed	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 285  :     dev->quiet     = (option & IMAGE_OPEN_QUIET)    ? 1 : 0;

  001f3	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001fa	83 e0 02	 and	 eax, 2
  001fd	85 c0		 test	 eax, eax
  001ff	74 0a		 je	 SHORT $LN11@open_fba64
  00201	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00209	eb 08		 jmp	 SHORT $LN12@open_fba64
$LN11@open_fba64:
  0020b	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN12@open_fba64:
  00213	8b 44 24 78	 mov	 eax, DWORD PTR tv154[rsp]
  00217	83 e0 01	 and	 eax, 1
  0021a	c1 e0 0c	 shl	 eax, 12
  0021d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00222	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  00228	0f ba f1 0c	 btr	 ecx, 12
  0022c	0b c8		 or	 ecx, eax
  0022e	8b c1		 mov	 eax, ecx
  00230	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00235	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 286  : 
; 287  :     /* Set the device type */
; 288  :     fba = dasd_lookup (DASD_FBADEV, NULL, DEFAULT_FBA_TYPE, 0);

  0023b	45 33 c9	 xor	 r9d, r9d
  0023e	41 b8 70 33 00
	00		 mov	 r8d, 13168		; 00003370H
  00244	33 d2		 xor	 edx, edx
  00246	b9 03 00 00 00	 mov	 ecx, 3
  0024b	e8 00 00 00 00	 call	 dasd_lookup
  00250	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 289  :     if (fba == NULL)

  00258	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  00261	0f 85 a6 00 00
	00		 jne	 $LN4@open_fba64

; 290  :     {
; 291  :         FWRMSG( stderr, HHC00451, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00267	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  0026c	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00270	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  00277	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0027c	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00280	d1 f9		 sar	 ecx, 1
  00282	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv173[rsp], ecx
  00289	b9 02 00 00 00	 mov	 ecx, 2
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00294	c7 44 24 50 70
	33 00 00	 mov	 DWORD PTR [rsp+80], 13168 ; 00003370H
  0029c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002a4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002a9	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  002b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002b4	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  002bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168797
  002c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168798
  002d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168799
  002e9	ba 24 01 00 00	 mov	 edx, 292		; 00000124H
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168800
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 292  :             cif->devblk.devnum, fname, DEFAULT_FBA_TYPE );
; 293  :         free (cif);

  002fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 294  :         return NULL;

  00306	33 c0		 xor	 eax, eax
  00308	e9 ab 02 00 00	 jmp	 $LN1@open_fba64
$LN4@open_fba64:

; 295  :     }
; 296  :     dev->devtype = fba->devt;

  0030d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00312	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fba$[rsp]
  0031a	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  0031e	66 89 48 4a	 mov	 WORD PTR [rax+74], cx

; 297  : 
; 298  :     /* Set the device handlers */
; 299  :     dev->hnd = &fba_dasd_device_hndinfo;

  00322	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fba_dasd_device_hndinfo
  0032e	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 300  : 
; 301  :     /* Set the device number */
; 302  :     dev->devnum = next_util_devnum();

  00335	e8 00 00 00 00	 call	 next_util_devnum
  0033a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0033f	66 89 41 48	 mov	 WORD PTR [rcx+72], ax

; 303  : 
; 304  :     /* Build arguments for fba_dasd_init_handler */
; 305  :     argv[0] = fname;

  00343	b8 08 00 00 00	 mov	 eax, 8
  00348	48 6b c0 00	 imul	 rax, rax, 0
  0034c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00354	48 89 8c 04 b8
	00 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 306  :     argc++;

  0035c	8b 44 24 70	 mov	 eax, DWORD PTR argc$[rsp]
  00360	ff c0		 inc	 eax
  00362	89 44 24 70	 mov	 DWORD PTR argc$[rsp], eax

; 307  :     if (sfname != NULL)

  00366	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  0036f	74 23		 je	 SHORT $LN5@open_fba64

; 308  :     {
; 309  :         argv[1] = sfname;

  00371	b8 08 00 00 00	 mov	 eax, 8
  00376	48 6b c0 01	 imul	 rax, rax, 1
  0037a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR sfname$[rsp]
  00382	48 89 8c 04 b8
	00 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 310  :         argc++;

  0038a	8b 44 24 70	 mov	 eax, DWORD PTR argc$[rsp]
  0038e	ff c0		 inc	 eax
  00390	89 44 24 70	 mov	 DWORD PTR argc$[rsp], eax
$LN5@open_fba64:

; 311  :     }
; 312  : 
; 313  :     /* Call the device handler initialization function */
; 314  :     rc = (dev->hnd->init)(dev, argc, argv);

  00394	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00399	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  003a0	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR argv$[rsp]
  003a8	8b 54 24 70	 mov	 edx, DWORD PTR argc$[rsp]
  003ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  003b1	ff 10		 call	 QWORD PTR [rax]
  003b3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 315  :     if (rc < 0)

  003ba	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003c2	0f 8d ca 00 00
	00		 jge	 $LN6@open_fba64

; 316  :     {
; 317  :         // "%1d:%04X CKD file %s: initialization failed"
; 318  :         FWRMSG( stderr, HHC00452, "E", SSID_TO_LCSS(cif->devblk.ssid),

  003c8	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  003d1	74 12		 je	 SHORT $LN13@open_fba64
  003d3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  003db	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  003e3	eb 0f		 jmp	 SHORT $LN14@open_fba64
$LN13@open_fba64:
  003e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168803
  003ec	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
$LN14@open_fba64:
  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  003f9	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  003fd	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv209[rsp], eax
  00404	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00409	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  0040d	d1 f9		 sar	 ecx, 1
  0040f	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv213[rsp], ecx
  00416	b9 02 00 00 00	 mov	 ecx, 2
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00421	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  00429	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0042e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  00435	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00439	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv213[rsp]
  00440	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168804
  0044b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168805
  00457	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00461	41 b9 03 00 00
	00		 mov	 r9d, 3
  00467	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168806
  0046e	ba 3f 01 00 00	 mov	 edx, 319		; 0000013fH
  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168807
  0047a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 319  :             cif->devblk.devnum, fname ? fname : "(null)" );
; 320  :         free (cif);

  00480	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 321  :         return NULL;

  0048b	33 c0		 xor	 eax, eax
  0048d	e9 26 01 00 00	 jmp	 $LN1@open_fba64
$LN6@open_fba64:

; 322  :     }
; 323  : 
; 324  :     /* Set CIF fields */
; 325  :     cif->fname = fname;

  00492	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00497	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0049f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 326  :     cif->fd = dev->fd;

  004a2	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004ac	8b 89 ac 01 00
	00		 mov	 ecx, DWORD PTR [rcx+428]
  004b2	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 327  : 
; 328  :     /* Extract the number of sectors and the sector size */
; 329  :     cif->heads = dev->fbanumblk;

  004b5	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004bf	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  004c5	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 330  :     cif->trksz = dev->fbablksiz;

  004c8	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004cd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004d2	8b 89 8c 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4492]
  004d8	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 331  :     if (is_verbose_util())

  004db	e8 00 00 00 00	 call	 is_verbose_util
  004e0	0f b6 c0	 movzx	 eax, al
  004e3	85 c0		 test	 eax, eax
  004e5	0f 84 a4 00 00
	00		 je	 $LN7@open_fba64

; 332  :     {
; 333  :        FWRMSG( stdout, HHC00454, "I", SSID_TO_LCSS(cif->devblk.ssid),

  004eb	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  004f0	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  004f4	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  004fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00500	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00504	d1 f9		 sar	 ecx, 1
  00506	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv245[rsp], ecx
  0050d	b9 01 00 00 00	 mov	 ecx, 1
  00512	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00518	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0051d	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00520	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00524	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00529	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0052c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00530	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00538	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0053d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  00544	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00548	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  0054f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168809
  0055a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168810
  00566	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00570	41 b9 03 00 00
	00		 mov	 r9d, 3
  00576	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168811
  0057d	ba 4e 01 00 00	 mov	 edx, 334		; 0000014eH
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168812
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@open_fba64:

; 334  :            cif->devblk.devnum, fname, cif->heads, cif->trksz );
; 335  :     }
; 336  : 
; 337  :     /* Indicate that the track buffer is empty */
; 338  :     cif->curcyl = -1;

  0058f	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00594	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH

; 339  :     cif->curhead = -1;

  0059b	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  005a0	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [rax+28], -1	; ffffffffH

; 340  :     cif->trkmodif = 0;

  005a7	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  005ac	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 341  : 
; 342  :     return cif;

  005b3	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
$LN1@open_fba64:

; 343  : } /* end function open_fba64_image */

  005b8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c0	48 33 cc	 xor	 rcx, rsp
  005c3	e8 00 00 00 00	 call	 __security_check_cookie
  005c8	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  005cf	c3		 ret	 0
open_fba64_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdutil64.c
_TEXT	SEGMENT
cif$ = 96
dev$ = 104
fd$ = 112
argc$ = 116
i$1 = 120
s$2 = 128
tv145 = 136
tv154 = 140
iLen$ = 144
p$3 = 152
rmtdev$ = 160
tv321 = 168
tv325 = 172
tv344 = 176
tv349 = 180
tv353 = 184
rc$ = 188
tv398 = 192
tv402 = 196
tv442 = 200
tv446 = 204
tv82 = 208
tv86 = 212
tv246 = 216
tv250 = 220
tv280 = 224
tv284 = 228
suffix$4 = 232
ckd$ = 240
tv395 = 248
tv71 = 256
tv238 = 264
tv272 = 272
argv$ = 280
devhdr$ = 304
buf$5 = 816
typname$ = 864
sfxname$ = 928
pathname$ = 1456
__$ArrayPad$ = 1728
fname$ = 1760
sfname$ = 1768
omode$ = 1776
option$ = 1784
open_ckd64_image PROC

; 38   : {

$LN38:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 06
	00 00		 sub	 rsp, 1752		; 000006d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 39   : int             fd;                     /* File descriptor           */
; 40   : int             rc;                     /* Return code               */
; 41   : int             iLen;                   /* Record length             */
; 42   : CKD_DEVHDR      devhdr;                 /* CKD device header         */
; 43   : CIFBLK         *cif;                    /* CKD image file descriptor */
; 44   : DEVBLK         *dev;                    /* CKD device block          */
; 45   : CKDDEV         *ckd;                    /* CKD DASD table entry      */
; 46   : char           *rmtdev;                 /* Possible remote device    */
; 47   : char           *argv[2];                /* Arguments to              */
; 48   : int             argc=0;                 /*                           */

  0002d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR argc$[rsp], 0

; 49   : char            sfxname[FILENAME_MAX*2];/* Suffixed file name        */
; 50   : char            typname[64];
; 51   : char            pathname[MAX_PATH];     /* file path in host format  */
; 52   : 
; 53   :     /* Obtain storage for the file descriptor structure */
; 54   :     cif = (CIFBLK*) calloc (1,sizeof(CIFBLK));

  00035	ba d0 1b 00 00	 mov	 edx, 7120		; 00001bd0H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00045	48 89 44 24 60	 mov	 QWORD PTR cif$[rsp], rax

; 55   :     if (cif == NULL)

  0004a	48 83 7c 24 60
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00050	0f 85 e3 00 00
	00		 jne	 $LN5@open_ckd64

; 56   :     {
; 57   :         char buf[40];
; 58   :         MSGBUF(buf, "calloc(1,%d)", (int)sizeof(CIFBLK));

  00056	41 b9 d0 1b 00
	00		 mov	 r9d, 7120		; 00001bd0H
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168700
  00063	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00068	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 59   :         FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00084	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv71[rsp], rax
  0008c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00091	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00095	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv82[rsp], ecx
  0009c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  000a1	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  000a5	d1 fa		 sar	 edx, 1
  000a7	89 94 24 d4 00
	00 00		 mov	 DWORD PTR tv86[rsp], edx
  000ae	b9 02 00 00 00	 mov	 ecx, 2
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  000c1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000c6	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  000ce	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d3	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000db	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e0	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  000e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000eb	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  000f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168701
  000fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168702
  00109	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	41 b9 03 00 00
	00		 mov	 r9d, 3
  00119	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168703
  00120	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168704
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 60   :             cif->devblk.devnum, fname, buf, strerror( errno ));
; 61   :         return NULL;

  00132	33 c0		 xor	 eax, eax
  00134	e9 32 0b 00 00	 jmp	 $LN1@open_ckd64
$LN5@open_ckd64:

; 62   :     }
; 63   : 
; 64   :     /* Initialize the devblk */
; 65   :     dev = &cif->devblk;

  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  0013e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00142	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 66   :     dev->cckd64 = 1;

  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00153	0c 01		 or	 al, 1
  00155	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0015a	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 67   :     if ((omode & O_RDWR) == 0) dev->ckdrdonly = 1;

  00160	8b 84 24 f0 06
	00 00		 mov	 eax, DWORD PTR omode$[rsp]
  00167	83 e0 02	 and	 eax, 2
  0016a	85 c0		 test	 eax, eax
  0016c	75 1a		 jne	 SHORT $LN6@open_ckd64
  0016e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00173	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00179	0f ba e8 12	 bts	 eax, 18
  0017d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00182	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN6@open_ckd64:

; 68   :     dev->fd = -1;

  00188	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0018d	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 69   :     dev->batch = 1;

  00197	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0019c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a2	0f ba e8 0a	 bts	 eax, 10
  001a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001ab	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 70   :     dev->dasdcopy  = (option & IMAGE_OPEN_DASDCOPY) ? 1 : 0;

  001b1	8b 84 24 f8 06
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  001b8	83 e0 01	 and	 eax, 1
  001bb	85 c0		 test	 eax, eax
  001bd	74 0d		 je	 SHORT $LN32@open_ckd64
  001bf	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  001ca	eb 0b		 jmp	 SHORT $LN33@open_ckd64
$LN32@open_ckd64:
  001cc	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN33@open_ckd64:
  001d7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  001de	83 e0 01	 and	 eax, 1
  001e1	c1 e0 0b	 shl	 eax, 11
  001e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  001ef	0f ba f1 0b	 btr	 ecx, 11
  001f3	0b c8		 or	 ecx, eax
  001f5	8b c1		 mov	 eax, ecx
  001f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  001fc	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 71   :     dev->quiet     = (option & IMAGE_OPEN_QUIET)    ? 1 : 0;

  00202	8b 84 24 f8 06
	00 00		 mov	 eax, DWORD PTR option$[rsp]
  00209	83 e0 02	 and	 eax, 2
  0020c	85 c0		 test	 eax, eax
  0020e	74 0d		 je	 SHORT $LN34@open_ckd64
  00210	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv154[rsp], 1
  0021b	eb 0b		 jmp	 SHORT $LN35@open_ckd64
$LN34@open_ckd64:
  0021d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
$LN35@open_ckd64:
  00228	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  0022f	83 e0 01	 and	 eax, 1
  00232	c1 e0 0c	 shl	 eax, 12
  00235	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0023a	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  00240	0f ba f1 0c	 btr	 ecx, 12
  00244	0b c8		 or	 ecx, eax
  00246	8b c1		 mov	 eax, ecx
  00248	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0024d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 72   : 
; 73   :     /* If the filename has a `:' then it may be a remote device */
; 74   :     if ((rmtdev = strchr(fname, ':')))

  00253	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00258	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00260	e8 00 00 00 00	 call	 strchr
  00265	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rmtdev$[rsp], rax
  0026d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rmtdev$[rsp], 0
  00276	74 6e		 je	 SHORT $LN7@open_ckd64

; 75   :     {
; 76   :         /* Verify port number follows colon */
; 77   :         char *p;
; 78   :         for (p = rmtdev + 1; *p && *p != ':'; p++)

  00278	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rmtdev$[rsp]
  00280	48 ff c0	 inc	 rax
  00283	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$3[rsp], rax
  0028b	eb 13		 jmp	 SHORT $LN4@open_ckd64
$LN2@open_ckd64:
  0028d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  00295	48 ff c0	 inc	 rax
  00298	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$3[rsp], rax
$LN4@open_ckd64:
  002a0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002a8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ab	85 c0		 test	 eax, eax
  002ad	74 37		 je	 SHORT $LN3@open_ckd64
  002af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ba	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  002bd	74 27		 je	 SHORT $LN3@open_ckd64

; 79   :         {
; 80   :             if (!isdigit(*p))  /* (port numbers are always numeric) */

  002bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$3[rsp]
  002c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ca	8b c8		 mov	 ecx, eax
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  002d2	85 c0		 test	 eax, eax
  002d4	75 0e		 jne	 SHORT $LN8@open_ckd64

; 81   :             {
; 82   :                 /* Not a port number ==> not really a remote device */
; 83   :                 rmtdev = NULL;

  002d6	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rmtdev$[rsp], 0

; 84   :                 break;

  002e2	eb 02		 jmp	 SHORT $LN3@open_ckd64
$LN8@open_ckd64:

; 85   :             }
; 86   :         }

  002e4	eb a7		 jmp	 SHORT $LN2@open_ckd64
$LN3@open_ckd64:
$LN7@open_ckd64:

; 87   :     }
; 88   : 
; 89   :     /* Read the device header so we can determine the device type */
; 90   :     STRLCPY( sfxname, fname );

  002e6	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  002ec	48 8b 94 24 e0
	06 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  002f4	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 91   :     hostpath(pathname, sfxname, sizeof(pathname));

  00302	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00308	48 8d 94 24 a0
	03 00 00	 lea	 rdx, QWORD PTR sfxname$[rsp]
  00310	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 92   :     fd = HOPEN (pathname, omode);

  0031e	8b 94 24 f0 06
	00 00		 mov	 edx, DWORD PTR omode$[rsp]
  00325	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00333	89 44 24 70	 mov	 DWORD PTR fd$[rsp], eax

; 93   :     if (fd < 0)

  00337	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  0033c	0f 8d dc 02 00
	00		 jge	 $LN9@open_ckd64

; 94   :     {
; 95   :         /* If no shadow file name was specified, then try opening the
; 96   :            file with the file sequence number in the name */
; 97   :         if (sfname == NULL)

  00342	48 83 bc 24 e8
	06 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  0034b	0f 85 c1 01 00
	00		 jne	 $LN10@open_ckd64

; 98   :         {
; 99   :             ptrdiff_t i;
; 100  :             char *s,*suffix;
; 101  : 
; 102  :             /* Look for last slash marking end of directory name */
; 103  :             s = strrchr (fname, PATHSEPC);

  00351	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00356	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0035e	e8 00 00 00 00	 call	 strrchr
  00363	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax

; 104  :             if (s == NULL) s = fname;

  0036b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR s$2[rsp], 0
  00374	75 10		 jne	 SHORT $LN11@open_ckd64
  00376	48 8b 84 24 e0
	06 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  0037e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax
$LN11@open_ckd64:

; 105  : 
; 106  :             /* Insert suffix before first dot in file name, or
; 107  :                append suffix to file name if there is no dot.
; 108  :                If the filename already has a place for the suffix
; 109  :                then use that. */
; 110  :             s = strchr (s, '.');

  00386	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0038b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$2[rsp]
  00393	e8 00 00 00 00	 call	 strchr
  00398	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$2[rsp], rax

; 111  :             if (s != NULL)

  003a0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR s$2[rsp], 0
  003a9	0f 84 be 00 00
	00		 je	 $LN12@open_ckd64

; 112  :             {
; 113  :                 i = s - fname;

  003af	48 8b 84 24 e0
	06 00 00	 mov	 rax, QWORD PTR fname$[rsp]
  003b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$2[rsp]
  003bf	48 2b c8	 sub	 rcx, rax
  003c2	48 8b c1	 mov	 rax, rcx
  003c5	48 89 44 24 78	 mov	 QWORD PTR i$1[rsp], rax

; 114  :                 if (i > 2 && fname[i-2] == '_')

  003ca	48 83 7c 24 78
	02		 cmp	 QWORD PTR i$1[rsp], 2
  003d0	7e 33		 jle	 SHORT $LN14@open_ckd64
  003d2	48 8b 44 24 78	 mov	 rax, QWORD PTR i$1[rsp]
  003d7	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  003df	48 03 c8	 add	 rcx, rax
  003e2	48 8b c1	 mov	 rax, rcx
  003e5	0f be 40 fe	 movsx	 eax, BYTE PTR [rax-2]
  003e9	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  003ec	75 17		 jne	 SHORT $LN14@open_ckd64

; 115  :                     suffix = sfxname + i - 1;

  003ee	48 8b 44 24 78	 mov	 rax, QWORD PTR i$1[rsp]
  003f3	48 8d 84 04 9f
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax-1]
  003fb	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
  00403	eb 66		 jmp	 SHORT $LN15@open_ckd64
$LN14@open_ckd64:

; 116  :                 else
; 117  :                 {
; 118  :                     strlcpy( sfxname + i, "_1", sizeof(sfxname)-(size_t)i );

  00405	b8 08 02 00 00	 mov	 eax, 520		; 00000208H
  0040a	48 2b 44 24 78	 sub	 rax, QWORD PTR i$1[rsp]
  0040f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$1[rsp]
  00414	48 8d 8c 0c a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp+rcx]
  0041c	4c 8b c0	 mov	 r8, rax
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168715
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 119  :                     STRLCAT( sfxname, fname + i );

  0042c	48 8b 44 24 78	 mov	 rax, QWORD PTR i$1[rsp]
  00431	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00439	48 03 c8	 add	 rcx, rax
  0043c	48 8b c1	 mov	 rax, rcx
  0043f	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00445	48 8b d0	 mov	 rdx, rax
  00448	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 120  :                     suffix = sfxname + i + 1;

  00456	48 8b 44 24 78	 mov	 rax, QWORD PTR i$1[rsp]
  0045b	48 8d 84 04 a1
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax+1]
  00463	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
$LN15@open_ckd64:

; 121  :                 }
; 122  :             }

  0046b	eb 65		 jmp	 SHORT $LN13@open_ckd64
$LN12@open_ckd64:

; 123  :             else
; 124  :             {
; 125  :                 if (strlen(sfxname) < 2 || sfxname[strlen(sfxname)-2] != '_')

  0046d	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00475	e8 00 00 00 00	 call	 strlen
  0047a	48 83 f8 02	 cmp	 rax, 2
  0047e	72 1a		 jb	 SHORT $LN17@open_ckd64
  00480	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00488	e8 00 00 00 00	 call	 strlen
  0048d	0f be 84 04 9e
	03 00 00	 movsx	 eax, BYTE PTR sfxname$[rsp+rax-2]
  00495	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00498	74 1b		 je	 SHORT $LN16@open_ckd64
$LN17@open_ckd64:

; 126  :                     STRLCAT (sfxname, "_1" );

  0049a	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  004a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168718
  004a7	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN16@open_ckd64:

; 127  :                 suffix = sfxname + strlen(sfxname) - 1;

  004b5	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  004bd	e8 00 00 00 00	 call	 strlen
  004c2	48 8d 84 04 9f
	03 00 00	 lea	 rax, QWORD PTR sfxname$[rsp+rax-1]
  004ca	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR suffix$4[rsp], rax
$LN13@open_ckd64:

; 128  :             }
; 129  :             *suffix = '1';

  004d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR suffix$4[rsp]
  004da	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H

; 130  :             hostpath(pathname, sfxname, sizeof(pathname));

  004dd	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  004e3	48 8d 94 24 a0
	03 00 00	 lea	 rdx, QWORD PTR sfxname$[rsp]
  004eb	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 131  :             fd = HOPEN (pathname, omode);

  004f9	8b 94 24 f0 06
	00 00		 mov	 edx, DWORD PTR omode$[rsp]
  00500	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00508	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0050e	89 44 24 70	 mov	 DWORD PTR fd$[rsp], eax
$LN10@open_ckd64:

; 132  :         }
; 133  :         if (fd < 0 && rmtdev == NULL)

  00512	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00517	0f 8d de 00 00
	00		 jge	 $LN18@open_ckd64
  0051d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rmtdev$[rsp], 0
  00526	0f 85 cf 00 00
	00		 jne	 $LN18@open_ckd64

; 134  :         {
; 135  :             FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0052c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00532	8b 08		 mov	 ecx, DWORD PTR [rax]
  00534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0053a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv238[rsp], rax
  00542	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00547	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0054b	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv246[rsp], ecx
  00552	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  00557	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  0055b	d1 fa		 sar	 edx, 1
  0055d	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv250[rsp], edx
  00564	b9 02 00 00 00	 mov	 ecx, 2
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0056f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv238[rsp]
  00577	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0057c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168721
  00583	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00588	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0058d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00590	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00595	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv246[rsp]
  0059c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005a0	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  005a7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168722
  005b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168723
  005be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168724
  005d5	ba 88 00 00 00	 mov	 edx, 136		; 00000088H
  005da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168725
  005e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 136  :                 cif->devblk.devnum, cif->fname, "open()", strerror( errno ));
; 137  :             free (cif);

  005e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  005ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 138  :             return NULL;

  005f2	33 c0		 xor	 eax, eax
  005f4	e9 72 06 00 00	 jmp	 $LN1@open_ckd64

; 139  :         }

  005f9	eb 23		 jmp	 SHORT $LN19@open_ckd64
$LN18@open_ckd64:

; 140  :         else if (fd < 0) STRLCPY( sfxname, fname );

  005fb	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00600	7d 1c		 jge	 SHORT $LN20@open_ckd64
  00602	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00608	48 8b 94 24 e0
	06 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00610	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  00618	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN20@open_ckd64:
$LN19@open_ckd64:
$LN9@open_ckd64:

; 141  :     }
; 142  : 
; 143  :     /* If not a possible remote device, check the dasd header
; 144  :        and set the device type */
; 145  :     if (fd >= 0)

  0061e	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00623	0f 8c 75 03 00
	00		 jl	 $LN21@open_ckd64

; 146  :     {
; 147  :         iLen = read(fd, &devhdr, CKD_DEVHDR_SIZE);

  00629	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0062f	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  00637	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  0063b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00641	89 84 24 90 00
	00 00		 mov	 DWORD PTR iLen$[rsp], eax

; 148  :         if (iLen < 0)

  00648	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLen$[rsp], 0
  00650	0f 8d d7 00 00
	00		 jge	 $LN22@open_ckd64

; 149  :         {
; 150  :             FWRMSG( stderr, HHC00404, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0065c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0065e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00664	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv272[rsp], rax
  0066c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00671	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00675	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv280[rsp], ecx
  0067c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  00681	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  00685	d1 fa		 sar	 edx, 1
  00687	89 94 24 e4 00
	00 00		 mov	 DWORD PTR tv284[rsp], edx
  0068e	b9 02 00 00 00	 mov	 ecx, 2
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00699	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv272[rsp]
  006a1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168729
  006ad	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  006b7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006bf	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv280[rsp]
  006c6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006ca	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  006d1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168730
  006dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168731
  006e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168732
  006ff	ba 97 00 00 00	 mov	 edx, 151		; 00000097H
  00704	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168733
  0070b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 151  :                 cif->devblk.devnum, cif->fname, "read()", strerror( errno ));
; 152  :             close (fd);

  00711	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00715	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 153  :             free (cif);

  0071b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00720	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 154  :             return NULL;

  00726	33 c0		 xor	 eax, eax
  00728	e9 3e 05 00 00	 jmp	 $LN1@open_ckd64
$LN22@open_ckd64:

; 155  :         }
; 156  :         close (fd);

  0072d	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 157  : 
; 158  :         /* Error if no device header or not CKD non-shadow type */
; 159  :         if (0
; 160  :             || iLen < CKD_DEVHDR_SIZE
; 161  :             || !(dh_devid_typ( devhdr.dh_devid ) & CKD64_CMP_OR_NML_TYP)

  00737	33 c0		 xor	 eax, eax
  00739	85 c0		 test	 eax, eax
  0073b	75 2a		 jne	 SHORT $LN24@open_ckd64
  0073d	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR iLen$[rsp]
  00745	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  0074b	7c 1a		 jl	 SHORT $LN24@open_ckd64
  0074d	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00755	e8 00 00 00 00	 call	 dh_devid_typ
  0075a	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0075f	85 c0		 test	 eax, eax
  00761	0f 85 02 01 00
	00		 jne	 $LN23@open_ckd64
$LN24@open_ckd64:

; 162  :         )
; 163  :         {
; 164  :             if (dh_devid_typ( devhdr.dh_devid ) & CKD32_CMP_OR_NML_TYP)

  00767	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  0076f	e8 00 00 00 00	 call	 dh_devid_typ
  00774	25 00 00 00 c0	 and	 eax, -1073741824	; c0000000H
  00779	85 c0		 test	 eax, eax
  0077b	74 4e		 je	 SHORT $LN25@open_ckd64

; 165  :             {
; 166  :                 dev->cckd64 = 0;

  0077d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00782	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00789	24 fe		 and	 al, 254			; 000000feH
  0078b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00790	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 167  :                 free( cif );

  00796	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 168  :                 return open_ckd_image( fname, sfname, omode, option );

  007a1	44 8b 8c 24 f8
	06 00 00	 mov	 r9d, DWORD PTR option$[rsp]
  007a9	44 8b 84 24 f0
	06 00 00	 mov	 r8d, DWORD PTR omode$[rsp]
  007b1	48 8b 94 24 e8
	06 00 00	 mov	 rdx, QWORD PTR sfname$[rsp]
  007b9	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  007c1	e8 00 00 00 00	 call	 open_ckd_image
  007c6	e9 a0 04 00 00	 jmp	 $LN1@open_ckd64
$LN25@open_ckd64:

; 169  :             }
; 170  : 
; 171  :             // "%1d:%04X CKD file %s: ckd header invalid"
; 172  :             FWRMSG( stderr, HHC00406, "E", SSID_TO_LCSS( cif->devblk.ssid ),

  007cb	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  007d0	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  007d4	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv321[rsp], eax
  007db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  007e0	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  007e4	d1 f9		 sar	 ecx, 1
  007e6	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv325[rsp], ecx
  007ed	b9 02 00 00 00	 mov	 ecx, 2
  007f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  007fd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00800	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00805	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv321[rsp]
  0080c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00810	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv325[rsp]
  00817	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0081b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168737
  00822	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00827	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168738
  0082e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00833	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00838	41 b9 03 00 00
	00		 mov	 r9d, 3
  0083e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168739
  00845	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  0084a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168740
  00851	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 173  :                 cif->devblk.devnum, cif->fname );
; 174  :             free( cif );

  00857	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 175  :             return NULL;

  00862	33 c0		 xor	 eax, eax
  00864	e9 02 04 00 00	 jmp	 $LN1@open_ckd64
$LN23@open_ckd64:

; 176  :         }
; 177  : 
; 178  :         /* Set the device type */
; 179  :         ckd = dasd_lookup (DASD_CKDDEV, NULL, devhdr.dh_devtyp, 0);

  00869	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00871	45 33 c9	 xor	 r9d, r9d
  00874	44 8b c0	 mov	 r8d, eax
  00877	33 d2		 xor	 edx, edx
  00879	b9 01 00 00 00	 mov	 ecx, 1
  0087e	e8 00 00 00 00	 call	 dasd_lookup
  00883	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 180  :         if (ckd == NULL)

  0088b	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  00894	0f 85 b8 00 00
	00		 jne	 $LN26@open_ckd64

; 181  :         {
; 182  :             // "%1d:%04X CKD file %s: DASD table entry not found for devtype 0x%2.2X"
; 183  :             FWRMSG( stderr, HHC00451, "E", SSID_TO_LCSS(cif->devblk.ssid),

  0089a	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  008a2	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv344[rsp], eax
  008a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  008ae	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  008b2	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv349[rsp], ecx
  008b9	48 8b 54 24 60	 mov	 rdx, QWORD PTR cif$[rsp]
  008be	0f b7 52 74	 movzx	 edx, WORD PTR [rdx+116]
  008c2	d1 fa		 sar	 edx, 1
  008c4	89 94 24 b8 00
	00 00		 mov	 DWORD PTR tv353[rsp], edx
  008cb	b9 02 00 00 00	 mov	 ecx, 2
  008d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d6	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  008dd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  008e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  008e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008e9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008ee	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv349[rsp]
  008f5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008f9	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv353[rsp]
  00900	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00904	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168742
  0090b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00910	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168743
  00917	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00921	41 b9 03 00 00
	00		 mov	 r9d, 3
  00927	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168744
  0092e	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  00933	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168745
  0093a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 184  :                 cif->devblk.devnum, cif->fname, devhdr.dh_devtyp );
; 185  :             free (cif);

  00940	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00945	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 186  :             return NULL;

  0094b	33 c0		 xor	 eax, eax
  0094d	e9 19 03 00 00	 jmp	 $LN1@open_ckd64
$LN26@open_ckd64:

; 187  :         }
; 188  :         dev->devtype = ckd->devt;

  00952	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00957	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  0095f	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  00963	66 89 48 4a	 mov	 WORD PTR [rax+74], cx

; 189  :         MSGBUF(typname, "%4.4X", dev->devtype);

  00967	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0096c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00970	44 8b c8	 mov	 r9d, eax
  00973	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168746
  0097a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0097f	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR typname$[rsp]
  00987	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 190  :         dev->typname=typname;   /* Makes HDL Happy */

  0098d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00992	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR typname$[rsp]
  0099a	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
$LN21@open_ckd64:

; 191  :     }
; 192  : 
; 193  :     /* Set the device handlers */
; 194  :     dev->hnd = &ckd_dasd_device_hndinfo;

  0099e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  009a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckd_dasd_device_hndinfo
  009aa	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 195  : 
; 196  :     /* Set the device number */
; 197  :     dev->devnum = next_util_devnum();

  009b1	e8 00 00 00 00	 call	 next_util_devnum
  009b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009bb	66 89 41 48	 mov	 WORD PTR [rcx+72], ax

; 198  : 
; 199  :     /* Build arguments for ckd_dasd_init_handler */
; 200  :     argv[0] = sfxname;

  009bf	b8 08 00 00 00	 mov	 eax, 8
  009c4	48 6b c0 00	 imul	 rax, rax, 0
  009c8	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR sfxname$[rsp]
  009d0	48 89 8c 04 18
	01 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 201  :     argc++;

  009d8	8b 44 24 74	 mov	 eax, DWORD PTR argc$[rsp]
  009dc	ff c0		 inc	 eax
  009de	89 44 24 74	 mov	 DWORD PTR argc$[rsp], eax

; 202  :     if (sfname != NULL)

  009e2	48 83 bc 24 e8
	06 00 00 00	 cmp	 QWORD PTR sfname$[rsp], 0
  009eb	74 23		 je	 SHORT $LN27@open_ckd64

; 203  :     {
; 204  :         argv[1] = sfname;

  009ed	b8 08 00 00 00	 mov	 eax, 8
  009f2	48 6b c0 01	 imul	 rax, rax, 1
  009f6	48 8b 8c 24 e8
	06 00 00	 mov	 rcx, QWORD PTR sfname$[rsp]
  009fe	48 89 8c 04 18
	01 00 00	 mov	 QWORD PTR argv$[rsp+rax], rcx

; 205  :         argc++;

  00a06	8b 44 24 74	 mov	 eax, DWORD PTR argc$[rsp]
  00a0a	ff c0		 inc	 eax
  00a0c	89 44 24 74	 mov	 DWORD PTR argc$[rsp], eax
$LN27@open_ckd64:

; 206  :     }
; 207  : 
; 208  :     /* Call the device handler initialization function */
; 209  :     rc = (dev->hnd->init)(dev, argc, argv);

  00a10	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00a15	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a1c	4c 8d 84 24 18
	01 00 00	 lea	 r8, QWORD PTR argv$[rsp]
  00a24	8b 54 24 74	 mov	 edx, DWORD PTR argc$[rsp]
  00a28	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00a2d	ff 10		 call	 QWORD PTR [rax]
  00a2f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 210  :     if (rc < 0)

  00a36	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a3e	0f 8d ca 00 00
	00		 jge	 $LN28@open_ckd64

; 211  :     {
; 212  :         // "%1d:%04X CKD file %s: initialization failed"
; 213  :         FWRMSG( stderr, HHC00452, "E", SSID_TO_LCSS(cif->devblk.ssid),

  00a44	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a49	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00a4d	74 12		 je	 SHORT $LN36@open_ckd64
  00a4f	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a54	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a57	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv395[rsp], rax
  00a5f	eb 0f		 jmp	 SHORT $LN37@open_ckd64
$LN36@open_ckd64:
  00a61	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168749
  00a68	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv395[rsp], rax
$LN37@open_ckd64:
  00a70	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00a75	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00a79	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv398[rsp], eax
  00a80	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00a85	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00a89	d1 f9		 sar	 ecx, 1
  00a8b	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv402[rsp], ecx
  00a92	b9 02 00 00 00	 mov	 ecx, 2
  00a97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a9d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv395[rsp]
  00aa5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00aaa	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  00ab1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ab5	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv402[rsp]
  00abc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ac0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168750
  00ac7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00acc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168751
  00ad3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ad8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00add	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ae3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168752
  00aea	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  00aef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168753
  00af6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 214  :             cif->devblk.devnum, cif->fname ? cif->fname : "(null)" );
; 215  :         free (cif);

  00afc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00b01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 216  :         return NULL;

  00b07	33 c0		 xor	 eax, eax
  00b09	e9 5d 01 00 00	 jmp	 $LN1@open_ckd64
$LN28@open_ckd64:

; 217  :     }
; 218  : 
; 219  :     /* Call the device start exit */
; 220  :     if (dev->hnd->start) (dev->hnd->start) (dev);

  00b0e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b13	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b1a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00b1f	74 14		 je	 SHORT $LN29@open_ckd64
  00b21	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b26	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b2d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b32	ff 50 28	 call	 QWORD PTR [rax+40]
$LN29@open_ckd64:

; 221  : 
; 222  :     /* Set CIF fields */
; 223  :     cif->fname = fname;

  00b35	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b3a	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00b42	48 89 08	 mov	 QWORD PTR [rax], rcx

; 224  :     cif->fd = dev->fd;

  00b45	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b4a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b4f	8b 89 ac 01 00
	00		 mov	 ecx, DWORD PTR [rcx+428]
  00b55	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 225  : 
; 226  :     /* Extract the number of heads and the track size */
; 227  :     cif->heads = dev->ckdheads;

  00b58	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00b5d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b62	8b 89 c0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4800]
  00b68	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 228  :     FETCH_LE_FW( cif->trksz, devhdr.dh_trksize );

  00b6b	48 8d 8c 24 3c
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  00b73	e8 00 00 00 00	 call	 fetch_fw_noswap
  00b78	8b c8		 mov	 ecx, eax
  00b7a	e8 00 00 00 00	 call	 _byteswap_ulong
  00b7f	8b c8		 mov	 ecx, eax
  00b81	e8 00 00 00 00	 call	 _byteswap_ulong
  00b86	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00b8b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 229  : 
; 230  :     if (is_verbose_util())

  00b8e	e8 00 00 00 00	 call	 is_verbose_util
  00b93	0f b6 c0	 movzx	 eax, al
  00b96	85 c0		 test	 eax, eax
  00b98	0f 84 a4 00 00
	00		 je	 $LN30@open_ckd64

; 231  :     {
; 232  :        FWRMSG( stdout, HHC00453, "I", SSID_TO_LCSS(cif->devblk.ssid),

  00b9e	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00ba3	0f b7 40 78	 movzx	 eax, WORD PTR [rax+120]
  00ba7	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv442[rsp], eax
  00bae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bb3	0f b7 49 74	 movzx	 ecx, WORD PTR [rcx+116]
  00bb7	d1 f9		 sar	 ecx, 1
  00bb9	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv446[rsp], ecx
  00bc0	b9 01 00 00 00	 mov	 ecx, 1
  00bc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bcb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bd0	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00bd3	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bd7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00bdc	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  00bdf	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00be3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  00be8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00beb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bf0	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv442[rsp]
  00bf7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bfb	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv446[rsp]
  00c02	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168756
  00c0d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168757
  00c19	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c1e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c23	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c29	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168758
  00c30	ba e9 00 00 00	 mov	 edx, 233		; 000000e9H
  00c35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168759
  00c3c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@open_ckd64:

; 233  :            cif->devblk.devnum, cif->fname, cif->heads, cif->trksz );
; 234  :     }
; 235  : 
; 236  :     /* Indicate that the track buffer is empty */
; 237  :     cif->curcyl = -1;

  00c42	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c47	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1	; ffffffffH

; 238  :     cif->curhead = -1;

  00c4e	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c53	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [rax+28], -1	; ffffffffH

; 239  :     cif->trkmodif = 0;

  00c5a	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
  00c5f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 240  : 
; 241  :     return cif;

  00c66	48 8b 44 24 60	 mov	 rax, QWORD PTR cif$[rsp]
$LN1@open_ckd64:

; 242  : } /* end function open_ckd64_image */

  00c6b	48 8b 8c 24 c0
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c73	48 33 cc	 xor	 rcx, rsp
  00c76	e8 00 00 00 00	 call	 __security_check_cookie
  00c7b	48 81 c4 d8 06
	00 00		 add	 rsp, 1752		; 000006d8H
  00c82	c3		 ret	 0
open_ckd64_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
END
