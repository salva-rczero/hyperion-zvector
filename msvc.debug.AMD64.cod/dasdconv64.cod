; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	twelvehex00
PUBLIC	gz_magic_id
PUBLIC	ckd_ident
_BSS	SEGMENT
twelvehex00 DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
gz_magic_id DB	01fH
	DB	08bH
	ORG $+2
ckd_ident DB	043H
	DB	04bH
	DB	044H
	DB	05fH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_dh_devid_str:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG168851 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$delayed_exit DD imagerel delayed_exit
	DD	imagerel delayed_exit+34
	DD	imagerel $unwind$delayed_exit
$pdata$argexit DD imagerel argexit
	DD	imagerel argexit+222
	DD	imagerel $unwind$argexit
$pdata$read_input_data DD imagerel read_input_data
	DD	imagerel read_input_data+399
	DD	imagerel $unwind$read_input_data
$pdata$find_input_record DD imagerel find_input_record
	DD	imagerel find_input_record+613
	DD	imagerel $unwind$find_input_record
$pdata$open_input_image DD imagerel open_input_image
	DD	imagerel open_input_image+2336
	DD	imagerel $unwind$open_input_image
$pdata$convert_ckd_file DD imagerel convert_ckd_file
	DD	imagerel convert_ckd_file+2770
	DD	imagerel $unwind$convert_ckd_file
$pdata$convert_ckd DD imagerel convert_ckd
	DD	imagerel convert_ckd+1574
	DD	imagerel $unwind$convert_ckd
$pdata$main DD	imagerel $LN31
	DD	imagerel $LN31+1495
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG168799 DB	'DASD CKD64 image conversion', 00H
$SG168802 DB	'-', 00H
	ORG $+2
$SG168800 DB	'dasdconv64', 00H
	ORG $+1
$SG168806 DB	'-r', 00H
	ORG $+1
$SG168809 DB	'-q', 00H
	ORG $+1
$SG168812 DB	'-lfs', 00H
	ORG $+3
$SG168827 DB	'E', 00H
	ORG $+2
$SG168828 DB	'HHC02416%s Unknown device type %04X', 0aH, 00H
	ORG $+3
$SG168829 DB	'main', 00H
	ORG $+3
$SG168830 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168831 DB	'I', 00H
	ORG $+2
$SG168847 DB	'I', 00H
	ORG $+2
$SG168832 DB	'HHC02423%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG168833 DB	'main', 00H
	ORG $+3
$SG168834 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168846 DB	0aH, 'HHC02410I   -lfs   build one large output file', 00H
$SG168848 DB	'HHC02410%s Usage: %s [options] infile outfile', 0aH, 'HH'
	DB	'C02410I   infile:  name of input HDR-30 CKD image file (''-'''
	DB	' means stdin)', 0aH, 'HHC02410I   outfile: name of AWSCKD ima'
	DB	'ge file to be created', 0aH, 'HHC02410I options:', 0aH, 'HHC0'
	DB	'2410I   -r     replace existing output file', 0aH, 'HHC02410I'
	DB	'   -q     suppress progress messages%s', 0aH, 00H
	ORG $+2
$SG168852 DB	'I', 00H
	ORG $+2
$SG168849 DB	'argexit', 00H
$SG168850 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168854 DB	'argexit', 00H
$SG168853 DB	'HHC02410%s Usage: %s [options] infile outfile', 0aH, 'HH'
	DB	'C02410I   infile:  name of input HDR-30 CKD image file (''-'''
	DB	' means stdin)', 0aH, 'HHC02410I   outfile: name of AWSCKD ima'
	DB	'ge file to be created', 0aH, 'HHC02410I options:', 0aH, 'HHC0'
	DB	'2410I   -r     replace existing output file', 0aH, 'HHC02410I'
	DB	'   -q     suppress progress messages%s', 0aH, 00H
	ORG $+2
$SG168879 DB	'read()', 00H
	ORG $+1
$SG168880 DB	'E', 00H
	ORG $+2
$SG168855 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168881 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168882 DB	'read_input_data', 00H
$SG168883 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168885 DB	'unexpected end of file', 00H
	ORG $+1
$SG168886 DB	'read()', 00H
	ORG $+1
$SG168887 DB	'E', 00H
	ORG $+2
$SG168994 DB	'-', 00H
	ORG $+2
$SG168888 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168889 DB	'read_input_data', 00H
$SG168890 DB	'dasdconv64.c', 00H
	ORG $+3
$SG168996 DB	'open()', 00H
	ORG $+1
$SG168997 DB	'E', 00H
	ORG $+2
$SG169002 DB	'E', 00H
	ORG $+2
$SG168998 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168999 DB	'open_input_image', 00H
	ORG $+3
$SG169007 DB	'I', 00H
	ORG $+2
$SG169000 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169003 DB	'HHC02413%s Dasdconv is compiled without compress support'
	DB	' and input is compressed', 0aH, 00H
	ORG $+2
$SG169028 DB	'E', 00H
	ORG $+2
$SG169004 DB	'open_input_image', 00H
	ORG $+3
$SG169041 DB	'E', 00H
	ORG $+2
$SG169005 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169008 DB	'HHC02414%s Input file is already in CKD format, use dasd'
	DB	'copy', 0aH, 00H
	ORG $+2
$SG169009 DB	'open_input_image', 00H
	ORG $+3
$SG169047 DB	'E', 00H
	ORG $+2
$SG169010 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169030 DB	'open_input_image', 00H
	ORG $+7
$SG169029 DB	'HHC02415%s Unknown device type %04X at offset 00000000 i'
	DB	'n input file', 0aH, 00H
	ORG $+2
$SG169031 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169042 DB	'HHC02416%s Unknown device type %04X', 0aH, 00H
	ORG $+3
$SG169043 DB	'open_input_image', 00H
	ORG $+3
$SG169051 DB	'(NONE)', 00H
	ORG $+1
$SG169158 DB	'E', 00H
	ORG $+2
$SG169044 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169046 DB	'malloc(%u)', 00H
	ORG $+1
$SG169165 DB	'E', 00H
	ORG $+2
$SG169048 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169049 DB	'open_input_image', 00H
	ORG $+3
$SG169157 DB	'open()', 00H
	ORG $+1
$SG169178 DB	'E', 00H
	ORG $+2
$SG169050 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169159 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169160 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169182 DB	'E', 00H
	ORG $+2
$SG169161 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169163 DB	'incomplete', 00H
	ORG $+1
$SG169188 DB	'E', 00H
	ORG $+2
$SG169164 DB	'write()', 00H
$SG169166 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169167 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169198 DB	'E', 00H
	ORG $+2
$SG169168 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169171 DB	'CYL=%u', 0aH, 00H
$SG169173 DB	'Writing cylinder %u', 0dH, 00H
	ORG $+3
$SG169179 DB	'HHC02417%s Invalid track header at offset 0x%16.16llX', 0aH
	DB	00H
	ORG $+1
$SG169180 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169204 DB	'E', 00H
	ORG $+2
$SG169181 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169183 DB	'HHC02418%s Expected CCHH %04X%04X, found CCHH %04X%04X', 0aH
	DB	00H
$SG169184 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169208 DB	'I', 00H
	ORG $+2
$SG169185 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169189 DB	'HHC02419%s Invalid record header (rc %d) at offset %04X '
	DB	'in trk at CCHH %04X%04X at offset 0x%16.16llX in file %s', 0aH
	DB	00H
	ORG $+2
$SG169278 DB	'E', 00H
	ORG $+2
$SG169190 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169284 DB	'E', 00H
	ORG $+2
$SG169191 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169196 DB	'incomplete', 00H
	ORG $+1
$SG169288 DB	'I', 00H
	ORG $+2
$SG169197 DB	'write()', 00H
$SG169199 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169200 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169298 DB	'_1', 00H
	ORG $+1
$SG169201 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169203 DB	'close()', 00H
$SG169205 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169206 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169299 DB	'_1', 00H
	ORG $+1
$SG169207 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169209 DB	'HHC02420%s %u cylinders succesfully written to file %s', 0aH
	DB	00H
$SG169210 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169211 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169279 DB	'HHC02421%s Cylinder count %u is outside range %u-%u', 0aH
	DB	00H
	ORG $+3
$SG169280 DB	'convert_ckd', 00H
	ORG $+4
$SG169281 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169283 DB	'malloc(%u)', 00H
	ORG $+5
$SG169285 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169286 DB	'convert_ckd', 00H
	ORG $+4
$SG169287 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169289 DB	'HHC02422%s Converting %04X volume %s: %u cyls, %u trks/c'
	DB	'yl, %u bytes/trk', 0aH, 00H
	ORG $+6
$SG169290 DB	'convert_ckd', 00H
	ORG $+4
$SG169291 DB	'dasdconv64.c', 00H
	ORG $+3
$SG169293 DB	'CYLS=%u', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	05bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:convert_ckd
	DD	023H
	DD	060eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:convert_ckd_file
	DD	026H
	DD	0ab8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_input_image
	DD	027H
	DD	08afH
voltbl	ENDS
xdata	SEGMENT
$unwind$delayed_exit DD 010801H
	DD	04208H
$unwind$argexit DD 010d01H
	DD	0a20dH
$unwind$read_input_data DD 011701H
	DD	0c217H
$unwind$find_input_record DD 011801H
	DD	08218H
$unwind$open_input_image DD 042f19H
	DD	049011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$convert_ckd_file DD 042e19H
	DD	089011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$convert_ckd DD 022b19H
	DD	0450119H
	DD	imagerel __GSHandlerCheck
	DD	0210H
$unwind$main DD	022219H
	DD	05b0110H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
tv189 = 112
maxdlen$ = 116
heads$ = 120
devtype$ = 124
quiet$ = 128
repl$ = 132
lfs$ = 136
ifd$ = 140
pgm$ = 144
tv190 = 152
volcyls$ = 156
itrklen$ = 160
itrkbuf$ = 168
volser$ = 176
ifname$ = 192
ofname$ = 448
__$ArrayPad$ = 704
argc$ = 736
argv$ = 744
main	PROC

; 105  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 106  : char           *pgm;                    /* less any extension (.ext) */
; 107  : IFD             ifd;                    /* Input file descriptor     */
; 108  : int             repl = 0;               /* 1=replace existing file   */

  00022	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR repl$[rsp], 0

; 109  : int             quiet = 0;              /* 1=suppress progress msgs  */

  0002d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 0

; 110  : BYTE           *itrkbuf;                /* -> Input track buffer     */
; 111  : U32             itrklen;                /* Input track length        */
; 112  : U32             volcyls;                /* Total cylinders on volume */
; 113  : U32             heads = 0;              /* Number of tracks/cylinder */

  00038	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR heads$[rsp], 0

; 114  : U32             maxdlen = 0;            /* Maximum R1 data length    */

  00040	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR maxdlen$[rsp], 0

; 115  : U16             devtype;                /* Device type               */
; 116  : char            ifname[256];            /* Input file name           */
; 117  : char            ofname[256];            /* Output file name          */
; 118  : BYTE            volser[7];              /* Volume serial (ASCIIZ)    */
; 119  : int             lfs = 0;                /* 1 = Build large file      */

  00048	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 120  : 
; 121  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00053	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168799
  00067	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168800
  0006e	48 8b 94 24 e8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00076	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00083	89 84 24 e0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 122  : 
; 123  :     /* Process the options in the argument list */
; 124  :     for (; argc > 1; argc--, argv++)

  0008a	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  0008c	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00093	ff c8		 dec	 eax
  00095	89 84 24 e0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0009c	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000a4	48 83 c0 08	 add	 rax, 8
  000a8	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  000b0	83 bc 24 e0 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000b8	0f 8e 0a 01 00
	00		 jle	 $LN3@main

; 125  :     {
; 126  :         if (strcmp(argv[1], "-") == 0) break;

  000be	b8 08 00 00 00	 mov	 eax, 8
  000c3	48 6b c0 01	 imul	 rax, rax, 1
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168802
  000ce	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000da	e8 00 00 00 00	 call	 strcmp
  000df	85 c0		 test	 eax, eax
  000e1	75 05		 jne	 SHORT $LN7@main
  000e3	e9 e0 00 00 00	 jmp	 $LN3@main
$LN7@main:

; 127  :         if (argv[1][0] != '-') break;

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	48 6b c9 00	 imul	 rcx, rcx, 0
  000fa	48 8b 94 24 e8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00102	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00106	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0010a	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0010d	74 05		 je	 SHORT $LN8@main
  0010f	e9 b4 00 00 00	 jmp	 $LN3@main
$LN8@main:

; 128  :         if (strcmp(argv[1], "-r") == 0)

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168806
  00124	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0012c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00130	e8 00 00 00 00	 call	 strcmp
  00135	85 c0		 test	 eax, eax
  00137	75 0d		 jne	 SHORT $LN9@main

; 129  :             repl = 1;

  00139	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR repl$[rsp], 1
  00144	eb 7d		 jmp	 SHORT $LN10@main
$LN9@main:

; 130  :         else if (strcmp(argv[1], "-q") == 0)

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 01	 imul	 rax, rax, 1
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168809
  00156	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0015e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00162	e8 00 00 00 00	 call	 strcmp
  00167	85 c0		 test	 eax, eax
  00169	75 0d		 jne	 SHORT $LN11@main

; 131  :             quiet = 1;

  0016b	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 1
  00176	eb 4b		 jmp	 SHORT $LN12@main
$LN11@main:

; 132  :         else
; 133  :         if (sizeof(off_t) > 4 && strcmp(argv[1], "-lfs") == 0)

  00178	33 c0		 xor	 eax, eax
  0017a	83 f8 01	 cmp	 eax, 1
  0017d	74 32		 je	 SHORT $LN13@main
  0017f	b8 08 00 00 00	 mov	 eax, 8
  00184	48 6b c0 01	 imul	 rax, rax, 1
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168812
  0018f	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00197	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0019b	e8 00 00 00 00	 call	 strcmp
  001a0	85 c0		 test	 eax, eax
  001a2	75 0d		 jne	 SHORT $LN13@main

; 134  :             lfs = 1;

  001a4	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  001af	eb 12		 jmp	 SHORT $LN14@main
$LN13@main:

; 135  :         else
; 136  :             argexit(5, pgm);

  001b1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  001b9	b9 05 00 00 00	 mov	 ecx, 5
  001be	e8 00 00 00 00	 call	 argexit
$LN14@main:
$LN12@main:
$LN10@main:

; 137  :     }

  001c3	e9 c4 fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 138  :     if (argc != 3)

  001c8	83 bc 24 e0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  001d0	74 12		 je	 SHORT $LN15@main

; 139  :         argexit(5, pgm);

  001d2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  001da	b9 05 00 00 00	 mov	 ecx, 5
  001df	e8 00 00 00 00	 call	 argexit
$LN15@main:

; 140  : 
; 141  :     /* The first argument is the input file name */
; 142  :     if (argv[1] == NULL || strlen(argv[1]) == 0
; 143  :         || strlen(argv[1]) > sizeof(ifname)-1)

  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 01	 imul	 rax, rax, 1
  001ed	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f5	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  001fa	74 41		 je	 SHORT $LN17@main
  001fc	b8 08 00 00 00	 mov	 eax, 8
  00201	48 6b c0 01	 imul	 rax, rax, 1
  00205	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0020d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00211	e8 00 00 00 00	 call	 strlen
  00216	48 85 c0	 test	 rax, rax
  00219	74 22		 je	 SHORT $LN17@main
  0021b	b8 08 00 00 00	 mov	 eax, 8
  00220	48 6b c0 01	 imul	 rax, rax, 1
  00224	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00230	e8 00 00 00 00	 call	 strlen
  00235	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  0023b	76 12		 jbe	 SHORT $LN16@main
$LN17@main:

; 144  :         argexit(1, pgm);

  0023d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  00245	b9 01 00 00 00	 mov	 ecx, 1
  0024a	e8 00 00 00 00	 call	 argexit
$LN16@main:

; 145  :     STRLCPY( ifname, argv[1] );

  0024f	b8 08 00 00 00	 mov	 eax, 8
  00254	48 6b c0 01	 imul	 rax, rax, 1
  00258	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0025e	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00266	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0026a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ifname$[rsp]
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 146  : 
; 147  :     /* The second argument is the output file name */
; 148  :     if (argv[2] == NULL || strlen(argv[2]) == 0
; 149  :         || strlen(argv[2]) > sizeof(ofname)-1)

  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 02	 imul	 rax, rax, 2
  00281	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00289	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0028e	74 41		 je	 SHORT $LN19@main
  00290	b8 08 00 00 00	 mov	 eax, 8
  00295	48 6b c0 02	 imul	 rax, rax, 2
  00299	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a1	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002a5	e8 00 00 00 00	 call	 strlen
  002aa	48 85 c0	 test	 rax, rax
  002ad	74 22		 je	 SHORT $LN19@main
  002af	b8 08 00 00 00	 mov	 eax, 8
  002b4	48 6b c0 02	 imul	 rax, rax, 2
  002b8	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002c0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002c4	e8 00 00 00 00	 call	 strlen
  002c9	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  002cf	76 12		 jbe	 SHORT $LN18@main
$LN19@main:

; 150  :         argexit(2, pgm);

  002d1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  002d9	b9 02 00 00 00	 mov	 ecx, 2
  002de	e8 00 00 00 00	 call	 argexit
$LN18@main:

; 151  :     STRLCPY( ofname, argv[2] );

  002e3	b8 08 00 00 00	 mov	 eax, 8
  002e8	48 6b c0 02	 imul	 rax, rax, 2
  002ec	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002f2	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002fa	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002fe	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 152  : 
; 153  :     /* Read the first track of the input file, and determine
; 154  :        the device type and size from the track header */
; 155  :     ifd = open_input_image (ifname, &devtype, &volcyls,

  0030c	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  00314	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00319	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR itrkbuf$[rsp]
  00321	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00326	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR itrklen$[rsp]
  0032e	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR volcyls$[rsp]
  00336	48 8d 54 24 7c	 lea	 rdx, QWORD PTR devtype$[rsp]
  0033b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ifname$[rsp]
  00343	e8 00 00 00 00	 call	 open_input_image
  00348	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ifd$[rsp], eax

; 156  :                 &itrklen, &itrkbuf, volser);
; 157  : 
; 158  :     /* Use the device type to determine track characteristics */
; 159  :     switch (devtype) {

  0034f	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00354	89 44 24 70	 mov	 DWORD PTR tv189[rsp], eax
  00358	81 7c 24 70 75
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13173 ; 00003375H
  00360	7f 3b		 jg	 SHORT $LN30@main
  00362	81 7c 24 70 75
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13173 ; 00003375H
  0036a	0f 84 b0 00 00
	00		 je	 $LN24@main
  00370	81 7c 24 70 14
	23 00 00	 cmp	 DWORD PTR tv189[rsp], 8980 ; 00002314H
  00378	74 52		 je	 SHORT $LN20@main
  0037a	81 7c 24 70 30
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13104 ; 00003330H
  00382	74 5d		 je	 SHORT $LN21@main
  00384	81 7c 24 70 40
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13120 ; 00003340H
  0038c	74 68		 je	 SHORT $LN22@main
  0038e	81 7c 24 70 50
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13136 ; 00003350H
  00396	74 73		 je	 SHORT $LN23@main
  00398	e9 d1 00 00 00	 jmp	 $LN28@main
$LN30@main:
  0039d	81 7c 24 70 80
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13184 ; 00003380H
  003a5	0f 84 8a 00 00
	00		 je	 $LN25@main
  003ab	81 7c 24 70 90
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13200 ; 00003390H
  003b3	0f 84 91 00 00
	00		 je	 $LN26@main
  003b9	81 7c 24 70 45
	93 00 00	 cmp	 DWORD PTR tv189[rsp], 37701 ; 00009345H
  003c1	0f 84 95 00 00
	00		 je	 $LN27@main
  003c7	e9 a2 00 00 00	 jmp	 $LN28@main
$LN20@main:

; 160  :     case 0x2314: heads = 20; maxdlen =  7294; break;

  003cc	c7 44 24 78 14
	00 00 00	 mov	 DWORD PTR heads$[rsp], 20
  003d4	c7 44 24 74 7e
	1c 00 00	 mov	 DWORD PTR maxdlen$[rsp], 7294 ; 00001c7eH
  003dc	e9 f5 00 00 00	 jmp	 $LN5@main
$LN21@main:

; 161  :     case 0x3330: heads = 19; maxdlen = 13030; break;

  003e1	c7 44 24 78 13
	00 00 00	 mov	 DWORD PTR heads$[rsp], 19
  003e9	c7 44 24 74 e6
	32 00 00	 mov	 DWORD PTR maxdlen$[rsp], 13030 ; 000032e6H
  003f1	e9 e0 00 00 00	 jmp	 $LN5@main
$LN22@main:

; 162  :     case 0x3340: heads = 12; maxdlen =  8368; break;

  003f6	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR heads$[rsp], 12
  003fe	c7 44 24 74 b0
	20 00 00	 mov	 DWORD PTR maxdlen$[rsp], 8368 ; 000020b0H
  00406	e9 cb 00 00 00	 jmp	 $LN5@main
$LN23@main:

; 163  :     case 0x3350: heads = 30; maxdlen = 19069; break;

  0040b	c7 44 24 78 1e
	00 00 00	 mov	 DWORD PTR heads$[rsp], 30
  00413	c7 44 24 74 7d
	4a 00 00	 mov	 DWORD PTR maxdlen$[rsp], 19069 ; 00004a7dH
  0041b	e9 b6 00 00 00	 jmp	 $LN5@main
$LN24@main:

; 164  :     case 0x3375: heads = 12; maxdlen = 35616; break;

  00420	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR heads$[rsp], 12
  00428	c7 44 24 74 20
	8b 00 00	 mov	 DWORD PTR maxdlen$[rsp], 35616 ; 00008b20H
  00430	e9 a1 00 00 00	 jmp	 $LN5@main
$LN25@main:

; 165  :     case 0x3380: heads = 15; maxdlen = 47476; break;

  00435	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  0043d	c7 44 24 74 74
	b9 00 00	 mov	 DWORD PTR maxdlen$[rsp], 47476 ; 0000b974H
  00445	e9 8c 00 00 00	 jmp	 $LN5@main
$LN26@main:

; 166  :     case 0x3390: heads = 15; maxdlen = 56664; break;

  0044a	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  00452	c7 44 24 74 58
	dd 00 00	 mov	 DWORD PTR maxdlen$[rsp], 56664 ; 0000dd58H
  0045a	eb 7a		 jmp	 SHORT $LN5@main
$LN27@main:

; 167  :     case 0x9345: heads = 15; maxdlen = 46456; break;

  0045c	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  00464	c7 44 24 74 78
	b5 00 00	 mov	 DWORD PTR maxdlen$[rsp], 46456 ; 0000b578H
  0046c	eb 68		 jmp	 SHORT $LN5@main
$LN28@main:

; 168  :     default:
; 169  :         // "Unknown device type %04X"
; 170  :         FWRMSG( stderr, HHC02416, "E", devtype );

  0046e	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00473	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  0047a	b9 02 00 00 00	 mov	 ecx, 2
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00485	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  0048c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00490	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168827
  00497	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168828
  004a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168829
  004ba	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168830
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 171  :         EXIT(3);

  004cc	b9 03 00 00 00	 mov	 ecx, 3
  004d1	e8 00 00 00 00	 call	 delayed_exit
$LN5@main:

; 172  :     } /* end switch(devtype) */
; 173  : 
; 174  :     /* Create the device */
; 175  :     convert_ckd (lfs, ifd, ifname, itrklen, itrkbuf, repl, quiet,

  004d6	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  004de	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  004e3	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  004ea	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  004ee	8b 44 24 74	 mov	 eax, DWORD PTR maxdlen$[rsp]
  004f2	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  004f6	8b 44 24 78	 mov	 eax, DWORD PTR heads$[rsp]
  004fa	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  004fe	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00503	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  00508	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR ofname$[rsp]
  00510	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00515	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR quiet$[rsp]
  0051c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00520	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR repl$[rsp]
  00527	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0052b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  00533	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00538	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR itrklen$[rsp]
  00540	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR ifname$[rsp]
  00548	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR ifd$[rsp]
  0054f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR lfs$[rsp]
  00556	e8 00 00 00 00	 call	 convert_ckd

; 176  :                 ofname, devtype, heads, maxdlen, volcyls, volser);
; 177  : 
; 178  :     /* Release the input buffer and close the input file */
; 179  :     free (itrkbuf);

  0055b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  00563	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 180  :     IFCLOS (ifd);

  00569	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 181  : 
; 182  :     /* Display completion message */
; 183  :     // "DASD operation completed"
; 184  :     WRMSG( HHC02423, "I" );

  00576	b9 01 00 00 00	 mov	 ecx, 1
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168831
  00588	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168832
  00594	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00599	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059e	41 b9 03 00 00
	00		 mov	 r9d, 3
  005a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168833
  005ab	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  005b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168834
  005b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 185  : 
; 186  :     return 0;

  005bd	33 c0		 xor	 eax, eax

; 187  : 
; 188  : } /* end function main */

  005bf	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c7	48 33 cc	 xor	 rcx, rsp
  005ca	e8 00 00 00 00	 call	 __security_check_cookie
  005cf	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  005d6	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
trksize$ = 128
maxcyls$ = 132
maxcpif$ = 136
cyl$ = 140
i$ = 144
fileseq$ = 148
s$ = 152
tv72 = 160
mincyls$ = 164
endcyl$ = 168
suffix$ = 176
cylsize$ = 184
tv155 = 188
obuf$ = 192
tv132 = 200
buf$1 = 208
sfname$ = 256
__$ArrayPad$ = 528
lfs$ = 560
ifd$ = 568
ifname$ = 576
itrklen$ = 584
itrkbuf$ = 592
repl$ = 600
quiet$ = 608
ofname$ = 616
devtype$ = 624
heads$ = 632
maxdlen$ = 640
volcyls$ = 648
volser$ = 656
convert_ckd PROC

; 788  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 789  : int             i;                      /* Array subscript           */
; 790  : char            *s;                     /* String pointer            */
; 791  : int             fileseq;                /* File sequence number      */
; 792  : char            sfname[260];            /* Suffixed name of this file*/
; 793  : char            *suffix;                /* -> Suffix character       */
; 794  : U32             endcyl;                 /* Last cylinder of this file*/
; 795  : U32             cyl;                    /* Cylinder number           */
; 796  : U32             cylsize;                /* Cylinder size in bytes    */
; 797  : BYTE           *obuf;                   /* -> Output track buffer    */
; 798  : U32             mincyls;                /* Minimum cylinder count    */
; 799  : U32             maxcyls;                /* Maximum cylinder count    */
; 800  : U32             maxcpif;                /* Maximum number of cylinders
; 801  :                                            in each CKD image file    */
; 802  : U32             trksize;                /* AWSCKD image track length */
; 803  : 
; 804  :     /* Compute the AWSCKD image track length */
; 805  :     trksize = CKD_TRKHDR_SIZE

  0002b	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR maxdlen$[rsp]
  00032	48 83 c0 25	 add	 rax, 37			; 00000025H
  00036	89 84 24 80 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 806  :             + CKD_R0_SIZE + CKD_R0_DLEN
; 807  :             + CKD_RECHDR_SIZE + maxdlen
; 808  :             + CKD_ENDTRK_SIZE;
; 809  :     trksize = ROUND_UP(trksize,512);

  0003d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR trksize$[rsp], 0
  00045	74 24		 je	 SHORT $LN23@convert_ck
  00047	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  0004e	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  00053	33 d2		 xor	 edx, edx
  00055	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0005a	f7 f1		 div	 ecx
  0005c	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  00062	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv72[rsp], eax
  00069	eb 0b		 jmp	 SHORT $LN24@convert_ck
$LN23@convert_ck:
  0006b	c7 84 24 a0 00
	00 00 00 02 00
	00		 mov	 DWORD PTR tv72[rsp], 512 ; 00000200H
$LN24@convert_ck:
  00076	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv72[rsp]
  0007d	89 84 24 80 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 810  : 
; 811  :     /* Compute minimum and maximum number of cylinders */
; 812  :     cylsize = trksize * heads;

  00084	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  0008b	0f af 84 24 78
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00093	89 84 24 b8 00
	00 00		 mov	 DWORD PTR cylsize$[rsp], eax

; 813  :     mincyls = 1;

  0009a	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mincyls$[rsp], 1

; 814  : 
; 815  :     if (!lfs)

  000a5	83 bc 24 30 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  000ad	75 26		 jne	 SHORT $LN8@convert_ck

; 816  :     {
; 817  :         maxcpif = 0x80000000 / cylsize;

  000af	33 d2		 xor	 edx, edx
  000b1	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000b6	f7 b4 24 b8 00
	00 00		 div	 DWORD PTR cylsize$[rsp]
  000bd	89 84 24 88 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax

; 818  :         maxcyls = maxcpif * CKD_MAXFILES;

  000c4	6b 84 24 88 00
	00 00 1b	 imul	 eax, DWORD PTR maxcpif$[rsp], 27
  000cc	89 84 24 84 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax

; 819  :     }

  000d3	eb 1c		 jmp	 SHORT $LN9@convert_ck
$LN8@convert_ck:

; 820  :     else
; 821  :         maxcpif = maxcyls = volcyls;

  000d5	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  000dc	89 84 24 84 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax
  000e3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  000ea	89 84 24 88 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax
$LN9@convert_ck:

; 822  : 
; 823  :     if (maxcyls > 65536) maxcyls = 65536;

  000f1	81 bc 24 84 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
  000fc	76 0b		 jbe	 SHORT $LN10@convert_ck
  000fe	c7 84 24 84 00
	00 00 00 00 01
	00		 mov	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
$LN10@convert_ck:

; 824  : 
; 825  :     /* Check for valid number of cylinders */
; 826  :     if (volcyls < mincyls || volcyls > maxcyls)

  00109	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR mincyls$[rsp]
  00110	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  00117	72 10		 jb	 SHORT $LN12@convert_ck
  00119	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  00120	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  00127	76 72		 jbe	 SHORT $LN11@convert_ck
$LN12@convert_ck:

; 827  :     {
; 828  :         // "Cylinder count %u is outside range %u-%u"
; 829  :         FWRMSG( stderr, HHC02421, "E",

  00129	b9 02 00 00 00	 mov	 ecx, 2
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00134	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  0013b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0013f	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR mincyls$[rsp]
  00146	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014a	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  00151	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169278
  0015c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169279
  00168	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00172	41 b9 03 00 00
	00		 mov	 r9d, 3
  00178	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169280
  0017f	ba 3e 03 00 00	 mov	 edx, 830		; 0000033eH
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 830  :                 volcyls, mincyls, maxcyls );
; 831  :         EXIT(4);

  00191	b9 04 00 00 00	 mov	 ecx, 4
  00196	e8 00 00 00 00	 call	 delayed_exit
$LN11@convert_ck:

; 832  :     }
; 833  : 
; 834  :     /* Obtain track data buffer */
; 835  :     obuf = malloc(trksize);

  0019b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  001a2	8b c8		 mov	 ecx, eax
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001aa	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR obuf$[rsp], rax

; 836  :     if (obuf == NULL)

  001b2	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR obuf$[rsp], 0
  001bb	0f 85 a3 00 00
	00		 jne	 $LN13@convert_ck

; 837  :     {
; 838  :         char buf[40];
; 839  :         MSGBUF( buf, "malloc(%u)", trksize);

  001c1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR trksize$[rsp]
  001c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169283
  001d0	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001d5	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 840  :         // "Error in function %s: %s"
; 841  :         FWRMSG( stderr, HHC02412, "E", buf, strerror( errno ));

  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001e9	8b 08		 mov	 ecx, DWORD PTR [rax]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001f1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001f9	b9 02 00 00 00	 mov	 ecx, 2
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00204	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  0020c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00211	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00219	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169284
  00225	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169285
  00231	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00236	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00241	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169286
  00248	ba 49 03 00 00	 mov	 edx, 841		; 00000349H
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169287
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 842  :         EXIT(6);

  0025a	b9 06 00 00 00	 mov	 ecx, 6
  0025f	e8 00 00 00 00	 call	 delayed_exit
$LN13@convert_ck:

; 843  :     }
; 844  : 
; 845  :     /* Display progress message */
; 846  :     // "Converting %04X volume %s: %u cyls, %u trks/cyl, %u bytes/trk"
; 847  :     WRMSG( HHC02422, "I", devtype, volser, volcyls, heads, trksize );

  00264	0f b7 84 24 70
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  0026c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  00273	b9 01 00 00 00	 mov	 ecx, 1
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  00285	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00289	8b 8c 24 78 02
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00290	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00294	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  0029b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0029f	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  002a7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002ac	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  002b3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169288
  002be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169289
  002ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169290
  002e1	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169291
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@convert_ck:

; 848  : 
; 849  :     EXTGUIMSG( "CYLS=%u\n", volcyls );

  002f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  002fa	83 38 00	 cmp	 DWORD PTR [rax], 0
  002fd	74 23		 je	 SHORT $LN14@convert_ck
  002ff	b9 02 00 00 00	 mov	 ecx, 2
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030a	44 8b 84 24 88
	02 00 00	 mov	 r8d, DWORD PTR volcyls$[rsp]
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169293
  00319	48 8b c8	 mov	 rcx, rax
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN14@convert_ck:
  00322	33 c0		 xor	 eax, eax
  00324	85 c0		 test	 eax, eax
  00326	75 cb		 jne	 SHORT $LN4@convert_ck

; 850  : 
; 851  :     /* Copy the unsuffixed AWSCKD image file name */
; 852  :     STRLCPY( sfname, ofname );

  00328	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0032e	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00336	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 853  :     suffix = NULL;

  00344	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR suffix$[rsp], 0

; 854  : 
; 855  :     /* Create the suffixed file name if volume will exceed 2GB */
; 856  :     if (volcyls > maxcpif)

  00350	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  00357	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  0035e	0f 86 2d 01 00
	00		 jbe	 $LN15@convert_ck

; 857  :     {
; 858  :         /* Look for last slash marking end of directory name */
; 859  :         s = strrchr (ofname, '/');

  00364	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00369	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00371	e8 00 00 00 00	 call	 strrchr
  00376	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 860  :         if (s == NULL) s = ofname;

  0037e	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  00387	75 10		 jne	 SHORT $LN16@convert_ck
  00389	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR ofname$[rsp]
  00391	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN16@convert_ck:

; 861  : 
; 862  :         /* Insert suffix before first dot in file name, or
; 863  :            append suffix to file name if there is no dot */
; 864  :         s = strchr (s, '.');

  00399	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0039e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003a6	e8 00 00 00 00	 call	 strchr
  003ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 865  :         if (s != NULL)

  003b3	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  003bc	0f 84 97 00 00
	00		 je	 $LN17@convert_ck

; 866  :         {
; 867  :             i = (int) (s - ofname);

  003c2	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR ofname$[rsp]
  003ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d2	48 2b c8	 sub	 rcx, rax
  003d5	48 8b c1	 mov	 rax, rcx
  003d8	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax

; 868  :             strlcpy( sfname + i, "_1", sizeof( sfname ) - i );

  003df	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  003e7	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  003ec	48 2b c8	 sub	 rcx, rax
  003ef	48 8b c1	 mov	 rax, rcx
  003f2	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  003fa	48 8d 8c 0c 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp+rcx]
  00402	4c 8b c0	 mov	 r8, rax
  00405	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169298
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 869  :             STRLCAT( sfname, ofname + i );

  00412	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0041a	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00422	48 03 c8	 add	 rcx, rax
  00425	48 8b c1	 mov	 rax, rcx
  00428	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0042e	48 8b d0	 mov	 rdx, rax
  00431	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 870  :             suffix = sfname + i + 1;

  0043f	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00447	48 8d 84 04 01
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax+1]
  0044f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax

; 871  :         }

  00457	eb 38		 jmp	 SHORT $LN18@convert_ck
$LN17@convert_ck:

; 872  :         else
; 873  :         {
; 874  :             STRLCAT( sfname, "_1" );

  00459	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169299
  00466	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 875  :             suffix = sfname + strlen(sfname) - 1;

  00474	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0047c	e8 00 00 00 00	 call	 strlen
  00481	48 8d 84 04 ff
	00 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  00489	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN18@convert_ck:
$LN15@convert_ck:

; 876  :         }
; 877  :     }
; 878  : 
; 879  :     /* Create the AWSCKD image files */
; 880  :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  00491	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0
  0049c	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 1
  004a7	eb 29		 jmp	 SHORT $LN7@convert_ck
$LN5@convert_ck:

; 881  :             cyl += maxcpif, fileseq++)

  004a9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  004b0	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  004b7	03 c8		 add	 ecx, eax
  004b9	8b c1		 mov	 eax, ecx
  004bb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax
  004c2	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  004c9	ff c0		 inc	 eax
  004cb	89 84 24 94 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax
$LN7@convert_ck:

; 876  :         }
; 877  :     }
; 878  : 
; 879  :     /* Create the AWSCKD image files */
; 880  :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  004d2	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  004d9	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR cyl$[rsp], eax
  004e0	0f 83 1a 01 00
	00		 jae	 $LN6@convert_ck

; 882  :     {
; 883  :         /* Insert the file sequence number in the file name */
; 884  :         if (suffix) *suffix = (char)('0' + fileseq);

  004e6	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR suffix$[rsp], 0
  004ef	74 14		 je	 SHORT $LN19@convert_ck
  004f1	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  004f8	83 c0 30	 add	 eax, 48			; 00000030H
  004fb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  00503	88 01		 mov	 BYTE PTR [rcx], al
$LN19@convert_ck:

; 885  : 
; 886  :         /* Calculate the ending cylinder for this file */
; 887  :         if (cyl + maxcpif < volcyls)

  00505	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  0050c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00513	03 c8		 add	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	3b 84 24 88 02
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  0051e	73 1b		 jae	 SHORT $LN20@convert_ck

; 888  :             endcyl = cyl + maxcpif - 1;

  00520	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  00527	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR maxcpif$[rsp]
  0052e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00532	89 84 24 a8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
  00539	eb 10		 jmp	 SHORT $LN21@convert_ck
$LN20@convert_ck:

; 889  :         else
; 890  :             endcyl = volcyls - 1;

  0053b	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00542	ff c8		 dec	 eax
  00544	89 84 24 a8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
$LN21@convert_ck:

; 891  : 
; 892  :         /* Create an AWSCKD image file */
; 893  :         convert_ckd_file (ifd, ifname, itrklen, itrkbuf, repl, quiet,

  0054b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  00553	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00558	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  0055f	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00563	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  0056a	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0056e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  00575	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00579	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  00581	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00586	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  0058d	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00591	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00598	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0059c	0f b7 84 24 70
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  005a4	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  005a9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  005b0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005b4	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp]
  005bc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005c1	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR quiet$[rsp]
  005c8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005cc	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR repl$[rsp]
  005d3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005d7	4c 8b 8c 24 50
	02 00 00	 mov	 r9, QWORD PTR itrkbuf$[rsp]
  005df	44 8b 84 24 48
	02 00 00	 mov	 r8d, DWORD PTR itrklen$[rsp]
  005e7	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  005ef	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  005f6	e8 00 00 00 00	 call	 convert_ckd_file

; 894  :                         sfname, fileseq, devtype, heads, trksize,
; 895  :                         obuf, cyl, endcyl, volcyls, volser);
; 896  :     }

  005fb	e9 a9 fe ff ff	 jmp	 $LN5@convert_ck
$LN6@convert_ck:

; 897  : 
; 898  :     /* Release the output track buffer */
; 899  :     free (obuf);

  00600	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR obuf$[rsp]
  00608	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 900  : 
; 901  : } /* end function convert_ckd */

  0060e	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00616	48 33 cc	 xor	 rcx, rsp
  00619	e8 00 00 00 00	 call	 __security_check_cookie
  0061e	48 81 c4 28 02
	00 00		 add	 rsp, 552		; 00000228H
  00625	c3		 ret	 0
convert_ckd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
klen$ = 112
cyl$ = 116
fileseq$ = 120
rc$ = 124
dlen$ = 128
head$ = 132
rec$ = 136
opos$ = 144
ihc$ = 152
ihh$ = 156
ofd$ = 160
tv76 = 164
highcyl$ = 168
rechdr$ = 176
ilen$ = 184
tv465 = 188
trkhdr$ = 192
offset$ = 200
tv176 = 208
ith$ = 216
iptr$ = 224
tv401 = 232
tv81 = 240
tv294 = 248
tv331 = 256
kptr$ = 264
dptr$ = 272
tv449 = 280
devhdr$ = 288
pathname$ = 800
__$ArrayPad$ = 1072
ifd$ = 1120
ifname$ = 1128
itrklen$ = 1136
itrkbuf$ = 1144
repl$ = 1152
quiet$ = 1160
ofname$ = 1168
fseqn$ = 1176
devtype$ = 1184
heads$ = 1192
trksize$ = 1200
obuf$ = 1208
start$ = 1216
end$ = 1224
volcyls$ = 1232
volser$ = 1240
convert_ckd_file PROC

; 567  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 48 04
	00 00		 sub	 rsp, 1096		; 00000448H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 30
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@convert_ck:

; 568  : int             rc;                     /* Return code               */
; 569  : int             ofd;                    /* Output file descriptor    */
; 570  : CKD_DEVHDR      devhdr;                 /* Output device header      */
; 571  : CKD_TRKHDR     *trkhdr;                 /* -> Output track header    */
; 572  : CKD_RECHDR     *rechdr;                 /* -> Output record header   */
; 573  : U32             cyl;                    /* Cylinder number           */
; 574  : U32             head;                   /* Head number               */
; 575  : BYTE            fileseq;                /* CKD header sequence number*/
; 576  : int             highcyl;                /* CKD header high cyl number*/
; 577  : BYTE           *opos;                   /* -> Byte in output buffer  */
; 578  : BYTE            klen;                   /* Key length                */
; 579  : U16             dlen;                   /* Data length               */
; 580  : BYTE            rec;                    /* Record number             */
; 581  : BYTE           *iptr;                   /* -> Byte in input buffer   */
; 582  : BYTE           *kptr;                   /* -> Key in input buffer    */
; 583  : BYTE           *dptr;                   /* -> Data in input buffer   */
; 584  : int             ilen;                   /* Bytes left in input buffer*/
; 585  : H30CKD_TRKHDR  *ith;                    /* -> Input track header     */
; 586  : U32             ihc, ihh;               /* Input trk header cyl,head */
; 587  : U64             offset;                 /* Current input file offset */
; 588  : char            pathname[MAX_PATH];     /* file path in host format  */
; 589  : 
; 590  :     UNREFERENCED(volser);

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN4@convert_ck

; 591  : 
; 592  :     /* Set file sequence number to zero if this is the only file */
; 593  :     if (fseqn == 1 && end + 1 == volcyls)

  00034	83 bc 24 98 04
	00 00 01	 cmp	 DWORD PTR fseqn$[rsp], 1
  0003c	75 19		 jne	 SHORT $LN16@convert_ck
  0003e	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00045	ff c0		 inc	 eax
  00047	3b 84 24 d0 04
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  0004e	75 07		 jne	 SHORT $LN16@convert_ck

; 594  :         fileseq = 0;

  00050	c6 44 24 78 00	 mov	 BYTE PTR fileseq$[rsp], 0
  00055	eb 0c		 jmp	 SHORT $LN17@convert_ck
$LN16@convert_ck:

; 595  :     else
; 596  :         fileseq = (BYTE) fseqn;

  00057	0f b6 84 24 98
	04 00 00	 movzx	 eax, BYTE PTR fseqn$[rsp]
  0005f	88 44 24 78	 mov	 BYTE PTR fileseq$[rsp], al
$LN17@convert_ck:

; 597  : 
; 598  :     /* Set high cylinder number to zero if this is the last file */
; 599  :     if (end + 1 == volcyls)

  00063	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	3b 84 24 d0 04
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00073	75 0d		 jne	 SHORT $LN18@convert_ck

; 600  :         highcyl = 0;

  00075	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR highcyl$[rsp], 0
  00080	eb 0e		 jmp	 SHORT $LN19@convert_ck
$LN18@convert_ck:

; 601  :     else
; 602  :         highcyl = end;

  00082	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00089	89 84 24 a8 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax
$LN19@convert_ck:

; 603  : 
; 604  :     /* Create the AWSCKD image file */
; 605  :     hostpath(pathname, (char *)ofname, sizeof(pathname));

  00090	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00096	48 8b 94 24 90
	04 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0009e	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 606  :     ofd = HOPEN (pathname,

  000ac	83 bc 24 80 04
	00 00 00	 cmp	 DWORD PTR repl$[rsp], 0
  000b4	74 0d		 je	 SHORT $LN37@convert_ck
  000b6	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv76[rsp], 0
  000c1	eb 0b		 jmp	 SHORT $LN38@convert_ck
$LN37@convert_ck:
  000c3	c7 84 24 a4 00
	00 00 00 04 00
	00		 mov	 DWORD PTR tv76[rsp], 1024 ; 00000400H
$LN38@convert_ck:
  000ce	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv76[rsp]
  000d5	0d 01 81 00 00	 or	 eax, 33025		; 00008101H
  000da	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  000e0	8b d0		 mov	 edx, eax
  000e2	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  000f0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR ofd$[rsp], eax

; 607  :                 O_WRONLY | O_CREAT | O_BINARY | (repl ? 0 : O_EXCL),
; 608  :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 609  : 
; 610  :     if (ofd < 0)

  000f7	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR ofd$[rsp], 0
  000ff	0f 8d 80 00 00
	00		 jge	 $LN20@convert_ck

; 611  :     {
; 612  :         // "Error in function %s: %s"
; 613  :         FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0010b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00113	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv81[rsp], rax
  0011b	b9 02 00 00 00	 mov	 ecx, 2
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00126	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv81[rsp]
  0012e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169157
  0013a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169158
  00146	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169159
  00152	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00157	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00162	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169160
  00169	ba 65 02 00 00	 mov	 edx, 613		; 00000265H
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 614  :         EXIT(8);

  0017b	b9 08 00 00 00	 mov	 ecx, 8
  00180	e8 00 00 00 00	 call	 delayed_exit
$LN20@convert_ck:

; 615  :     }
; 616  : 
; 617  :     /* Create the device header */
; 618  :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  00185	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  0018d	48 8b f8	 mov	 rdi, rax
  00190	33 c0		 xor	 eax, eax
  00192	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00197	f3 aa		 rep stosb

; 619  :     memcpy( devhdr.dh_devid, dh_devid_str( CKD_P064_TYP ), 8 );

  00199	b9 00 00 80 00	 mov	 ecx, 8388608		; 00800000H
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  001a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a7	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax

; 620  : 
; 621  :     STORE_LE_FW( devhdr.dh_heads,    heads   );

  001af	8b 8c 24 a8 04
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  001b6	e8 00 00 00 00	 call	 _byteswap_ulong
  001bb	8b c8		 mov	 ecx, eax
  001bd	e8 00 00 00 00	 call	 _byteswap_ulong
  001c2	8b d0		 mov	 edx, eax
  001c4	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  001cc	e8 00 00 00 00	 call	 store_fw_noswap

; 622  :     STORE_LE_FW( devhdr.dh_trksize,  trksize );

  001d1	8b 8c 24 b0 04
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  001d8	e8 00 00 00 00	 call	 _byteswap_ulong
  001dd	8b c8		 mov	 ecx, eax
  001df	e8 00 00 00 00	 call	 _byteswap_ulong
  001e4	8b d0		 mov	 edx, eax
  001e6	48 8d 8c 24 2c
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  001ee	e8 00 00 00 00	 call	 store_fw_noswap

; 623  :                  devhdr.dh_devtyp   = devtype & 0xFF;

  001f3	0f b7 84 24 a0
	04 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  001fb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00200	88 84 24 30 01
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 624  :                  devhdr.dh_fileseq = fileseq & 0xFF;

  00207	0f b6 44 24 78	 movzx	 eax, BYTE PTR fileseq$[rsp]
  0020c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00211	88 84 24 31 01
	00 00		 mov	 BYTE PTR devhdr$[rsp+17], al

; 625  :     STORE_LE_HW( devhdr.dh_highcyl,  (U16) highcyl );

  00218	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR highcyl$[rsp]
  00220	e8 00 00 00 00	 call	 _byteswap_ushort
  00225	0f b7 c8	 movzx	 ecx, ax
  00228	e8 00 00 00 00	 call	 _byteswap_ushort
  0022d	0f b7 d0	 movzx	 edx, ax
  00230	48 8d 8c 24 32
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  00238	e8 00 00 00 00	 call	 store_hw_noswap

; 626  : 
; 627  :     /* Write the device header */
; 628  :     rc = write (ofd, &devhdr, CKD_DEVHDR_SIZE);

  0023d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00243	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0024b	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00258	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 629  :     if (rc < CKD_DEVHDR_SIZE)

  0025c	48 63 44 24 7c	 movsxd	 rax, DWORD PTR rc$[rsp]
  00261	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  00267	0f 8d 9c 00 00
	00		 jge	 $LN21@convert_ck

; 630  :     {
; 631  :         // "Error in function %s: %s"
; 632  :         FWRMSG( stderr, HHC02412, "E", "write()", errno ? strerror(errno) : "incomplete" );

  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00273	83 38 00	 cmp	 DWORD PTR [rax], 0
  00276	74 18		 je	 SHORT $LN39@convert_ck
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0027e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00286	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  0028e	eb 0f		 jmp	 SHORT $LN40@convert_ck
$LN39@convert_ck:
  00290	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169163
  00297	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
$LN40@convert_ck:
  0029f	b9 02 00 00 00	 mov	 ecx, 2
  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002aa	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002b2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169164
  002be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  002ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  002d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169167
  002ed	ba 78 02 00 00	 mov	 edx, 632		; 00000278H
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169168
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 633  :         EXIT(1);

  002ff	b9 01 00 00 00	 mov	 ecx, 1
  00304	e8 00 00 00 00	 call	 delayed_exit
$LN21@convert_ck:

; 634  :     }
; 635  : 
; 636  :     /* Write each cylinder */
; 637  :     for (cyl = start; cyl <= end; cyl++)

  00309	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00310	89 44 24 74	 mov	 DWORD PTR cyl$[rsp], eax
  00314	eb 0a		 jmp	 SHORT $LN7@convert_ck
$LN5@convert_ck:
  00316	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  0031a	ff c0		 inc	 eax
  0031c	89 44 24 74	 mov	 DWORD PTR cyl$[rsp], eax
$LN7@convert_ck:
  00320	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00327	39 44 24 74	 cmp	 DWORD PTR cyl$[rsp], eax
  0032b	0f 87 76 06 00
	00		 ja	 $LN6@convert_ck

; 638  :     {
; 639  :         /* Display progress message every 10 cylinders */
; 640  :         if ((cyl % 10) == 0)

  00331	33 d2		 xor	 edx, edx
  00333	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  00337	b9 0a 00 00 00	 mov	 ecx, 10
  0033c	f7 f1		 div	 ecx
  0033e	8b c2		 mov	 eax, edx
  00340	85 c0		 test	 eax, eax
  00342	75 5c		 jne	 SHORT $LN22@convert_ck
$LN10@convert_ck:

; 641  :         {
; 642  :             EXTGUIMSG( "CYL=%u\n", cyl );

  00344	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0034b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0034e	74 20		 je	 SHORT $LN23@convert_ck
  00350	b9 02 00 00 00	 mov	 ecx, 2
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0035b	44 8b 44 24 74	 mov	 r8d, DWORD PTR cyl$[rsp]
  00360	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169171
  00367	48 8b c8	 mov	 rcx, rax
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN23@convert_ck:
  00370	33 c0		 xor	 eax, eax
  00372	85 c0		 test	 eax, eax
  00374	75 ce		 jne	 SHORT $LN10@convert_ck

; 643  :             if (!quiet)

  00376	83 bc 24 88 04
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  0037e	75 20		 jne	 SHORT $LN24@convert_ck

; 644  :                 fprintf (stderr, "Writing cylinder %u\r", cyl);

  00380	b9 02 00 00 00	 mov	 ecx, 2
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0038b	44 8b 44 24 74	 mov	 r8d, DWORD PTR cyl$[rsp]
  00390	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169173
  00397	48 8b c8	 mov	 rcx, rax
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN24@convert_ck:
$LN22@convert_ck:

; 645  :         }
; 646  : 
; 647  :         for (head = 0; head < heads; head++)

  003a0	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR head$[rsp], 0
  003ab	eb 10		 jmp	 SHORT $LN13@convert_ck
$LN11@convert_ck:
  003ad	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  003b4	ff c0		 inc	 eax
  003b6	89 84 24 84 00
	00 00		 mov	 DWORD PTR head$[rsp], eax
$LN13@convert_ck:
  003bd	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  003c4	39 84 24 84 00
	00 00		 cmp	 DWORD PTR head$[rsp], eax
  003cb	0f 83 d1 05 00
	00		 jae	 $LN12@convert_ck

; 648  :         {
; 649  :             /* Calculate the current offset in the file */
; 650  :             offset = (((U64)cyl*heads)+head)*itrklen;

  003d1	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  003d5	8b 8c 24 a8 04
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  003dc	48 0f af c1	 imul	 rax, rcx
  003e0	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  003e7	48 03 c1	 add	 rax, rcx
  003ea	48 63 8c 24 70
	04 00 00	 movsxd	 rcx, DWORD PTR itrklen$[rsp]
  003f2	48 0f af c1	 imul	 rax, rcx
  003f6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 651  : 
; 652  :             /* Read the input track image (except cyl 0 head 0
; 653  :                already read by the open_input_image procedure) */
; 654  :             if (cyl > 0 || head > 0)

  003fe	83 7c 24 74 00	 cmp	 DWORD PTR cyl$[rsp], 0
  00403	77 0a		 ja	 SHORT $LN26@convert_ck
  00405	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR head$[rsp], 0
  0040d	76 31		 jbe	 SHORT $LN25@convert_ck
$LN26@convert_ck:

; 655  :             {
; 656  :                 read_input_data (ifd, ifname,

  0040f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00417	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041c	44 8b 8c 24 70
	04 00 00	 mov	 r9d, DWORD PTR itrklen$[rsp]
  00424	4c 8b 84 24 78
	04 00 00	 mov	 r8, QWORD PTR itrkbuf$[rsp]
  0042c	48 8b 94 24 68
	04 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  00434	8b 8c 24 60 04
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  0043b	e8 00 00 00 00	 call	 read_input_data
$LN25@convert_ck:

; 657  :                                  itrkbuf, itrklen,
; 658  :                                  offset);
; 659  :             } /* end if(cyl>0||head>0) */
; 660  : 
; 661  :             /* Validate the track header */
; 662  :             ith = (H30CKD_TRKHDR*)itrkbuf;

  00440	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  00448	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR ith$[rsp], rax

; 663  :             FETCH_HW (ihc, ith->cyl);

  00450	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR ith$[rsp]
  00458	48 83 c0 10	 add	 rax, 16
  0045c	48 8b c8	 mov	 rcx, rax
  0045f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00464	0f b7 c8	 movzx	 ecx, ax
  00467	e8 00 00 00 00	 call	 _byteswap_ushort
  0046c	0f b7 c0	 movzx	 eax, ax
  0046f	89 84 24 98 00
	00 00		 mov	 DWORD PTR ihc$[rsp], eax

; 664  :             FETCH_HW (ihh, ith->head);

  00476	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR ith$[rsp]
  0047e	48 83 c0 12	 add	 rax, 18
  00482	48 8b c8	 mov	 rcx, rax
  00485	e8 00 00 00 00	 call	 fetch_hw_noswap
  0048a	0f b7 c8	 movzx	 ecx, ax
  0048d	e8 00 00 00 00	 call	 _byteswap_ushort
  00492	0f b7 c0	 movzx	 eax, ax
  00495	89 84 24 9c 00
	00 00		 mov	 DWORD PTR ihh$[rsp], eax

; 665  :             if (ihc != cyl || ihh != head)

  0049c	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  004a0	39 84 24 98 00
	00 00		 cmp	 DWORD PTR ihc$[rsp], eax
  004a7	75 14		 jne	 SHORT $LN28@convert_ck
  004a9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  004b0	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR ihh$[rsp], eax
  004b7	0f 84 ce 00 00
	00		 je	 $LN27@convert_ck
$LN28@convert_ck:

; 666  :             {
; 667  :                 // "Invalid track header at offset 0x%16.16"PRIX64
; 668  :                 FWRMSG( stderr, HHC02417, "E", offset );

  004bd	b9 02 00 00 00	 mov	 ecx, 2
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  004d0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169178
  004dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169179
  004e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169180
  004ff	ba 9c 02 00 00	 mov	 edx, 668		; 0000029cH
  00504	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169181
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 669  :                 // "Expected CCHH %04X%04X, found CCHH %04X%04X"
; 670  :                 FWRMSG( stderr, HHC02418, "E", cyl, head, ihc, ihh );

  00511	b9 02 00 00 00	 mov	 ecx, 2
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0051c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR ihh$[rsp]
  00523	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00527	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ihc$[rsp]
  0052e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00532	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  00539	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0053d	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  00541	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00545	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169182
  0054c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169183
  00558	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0055d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00562	41 b9 03 00 00
	00		 mov	 r9d, 3
  00568	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169184
  0056f	ba 9e 02 00 00	 mov	 edx, 670		; 0000029eH
  00574	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169185
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 671  :                 EXIT(8);

  00581	b9 08 00 00 00	 mov	 ecx, 8
  00586	e8 00 00 00 00	 call	 delayed_exit
$LN27@convert_ck:

; 672  :             }
; 673  : 
; 674  :             /* Clear the output track image to zeroes */
; 675  :             memset (obuf, 0, trksize);

  0058b	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00592	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv294[rsp], rax
  0059a	48 8b bc 24 b8
	04 00 00	 mov	 rdi, QWORD PTR obuf$[rsp]
  005a2	33 c0		 xor	 eax, eax
  005a4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv294[rsp]
  005ac	f3 aa		 rep stosb

; 676  : 
; 677  :             /* Build the output track header */
; 678  :             trkhdr = (CKD_TRKHDR*)obuf;

  005ae	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  005b6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 679  :             trkhdr->bin = 0;

  005be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  005c6	c6 00 00	 mov	 BYTE PTR [rax], 0

; 680  :             STORE_HW (trkhdr->cyl,  (U16) cyl);

  005c9	0f b7 4c 24 74	 movzx	 ecx, WORD PTR cyl$[rsp]
  005ce	e8 00 00 00 00	 call	 _byteswap_ushort
  005d3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  005db	48 ff c1	 inc	 rcx
  005de	0f b7 d0	 movzx	 edx, ax
  005e1	e8 00 00 00 00	 call	 store_hw_noswap

; 681  :             STORE_HW (trkhdr->head, (U16) head);

  005e6	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  005ee	e8 00 00 00 00	 call	 _byteswap_ushort
  005f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  005fb	48 83 c1 03	 add	 rcx, 3
  005ff	0f b7 d0	 movzx	 edx, ax
  00602	e8 00 00 00 00	 call	 store_hw_noswap

; 682  :             opos = obuf + CKD_TRKHDR_SIZE;

  00607	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  0060f	48 83 c0 05	 add	 rax, 5
  00613	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax

; 683  : 
; 684  :             /* Copy each record from the input buffer */
; 685  :             iptr = itrkbuf + H30CKD_TRKHDR_SIZE;

  0061b	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  00623	48 83 c0 30	 add	 rax, 48			; 00000030H
  00627	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR iptr$[rsp], rax

; 686  :             ilen = itrklen - H30CKD_TRKHDR_SIZE;

  0062f	48 63 84 24 70
	04 00 00	 movsxd	 rax, DWORD PTR itrklen$[rsp]
  00637	48 83 e8 30	 sub	 rax, 48			; 00000030H
  0063b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ilen$[rsp], eax
$LN14@convert_ck:

; 687  :             while (1)

  00642	33 c0		 xor	 eax, eax
  00644	83 f8 01	 cmp	 eax, 1
  00647	0f 84 69 02 00
	00		 je	 $LN15@convert_ck

; 688  :             {
; 689  :                 /* Locate the next input record */
; 690  :                 rc = find_input_record (itrkbuf, &iptr, &ilen,

  0064d	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR rec$[rsp]
  00655	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0065a	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR ihh$[rsp]
  00662	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00667	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR ihc$[rsp]
  0066f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00674	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR dptr$[rsp]
  0067c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00681	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dlen$[rsp]
  00689	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0068e	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR kptr$[rsp]
  00696	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0069b	4c 8d 4c 24 70	 lea	 r9, QWORD PTR klen$[rsp]
  006a0	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR ilen$[rsp]
  006a8	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR iptr$[rsp]
  006b0	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  006b8	e8 00 00 00 00	 call	 find_input_record
  006bd	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 691  :                         &klen, &kptr, &dlen, &dptr,
; 692  :                         &ihc, &ihh, &rec);
; 693  : 
; 694  :                 /* Exit at end of track */
; 695  :                 if (rc == 1) break;

  006c1	83 7c 24 7c 01	 cmp	 DWORD PTR rc$[rsp], 1
  006c6	75 05		 jne	 SHORT $LN29@convert_ck
  006c8	e9 e9 01 00 00	 jmp	 $LN15@convert_ck
$LN29@convert_ck:

; 696  : 
; 697  :                 /* Error if invalid record header detected */
; 698  :                 if (rc > 1)

  006cd	83 7c 24 7c 01	 cmp	 DWORD PTR rc$[rsp], 1
  006d2	0f 8e b0 00 00
	00		 jle	 $LN30@convert_ck

; 699  :                 {
; 700  :                     // "Invalid record header (rc %d) at offset %04X in trk at CCHH %04X%04X at offset 0x%16.16"PRIX64" in file %s"
; 701  :                     FWRMSG( stderr, HHC02419, "E",

  006d8	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  006e0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR iptr$[rsp]
  006e8	48 2b c8	 sub	 rcx, rax
  006eb	48 8b c1	 mov	 rax, rcx
  006ee	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv331[rsp], rax
  006f6	b9 02 00 00 00	 mov	 ecx, 2
  006fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00701	48 8b 8c 24 68
	04 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00709	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0070e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00716	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0071b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  00722	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00726	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  0072a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0072e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv331[rsp]
  00736	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0073a	8b 4c 24 7c	 mov	 ecx, DWORD PTR rc$[rsp]
  0073e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00742	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169188
  00749	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169189
  00755	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0075a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00765	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169190
  0076c	ba bf 02 00 00	 mov	 edx, 703		; 000002bfH
  00771	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169191
  00778	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 702  :                             rc, (unsigned int)(iptr-itrkbuf), cyl, head,
; 703  :                             offset, ifname );
; 704  :                     EXIT(9);

  0077e	b9 09 00 00 00	 mov	 ecx, 9
  00783	e8 00 00 00 00	 call	 delayed_exit
$LN30@convert_ck:

; 705  :                 }
; 706  : 
; 707  :                 /* Build AWSCKD record header in output buffer */
; 708  :                 rechdr = (CKD_RECHDR*)opos;

  00788	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  00790	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 709  :                 opos += CKD_RECHDR_SIZE;

  00798	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  007a0	48 83 c0 08	 add	 rax, 8
  007a4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax

; 710  :                 STORE_HW (rechdr->cyl,  (U16) ihc);

  007ac	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR ihc$[rsp]
  007b4	e8 00 00 00 00	 call	 _byteswap_ushort
  007b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  007c1	0f b7 d0	 movzx	 edx, ax
  007c4	e8 00 00 00 00	 call	 store_hw_noswap

; 711  :                 STORE_HW (rechdr->head, (U16) ihh);

  007c9	0f b7 8c 24 9c
	00 00 00	 movzx	 ecx, WORD PTR ihh$[rsp]
  007d1	e8 00 00 00 00	 call	 _byteswap_ushort
  007d6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  007de	48 83 c1 02	 add	 rcx, 2
  007e2	0f b7 d0	 movzx	 edx, ax
  007e5	e8 00 00 00 00	 call	 store_hw_noswap

; 712  :                 rechdr->rec = rec;

  007ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  007f2	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR rec$[rsp]
  007fa	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 713  :                 rechdr->klen = klen;

  007fd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  00805	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR klen$[rsp]
  0080a	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 714  :                 STORE_HW (rechdr->dlen, dlen);

  0080d	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR dlen$[rsp]
  00815	e8 00 00 00 00	 call	 _byteswap_ushort
  0081a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00822	48 83 c1 06	 add	 rcx, 6
  00826	0f b7 d0	 movzx	 edx, ax
  00829	e8 00 00 00 00	 call	 store_hw_noswap

; 715  : 
; 716  :                 /* Copy key and data to output buffer */
; 717  :                 if (klen != 0)

  0082e	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  00833	85 c0		 test	 eax, eax
  00835	74 34		 je	 SHORT $LN31@convert_ck

; 718  :                 {
; 719  :                     memcpy (opos, kptr, klen);

  00837	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  0083c	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR opos$[rsp]
  00844	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR kptr$[rsp]
  0084c	8b c8		 mov	 ecx, eax
  0084e	f3 a4		 rep movsb

; 720  :                     opos += klen;

  00850	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  00855	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opos$[rsp]
  0085d	48 03 c8	 add	 rcx, rax
  00860	48 8b c1	 mov	 rax, rcx
  00863	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax
$LN31@convert_ck:

; 721  :                 }
; 722  :                 if (dlen != 0)

  0086b	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR dlen$[rsp]
  00873	85 c0		 test	 eax, eax
  00875	74 3a		 je	 SHORT $LN32@convert_ck

; 723  :                 {
; 724  :                     memcpy (opos, dptr, dlen);

  00877	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR dlen$[rsp]
  0087f	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR opos$[rsp]
  00887	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR dptr$[rsp]
  0088f	8b c8		 mov	 ecx, eax
  00891	f3 a4		 rep movsb

; 725  :                     opos += dlen;

  00893	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR dlen$[rsp]
  0089b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opos$[rsp]
  008a3	48 03 c8	 add	 rcx, rax
  008a6	48 8b c1	 mov	 rax, rcx
  008a9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax
$LN32@convert_ck:

; 726  :                 }
; 727  : 
; 728  :             } /* end while */

  008b1	e9 8c fd ff ff	 jmp	 $LN14@convert_ck
$LN15@convert_ck:

; 729  : 
; 730  :             /* Build the end of track marker */
; 731  :             memcpy( opos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  008b6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  008be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  008c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 732  : 
; 733  :             /* Write the track to the file */
; 734  :             rc = write (ofd, obuf, trksize);

  008c8	44 8b 84 24 b0
	04 00 00	 mov	 r8d, DWORD PTR trksize$[rsp]
  008d0	48 8b 94 24 b8
	04 00 00	 mov	 rdx, QWORD PTR obuf$[rsp]
  008d8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  008df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  008e5	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 735  :             if (rc < 0 || (U32)rc < trksize)

  008e9	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  008ee	7c 11		 jl	 SHORT $LN34@convert_ck
  008f0	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  008f7	39 44 24 7c	 cmp	 DWORD PTR rc$[rsp], eax
  008fb	0f 83 9c 00 00
	00		 jae	 $LN33@convert_ck
$LN34@convert_ck:

; 736  :             {
; 737  :                 // "Error in function %s: %s"
; 738  :                 FWRMSG( stderr, HHC02412, "E", "write()",

  00901	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00907	83 38 00	 cmp	 DWORD PTR [rax], 0
  0090a	74 18		 je	 SHORT $LN41@convert_ck
  0090c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00912	8b 08		 mov	 ecx, DWORD PTR [rax]
  00914	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0091a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
  00922	eb 0f		 jmp	 SHORT $LN42@convert_ck
$LN41@convert_ck:
  00924	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169196
  0092b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
$LN42@convert_ck:
  00933	b9 02 00 00 00	 mov	 ecx, 2
  00938	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0093e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv401[rsp]
  00946	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0094b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169197
  00952	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00957	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169198
  0095e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00963	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169199
  0096a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0096f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00974	41 b9 03 00 00
	00		 mov	 r9d, 3
  0097a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169200
  00981	ba e3 02 00 00	 mov	 edx, 739		; 000002e3H
  00986	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169201
  0098d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 739  :                         errno ? strerror(errno) : "incomplete" );
; 740  :                 EXIT(1);

  00993	b9 01 00 00 00	 mov	 ecx, 1
  00998	e8 00 00 00 00	 call	 delayed_exit
$LN33@convert_ck:

; 741  :             }
; 742  : 
; 743  :         } /* end for(head) */

  0099d	e9 0b fa ff ff	 jmp	 $LN11@convert_ck
$LN12@convert_ck:

; 744  : 
; 745  :     } /* end for(cyl) */

  009a2	e9 6f f9 ff ff	 jmp	 $LN5@convert_ck
$LN6@convert_ck:

; 746  : 
; 747  :     /* Close the AWSCKD image file */
; 748  :     rc = close (ofd);

  009a7	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  009b4	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 749  :     if (rc < 0)

  009b8	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  009bd	0f 8d 80 00 00
	00		 jge	 $LN35@convert_ck

; 750  :     {
; 751  :         // "Error in function %s: %s"
; 752  :         FWRMSG( stderr, HHC02412, "E", "close()", strerror( errno ));

  009c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009c9	8b 08		 mov	 ecx, DWORD PTR [rax]
  009cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009d1	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv449[rsp], rax
  009d9	b9 02 00 00 00	 mov	 ecx, 2
  009de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv449[rsp]
  009ec	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169203
  009f8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169204
  00a04	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169205
  00a10	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a15	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a1a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a20	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169206
  00a27	ba f0 02 00 00	 mov	 edx, 752		; 000002f0H
  00a2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169207
  00a33	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 753  :         EXIT(10);

  00a39	b9 0a 00 00 00	 mov	 ecx, 10
  00a3e	e8 00 00 00 00	 call	 delayed_exit
$LN35@convert_ck:

; 754  :     }
; 755  : 
; 756  :     /* Display completion message */
; 757  :     // "%u cylinders succesfully written to file %s"
; 758  :     WRMSG( HHC02420, "I", cyl - start, ofname );

  00a43	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00a4a	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  00a4e	2b c8		 sub	 ecx, eax
  00a50	8b c1		 mov	 eax, ecx
  00a52	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv465[rsp], eax
  00a59	b9 01 00 00 00	 mov	 ecx, 1
  00a5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a64	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00a6c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a71	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv465[rsp]
  00a78	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169208
  00a83	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169209
  00a8f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a94	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a99	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a9f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169210
  00aa6	ba f6 02 00 00	 mov	 edx, 758		; 000002f6H
  00aab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169211
  00ab2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 759  : 
; 760  : } /* end function convert_ckd_file */

  00ab8	48 8b 8c 24 30
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ac0	48 33 cc	 xor	 rcx, rsp
  00ac3	e8 00 00 00 00	 call	 __security_check_cookie
  00ac8	48 81 c4 48 04
	00 00		 add	 rsp, 1096		; 00000448H
  00acf	5f		 pop	 rdi
  00ad0	5e		 pop	 rsi
  00ad1	c3		 ret	 0
convert_ckd_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
dt$ = 80
alts$ = 84
cyls$ = 88
itrklen$ = 92
tv182 = 96
rec$ = 100
klen$ = 101
code$ = 104
ifd$ = 108
tv166 = 112
dlen$ = 116
itrkbuf$ = 120
tv167 = 128
tv183 = 132
len$ = 136
rc$ = 140
cyl$ = 144
head$ = 148
dptr$ = 152
tv75 = 160
tv211 = 168
pbuf$ = 176
kptr$ = 184
h30trkhdr$ = 192
buf$1 = 240
pathname$ = 288
__$ArrayPad$ = 560
ifname$ = 608
devt$ = 616
vcyls$ = 624
itrkl$ = 632
itrkb$ = 640
volser$ = 648
open_input_image PROC

; 369  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : int             rc;                     /* Return code               */
; 371  : H30CKD_TRKHDR   h30trkhdr;              /* Input track header        */
; 372  : IFD             ifd;                    /* Input file descriptor     */
; 373  : int             len;                    /* Length of input           */
; 374  : U16             code;                   /* Device type code          */
; 375  : U16             dt = 0;                 /* Device type               */

  0002f	33 c0		 xor	 eax, eax
  00031	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax

; 376  : U32             cyls;                   /* Device size (pri+alt cyls)*/
; 377  : U32             alts;                   /* Number of alternate cyls  */
; 378  : BYTE           *itrkbuf;                /* -> Input track buffer     */
; 379  : U32             itrklen = 0;            /* Input track length        */

  00036	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR itrklen$[rsp], 0

; 380  : BYTE           *pbuf;                   /* Current byte in input buf */
; 381  : BYTE            klen;                   /* Key length                */
; 382  : U16             dlen;                   /* Data length               */
; 383  : BYTE           *kptr;                   /* -> Key in input buffer    */
; 384  : BYTE           *dptr;                   /* -> Data in input buffer   */
; 385  : U32             cyl;                    /* Cylinder number           */
; 386  : U32             head;                   /* Head number               */
; 387  : BYTE            rec;                    /* Record number             */
; 388  : char            pathname[MAX_PATH];     /* file path in host format  */
; 389  : 
; 390  :     hostpath(pathname, (char *)ifname, sizeof(pathname));

  0003e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00044	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  0004c	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 391  : 
; 392  :     /* Open the HDR-30 CKD image file */
; 393  :   #if defined( HAVE_ZLIB )
; 394  :     if (strcmp(ifname, "-") == 0)
; 395  :         ifd = gzdopen (STDIN_FILENO, "rb");
; 396  :     else
; 397  :         ifd = gzopen (pathname, "rb");
; 398  : 
; 399  :     if (ifd == NULL)
; 400  :     {
; 401  :         // "Error in function %s: %s"
; 402  :         FWRMSG( stderr, HHC02412, "E", "gzopen()", strerror( errno ));
; 403  :         EXIT(3);
; 404  :     }
; 405  :   #else /*!defined( HAVE_ZLIB )*/
; 406  :     if (strcmp(ifname, "-") == 0)

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168994
  00061	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00069	e8 00 00 00 00	 call	 strcmp
  0006e	85 c0		 test	 eax, eax
  00070	75 0d		 jne	 SHORT $LN8@open_input

; 407  :         ifd = STDIN_FILENO;

  00072	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ifd$[rsp], 0
  0007a	e9 a2 00 00 00	 jmp	 $LN9@open_input
$LN8@open_input:

; 408  :     else
; 409  :     {
; 410  :         ifd = HOPEN (pathname, O_RDONLY | O_BINARY);

  0007f	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00084	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00092	89 44 24 6c	 mov	 DWORD PTR ifd$[rsp], eax

; 411  : 
; 412  :         if (ifd < 0)

  00096	83 7c 24 6c 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0009b	0f 8d 80 00 00
	00		 jge	 $LN10@open_input

; 413  :         {
; 414  :             // "Error in function %s: %s"
; 415  :             FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a7	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000af	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000b7	b9 02 00 00 00	 mov	 ecx, 2
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000ca	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168996
  000d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  000e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168998
  000ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168999
  00105	ba 9f 01 00 00	 mov	 edx, 415		; 0000019fH
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169000
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 416  :             EXIT(3);

  00117	b9 03 00 00 00	 mov	 ecx, 3
  0011c	e8 00 00 00 00	 call	 delayed_exit
$LN10@open_input:
$LN9@open_input:

; 417  :         }
; 418  :     }
; 419  :   #endif /*!defined( HAVE_ZLIB )*/
; 420  : 
; 421  :     /* Read the first track header */
; 422  :     read_input_data (ifd, ifname, (BYTE*)&h30trkhdr,

  00121	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0012a	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00130	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR h30trkhdr$[rsp]
  00138	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  00140	8b 4c 24 6c	 mov	 ecx, DWORD PTR ifd$[rsp]
  00144	e8 00 00 00 00	 call	 read_input_data

; 423  :                     H30CKD_TRKHDR_SIZE, 0);
; 424  : 
; 425  :   #if !defined( HAVE_ZLIB )
; 426  :     /* Reject input if compressed and we lack gzip support */
; 427  :     if (memcmp(h30trkhdr.devcode, gz_magic_id, sizeof(gz_magic_id)) == 0)

  00149	41 b8 02 00 00
	00		 mov	 r8d, 2
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gz_magic_id
  00156	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  0015e	e8 00 00 00 00	 call	 memcmp
  00163	85 c0		 test	 eax, eax
  00165	75 51		 jne	 SHORT $LN11@open_input

; 428  :     {
; 429  :         // "Dasdconv64 is compiled without compress support and input is compressed"
; 430  :         FWRMSG( stderr, HHC02413, "E" );

  00167	b9 02 00 00 00	 mov	 ecx, 2
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169002
  00179	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169003
  00185	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0018a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00195	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169004
  0019c	ba ae 01 00 00	 mov	 edx, 430		; 000001aeH
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169005
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 431  :         EXIT(3);

  001ae	b9 03 00 00 00	 mov	 ecx, 3
  001b3	e8 00 00 00 00	 call	 delayed_exit
$LN11@open_input:

; 432  :     }
; 433  :   #endif /*!defined( HAVE_ZLIB )*/
; 434  : 
; 435  :     /* Reject input if it is already in CKD or CCKD format */
; 436  :     if (memcmp((BYTE*)&h30trkhdr, ckd_ident, sizeof(ckd_ident)) == 0)

  001b8	41 b8 04 00 00
	00		 mov	 r8d, 4
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ckd_ident
  001c5	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  001cd	e8 00 00 00 00	 call	 memcmp
  001d2	85 c0		 test	 eax, eax
  001d4	75 51		 jne	 SHORT $LN12@open_input

; 437  :     {
; 438  :         // "Input file is already in CKD format, use dasdcopy64"
; 439  :         WRMSG( HHC02414, "I" );

  001d6	b9 01 00 00 00	 mov	 ecx, 1
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169007
  001e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169008
  001f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00204	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169009
  0020b	ba b7 01 00 00	 mov	 edx, 439		; 000001b7H
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169010
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 440  :         EXIT(3);

  0021d	b9 03 00 00 00	 mov	 ecx, 3
  00222	e8 00 00 00 00	 call	 delayed_exit
$LN12@open_input:

; 441  :     }
; 442  : 
; 443  :     /* Extract the device type code from the track header */
; 444  :     FETCH_HW (code, h30trkhdr.devcode);

  00227	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  0022f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00234	0f b7 c8	 movzx	 ecx, ax
  00237	e8 00 00 00 00	 call	 _byteswap_ushort
  0023c	66 89 44 24 68	 mov	 WORD PTR code$[rsp], ax

; 445  : 
; 446  :     /* Determine the input device type and size from the device code */
; 447  :     switch (code) {

  00241	0f b7 44 24 68	 movzx	 eax, WORD PTR code$[rsp]
  00246	89 44 24 70	 mov	 DWORD PTR tv166[rsp], eax
  0024a	8b 44 24 70	 mov	 eax, DWORD PTR tv166[rsp]
  0024e	ff c8		 dec	 eax
  00250	89 44 24 70	 mov	 DWORD PTR tv166[rsp], eax
  00254	83 7c 24 70 14	 cmp	 DWORD PTR tv166[rsp], 20
  00259	0f 87 05 02 00
	00		 ja	 $LN29@open_input
  0025f	48 63 44 24 70	 movsxd	 rax, DWORD PTR tv166[rsp]
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0026b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@open_input[rcx+rax*4]
  00272	48 03 c1	 add	 rax, rcx
  00275	ff e0		 jmp	 rax
$LN13@open_input:

; 448  :     case 0x01: dt=0x3330; cyls=411; alts=7; break;      /* 3330      */

  00277	b8 30 33 00 00	 mov	 eax, 13104		; 00003330H
  0027c	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00281	c7 44 24 58 9b
	01 00 00	 mov	 DWORD PTR cyls$[rsp], 411 ; 0000019bH
  00289	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  00291	e9 36 02 00 00	 jmp	 $LN2@open_input
$LN14@open_input:

; 449  :     case 0x02: dt=0x3330; cyls=815; alts=7; break;      /* 3330-11   */

  00296	b8 30 33 00 00	 mov	 eax, 13104		; 00003330H
  0029b	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002a0	c7 44 24 58 2f
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 815 ; 0000032fH
  002a8	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  002b0	e9 17 02 00 00	 jmp	 $LN2@open_input
$LN15@open_input:

; 450  :     case 0x03: dt=0x3340; cyls=351; alts=1; break;      /* 3340-35   */

  002b5	b8 40 33 00 00	 mov	 eax, 13120		; 00003340H
  002ba	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002bf	c7 44 24 58 5f
	01 00 00	 mov	 DWORD PTR cyls$[rsp], 351 ; 0000015fH
  002c7	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR alts$[rsp], 1
  002cf	e9 f8 01 00 00	 jmp	 $LN2@open_input
$LN16@open_input:

; 451  :     case 0x04: dt=0x3340; cyls=701; alts=1; break;      /* 3340-70   */

  002d4	b8 40 33 00 00	 mov	 eax, 13120		; 00003340H
  002d9	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002de	c7 44 24 58 bd
	02 00 00	 mov	 DWORD PTR cyls$[rsp], 701 ; 000002bdH
  002e6	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR alts$[rsp], 1
  002ee	e9 d9 01 00 00	 jmp	 $LN2@open_input
$LN17@open_input:

; 452  :     case 0x05: dt=0x3350; cyls=562; alts=7; break;      /* 3350      */

  002f3	b8 50 33 00 00	 mov	 eax, 13136		; 00003350H
  002f8	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002fd	c7 44 24 58 32
	02 00 00	 mov	 DWORD PTR cyls$[rsp], 562 ; 00000232H
  00305	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  0030d	e9 ba 01 00 00	 jmp	 $LN2@open_input
$LN18@open_input:

; 453  :     case 0x06: dt=0x3375; cyls=962; alts=3; break;      /* 3375      */

  00312	b8 75 33 00 00	 mov	 eax, 13173		; 00003375H
  00317	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0031c	c7 44 24 58 c2
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 962 ; 000003c2H
  00324	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  0032c	e9 9b 01 00 00	 jmp	 $LN2@open_input
$LN19@open_input:

; 454  :     case 0x08: dt=0x3380; cyls=888; alts=3; break;      /* 3380-A,D,J*/

  00331	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00336	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0033b	c7 44 24 58 78
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 888 ; 00000378H
  00343	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  0034b	e9 7c 01 00 00	 jmp	 $LN2@open_input
$LN20@open_input:

; 455  :     case 0x09: dt=0x3380; cyls=1774; alts=4; break;     /* 3380-E    */

  00350	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00355	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0035a	c7 44 24 58 ee
	06 00 00	 mov	 DWORD PTR cyls$[rsp], 1774 ; 000006eeH
  00362	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  0036a	e9 5d 01 00 00	 jmp	 $LN2@open_input
$LN21@open_input:

; 456  :     case 0x0A: dt=0x3380; cyls=2660; alts=5; break;     /* 3380-K    */

  0036f	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00374	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00379	c7 44 24 58 64
	0a 00 00	 mov	 DWORD PTR cyls$[rsp], 2660 ; 00000a64H
  00381	c7 44 24 54 05
	00 00 00	 mov	 DWORD PTR alts$[rsp], 5
  00389	e9 3e 01 00 00	 jmp	 $LN2@open_input
$LN22@open_input:

; 457  :     case 0x0B: dt=0x3390; cyls=1117; alts=4; break;     /* 3390-1    */

  0038e	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  00393	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00398	c7 44 24 58 5d
	04 00 00	 mov	 DWORD PTR cyls$[rsp], 1117 ; 0000045dH
  003a0	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003a8	e9 1f 01 00 00	 jmp	 $LN2@open_input
$LN23@open_input:

; 458  :     case 0x0C: dt=0x3390; cyls=2230; alts=4; break;     /* 3390-2    */

  003ad	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  003b2	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003b7	c7 44 24 58 b6
	08 00 00	 mov	 DWORD PTR cyls$[rsp], 2230 ; 000008b6H
  003bf	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003c7	e9 00 01 00 00	 jmp	 $LN2@open_input
$LN24@open_input:

; 459  :     case 0x0D: dt=0x3390; cyls=3343; alts=4; break;     /* 3390-3    */

  003cc	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  003d1	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003d6	c7 44 24 58 0f
	0d 00 00	 mov	 DWORD PTR cyls$[rsp], 3343 ; 00000d0fH
  003de	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003e6	e9 e1 00 00 00	 jmp	 $LN2@open_input
$LN25@open_input:

; 460  :     case 0x12: dt=0x2314; cyls=203; alts=3; break;      /* 2314      */

  003eb	b8 14 23 00 00	 mov	 eax, 8980		; 00002314H
  003f0	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003f5	c7 44 24 58 cb
	00 00 00	 mov	 DWORD PTR cyls$[rsp], 203 ; 000000cbH
  003fd	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  00405	e9 c2 00 00 00	 jmp	 $LN2@open_input
$LN26@open_input:

; 461  :     case 0x13: dt=0x3390; cyls=10038; alts=21; break;   /* 3390-9    */

  0040a	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  0040f	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00414	c7 44 24 58 36
	27 00 00	 mov	 DWORD PTR cyls$[rsp], 10038 ; 00002736H
  0041c	c7 44 24 54 15
	00 00 00	 mov	 DWORD PTR alts$[rsp], 21
  00424	e9 a3 00 00 00	 jmp	 $LN2@open_input
$LN27@open_input:

; 462  :     case 0x14: dt=0x9345; cyls=1454; alts=14; break;    /* 9345-1    */

  00429	b8 45 93 00 00	 mov	 eax, 37701		; 00009345H
  0042e	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00433	c7 44 24 58 ae
	05 00 00	 mov	 DWORD PTR cyls$[rsp], 1454 ; 000005aeH
  0043b	c7 44 24 54 0e
	00 00 00	 mov	 DWORD PTR alts$[rsp], 14
  00443	e9 84 00 00 00	 jmp	 $LN2@open_input
$LN28@open_input:

; 463  :     case 0x15: dt=0x9345; cyls=2170; alts=14; break;    /* 9345-2    */

  00448	b8 45 93 00 00	 mov	 eax, 37701		; 00009345H
  0044d	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00452	c7 44 24 58 7a
	08 00 00	 mov	 DWORD PTR cyls$[rsp], 2170 ; 0000087aH
  0045a	c7 44 24 54 0e
	00 00 00	 mov	 DWORD PTR alts$[rsp], 14
  00462	eb 68		 jmp	 SHORT $LN2@open_input
$LN29@open_input:

; 464  :     default:
; 465  :         // "Unknown device type %04X at offset 00000000 in input file"
; 466  :         FWRMSG( stderr, HHC02415, "E", code );

  00464	0f b7 44 24 68	 movzx	 eax, WORD PTR code$[rsp]
  00469	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  00470	b9 02 00 00 00	 mov	 ecx, 2
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0047b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00482	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00486	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169028
  0048d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169029
  00499	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169030
  004b0	ba d2 01 00 00	 mov	 edx, 466		; 000001d2H
  004b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169031
  004bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 467  :         EXIT(3);

  004c2	b9 03 00 00 00	 mov	 ecx, 3
  004c7	e8 00 00 00 00	 call	 delayed_exit
$LN2@open_input:

; 468  :     } /* end switch(code) */
; 469  : 
; 470  :     /* Use the device type to determine the input image track size */
; 471  :     switch (dt) {

  004cc	0f b7 44 24 50	 movzx	 eax, WORD PTR dt$[rsp]
  004d1	89 44 24 60	 mov	 DWORD PTR tv182[rsp], eax
  004d5	81 7c 24 60 75
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13173 ; 00003375H
  004dd	7f 34		 jg	 SHORT $LN44@open_input
  004df	81 7c 24 60 75
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13173 ; 00003375H
  004e7	74 7e		 je	 SHORT $LN34@open_input
  004e9	81 7c 24 60 14
	23 00 00	 cmp	 DWORD PTR tv182[rsp], 8980 ; 00002314H
  004f1	74 40		 je	 SHORT $LN30@open_input
  004f3	81 7c 24 60 30
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13104 ; 00003330H
  004fb	74 43		 je	 SHORT $LN31@open_input
  004fd	81 7c 24 60 40
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13120 ; 00003340H
  00505	74 46		 je	 SHORT $LN32@open_input
  00507	81 7c 24 60 50
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13136 ; 00003350H
  0050f	74 49		 je	 SHORT $LN33@open_input
  00511	eb 7f		 jmp	 SHORT $LN38@open_input
$LN44@open_input:
  00513	81 7c 24 60 80
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13184 ; 00003380H
  0051b	74 57		 je	 SHORT $LN35@open_input
  0051d	81 7c 24 60 90
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13200 ; 00003390H
  00525	74 57		 je	 SHORT $LN36@open_input
  00527	81 7c 24 60 45
	93 00 00	 cmp	 DWORD PTR tv182[rsp], 37701 ; 00009345H
  0052f	74 57		 je	 SHORT $LN37@open_input
  00531	eb 5f		 jmp	 SHORT $LN38@open_input
$LN30@open_input:

; 472  :     case 0x2314: itrklen = 0x2000; break;

  00533	c7 44 24 5c 00
	20 00 00	 mov	 DWORD PTR itrklen$[rsp], 8192 ; 00002000H
  0053b	e9 ba 00 00 00	 jmp	 $LN4@open_input
$LN31@open_input:

; 473  :     case 0x3330: itrklen = 0x3400; break;

  00540	c7 44 24 5c 00
	34 00 00	 mov	 DWORD PTR itrklen$[rsp], 13312 ; 00003400H
  00548	e9 ad 00 00 00	 jmp	 $LN4@open_input
$LN32@open_input:

; 474  :     case 0x3340: itrklen = 0x2400; break;

  0054d	c7 44 24 5c 00
	24 00 00	 mov	 DWORD PTR itrklen$[rsp], 9216 ; 00002400H
  00555	e9 a0 00 00 00	 jmp	 $LN4@open_input
$LN33@open_input:

; 475  :     case 0x3350: itrklen = 0x4C00; break;

  0055a	c7 44 24 5c 00
	4c 00 00	 mov	 DWORD PTR itrklen$[rsp], 19456 ; 00004c00H
  00562	e9 93 00 00 00	 jmp	 $LN4@open_input
$LN34@open_input:

; 476  :     case 0x3375: itrklen = 0x9000; break;

  00567	c7 44 24 5c 00
	90 00 00	 mov	 DWORD PTR itrklen$[rsp], 36864 ; 00009000H
  0056f	e9 86 00 00 00	 jmp	 $LN4@open_input
$LN35@open_input:

; 477  :     case 0x3380: itrklen = 0xBC00; break;

  00574	c7 44 24 5c 00
	bc 00 00	 mov	 DWORD PTR itrklen$[rsp], 48128 ; 0000bc00H
  0057c	eb 7c		 jmp	 SHORT $LN4@open_input
$LN36@open_input:

; 478  :     case 0x3390: itrklen = 0xE400; break;

  0057e	c7 44 24 5c 00
	e4 00 00	 mov	 DWORD PTR itrklen$[rsp], 58368 ; 0000e400H
  00586	eb 72		 jmp	 SHORT $LN4@open_input
$LN37@open_input:

; 479  :     case 0x9345: itrklen = 0xBC00; break;

  00588	c7 44 24 5c 00
	bc 00 00	 mov	 DWORD PTR itrklen$[rsp], 48128 ; 0000bc00H
  00590	eb 68		 jmp	 SHORT $LN4@open_input
$LN38@open_input:

; 480  :     default:
; 481  :         // "Unknown device type %04X"
; 482  :         FWRMSG( stderr, HHC02416, "E", dt );

  00592	0f b7 44 24 50	 movzx	 eax, WORD PTR dt$[rsp]
  00597	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  0059e	b9 02 00 00 00	 mov	 ecx, 2
  005a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a9	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  005b0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169041
  005bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169042
  005c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169043
  005de	ba e2 01 00 00	 mov	 edx, 482		; 000001e2H
  005e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169044
  005ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 483  :         EXIT(3);

  005f0	b9 03 00 00 00	 mov	 ecx, 3
  005f5	e8 00 00 00 00	 call	 delayed_exit
$LN4@open_input:

; 484  :     } /* end switch(dt) */
; 485  : 
; 486  :     /* Obtain the input track buffer */
; 487  :     itrkbuf = malloc (itrklen);

  005fa	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  005fe	8b c8		 mov	 ecx, eax
  00600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00606	48 89 44 24 78	 mov	 QWORD PTR itrkbuf$[rsp], rax

; 488  :     if (itrkbuf == NULL)

  0060b	48 83 7c 24 78
	00		 cmp	 QWORD PTR itrkbuf$[rsp], 0
  00611	0f 85 a0 00 00
	00		 jne	 $LN39@open_input

; 489  :     {
; 490  :         char buf[40];
; 491  :         MSGBUF( buf, "malloc(%u)", itrklen);

  00617	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR itrklen$[rsp]
  0061c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169046
  00623	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00628	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00630	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 492  :         // "Error in function %s: %s"
; 493  :         FWRMSG( stderr, HHC02412, "E", buf, strerror( errno ));

  00636	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0063c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00644	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  0064c	b9 02 00 00 00	 mov	 ecx, 2
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00657	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  0065f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00664	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0066c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00671	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169047
  00678	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169048
  00684	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00689	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00694	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169049
  0069b	ba ed 01 00 00	 mov	 edx, 493		; 000001edH
  006a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169050
  006a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 494  :         EXIT(3);

  006ad	b9 03 00 00 00	 mov	 ecx, 3
  006b2	e8 00 00 00 00	 call	 delayed_exit
$LN39@open_input:

; 495  :     }
; 496  : 
; 497  :     /* Copy the first track header to the input track buffer */
; 498  :     memcpy (itrkbuf, &h30trkhdr, H30CKD_TRKHDR_SIZE);

  006b7	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR h30trkhdr$[rsp]
  006bf	48 8b 7c 24 78	 mov	 rdi, QWORD PTR itrkbuf$[rsp]
  006c4	48 8b f0	 mov	 rsi, rax
  006c7	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  006cc	f3 a4		 rep movsb

; 499  : 
; 500  :     /* Read the remainder of the first track into the buffer */
; 501  :     read_input_data (ifd, ifname,

  006ce	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  006d2	48 83 e8 30	 sub	 rax, 48			; 00000030H
  006d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  006db	48 83 c1 30	 add	 rcx, 48			; 00000030H
  006df	48 c7 44 24 20
	30 00 00 00	 mov	 QWORD PTR [rsp+32], 48	; 00000030H
  006e8	44 8b c8	 mov	 r9d, eax
  006eb	4c 8b c1	 mov	 r8, rcx
  006ee	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  006f6	8b 4c 24 6c	 mov	 ecx, DWORD PTR ifd$[rsp]
  006fa	e8 00 00 00 00	 call	 read_input_data

; 502  :                      itrkbuf + H30CKD_TRKHDR_SIZE,
; 503  :                      itrklen - H30CKD_TRKHDR_SIZE,
; 504  :                      H30CKD_TRKHDR_SIZE);
; 505  : 
; 506  :     /* Initialize the volume serial number */
; 507  :     strlcpy( (char*) volser, "(NONE)", VOLSER_LEN+1 );

  006ff	41 b8 07 00 00
	00		 mov	 r8d, 7
  00705	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169051
  0070c	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00714	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 508  : 
; 509  :     /* Search for volume label in record 3 of first track */
; 510  :     pbuf = itrkbuf + H30CKD_TRKHDR_SIZE;

  0071a	48 8b 44 24 78	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  0071f	48 83 c0 30	 add	 rax, 48			; 00000030H
  00723	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pbuf$[rsp], rax

; 511  :     len  = itrklen - H30CKD_TRKHDR_SIZE;

  0072b	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  0072f	48 83 e8 30	 sub	 rax, 48			; 00000030H
  00733	89 84 24 88 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN6@open_input:

; 512  :     while (1)

  0073a	33 c0		 xor	 eax, eax
  0073c	83 f8 01	 cmp	 eax, 1
  0073f	0f 84 22 01 00
	00		 je	 $LN7@open_input

; 513  :     {
; 514  :         /* Find next input record */
; 515  :         rc = find_input_record (itrkbuf, &pbuf, &len,

  00745	48 8d 44 24 64	 lea	 rax, QWORD PTR rec$[rsp]
  0074a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0074f	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR head$[rsp]
  00757	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0075c	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  00764	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00769	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dptr$[rsp]
  00771	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00776	48 8d 44 24 74	 lea	 rax, QWORD PTR dlen$[rsp]
  0077b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00780	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR kptr$[rsp]
  00788	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0078d	4c 8d 4c 24 65	 lea	 r9, QWORD PTR klen$[rsp]
  00792	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR len$[rsp]
  0079a	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR pbuf$[rsp]
  007a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  007a7	e8 00 00 00 00	 call	 find_input_record
  007ac	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 516  :                 &klen, &kptr, &dlen, &dptr,
; 517  :                 &cyl, &head, &rec);
; 518  : 
; 519  :         /* Give up if error or end of track */
; 520  :         if (rc != 0) break;

  007b3	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  007bb	74 05		 je	 SHORT $LN40@open_input
  007bd	e9 a5 00 00 00	 jmp	 $LN7@open_input
$LN40@open_input:

; 521  : 
; 522  :         /* Process when record 3 is found */
; 523  :         if (cyl == 0 && head == 0 && rec == 3)

  007c2	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyl$[rsp], 0
  007ca	0f 85 92 00 00
	00		 jne	 $LN41@open_input
  007d0	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR head$[rsp], 0
  007d8	0f 85 84 00 00
	00		 jne	 $LN41@open_input
  007de	0f b6 44 24 64	 movzx	 eax, BYTE PTR rec$[rsp]
  007e3	83 f8 03	 cmp	 eax, 3
  007e6	75 7a		 jne	 SHORT $LN41@open_input

; 524  :         {
; 525  :             /* Extract volser if it is a volume label */
; 526  :             if (klen ==  4 && memcmp( kptr, VOL1_KEY, VOL1_KEYLEN ) == 0
; 527  :             &&  dlen == 80 && memcmp( dptr, VOL1_KEY, VOL1_KEYLEN ) == 0)

  007e8	0f b6 44 24 65	 movzx	 eax, BYTE PTR klen$[rsp]
  007ed	83 f8 04	 cmp	 eax, 4
  007f0	75 6e		 jne	 SHORT $LN42@open_input
  007f2	41 b8 04 00 00
	00		 mov	 r8d, 4
  007f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VOL1_KEY
  007ff	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR kptr$[rsp]
  00807	e8 00 00 00 00	 call	 memcmp
  0080c	85 c0		 test	 eax, eax
  0080e	75 50		 jne	 SHORT $LN42@open_input
  00810	0f b7 44 24 74	 movzx	 eax, WORD PTR dlen$[rsp]
  00815	83 f8 50	 cmp	 eax, 80			; 00000050H
  00818	75 46		 jne	 SHORT $LN42@open_input
  0081a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00820	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VOL1_KEY
  00827	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  0082f	e8 00 00 00 00	 call	 memcmp
  00834	85 c0		 test	 eax, eax
  00836	75 28		 jne	 SHORT $LN42@open_input

; 528  :                 make_asciiz( (char*) volser, VOLSER_LEN+1, dptr + VOL1_KEYLEN, VOLSER_LEN );

  00838	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  00840	48 83 c0 04	 add	 rax, 4
  00844	41 b9 06 00 00
	00		 mov	 r9d, 6
  0084a	4c 8b c0	 mov	 r8, rax
  0084d	ba 07 00 00 00	 mov	 edx, 7
  00852	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  0085a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz
$LN42@open_input:

; 529  :             break;

  00860	eb 05		 jmp	 SHORT $LN7@open_input
$LN41@open_input:

; 530  :         }
; 531  :     } /* end while */

  00862	e9 d3 fe ff ff	 jmp	 $LN6@open_input
$LN7@open_input:

; 532  : 
; 533  :     /* Set output variables and return the input file descriptor */
; 534  :     *devt  = dt;

  00867	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR devt$[rsp]
  0086f	0f b7 4c 24 50	 movzx	 ecx, WORD PTR dt$[rsp]
  00874	66 89 08	 mov	 WORD PTR [rax], cx

; 535  :     *vcyls = cyls - alts;

  00877	8b 44 24 54	 mov	 eax, DWORD PTR alts$[rsp]
  0087b	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  0087f	2b c8		 sub	 ecx, eax
  00881	8b c1		 mov	 eax, ecx
  00883	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR vcyls$[rsp]
  0088b	89 01		 mov	 DWORD PTR [rcx], eax

; 536  :     *itrkl = itrklen;

  0088d	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR itrkl$[rsp]
  00895	8b 4c 24 5c	 mov	 ecx, DWORD PTR itrklen$[rsp]
  00899	89 08		 mov	 DWORD PTR [rax], ecx

; 537  :     *itrkb = itrkbuf;

  0089b	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR itrkb$[rsp]
  008a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  008a8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 538  :     return ifd;

  008ab	8b 44 24 6c	 mov	 eax, DWORD PTR ifd$[rsp]

; 539  : 
; 540  : } /* end function open_input_image */

  008af	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008b7	48 33 cc	 xor	 rcx, rsp
  008ba	e8 00 00 00 00	 call	 __security_check_cookie
  008bf	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  008c6	5f		 pop	 rdi
  008c7	5e		 pop	 rsi
  008c8	c3		 ret	 0
  008c9	0f 1f 00	 npad	 3
$LN45@open_input:
  008cc	00 00 00 00	 DD	 $LN13@open_input
  008d0	00 00 00 00	 DD	 $LN14@open_input
  008d4	00 00 00 00	 DD	 $LN15@open_input
  008d8	00 00 00 00	 DD	 $LN16@open_input
  008dc	00 00 00 00	 DD	 $LN17@open_input
  008e0	00 00 00 00	 DD	 $LN18@open_input
  008e4	00 00 00 00	 DD	 $LN29@open_input
  008e8	00 00 00 00	 DD	 $LN19@open_input
  008ec	00 00 00 00	 DD	 $LN20@open_input
  008f0	00 00 00 00	 DD	 $LN21@open_input
  008f4	00 00 00 00	 DD	 $LN22@open_input
  008f8	00 00 00 00	 DD	 $LN23@open_input
  008fc	00 00 00 00	 DD	 $LN24@open_input
  00900	00 00 00 00	 DD	 $LN29@open_input
  00904	00 00 00 00	 DD	 $LN29@open_input
  00908	00 00 00 00	 DD	 $LN29@open_input
  0090c	00 00 00 00	 DD	 $LN29@open_input
  00910	00 00 00 00	 DD	 $LN25@open_input
  00914	00 00 00 00	 DD	 $LN26@open_input
  00918	00 00 00 00	 DD	 $LN27@open_input
  0091c	00 00 00 00	 DD	 $LN28@open_input
open_input_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
klen$ = 32
dlen$ = 36
n$ = 40
hrec$ = 48
buf$ = 80
ppbuf$ = 88
plen$ = 96
pkl$ = 104
pkp$ = 112
pdl$ = 120
pdp$ = 128
pcc$ = 136
phh$ = 144
prn$ = 152
find_input_record PROC

; 288  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@find_input:

; 289  : H30CKD_RECHDR  *hrec;                   /* Input record header       */
; 290  : U16             dlen;                   /* Data length               */
; 291  : BYTE            klen;                   /* Key length                */
; 292  : int             n;                      /* Integer work area         */
; 293  : 
; 294  :     UNREFERENCED(buf);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@find_input

; 295  : 
; 296  :     /* End of track if not enough bytes remain in buffer */
; 297  :     if (*plen < H30CKD_RECHDR_SIZE) return 1;

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  00023	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00026	48 83 f8 0c	 cmp	 rax, 12
  0002a	7d 0a		 jge	 SHORT $LN5@find_input
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e9 2a 02 00 00	 jmp	 $LN1@find_input
$LN5@find_input:

; 298  : 
; 299  :     /* Point to record header */
; 300  :     hrec = (H30CKD_RECHDR*)(*ppbuf);

  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 44 24 30	 mov	 QWORD PTR hrec$[rsp], rax

; 301  : 
; 302  :     /* End of track if record header is all zero */
; 303  :     if (memcmp(*ppbuf, twelvehex00, 12) == 0) return 1;

  00043	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:twelvehex00
  00050	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  00055	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00058	e8 00 00 00 00	 call	 memcmp
  0005d	85 c0		 test	 eax, eax
  0005f	75 0a		 jne	 SHORT $LN6@find_input
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	e9 f5 01 00 00	 jmp	 $LN1@find_input
$LN6@find_input:

; 304  : 
; 305  :     /* Extract the key length and data length */
; 306  :     klen = hrec->klen;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  00070	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  00074	88 44 24 20	 mov	 BYTE PTR klen$[rsp], al

; 307  :     FETCH_HW (dlen, hrec->dlen);

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0007d	48 83 c0 0a	 add	 rax, 10
  00081	48 8b c8	 mov	 rcx, rax
  00084	e8 00 00 00 00	 call	 fetch_hw_noswap
  00089	0f b7 c8	 movzx	 ecx, ax
  0008c	e8 00 00 00 00	 call	 _byteswap_ushort
  00091	66 89 44 24 24	 mov	 WORD PTR dlen$[rsp], ax

; 308  : 
; 309  :     /* Check that the reserved bytes are all zero */
; 310  :     if (memcmp(hrec->resv00, twelvehex00, sizeof(hrec->resv00)) != 0)

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0009b	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:twelvehex00
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 memcmp
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN7@find_input

; 311  :         return 2;

  000b4	b8 02 00 00 00	 mov	 eax, 2
  000b9	e9 a2 01 00 00	 jmp	 $LN1@find_input
$LN7@find_input:

; 312  : 
; 313  :     /* Check that the key and data do not overflow the buffer */
; 314  :     if (*plen < H30CKD_RECHDR_SIZE + klen + dlen)

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  000c3	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000c6	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR klen$[rsp]
  000cb	0f b7 54 24 24	 movzx	 edx, WORD PTR dlen$[rsp]
  000d0	48 8d 4c 11 0c	 lea	 rcx, QWORD PTR [rcx+rdx+12]
  000d5	48 3b c1	 cmp	 rax, rcx
  000d8	7d 0a		 jge	 SHORT $LN8@find_input

; 315  :         return 3;

  000da	b8 03 00 00 00	 mov	 eax, 3
  000df	e9 7c 01 00 00	 jmp	 $LN1@find_input
$LN8@find_input:

; 316  : 
; 317  :     /* Return the cylinder, head, and record number */
; 318  :     FETCH_HW (*pcc, hrec->cyl);

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  000e9	48 83 c0 04	 add	 rax, 4
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f5	0f b7 c8	 movzx	 ecx, ax
  000f8	e8 00 00 00 00	 call	 _byteswap_ushort
  000fd	0f b7 c0	 movzx	 eax, ax
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pcc$[rsp]
  00108	89 01		 mov	 DWORD PTR [rcx], eax

; 319  :     FETCH_HW (*phh, hrec->head);

  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0010f	48 83 c0 06	 add	 rax, 6
  00113	48 8b c8	 mov	 rcx, rax
  00116	e8 00 00 00 00	 call	 fetch_hw_noswap
  0011b	0f b7 c8	 movzx	 ecx, ax
  0011e	e8 00 00 00 00	 call	 _byteswap_ushort
  00123	0f b7 c0	 movzx	 eax, ax
  00126	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR phh$[rsp]
  0012e	89 01		 mov	 DWORD PTR [rcx], eax

; 320  :     *prn = hrec->rec;

  00130	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR prn$[rsp]
  00138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hrec$[rsp]
  0013d	0f b6 49 08	 movzx	 ecx, BYTE PTR [rcx+8]
  00141	88 08		 mov	 BYTE PTR [rax], cl

; 321  : 
; 322  :     /* Point past the record header to the key */
; 323  :     *plen -= H30CKD_RECHDR_SIZE;

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  00148	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0014b	48 83 e8 0c	 sub	 rax, 12
  0014f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00154	89 01		 mov	 DWORD PTR [rcx], eax

; 324  :     *ppbuf += H30CKD_RECHDR_SIZE;

  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  0015b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015e	48 83 c0 0c	 add	 rax, 12
  00162	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00167	48 89 01	 mov	 QWORD PTR [rcx], rax

; 325  : 
; 326  :     /* Return the key length and key pointer */
; 327  :     *pkl = klen;

  0016a	48 8b 44 24 68	 mov	 rax, QWORD PTR pkl$[rsp]
  0016f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR klen$[rsp]
  00174	88 08		 mov	 BYTE PTR [rax], cl

; 328  :     *pkp = *ppbuf;

  00176	48 8b 44 24 70	 mov	 rax, QWORD PTR pkp$[rsp]
  0017b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00180	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00183	48 89 08	 mov	 QWORD PTR [rax], rcx

; 329  : 
; 330  :     /* Point past the key to the data */
; 331  :     *plen -= klen;

  00186	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  0018b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00190	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00192	2b c8		 sub	 ecx, eax
  00194	8b c1		 mov	 eax, ecx
  00196	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  0019b	89 01		 mov	 DWORD PTR [rcx], eax

; 332  :     *ppbuf += klen;

  0019d	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001a7	48 03 01	 add	 rax, QWORD PTR [rcx]
  001aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001af	48 89 01	 mov	 QWORD PTR [rcx], rax

; 333  : 
; 334  :     /* Return the data length and data pointer */
; 335  :     *pdl = dlen;

  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR pdl$[rsp]
  001b7	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  001bc	66 89 08	 mov	 WORD PTR [rax], cx

; 336  :     *pdp = *ppbuf;

  001bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pdp$[rsp]
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001cc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001cf	48 89 08	 mov	 QWORD PTR [rax], rcx

; 337  : 
; 338  :     /* Point past the data to the next record header */
; 339  :     *plen -= dlen;

  001d2	0f b7 44 24 24	 movzx	 eax, WORD PTR dlen$[rsp]
  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  001dc	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001de	2b c8		 sub	 ecx, eax
  001e0	8b c1		 mov	 eax, ecx
  001e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  001e7	89 01		 mov	 DWORD PTR [rcx], eax

; 340  :     *ppbuf += dlen;

  001e9	0f b7 44 24 24	 movzx	 eax, WORD PTR dlen$[rsp]
  001ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001f3	48 03 01	 add	 rax, QWORD PTR [rcx]
  001f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001fb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 341  : 
; 342  :     /* Ensure next header starts on a fullword boundary */
; 343  :     if ((klen + dlen) & 3)

  001fe	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  00203	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  00208	03 c1		 add	 eax, ecx
  0020a	83 e0 03	 and	 eax, 3
  0020d	85 c0		 test	 eax, eax
  0020f	74 4d		 je	 SHORT $LN9@find_input

; 344  :     {
; 345  :         n = 4 - ((klen + dlen) % 4);

  00211	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  00216	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  0021b	03 c1		 add	 eax, ecx
  0021d	99		 cdq
  0021e	83 e2 03	 and	 edx, 3
  00221	03 c2		 add	 eax, edx
  00223	83 e0 03	 and	 eax, 3
  00226	2b c2		 sub	 eax, edx
  00228	b9 04 00 00 00	 mov	 ecx, 4
  0022d	2b c8		 sub	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 346  :         *plen -= n;

  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  0023a	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  0023e	8b 00		 mov	 eax, DWORD PTR [rax]
  00240	2b c1		 sub	 eax, ecx
  00242	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00247	89 01		 mov	 DWORD PTR [rcx], eax

; 347  :         *ppbuf += n;

  00249	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00253	48 03 01	 add	 rax, QWORD PTR [rcx]
  00256	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  0025b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@find_input:

; 348  :     }
; 349  : 
; 350  :     return 0;

  0025e	33 c0		 xor	 eax, eax
$LN1@find_input:

; 351  : } /* end function find_input_record */

  00260	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00264	c3		 ret	 0
find_input_record ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
len$ = 80
rc$ = 84
tv76 = 88
ifd$ = 112
ifname$ = 120
buf$ = 128
reqlen$ = 136
offset$ = 144
read_input_data PROC

; 230  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 231  : int     rc;                             /* Return code               */
; 232  : int     len = 0;                        /* Number of bytes read      */

  00017	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN4@read_input:

; 233  : 
; 234  :     UNREFERENCED(ifname);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN4@read_input
$LN7@read_input:

; 235  :     UNREFERENCED(offset);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN7@read_input
$LN8@read_input:

; 236  :     while (len < reqlen)

  0002b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reqlen$[rsp]
  00032	39 44 24 50	 cmp	 DWORD PTR len$[rsp], eax
  00036	0f 8d d8 00 00
	00		 jge	 $LN9@read_input

; 237  :     {
; 238  :         rc = IFREAD (ifd, buf + len, reqlen - len);

  0003c	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00040	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR reqlen$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR len$[rsp]
  00050	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00058	48 03 d1	 add	 rdx, rcx
  0005b	48 8b ca	 mov	 rcx, rdx
  0005e	44 8b c0	 mov	 r8d, eax
  00061	48 8b d1	 mov	 rdx, rcx
  00064	8b 4c 24 70	 mov	 ecx, DWORD PTR ifd$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0006e	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 239  :         if (rc == 0) break;

  00072	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00077	75 05		 jne	 SHORT $LN10@read_input
  00079	e9 96 00 00 00	 jmp	 $LN9@read_input
$LN10@read_input:

; 240  :         if (rc < 0)

  0007e	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00083	7d 7a		 jge	 SHORT $LN11@read_input

; 241  :         {
; 242  :             // "Error in function %s: %s"
; 243  : #if defined( HAVE_ZLIB )
; 244  :             FWRMSG( stderr, HHC02412, "E", "gzread()", strerror( errno ));
; 245  : #else
; 246  :             FWRMSG( stderr, HHC02412, "E", "read()", strerror( errno ));

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00093	48 89 44 24 58	 mov	 QWORD PTR tv76[rsp], rax
  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv76[rsp]
  000a8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168879
  000b4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168880
  000c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168881
  000cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168882
  000e3	ba f6 00 00 00	 mov	 edx, 246		; 000000f6H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168883
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 247  : #endif
; 248  :             EXIT(3);

  000f5	b9 03 00 00 00	 mov	 ecx, 3
  000fa	e8 00 00 00 00	 call	 delayed_exit
$LN11@read_input:

; 249  :         }
; 250  :         len += rc;

  000ff	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00103	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00107	03 c8		 add	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	89 44 24 50	 mov	 DWORD PTR len$[rsp], eax

; 251  :     } /* end while */

  0010f	e9 17 ff ff ff	 jmp	 $LN8@read_input
$LN9@read_input:

; 252  : 
; 253  :     if (len < reqlen)

  00114	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reqlen$[rsp]
  0011b	39 44 24 50	 cmp	 DWORD PTR len$[rsp], eax
  0011f	7d 69		 jge	 SHORT $LN12@read_input

; 254  :     {
; 255  :         // "Error in function %s: %s"
; 256  : #if defined( HAVE_ZLIB )
; 257  :         FWRMSG( stderr, HHC02412, "E", "gzread()", "unexpected end of file" );
; 258  : #else
; 259  :         FWRMSG( stderr, HHC02412, "E", "read()", "unexpected end of file" );

  00121	b9 02 00 00 00	 mov	 ecx, 2
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168885
  00133	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168886
  0013f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168887
  0014b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168888
  00157	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	41 b9 03 00 00
	00		 mov	 r9d, 3
  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168889
  0016e	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168890
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 260  : #endif
; 261  :         EXIT(3);

  00180	b9 03 00 00 00	 mov	 ecx, 3
  00185	e8 00 00 00 00	 call	 delayed_exit
$LN12@read_input:

; 262  :     }
; 263  : 
; 264  : } /* end function read_input_data */

  0018a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018e	c3		 ret	 0
read_input_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
code$ = 96
pgm$ = 104
argexit	PROC

; 207  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 208  :     // "Usage: %s ...
; 209  :     if (sizeof(off_t) > 4)

  0000d	33 c0		 xor	 eax, eax
  0000f	83 f8 01	 cmp	 eax, 1
  00012	74 5f		 je	 SHORT $LN2@argexit

; 210  :         WRMSG( HHC02410, "I", pgm,

  00014	b9 01 00 00 00	 mov	 ecx, 1
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168846
  00026	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pgm$[rsp]
  00030	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168847
  0003c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168848
  00048	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00052	41 b9 03 00 00
	00		 mov	 r9d, 3
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168849
  0005f	ba d3 00 00 00	 mov	 edx, 211		; 000000d3H
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168850
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00071	eb 5d		 jmp	 SHORT $LN3@argexit
$LN2@argexit:

; 211  :                 "\nHHC02410I   -lfs   build one large output file" );
; 212  :     else
; 213  :         WRMSG( HHC02410, "I", pgm, "" );

  00073	b9 01 00 00 00	 mov	 ecx, 1
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168851
  00085	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pgm$[rsp]
  0008f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168852
  0009b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168853
  000a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168854
  000be	ba d5 00 00 00	 mov	 edx, 213		; 000000d5H
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168855
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@argexit:

; 214  : 
; 215  :     EXIT(code);

  000d0	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  000d4	e8 00 00 00 00	 call	 delayed_exit

; 216  : } /* end function argexit */

  000d9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000dd	c3		 ret	 0
argexit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv64.c
_TEXT	SEGMENT
exit_code$ = 48
delayed_exit PROC

; 194  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 195  :     /* Delay exiting is to give the system
; 196  :      * time to display the error message. */
; 197  :     usleep(100000);

  00008	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 198  :     exit(exit_code);

  00013	8b 4c 24 30	 mov	 ecx, DWORD PTR exit_code$[rsp]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@delayed_ex:

; 199  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
delayed_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
