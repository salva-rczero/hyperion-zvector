; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	comm3705_kw:DWORD
_DATA	ENDS
_DATA	SEGMENT
commadpt_immed_command DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG168212 DB	'lport', 00H
	ORG $+2
$SG168213 DB	'%79s', 00H
	ORG $+3
$SG168214 DB	'lhost', 00H
	ORG $+2
$SG168215 DB	'%79s', 00H
	ORG $+3
$SG168216 DB	'rport', 00H
	ORG $+2
$SG168217 DB	'%79s', 00H
	ORG $+3
$SG168218 DB	'rhost', 00H
	ORG $+2
$SG168219 DB	'%79s', 00H
	ORG $+3
$SG168220 DB	'dial', 00H
	ORG $+3
$SG168221 DB	'%79s', 00H
	ORG $+3
$SG168222 DB	'rto', 00H
$SG168223 DB	'%79s', 00H
	ORG $+3
$SG168224 DB	'pto', 00H
$SG168225 DB	'%79s', 00H
	ORG $+3
$SG168226 DB	'eto', 00H
$SG168227 DB	'%79s', 00H
	ORG $+3
$SG168230 DB	'lnctl', 00H
	ORG $+2
$SG168248 DB	'unitsz', 00H
	ORG $+5
$SG168228 DB	'switched', 00H
	ORG $+3
$SG168229 DB	'%79s', 00H
	ORG $+3
$SG168231 DB	'%79s', 00H
	ORG $+3
$SG168232 DB	'debug', 00H
	ORG $+2
$SG168233 DB	'%79s', 00H
	ORG $+7
$SG168234 DB	'emu3791', 00H
$SG168235 DB	'%79s', 00H
	ORG $+3
$SG168236 DB	'locsuba', 00H
$SG168237 DB	'%79s', 00H
	ORG $+3
$SG168238 DB	'rmtsuba', 00H
$SG168239 DB	'%79s', 00H
	ORG $+3
$SG168240 DB	'locncpnm', 00H
	ORG $+3
$SG168241 DB	'%79s', 00H
	ORG $+7
$SG168242 DB	'rmtncpnm', 00H
	ORG $+3
$SG168243 DB	'%79s', 00H
	ORG $+3
$SG168244 DB	'idblk', 00H
	ORG $+2
$SG168245 DB	'%79s', 00H
	ORG $+3
$SG168246 DB	'idnum', 00H
	ORG $+2
$SG168247 DB	'%79s', 00H
	ORG $+3
$SG168249 DB	'%79s', 00H
	ORG $+7
$SG168250 DB	'ackspeed', 00H
	ORG $+3
$SG168251 DB	'%79s', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	make_seq
PUBLIC	make_sna_requests
PUBLIC	make_sna_response
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_ntohs:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_getservbyname:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_socketpair:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_socket_set_blocking_mode:PROC
EXTRN	__imp_socket_is_socket:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_prt_host_to_guest:PROC
EXTRN	__imp_write_socket:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_parser:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
cons_hostinfo DB 0270H DUP (?)
$SG169149 DB	01H DUP (?)
	ALIGN	4

$SG169209 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$make_sna_requests2 DD imagerel make_sna_requests2
	DD	imagerel make_sna_requests2+1392
	DD	imagerel $unwind$make_sna_requests2
$pdata$make_sna_requests3 DD imagerel make_sna_requests3
	DD	imagerel make_sna_requests3+724
	DD	imagerel $unwind$make_sna_requests3
$pdata$make_sna_requests4 DD imagerel make_sna_requests4
	DD	imagerel make_sna_requests4+1209
	DD	imagerel $unwind$make_sna_requests4
$pdata$make_sna_requests5 DD imagerel make_sna_requests5
	DD	imagerel make_sna_requests5+755
	DD	imagerel $unwind$make_sna_requests5
$pdata$double_up_iac DD imagerel double_up_iac
	DD	imagerel double_up_iac+232
	DD	imagerel $unwind$double_up_iac
$pdata$send_packet DD imagerel send_packet
	DD	imagerel send_packet+190
	DD	imagerel $unwind$send_packet
$pdata$recv_packet DD imagerel recv_packet
	DD	imagerel recv_packet+381
	DD	imagerel $unwind$recv_packet
$pdata$expect DD imagerel expect
	DD	imagerel expect+253
	DD	imagerel $unwind$expect
$pdata$negotiate DD imagerel negotiate
	DD	imagerel negotiate+1754
	DD	imagerel $unwind$negotiate
$pdata$connect_client DD imagerel connect_client
	DD	imagerel connect_client+1245
	DD	imagerel $unwind$connect_client
$pdata$logdump DD imagerel logdump
	DD	imagerel logdump+1951
	DD	imagerel $unwind$logdump
$pdata$put_bufpool DD imagerel put_bufpool
	DD	imagerel put_bufpool+77
	DD	imagerel $unwind$put_bufpool
$pdata$get_bufpool DD imagerel get_bufpool
	DD	imagerel get_bufpool+66
	DD	imagerel $unwind$get_bufpool
$pdata$init_bufpool DD imagerel init_bufpool
	DD	imagerel init_bufpool+182
	DD	imagerel $unwind$init_bufpool
$pdata$free_bufpool DD imagerel free_bufpool
	DD	imagerel free_bufpool+95
	DD	imagerel $unwind$free_bufpool
$pdata$commadpt_clean_device DD imagerel commadpt_clean_device
	DD	imagerel commadpt_clean_device+368
	DD	imagerel $unwind$commadpt_clean_device
$pdata$commadpt_alloc_device DD imagerel commadpt_alloc_device
	DD	imagerel commadpt_alloc_device+394
	DD	imagerel $unwind$commadpt_alloc_device
$pdata$commadpt_getport DD imagerel commadpt_getport
	DD	imagerel commadpt_getport+91
	DD	imagerel $unwind$commadpt_getport
$pdata$commadpt_getaddr DD imagerel commadpt_getaddr
	DD	imagerel commadpt_getaddr+83
	DD	imagerel $unwind$commadpt_getaddr
$pdata$connect_message DD imagerel connect_message
	DD	imagerel connect_message+593
	DD	imagerel $unwind$connect_message
$pdata$commadpt_read_tty DD imagerel commadpt_read_tty
	DD	imagerel commadpt_read_tty+1882
	DD	imagerel $unwind$commadpt_read_tty
$pdata$telnet_thread DD imagerel telnet_thread
	DD	imagerel telnet_thread+1409
	DD	imagerel $unwind$telnet_thread
$pdata$commadpt_thread DD imagerel commadpt_thread
	DD	imagerel commadpt_thread+892
	DD	imagerel $unwind$commadpt_thread
$pdata$msg013e DD imagerel msg013e
	DD	imagerel msg013e+213
	DD	imagerel $unwind$msg013e
$pdata$commadpt_init_handler DD imagerel commadpt_init_handler
	DD	imagerel commadpt_init_handler+4560
	DD	imagerel $unwind$commadpt_init_handler
$pdata$commadpt_query_device DD imagerel commadpt_query_device
	DD	imagerel commadpt_query_device+401
	DD	imagerel $unwind$commadpt_query_device
$pdata$commadpt_close_device DD imagerel commadpt_close_device
	DD	imagerel commadpt_close_device+505
	DD	imagerel $unwind$commadpt_close_device
$pdata$make_seq DD imagerel $LN6
	DD	imagerel $LN6+264
	DD	imagerel $unwind$make_seq
$pdata$format_sna DD imagerel format_sna
	DD	imagerel format_sna+2337
	DD	imagerel $unwind$format_sna
$pdata$make_sna_requests DD imagerel $LN5
	DD	imagerel $LN5+936
	DD	imagerel $unwind$make_sna_requests
$pdata$make_sna_response DD imagerel $LN29
	DD	imagerel $LN29+2937
	DD	imagerel $unwind$make_sna_response
$pdata$th_remap DD imagerel th_remap
	DD	imagerel th_remap+999
	DD	imagerel $unwind$th_remap
$pdata$commadpt_execute_ccw DD imagerel commadpt_execute_ccw
	DD	imagerel commadpt_execute_ccw+2031
	DD	imagerel $unwind$commadpt_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
	ORG $+3
R010201	DB	01H
	DB	02H
	DB	01H
	ORG $+1
R010202	DB	01H
	DB	02H
	DB	02H
	ORG $+1
R010203	DB	01H
	DB	02H
	DB	03H
	ORG $+1
R010204	DB	01H
	DB	02H
	DB	04H
	ORG $+1
R010205	DB	01H
	DB	02H
	DB	05H
	ORG $+1
R01020A	DB	01H
	DB	02H
	DB	0aH
	ORG $+1
R01020B	DB	01H
	DB	02H
	DB	0bH
	ORG $+1
R01020F	DB	01H
	DB	02H
	DB	0fH
	ORG $+1
R010211	DB	01H
	DB	02H
	DB	011H
	ORG $+1
R010216	DB	01H
	DB	02H
	DB	016H
	ORG $+1
R010217	DB	01H
	DB	02H
	DB	017H
	ORG $+1
R010219	DB	01H
	DB	02H
	DB	019H
	ORG $+1
R01021A	DB	01H
	DB	02H
	DB	01aH
	ORG $+1
R01021B	DB	01H
	DB	02H
	DB	01bH
	ORG $+1
R010280	DB	01H
	DB	02H
	DB	080H
	ORG $+1
R010281	DB	01H
	DB	02H
	DB	081H
	ORG $+1
R010284	DB	01H
	DB	02H
	DB	084H
	ORG $+1
$SG168311 DB	'send()', 00H
	ORG $+1
ptab	DQ	FLAT:$SG168212
	DQ	FLAT:$SG168213
	DQ	FLAT:$SG168214
	DQ	FLAT:$SG168215
	DQ	FLAT:$SG168216
	DQ	FLAT:$SG168217
	DQ	FLAT:$SG168218
	DQ	FLAT:$SG168219
	DQ	FLAT:$SG168220
	DQ	FLAT:$SG168221
	DQ	FLAT:$SG168222
	DQ	FLAT:$SG168223
	DQ	FLAT:$SG168224
	DQ	FLAT:$SG168225
	DQ	FLAT:$SG168226
	DQ	FLAT:$SG168227
	DQ	FLAT:$SG168228
	DQ	FLAT:$SG168229
	DQ	FLAT:$SG168230
	DQ	FLAT:$SG168231
	DQ	FLAT:$SG168232
	DQ	FLAT:$SG168233
	DQ	FLAT:$SG168234
	DQ	FLAT:$SG168235
	DQ	FLAT:$SG168236
	DQ	FLAT:$SG168237
	DQ	FLAT:$SG168238
	DQ	FLAT:$SG168239
	DQ	FLAT:$SG168240
	DQ	FLAT:$SG168241
	DQ	FLAT:$SG168242
	DQ	FLAT:$SG168243
	DQ	FLAT:$SG168244
	DQ	FLAT:$SG168245
	DQ	FLAT:$SG168246
	DQ	FLAT:$SG168247
	DQ	FLAT:$SG168248
	DQ	FLAT:$SG168249
	DQ	FLAT:$SG168250
	DQ	FLAT:$SG168251
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG168312 DB	'E', 00H
	ORG $+2
$SG168334 DB	'recv()', 00H
	ORG $+1
$SG168335 DB	'E', 00H
	ORG $+2
$SG168313 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+1
?do_term@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::do_term
	DB	0fdH
	DB	018H
	ORG $+1
$SG168314 DB	'send_packet', 00H
?will_term@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::will_term
	DB	0fbH
	DB	018H
	ORG $+1
$SG168315 DB	'comm3705.c', 00H
	ORG $+1
?type_is@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::type_is
	DB	0faH
	DB	018H
	DB	00H
$SG168336 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+1
?wont_echo@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::wont_echo
	DB	0fcH
	DB	01H
	ORG $+1
$SG168337 DB	'recv_packet', 00H
?dont_echo@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::dont_echo
	DB	0feH
	DB	01H
	ORG $+1
$SG168338 DB	'comm3705.c', 00H
	ORG $+1
?do_bin@?1??expect@@9@9 DB 0ffH				; `expect'::`2'::do_bin
	DB	0fdH
	DB	00H
	DB	0ffH
	DB	0fbH
	DB	00H
	ORG $+2
?will_bin@?1??expect@@9@9 DB 0ffH			; `expect'::`2'::will_bin
	DB	0fbH
	DB	00H
	DB	0ffH
	DB	0fdH
	DB	00H
	ORG $+2
?req_type@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::req_type
	DB	0faH
	DB	018H
	DB	01H
	DB	0ffH
	DB	0f0H
	ORG $+2
?do_eor@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::do_eor
	DB	0fdH
	DB	019H
	DB	0ffH
	DB	0fbH
	DB	019H
	ORG $+2
?will_eor@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::will_eor
	DB	0fbH
	DB	019H
	DB	0ffH
	DB	0fdH
	DB	019H
	ORG $+2
?do_bin@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::do_bin
	DB	0fdH
	DB	00H
	DB	0ffH
	DB	0fbH
	DB	00H
	ORG $+2
?will_bin@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::will_bin
	DB	0fbH
	DB	00H
	DB	0ffH
	DB	0fdH
	DB	00H
	ORG $+2
?will_naws@?1??negotiate@@9@9 DB 0ffH			; `negotiate'::`2'::will_naws
	DB	0fbH
	DB	01fH
	ORG $+1
$SG168415 DB	'IAC DO TERMINAL_TYPE', 00H
	ORG $+3
$SG168417 DB	'IAC WILL TERMINAL_TYPE', 00H
	ORG $+1
$SG168419 DB	'IAC SB TERMINAL_TYPE SEND IAC SE', 00H
	ORG $+3
$SG168430 DB	'@%hx%c', 00H
	ORG $+1
$SG168432 DB	'IBM-', 00H
	ORG $+3
$SG168434 DB	'ANSI', 00H
	ORG $+3
$SG168455 DB	'328', 00H
$SG168435 DB	'IAC WONT ECHO', 00H
	ORG $+2
$SG168437 DB	'IAC DONT ECHO', 00H
	ORG $+2
$SG168441 DB	'DYNAMIC', 00H
$SG168443 DB	'3277', 00H
	ORG $+3
$SG168444 DB	'3270', 00H
	ORG $+3
$SG168445 DB	'3178', 00H
	ORG $+3
$SG168446 DB	'3278', 00H
	ORG $+3
$SG168447 DB	'3179', 00H
	ORG $+3
$SG168448 DB	'3180', 00H
	ORG $+3
$SG168449 DB	'3287', 00H
	ORG $+3
$SG168450 DB	'3279', 00H
	ORG $+3
$SG168457 DB	'-E', 00H
	ORG $+1
$SG168519 DB	'UP', 00H
	ORG $+1
$SG168458 DB	'IAC DO EOR IAC WILL EOR', 00H
$SG168460 DB	'IAC WILL EOR IAC DO EOR', 00H
$SG168462 DB	'IAC DO BINARY IAC WILL BINARY', 00H
	ORG $+2
$SG168464 DB	'IAC WILL BINARY IAC DO BINARY', 00H
	ORG $+2
$SG168468 DB	'3287', 00H
	ORG $+3
$SG168518 DB	'MP=%d', 00H
	ORG $+2
$SG168520 DB	'running on %s (%s-%s.%s %s %s)', 00H
	ORG $+1
$SG168521 DB	'19:16:35', 00H
	ORG $+3
$SG168526 DB	'I', 00H
	ORG $+2
$SG168522 DB	'Feb  6 2023', 00H
$SG168585 DB	'D', 00H
	ORG $+2
$SG168523 DB	'4.6.0.10893-SDL-DEV-g5b56a850-modified', 00H
	ORG $+1
$SG168524 DB	'Hercules version %s built on %s %s', 00H
	ORG $+1
$SG168589 DB	'D', 00H
	ORG $+2
$SG168525 DB	'Connected to device %4.4X', 00H
	ORG $+2
$SG168595 DB	'D', 00H
	ORG $+2
$SG168527 DB	'HHC01018%s %1d:%04X COMM: client %s devtype %4.4X: conne'
	DB	'cted', 0aH, 00H
	ORG $+2
$SG168528 DB	'connect_client', 00H
	ORG $+1
$SG168529 DB	'comm3705.c', 00H
	ORG $+1
$SG168601 DB	' ', 00H
	ORG $+2
$SG168532 DB	0f5H, '@', 011H, '@@', 01dH, '`%s', 011H, 0c1H, 'P', 01dH
	DB	'`%s', 011H, 0c2H, '`', 01dH, '`%s', 00H
$SG168536 DB	'connect_client', 00H
	ORG $+1
$SG168537 DB	'comm3705.c', 00H
	ORG $+5
$SG168538 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168540 DB	'connect_client', 00H
	ORG $+1
$SG168541 DB	'comm3705.c', 00H
	ORG $+5
$SG168547 DB	'connect_client', 00H
	ORG $+1
$SG168557 DB	'CONNECTION RESPONSE', 00H
	ORG $+4
$SG168542 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168548 DB	'comm3705.c', 00H
	ORG $+5
$SG168551 DB	'connect_client', 00H
	ORG $+1
$SG168587 DB	'logdump', 00H
$SG168549 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168552 DB	'comm3705.c', 00H
	ORG $+5
$SG168555 DB	'%s', 0dH, 0aH, '%s', 0dH, 0aH, '%s', 0dH, 0aH, 00H
	ORG $+3
$SG168586 DB	'HHC01048%s %1d:%04X COMM: %s', 0aH, 00H
	ORG $+2
$SG168591 DB	'logdump', 00H
$SG168553 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168588 DB	'comm3705.c', 00H
	ORG $+1
$SG168603 DB	'D', 00H
	ORG $+2
$SG168590 DB	'HHC01049%s %1d:%04X COMM: %s: dump of %u (0x%04x) byte(s'
	DB	')', 0aH, 00H
	ORG $+1
$SG168609 DB	'D', 00H
	ORG $+2
$SG168592 DB	'comm3705.c', 00H
	ORG $+1
$SG168613 DB	'%c', 00H
	ORG $+1
$SG168596 DB	'HHC01050%s %1d:%04X COMM: %s: %s', 0aH, 00H
	ORG $+2
$SG168614 DB	'D', 00H
	ORG $+2
$SG168597 DB	'logdump', 00H
$SG168598 DB	'comm3705.c', 00H
	ORG $+1
$SG168668 DB	'D', 00H
	ORG $+2
$SG168599 DB	': %04X:', 00H
$SG168602 DB	'%02X', 00H
	ORG $+3
$SG168604 DB	'HHC01050%s %1d:%04X COMM: %s: %s', 0aH, 00H
	ORG $+2
$SG168674 DB	'D', 00H
	ORG $+2
$SG168605 DB	'logdump', 00H
$SG168606 DB	'comm3705.c', 00H
	ORG $+1
$SG168690 DB	'E', 00H
	ORG $+2
$SG168610 DB	'HHC01051%s %1d:%04X COMM: %s', 0aH, 00H
	ORG $+2
$SG168611 DB	'logdump', 00H
$SG168612 DB	'comm3705.c', 00H
	ORG $+1
$SG168702 DB	'tcp', 00H
$SG168615 DB	'HHC01051%s %1d:%04X COMM: %s', 0aH, 00H
	ORG $+2
$SG168616 DB	'logdump', 00H
$SG168617 DB	'comm3705.c', 00H
	ORG $+1
$SG168747 DB	'I', 00H
	ORG $+2
$SG168667 DB	'control block freed', 00H
$SG168761 DB	0dH, 0aH, 00H
	ORG $+1
$SG168669 DB	'HHC01052%s %1d:%04X COMM: clean: %s', 0aH, 00H
	ORG $+3
$SG168670 DB	'commadpt_clean_device', 00H
	ORG $+2
$SG168671 DB	'comm3705.c', 00H
	ORG $+1
$SG168793 DB	'D', 00H
	ORG $+2
$SG168673 DB	'control block not freed: not allocated', 00H
	ORG $+1
$SG168675 DB	'HHC01052%s %1d:%04X COMM: clean: %s', 0aH, 00H
	ORG $+3
$SG168676 DB	'commadpt_clean_device', 00H
	ORG $+2
$SG168677 DB	'comm3705.c', 00H
	ORG $+1
$SG168799 DB	'D', 00H
	ORG $+2
$SG168689 DB	'malloc(%d)', 00H
	ORG $+1
$SG168805 DB	'D', 00H
	ORG $+2
$SG168691 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
$SG168825 DB	'D', 00H
	ORG $+2
$SG168692 DB	'commadpt_alloc_device', 00H
	ORG $+2
$SG168693 DB	'comm3705.c', 00H
	ORG $+1
$SG168857 DB	'E', 00H
	ORG $+2
$SG168745 DB	'%s:%d VTAM CONNECTION ACCEPTED - NETWORK NODE= %4.4X', 00H
	ORG $+3
$SG168746 DB	'%s:%d VTAM CONNECTION TERMINATED', 00H
	ORG $+3
$SG168863 DB	'bind()', 00H
	ORG $+1
$SG168864 DB	'E', 00H
	ORG $+2
$SG168748 DB	'HHC01047%s COMM: connect message sent: %s', 0aH, 00H
	ORG $+1
$SG168870 DB	'E', 00H
	ORG $+2
$SG168749 DB	'connect_message', 00H
$SG168750 DB	'comm3705.c', 00H
	ORG $+1
$SG168874 DB	'I', 00H
	ORG $+2
$SG168752 DB	'connect_message', 00H
$SG168753 DB	'comm3705.c', 00H
	ORG $+5
$SG168754 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168756 DB	'connect_message', 00H
$SG168757 DB	'comm3705.c', 00H
	ORG $+5
$SG168762 DB	'connect_message', 00H
$SG168788 DB	'RECV', 00H
	ORG $+3
$SG168758 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168763 DB	'comm3705.c', 00H
	ORG $+5
$SG168766 DB	'connect_message', 00H
$SG168795 DB	'commadpt_read_tty', 00H
	ORG $+6
$SG168764 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168767 DB	'comm3705.c', 00H
	ORG $+5
$SG168801 DB	'commadpt_read_tty', 00H
	ORG $+6
$SG168768 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168806 DB	'HHC01055%s %1d:%04X COMM: received telnet IAC 0x%02x', 0aH
	DB	00H
	ORG $+2
$SG168794 DB	'HHC01053%s %1d:%04X COMM: received telnet command 0x%02x'
	DB	' 0x%02x', 0aH, 00H
	ORG $+3
$SG168906 DB	'I', 00H
	ORG $+2
$SG168796 DB	'comm3705.c', 00H
	ORG $+5
$SG168807 DB	'commadpt_read_tty', 00H
	ORG $+6
$SG168800 DB	'HHC01054%s %1d:%04X COMM: sending telnet command 0x%02x '
	DB	'0x%02x', 0aH, 00H
$SG168802 DB	'comm3705.c', 00H
	ORG $+1
$SG168916 DB	'D', 00H
	ORG $+2
$SG168808 DB	'comm3705.c', 00H
	ORG $+1
$SG168921 DB	'I', 00H
	ORG $+2
$SG168826 DB	'HHC01056%s %1d:%04X COMM: posted %d input bytes', 0aH, 00H
	ORG $+3
$SG168939 DB	'E', 00H
	ORG $+2
$SG168827 DB	'commadpt_read_tty', 00H
	ORG $+2
$SG168986 DB	'D', 00H
	ORG $+2
$SG168828 DB	'comm3705.c', 00H
	ORG $+5
$SG168858 DB	'HHC01002%s %1d:%04X COMM: cannot obtain socket for incom'
	DB	'ing calls: %s', 0aH, 00H
	ORG $+1
$SG168859 DB	'telnet_thread', 00H
	ORG $+2
$SG168860 DB	'comm3705.c', 00H
	ORG $+1
$SG168992 DB	'I', 00H
	ORG $+2
$SG168861 DB	'comm3705.c:1115', 00H
$SG168865 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
$SG168997 DB	'D', 00H
	ORG $+2
$SG168866 DB	'telnet_thread', 00H
	ORG $+2
$SG168867 DB	'comm3705.c', 00H
	ORG $+1
$SG169004 DB	'E', 00H
	ORG $+2
$SG168869 DB	'listen()', 00H
	ORG $+3
$SG169009 DB	'E', 00H
	ORG $+2
$SG168871 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
$SG169022 DB	'*', 00H
	ORG $+2
$SG168872 DB	'telnet_thread', 00H
	ORG $+2
$SG168873 DB	'comm3705.c', 00H
	ORG $+5
$SG168876 DB	'telnet_thread', 00H
	ORG $+2
$SG168903 DB	'comm3705.c:1215', 00H
$SG168907 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG168875 DB	'HHC01004%s %1d:%04X COMM: listening on port %d for incom'
	DB	'ing TCP connections', 0aH, 00H
	ORG $+3
$SG168877 DB	'comm3705.c', 00H
	ORG $+1
$SG169028 DB	'yes', 00H
$SG168904 DB	'3705 device(%1d:%04X) thread', 00H
	ORG $+3
$SG168905 DB	'comm3705.c:1221', 00H
$SG168908 DB	'commadpt_thread', 00H
$SG168909 DB	'comm3705.c', 00H
	ORG $+1
$SG169029 DB	'1', 00H
	ORG $+2
$SG168910 DB	'comm3705.c:1224', 00H
$SG168913 DB	'comm3705.c:1228', 00H
$SG168917 DB	'HHC01057%s %1d:%04X COMM: raised attention, return code '
	DB	'%d', 0aH, 00H
$SG169034 DB	' ', 00H
	ORG $+2
$SG168918 DB	'commadpt_thread', 00H
$SG168919 DB	'comm3705.c', 00H
	ORG $+1
$SG169037 DB	' ', 00H
	ORG $+2
$SG168920 DB	'comm3705.c:1245', 00H
$SG168922 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG168923 DB	'commadpt_thread', 00H
$SG168924 DB	'comm3705.c', 00H
	ORG $+1
$SG169039 DB	'%3x', 00H
$SG168925 DB	'comm3705.c:1246', 00H
$SG168940 DB	'HHC01007%s %1d:%04X COMM: option %s value %s invalid', 0aH
	DB	00H
	ORG $+2
$SG168941 DB	'msg013e', 00H
$SG168942 DB	'comm3705.c', 00H
	ORG $+1
$SG169041 DB	'%5x', 00H
$SG168987 DB	'HHC01058%s %1d:%04X COMM: initialization starting', 0aH, 00H
	ORG $+1
$SG169046 DB	'I', 00H
	ORG $+2
$SG168988 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG168989 DB	'comm3705.c', 00H
	ORG $+1
$SG169067 DB	'E', 00H
	ORG $+2
$SG168993 DB	'HHC01011%s %1d:%04X COMM: initialization not performed', 0aH
	DB	00H
$SG168994 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG168995 DB	'comm3705.c', 00H
	ORG $+5
$SG168999 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG168998 DB	'HHC01059%s %1d:%04X COMM: initialization: control block '
	DB	'allocated', 0aH, 00H
	ORG $+1
$SG169075 DB	'E', 00H
	ORG $+2
$SG169000 DB	'comm3705.c', 00H
	ORG $+1
$SG169100 DB	'.', 00H
	ORG $+2
$SG169001 DB	'MHP3705 ', 00H
	ORG $+3
$SG169019 DB	'LPORT', 00H
	ORG $+2
$SG169107 DB	'D', 00H
	ORG $+2
$SG169002 DB	'MHPRMT1 ', 00H
	ORG $+3
$SG169024 DB	'LHOST', 00H
	ORG $+2
$SG169115 DB	'D', 00H
	ORG $+2
$SG169005 DB	'HHC01012%s %1d:%04X COMM: error parsing %s', 0aH, 00H
$SG169166 DB	'SDT', 00H
$SG169006 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169007 DB	'comm3705.c', 00H
	ORG $+1
$SG169199 DB	'FNA', 00H
$SG169010 DB	'HHC01019%s %1d:%04X COMM: unrecognized parameter %s', 0aH
	DB	00H
	ORG $+3
$SG169011 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169012 DB	'comm3705.c', 00H
	ORG $+1
$SG169203 DB	'ANA', 00H
$SG169033 DB	'        ', 00H
	ORG $+3
$SG169158 DB	'ACTPU', 00H
	ORG $+2
$SG169162 DB	'DACTLU', 00H
	ORG $+1
$SG169210 DB	'D', 00H
	ORG $+2
$SG169036 DB	'        ', 00H
	ORG $+7
$SG169047 DB	'HHC01014%s %1d:%04X COMM: initialization failed due to p'
	DB	'revious errors', 0aH, 00H
$SG169048 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169049 DB	'comm3705.c', 00H
	ORG $+1
$SG169231 DB	'E', 00H
	ORG $+2
$SG169050 DB	'comm3705.c:1430', 00H
$SG169051 DB	'&dev->commadpt->lock', 00H
	ORG $+3
$SG169052 DB	'comm3705.c:1433', 00H
$SG169053 DB	'comm3705.c:1434', 00H
$SG169055 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169056 DB	'comm3705.c', 00H
	ORG $+5
$SG169057 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169059 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169060 DB	'comm3705.c', 00H
	ORG $+5
$SG169061 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169063 DB	'comm3705.c:1440', 00H
$SG169064 DB	'commadpt %1d:%04X thread2', 00H
	ORG $+2
$SG169164 DB	'DACTPU', 00H
	ORG $+1
$SG169257 DB	'E', 00H
	ORG $+2
$SG169065 DB	'comm3705.c:1449', 00H
$SG169068 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169170 DB	'UNBIND', 00H
	ORG $+1
$SG169278 DB	'E', 00H
	ORG $+2
$SG169069 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169070 DB	'comm3705.c', 00H
	ORG $+1
$SG169298 DB	'E', 00H
	ORG $+2
$SG169071 DB	'comm3705.c:1453', 00H
$SG169072 DB	'commadpt %1d:%04X thread', 00H
	ORG $+3
$SG169160 DB	'ACTLU', 00H
	ORG $+2
$SG169201 DB	'ABCONN', 00H
	ORG $+1
$SG169318 DB	'E', 00H
	ORG $+2
$SG169073 DB	'comm3705.c:1464', 00H
$SG169076 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169354 DB	'E', 00H
	ORG $+2
$SG169077 DB	'commadpt_init_handler', 00H
	ORG $+2
$SG169078 DB	'comm3705.c', 00H
	ORG $+1
$SG169437 DB	'D', 00H
	ORG $+2
$SG169079 DB	'comm3705.c:1468', 00H
$SG169080 DB	'comm3705.c:1474', 00H
$SG169094 DB	'LINE', 00H
	ORG $+3
$SG169101 DB	'Read count=%d, Write count=%d IO[%llu]', 00H
	ORG $+1
$SG169108 DB	'HHC01060%s %1d:%04X COMM: closing down', 0aH, 00H
$SG169109 DB	'commadpt_close_device', 00H
	ORG $+2
$SG169110 DB	'comm3705.c', 00H
	ORG $+1
$SG169448 DB	'RD', 00H
	ORG $+1
$SG169111 DB	'comm3705.c:1505', 00H
$SG169113 DB	'comm3705.c:1513', 00H
$SG169116 DB	'HHC01061%s %1d:%04X COMM: closed down', 0aH, 00H
	ORG $+1
$SG169117 DB	'commadpt_close_device', 00H
	ORG $+2
$SG169118 DB	'comm3705.c', 00H
	ORG $+1
$SG169457 DB	'WR', 00H
	ORG $+1
$SG169150 DB	'%02X%02X %02X%02X %02X%02X %02X%02X %02X%02X', 00H
	ORG $+3
$SG169151 DB	'%02X%02X%02X', 00H
	ORG $+3
$SG169152 DB	'%02X', 00H
	ORG $+3
$SG169153 DB	'%02X', 00H
	ORG $+3
$SG169155 DB	'%02X', 00H
	ORG $+3
$SG169168 DB	'BIND', 00H
	ORG $+3
$SG169172 DB	'CONTACT', 00H
$SG169174 DB	'DISCONTACT', 00H
	ORG $+5
$SG169176 DB	'IPLINIT', 00H
$SG169178 DB	'IPLTEXT', 00H
$SG169180 DB	'IPLFINAL', 00H
	ORG $+7
$SG169182 DB	'ACTLINK', 00H
$SG169184 DB	'DACTLINK', 00H
	ORG $+3
$SG169186 DB	'SETCV', 00H
	ORG $+6
$SG169187 DB	'%s[%02x]', 00H
	ORG $+3
$SG169189 DB	'SETCV', 00H
	ORG $+6
$SG169191 DB	'CONTACTED', 00H
	ORG $+2
$SG169193 DB	'INOP', 00H
	ORG $+7
$SG169195 DB	'REQCONT', 00H
$SG169197 DB	'REQDISCONT', 00H
	ORG $+5
$SG169205 DB	'ACTCONNIN', 00H
	ORG $+6
$SG169207 DB	'DACTCONNIN', 00H
	ORG $+5
$SG169211 DB	'HHC01062%s %1d:%04X COMM: %s: %s %s %-6.6s %s', 0aH, 00H
	ORG $+1
$SG169212 DB	'format_sna', 00H
	ORG $+5
$SG169213 DB	'comm3705.c', 00H
	ORG $+5
$SG169230 DB	'SNA request2', 00H
	ORG $+3
$SG169232 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169233 DB	'make_sna_requests2', 00H
	ORG $+5
$SG169234 DB	'comm3705.c', 00H
	ORG $+5
$SG169256 DB	'SNA request3', 00H
	ORG $+3
$SG169258 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169259 DB	'make_sna_requests3', 00H
	ORG $+5
$SG169260 DB	'comm3705.c', 00H
	ORG $+5
$SG169277 DB	'SNA request4', 00H
	ORG $+3
$SG169279 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169280 DB	'make_sna_requests4', 00H
	ORG $+5
$SG169281 DB	'comm3705.c', 00H
	ORG $+5
$SG169297 DB	'SNA request5', 00H
	ORG $+3
$SG169299 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169300 DB	'make_sna_requests5', 00H
	ORG $+5
$SG169301 DB	'comm3705.c', 00H
	ORG $+5
$SG169317 DB	'SNA request', 00H
	ORG $+4
$SG169319 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169320 DB	'make_sna_requests', 00H
	ORG $+6
$SG169321 DB	'comm3705.c', 00H
	ORG $+1
$SG169348 DB	'SEND', 00H
	ORG $+3
$SG169350 DB	'SEND', 00H
	ORG $+7
$SG169353 DB	'SNA response', 00H
	ORG $+3
$SG169355 DB	'HHC01020%s %1d:%04X COMM: no buffers trying to send %s', 0aH
	DB	00H
$SG169356 DB	'make_sna_response', 00H
	ORG $+6
$SG169357 DB	'comm3705.c', 00H
	ORG $+5
$SG169438 DB	'HHC01063%s %1d:%04X COMM: CCW exec - entry code %x', 0aH
	DB	00H
	ORG $+4
$SG169439 DB	'commadpt_execute_ccw', 00H
	ORG $+3
$SG169440 DB	'comm3705.c', 00H
	ORG $+5
$SG169441 DB	'comm3705.c:2124', 00H
$SG169446 DB	'READ', 00H
	ORG $+3
$SG169450 DB	'WRITE BLOCK', 00H
$SG169453 DB	'WRITE', 00H
	ORG $+6
$SG169465 DB	'comm3705.c:2222', 00H
$SG169507 DB	'DEVBLK', 00H
	ORG $+1
com3705_device_hndinfo DQ FLAT:commadpt_init_handler
	DQ	FLAT:commadpt_execute_ccw
	DQ	FLAT:commadpt_close_device
	DQ	FLAT:commadpt_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:commadpt_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:commadpt_immed_command
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG169503 DB	'SDL 4.60', 00H
	ORG $+7
$SG169504 DB	'HERCULES', 00H
	ORG $+7
$SG169506 DB	'SDL 4.00', 00H
	ORG $+7
$SG169509 DB	'SDL 4.2', 00H
$SG169510 DB	'SYSBLK', 00H
	ORG $+1
$SG169515 DB	'3705', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:make_sna_response
	DD	023H
	DD	0b5fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:format_sna
	DD	02bH
	DD	0905H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:commadpt_query_device
	DD	025H
	DD	0179H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:commadpt_init_handler
	DD	020H
	DD	01164H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:commadpt_thread
	DD	016H
	DD	0364H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:telnet_thread
	DD	016H
	DD	0569H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:connect_message
	DD	01eH
	DD	0239H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:commadpt_alloc_device
	DD	017H
	DD	0171H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:logdump
	DD	025H
	DD	0787H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:connect_client
	DD	016H
	DD	04c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:negotiate
	DD	024H
	DD	06c2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:expect
	DD	024H
	DD	0e5H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$make_sna_requests2 DD 040e01H
	DD	013010eH
	DD	060067007H
$unwind$make_sna_requests3 DD 020c01H
	DD	011010cH
$unwind$make_sna_requests4 DD 021501H
	DD	0110115H
$unwind$make_sna_requests5 DD 020c01H
	DD	011010cH
$unwind$double_up_iac DD 010d01H
	DD	0220dH
$unwind$send_packet DD 011701H
	DD	0c217H
$unwind$recv_packet DD 011701H
	DD	0e217H
$unwind$expect DD 022c19H
	DD	049011aH
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$negotiate DD 022c19H
	DD	04d011aH
	DD	imagerel __GSHandlerCheck
	DD	0250H
$unwind$connect_client DD 021e19H
	DD	081010cH
	DD	imagerel __GSHandlerCheck
	DD	03f0H
$unwind$logdump DD 022d19H
	DD	02d011bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$put_bufpool DD 010e01H
	DD	0220eH
$unwind$get_bufpool DD 010901H
	DD	02209H
$unwind$init_bufpool DD 010901H
	DD	08209H
$unwind$free_bufpool DD 010901H
	DD	04209H
$unwind$commadpt_clean_device DD 010901H
	DD	0c209H
$unwind$commadpt_alloc_device DD 031f19H
	DD	014010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$commadpt_getport DD 010901H
	DD	06209H
$unwind$commadpt_getaddr DD 010e01H
	DD	0620eH
$unwind$connect_message DD 022619H
	DD	02f0114H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$commadpt_read_tty DD 021601H
	DD	0170116H
$unwind$telnet_thread DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$commadpt_thread DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$msg013e DD 011301H
	DD	0e213H
$unwind$commadpt_init_handler DD 032819H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$commadpt_query_device DD 022d19H
	DD	02d011bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$commadpt_close_device DD 010901H
	DD	0c209H
$unwind$make_seq DD 010e01H
	DD	0220eH
$unwind$format_sna DD 063319H
	DD	0270121H
	DD	06019701aH
	DD	030175018H
	DD	imagerel __GSHandlerCheck
	DD	0128H
$unwind$make_sna_requests DD 021101H
	DD	0110111H
$unwind$make_sna_response DD 042b19H
	DD	022130119H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	011080H
$unwind$th_remap DD 011301H
	DD	04213H
$unwind$commadpt_execute_ccw DD 041c01H
	DD	013011cH
	DD	060147015H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 2291 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2292 : {
; 2293 :     HDL_DEVICE(3705, com3705_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:com3705_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169515
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 2294 : }
; 2295 : END_DEVICE_SECTION;

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 2272 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 2273 : {
; 2274 :     HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169503
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169504
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 2275 :     HDL_DEPENDENCY(DEVBLK);

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169506
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169507
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 2276 :     HDL_DEPENDENCY(SYSBLK);

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169509
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169510
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 2277 : }
; 2278 : END_DEPENDENCY_SECTION;

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
piusize$ = 80
tv131 = 84
tv77 = 88
tv83 = 92
tv137 = 96
tv140 = 100
num$ = 104
llsize$ = 108
piudata$ = 112
tv72 = 120
eleptr$ = 128
dev$ = 176
code$ = 184
flags$ = 192
chained$ = 200
count$ = 208
prevcode$ = 216
ccwseq$ = 224
iobuf$ = 232
more$ = 240
unitstat$ = 248
residual$ = 256
commadpt_execute_ccw PROC

; 2102 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
$LN4@commadpt_e:

; 2103 : U32 num;                        /* Work : Actual CCW transfer count                   */
; 2104 : BYTE    *piudata;
; 2105 : int     piusize;
; 2106 : void    *eleptr;
; 2107 : int     llsize;
; 2108 : 
; 2109 :     UNREFERENCED(flags);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@commadpt_e
$LN7@commadpt_e:

; 2110 :     UNREFERENCED(chained);

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN7@commadpt_e
$LN10@commadpt_e:

; 2111 :     UNREFERENCED(prevcode);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN10@commadpt_e
$LN13@commadpt_e:

; 2112 :     UNREFERENCED(ccwseq);

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN13@commadpt_e

; 2113 : 
; 2114 :     *residual = 0;

  00034	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2115 : 
; 2116 :     /*
; 2117 :      * Obtain the COMMADPT lock
; 2118 :      */
; 2119 :     if(dev->ccwtrace)

  00042	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00050	c1 e8 0f	 shr	 eax, 15
  00053	83 e0 01	 and	 eax, 1
  00056	85 c0		 test	 eax, eax
  00058	0f 84 b7 00 00
	00		 je	 $LN16@commadpt_e

; 2120 :     {
; 2121 :         WRMSG(HHC01063,"D",

  0005e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00067	74 12		 je	 SHORT $LN36@commadpt_e
  00069	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00071	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00075	89 44 24 58	 mov	 DWORD PTR tv77[rsp], eax
  00079	eb 08		 jmp	 SHORT $LN37@commadpt_e
$LN36@commadpt_e:
  0007b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN37@commadpt_e:
  00083	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0008c	74 14		 je	 SHORT $LN38@commadpt_e
  0008e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00096	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0009a	d1 f8		 sar	 eax, 1
  0009c	89 44 24 5c	 mov	 DWORD PTR tv83[rsp], eax
  000a0	eb 08		 jmp	 SHORT $LN39@commadpt_e
$LN38@commadpt_e:
  000a2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN39@commadpt_e:
  000aa	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000b2	89 44 24 78	 mov	 DWORD PTR tv72[rsp], eax
  000b6	b9 01 00 00 00	 mov	 ecx, 1
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c1	8b 4c 24 78	 mov	 ecx, DWORD PTR tv72[rsp]
  000c5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000c9	8b 4c 24 58	 mov	 ecx, DWORD PTR tv77[rsp]
  000cd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000d1	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv83[rsp]
  000d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169437
  000e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169438
  000ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169439
  00103	ba 4a 08 00 00	 mov	 edx, 2122		; 0000084aH
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169440
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@commadpt_e:

; 2122 :             LCSS_DEVNUM,code);
; 2123 :     }
; 2124 :     obtain_lock(&dev->commadpt->lock);

  00115	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011d	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00124	48 83 c0 30	 add	 rax, 48			; 00000030H
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169441
  0012f	48 8b c8	 mov	 rcx, rax
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2125 :     switch (code) {

  00138	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00140	89 44 24 54	 mov	 DWORD PTR tv131[rsp], eax
  00144	8b 44 24 54	 mov	 eax, DWORD PTR tv131[rsp]
  00148	ff c8		 dec	 eax
  0014a	89 44 24 54	 mov	 DWORD PTR tv131[rsp], eax
  0014e	81 7c 24 54 92
	00 00 00	 cmp	 DWORD PTR tv131[rsp], 146 ; 00000092H
  00156	0f 87 7e 05 00
	00		 ja	 $LN34@commadpt_e
  0015c	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv131[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00168	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN44@commadpt_e[rcx+rax]
  00170	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@commadpt_e[rcx+rax*4]
  00177	48 03 c1	 add	 rax, rcx
  0017a	ff e0		 jmp	 rax
$LN17@commadpt_e:

; 2126 :         /*---------------------------------------------------------------*/
; 2127 :         /* BASIC SENSE                                                   */
; 2128 :         /*---------------------------------------------------------------*/
; 2129 :         case 0x04:
; 2130 :             dev->commadpt->unack_attn_count = 0;

  0017c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00184	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0018b	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [rax+116], 0

; 2131 :             num=count<dev->numsense?count:dev->numsense;

  00192	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019a	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  001a0	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  001a7	73 0d		 jae	 SHORT $LN40@commadpt_e
  001a9	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  001b0	89 44 24 60	 mov	 DWORD PTR tv137[rsp], eax
  001b4	eb 12		 jmp	 SHORT $LN41@commadpt_e
$LN40@commadpt_e:
  001b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001be	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  001c4	89 44 24 60	 mov	 DWORD PTR tv137[rsp], eax
$LN41@commadpt_e:
  001c8	8b 44 24 60	 mov	 eax, DWORD PTR tv137[rsp]
  001cc	89 44 24 68	 mov	 DWORD PTR num$[rsp], eax

; 2132 :             *more=count<dev->numsense?1:0;

  001d0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d8	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  001de	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  001e5	73 0a		 jae	 SHORT $LN42@commadpt_e
  001e7	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN43@commadpt_e
$LN42@commadpt_e:
  001f1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN43@commadpt_e:
  001f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00201	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv140[rsp]
  00206	88 08		 mov	 BYTE PTR [rax], cl

; 2133 :             memcpy(iobuf,dev->sense,num);

  00208	8b 44 24 68	 mov	 eax, DWORD PTR num$[rsp]
  0020c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00214	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  0021b	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00223	48 8b f1	 mov	 rsi, rcx
  00226	8b c8		 mov	 ecx, eax
  00228	f3 a4		 rep movsb

; 2134 :             *residual=count-num;

  0022a	8b 44 24 68	 mov	 eax, DWORD PTR num$[rsp]
  0022e	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00235	2b c8		 sub	 ecx, eax
  00237	8b c1		 mov	 eax, ecx
  00239	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00241	89 01		 mov	 DWORD PTR [rcx], eax

; 2135 :             *unitstat=CSW_CE|CSW_DE;

  00243	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0024b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2136 :             break;

  0024e	e9 ab 04 00 00	 jmp	 $LN14@commadpt_e
$LN18@commadpt_e:

; 2137 : 
; 2138 :         /*---------------------------------------------------------------*/
; 2139 :         /* READ type CCWs                                                */
; 2140 :         /*---------------------------------------------------------------*/
; 2141 :         case 0x02:   /* READ */
; 2142 :             dev->commadpt->read_ccw_count++;

  00253	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00262	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00265	ff c0		 inc	 eax
  00267	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026f	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00276	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 2143 :             dev->commadpt->unack_attn_count = 0;

  00279	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00281	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00288	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [rax+116], 0

; 2144 :             *more = 0;

  0028f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00297	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2145 :             make_sna_requests2(dev->commadpt);

  0029a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a2	48 8b 88 68 11
	00 00		 mov	 rcx, QWORD PTR [rax+4456]
  002a9	e8 00 00 00 00	 call	 make_sna_requests2

; 2146 :             make_sna_requests3(dev->commadpt);

  002ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b6	48 8b 88 68 11
	00 00		 mov	 rcx, QWORD PTR [rax+4456]
  002bd	e8 00 00 00 00	 call	 make_sna_requests3

; 2147 :             eleptr = get_bufpool(&dev->commadpt->sendq);

  002c2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ca	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  002d1	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  002d7	48 8b c8	 mov	 rcx, rax
  002da	e8 00 00 00 00	 call	 get_bufpool
  002df	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR eleptr$[rsp], rax

; 2148 :             *residual=count;

  002e7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  002ef	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  002f6	89 08		 mov	 DWORD PTR [rax], ecx

; 2149 :             if (eleptr) {

  002f8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR eleptr$[rsp], 0
  00301	0f 84 de 01 00
	00		 je	 $LN19@commadpt_e

; 2150 :                 piudata = SIZEOF_INT_P + (BYTE*)eleptr;

  00307	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR eleptr$[rsp]
  0030f	48 83 c0 08	 add	 rax, 8
  00313	48 89 44 24 70	 mov	 QWORD PTR piudata$[rsp], rax

; 2151 :                 piusize = (piudata[8] << 8) + piudata[9];

  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	48 6b c0 08	 imul	 rax, rax, 8
  00321	48 8b 4c 24 70	 mov	 rcx, QWORD PTR piudata$[rsp]
  00326	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0032a	c1 e0 08	 shl	 eax, 8
  0032d	b9 01 00 00 00	 mov	 ecx, 1
  00332	48 6b c9 09	 imul	 rcx, rcx, 9
  00336	48 8b 54 24 70	 mov	 rdx, QWORD PTR piudata$[rsp]
  0033b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0033f	03 c1		 add	 eax, ecx
  00341	89 44 24 50	 mov	 DWORD PTR piusize$[rsp], eax

; 2152 :                 piusize += 10;    // for FID1 TH

  00345	8b 44 24 50	 mov	 eax, DWORD PTR piusize$[rsp]
  00349	83 c0 0a	 add	 eax, 10
  0034c	89 44 24 50	 mov	 DWORD PTR piusize$[rsp], eax

; 2153 :                 iobuf[0] = BUFPD;

  00350	b8 01 00 00 00	 mov	 eax, 1
  00355	48 6b c0 00	 imul	 rax, rax, 0
  00359	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00361	c6 04 01 1c	 mov	 BYTE PTR [rcx+rax], 28

; 2154 :                 memcpy (&iobuf[BUFPD], piudata, piusize);

  00365	48 63 44 24 50	 movsxd	 rax, DWORD PTR piusize$[rsp]
  0036a	b9 01 00 00 00	 mov	 ecx, 1
  0036f	48 6b c9 1c	 imul	 rcx, rcx, 28
  00373	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0037b	48 03 d1	 add	 rdx, rcx
  0037e	48 8b ca	 mov	 rcx, rdx
  00381	48 8b f9	 mov	 rdi, rcx
  00384	48 8b 74 24 70	 mov	 rsi, QWORD PTR piudata$[rsp]
  00389	48 8b c8	 mov	 rcx, rax
  0038c	f3 a4		 rep movsb

; 2155 :                 if (dev->commadpt->emu3791) {

  0038e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00396	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0039d	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  003a0	c1 e8 0a	 shr	 eax, 10
  003a3	83 e0 01	 and	 eax, 1
  003a6	85 c0		 test	 eax, eax
  003a8	74 7d		 je	 SHORT $LN20@commadpt_e

; 2156 :                     llsize = piusize + BUFPD;

  003aa	8b 44 24 50	 mov	 eax, DWORD PTR piusize$[rsp]
  003ae	83 c0 1c	 add	 eax, 28
  003b1	89 44 24 6c	 mov	 DWORD PTR llsize$[rsp], eax

; 2157 :                     iobuf[0] = (llsize >> 8) & 0xff;

  003b5	8b 44 24 6c	 mov	 eax, DWORD PTR llsize$[rsp]
  003b9	c1 f8 08	 sar	 eax, 8
  003bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c1	b9 01 00 00 00	 mov	 ecx, 1
  003c6	48 6b c9 00	 imul	 rcx, rcx, 0
  003ca	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  003d2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2158 :                     iobuf[1] = llsize & 0xff;

  003d5	8b 44 24 6c	 mov	 eax, DWORD PTR llsize$[rsp]
  003d9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003de	b9 01 00 00 00	 mov	 ecx, 1
  003e3	48 6b c9 01	 imul	 rcx, rcx, 1
  003e7	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  003ef	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2159 :                     th_remap(MAP_FID1_FID2, &iobuf[BUFPD], dev->commadpt->locsuba);

  003f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003fa	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00401	b9 01 00 00 00	 mov	 ecx, 1
  00406	48 6b c9 1c	 imul	 rcx, rcx, 28
  0040a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00412	48 03 d1	 add	 rdx, rcx
  00415	48 8b ca	 mov	 rcx, rdx
  00418	44 0f b7 40 54	 movzx	 r8d, WORD PTR [rax+84]
  0041d	48 8b d1	 mov	 rdx, rcx
  00420	33 c9		 xor	 ecx, ecx
  00422	e8 00 00 00 00	 call	 th_remap
$LN20@commadpt_e:

; 2160 :                 }
; 2161 :                 *residual=count - (piusize + BUFPD);

  00427	8b 44 24 50	 mov	 eax, DWORD PTR piusize$[rsp]
  0042b	83 c0 1c	 add	 eax, 28
  0042e	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00435	2b c8		 sub	 ecx, eax
  00437	8b c1		 mov	 eax, ecx
  00439	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00441	89 01		 mov	 DWORD PTR [rcx], eax

; 2162 :                 logdump("READ", dev, &iobuf[BUFPD], piusize);

  00443	48 63 44 24 50	 movsxd	 rax, DWORD PTR piusize$[rsp]
  00448	b9 01 00 00 00	 mov	 ecx, 1
  0044d	48 6b c9 1c	 imul	 rcx, rcx, 28
  00451	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00459	48 03 d1	 add	 rdx, rcx
  0045c	48 8b ca	 mov	 rcx, rdx
  0045f	4c 8b c8	 mov	 r9, rax
  00462	4c 8b c1	 mov	 r8, rcx
  00465	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0046d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169446
  00474	e8 00 00 00 00	 call	 logdump

; 2163 :                 if (dev->commadpt->debug_sna)

  00479	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00481	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00488	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0048b	c1 e8 09	 shr	 eax, 9
  0048e	83 e0 01	 and	 eax, 1
  00491	85 c0		 test	 eax, eax
  00493	74 2b		 je	 SHORT $LN21@commadpt_e

; 2164 :                     format_sna(piudata, "RD", dev->ssid, dev->devnum);

  00495	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0049d	44 0f b7 48 48	 movzx	 r9d, WORD PTR [rax+72]
  004a2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004aa	44 0f b7 40 44	 movzx	 r8d, WORD PTR [rax+68]
  004af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169448
  004b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR piudata$[rsp]
  004bb	e8 00 00 00 00	 call	 format_sna
$LN21@commadpt_e:

; 2165 :                 put_bufpool(&dev->commadpt->freeq, eleptr);

  004c0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c8	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  004cf	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  004d5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR eleptr$[rsp]
  004dd	48 8b c8	 mov	 rcx, rax
  004e0	e8 00 00 00 00	 call	 put_bufpool
$LN19@commadpt_e:

; 2166 :             }
; 2167 :             *unitstat  = CSW_CE | CSW_DE | CSW_UX;

  004e5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004ed	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 2168 :             break;

  004f0	e9 09 02 00 00	 jmp	 $LN14@commadpt_e
$LN22@commadpt_e:

; 2169 : 
; 2170 :         /*---------------------------------------------------------------*/
; 2171 :         /* 3791 WRITE BLOCK                                              */
; 2172 :         /*---------------------------------------------------------------*/
; 2173 :         case 0x05:
; 2174 :             logdump("WRITE BLOCK", dev, iobuf, count);

  004f5	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004fc	44 8b c8	 mov	 r9d, eax
  004ff	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  00507	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0050f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169450
  00516	e8 00 00 00 00	 call	 logdump

; 2175 :             *residual=0;

  0051b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00523	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2176 :             *unitstat=CSW_CE|CSW_DE;

  00529	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00531	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2177 :             break;

  00534	e9 c5 01 00 00	 jmp	 $LN14@commadpt_e
$LN23@commadpt_e:
$LN24@commadpt_e:

; 2178 : 
; 2179 :         /*---------------------------------------------------------------*/
; 2180 :         /* WRITE type CCWs                                               */
; 2181 :         /*---------------------------------------------------------------*/
; 2182 :         case 0x09:   /* WRITE BREAK */
; 2183 :         case 0x01:   /* WRITE */
; 2184 :             dev->commadpt->write_ccw_count++;

  00539	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00541	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00548	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0054b	ff c0		 inc	 eax
  0054d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0055c	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 2185 :             dev->commadpt->unack_attn_count = 0;

  0055f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00567	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0056e	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [rax+116], 0

; 2186 :             logdump("WRITE", dev, iobuf, count);

  00575	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0057c	44 8b c8	 mov	 r9d, eax
  0057f	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  00587	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0058f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169453
  00596	e8 00 00 00 00	 call	 logdump

; 2187 :             if (dev->commadpt->emu3791 && (iobuf[4] & 0xf0) == 0x20)

  0059b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005a3	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  005aa	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  005ad	c1 e8 0a	 shr	 eax, 10
  005b0	83 e0 01	 and	 eax, 1
  005b3	85 c0		 test	 eax, eax
  005b5	74 45		 je	 SHORT $LN25@commadpt_e
  005b7	b8 01 00 00 00	 mov	 eax, 1
  005bc	48 6b c0 04	 imul	 rax, rax, 4
  005c0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  005c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005cc	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005d1	83 f8 20	 cmp	 eax, 32			; 00000020H
  005d4	75 26		 jne	 SHORT $LN25@commadpt_e

; 2188 :                 th_remap(MAP_FID2_FID1, iobuf, dev->commadpt->locsuba);

  005d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005de	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  005e5	44 0f b7 40 54	 movzx	 r8d, WORD PTR [rax+84]
  005ea	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  005f2	b9 01 00 00 00	 mov	 ecx, 1
  005f7	e8 00 00 00 00	 call	 th_remap
$LN25@commadpt_e:

; 2189 :             if ((iobuf[0] & 0xf0) == 0x10) {  // if FID1

  005fc	b8 01 00 00 00	 mov	 eax, 1
  00601	48 6b c0 00	 imul	 rax, rax, 0
  00605	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0060d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00611	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00616	83 f8 10	 cmp	 eax, 16
  00619	0f 85 82 00 00
	00		 jne	 $LN26@commadpt_e

; 2190 :                 if (dev->commadpt->debug_sna)

  0061f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00627	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0062e	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00631	c1 e8 09	 shr	 eax, 9
  00634	83 e0 01	 and	 eax, 1
  00637	85 c0		 test	 eax, eax
  00639	74 2e		 je	 SHORT $LN27@commadpt_e

; 2191 :                     format_sna(iobuf, "WR", dev->ssid, dev->devnum);

  0063b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00643	44 0f b7 48 48	 movzx	 r9d, WORD PTR [rax+72]
  00648	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00650	44 0f b7 40 44	 movzx	 r8d, WORD PTR [rax+68]
  00655	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169457
  0065c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00664	e8 00 00 00 00	 call	 format_sna
$LN27@commadpt_e:

; 2192 :                 make_sna_response(iobuf, dev->commadpt);

  00669	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00671	48 8b 90 68 11
	00 00		 mov	 rdx, QWORD PTR [rax+4456]
  00678	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00680	e8 00 00 00 00	 call	 make_sna_response

; 2193 :                 make_sna_requests(iobuf, dev->commadpt);

  00685	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068d	48 8b 90 68 11
	00 00		 mov	 rdx, QWORD PTR [rax+4456]
  00694	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0069c	e8 00 00 00 00	 call	 make_sna_requests
$LN26@commadpt_e:

; 2194 :             }
; 2195 :             *residual = 0;

  006a1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  006a9	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2196 :             *unitstat = CSW_CE | CSW_DE;

  006af	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006b7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2197 :             break;

  006ba	eb 42		 jmp	 SHORT $LN14@commadpt_e
$LN28@commadpt_e:
$LN29@commadpt_e:
$LN30@commadpt_e:
$LN31@commadpt_e:
$LN32@commadpt_e:
$LN33@commadpt_e:

; 2198 : 
; 2199 :         /*---------------------------------------------------------------*/
; 2200 :         /* CCWs to be treated as NOPs                                    */
; 2201 :         /*---------------------------------------------------------------*/
; 2202 :         case 0x03:   /* NOP */
; 2203 :         case 0x93:   /* RESTART */
; 2204 :         case 0x31:   /* WS0 */
; 2205 :         case 0x51:   /* WS1 */
; 2206 :         case 0x32:   /* RS0 */
; 2207 :         case 0x52:   /* RS1 */
; 2208 :             *residual=count;

  006bc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  006c4	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  006cb	89 08		 mov	 DWORD PTR [rax], ecx

; 2209 :             *unitstat=CSW_CE|CSW_DE;

  006cd	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006d5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2210 :             break;

  006d8	eb 24		 jmp	 SHORT $LN14@commadpt_e
$LN34@commadpt_e:

; 2211 : 
; 2212 :         default:
; 2213 :         /*---------------------------------------------------------------*/
; 2214 :         /* INVALID OPERATION                                             */
; 2215 :         /*---------------------------------------------------------------*/
; 2216 :             /* Set command reject sense byte, and unit check status */
; 2217 :             *unitstat=CSW_CE+CSW_DE+CSW_UC;

  006da	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006e2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2218 :             dev->sense[0]=SENSE_CR;

  006e5	b8 01 00 00 00	 mov	 eax, 1
  006ea	48 6b c0 00	 imul	 rax, rax, 0
  006ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f6	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H
$LN14@commadpt_e:

; 2219 :             break;
; 2220 : 
; 2221 :     }
; 2222 :     release_lock(&dev->commadpt->lock);

  006fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00706	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0070d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00711	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169465
  00718	48 8b c8	 mov	 rcx, rax
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2223 : }

  00721	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00728	5f		 pop	 rdi
  00729	5e		 pop	 rsi
  0072a	c3		 ret	 0
  0072b	90		 npad	 1
$LN45@commadpt_e:
  0072c	00 00 00 00	 DD	 $LN24@commadpt_e
  00730	00 00 00 00	 DD	 $LN18@commadpt_e
  00734	00 00 00 00	 DD	 $LN28@commadpt_e
  00738	00 00 00 00	 DD	 $LN17@commadpt_e
  0073c	00 00 00 00	 DD	 $LN22@commadpt_e
  00740	00 00 00 00	 DD	 $LN23@commadpt_e
  00744	00 00 00 00	 DD	 $LN30@commadpt_e
  00748	00 00 00 00	 DD	 $LN32@commadpt_e
  0074c	00 00 00 00	 DD	 $LN31@commadpt_e
  00750	00 00 00 00	 DD	 $LN33@commadpt_e
  00754	00 00 00 00	 DD	 $LN29@commadpt_e
  00758	00 00 00 00	 DD	 $LN34@commadpt_e
$LN44@commadpt_e:
  0075c	00		 DB	 0
  0075d	01		 DB	 1
  0075e	02		 DB	 2
  0075f	03		 DB	 3
  00760	04		 DB	 4
  00761	0b		 DB	 11
  00762	0b		 DB	 11
  00763	0b		 DB	 11
  00764	05		 DB	 5
  00765	0b		 DB	 11
  00766	0b		 DB	 11
  00767	0b		 DB	 11
  00768	0b		 DB	 11
  00769	0b		 DB	 11
  0076a	0b		 DB	 11
  0076b	0b		 DB	 11
  0076c	0b		 DB	 11
  0076d	0b		 DB	 11
  0076e	0b		 DB	 11
  0076f	0b		 DB	 11
  00770	0b		 DB	 11
  00771	0b		 DB	 11
  00772	0b		 DB	 11
  00773	0b		 DB	 11
  00774	0b		 DB	 11
  00775	0b		 DB	 11
  00776	0b		 DB	 11
  00777	0b		 DB	 11
  00778	0b		 DB	 11
  00779	0b		 DB	 11
  0077a	0b		 DB	 11
  0077b	0b		 DB	 11
  0077c	0b		 DB	 11
  0077d	0b		 DB	 11
  0077e	0b		 DB	 11
  0077f	0b		 DB	 11
  00780	0b		 DB	 11
  00781	0b		 DB	 11
  00782	0b		 DB	 11
  00783	0b		 DB	 11
  00784	0b		 DB	 11
  00785	0b		 DB	 11
  00786	0b		 DB	 11
  00787	0b		 DB	 11
  00788	0b		 DB	 11
  00789	0b		 DB	 11
  0078a	0b		 DB	 11
  0078b	0b		 DB	 11
  0078c	06		 DB	 6
  0078d	07		 DB	 7
  0078e	0b		 DB	 11
  0078f	0b		 DB	 11
  00790	0b		 DB	 11
  00791	0b		 DB	 11
  00792	0b		 DB	 11
  00793	0b		 DB	 11
  00794	0b		 DB	 11
  00795	0b		 DB	 11
  00796	0b		 DB	 11
  00797	0b		 DB	 11
  00798	0b		 DB	 11
  00799	0b		 DB	 11
  0079a	0b		 DB	 11
  0079b	0b		 DB	 11
  0079c	0b		 DB	 11
  0079d	0b		 DB	 11
  0079e	0b		 DB	 11
  0079f	0b		 DB	 11
  007a0	0b		 DB	 11
  007a1	0b		 DB	 11
  007a2	0b		 DB	 11
  007a3	0b		 DB	 11
  007a4	0b		 DB	 11
  007a5	0b		 DB	 11
  007a6	0b		 DB	 11
  007a7	0b		 DB	 11
  007a8	0b		 DB	 11
  007a9	0b		 DB	 11
  007aa	0b		 DB	 11
  007ab	0b		 DB	 11
  007ac	08		 DB	 8
  007ad	09		 DB	 9
  007ae	0b		 DB	 11
  007af	0b		 DB	 11
  007b0	0b		 DB	 11
  007b1	0b		 DB	 11
  007b2	0b		 DB	 11
  007b3	0b		 DB	 11
  007b4	0b		 DB	 11
  007b5	0b		 DB	 11
  007b6	0b		 DB	 11
  007b7	0b		 DB	 11
  007b8	0b		 DB	 11
  007b9	0b		 DB	 11
  007ba	0b		 DB	 11
  007bb	0b		 DB	 11
  007bc	0b		 DB	 11
  007bd	0b		 DB	 11
  007be	0b		 DB	 11
  007bf	0b		 DB	 11
  007c0	0b		 DB	 11
  007c1	0b		 DB	 11
  007c2	0b		 DB	 11
  007c3	0b		 DB	 11
  007c4	0b		 DB	 11
  007c5	0b		 DB	 11
  007c6	0b		 DB	 11
  007c7	0b		 DB	 11
  007c8	0b		 DB	 11
  007c9	0b		 DB	 11
  007ca	0b		 DB	 11
  007cb	0b		 DB	 11
  007cc	0b		 DB	 11
  007cd	0b		 DB	 11
  007ce	0b		 DB	 11
  007cf	0b		 DB	 11
  007d0	0b		 DB	 11
  007d1	0b		 DB	 11
  007d2	0b		 DB	 11
  007d3	0b		 DB	 11
  007d4	0b		 DB	 11
  007d5	0b		 DB	 11
  007d6	0b		 DB	 11
  007d7	0b		 DB	 11
  007d8	0b		 DB	 11
  007d9	0b		 DB	 11
  007da	0b		 DB	 11
  007db	0b		 DB	 11
  007dc	0b		 DB	 11
  007dd	0b		 DB	 11
  007de	0b		 DB	 11
  007df	0b		 DB	 11
  007e0	0b		 DB	 11
  007e1	0b		 DB	 11
  007e2	0b		 DB	 11
  007e3	0b		 DB	 11
  007e4	0b		 DB	 11
  007e5	0b		 DB	 11
  007e6	0b		 DB	 11
  007e7	0b		 DB	 11
  007e8	0b		 DB	 11
  007e9	0b		 DB	 11
  007ea	0b		 DB	 11
  007eb	0b		 DB	 11
  007ec	0b		 DB	 11
  007ed	0b		 DB	 11
  007ee	0a		 DB	 10
commadpt_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
len$ = 0
thdaf$ = 4
thoaf$ = 8
thsnf$ = 12
thmpf$ = 16
thm2$ = 20
r$ = 48
thptr$ = 56
locsuba$ = 64
th_remap PROC

; 2044 : { /* for 3791 support, remaps SNA FID1 <--> FID2 TH headers */

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2045 : int     thmpf;
; 2046 : int     thm2;
; 2047 : int     thdaf;
; 2048 : int     thoaf;
; 2049 : int     thsnf;
; 2050 : int     len;
; 2051 : 
; 2052 :     if (r == MAP_FID1_FID2)

  00013	83 7c 24 30 00	 cmp	 DWORD PTR r$[rsp], 0
  00018	0f 85 e2 01 00
	00		 jne	 $LN2@th_remap

; 2053 :     {
; 2054 :         thmpf = thptr[0];

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	48 6b c0 00	 imul	 rax, rax, 0
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  0002c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00030	89 44 24 10	 mov	 DWORD PTR thmpf$[rsp], eax

; 2055 :         thm2  = thptr[1];

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	48 6b c0 01	 imul	 rax, rax, 1
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00042	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00046	89 44 24 14	 mov	 DWORD PTR thm2$[rsp], eax

; 2056 :         thdaf = (thptr[2] << 8) + thptr[3];

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	48 6b c0 02	 imul	 rax, rax, 2
  00053	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00058	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005c	c1 e0 08	 shl	 eax, 8
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	48 6b c9 03	 imul	 rcx, rcx, 3
  00068	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  0006d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00071	03 c1		 add	 eax, ecx
  00073	89 44 24 04	 mov	 DWORD PTR thdaf$[rsp], eax

; 2057 :         thoaf = (thptr[4] << 8) + thptr[5];

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	48 6b c0 04	 imul	 rax, rax, 4
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00085	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00089	c1 e0 08	 shl	 eax, 8
  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	48 6b c9 05	 imul	 rcx, rcx, 5
  00095	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  0009a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0009e	03 c1		 add	 eax, ecx
  000a0	89 44 24 08	 mov	 DWORD PTR thoaf$[rsp], eax

; 2058 :         thsnf = (thptr[6] << 8) + thptr[7];

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	48 6b c0 06	 imul	 rax, rax, 6
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  000b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b6	c1 e0 08	 shl	 eax, 8
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	48 6b c9 07	 imul	 rcx, rcx, 7
  000c2	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  000c7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000cb	03 c1		 add	 eax, ecx
  000cd	89 44 24 0c	 mov	 DWORD PTR thsnf$[rsp], eax

; 2059 :         len = (thptr[8] << 8) + thptr[9];

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 08	 imul	 rax, rax, 8
  000da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  000df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e3	c1 e0 08	 shl	 eax, 8
  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	48 6b c9 09	 imul	 rcx, rcx, 9
  000ef	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  000f4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f8	03 c1		 add	 eax, ecx
  000fa	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 2060 :         len += 10;

  000fd	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00100	83 c0 0a	 add	 eax, 10
  00103	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 2061 :         thptr[0] = (len >> 8) & 0xff;

  00106	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00109	c1 f8 08	 sar	 eax, 8
  0010c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00111	b9 01 00 00 00	 mov	 ecx, 1
  00116	48 6b c9 00	 imul	 rcx, rcx, 0
  0011a	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  0011f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2062 :         thptr[1] = len & 0xff;

  00122	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00125	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	48 6b c9 01	 imul	 rcx, rcx, 1
  00133	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00138	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2063 :         thptr[2] = 0x00;

  0013b	b8 01 00 00 00	 mov	 eax, 1
  00140	48 6b c0 02	 imul	 rax, rax, 2
  00144	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00149	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 2064 :         thptr[3] = 0x00;

  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	48 6b c0 03	 imul	 rax, rax, 3
  00156	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  0015b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 2065 :         thptr[4] = 0x20 | (thmpf & 0x0f);

  0015f	8b 44 24 10	 mov	 eax, DWORD PTR thmpf$[rsp]
  00163	83 e0 0f	 and	 eax, 15
  00166	83 c8 20	 or	 eax, 32			; 00000020H
  00169	b9 01 00 00 00	 mov	 ecx, 1
  0016e	48 6b c9 04	 imul	 rcx, rcx, 4
  00172	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00177	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2066 :         thptr[5] = thm2;

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	48 6b c0 05	 imul	 rax, rax, 5
  00183	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00188	0f b6 54 24 14	 movzx	 edx, BYTE PTR thm2$[rsp]
  0018d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2067 :         thptr[6] = thdaf & 0xff;

  00190	8b 44 24 04	 mov	 eax, DWORD PTR thdaf$[rsp]
  00194	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	48 6b c9 06	 imul	 rcx, rcx, 6
  001a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  001a7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2068 :         thptr[7] = thoaf & 0xff;

  001aa	8b 44 24 08	 mov	 eax, DWORD PTR thoaf$[rsp]
  001ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b3	b9 01 00 00 00	 mov	 ecx, 1
  001b8	48 6b c9 07	 imul	 rcx, rcx, 7
  001bc	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  001c1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2069 :         thptr[8] = (thsnf >> 8) & 0xff;

  001c4	8b 44 24 0c	 mov	 eax, DWORD PTR thsnf$[rsp]
  001c8	c1 f8 08	 sar	 eax, 8
  001cb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d0	b9 01 00 00 00	 mov	 ecx, 1
  001d5	48 6b c9 08	 imul	 rcx, rcx, 8
  001d9	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  001de	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2070 :         thptr[9] = thsnf & 0xff;

  001e1	8b 44 24 0c	 mov	 eax, DWORD PTR thsnf$[rsp]
  001e5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ea	b9 01 00 00 00	 mov	 ecx, 1
  001ef	48 6b c9 09	 imul	 rcx, rcx, 9
  001f3	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  001f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2071 :     }

  001fb	e9 e2 01 00 00	 jmp	 $LN3@th_remap
$LN2@th_remap:

; 2072 :     else
; 2073 :     { /* map fid2 to fid1 */
; 2074 :         len = (thptr[0] << 8) + thptr[1];

  00200	b8 01 00 00 00	 mov	 eax, 1
  00205	48 6b c0 00	 imul	 rax, rax, 0
  00209	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  0020e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00212	c1 e0 08	 shl	 eax, 8
  00215	b9 01 00 00 00	 mov	 ecx, 1
  0021a	48 6b c9 01	 imul	 rcx, rcx, 1
  0021e	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00223	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00227	03 c1		 add	 eax, ecx
  00229	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 2075 :         thmpf = thptr[4];

  0022c	b8 01 00 00 00	 mov	 eax, 1
  00231	48 6b c0 04	 imul	 rax, rax, 4
  00235	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  0023a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0023e	89 44 24 10	 mov	 DWORD PTR thmpf$[rsp], eax

; 2076 :         thm2  = thptr[5];

  00242	b8 01 00 00 00	 mov	 eax, 1
  00247	48 6b c0 05	 imul	 rax, rax, 5
  0024b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00250	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00254	89 44 24 14	 mov	 DWORD PTR thm2$[rsp], eax

; 2077 :         thdaf = thptr[6];

  00258	b8 01 00 00 00	 mov	 eax, 1
  0025d	48 6b c0 06	 imul	 rax, rax, 6
  00261	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00266	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026a	89 44 24 04	 mov	 DWORD PTR thdaf$[rsp], eax

; 2078 :         thoaf = thptr[7];

  0026e	b8 01 00 00 00	 mov	 eax, 1
  00273	48 6b c0 07	 imul	 rax, rax, 7
  00277	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  0027c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00280	89 44 24 08	 mov	 DWORD PTR thoaf$[rsp], eax

; 2079 :         thsnf = (thptr[8] << 8) + thptr[9];

  00284	b8 01 00 00 00	 mov	 eax, 1
  00289	48 6b c0 08	 imul	 rax, rax, 8
  0028d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00292	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00296	c1 e0 08	 shl	 eax, 8
  00299	b9 01 00 00 00	 mov	 ecx, 1
  0029e	48 6b c9 09	 imul	 rcx, rcx, 9
  002a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  002a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002ab	03 c1		 add	 eax, ecx
  002ad	89 44 24 0c	 mov	 DWORD PTR thsnf$[rsp], eax

; 2080 :         thdaf |= locsuba;

  002b1	0f b7 44 24 40	 movzx	 eax, WORD PTR locsuba$[rsp]
  002b6	8b 4c 24 04	 mov	 ecx, DWORD PTR thdaf$[rsp]
  002ba	0b c8		 or	 ecx, eax
  002bc	8b c1		 mov	 eax, ecx
  002be	89 44 24 04	 mov	 DWORD PTR thdaf$[rsp], eax

; 2081 :         thoaf |= 0x0800;   /* SSCP subarea = 1 (maxsuba=31) */

  002c2	8b 44 24 08	 mov	 eax, DWORD PTR thoaf$[rsp]
  002c6	0f ba e8 0b	 bts	 eax, 11
  002ca	89 44 24 08	 mov	 DWORD PTR thoaf$[rsp], eax

; 2082 :         len -= 10;

  002ce	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  002d1	83 e8 0a	 sub	 eax, 10
  002d4	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 2083 :         thptr[0] = 0x10 | (thmpf & 0x0f);

  002d7	8b 44 24 10	 mov	 eax, DWORD PTR thmpf$[rsp]
  002db	83 e0 0f	 and	 eax, 15
  002de	83 c8 10	 or	 eax, 16
  002e1	b9 01 00 00 00	 mov	 ecx, 1
  002e6	48 6b c9 00	 imul	 rcx, rcx, 0
  002ea	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  002ef	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2084 :         thptr[1] = thm2;

  002f2	b8 01 00 00 00	 mov	 eax, 1
  002f7	48 6b c0 01	 imul	 rax, rax, 1
  002fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR thptr$[rsp]
  00300	0f b6 54 24 14	 movzx	 edx, BYTE PTR thm2$[rsp]
  00305	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2085 :         thptr[2] = (thdaf >> 8) & 0xff;

  00308	8b 44 24 04	 mov	 eax, DWORD PTR thdaf$[rsp]
  0030c	c1 f8 08	 sar	 eax, 8
  0030f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00314	b9 01 00 00 00	 mov	 ecx, 1
  00319	48 6b c9 02	 imul	 rcx, rcx, 2
  0031d	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00322	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2086 :         thptr[3] = thdaf & 0xff;

  00325	8b 44 24 04	 mov	 eax, DWORD PTR thdaf$[rsp]
  00329	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0032e	b9 01 00 00 00	 mov	 ecx, 1
  00333	48 6b c9 03	 imul	 rcx, rcx, 3
  00337	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  0033c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2087 :         thptr[4] = (thoaf >> 8) & 0xff;

  0033f	8b 44 24 08	 mov	 eax, DWORD PTR thoaf$[rsp]
  00343	c1 f8 08	 sar	 eax, 8
  00346	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0034b	b9 01 00 00 00	 mov	 ecx, 1
  00350	48 6b c9 04	 imul	 rcx, rcx, 4
  00354	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00359	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2088 :         thptr[5] = thoaf & 0xff;

  0035c	8b 44 24 08	 mov	 eax, DWORD PTR thoaf$[rsp]
  00360	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00365	b9 01 00 00 00	 mov	 ecx, 1
  0036a	48 6b c9 05	 imul	 rcx, rcx, 5
  0036e	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00373	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2089 :         thptr[6] = (thsnf >> 8) & 0xff;

  00376	8b 44 24 0c	 mov	 eax, DWORD PTR thsnf$[rsp]
  0037a	c1 f8 08	 sar	 eax, 8
  0037d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00382	b9 01 00 00 00	 mov	 ecx, 1
  00387	48 6b c9 06	 imul	 rcx, rcx, 6
  0038b	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  00390	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2090 :         thptr[7] = thsnf & 0xff;

  00393	8b 44 24 0c	 mov	 eax, DWORD PTR thsnf$[rsp]
  00397	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0039c	b9 01 00 00 00	 mov	 ecx, 1
  003a1	48 6b c9 07	 imul	 rcx, rcx, 7
  003a5	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  003aa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2091 :         thptr[8] = (len >> 8) & 0xff;

  003ad	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  003b0	c1 f8 08	 sar	 eax, 8
  003b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003b8	b9 01 00 00 00	 mov	 ecx, 1
  003bd	48 6b c9 08	 imul	 rcx, rcx, 8
  003c1	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  003c6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2092 :         thptr[9] = len & 0xff;

  003c9	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  003cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003d1	b9 01 00 00 00	 mov	 ecx, 1
  003d6	48 6b c9 09	 imul	 rcx, rcx, 9
  003da	48 8b 54 24 38	 mov	 rdx, QWORD PTR thptr$[rsp]
  003df	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN3@th_remap:

; 2093 :     }
; 2094 : }

  003e2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  003e6	c3		 ret	 0
th_remap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
amt$ = 84
respbuf$ = 88
i1$ = 96
ru_ptr$ = 104
tv208 = 112
tv213 = 116
eleptr$ = 120
obuf$ = 128
buf$ = 4224
__$ArrayPad$ = 69760
requestp$ = 69808
ca$ = 69816
make_sna_response PROC

; 1902 : void make_sna_response (BYTE * requestp, COMMADPT *ca) {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 98 10 01 00	 mov	 eax, 69784		; 00011098H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 80
	10 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1903 :     BYTE    *respbuf;
; 1904 :     BYTE    *ru_ptr;
; 1905 :     int     ru_size;
; 1906 :     void    *eleptr;
; 1907 :     BYTE    obuf[4096];
; 1908 :     BYTE    buf[BUFLEN_3270];
; 1909 :     int     amt;
; 1910 :     int     i1;
; 1911 : 
; 1912 :     if ((requestp[10] & 0x80) != 0) return;   // disregard if this is a resp.

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 0a	 imul	 rax, rax, 10
  00034	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00045	85 c0		 test	 eax, eax
  00047	74 05		 je	 SHORT $LN5@make_sna_r
  00049	e9 11 0b 00 00	 jmp	 $LN1@make_sna_r
$LN5@make_sna_r:

; 1913 :     if ((requestp[10] & (unsigned char)0xfc) == 0x00 && requestp[2] == ca->lu_addr0 && requestp[3] == ca->lu_addr1 && ca->sfd > 0) {   /* if type=data, and DAF matches up, and socket exists */

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 0a	 imul	 rax, rax, 10
  00057	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0005f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00063	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00068	85 c0		 test	 eax, eax
  0006a	0f 85 58 02 00
	00		 jne	 $LN6@make_sna_r
  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	48 6b c0 02	 imul	 rax, rax, 2
  00079	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00081	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00085	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0008d	0f b6 89 b6 00
	01 00		 movzx	 ecx, BYTE PTR [rcx+65718]
  00094	3b c1		 cmp	 eax, ecx
  00096	0f 85 2c 02 00
	00		 jne	 $LN6@make_sna_r
  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	48 6b c0 03	 imul	 rax, rax, 3
  000a5	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  000ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b1	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  000b9	0f b6 89 b7 00
	01 00		 movzx	 ecx, BYTE PTR [rcx+65719]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	0f 85 00 02 00
	00		 jne	 $LN6@make_sna_r
  000c8	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  000d0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000d4	0f 8e ee 01 00
	00		 jle	 $LN6@make_sna_r

; 1914 :         amt = (requestp[8] << 8) + requestp[9];

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 08	 imul	 rax, rax, 8
  000e3	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  000eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ef	c1 e0 08	 shl	 eax, 8
  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	48 6b c9 09	 imul	 rcx, rcx, 9
  000fb	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00103	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00107	03 c1		 add	 eax, ecx
  00109	89 44 24 54	 mov	 DWORD PTR amt$[rsp], eax

; 1915 :         amt -= 3;

  0010d	8b 44 24 54	 mov	 eax, DWORD PTR amt$[rsp]
  00111	83 e8 03	 sub	 eax, 3
  00114	89 44 24 54	 mov	 DWORD PTR amt$[rsp], eax

; 1916 :         if (ca->is_3270) {

  00118	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00120	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00123	c1 e8 07	 shr	 eax, 7
  00126	83 e0 01	 and	 eax, 1
  00129	85 c0		 test	 eax, eax
  0012b	0f 84 d9 00 00
	00		 je	 $LN7@make_sna_r

; 1917 :             memcpy(buf, &requestp[13], amt);

  00131	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  00136	b9 01 00 00 00	 mov	 ecx, 1
  0013b	48 6b c9 0d	 imul	 rcx, rcx, 13
  0013f	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00147	48 03 d1	 add	 rdx, rcx
  0014a	48 8b ca	 mov	 rcx, rdx
  0014d	48 8d 94 24 80
	10 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00155	48 8b fa	 mov	 rdi, rdx
  00158	48 8b f1	 mov	 rsi, rcx
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	f3 a4		 rep movsb

; 1918 :             /* Double up any IAC bytes in the data */
; 1919 :             amt = double_up_iac (buf, amt);

  00160	8b 54 24 54	 mov	 edx, DWORD PTR amt$[rsp]
  00164	48 8d 8c 24 80
	10 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0016c	e8 00 00 00 00	 call	 double_up_iac
  00171	89 44 24 54	 mov	 DWORD PTR amt$[rsp], eax

; 1920 :             /* Append telnet EOR marker at end of data */
; 1921 :             if ((requestp[10] & 0x01) == 0x01) {   /* if last-in-chain is set */

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	48 6b c0 0a	 imul	 rax, rax, 10
  0017e	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00186	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018a	83 e0 01	 and	 eax, 1
  0018d	83 f8 01	 cmp	 eax, 1
  00190	75 2e		 jne	 SHORT $LN9@make_sna_r

; 1922 :                 buf[amt++] = IAC;

  00192	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  00197	c6 84 04 80 10
	00 00 ff	 mov	 BYTE PTR buf$[rsp+rax], 255 ; 000000ffH
  0019f	8b 44 24 54	 mov	 eax, DWORD PTR amt$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	89 44 24 54	 mov	 DWORD PTR amt$[rsp], eax

; 1923 :                 buf[amt++] = EOR_MARK;

  001a9	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  001ae	c6 84 04 80 10
	00 00 ef	 mov	 BYTE PTR buf$[rsp+rax], 239 ; 000000efH
  001b6	8b 44 24 54	 mov	 eax, DWORD PTR amt$[rsp]
  001ba	ff c0		 inc	 eax
  001bc	89 44 24 54	 mov	 DWORD PTR amt$[rsp], eax
$LN9@make_sna_r:

; 1924 :             }
; 1925 :             /* Send the data to the client */
; 1926 :             logdump ("SEND", ca->dev, buf, amt);

  001c0	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  001c5	4c 8b c8	 mov	 r9, rax
  001c8	4c 8d 84 24 80
	10 00 00	 lea	 r8, QWORD PTR buf$[rsp]
  001d0	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  001d8	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169348
  001e2	e8 00 00 00 00	 call	 logdump

; 1927 :             write_socket(ca->sfd,buf,amt);

  001e7	44 8b 44 24 54	 mov	 r8d, DWORD PTR amt$[rsp]
  001ec	48 8d 94 24 80
	10 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  001f4	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  001fc	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket

; 1928 :         } else {

  00205	e9 be 00 00 00	 jmp	 $LN8@make_sna_r
$LN7@make_sna_r:

; 1929 :             // convert data portion to ASCII and write to remote user
; 1930 :             if (amt > 0) {

  0020a	83 7c 24 54 00	 cmp	 DWORD PTR amt$[rsp], 0
  0020f	0f 8e b3 00 00
	00		 jle	 $LN10@make_sna_r

; 1931 :                 memcpy(obuf, &requestp[13], amt);

  00215	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  0021a	b9 01 00 00 00	 mov	 ecx, 1
  0021f	48 6b c9 0d	 imul	 rcx, rcx, 13
  00223	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  0022b	48 03 d1	 add	 rdx, rcx
  0022e	48 8b ca	 mov	 rcx, rdx
  00231	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR obuf$[rsp]
  00239	48 8b fa	 mov	 rdi, rdx
  0023c	48 8b f1	 mov	 rsi, rcx
  0023f	48 8b c8	 mov	 rcx, rax
  00242	f3 a4		 rep movsb

; 1932 :                 for (i1=0; i1<amt; i1++) {

  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i1$[rsp], 0
  0024c	eb 0a		 jmp	 SHORT $LN4@make_sna_r
$LN2@make_sna_r:
  0024e	8b 44 24 60	 mov	 eax, DWORD PTR i1$[rsp]
  00252	ff c0		 inc	 eax
  00254	89 44 24 60	 mov	 DWORD PTR i1$[rsp], eax
$LN4@make_sna_r:
  00258	8b 44 24 54	 mov	 eax, DWORD PTR amt$[rsp]
  0025c	39 44 24 60	 cmp	 DWORD PTR i1$[rsp], eax
  00260	7d 21		 jge	 SHORT $LN3@make_sna_r

; 1933 :                     obuf[i1] = guest_to_host(obuf[i1]);

  00262	48 63 44 24 60	 movsxd	 rax, DWORD PTR i1$[rsp]
  00267	0f b6 8c 04 80
	00 00 00	 movzx	 ecx, BYTE PTR obuf$[rsp+rax]
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00275	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0027a	88 84 0c 80 00
	00 00		 mov	 BYTE PTR obuf$[rsp+rcx], al

; 1934 :                 }

  00281	eb cb		 jmp	 SHORT $LN2@make_sna_r
$LN3@make_sna_r:

; 1935 :                 logdump ("SEND", ca->dev, obuf, amt);

  00283	48 63 44 24 54	 movsxd	 rax, DWORD PTR amt$[rsp]
  00288	4c 8b c8	 mov	 r9, rax
  0028b	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR obuf$[rsp]
  00293	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  0029b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169350
  002a5	e8 00 00 00 00	 call	 logdump

; 1936 :                 write_socket(ca->sfd,obuf,amt);

  002aa	44 8b 44 24 54	 mov	 r8d, DWORD PTR amt$[rsp]
  002af	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR obuf$[rsp]
  002b7	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  002bf	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
$LN10@make_sna_r:
$LN8@make_sna_r:
$LN6@make_sna_r:

; 1937 :             }
; 1938 :         }
; 1939 :     }
; 1940 :     if ((requestp[11] & 0xf0) != 0x80) return;   // disregard if not DR1 requested

  002c8	b8 01 00 00 00	 mov	 eax, 1
  002cd	48 6b c0 0b	 imul	 rax, rax, 11
  002d1	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  002d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002dd	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002e2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002e7	74 05		 je	 SHORT $LN11@make_sna_r
  002e9	e9 71 08 00 00	 jmp	 $LN1@make_sna_r
$LN11@make_sna_r:

; 1941 : 
; 1942 :     eleptr = get_bufpool(&ca->freeq);

  002ee	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  002f6	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  002fc	48 8b c8	 mov	 rcx, rax
  002ff	e8 00 00 00 00	 call	 get_bufpool
  00304	48 89 44 24 78	 mov	 QWORD PTR eleptr$[rsp], rax

; 1943 :     if (!eleptr)  {

  00309	48 83 7c 24 78
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  0030f	0f 85 90 00 00
	00		 jne	 $LN12@make_sna_r

; 1944 :         WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA response");

  00315	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  0031d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00320	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00324	89 44 24 70	 mov	 DWORD PTR tv208[rsp], eax
  00328	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00330	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00333	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00337	d1 f9		 sar	 ecx, 1
  00339	89 4c 24 74	 mov	 DWORD PTR tv213[rsp], ecx
  0033d	b9 01 00 00 00	 mov	 ecx, 1
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169353
  0034f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00354	8b 4c 24 70	 mov	 ecx, DWORD PTR tv208[rsp]
  00358	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0035c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv213[rsp]
  00360	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169354
  0036b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169355
  00377	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00381	41 b9 03 00 00
	00		 mov	 r9d, 3
  00387	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169356
  0038e	ba 98 07 00 00	 mov	 edx, 1944		; 00000798H
  00393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169357
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1945 :         return;

  003a0	e9 ba 07 00 00	 jmp	 $LN1@make_sna_r
$LN12@make_sna_r:

; 1946 :     }
; 1947 :     respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  003a5	48 8b 44 24 78	 mov	 rax, QWORD PTR eleptr$[rsp]
  003aa	48 83 c0 08	 add	 rax, 8
  003ae	48 89 44 24 58	 mov	 QWORD PTR respbuf$[rsp], rax

; 1948 : 
; 1949 :     /* first do the ten-byte FID1 TH */
; 1950 :     respbuf[0] = requestp[0];

  003b3	b8 01 00 00 00	 mov	 eax, 1
  003b8	48 6b c0 00	 imul	 rax, rax, 0
  003bc	b9 01 00 00 00	 mov	 ecx, 1
  003c1	48 6b c9 00	 imul	 rcx, rcx, 0
  003c5	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  003ca	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  003d2	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  003d6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1951 :     respbuf[1] = requestp[1];

  003d9	b8 01 00 00 00	 mov	 eax, 1
  003de	48 6b c0 01	 imul	 rax, rax, 1
  003e2	b9 01 00 00 00	 mov	 ecx, 1
  003e7	48 6b c9 01	 imul	 rcx, rcx, 1
  003eb	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  003f0	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  003f8	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  003fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1952 :     respbuf[2] = requestp[4];   // daf

  003ff	b8 01 00 00 00	 mov	 eax, 1
  00404	48 6b c0 04	 imul	 rax, rax, 4
  00408	b9 01 00 00 00	 mov	 ecx, 1
  0040d	48 6b c9 02	 imul	 rcx, rcx, 2
  00411	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00416	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  0041e	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00422	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1953 :     respbuf[3] = requestp[5];

  00425	b8 01 00 00 00	 mov	 eax, 1
  0042a	48 6b c0 05	 imul	 rax, rax, 5
  0042e	b9 01 00 00 00	 mov	 ecx, 1
  00433	48 6b c9 03	 imul	 rcx, rcx, 3
  00437	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0043c	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  00444	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00448	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1954 :     respbuf[4] = requestp[2];   // oaf

  0044b	b8 01 00 00 00	 mov	 eax, 1
  00450	48 6b c0 02	 imul	 rax, rax, 2
  00454	b9 01 00 00 00	 mov	 ecx, 1
  00459	48 6b c9 04	 imul	 rcx, rcx, 4
  0045d	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00462	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  0046a	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  0046e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1955 :     respbuf[5] = requestp[3];

  00471	b8 01 00 00 00	 mov	 eax, 1
  00476	48 6b c0 03	 imul	 rax, rax, 3
  0047a	b9 01 00 00 00	 mov	 ecx, 1
  0047f	48 6b c9 05	 imul	 rcx, rcx, 5
  00483	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00488	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  00490	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00494	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1956 :     respbuf[6] = requestp[6];   // seq #

  00497	b8 01 00 00 00	 mov	 eax, 1
  0049c	48 6b c0 06	 imul	 rax, rax, 6
  004a0	b9 01 00 00 00	 mov	 ecx, 1
  004a5	48 6b c9 06	 imul	 rcx, rcx, 6
  004a9	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  004ae	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  004b6	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  004ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1957 :     respbuf[7] = requestp[7];

  004bd	b8 01 00 00 00	 mov	 eax, 1
  004c2	48 6b c0 07	 imul	 rax, rax, 7
  004c6	b9 01 00 00 00	 mov	 ecx, 1
  004cb	48 6b c9 07	 imul	 rcx, rcx, 7
  004cf	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  004d4	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  004dc	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  004e0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1958 : 
; 1959 :     /* do RH */
; 1960 :     respbuf[10] = requestp[10];

  004e3	b8 01 00 00 00	 mov	 eax, 1
  004e8	48 6b c0 0a	 imul	 rax, rax, 10
  004ec	b9 01 00 00 00	 mov	 ecx, 1
  004f1	48 6b c9 0a	 imul	 rcx, rcx, 10
  004f5	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  004fa	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  00502	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00506	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1961 :     respbuf[10] |= 0x83;         // indicate this is a resp.

  00509	b8 01 00 00 00	 mov	 eax, 1
  0050e	48 6b c0 0a	 imul	 rax, rax, 10
  00512	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00517	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051b	0d 83 00 00 00	 or	 eax, 131		; 00000083H
  00520	b9 01 00 00 00	 mov	 ecx, 1
  00525	48 6b c9 0a	 imul	 rcx, rcx, 10
  00529	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0052e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1962 :     respbuf[11] = requestp[11];

  00531	b8 01 00 00 00	 mov	 eax, 1
  00536	48 6b c0 0b	 imul	 rax, rax, 11
  0053a	b9 01 00 00 00	 mov	 ecx, 1
  0053f	48 6b c9 0b	 imul	 rcx, rcx, 11
  00543	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00548	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  00550	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00554	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1963 : //    respbuf[12] = requestp[12];
; 1964 :     respbuf[12] = 0x00;

  00557	b8 01 00 00 00	 mov	 eax, 1
  0055c	48 6b c0 0c	 imul	 rax, rax, 12
  00560	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00565	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1965 : 
; 1966 :     /* do RU */
; 1967 :     ru_size = 0;

  00569	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ru_size$[rsp], 0

; 1968 :     ru_ptr = &respbuf[13];

  00571	b8 01 00 00 00	 mov	 eax, 1
  00576	48 6b c0 0d	 imul	 rax, rax, 13
  0057a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0057f	48 03 c8	 add	 rcx, rax
  00582	48 8b c1	 mov	 rax, rcx
  00585	48 89 44 24 68	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1969 :     if ((requestp[10] & 0x08) != 0)

  0058a	b8 01 00 00 00	 mov	 eax, 1
  0058f	48 6b c0 0a	 imul	 rax, rax, 10
  00593	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0059b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0059f	83 e0 08	 and	 eax, 8
  005a2	85 c0		 test	 eax, eax
  005a4	74 2c		 je	 SHORT $LN13@make_sna_r

; 1970 :         ru_ptr[ru_size++] = requestp[13];

  005a6	b8 01 00 00 00	 mov	 eax, 1
  005ab	48 6b c0 0d	 imul	 rax, rax, 13
  005af	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  005b4	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  005b9	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  005c1	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  005c5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005c8	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  005cc	ff c0		 inc	 eax
  005ce	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax
$LN13@make_sna_r:

; 1971 :     if (requestp[13] == 0x11 && requestp[14] == 0x02) {   /* ACTPU (NCP)*/

  005d2	b8 01 00 00 00	 mov	 eax, 1
  005d7	48 6b c0 0d	 imul	 rax, rax, 13
  005db	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  005e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005e7	83 f8 11	 cmp	 eax, 17
  005ea	0f 85 36 01 00
	00		 jne	 $LN14@make_sna_r
  005f0	b8 01 00 00 00	 mov	 eax, 1
  005f5	48 6b c0 0e	 imul	 rax, rax, 14
  005f9	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00601	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00605	83 f8 02	 cmp	 eax, 2
  00608	0f 85 18 01 00
	00		 jne	 $LN14@make_sna_r

; 1972 :         ca->ncp_addr0 = requestp[2];

  0060e	b8 01 00 00 00	 mov	 eax, 1
  00613	48 6b c0 02	 imul	 rax, rax, 2
  00617	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0061f	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00627	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0062b	88 81 b2 00 01
	00		 mov	 BYTE PTR [rcx+65714], al

; 1973 :         ca->ncp_addr1 = requestp[3];

  00631	b8 01 00 00 00	 mov	 eax, 1
  00636	48 6b c0 03	 imul	 rax, rax, 3
  0063a	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00642	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  0064a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0064e	88 81 b3 00 01
	00		 mov	 BYTE PTR [rcx+65715], al

; 1974 : //        ca->ncp_sscp_seqn = 0;
; 1975 :         ru_ptr[ru_size++] = 0x02;

  00654	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00659	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0065e	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2
  00662	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00666	ff c0		 inc	 eax
  00668	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1976 :         if (requestp[2] == (ca->rmtsuba >> 8)){      /* remote NCP    */

  0066c	b8 01 00 00 00	 mov	 eax, 1
  00671	48 6b c0 02	 imul	 rax, rax, 2
  00675	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0067d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00681	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00689	0f b7 49 56	 movzx	 ecx, WORD PTR [rcx+86]
  0068d	c1 f9 08	 sar	 ecx, 8
  00690	3b c1		 cmp	 eax, ecx
  00692	75 36		 jne	 SHORT $LN15@make_sna_r

; 1977 :             memcpy(&ru_ptr[ru_size],ca->rmtncpnm,8); /* load mod name */

  00694	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00699	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0069e	48 8b 94 24 b8
	10 01 00	 mov	 rdx, QWORD PTR ca$[rsp]
  006a6	48 8b 52 49	 mov	 rdx, QWORD PTR [rdx+73]
  006aa	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1978 :             ru_size += 8;

  006ae	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  006b2	83 c0 08	 add	 eax, 8
  006b5	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1979 :             ca->ncpb_sscp_seqn = 0;

  006b9	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  006c1	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 1980 :         } else

  006c8	eb 5c		 jmp	 SHORT $LN16@make_sna_r
$LN15@make_sna_r:

; 1981 :         if (requestp[2] == (ca->locsuba >> 8)){      /* local  NCP    */

  006ca	b8 01 00 00 00	 mov	 eax, 1
  006cf	48 6b c0 02	 imul	 rax, rax, 2
  006d3	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  006db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006df	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  006e7	0f b7 49 54	 movzx	 ecx, WORD PTR [rcx+84]
  006eb	c1 f9 08	 sar	 ecx, 8
  006ee	3b c1		 cmp	 eax, ecx
  006f0	75 34		 jne	 SHORT $LN17@make_sna_r

; 1982 :             memcpy(&ru_ptr[ru_size],ca->locncpnm,8); /* load mod name */

  006f2	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  006f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  006fc	48 8b 94 24 b8
	10 01 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00704	48 8b 52 40	 mov	 rdx, QWORD PTR [rdx+64]
  00708	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1983 :             ru_size += 8;

  0070c	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00710	83 c0 08	 add	 eax, 8
  00713	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1984 :             ca->ncpa_sscp_seqn = 0;

  00717	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  0071f	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0
$LN17@make_sna_r:
$LN16@make_sna_r:
$LN14@make_sna_r:

; 1985 :         }
; 1986 :     }
; 1987 :     if (requestp[13] == 0x11 && requestp[14] == 0x01) {   /* ACTPU (PU)*/

  00726	b8 01 00 00 00	 mov	 eax, 1
  0072b	48 6b c0 0d	 imul	 rax, rax, 13
  0072f	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00737	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0073b	83 f8 11	 cmp	 eax, 17
  0073e	75 78		 jne	 SHORT $LN18@make_sna_r
  00740	b8 01 00 00 00	 mov	 eax, 1
  00745	48 6b c0 0e	 imul	 rax, rax, 14
  00749	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00751	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00755	83 f8 01	 cmp	 eax, 1
  00758	75 5e		 jne	 SHORT $LN18@make_sna_r

; 1988 :         ru_ptr[ru_size++] = 0x01;

  0075a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0075f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00764	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00768	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0076c	ff c0		 inc	 eax
  0076e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1989 :         /* save daf as our own net addr */
; 1990 :         ca->pu_addr0 = requestp[2];

  00772	b8 01 00 00 00	 mov	 eax, 1
  00777	48 6b c0 02	 imul	 rax, rax, 2
  0077b	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00783	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  0078b	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0078f	88 81 b4 00 01
	00		 mov	 BYTE PTR [rcx+65716], al

; 1991 :         ca->pu_addr1 = requestp[3];

  00795	b8 01 00 00 00	 mov	 eax, 1
  0079a	48 6b c0 03	 imul	 rax, rax, 3
  0079e	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  007a6	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  007ae	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  007b2	88 81 b5 00 01
	00		 mov	 BYTE PTR [rcx+65717], al
$LN18@make_sna_r:

; 1992 :     }
; 1993 :     if (requestp[13] == 0x01) {   /* 01XXXX Network Services */

  007b8	b8 01 00 00 00	 mov	 eax, 1
  007bd	48 6b c0 0d	 imul	 rax, rax, 13
  007c1	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  007c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007cd	83 f8 01	 cmp	 eax, 1
  007d0	75 58		 jne	 SHORT $LN19@make_sna_r

; 1994 :         ru_ptr[ru_size++] = requestp[14];

  007d2	b8 01 00 00 00	 mov	 eax, 1
  007d7	48 6b c0 0e	 imul	 rax, rax, 14
  007db	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  007e0	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  007e5	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  007ed	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  007f1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007f4	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  007f8	ff c0		 inc	 eax
  007fa	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1995 :         ru_ptr[ru_size++] = requestp[15];

  007fe	b8 01 00 00 00	 mov	 eax, 1
  00803	48 6b c0 0f	 imul	 rax, rax, 15
  00807	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  0080c	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  00811	48 8b bc 24 b0
	10 01 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  00819	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  0081d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00820	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00824	ff c0		 inc	 eax
  00826	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax
$LN19@make_sna_r:

; 1996 :     }
; 1997 :     if (!memcmp(&requestp[13], R010219, 3) && ca->sfd > 0) {   /* ANA */

  0082a	b8 01 00 00 00	 mov	 eax, 1
  0082f	48 6b c0 0d	 imul	 rax, rax, 13
  00833	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0083b	48 03 c8	 add	 rcx, rax
  0083e	48 8b c1	 mov	 rax, rcx
  00841	41 b8 03 00 00
	00		 mov	 r8d, 3
  00847	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010219
  0084e	48 8b c8	 mov	 rcx, rax
  00851	e8 00 00 00 00	 call	 memcmp
  00856	85 c0		 test	 eax, eax
  00858	75 67		 jne	 SHORT $LN20@make_sna_r
  0085a	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00862	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00866	7e 59		 jle	 SHORT $LN20@make_sna_r

; 1998 :         if (!ca->is_3270) {

  00868	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00870	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00873	c1 e8 07	 shr	 eax, 7
  00876	83 e0 01	 and	 eax, 1
  00879	85 c0		 test	 eax, eax
  0087b	75 44		 jne	 SHORT $LN21@make_sna_r

; 1999 :             connect_message(ca->sfd, (requestp[20] << 8) + requestp[21], 0);

  0087d	b8 01 00 00 00	 mov	 eax, 1
  00882	48 6b c0 14	 imul	 rax, rax, 20
  00886	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0088e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00892	c1 e0 08	 shl	 eax, 8
  00895	b9 01 00 00 00	 mov	 ecx, 1
  0089a	48 6b c9 15	 imul	 rcx, rcx, 21
  0089e	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  008a6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  008aa	03 c1		 add	 eax, ecx
  008ac	45 33 c0	 xor	 r8d, r8d
  008af	8b d0		 mov	 edx, eax
  008b1	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  008b9	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  008bc	e8 00 00 00 00	 call	 connect_message
$LN21@make_sna_r:
$LN20@make_sna_r:

; 2000 :         }
; 2001 :     }
; 2002 :     if (requestp[13] == 0x0D) {   /* ACTLU */

  008c1	b8 01 00 00 00	 mov	 eax, 1
  008c6	48 6b c0 0d	 imul	 rax, rax, 13
  008ca	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  008d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008d6	83 f8 0d	 cmp	 eax, 13
  008d9	0f 85 b7 00 00
	00		 jne	 $LN22@make_sna_r

; 2003 :         /* save daf as our own net addr */
; 2004 :         ca->lu_addr0 = requestp[2];

  008df	b8 01 00 00 00	 mov	 eax, 1
  008e4	48 6b c0 02	 imul	 rax, rax, 2
  008e8	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  008f0	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  008f8	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  008fc	88 81 b6 00 01
	00		 mov	 BYTE PTR [rcx+65718], al

; 2005 :         ca->lu_addr1 = requestp[3];

  00902	b8 01 00 00 00	 mov	 eax, 1
  00907	48 6b c0 03	 imul	 rax, rax, 3
  0090b	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00913	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  0091b	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0091f	88 81 b7 00 01
	00		 mov	 BYTE PTR [rcx+65719], al

; 2006 :         /* save oaf as our sscp net addr */
; 2007 :         ca->sscp_addr0 = requestp[4];

  00925	b8 01 00 00 00	 mov	 eax, 1
  0092a	48 6b c0 04	 imul	 rax, rax, 4
  0092e	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00936	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  0093e	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00942	88 81 b0 00 01
	00		 mov	 BYTE PTR [rcx+65712], al

; 2008 :         ca->sscp_addr1 = requestp[5];

  00948	b8 01 00 00 00	 mov	 eax, 1
  0094d	48 6b c0 05	 imul	 rax, rax, 5
  00951	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00959	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00961	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00965	88 81 b1 00 01
	00		 mov	 BYTE PTR [rcx+65713], al

; 2009 : 
; 2010 :         ca->lu_sscp_seqn = 0;

  0096b	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00973	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 2011 :         ca->bindflag = 0;

  0097d	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00985	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00988	83 e0 fb	 and	 eax, -5			; fffffffbH
  0098b	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00993	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN22@make_sna_r:

; 2012 :     }
; 2013 :     if (requestp[13] == 0x0E || !memcmp(&requestp[13], R01020F, 3)) {  // DACTLU or ABCONN

  00996	b8 01 00 00 00	 mov	 eax, 1
  0099b	48 6b c0 0d	 imul	 rax, rax, 13
  0099f	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  009a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009ab	83 f8 0e	 cmp	 eax, 14
  009ae	74 30		 je	 SHORT $LN24@make_sna_r
  009b0	b8 01 00 00 00	 mov	 eax, 1
  009b5	48 6b c0 0d	 imul	 rax, rax, 13
  009b9	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  009c1	48 03 c8	 add	 rcx, rax
  009c4	48 8b c1	 mov	 rax, rcx
  009c7	41 b8 03 00 00
	00		 mov	 r8d, 3
  009cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01020F
  009d4	48 8b c8	 mov	 rcx, rax
  009d7	e8 00 00 00 00	 call	 memcmp
  009dc	85 c0		 test	 eax, eax
  009de	75 46		 jne	 SHORT $LN23@make_sna_r
$LN24@make_sna_r:

; 2014 :         if (!ca->is_3270) {

  009e0	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  009e8	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  009eb	c1 e8 07	 shr	 eax, 7
  009ee	83 e0 01	 and	 eax, 1
  009f1	85 c0		 test	 eax, eax
  009f3	75 18		 jne	 SHORT $LN25@make_sna_r

; 2015 :             connect_message(ca->sfd, 0, 1);

  009f5	41 b8 01 00 00
	00		 mov	 r8d, 1
  009fb	33 d2		 xor	 edx, edx
  009fd	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00a05	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00a08	e8 00 00 00 00	 call	 connect_message
$LN25@make_sna_r:

; 2016 :         }
; 2017 :         ca->hangup = 1;

  00a0d	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00a15	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00a18	83 c8 40	 or	 eax, 64			; 00000040H
  00a1b	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00a23	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN23@make_sna_r:

; 2018 :     }
; 2019 :     if (requestp[13] == 0x31) {   /* BIND */

  00a26	b8 01 00 00 00	 mov	 eax, 1
  00a2b	48 6b c0 0d	 imul	 rax, rax, 13
  00a2f	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00a37	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a3b	83 f8 31	 cmp	 eax, 49			; 00000031H
  00a3e	75 71		 jne	 SHORT $LN26@make_sna_r

; 2020 :         /* save oaf from BIND request */
; 2021 :         ca->tso_addr0 = requestp[4];

  00a40	b8 01 00 00 00	 mov	 eax, 1
  00a45	48 6b c0 04	 imul	 rax, rax, 4
  00a49	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00a51	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00a59	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00a5d	88 81 b8 00 01
	00		 mov	 BYTE PTR [rcx+65720], al

; 2022 :         ca->tso_addr1 = requestp[5];

  00a63	b8 01 00 00 00	 mov	 eax, 1
  00a68	48 6b c0 05	 imul	 rax, rax, 5
  00a6c	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00a74	48 8b 94 24 b0
	10 01 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00a7c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00a80	88 81 b9 00 01
	00		 mov	 BYTE PTR [rcx+65721], al

; 2023 :         ca->lu_lu_seqn = 0;

  00a86	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00a8e	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 2024 :         ca->bindflag = 1;

  00a98	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00aa0	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00aa3	83 c8 04	 or	 eax, 4
  00aa6	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00aae	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN26@make_sna_r:

; 2025 :     }
; 2026 :     if (requestp[13] == 0x32 && requestp[14] != 0x02) {   /* BIND */

  00ab1	b8 01 00 00 00	 mov	 eax, 1
  00ab6	48 6b c0 0d	 imul	 rax, rax, 13
  00aba	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00ac2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ac6	83 f8 32	 cmp	 eax, 50			; 00000032H
  00ac9	75 33		 jne	 SHORT $LN27@make_sna_r
  00acb	b8 01 00 00 00	 mov	 eax, 1
  00ad0	48 6b c0 0e	 imul	 rax, rax, 14
  00ad4	48 8b 8c 24 b0
	10 01 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00adc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ae0	83 f8 02	 cmp	 eax, 2
  00ae3	74 19		 je	 SHORT $LN27@make_sna_r

; 2027 :         ca->bindflag = 0;

  00ae5	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00aed	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00af0	83 e0 fb	 and	 eax, -5			; fffffffbH
  00af3	48 8b 8c 24 b8
	10 01 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00afb	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN27@make_sna_r:

; 2028 :     }
; 2029 : 
; 2030 :     /* set length field in TH */
; 2031 :     ru_size += 3;   /* for RH */

  00afe	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00b02	83 c0 03	 add	 eax, 3
  00b05	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 2032 :     respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  00b09	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00b0d	c1 f8 08	 sar	 eax, 8
  00b10	0f b6 c0	 movzx	 eax, al
  00b13	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b18	b9 01 00 00 00	 mov	 ecx, 1
  00b1d	48 6b c9 08	 imul	 rcx, rcx, 8
  00b21	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00b26	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2033 :     respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  00b29	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  00b2e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b33	b9 01 00 00 00	 mov	 ecx, 1
  00b38	48 6b c9 09	 imul	 rcx, rcx, 9
  00b3c	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00b41	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2034 : 
; 2035 :     put_bufpool(&ca->sendq, eleptr);

  00b44	48 8b 84 24 b8
	10 01 00	 mov	 rax, QWORD PTR ca$[rsp]
  00b4c	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  00b52	48 8b 54 24 78	 mov	 rdx, QWORD PTR eleptr$[rsp]
  00b57	48 8b c8	 mov	 rcx, rax
  00b5a	e8 00 00 00 00	 call	 put_bufpool
$LN1@make_sna_r:

; 2036 : }

  00b5f	48 8b 8c 24 80
	10 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b67	48 33 cc	 xor	 rcx, rsp
  00b6a	e8 00 00 00 00	 call	 __security_check_cookie
  00b6f	48 81 c4 98 10
	01 00		 add	 rsp, 69784		; 00011098H
  00b76	5f		 pop	 rdi
  00b77	5e		 pop	 rsi
  00b78	c3		 ret	 0
make_sna_response ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
tv80 = 84
tv85 = 88
respbuf$ = 96
ru_ptr$ = 104
eleptr$ = 112
requestp$ = 144
ca$ = 152
make_sna_requests PROC

; 1855 : void make_sna_requests (BYTE * requestp, COMMADPT *ca) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1856 :     BYTE    *respbuf;
; 1857 :     BYTE    *ru_ptr;
; 1858 :     int     ru_size;
; 1859 :     void    *eleptr;
; 1860 :     if (memcmp(&requestp[13], R010201, 3)) return;   // we only want to process CONTACT

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 0d	 imul	 rax, rax, 13
  0001a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	41 b8 03 00 00
	00		 mov	 r8d, 3
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010201
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 memcmp
  0003d	85 c0		 test	 eax, eax
  0003f	74 05		 je	 SHORT $LN2@make_sna_r
  00041	e9 5a 03 00 00	 jmp	 $LN1@make_sna_r
$LN2@make_sna_r:

; 1861 :     eleptr = get_bufpool(&ca->freeq);

  00046	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0004e	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 get_bufpool
  0005c	48 89 44 24 70	 mov	 QWORD PTR eleptr$[rsp], rax

; 1862 :     if (!eleptr)  {

  00061	48 83 7c 24 70
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  00067	0f 85 90 00 00
	00		 jne	 $LN3@make_sna_r

; 1863 :             WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA request");

  0006d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0007c	89 44 24 54	 mov	 DWORD PTR tv80[rsp], eax
  00080	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00088	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0008f	d1 f9		 sar	 ecx, 1
  00091	89 4c 24 58	 mov	 DWORD PTR tv85[rsp], ecx
  00095	b9 01 00 00 00	 mov	 ecx, 1
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169317
  000a7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ac	8b 4c 24 54	 mov	 ecx, DWORD PTR tv80[rsp]
  000b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b4	8b 4c 24 58	 mov	 ecx, DWORD PTR tv85[rsp]
  000b8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169318
  000c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169319
  000cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169320
  000e6	ba 47 07 00 00	 mov	 edx, 1863		; 00000747H
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169321
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1864 :             return;

  000f8	e9 a3 02 00 00	 jmp	 $LN1@make_sna_r
$LN3@make_sna_r:

; 1865 :     }
; 1866 :     respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  000fd	48 8b 44 24 70	 mov	 rax, QWORD PTR eleptr$[rsp]
  00102	48 83 c0 08	 add	 rax, 8
  00106	48 89 44 24 60	 mov	 QWORD PTR respbuf$[rsp], rax

; 1867 : 
; 1868 :     /* first do the ten-byte FID1 TH */
; 1869 : //    respbuf[0] = requestp[0];
; 1870 : //    respbuf[1] = requestp[1];
; 1871 :     respbuf[0] = 0x1c;

  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	48 6b c0 00	 imul	 rax, rax, 0
  00114	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00119	c6 04 01 1c	 mov	 BYTE PTR [rcx+rax], 28

; 1872 :     respbuf[1] = 0x00;

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	48 6b c0 01	 imul	 rax, rax, 1
  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0012b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1873 :     respbuf[2] = requestp[4];   // daf

  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	48 6b c0 04	 imul	 rax, rax, 4
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	48 6b c9 02	 imul	 rcx, rcx, 2
  00141	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00146	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  0014e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00153	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1874 :     respbuf[3] = requestp[5];

  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	48 6b c0 05	 imul	 rax, rax, 5
  0015f	b9 01 00 00 00	 mov	 ecx, 1
  00164	48 6b c9 03	 imul	 rcx, rcx, 3
  00168	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0016d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  00175	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0017a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1875 :     respbuf[4] = requestp[2];   // oaf

  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	48 6b c0 02	 imul	 rax, rax, 2
  00186	b9 01 00 00 00	 mov	 ecx, 1
  0018b	48 6b c9 04	 imul	 rcx, rcx, 4
  0018f	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00194	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  0019c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001a1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1876 :     respbuf[5] = requestp[3];

  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	48 6b c0 03	 imul	 rax, rax, 3
  001ad	b9 01 00 00 00	 mov	 ecx, 1
  001b2	48 6b c9 05	 imul	 rcx, rcx, 5
  001b6	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  001bb	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  001c3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001c8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1877 :     make_seq(ca, respbuf);

  001cb	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  001d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  001d8	e8 00 00 00 00	 call	 make_seq

; 1878 :     /* do RH */
; 1879 :     respbuf[10] = requestp[10];

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 0a	 imul	 rax, rax, 10
  001e6	b9 01 00 00 00	 mov	 ecx, 1
  001eb	48 6b c9 0a	 imul	 rcx, rcx, 10
  001ef	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  001f4	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  001fc	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00201	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1880 :     respbuf[11] = requestp[11];

  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	48 6b c0 0b	 imul	 rax, rax, 11
  0020d	b9 01 00 00 00	 mov	 ecx, 1
  00212	48 6b c9 0b	 imul	 rcx, rcx, 11
  00216	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0021b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  00223	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00228	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1881 :     respbuf[11] = 0x00;

  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	48 6b c0 0b	 imul	 rax, rax, 11
  00234	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00239	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1882 :     respbuf[12] = requestp[12];

  0023d	b8 01 00 00 00	 mov	 eax, 1
  00242	48 6b c0 0c	 imul	 rax, rax, 12
  00246	b9 01 00 00 00	 mov	 ecx, 1
  0024b	48 6b c9 0c	 imul	 rcx, rcx, 12
  0024f	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00254	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  0025c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00261	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1883 : 
; 1884 :     /* make a CONTACTED RU */
; 1885 :     ru_size = 0;

  00264	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ru_size$[rsp], 0

; 1886 :     ru_ptr = &respbuf[13];

  0026c	b8 01 00 00 00	 mov	 eax, 1
  00271	48 6b c0 0d	 imul	 rax, rax, 13
  00275	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0027a	48 03 c8	 add	 rcx, rax
  0027d	48 8b c1	 mov	 rax, rcx
  00280	48 89 44 24 68	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1887 :     ru_ptr[ru_size++] = 0x01;

  00285	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0028a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0028f	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00293	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00297	ff c0		 inc	 eax
  00299	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1888 :     ru_ptr[ru_size++] = 0x02;

  0029d	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  002a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  002a7	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2
  002ab	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002af	ff c0		 inc	 eax
  002b1	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1889 :     ru_ptr[ru_size++] = 0x80;

  002b5	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  002ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  002bf	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H
  002c3	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002c7	ff c0		 inc	 eax
  002c9	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1890 :     ru_ptr[ru_size++] = requestp[16];

  002cd	b8 01 00 00 00	 mov	 eax, 1
  002d2	48 6b c0 10	 imul	 rax, rax, 16
  002d6	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  002db	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  002e0	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  002e8	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002ed	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002f0	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002f4	ff c0		 inc	 eax
  002f6	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1891 :     ru_ptr[ru_size++] = requestp[17];

  002fa	b8 01 00 00 00	 mov	 eax, 1
  002ff	48 6b c0 11	 imul	 rax, rax, 17
  00303	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  00308	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  0030d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  00315	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0031a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0031d	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00321	ff c0		 inc	 eax
  00323	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1892 :     ru_ptr[ru_size++] = 0x01;

  00327	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0032c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00331	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00335	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00339	ff c0		 inc	 eax
  0033b	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1893 : 
; 1894 :     /* set length field in TH */
; 1895 :     ru_size += 3;   /* for RH */

  0033f	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00343	83 c0 03	 add	 eax, 3
  00346	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1896 :     respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  0034a	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0034e	c1 f8 08	 sar	 eax, 8
  00351	0f b6 c0	 movzx	 eax, al
  00354	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00359	b9 01 00 00 00	 mov	 ecx, 1
  0035e	48 6b c9 08	 imul	 rcx, rcx, 8
  00362	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00367	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1897 :     respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  0036a	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  0036f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00374	b9 01 00 00 00	 mov	 ecx, 1
  00379	48 6b c9 09	 imul	 rcx, rcx, 9
  0037d	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00382	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1898 : 
; 1899 :     put_bufpool(&ca->sendq, eleptr);

  00385	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0038d	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  00393	48 8b 54 24 70	 mov	 rdx, QWORD PTR eleptr$[rsp]
  00398	48 8b c8	 mov	 rcx, rax
  0039b	e8 00 00 00 00	 call	 put_bufpool
$LN1@make_sna_r:

; 1900 : }

  003a0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  003a7	c3		 ret	 0
make_sna_requests ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_type$ = 112
len$ = 120
tv422 = 124
tv425 = 128
fmtbuf4$ = 136
fmtbuf3$ = 168
fmtbuf6$ = 200
fmtbuf2$ = 232
fmtbuf$ = 264
__$ArrayPad$ = 296
requestp$ = 352
tag$ = 360
ssid$ = 368
devnum$ = 376
format_sna PROC

; 1540 : static void format_sna (BYTE * requestp, char * tag, U16 ssid, U16 devnum) {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	53		 push	 rbx
  00017	55		 push	 rbp
  00018	56		 push	 rsi
  00019	57		 push	 rdi
  0001a	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1541 :     char     fmtbuf[32];
; 1542 :     char     fmtbuf2[32];
; 1543 :     char     fmtbuf3[32];
; 1544 :     char     fmtbuf4[32];
; 1545 : //  char     fmtbuf5[256];
; 1546 :     char     fmtbuf6[32];
; 1547 :     char     *ru_type="";

  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169149
  0003a	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax

; 1548 :     int      len;
; 1549 :     sprintf(fmtbuf, "%02X%02X %02X%02X %02X%02X %02X%02X %02X%02X",

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	48 6b c0 09	 imul	 rax, rax, 9
  00048	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00050	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 08	 imul	 rcx, rcx, 8
  0005d	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00065	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 6b d2 07	 imul	 rdx, rdx, 7
  00072	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR requestp$[rsp]
  0007a	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0007f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00085	4d 6b c0 06	 imul	 r8, r8, 6
  00089	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR requestp$[rsp]
  00091	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00096	41 b9 01 00 00
	00		 mov	 r9d, 1
  0009c	4d 6b c9 05	 imul	 r9, r9, 5
  000a0	4c 8b 94 24 60
	01 00 00	 mov	 r10, QWORD PTR requestp$[rsp]
  000a8	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  000ad	41 ba 01 00 00
	00		 mov	 r10d, 1
  000b3	4d 6b d2 04	 imul	 r10, r10, 4
  000b7	4c 8b 9c 24 60
	01 00 00	 mov	 r11, QWORD PTR requestp$[rsp]
  000bf	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  000c4	41 bb 01 00 00
	00		 mov	 r11d, 1
  000ca	4d 6b db 03	 imul	 r11, r11, 3
  000ce	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR requestp$[rsp]
  000d6	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  000db	41 bb 01 00 00
	00		 mov	 r11d, 1
  000e1	4d 6b db 02	 imul	 r11, r11, 2
  000e5	48 8b bc 24 60
	01 00 00	 mov	 rdi, QWORD PTR requestp$[rsp]
  000ed	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  000f2	41 bb 01 00 00
	00		 mov	 r11d, 1
  000f8	4d 6b db 01	 imul	 r11, r11, 1
  000fc	48 8b b4 24 60
	01 00 00	 mov	 rsi, QWORD PTR requestp$[rsp]
  00104	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00109	41 bb 01 00 00
	00		 mov	 r11d, 1
  0010f	4d 6b db 00	 imul	 r11, r11, 0
  00113	48 8b ac 24 60
	01 00 00	 mov	 rbp, QWORD PTR requestp$[rsp]
  0011b	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  00120	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00124	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00128	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  0012c	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  00131	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00136	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  0013b	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0013f	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00143	44 8b ce	 mov	 r9d, esi
  00146	44 8b c5	 mov	 r8d, ebp
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169150
  00150	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR fmtbuf$[rsp]
  00158	e8 00 00 00 00	 call	 sprintf

; 1550 :         requestp[0], requestp[1], requestp[2], requestp[3], requestp[4], requestp[5], requestp[6], requestp[7], requestp[8], requestp[9]);
; 1551 :     sprintf(fmtbuf2, "%02X%02X%02X",

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	48 6b c0 0c	 imul	 rax, rax, 12
  00166	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0016e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00172	b9 01 00 00 00	 mov	 ecx, 1
  00177	48 6b c9 0b	 imul	 rcx, rcx, 11
  0017b	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  00183	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00187	ba 01 00 00 00	 mov	 edx, 1
  0018c	48 6b d2 0a	 imul	 rdx, rdx, 10
  00190	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR requestp$[rsp]
  00198	0f b6 14 13	 movzx	 edx, BYTE PTR [rbx+rdx]
  0019c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001a0	44 8b c9	 mov	 r9d, ecx
  001a3	44 8b c2	 mov	 r8d, edx
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169151
  001ad	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf2$[rsp]
  001b5	e8 00 00 00 00	 call	 sprintf

; 1552 :         requestp[10], requestp[11], requestp[12]);
; 1553 :     len = (requestp[8] << 8) + requestp[9];

  001ba	b8 01 00 00 00	 mov	 eax, 1
  001bf	48 6b c0 08	 imul	 rax, rax, 8
  001c3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  001cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cf	c1 e0 08	 shl	 eax, 8
  001d2	b9 01 00 00 00	 mov	 ecx, 1
  001d7	48 6b c9 09	 imul	 rcx, rcx, 9
  001db	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR requestp$[rsp]
  001e3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001e7	03 c1		 add	 eax, ecx
  001e9	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 1554 :     len -= 3;   /* for len of ru only */

  001ed	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  001f1	83 e8 03	 sub	 eax, 3
  001f4	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 1555 :     sprintf(fmtbuf3, "%02X", requestp[13]);

  001f8	b8 01 00 00 00	 mov	 eax, 1
  001fd	48 6b c0 0d	 imul	 rax, rax, 13
  00201	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00209	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020d	44 8b c0	 mov	 r8d, eax
  00210	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169152
  00217	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf3$[rsp]
  0021f	e8 00 00 00 00	 call	 sprintf

; 1556 :     sprintf(fmtbuf4, "%02X", requestp[14]);

  00224	b8 01 00 00 00	 mov	 eax, 1
  00229	48 6b c0 0e	 imul	 rax, rax, 14
  0022d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00235	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00239	44 8b c0	 mov	 r8d, eax
  0023c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169153
  00243	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf4$[rsp]
  0024b	e8 00 00 00 00	 call	 sprintf

; 1557 :     if (len > 1)

  00250	83 7c 24 78 01	 cmp	 DWORD PTR len$[rsp], 1
  00255	7e 1c		 jle	 SHORT $LN2@format_sna

; 1558 :         STRLCAT( fmtbuf3, fmtbuf4 );

  00257	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0025d	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR fmtbuf4$[rsp]
  00265	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf3$[rsp]
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN2@format_sna:

; 1559 :     sprintf(fmtbuf4, "%02X", requestp[15]);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 0f	 imul	 rax, rax, 15
  0027c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	44 8b c0	 mov	 r8d, eax
  0028b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169155
  00292	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf4$[rsp]
  0029a	e8 00 00 00 00	 call	 sprintf

; 1560 :     if (len > 2)

  0029f	83 7c 24 78 02	 cmp	 DWORD PTR len$[rsp], 2
  002a4	7e 1c		 jle	 SHORT $LN3@format_sna

; 1561 :         STRLCAT( fmtbuf3, fmtbuf4 );

  002a6	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  002ac	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR fmtbuf4$[rsp]
  002b4	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf3$[rsp]
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN3@format_sna:

; 1562 :     if (requestp[13] == 0x11)

  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	48 6b c0 0d	 imul	 rax, rax, 13
  002cb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  002d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d7	83 f8 11	 cmp	 eax, 17
  002da	75 0c		 jne	 SHORT $LN4@format_sna

; 1563 :         ru_type = "ACTPU";

  002dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169158
  002e3	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN4@format_sna:

; 1564 :     if (requestp[13] == 0x0D)

  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	48 6b c0 0d	 imul	 rax, rax, 13
  002f1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  002f9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fd	83 f8 0d	 cmp	 eax, 13
  00300	75 0c		 jne	 SHORT $LN5@format_sna

; 1565 :         ru_type = "ACTLU";

  00302	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169160
  00309	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN5@format_sna:

; 1566 :     if (requestp[13] == 0x0E)

  0030e	b8 01 00 00 00	 mov	 eax, 1
  00313	48 6b c0 0d	 imul	 rax, rax, 13
  00317	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0031f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00323	83 f8 0e	 cmp	 eax, 14
  00326	75 0c		 jne	 SHORT $LN6@format_sna

; 1567 :         ru_type = "DACTLU";

  00328	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169162
  0032f	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN6@format_sna:

; 1568 :     if (requestp[13] == 0x12)

  00334	b8 01 00 00 00	 mov	 eax, 1
  00339	48 6b c0 0d	 imul	 rax, rax, 13
  0033d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00345	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00349	83 f8 12	 cmp	 eax, 18
  0034c	75 0c		 jne	 SHORT $LN7@format_sna

; 1569 :         ru_type = "DACTPU";

  0034e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169164
  00355	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN7@format_sna:

; 1570 :     if (requestp[13] == 0xA0)

  0035a	b8 01 00 00 00	 mov	 eax, 1
  0035f	48 6b c0 0d	 imul	 rax, rax, 13
  00363	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0036b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036f	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00374	75 0c		 jne	 SHORT $LN8@format_sna

; 1571 :         ru_type = "SDT";

  00376	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169166
  0037d	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN8@format_sna:

; 1572 :     if (requestp[13] == 0x31)

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 0d	 imul	 rax, rax, 13
  0038b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	83 f8 31	 cmp	 eax, 49			; 00000031H
  0039a	75 0c		 jne	 SHORT $LN9@format_sna

; 1573 :         ru_type = "BIND";

  0039c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169168
  003a3	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN9@format_sna:

; 1574 :     if (requestp[13] == 0x32)

  003a8	b8 01 00 00 00	 mov	 eax, 1
  003ad	48 6b c0 0d	 imul	 rax, rax, 13
  003b1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  003b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003bd	83 f8 32	 cmp	 eax, 50			; 00000032H
  003c0	75 0c		 jne	 SHORT $LN10@format_sna

; 1575 :         ru_type = "UNBIND";

  003c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169170
  003c9	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN10@format_sna:

; 1576 :     if (!memcmp(&requestp[13], R010201, 3))

  003ce	b8 01 00 00 00	 mov	 eax, 1
  003d3	48 6b c0 0d	 imul	 rax, rax, 13
  003d7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  003df	48 03 c8	 add	 rcx, rax
  003e2	48 8b c1	 mov	 rax, rcx
  003e5	41 b8 03 00 00
	00		 mov	 r8d, 3
  003eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010201
  003f2	48 8b c8	 mov	 rcx, rax
  003f5	e8 00 00 00 00	 call	 memcmp
  003fa	85 c0		 test	 eax, eax
  003fc	75 0c		 jne	 SHORT $LN11@format_sna

; 1577 :         ru_type = "CONTACT";

  003fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169172
  00405	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN11@format_sna:

; 1578 :     if (!memcmp(&requestp[13], R010202, 3))

  0040a	b8 01 00 00 00	 mov	 eax, 1
  0040f	48 6b c0 0d	 imul	 rax, rax, 13
  00413	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0041b	48 03 c8	 add	 rcx, rax
  0041e	48 8b c1	 mov	 rax, rcx
  00421	41 b8 03 00 00
	00		 mov	 r8d, 3
  00427	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010202
  0042e	48 8b c8	 mov	 rcx, rax
  00431	e8 00 00 00 00	 call	 memcmp
  00436	85 c0		 test	 eax, eax
  00438	75 0c		 jne	 SHORT $LN12@format_sna

; 1579 :         ru_type = "DISCONTACT";

  0043a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169174
  00441	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN12@format_sna:

; 1580 :     if (!memcmp(&requestp[13], R010203, 3))

  00446	b8 01 00 00 00	 mov	 eax, 1
  0044b	48 6b c0 0d	 imul	 rax, rax, 13
  0044f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00457	48 03 c8	 add	 rcx, rax
  0045a	48 8b c1	 mov	 rax, rcx
  0045d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00463	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010203
  0046a	48 8b c8	 mov	 rcx, rax
  0046d	e8 00 00 00 00	 call	 memcmp
  00472	85 c0		 test	 eax, eax
  00474	75 0c		 jne	 SHORT $LN13@format_sna

; 1581 :         ru_type = "IPLINIT";

  00476	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169176
  0047d	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN13@format_sna:

; 1582 :     if (!memcmp(&requestp[13], R010204, 3))

  00482	b8 01 00 00 00	 mov	 eax, 1
  00487	48 6b c0 0d	 imul	 rax, rax, 13
  0048b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00493	48 03 c8	 add	 rcx, rax
  00496	48 8b c1	 mov	 rax, rcx
  00499	41 b8 03 00 00
	00		 mov	 r8d, 3
  0049f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010204
  004a6	48 8b c8	 mov	 rcx, rax
  004a9	e8 00 00 00 00	 call	 memcmp
  004ae	85 c0		 test	 eax, eax
  004b0	75 0c		 jne	 SHORT $LN14@format_sna

; 1583 :         ru_type = "IPLTEXT";

  004b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169178
  004b9	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN14@format_sna:

; 1584 :     if (!memcmp(&requestp[13], R010205, 3))

  004be	b8 01 00 00 00	 mov	 eax, 1
  004c3	48 6b c0 0d	 imul	 rax, rax, 13
  004c7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  004cf	48 03 c8	 add	 rcx, rax
  004d2	48 8b c1	 mov	 rax, rcx
  004d5	41 b8 03 00 00
	00		 mov	 r8d, 3
  004db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010205
  004e2	48 8b c8	 mov	 rcx, rax
  004e5	e8 00 00 00 00	 call	 memcmp
  004ea	85 c0		 test	 eax, eax
  004ec	75 0c		 jne	 SHORT $LN15@format_sna

; 1585 :         ru_type = "IPLFINAL";

  004ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169180
  004f5	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN15@format_sna:

; 1586 :     if (!memcmp(&requestp[13], R01020A, 3))

  004fa	b8 01 00 00 00	 mov	 eax, 1
  004ff	48 6b c0 0d	 imul	 rax, rax, 13
  00503	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0050b	48 03 c8	 add	 rcx, rax
  0050e	48 8b c1	 mov	 rax, rcx
  00511	41 b8 03 00 00
	00		 mov	 r8d, 3
  00517	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01020A
  0051e	48 8b c8	 mov	 rcx, rax
  00521	e8 00 00 00 00	 call	 memcmp
  00526	85 c0		 test	 eax, eax
  00528	75 0c		 jne	 SHORT $LN16@format_sna

; 1587 :         ru_type = "ACTLINK";

  0052a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169182
  00531	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN16@format_sna:

; 1588 :     if (!memcmp(&requestp[13], R01020B, 3))

  00536	b8 01 00 00 00	 mov	 eax, 1
  0053b	48 6b c0 0d	 imul	 rax, rax, 13
  0053f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00547	48 03 c8	 add	 rcx, rax
  0054a	48 8b c1	 mov	 rax, rcx
  0054d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00553	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01020B
  0055a	48 8b c8	 mov	 rcx, rax
  0055d	e8 00 00 00 00	 call	 memcmp
  00562	85 c0		 test	 eax, eax
  00564	75 0c		 jne	 SHORT $LN17@format_sna

; 1589 :         ru_type = "DACTLINK";

  00566	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169184
  0056d	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN17@format_sna:

; 1590 :     if (!memcmp(&requestp[13], R010211, 3)) {

  00572	b8 01 00 00 00	 mov	 eax, 1
  00577	48 6b c0 0d	 imul	 rax, rax, 13
  0057b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00583	48 03 c8	 add	 rcx, rax
  00586	48 8b c1	 mov	 rax, rcx
  00589	41 b8 03 00 00
	00		 mov	 r8d, 3
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010211
  00596	48 8b c8	 mov	 rcx, rax
  00599	e8 00 00 00 00	 call	 memcmp
  0059e	85 c0		 test	 eax, eax
  005a0	75 6a		 jne	 SHORT $LN18@format_sna

; 1591 :         sprintf(fmtbuf6, "%s[%02x]", "SETCV", requestp[18]);

  005a2	b8 01 00 00 00	 mov	 eax, 1
  005a7	48 6b c0 12	 imul	 rax, rax, 18
  005ab	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  005b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005b7	44 8b c8	 mov	 r9d, eax
  005ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169186
  005c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169187
  005c8	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf6$[rsp]
  005d0	e8 00 00 00 00	 call	 sprintf

; 1592 :         ru_type = fmtbuf6;

  005d5	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR fmtbuf6$[rsp]
  005dd	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax

; 1593 :         if ((requestp[10] & 0x80) != 0)

  005e2	b8 01 00 00 00	 mov	 eax, 1
  005e7	48 6b c0 0a	 imul	 rax, rax, 10
  005eb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  005f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005f7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005fc	85 c0		 test	 eax, eax
  005fe	74 0c		 je	 SHORT $LN19@format_sna

; 1594 :             ru_type = "SETCV";

  00600	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169189
  00607	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN19@format_sna:
$LN18@format_sna:

; 1595 :     }
; 1596 :     if (!memcmp(&requestp[13], R010280, 3))

  0060c	b8 01 00 00 00	 mov	 eax, 1
  00611	48 6b c0 0d	 imul	 rax, rax, 13
  00615	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0061d	48 03 c8	 add	 rcx, rax
  00620	48 8b c1	 mov	 rax, rcx
  00623	41 b8 03 00 00
	00		 mov	 r8d, 3
  00629	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010280
  00630	48 8b c8	 mov	 rcx, rax
  00633	e8 00 00 00 00	 call	 memcmp
  00638	85 c0		 test	 eax, eax
  0063a	75 0c		 jne	 SHORT $LN20@format_sna

; 1597 :         ru_type = "CONTACTED";

  0063c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169191
  00643	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN20@format_sna:

; 1598 :     if (!memcmp(&requestp[13], R010281, 3))

  00648	b8 01 00 00 00	 mov	 eax, 1
  0064d	48 6b c0 0d	 imul	 rax, rax, 13
  00651	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00659	48 03 c8	 add	 rcx, rax
  0065c	48 8b c1	 mov	 rax, rcx
  0065f	41 b8 03 00 00
	00		 mov	 r8d, 3
  00665	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010281
  0066c	48 8b c8	 mov	 rcx, rax
  0066f	e8 00 00 00 00	 call	 memcmp
  00674	85 c0		 test	 eax, eax
  00676	75 0c		 jne	 SHORT $LN21@format_sna

; 1599 :         ru_type = "INOP";

  00678	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169193
  0067f	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN21@format_sna:

; 1600 :     if (!memcmp(&requestp[13], R010284, 3))

  00684	b8 01 00 00 00	 mov	 eax, 1
  00689	48 6b c0 0d	 imul	 rax, rax, 13
  0068d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00695	48 03 c8	 add	 rcx, rax
  00698	48 8b c1	 mov	 rax, rcx
  0069b	41 b8 03 00 00
	00		 mov	 r8d, 3
  006a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010284
  006a8	48 8b c8	 mov	 rcx, rax
  006ab	e8 00 00 00 00	 call	 memcmp
  006b0	85 c0		 test	 eax, eax
  006b2	75 0c		 jne	 SHORT $LN22@format_sna

; 1601 :         ru_type = "REQCONT";

  006b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169195
  006bb	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN22@format_sna:

; 1602 :     if (!memcmp(&requestp[13], R01021B, 3))

  006c0	b8 01 00 00 00	 mov	 eax, 1
  006c5	48 6b c0 0d	 imul	 rax, rax, 13
  006c9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  006d1	48 03 c8	 add	 rcx, rax
  006d4	48 8b c1	 mov	 rax, rcx
  006d7	41 b8 03 00 00
	00		 mov	 r8d, 3
  006dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01021B
  006e4	48 8b c8	 mov	 rcx, rax
  006e7	e8 00 00 00 00	 call	 memcmp
  006ec	85 c0		 test	 eax, eax
  006ee	75 0c		 jne	 SHORT $LN23@format_sna

; 1603 :         ru_type = "REQDISCONT";

  006f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169197
  006f7	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN23@format_sna:

; 1604 :     if (!memcmp(&requestp[13], R01021A, 3))

  006fc	b8 01 00 00 00	 mov	 eax, 1
  00701	48 6b c0 0d	 imul	 rax, rax, 13
  00705	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  0070d	48 03 c8	 add	 rcx, rax
  00710	48 8b c1	 mov	 rax, rcx
  00713	41 b8 03 00 00
	00		 mov	 r8d, 3
  00719	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01021A
  00720	48 8b c8	 mov	 rcx, rax
  00723	e8 00 00 00 00	 call	 memcmp
  00728	85 c0		 test	 eax, eax
  0072a	75 0c		 jne	 SHORT $LN24@format_sna

; 1605 :         ru_type = "FNA";

  0072c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169199
  00733	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN24@format_sna:

; 1606 :     if (!memcmp(&requestp[13], R01020F, 3))

  00738	b8 01 00 00 00	 mov	 eax, 1
  0073d	48 6b c0 0d	 imul	 rax, rax, 13
  00741	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00749	48 03 c8	 add	 rcx, rax
  0074c	48 8b c1	 mov	 rax, rcx
  0074f	41 b8 03 00 00
	00		 mov	 r8d, 3
  00755	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R01020F
  0075c	48 8b c8	 mov	 rcx, rax
  0075f	e8 00 00 00 00	 call	 memcmp
  00764	85 c0		 test	 eax, eax
  00766	75 0c		 jne	 SHORT $LN25@format_sna

; 1607 :         ru_type = "ABCONN";

  00768	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169201
  0076f	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN25@format_sna:

; 1608 :     if (!memcmp(&requestp[13], R010219, 3))

  00774	b8 01 00 00 00	 mov	 eax, 1
  00779	48 6b c0 0d	 imul	 rax, rax, 13
  0077d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00785	48 03 c8	 add	 rcx, rax
  00788	48 8b c1	 mov	 rax, rcx
  0078b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00791	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010219
  00798	48 8b c8	 mov	 rcx, rax
  0079b	e8 00 00 00 00	 call	 memcmp
  007a0	85 c0		 test	 eax, eax
  007a2	75 0c		 jne	 SHORT $LN26@format_sna

; 1609 :         ru_type = "ANA";

  007a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169203
  007ab	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN26@format_sna:

; 1610 :     if (!memcmp(&requestp[13], R010216, 3))

  007b0	b8 01 00 00 00	 mov	 eax, 1
  007b5	48 6b c0 0d	 imul	 rax, rax, 13
  007b9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  007c1	48 03 c8	 add	 rcx, rax
  007c4	48 8b c1	 mov	 rax, rcx
  007c7	41 b8 03 00 00
	00		 mov	 r8d, 3
  007cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010216
  007d4	48 8b c8	 mov	 rcx, rax
  007d7	e8 00 00 00 00	 call	 memcmp
  007dc	85 c0		 test	 eax, eax
  007de	75 0c		 jne	 SHORT $LN27@format_sna

; 1611 :         ru_type = "ACTCONNIN";

  007e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169205
  007e7	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN27@format_sna:

; 1612 :     if (!memcmp(&requestp[13], R010217, 3))

  007ec	b8 01 00 00 00	 mov	 eax, 1
  007f1	48 6b c0 0d	 imul	 rax, rax, 13
  007f5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  007fd	48 03 c8	 add	 rcx, rax
  00800	48 8b c1	 mov	 rax, rcx
  00803	41 b8 03 00 00
	00		 mov	 r8d, 3
  00809	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:R010217
  00810	48 8b c8	 mov	 rcx, rax
  00813	e8 00 00 00 00	 call	 memcmp
  00818	85 c0		 test	 eax, eax
  0081a	75 0c		 jne	 SHORT $LN28@format_sna

; 1613 :         ru_type = "DACTCONNIN";

  0081c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169207
  00823	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN28@format_sna:

; 1614 :     if ((requestp[10] & 0x08) == 0)

  00828	b8 01 00 00 00	 mov	 eax, 1
  0082d	48 6b c0 0a	 imul	 rax, rax, 10
  00831	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR requestp$[rsp]
  00839	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0083d	83 e0 08	 and	 eax, 8
  00840	85 c0		 test	 eax, eax
  00842	75 0c		 jne	 SHORT $LN29@format_sna

; 1615 :         ru_type = "";

  00844	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169209
  0084b	48 89 44 24 70	 mov	 QWORD PTR ru_type$[rsp], rax
$LN29@format_sna:

; 1616 :     WRMSG(HHC01062,"D",

  00850	0f b7 84 24 78
	01 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00858	89 44 24 7c	 mov	 DWORD PTR tv422[rsp], eax
  0085c	0f b7 8c 24 70
	01 00 00	 movzx	 ecx, WORD PTR ssid$[rsp]
  00864	d1 f9		 sar	 ecx, 1
  00866	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv425[rsp], ecx
  0086d	b9 01 00 00 00	 mov	 ecx, 1
  00872	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00878	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ru_type$[rsp]
  0087d	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00882	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf3$[rsp]
  0088a	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0088f	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR fmtbuf2$[rsp]
  00897	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0089c	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR fmtbuf$[rsp]
  008a4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008a9	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tag$[rsp]
  008b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008b6	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv422[rsp]
  008ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008be	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv425[rsp]
  008c5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169210
  008d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169211
  008dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  008ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169212
  008f3	ba 51 06 00 00	 mov	 edx, 1617		; 00000651H
  008f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169213
  008ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1617 :         SSID_TO_LCSS(ssid), devnum, tag, fmtbuf, fmtbuf2, fmtbuf3, ru_type);
; 1618 : }

  00905	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0090d	48 33 cc	 xor	 rcx, rsp
  00910	e8 00 00 00 00	 call	 __security_check_cookie
  00915	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  0091c	5f		 pop	 rdi
  0091d	5e		 pop	 rsi
  0091e	5d		 pop	 rbp
  0091f	5b		 pop	 rbx
  00920	c3		 ret	 0
format_sna ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
tv75 = 0
tv130 = 4
ca$ = 32
reqptr$ = 40
make_seq PROC

; 1529 : void make_seq (COMMADPT * ca, BYTE * reqptr) {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1530 :     if (reqptr[4] == (ca->locsuba >> 8)) { /* local NCP  */

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 04	 imul	 rax, rax, 4
  00017	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reqptr$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ca$[rsp]
  00025	0f b7 49 54	 movzx	 ecx, WORD PTR [rcx+84]
  00029	c1 f9 08	 sar	 ecx, 8
  0002c	3b c1		 cmp	 eax, ecx
  0002e	75 58		 jne	 SHORT $LN2@make_seq

; 1531 :         reqptr[6] = (unsigned char)(++ca->ncpa_sscp_seqn >> 8) & 0xff;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  00035	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00038	ff c0		 inc	 eax
  0003a	89 04 24	 mov	 DWORD PTR tv75[rsp], eax
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  00042	8b 0c 24	 mov	 ecx, DWORD PTR tv75[rsp]
  00045	89 48 78	 mov	 DWORD PTR [rax+120], ecx
  00048	8b 04 24	 mov	 eax, DWORD PTR tv75[rsp]
  0004b	c1 f8 08	 sar	 eax, 8
  0004e	0f b6 c0	 movzx	 eax, al
  00051	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	48 6b c9 06	 imul	 rcx, rcx, 6
  0005f	48 8b 54 24 28	 mov	 rdx, QWORD PTR reqptr$[rsp]
  00064	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1532 :         reqptr[7] = (unsigned char)(  ca->ncpa_sscp_seqn     ) & 0xff;

  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  0006c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00070	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00075	b9 01 00 00 00	 mov	 ecx, 1
  0007a	48 6b c9 07	 imul	 rcx, rcx, 7
  0007e	48 8b 54 24 28	 mov	 rdx, QWORD PTR reqptr$[rsp]
  00083	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1533 :     } else

  00086	eb 7b		 jmp	 SHORT $LN3@make_seq
$LN2@make_seq:

; 1534 :     if (reqptr[4] == (ca->rmtsuba >> 8)){ /* remote NCP */

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	48 6b c0 04	 imul	 rax, rax, 4
  00091	48 8b 4c 24 28	 mov	 rcx, QWORD PTR reqptr$[rsp]
  00096	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ca$[rsp]
  0009f	0f b7 49 56	 movzx	 ecx, WORD PTR [rcx+86]
  000a3	c1 f9 08	 sar	 ecx, 8
  000a6	3b c1		 cmp	 eax, ecx
  000a8	75 59		 jne	 SHORT $LN4@make_seq

; 1535 :         reqptr[6] = (unsigned char)(++ca->ncpb_sscp_seqn >> 8) & 0xff;

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  000af	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 04	 mov	 DWORD PTR tv130[rsp], eax
  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  000bd	8b 4c 24 04	 mov	 ecx, DWORD PTR tv130[rsp]
  000c1	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  000c4	8b 44 24 04	 mov	 eax, DWORD PTR tv130[rsp]
  000c8	c1 f8 08	 sar	 eax, 8
  000cb	0f b6 c0	 movzx	 eax, al
  000ce	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	48 6b c9 06	 imul	 rcx, rcx, 6
  000dc	48 8b 54 24 28	 mov	 rdx, QWORD PTR reqptr$[rsp]
  000e1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1536 :         reqptr[7] = (unsigned char)(  ca->ncpb_sscp_seqn     ) & 0xff;

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR ca$[rsp]
  000e9	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	48 6b c9 07	 imul	 rcx, rcx, 7
  000fb	48 8b 54 24 28	 mov	 rdx, QWORD PTR reqptr$[rsp]
  00100	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN4@make_seq:
$LN3@make_seq:

; 1537 :     }
; 1538 : }

  00103	48 83 c4 18	 add	 rsp, 24
  00107	c3		 ret	 0
make_seq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
tv71 = 80
tv77 = 84
tv144 = 88
tv150 = 92
dev$ = 112
commadpt_close_device PROC

; 1498 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1499 :     if (dev->ccwtrace)

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00014	c1 e8 0f	 shr	 eax, 15
  00017	83 e0 01	 and	 eax, 1
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 97 00 00
	00		 je	 $LN2@commadpt_c

; 1500 :     {
; 1501 :         // "%1d:%04X COMM: closing down"
; 1502 :         WRMSG( HHC01060, "D", LCSS_DEVNUM );

  00022	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00028	74 0f		 je	 SHORT $LN6@commadpt_c
  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00033	89 44 24 50	 mov	 DWORD PTR tv71[rsp], eax
  00037	eb 08		 jmp	 SHORT $LN7@commadpt_c
$LN6@commadpt_c:
  00039	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN7@commadpt_c:
  00041	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00047	74 11		 je	 SHORT $LN8@commadpt_c
  00049	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0004e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00052	d1 f8		 sar	 eax, 1
  00054	89 44 24 54	 mov	 DWORD PTR tv77[rsp], eax
  00058	eb 08		 jmp	 SHORT $LN9@commadpt_c
$LN8@commadpt_c:
  0005a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN9@commadpt_c:
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006d	8b 4c 24 50	 mov	 ecx, DWORD PTR tv71[rsp]
  00071	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00075	8b 4c 24 54	 mov	 ecx, DWORD PTR tv77[rsp]
  00079	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169107
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169108
  00090	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169109
  000a7	ba de 05 00 00	 mov	 edx, 1502		; 000005deH
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169110
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@commadpt_c:

; 1503 :     }
; 1504 : 
; 1505 :     obtain_lock( &dev->commadpt->lock );

  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000be	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  000c5	48 83 c0 30	 add	 rax, 48			; 00000030H
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169111
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1506 :     {
; 1507 :         /* Terminate current I/O thread if necessary */
; 1508 :         if (dev->busy)

  000d9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000de	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e4	c1 e8 13	 shr	 eax, 19
  000e7	83 e0 01	 and	 eax, 1
  000ea	85 c0		 test	 eax, eax
  000ec	74 0a		 je	 SHORT $LN3@commadpt_c

; 1509 :             commadpt_halt_or_clear( dev );

  000ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000f3	e8 00 00 00 00	 call	 commadpt_halt_or_clear
$LN3@commadpt_c:

; 1510 : 
; 1511 :         free_bufpool( dev->commadpt );

  000f8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000fd	48 8b 88 68 11
	00 00		 mov	 rcx, QWORD PTR [rax+4456]
  00104	e8 00 00 00 00	 call	 free_bufpool

; 1512 :     }
; 1513 :     release_lock( &dev->commadpt->lock );

  00109	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00115	48 83 c0 30	 add	 rax, 48			; 00000030H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169113
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1514 : 
; 1515 :     /* Free all work storage */
; 1516 :     commadpt_clean_device( dev );

  00129	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0012e	e8 00 00 00 00	 call	 commadpt_clean_device

; 1517 : 
; 1518 :     /* Indicate to hercules the device is no longer opened */
; 1519 :     dev->fd = -1;

  00133	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00138	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 1520 : 
; 1521 :     if (dev->ccwtrace)

  00142	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00147	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0014d	c1 e8 0f	 shr	 eax, 15
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	0f 84 97 00 00
	00		 je	 $LN4@commadpt_c

; 1522 :     {
; 1523 :         // "%1d:%04X COMM: closed down"
; 1524 :         WRMSG( HHC01061, "D", LCSS_DEVNUM );

  0015b	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00161	74 0f		 je	 SHORT $LN10@commadpt_c
  00163	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00168	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0016c	89 44 24 58	 mov	 DWORD PTR tv144[rsp], eax
  00170	eb 08		 jmp	 SHORT $LN11@commadpt_c
$LN10@commadpt_c:
  00172	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN11@commadpt_c:
  0017a	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00180	74 11		 je	 SHORT $LN12@commadpt_c
  00182	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00187	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0018b	d1 f8		 sar	 eax, 1
  0018d	89 44 24 5c	 mov	 DWORD PTR tv150[rsp], eax
  00191	eb 08		 jmp	 SHORT $LN13@commadpt_c
$LN12@commadpt_c:
  00193	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN13@commadpt_c:
  0019b	b9 01 00 00 00	 mov	 ecx, 1
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a6	8b 4c 24 58	 mov	 ecx, DWORD PTR tv144[rsp]
  001aa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ae	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv150[rsp]
  001b2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  001bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169116
  001c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169117
  001e0	ba f4 05 00 00	 mov	 edx, 1524		; 000005f4H
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169118
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@commadpt_c:

; 1525 :     }
; 1526 :     return 0;

  001f2	33 c0		 xor	 eax, eax

; 1527 : }

  001f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001f8	c3		 ret	 0
commadpt_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
$T1 = 48
filename$ = 64
__$ArrayPad$ = 336
dev$ = 368
class$ = 376
buflen$ = 384
buffer$ = 392
commadpt_query_device PROC

; 1484 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1485 :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 1486 : 
; 1487 :     BEGIN_DEVICE_CLASS_QUERY( "LINE", dev, class, buflen, buffer );

  0002d	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR class$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@commadpt_q
  00038	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR class$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169094
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@commadpt_q:
  0004a	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@commadpt_q
  00055	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR class$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@commadpt_q
  00060	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@commadpt_q
  0006a	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@commadpt_q
$LN4@commadpt_q:
  00075	e9 ff 00 00 00	 jmp	 $LN1@commadpt_q
$LN3@commadpt_q:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@commadpt_q
  00091	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169100
  000c3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@commadpt_q
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 30
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@commadpt_q
  000ea	eb 05		 jmp	 SHORT $LN10@commadpt_q
$LN9@commadpt_q:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@commadpt_q:
  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 40 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@commadpt_q:
  000fb	eb 22		 jmp	 SHORT $LN6@commadpt_q
$LN5@commadpt_q:
  000fd	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@commadpt_q:

; 1488 : 
; 1489 :     snprintf(buffer,buflen,"Read count=%d, Write count=%d IO[%"PRIu64"]",

  0011f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0012e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00136	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0013d	48 63 94 24 80
	01 00 00	 movsxd	 rdx, DWORD PTR buflen$[rsp]
  00145	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0014d	4d 8b 80 00 06
	00 00		 mov	 r8, QWORD PTR [r8+1536]
  00154	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00159	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0015c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00160	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  00164	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169101
  0016b	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@commadpt_q:
$LN8@commadpt_q:

; 1490 :         dev->commadpt->read_ccw_count, dev->commadpt->write_ccw_count, dev->excps );
; 1491 : }

  00179	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00181	48 33 cc	 xor	 rcx, rsp
  00184	e8 00 00 00 00	 call	 __security_check_cookie
  00189	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00190	c3		 ret	 0
commadpt_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
rc$ = 80
errcnt$ = 84
i$ = 88
tv296 = 92
pc$ = 96
tv78 = 100
tv84 = 104
tv136 = 108
tv142 = 112
tv160 = 116
tv166 = 120
tv252 = 124
tv258 = 128
tv278 = 132
tv284 = 136
tv487 = 140
tv493 = 144
$T1 = 152
$T2 = 160
tv214 = 168
tv226 = 176
tv245 = 184
tv271 = 192
tv705 = 200
tv397 = 208
tv699 = 216
tv462 = 224
tv581 = 232
tv621 = 240
res$ = 256
thread_name2$ = 336
thread_name$ = 368
__$ArrayPad$ = 400
dev$ = 432
argc$ = 440
argv$ = 448
commadpt_init_handler PROC

; 1271 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1272 :     char thread_name[32];
; 1273 :     char thread_name2[32];
; 1274 :     int i;
; 1275 :     int rc;
; 1276 :     int pc; /* Parse code */
; 1277 :     int errcnt;
; 1278 :     union {
; 1279 :         int num;
; 1280 :         char text[MAX_PARSER_STRLEN+1];
; 1281 :     } res;
; 1282 : 
; 1283 :     /* For re-initialisation, close the existing file, if any */
; 1284 :     if (dev->fd >= 0)

  00028	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00030	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00037	7c 1a		 jl	 SHORT $LN13@commadpt_i

; 1285 :         (dev->hnd->close)(dev);

  00039	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00048	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	ff 50 10	 call	 QWORD PTR [rax+16]
$LN13@commadpt_i:

; 1286 : 
; 1287 :     dev->devtype=0x3705;

  00053	b8 05 37 00 00	 mov	 eax, 14085		; 00003705H
  00058	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00060	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 1288 :     dev->excps = 0;

  00064	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 1289 :     if(dev->ccwtrace)

  00077	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00085	c1 e8 0f	 shr	 eax, 15
  00088	83 e0 01	 and	 eax, 1
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 a3 00 00
	00		 je	 $LN14@commadpt_i

; 1290 :     {
; 1291 :         WRMSG(HHC01058,"D",

  00093	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0009c	74 12		 je	 SHORT $LN48@commadpt_i
  0009e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000aa	89 44 24 64	 mov	 DWORD PTR tv78[rsp], eax
  000ae	eb 08		 jmp	 SHORT $LN49@commadpt_i
$LN48@commadpt_i:
  000b0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN49@commadpt_i:
  000b8	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c1	74 14		 je	 SHORT $LN50@commadpt_i
  000c3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000cf	d1 f8		 sar	 eax, 1
  000d1	89 44 24 68	 mov	 DWORD PTR tv84[rsp], eax
  000d5	eb 08		 jmp	 SHORT $LN51@commadpt_i
$LN50@commadpt_i:
  000d7	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN51@commadpt_i:
  000df	b9 01 00 00 00	 mov	 ecx, 1
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ea	8b 4c 24 64	 mov	 ecx, DWORD PTR tv78[rsp]
  000ee	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f2	8b 4c 24 68	 mov	 ecx, DWORD PTR tv84[rsp]
  000f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168986
  00101	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168987
  0010d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168988
  00124	ba 0c 05 00 00	 mov	 edx, 1292		; 0000050cH
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168989
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@commadpt_i:

; 1292 :             LCSS_DEVNUM);
; 1293 :     }
; 1294 : 
; 1295 :     if(dev->commadpt!=NULL)

  00136	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013e	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  00146	74 0d		 je	 SHORT $LN15@commadpt_i

; 1296 :     {
; 1297 :         commadpt_clean_device(dev);

  00148	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00150	e8 00 00 00 00	 call	 commadpt_clean_device
$LN15@commadpt_i:

; 1298 :     }
; 1299 :     rc=commadpt_alloc_device(dev);

  00155	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015d	e8 00 00 00 00	 call	 commadpt_alloc_device
  00162	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1300 :     if(rc<0)

  00166	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0016b	0f 8d ad 00 00
	00		 jge	 $LN16@commadpt_i

; 1301 :     {
; 1302 :         WRMSG(HHC01011, "I", LCSS_DEVNUM);

  00171	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0017a	74 12		 je	 SHORT $LN52@commadpt_i
  0017c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00184	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00188	89 44 24 6c	 mov	 DWORD PTR tv136[rsp], eax
  0018c	eb 08		 jmp	 SHORT $LN53@commadpt_i
$LN52@commadpt_i:
  0018e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN53@commadpt_i:
  00196	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0019f	74 14		 je	 SHORT $LN54@commadpt_i
  001a1	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ad	d1 f8		 sar	 eax, 1
  001af	89 44 24 70	 mov	 DWORD PTR tv142[rsp], eax
  001b3	eb 08		 jmp	 SHORT $LN55@commadpt_i
$LN54@commadpt_i:
  001b5	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN55@commadpt_i:
  001bd	b9 01 00 00 00	 mov	 ecx, 1
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c8	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv136[rsp]
  001cc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001d0	8b 4c 24 70	 mov	 ecx, DWORD PTR tv142[rsp]
  001d4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168992
  001df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168993
  001eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168994
  00202	ba 16 05 00 00	 mov	 edx, 1302		; 00000516H
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168995
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1303 :         return(-1);

  00214	b8 ff ff ff ff	 mov	 eax, -1
  00219	e9 46 0f 00 00	 jmp	 $LN1@commadpt_i
$LN16@commadpt_i:

; 1304 :     }
; 1305 :     if(dev->ccwtrace)

  0021e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00226	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0022c	c1 e8 0f	 shr	 eax, 15
  0022f	83 e0 01	 and	 eax, 1
  00232	85 c0		 test	 eax, eax
  00234	0f 84 a3 00 00
	00		 je	 $LN17@commadpt_i

; 1306 :     {
; 1307 :         WRMSG(HHC01059,"D",

  0023a	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00243	74 12		 je	 SHORT $LN56@commadpt_i
  00245	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00251	89 44 24 74	 mov	 DWORD PTR tv160[rsp], eax
  00255	eb 08		 jmp	 SHORT $LN57@commadpt_i
$LN56@commadpt_i:
  00257	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN57@commadpt_i:
  0025f	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00268	74 14		 je	 SHORT $LN58@commadpt_i
  0026a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00272	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00276	d1 f8		 sar	 eax, 1
  00278	89 44 24 78	 mov	 DWORD PTR tv166[rsp], eax
  0027c	eb 08		 jmp	 SHORT $LN59@commadpt_i
$LN58@commadpt_i:
  0027e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN59@commadpt_i:
  00286	b9 01 00 00 00	 mov	 ecx, 1
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00291	8b 4c 24 74	 mov	 ecx, DWORD PTR tv160[rsp]
  00295	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00299	8b 4c 24 78	 mov	 ecx, DWORD PTR tv166[rsp]
  0029d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  002a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168998
  002b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002be	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168999
  002cb	ba 1c 05 00 00	 mov	 edx, 1308		; 0000051cH
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169000
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@commadpt_i:

; 1308 :             LCSS_DEVNUM);
; 1309 :     }
; 1310 :     errcnt=0;

  002dd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR errcnt$[rsp], 0

; 1311 :     /*
; 1312 :      * Initialise ports & hosts
; 1313 :     */
; 1314 :     dev->commadpt->sfd=-1;

  002e5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  002f4	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1

; 1315 :     dev->commadpt->lport=0;

  002fb	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00303	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0030a	33 c9		 xor	 ecx, ecx
  0030c	66 89 48 10	 mov	 WORD PTR [rax+16], cx

; 1316 :     dev->commadpt->debug_sna=0;

  00310	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00318	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0031f	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00322	0f ba f0 09	 btr	 eax, 9
  00326	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0032e	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00335	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1317 :     dev->commadpt->emu3791=0;

  00338	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00340	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00347	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0034a	0f ba f0 0a	 btr	 eax, 10
  0034e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00356	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0035d	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1318 :     dev->commadpt->locsuba = 0x3800;              /* local  subarea = 7 (maxsuba=31)        */

  00360	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00368	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0036f	b9 00 38 00 00	 mov	 ecx, 14336		; 00003800H
  00374	66 89 48 54	 mov	 WORD PTR [rax+84], cx

; 1319 :     dev->commadpt->rmtsuba = 0x4000;              /* remote subarea = 8 (maxsuba=31)        */

  00378	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00380	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00387	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0038c	66 89 48 56	 mov	 WORD PTR [rax+86], cx

; 1320 :     strcpy(dev->commadpt->locncpnm,"MHP3705 ");   /* local  NCP name                        */

  00390	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00398	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0039f	48 83 c0 40	 add	 rax, 64			; 00000040H
  003a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169001
  003aa	48 8b c8	 mov	 rcx, rax
  003ad	e8 00 00 00 00	 call	 strcpy

; 1321 :     strcpy(dev->commadpt->rmtncpnm,"MHPRMT1 ");   /* remote NCP name                        */

  003b2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ba	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003c1	48 83 c0 49	 add	 rax, 73			; 00000049H
  003c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169002
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 strcpy

; 1322 :     prt_host_to_guest((BYTE*) dev->commadpt->locncpnm, (BYTE*) dev->commadpt->locncpnm, strlen(dev->commadpt->locncpnm)); /* convert to EBCDIC */

  003d4	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  003e3	48 83 c0 40	 add	 rax, 64			; 00000040H
  003e7	48 8b c8	 mov	 rcx, rax
  003ea	e8 00 00 00 00	 call	 strlen
  003ef	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f7	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  003fe	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00402	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0040a	48 8b 92 68 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4456]
  00411	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00415	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv214[rsp], rdx
  0041d	44 8b c0	 mov	 r8d, eax
  00420	48 8b d1	 mov	 rdx, rcx
  00423	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv214[rsp]
  0042b	48 8b c8	 mov	 rcx, rax
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest

; 1323 :     prt_host_to_guest((BYTE*) dev->commadpt->rmtncpnm, (BYTE*) dev->commadpt->rmtncpnm, strlen(dev->commadpt->rmtncpnm)); /* convert to EBCDIC */

  00434	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043c	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00443	48 83 c0 49	 add	 rax, 73			; 00000049H
  00447	48 8b c8	 mov	 rcx, rax
  0044a	e8 00 00 00 00	 call	 strlen
  0044f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00457	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0045e	48 83 c1 49	 add	 rcx, 73			; 00000049H
  00462	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0046a	48 8b 92 68 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4456]
  00471	48 83 c2 49	 add	 rdx, 73			; 00000049H
  00475	48 89 94 24 b0
	00 00 00	 mov	 QWORD PTR tv226[rsp], rdx
  0047d	44 8b c0	 mov	 r8d, eax
  00480	48 8b d1	 mov	 rdx, rcx
  00483	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv226[rsp]
  0048b	48 8b c8	 mov	 rcx, rax
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest

; 1324 :     dev->commadpt->idblk = 0x17;                  /* IDBLK of switched PU (default=0x017)   */

  00494	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0049c	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  004a3	c7 40 5c 17 00
	00 00		 mov	 DWORD PTR [rax+92], 23

; 1325 :     dev->commadpt->idnum = 0x17;                  /* IDNUM of switched PU (default=0x00017) */

  004aa	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004b2	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  004b9	c7 40 60 17 00
	00 00		 mov	 DWORD PTR [rax+96], 23

; 1326 :     dev->commadpt->unitsz = 256;                  /* I/O blocksize (must equal RRT KEYLN)   */

  004c0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c8	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  004cf	c7 80 8c 00 01
	00 00 01 00 00	 mov	 DWORD PTR [rax+65676], 256 ; 00000100H

; 1327 :                                                   /* unitsz=256 is invalid for TCAM and     */
; 1328 :                                                   /* instable for VTAM. Default retained    */
; 1329 :                                                   /* for compatibility with previous        */
; 1330 :                                                   /* versions only.                         */
; 1331 :     dev->commadpt->ackspeed = 0;                  /* choose Max's original attn algorithm   */

  004d9	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e1	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  004e8	c7 80 90 00 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+65680], 0

; 1332 :     for(i=0;i<argc;i++)

  004f2	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004fa	eb 0a		 jmp	 SHORT $LN4@commadpt_i
$LN2@commadpt_i:
  004fc	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00500	ff c0		 inc	 eax
  00502	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN4@commadpt_i:
  00506	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0050d	39 44 24 58	 cmp	 DWORD PTR i$[rsp], eax
  00511	0f 8d c6 06 00
	00		 jge	 $LN3@commadpt_i

; 1333 :     {
; 1334 :         pc=parser(ptab,argv[i],&res);

  00517	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  0051c	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR res$[rsp]
  00524	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0052c	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00530	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptab
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parser
  0053d	89 44 24 60	 mov	 DWORD PTR pc$[rsp], eax

; 1335 :         if(pc<0)

  00541	83 7c 24 60 00	 cmp	 DWORD PTR pc$[rsp], 0
  00546	0f 8d e1 00 00
	00		 jge	 $LN18@commadpt_i

; 1336 :         {
; 1337 :             WRMSG(HHC01012, "E",LCSS_DEVNUM,argv[i]);

  0054c	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00555	74 12		 je	 SHORT $LN60@commadpt_i
  00557	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0055f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00563	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
  00567	eb 08		 jmp	 SHORT $LN61@commadpt_i
$LN60@commadpt_i:
  00569	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN61@commadpt_i:
  00571	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0057a	74 17		 je	 SHORT $LN62@commadpt_i
  0057c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00584	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00588	d1 f8		 sar	 eax, 1
  0058a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv258[rsp], eax
  00591	eb 0b		 jmp	 SHORT $LN63@commadpt_i
$LN62@commadpt_i:
  00593	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv258[rsp], 0
$LN63@commadpt_i:
  0059e	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  005a3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv245[rsp], rax
  005ab	b9 01 00 00 00	 mov	 ecx, 1
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b6	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005be	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv245[rsp]
  005c6	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  005ca	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005cf	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv252[rsp]
  005d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005d7	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  005de	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169004
  005e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169005
  005f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00605	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169006
  0060c	ba 39 05 00 00	 mov	 edx, 1337		; 00000539H
  00611	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169007
  00618	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1338 :             errcnt++;

  0061e	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  00622	ff c0		 inc	 eax
  00624	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax

; 1339 :             continue;

  00628	e9 cf fe ff ff	 jmp	 $LN2@commadpt_i
$LN18@commadpt_i:

; 1340 :         }
; 1341 :         if(pc==0)

  0062d	83 7c 24 60 00	 cmp	 DWORD PTR pc$[rsp], 0
  00632	0f 85 ea 00 00
	00		 jne	 $LN19@commadpt_i

; 1342 :         {
; 1343 :             WRMSG(HHC01019, "E",LCSS_DEVNUM,argv[i]);

  00638	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00641	74 15		 je	 SHORT $LN64@commadpt_i
  00643	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0064b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0064f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv278[rsp], eax
  00656	eb 0b		 jmp	 SHORT $LN65@commadpt_i
$LN64@commadpt_i:
  00658	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv278[rsp], 0
$LN65@commadpt_i:
  00663	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0066c	74 17		 je	 SHORT $LN66@commadpt_i
  0066e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00676	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0067a	d1 f8		 sar	 eax, 1
  0067c	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
  00683	eb 0b		 jmp	 SHORT $LN67@commadpt_i
$LN66@commadpt_i:
  00685	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv284[rsp], 0
$LN67@commadpt_i:
  00690	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00695	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  0069d	b9 01 00 00 00	 mov	 ecx, 1
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a8	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006b0	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv271[rsp]
  006b8	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  006bc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006c1	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  006c8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006cc	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  006d3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169009
  006de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169010
  006ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  006fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169011
  00701	ba 3f 05 00 00	 mov	 edx, 1343		; 0000053fH
  00706	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169012
  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1344 :             errcnt++;

  00713	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  00717	ff c0		 inc	 eax
  00719	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax

; 1345 :             continue;

  0071d	e9 da fd ff ff	 jmp	 $LN2@commadpt_i
$LN19@commadpt_i:

; 1346 :         }
; 1347 :         switch(pc)

  00722	8b 44 24 60	 mov	 eax, DWORD PTR pc$[rsp]
  00726	89 44 24 5c	 mov	 DWORD PTR tv296[rsp], eax
  0072a	8b 44 24 5c	 mov	 eax, DWORD PTR tv296[rsp]
  0072e	ff c8		 dec	 eax
  00730	89 44 24 5c	 mov	 DWORD PTR tv296[rsp], eax
  00734	83 7c 24 5c 13	 cmp	 DWORD PTR tv296[rsp], 19
  00739	0f 87 99 04 00
	00		 ja	 $LN40@commadpt_i
  0073f	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv296[rsp]
  00744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0074b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN76@commadpt_i[rcx+rax*4]
  00752	48 03 c1	 add	 rax, rcx
  00755	ff e0		 jmp	 rax
$LN20@commadpt_i:

; 1348 :         {
; 1349 :             case COMMADPT_KW_DEBUG:
; 1350 :                 if (res.text[0] == 'y' || res.text[0] == 'Y')

  00757	b8 01 00 00 00	 mov	 eax, 1
  0075c	48 6b c0 00	 imul	 rax, rax, 0
  00760	0f be 84 04 00
	01 00 00	 movsx	 eax, BYTE PTR res$[rsp+rax]
  00768	83 f8 79	 cmp	 eax, 121		; 00000079H
  0076b	74 16		 je	 SHORT $LN23@commadpt_i
  0076d	b8 01 00 00 00	 mov	 eax, 1
  00772	48 6b c0 00	 imul	 rax, rax, 0
  00776	0f be 84 04 00
	01 00 00	 movsx	 eax, BYTE PTR res$[rsp+rax]
  0077e	83 f8 59	 cmp	 eax, 89			; 00000059H
  00781	75 2a		 jne	 SHORT $LN21@commadpt_i
$LN23@commadpt_i:

; 1351 :                     dev->commadpt->debug_sna = 1;

  00783	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0078b	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00792	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00795	0f ba e8 09	 bts	 eax, 9
  00799	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007a1	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  007a8	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  007ab	eb 28		 jmp	 SHORT $LN22@commadpt_i
$LN21@commadpt_i:

; 1352 :                 else
; 1353 :                     dev->commadpt->debug_sna = 0;

  007ad	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007b5	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  007bc	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  007bf	0f ba f0 09	 btr	 eax, 9
  007c3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007cb	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  007d2	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN22@commadpt_i:

; 1354 :                 break;

  007d5	e9 fe 03 00 00	 jmp	 $LN5@commadpt_i
$LN24@commadpt_i:

; 1355 :             case COMMADPT_KW_LPORT:
; 1356 :                 rc=commadpt_getport(res.text);

  007da	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  007e2	e8 00 00 00 00	 call	 commadpt_getport
  007e7	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1357 :                 if(rc<0)

  007eb	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  007f0	7d 2b		 jge	 SHORT $LN25@commadpt_i

; 1358 :                 {
; 1359 :                     errcnt++;

  007f2	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  007f6	ff c0		 inc	 eax
  007f8	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax

; 1360 :                     msg013e(dev,"LPORT",res.text);

  007fc	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR res$[rsp]
  00804	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169019
  0080b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00813	e8 00 00 00 00	 call	 msg013e

; 1361 :                     break;

  00818	e9 bb 03 00 00	 jmp	 $LN5@commadpt_i
$LN25@commadpt_i:

; 1362 :                 }
; 1363 :                 dev->commadpt->lport=rc;

  0081d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00825	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0082c	0f b7 4c 24 50	 movzx	 ecx, WORD PTR rc$[rsp]
  00831	66 89 48 10	 mov	 WORD PTR [rax+16], cx

; 1364 :                 break;

  00835	e9 9e 03 00 00	 jmp	 $LN5@commadpt_i
$LN26@commadpt_i:

; 1365 :             case COMMADPT_KW_LHOST:
; 1366 :                 if(strcmp(res.text,"*")==0)

  0083a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169022
  00841	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00849	e8 00 00 00 00	 call	 strcmp
  0084e	85 c0		 test	 eax, eax
  00850	75 1b		 jne	 SHORT $LN27@commadpt_i

; 1367 :                 {
; 1368 :                     dev->commadpt->lhost=INADDR_ANY;

  00852	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0085a	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00861	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 1369 :                     break;

  00868	e9 6b 03 00 00	 jmp	 $LN5@commadpt_i
$LN27@commadpt_i:

; 1370 :                 }
; 1371 :                 rc=commadpt_getaddr(&dev->commadpt->lhost,res.text);

  0086d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00875	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0087c	48 83 c0 14	 add	 rax, 20
  00880	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR res$[rsp]
  00888	48 8b c8	 mov	 rcx, rax
  0088b	e8 00 00 00 00	 call	 commadpt_getaddr
  00890	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1372 :                 if(rc!=0)

  00894	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00899	74 26		 je	 SHORT $LN28@commadpt_i

; 1373 :                 {
; 1374 :                     msg013e(dev,"LHOST",res.text);

  0089b	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR res$[rsp]
  008a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169024
  008aa	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008b2	e8 00 00 00 00	 call	 msg013e

; 1375 :                     errcnt++;

  008b7	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  008bb	ff c0		 inc	 eax
  008bd	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax
$LN28@commadpt_i:

; 1376 :                 }
; 1377 :                 break;

  008c1	e9 12 03 00 00	 jmp	 $LN5@commadpt_i
$LN29@commadpt_i:

; 1378 :             case COMMADPT_KW_EMU3791:
; 1379 :                 if(strcasecmp(res.text,"yes")==0 || strcmp(res.text,"1"))

  008c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169028
  008cd	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  008d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  008db	85 c0		 test	 eax, eax
  008dd	74 18		 je	 SHORT $LN31@commadpt_i
  008df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169029
  008e6	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  008ee	e8 00 00 00 00	 call	 strcmp
  008f3	85 c0		 test	 eax, eax
  008f5	74 28		 je	 SHORT $LN30@commadpt_i
$LN31@commadpt_i:

; 1380 :                     dev->commadpt->emu3791=1;

  008f7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008ff	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00906	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00909	0f ba e8 0a	 bts	 eax, 10
  0090d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00915	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0091c	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN30@commadpt_i:

; 1381 :                 break;

  0091f	e9 b4 02 00 00	 jmp	 $LN5@commadpt_i
$LN32@commadpt_i:

; 1382 :             case COMMADPT_KW_LOCSUBA:
; 1383 :                     dev->commadpt->locsuba = (atoi(res.text)<<11); /* (maxsuba=31) */

  00924	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  0092c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00932	c1 e0 0b	 shl	 eax, 11
  00935	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0093d	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00944	66 89 41 54	 mov	 WORD PTR [rcx+84], ax

; 1384 :                 break;

  00948	e9 8b 02 00 00	 jmp	 $LN5@commadpt_i
$LN33@commadpt_i:

; 1385 :             case COMMADPT_KW_RMTSUBA:
; 1386 :                     dev->commadpt->rmtsuba = (atoi(res.text)<<11); /* (maxsuba=31) */

  0094d	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00955	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0095b	c1 e0 0b	 shl	 eax, 11
  0095e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00966	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0096d	66 89 41 56	 mov	 WORD PTR [rcx+86], ax

; 1387 :                 break;

  00971	e9 62 02 00 00	 jmp	 $LN5@commadpt_i
$LN34@commadpt_i:

; 1388 :             case COMMADPT_KW_LOCNCPNM:
; 1389 :                     strcpy(dev->commadpt->locncpnm,"        ");

  00976	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0097e	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00985	48 83 c0 40	 add	 rax, 64			; 00000040H
  00989	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169033
  00990	48 8b c8	 mov	 rcx, rax
  00993	e8 00 00 00 00	 call	 strcpy

; 1390 :                     strcpy(dev->commadpt->locncpnm,res.text);

  00998	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009a0	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  009a7	48 83 c0 40	 add	 rax, 64			; 00000040H
  009ab	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR res$[rsp]
  009b3	48 8b c8	 mov	 rcx, rax
  009b6	e8 00 00 00 00	 call	 strcpy

; 1391 :                     memcpy(&dev->commadpt->locncpnm[strlen(res.text)]," ",1);

  009bb	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009c3	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  009ca	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv705[rsp], rax
  009d2	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  009da	e8 00 00 00 00	 call	 strlen
  009df	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR $SG169034
  009e6	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv705[rsp]
  009ee	88 4c 02 40	 mov	 BYTE PTR [rdx+rax+64], cl

; 1392 :                     prt_host_to_guest((BYTE*) dev->commadpt->locncpnm, (BYTE*) dev->commadpt->locncpnm, strlen(dev->commadpt->locncpnm));

  009f2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009fa	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00a01	48 83 c0 40	 add	 rax, 64			; 00000040H
  00a05	48 8b c8	 mov	 rcx, rax
  00a08	e8 00 00 00 00	 call	 strlen
  00a0d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a15	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00a1c	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00a20	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00a28	48 8b 92 68 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4456]
  00a2f	48 83 c2 40	 add	 rdx, 64			; 00000040H
  00a33	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv397[rsp], rdx
  00a3b	44 8b c0	 mov	 r8d, eax
  00a3e	48 8b d1	 mov	 rdx, rcx
  00a41	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv397[rsp]
  00a49	48 8b c8	 mov	 rcx, rax
  00a4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest

; 1393 :                 break;

  00a52	e9 81 01 00 00	 jmp	 $LN5@commadpt_i
$LN35@commadpt_i:

; 1394 :             case COMMADPT_KW_RMTNCPNM:
; 1395 :                     strcpy(dev->commadpt->rmtncpnm,"        ");

  00a57	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a5f	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00a66	48 83 c0 49	 add	 rax, 73			; 00000049H
  00a6a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169036
  00a71	48 8b c8	 mov	 rcx, rax
  00a74	e8 00 00 00 00	 call	 strcpy

; 1396 :                     strcpy(dev->commadpt->rmtncpnm,res.text);

  00a79	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a81	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00a88	48 83 c0 49	 add	 rax, 73			; 00000049H
  00a8c	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR res$[rsp]
  00a94	48 8b c8	 mov	 rcx, rax
  00a97	e8 00 00 00 00	 call	 strcpy

; 1397 :                     memcpy(&dev->commadpt->rmtncpnm[strlen(res.text)]," ",1);

  00a9c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00aa4	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00aab	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv699[rsp], rax
  00ab3	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00abb	e8 00 00 00 00	 call	 strlen
  00ac0	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR $SG169037
  00ac7	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv699[rsp]
  00acf	88 4c 02 49	 mov	 BYTE PTR [rdx+rax+73], cl

; 1398 :                     prt_host_to_guest((BYTE*) dev->commadpt->rmtncpnm, (BYTE*) dev->commadpt->rmtncpnm, strlen(dev->commadpt->rmtncpnm));

  00ad3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00adb	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00ae2	48 83 c0 49	 add	 rax, 73			; 00000049H
  00ae6	48 8b c8	 mov	 rcx, rax
  00ae9	e8 00 00 00 00	 call	 strlen
  00aee	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00af6	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00afd	48 83 c1 49	 add	 rcx, 73			; 00000049H
  00b01	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00b09	48 8b 92 68 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4456]
  00b10	48 83 c2 49	 add	 rdx, 73			; 00000049H
  00b14	48 89 94 24 e0
	00 00 00	 mov	 QWORD PTR tv462[rsp], rdx
  00b1c	44 8b c0	 mov	 r8d, eax
  00b1f	48 8b d1	 mov	 rdx, rcx
  00b22	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv462[rsp]
  00b2a	48 8b c8	 mov	 rcx, rax
  00b2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest

; 1399 :                 break;

  00b33	e9 a0 00 00 00	 jmp	 $LN5@commadpt_i
$LN36@commadpt_i:

; 1400 :             case COMMADPT_KW_IDBLK:
; 1401 :                     sscanf(res.text,"%3x",&dev->commadpt->idblk);

  00b38	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b40	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00b47	48 83 c0 5c	 add	 rax, 92			; 0000005cH
  00b4b	4c 8b c0	 mov	 r8, rax
  00b4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169039
  00b55	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00b5d	e8 00 00 00 00	 call	 sscanf

; 1402 :                 break;

  00b62	eb 74		 jmp	 SHORT $LN5@commadpt_i
$LN37@commadpt_i:

; 1403 :             case COMMADPT_KW_IDNUM:
; 1404 :                     sscanf(res.text,"%5x",&dev->commadpt->idnum);

  00b64	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b6c	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00b73	48 83 c0 60	 add	 rax, 96			; 00000060H
  00b77	4c 8b c0	 mov	 r8, rax
  00b7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169041
  00b81	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00b89	e8 00 00 00 00	 call	 sscanf

; 1405 :                 break;

  00b8e	eb 48		 jmp	 SHORT $LN5@commadpt_i
$LN38@commadpt_i:

; 1406 :             case COMMADPT_KW_UNITSZ:
; 1407 :                     dev->commadpt->unitsz = atoi(res.text);

  00b90	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00b98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b9e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ba6	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00bad	89 81 8c 00 01
	00		 mov	 DWORD PTR [rcx+65676], eax

; 1408 :                 break;

  00bb3	eb 23		 jmp	 SHORT $LN5@commadpt_i
$LN39@commadpt_i:

; 1409 :             case COMMADPT_KW_ACKSPEED:
; 1410 :                     dev->commadpt->ackspeed = atoi(res.text);

  00bb5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR res$[rsp]
  00bbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00bc3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bcb	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00bd2	89 81 90 00 01
	00		 mov	 DWORD PTR [rcx+65680], eax
$LN40@commadpt_i:
$LN5@commadpt_i:

; 1411 :                 break;
; 1412 :             default:
; 1413 :                 break;
; 1414 :         }
; 1415 :     }

  00bd8	e9 1f f9 ff ff	 jmp	 $LN2@commadpt_i
$LN3@commadpt_i:

; 1416 :     if(errcnt>0)

  00bdd	83 7c 24 54 00	 cmp	 DWORD PTR errcnt$[rsp], 0
  00be2	0f 8e bf 00 00
	00		 jle	 $LN41@commadpt_i

; 1417 :     {
; 1418 :         WRMSG(HHC01014, "I",LCSS_DEVNUM);

  00be8	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00bf1	74 15		 je	 SHORT $LN68@commadpt_i
  00bf3	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bfb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00bff	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv487[rsp], eax
  00c06	eb 0b		 jmp	 SHORT $LN69@commadpt_i
$LN68@commadpt_i:
  00c08	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv487[rsp], 0
$LN69@commadpt_i:
  00c13	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c1c	74 17		 je	 SHORT $LN70@commadpt_i
  00c1e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c26	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00c2a	d1 f8		 sar	 eax, 1
  00c2c	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv493[rsp], eax
  00c33	eb 0b		 jmp	 SHORT $LN71@commadpt_i
$LN70@commadpt_i:
  00c35	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv493[rsp], 0
$LN71@commadpt_i:
  00c40	b9 01 00 00 00	 mov	 ecx, 1
  00c45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c4b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv487[rsp]
  00c52	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c56	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv493[rsp]
  00c5d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169046
  00c68	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169047
  00c74	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c79	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c7e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c84	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169048
  00c8b	ba 8a 05 00 00	 mov	 edx, 1418		; 0000058aH
  00c90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169049
  00c97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1419 :         return -1;

  00c9d	b8 ff ff ff ff	 mov	 eax, -1
  00ca2	e9 bd 04 00 00	 jmp	 $LN1@commadpt_i
$LN41@commadpt_i:

; 1420 :     }
; 1421 :     dev->bufsize=dev->commadpt->unitsz;

  00ca7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00caf	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00cb6	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cbe	8b 80 8c 00 01
	00		 mov	 eax, DWORD PTR [rax+65676]
  00cc4	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 1422 :     dev->numsense=2;

  00cca	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cd2	c7 80 60 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+864], 2

; 1423 :     memset(dev->sense,0,sizeof(dev->sense));

  00cdc	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ce4	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00cea	48 8b f8	 mov	 rdi, rax
  00ced	33 c0		 xor	 eax, eax
  00cef	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00cf4	f3 aa		 rep stosb

; 1424 : 
; 1425 :     init_bufpool(dev->commadpt);

  00cf6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cfe	48 8b 88 68 11
	00 00		 mov	 rcx, QWORD PTR [rax+4456]
  00d05	e8 00 00 00 00	 call	 init_bufpool

; 1426 : 
; 1427 :     dev->commadpt->devnum=dev->devnum;

  00d0a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d12	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00d19	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d21	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00d25	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 1428 : 
; 1429 :     /* Initialize the CA lock */
; 1430 :     initialize_lock(&dev->commadpt->lock);

  00d29	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d31	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00d38	48 83 c0 30	 add	 rax, 48			; 00000030H
  00d3c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169050
  00d43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169051
  00d4a	48 8b c8	 mov	 rcx, rax
  00d4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1431 : 
; 1432 :     /* Initialise thread->I/O & halt initiation EVB */
; 1433 :     initialize_condition(&dev->commadpt->ipc);

  00d53	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d5b	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00d62	48 83 c0 20	 add	 rax, 32			; 00000020H
  00d66	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169052
  00d6d	48 8b c8	 mov	 rcx, rax
  00d70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1434 :     initialize_condition(&dev->commadpt->ipc_halt);

  00d76	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d7e	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00d85	48 83 c0 28	 add	 rax, 40			; 00000028H
  00d89	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169053
  00d90	48 8b c8	 mov	 rcx, rax
  00d93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition
$LN9@commadpt_i:

; 1435 : 
; 1436 :     /* Allocate I/O -> Thread signaling pipe */
; 1437 :     VERIFY(!create_pipe(dev->commadpt->pipe));

  00d99	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00da1	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00da8	48 83 c0 38	 add	 rax, 56			; 00000038H
  00dac	4c 8b c8	 mov	 r9, rax
  00daf	45 33 c0	 xor	 r8d, r8d
  00db2	ba 01 00 00 00	 mov	 edx, 1
  00db7	b9 02 00 00 00	 mov	 ecx, 2
  00dbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socketpair
  00dc2	85 c0		 test	 eax, eax
  00dc4	74 5c		 je	 SHORT $LN42@commadpt_i
$LN12@commadpt_i:
  00dc6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169055
  00dcd	41 b8 9d 05 00
	00		 mov	 r8d, 1437		; 0000059dH
  00dd3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169056
  00dda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169057
  00de1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00de7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ded	85 c0		 test	 eax, eax
  00def	74 20		 je	 SHORT $LN43@commadpt_i
  00df1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169059
  00df8	41 b8 9d 05 00
	00		 mov	 r8d, 1437		; 0000059dH
  00dfe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169060
  00e05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169061
  00e0c	e8 00 00 00 00	 call	 DebuggerTrace
$LN43@commadpt_i:
  00e11	33 c0		 xor	 eax, eax
  00e13	85 c0		 test	 eax, eax
  00e15	75 af		 jne	 SHORT $LN12@commadpt_i
  00e17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e1d	85 c0		 test	 eax, eax
  00e1f	74 01		 je	 SHORT $LN44@commadpt_i
  00e21	cc		 int	 3
$LN44@commadpt_i:
$LN42@commadpt_i:
  00e22	33 c0		 xor	 eax, eax
  00e24	85 c0		 test	 eax, eax
  00e26	0f 85 6d ff ff
	ff		 jne	 $LN9@commadpt_i

; 1438 : 
; 1439 :     /* Obtain the CA lock */
; 1440 :     obtain_lock(&dev->commadpt->lock);

  00e2c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e34	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00e3b	48 83 c0 30	 add	 rax, 48			; 00000030H
  00e3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169063
  00e46	48 8b c8	 mov	 rcx, rax
  00e49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1441 : 
; 1442 :     /* Start the telnet worker thread */
; 1443 : 
; 1444 :     /* Set thread-name for debugging purposes */
; 1445 :     MSGBUF(thread_name2,

  00e4f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e57	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e5b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e63	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00e67	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00e6b	44 8b c9	 mov	 r9d, ecx
  00e6e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169064
  00e75	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00e7a	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR thread_name2$[rsp]
  00e82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1446 :         "commadpt %1d:%04X thread2",dev->ssid,dev->devnum);
; 1447 :     thread_name2[sizeof(thread_name2)-1]=0;

  00e88	b8 01 00 00 00	 mov	 eax, 1
  00e8d	48 6b c0 1f	 imul	 rax, rax, 31
  00e91	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00e99	48 83 bc 24 98
	00 00 00 20	 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00ea2	73 02		 jae	 SHORT $LN72@commadpt_i
  00ea4	eb 05		 jmp	 SHORT $LN73@commadpt_i
$LN72@commadpt_i:
  00ea6	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN73@commadpt_i:
  00eab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00eb3	c6 84 04 50 01
	00 00 00	 mov	 BYTE PTR thread_name2$[rsp+rax], 0

; 1448 : 
; 1449 :     rc = create_thread(&dev->commadpt->tthread,&sysblk.detattr,telnet_thread,dev->commadpt,thread_name2);

  00ebb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ec2	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00ec8	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ed0	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  00ed7	48 83 c1 0c	 add	 rcx, 12
  00edb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169065
  00ee2	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00ee7	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR thread_name2$[rsp]
  00eef	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00ef4	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00efc	4c 8b 8a 68 11
	00 00		 mov	 r9, QWORD PTR [rdx+4456]
  00f03	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:telnet_thread
  00f0a	48 8b d0	 mov	 rdx, rax
  00f0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00f13	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1450 :     if(rc)

  00f17	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00f1c	0f 84 93 00 00
	00		 je	 $LN45@commadpt_i

; 1451 :     {
; 1452 :         WRMSG(HHC00102, "E" ,strerror(rc));

  00f22	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00f26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f2c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv581[rsp], rax
  00f34	b9 01 00 00 00	 mov	 ecx, 1
  00f39	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f3f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv581[rsp]
  00f47	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169067
  00f53	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169068
  00f5f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f64	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f69	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f6f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169069
  00f76	ba ac 05 00 00	 mov	 edx, 1452		; 000005acH
  00f7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169070
  00f82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1453 :         release_lock(&dev->commadpt->lock);

  00f88	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f90	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00f97	48 83 c0 30	 add	 rax, 48			; 00000030H
  00f9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169071
  00fa2	48 8b c8	 mov	 rcx, rax
  00fa5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1454 :         return -1;

  00fab	b8 ff ff ff ff	 mov	 eax, -1
  00fb0	e9 af 01 00 00	 jmp	 $LN1@commadpt_i
$LN45@commadpt_i:

; 1455 :     }
; 1456 : 
; 1457 :     /* Start the async worker thread */
; 1458 : 
; 1459 :     /* Set thread-name for debugging purposes */
; 1460 :     MSGBUF(thread_name,

  00fb5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fbd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00fc1	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fc9	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00fcd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00fd1	44 8b c9	 mov	 r9d, ecx
  00fd4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169072
  00fdb	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00fe0	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  00fe8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1461 :         "commadpt %1d:%04X thread",dev->ssid,dev->devnum);
; 1462 :     thread_name[sizeof(thread_name)-1]=0;

  00fee	b8 01 00 00 00	 mov	 eax, 1
  00ff3	48 6b c0 1f	 imul	 rax, rax, 31
  00ff7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00fff	48 83 bc 24 a0
	00 00 00 20	 cmp	 QWORD PTR $T2[rsp], 32	; 00000020H
  01008	73 02		 jae	 SHORT $LN74@commadpt_i
  0100a	eb 05		 jmp	 SHORT $LN75@commadpt_i
$LN74@commadpt_i:
  0100c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN75@commadpt_i:
  01011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  01019	c6 84 04 70 01
	00 00 00	 mov	 BYTE PTR thread_name$[rsp+rax], 0

; 1463 : 
; 1464 :     rc = create_thread(&dev->commadpt->cthread,&sysblk.detattr,commadpt_thread,dev->commadpt,thread_name);

  01021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01028	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0102e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01036	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0103d	48 83 c1 08	 add	 rcx, 8
  01041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169073
  01048	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0104d	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  01055	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0105a	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01062	4c 8b 8a 68 11
	00 00		 mov	 r9, QWORD PTR [rdx+4456]
  01069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:commadpt_thread
  01070	48 8b d0	 mov	 rdx, rax
  01073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  01079	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1465 :     if(rc)

  0107d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01082	0f 84 90 00 00
	00		 je	 $LN46@commadpt_i

; 1466 :     {
; 1467 :         WRMSG(HHC00102, "E", strerror(rc));

  01088	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0108c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01092	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv621[rsp], rax
  0109a	b9 01 00 00 00	 mov	 ecx, 1
  0109f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010a5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv621[rsp]
  010ad	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169075
  010b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169076
  010c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  010d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169077
  010dc	ba bb 05 00 00	 mov	 edx, 1467		; 000005bbH
  010e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169078
  010e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1468 :         release_lock(&dev->commadpt->lock);

  010ee	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010f6	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  010fd	48 83 c0 30	 add	 rax, 48			; 00000030H
  01101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169079
  01108	48 8b c8	 mov	 rcx, rax
  0110b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1469 :         return -1;

  01111	b8 ff ff ff ff	 mov	 eax, -1
  01116	eb 4c		 jmp	 SHORT $LN1@commadpt_i
$LN46@commadpt_i:

; 1470 :     }
; 1471 :     dev->commadpt->have_cthread=1;

  01118	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01120	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  01127	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0112a	83 c8 01	 or	 eax, 1
  0112d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01135	48 8b 89 68 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4456]
  0113c	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1472 : 
; 1473 :     /* Release the CA lock */
; 1474 :     release_lock(&dev->commadpt->lock);

  0113f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01147	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  0114e	48 83 c0 30	 add	 rax, 48			; 00000030H
  01152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169080
  01159	48 8b c8	 mov	 rcx, rax
  0115c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1475 :     /* Indicate succesfull completion */
; 1476 :     return 0;

  01162	33 c0		 xor	 eax, eax
$LN1@commadpt_i:
$LN47@commadpt_i:

; 1477 : }

  01164	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0116c	48 33 cc	 xor	 rcx, rsp
  0116f	e8 00 00 00 00	 call	 __security_check_cookie
  01174	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  0117b	5f		 pop	 rdi
  0117c	c3		 ret	 0
  0117d	0f 1f 00	 npad	 3
$LN76@commadpt_i:
  01180	00 00 00 00	 DD	 $LN24@commadpt_i
  01184	00 00 00 00	 DD	 $LN26@commadpt_i
  01188	00 00 00 00	 DD	 $LN40@commadpt_i
  0118c	00 00 00 00	 DD	 $LN40@commadpt_i
  01190	00 00 00 00	 DD	 $LN40@commadpt_i
  01194	00 00 00 00	 DD	 $LN40@commadpt_i
  01198	00 00 00 00	 DD	 $LN40@commadpt_i
  0119c	00 00 00 00	 DD	 $LN40@commadpt_i
  011a0	00 00 00 00	 DD	 $LN40@commadpt_i
  011a4	00 00 00 00	 DD	 $LN40@commadpt_i
  011a8	00 00 00 00	 DD	 $LN20@commadpt_i
  011ac	00 00 00 00	 DD	 $LN29@commadpt_i
  011b0	00 00 00 00	 DD	 $LN32@commadpt_i
  011b4	00 00 00 00	 DD	 $LN33@commadpt_i
  011b8	00 00 00 00	 DD	 $LN34@commadpt_i
  011bc	00 00 00 00	 DD	 $LN35@commadpt_i
  011c0	00 00 00 00	 DD	 $LN36@commadpt_i
  011c4	00 00 00 00	 DD	 $LN37@commadpt_i
  011c8	00 00 00 00	 DD	 $LN38@commadpt_i
  011cc	00 00 00 00	 DD	 $LN39@commadpt_i
commadpt_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
tv69 = 96
tv75 = 100
dev$ = 128
kw$ = 136
kv$ = 144
msg013e	PROC

; 1264 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1265 :     WRMSG(HHC01007, "E", LCSS_DEVNUM,kw,kv);

  00013	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0001c	74 12		 je	 SHORT $LN3@msg013e
  0001e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0002a	89 44 24 60	 mov	 DWORD PTR tv69[rsp], eax
  0002e	eb 08		 jmp	 SHORT $LN4@msg013e
$LN3@msg013e:
  00030	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN4@msg013e:
  00038	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00041	74 14		 je	 SHORT $LN5@msg013e
  00043	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0004f	d1 f8		 sar	 eax, 1
  00051	89 44 24 64	 mov	 DWORD PTR tv75[rsp], eax
  00055	eb 08		 jmp	 SHORT $LN6@msg013e
$LN5@msg013e:
  00057	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN6@msg013e:
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR kv$[rsp]
  00072	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00077	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kw$[rsp]
  0007f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00084	8b 4c 24 60	 mov	 ecx, DWORD PTR tv69[rsp]
  00088	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008c	8b 4c 24 64	 mov	 ecx, DWORD PTR tv75[rsp]
  00090	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168939
  0009b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168940
  000a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168941
  000be	ba f1 04 00 00	 mov	 edx, 1265		; 000004f1H
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168942
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1266 : }

  000d0	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000d4	c3		 ret	 0
msg013e	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
dev$ = 8
commadpt_halt_or_clear PROC

; 1253 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1254 :     if (dev->busy)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00010	c1 e8 13	 shr	 eax, 19
  00013	83 e0 01	 and	 eax, 1

; 1255 :     {
; 1256 :         // TODO: add code to halt/clear subchannel, if needed.
; 1257 :     }
; 1258 : }

  00016	c3		 ret	 0
commadpt_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ca$ = 80
delay$ = 88
tv146 = 92
devnum$ = 96
tv78 = 100
tv83 = 104
rc$ = 108
tv172 = 112
tv177 = 116
tv189 = 120
tv194 = 124
threadname$ = 128
__$ArrayPad$ = 168
vca$ = 192
commadpt_thread PROC

; 1202 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1203 :     COMMADPT    *ca;            /* Work CA Control Block Pointer     */
; 1204 :     int devnum;                 /* device number copy for convenience*/
; 1205 :     int delay;                  /* unacknowledged attention delay    */
; 1206 :     int rc;                     /* return code from various rtns     */
; 1207 :     char threadname[40];        /* string for WRMSG               */
; 1208 : 
; 1209 :     /*---------------------END OF DECLARES---------------------------*/
; 1210 : 
; 1211 :     /* fetch the commadpt structure */
; 1212 :     ca=(COMMADPT *)vca;

  0001e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR vca$[rsp]
  00026	48 89 44 24 50	 mov	 QWORD PTR ca$[rsp], rax

; 1213 : 
; 1214 :     /* Obtain the CA lock */
; 1215 :     obtain_lock(&ca->lock);

  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00030	48 83 c0 30	 add	 rax, 48			; 00000030H
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168903
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1216 : 
; 1217 :     /* get a work copy of devnum (for messages) */
; 1218 :     devnum=ca->devnum;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00049	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0004d	89 44 24 60	 mov	 DWORD PTR devnum$[rsp], eax

; 1219 : 
; 1220 :     MSGBUF(threadname, "3705 device(%1d:%04X) thread", ca->dev->ssid, devnum);

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0005d	8b 4c 24 60	 mov	 ecx, DWORD PTR devnum$[rsp]
  00061	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00065	44 8b c8	 mov	 r9d, eax
  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168904
  0006f	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00074	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1221 :     LOG_THREAD_BEGIN( threadname );

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168905
  0008f	8b c8		 mov	 ecx, eax
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00097	89 44 24 64	 mov	 DWORD PTR tv78[rsp], eax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000a1	89 44 24 68	 mov	 DWORD PTR tv83[rsp], eax
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  000b8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000bd	8b 4c 24 64	 mov	 ecx, DWORD PTR tv78[rsp]
  000c1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c5	8b 4c 24 68	 mov	 ecx, DWORD PTR tv83[rsp]
  000c9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168906
  000d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168907
  000e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168908
  000f7	ba c5 04 00 00	 mov	 edx, 1221		; 000004c5H
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168909
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@commadpt_t:

; 1222 : 
; 1223 :     while (!sysblk.shutdown) {

  00109	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00110	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00116	c1 e8 0b	 shr	 eax, 11
  00119	83 e0 01	 and	 eax, 1
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 9e 01 00
	00		 jne	 $LN3@commadpt_t

; 1224 :         release_lock(&ca->lock);

  00124	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00129	48 83 c0 30	 add	 rax, 48			; 00000030H
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168910
  00134	48 8b c8	 mov	 rcx, rax
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1225 :         if(ca->ackspeed == 0) delay = 50000 + (ca->unack_attn_count * 100000);         /* Max's reliable algorithm      */

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00142	83 b8 90 00 01
	00 00		 cmp	 DWORD PTR [rax+65680], 0
  00149	75 17		 jne	 SHORT $LN4@commadpt_t
  0014b	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00150	69 40 74 a0 86
	01 00		 imul	 eax, DWORD PTR [rax+116], 100000 ; 000186a0H
  00157	05 50 c3 00 00	 add	 eax, 50000		; 0000c350H
  0015c	89 44 24 58	 mov	 DWORD PTR delay$[rsp], eax
  00160	eb 23		 jmp	 SHORT $LN5@commadpt_t
$LN4@commadpt_t:

; 1226 :         else delay = (ca->unack_attn_count * ca->unack_attn_count + 1) * ca->ackspeed; /* much faster but TCAM hates it */

  00162	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00167	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  0016c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0016f	0f af 41 74	 imul	 eax, DWORD PTR [rcx+116]
  00173	ff c0		 inc	 eax
  00175	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  0017a	0f af 81 90 00
	01 00		 imul	 eax, DWORD PTR [rcx+65680]
  00181	89 44 24 58	 mov	 DWORD PTR delay$[rsp], eax
$LN5@commadpt_t:

; 1227 :         usleep(min(1000000,delay));                                                    /* go to sleep, max. 1 second    */

  00185	81 7c 24 58 40
	42 0f 00	 cmp	 DWORD PTR delay$[rsp], 1000000 ; 000f4240H
  0018d	7e 0a		 jle	 SHORT $LN9@commadpt_t
  0018f	c7 44 24 5c 40
	42 0f 00	 mov	 DWORD PTR tv146[rsp], 1000000 ; 000f4240H
  00197	eb 08		 jmp	 SHORT $LN10@commadpt_t
$LN9@commadpt_t:
  00199	8b 44 24 58	 mov	 eax, DWORD PTR delay$[rsp]
  0019d	89 44 24 5c	 mov	 DWORD PTR tv146[rsp], eax
$LN10@commadpt_t:
  001a1	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv146[rsp]
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1228 :         obtain_lock(&ca->lock);

  001ab	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  001b0	48 83 c0 30	 add	 rax, 48			; 00000030H
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168913
  001bb	48 8b c8	 mov	 rcx, rax
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1229 :         make_sna_requests2(ca);

  001c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  001c9	e8 00 00 00 00	 call	 make_sna_requests2

; 1230 :         make_sna_requests3(ca);

  001ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  001d3	e8 00 00 00 00	 call	 make_sna_requests3

; 1231 :         if (ca->sendq
; 1232 : // attempt to fix hot i/o bug
; 1233 :             && ca->unack_attn_count < 10

  001d8	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  001dd	48 83 b8 a0 00
	01 00 00	 cmp	 QWORD PTR [rax+65696], 0
  001e5	0f 84 d2 00 00
	00		 je	 $LN6@commadpt_t
  001eb	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  001f0	83 78 74 0a	 cmp	 DWORD PTR [rax+116], 10
  001f4	0f 8d c3 00 00
	00		 jge	 $LN6@commadpt_t

; 1234 :         )
; 1235 :         {
; 1236 :             ca->unack_attn_count++;

  001fa	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  001ff	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00202	ff c0		 inc	 eax
  00204	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  00209	89 41 74	 mov	 DWORD PTR [rcx+116], eax

; 1237 :             rc = device_attention(ca->dev, CSW_ATTN);

  0020c	b2 80		 mov	 dl, 128			; 00000080H
  0020e	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00213	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
  0021c	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 1238 :             if(ca->dev->ccwtrace)

  00220	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00225	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00228	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0022e	c1 e8 0f	 shr	 eax, 15
  00231	83 e0 01	 and	 eax, 1
  00234	85 c0		 test	 eax, eax
  00236	0f 84 81 00 00
	00		 je	 $LN7@commadpt_t

; 1239 :                 WRMSG(HHC01057, "D",

  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00241	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00244	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00248	89 44 24 70	 mov	 DWORD PTR tv172[rsp], eax
  0024c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  00251	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00254	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00258	d1 f9		 sar	 ecx, 1
  0025a	89 4c 24 74	 mov	 DWORD PTR tv177[rsp], ecx
  0025e	b9 01 00 00 00	 mov	 ecx, 1
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00269	8b 4c 24 6c	 mov	 ecx, DWORD PTR rc$[rsp]
  0026d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00271	8b 4c 24 70	 mov	 ecx, DWORD PTR tv172[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 4c 24 74	 mov	 ecx, DWORD PTR tv177[rsp]
  0027d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168916
  00288	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168917
  00294	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00299	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029e	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168918
  002ab	ba d8 04 00 00	 mov	 edx, 1240		; 000004d8H
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168919
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@commadpt_t:
$LN6@commadpt_t:

; 1240 :                     SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, rc);
; 1241 :         }
; 1242 :     }

  002bd	e9 47 fe ff ff	 jmp	 $LN2@commadpt_t
$LN3@commadpt_t:

; 1243 :     // end while(!sysblk.shutdown)
; 1244 : 
; 1245 :     LOG_THREAD_END( threadname );

  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168920
  002cf	8b c8		 mov	 ecx, eax
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  002d7	89 44 24 78	 mov	 DWORD PTR tv189[rsp], eax
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  002e1	89 44 24 7c	 mov	 DWORD PTR tv194[rsp], eax
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  002f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002fd	8b 4c 24 78	 mov	 ecx, DWORD PTR tv189[rsp]
  00301	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00305	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv194[rsp]
  00309	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168921
  00314	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168922
  00320	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00325	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00330	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168923
  00337	ba dd 04 00 00	 mov	 edx, 1245		; 000004ddH
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168924
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1246 :     release_lock(&ca->lock);

  00349	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  0034e	48 83 c0 30	 add	 rax, 48			; 00000030H
  00352	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168925
  00359	48 8b c8	 mov	 rcx, rax
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1247 :     return NULL;

  00362	33 c0		 xor	 eax, eax

; 1248 : }

  00364	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0036c	48 33 cc	 xor	 rcx, rsp
  0036f	e8 00 00 00 00	 call	 __security_check_cookie
  00374	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0037b	c3		 ret	 0
commadpt_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ca$ = 96
rc$ = 104
devnum$ = 108
tv245 = 112
tv84 = 116
sockopt$ = 120
tv160 = 124
tv186 = 128
tv198 = 132
tv204 = 136
tv76 = 144
tv151 = 152
tv177 = 160
sin$ = 168
bfr$ = 192
__$ArrayPad$ = 448
vca$ = 480
telnet_thread PROC

; 1097 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1098 :     COMMADPT *ca;
; 1099 :     int devnum;                 /* device number copy for convenience*/
; 1100 :     int        sockopt;         /* Used for setsocketoption          */
; 1101 :     int rc;                     /* return code from various rtns     */
; 1102 :     struct sockaddr_in sin;     /* bind socket address structure     */
; 1103 :     BYTE bfr[256];
; 1104 : 
; 1105 :     ca=(COMMADPT*)vca;

  0001e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR vca$[rsp]
  00026	48 89 44 24 60	 mov	 QWORD PTR ca$[rsp], rax

; 1106 :     /* get a work copy of devnum (for messages) */
; 1107 :     ca->sfd = 0;

  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00030	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1108 :     devnum=ca->devnum;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0003c	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00040	89 44 24 6c	 mov	 DWORD PTR devnum$[rsp], eax

; 1109 : 
; 1110 :     ca->lfd=socket(AF_INET,SOCK_STREAM,0);

  00044	45 33 c0	 xor	 r8d, r8d
  00047	ba 01 00 00 00	 mov	 edx, 1
  0004c	b9 02 00 00 00	 mov	 ecx, 2
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  0005c	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1111 :     if(!socket_is_socket(ca->lfd))

  0005f	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00064	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_is_socket
  0006d	85 c0		 test	 eax, eax
  0006f	0f 85 bf 00 00
	00		 jne	 $LN8@telnet_thr

; 1112 :     {
; 1113 :         WRMSG(HHC01002, "E",SSID_TO_LCSS(ca->dev->ssid),devnum,strerror(HSO_errno));

  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0007b	8b c8		 mov	 ecx, eax
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00083	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00090	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00093	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00097	d1 f9		 sar	 ecx, 1
  00099	89 4c 24 74	 mov	 DWORD PTR tv84[rsp], ecx
  0009d	b9 01 00 00 00	 mov	 ecx, 1
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000b0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b5	8b 4c 24 6c	 mov	 ecx, DWORD PTR devnum$[rsp]
  000b9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000bd	8b 4c 24 74	 mov	 ecx, DWORD PTR tv84[rsp]
  000c1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168857
  000cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168858
  000d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168859
  000ef	ba 59 04 00 00	 mov	 edx, 1113		; 00000459H
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168860
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1114 :         ca->have_cthread=0;

  00101	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00106	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00109	83 e0 fe	 and	 eax, -2			; fffffffeH
  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00111	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1115 :         release_lock(&ca->lock);

  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00119	48 83 c0 30	 add	 rax, 48			; 00000030H
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168861
  00124	48 8b c8	 mov	 rcx, rax
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1116 :         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 35 04 00 00	 jmp	 $LN1@telnet_thr
$LN8@telnet_thr:

; 1117 :     }
; 1118 : 
; 1119 :     /* Reuse the address regardless of any */
; 1120 :     /* spurious connection on that port    */
; 1121 :     sockopt=1;

  00134	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR sockopt$[rsp], 1

; 1122 :     setsockopt(ca->lfd,SOL_SOCKET,SO_REUSEADDR,(GETSET_SOCKOPT_T*)&sockopt,sizeof(sockopt));

  0013c	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00141	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00145	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014d	4c 8d 4c 24 78	 lea	 r9, QWORD PTR sockopt$[rsp]
  00152	41 b8 04 00 00
	00		 mov	 r8d, 4
  00158	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0015d	48 8b c8	 mov	 rcx, rax
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 1123 : 
; 1124 :     /* Bind the socket */
; 1125 :     sin.sin_family=AF_INET;

  00166	b8 02 00 00 00	 mov	 eax, 2
  0016b	66 89 84 24 a8
	00 00 00	 mov	 WORD PTR sin$[rsp], ax

; 1126 :     sin.sin_addr.s_addr=ca->lhost;

  00173	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00178	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0017b	89 84 24 ac 00
	00 00		 mov	 DWORD PTR sin$[rsp+4], eax

; 1127 :     sin.sin_port=htons(ca->lport);

  00182	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00187	0f b7 48 10	 movzx	 ecx, WORD PTR [rax+16]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00191	66 89 84 24 aa
	00 00 00	 mov	 WORD PTR sin$[rsp+2], ax

; 1128 :     rc=bind(ca->lfd,(struct sockaddr *)&sin,sizeof(sin));

  00199	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0019e	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  001a2	41 b8 10 00 00
	00		 mov	 r8d, 16
  001a8	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR sin$[rsp]
  001b0	48 8b c8	 mov	 rcx, rax
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  001b9	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1129 :     if (rc < 0)

  001bd	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  001c2	0f 8d 9f 00 00
	00		 jge	 $LN9@telnet_thr

; 1130 :     {
; 1131 :         WRMSG(HHC01000, "E",SSID_TO_LCSS(ca->dev->ssid),devnum,"bind()",strerror(HSO_errno));

  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001ce	8b c8		 mov	 ecx, eax
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001d6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  001de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  001e3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001e6	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  001ea	d1 f9		 sar	 ecx, 1
  001ec	89 4c 24 7c	 mov	 DWORD PTR tv160[rsp], ecx
  001f0	b9 01 00 00 00	 mov	 ecx, 1
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv151[rsp]
  00203	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168863
  0020f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00214	8b 4c 24 6c	 mov	 ecx, DWORD PTR devnum$[rsp]
  00218	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0021c	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv160[rsp]
  00220	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168864
  0022b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168865
  00237	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00241	41 b9 03 00 00
	00		 mov	 r9d, 3
  00247	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168866
  0024e	ba 6b 04 00 00	 mov	 edx, 1131		; 0000046bH
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168867
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1132 :         return NULL;

  00260	33 c0		 xor	 eax, eax
  00262	e9 02 03 00 00	 jmp	 $LN1@telnet_thr
$LN9@telnet_thr:

; 1133 :     }
; 1134 :     /* Start the listen */
; 1135 :     rc = listen(ca->lfd,10);

  00267	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0026c	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00270	ba 0a 00 00 00	 mov	 edx, 10
  00275	48 8b c8	 mov	 rcx, rax
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  0027e	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1136 :     if (rc < 0)

  00282	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00287	0f 8d a5 00 00
	00		 jge	 $LN10@telnet_thr

; 1137 :     {
; 1138 :         WRMSG(HHC01000, "E",SSID_TO_LCSS(ca->dev->ssid),devnum,"listen()",strerror(HSO_errno));

  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00293	8b c8		 mov	 ecx, eax
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0029b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  002a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  002a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002ab	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002af	d1 f9		 sar	 ecx, 1
  002b1	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv186[rsp], ecx
  002b8	b9 01 00 00 00	 mov	 ecx, 1
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  002cb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168869
  002d7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002dc	8b 4c 24 6c	 mov	 ecx, DWORD PTR devnum$[rsp]
  002e0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002e4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  002eb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168870
  002f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168871
  00302	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00307	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00312	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168872
  00319	ba 72 04 00 00	 mov	 edx, 1138		; 00000472H
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168873
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1139 :         return NULL;

  0032b	33 c0		 xor	 eax, eax
  0032d	e9 37 02 00 00	 jmp	 $LN1@telnet_thr
$LN10@telnet_thr:

; 1140 :     }
; 1141 :     WRMSG(HHC01004, "I", SSID_TO_LCSS(ca->dev->ssid), devnum, ca->lport);

  00332	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00337	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0033b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv198[rsp], eax
  00342	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00347	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0034a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0034e	d1 f9		 sar	 ecx, 1
  00350	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv204[rsp], ecx
  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00362	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  00369	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0036d	8b 4c 24 6c	 mov	 ecx, DWORD PTR devnum$[rsp]
  00371	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00375	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv204[rsp]
  0037c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168874
  00387	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168875
  00393	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00398	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039d	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168876
  003aa	ba 75 04 00 00	 mov	 edx, 1141		; 00000475H
  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168877
  003b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@telnet_thr:

; 1142 :     for (;;)
; 1143 :     {
; 1144 :         ca->sfd = 0;

  003bc	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  003c1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1145 :         ca->sfd=accept(ca->lfd,NULL,0);

  003c8	45 33 c0	 xor	 r8d, r8d
  003cb	33 d2		 xor	 edx, edx
  003cd	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  003d2	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  003db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  003e0	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1146 :         if (ca->sfd < 1)

  003e3	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  003e8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003ec	7d 02		 jge	 SHORT $LN11@telnet_thr

; 1147 :             continue;

  003ee	eb cc		 jmp	 SHORT $LN2@telnet_thr
$LN11@telnet_thr:

; 1148 :         if  (connect_client(&ca->sfd))

  003f0	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  003f5	48 83 c0 18	 add	 rax, 24
  003f9	48 8b c8	 mov	 rcx, rax
  003fc	e8 00 00 00 00	 call	 connect_client
  00401	85 c0		 test	 eax, eax
  00403	74 16		 je	 SHORT $LN12@telnet_thr

; 1149 :         {
; 1150 :             ca->is_3270 = 1;

  00405	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0040a	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0040d	0f ba e8 07	 bts	 eax, 7
  00411	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00416	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1151 :         }

  00419	eb 14		 jmp	 SHORT $LN13@telnet_thr
$LN12@telnet_thr:

; 1152 :         else
; 1153 :         {
; 1154 :             ca->is_3270 = 0;

  0041b	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00420	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00423	0f ba f0 07	 btr	 eax, 7
  00427	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  0042c	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN13@telnet_thr:

; 1155 :         }
; 1156 :         socket_set_blocking_mode(ca->sfd,0);  // set to non-blocking mode

  0042f	33 d2		 xor	 edx, edx
  00431	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00436	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode

; 1157 :         if (ca->emu3791 == 0) {make_sna_requests4(ca, 0, (ca->is_3270) ? 0x02 : 0x01);}   // send REQCONT

  0043f	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00444	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00447	c1 e8 0a	 shr	 eax, 10
  0044a	83 e0 01	 and	 eax, 1
  0044d	85 c0		 test	 eax, eax
  0044f	75 36		 jne	 SHORT $LN14@telnet_thr
  00451	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00456	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00459	c1 e8 07	 shr	 eax, 7
  0045c	83 e0 01	 and	 eax, 1
  0045f	85 c0		 test	 eax, eax
  00461	74 0a		 je	 SHORT $LN22@telnet_thr
  00463	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv245[rsp], 2
  0046b	eb 08		 jmp	 SHORT $LN23@telnet_thr
$LN22@telnet_thr:
  0046d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv245[rsp], 1
$LN23@telnet_thr:
  00475	44 0f b6 44 24
	70		 movzx	 r8d, BYTE PTR tv245[rsp]
  0047b	33 d2		 xor	 edx, edx
  0047d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00482	e8 00 00 00 00	 call	 make_sna_requests4
$LN14@telnet_thr:

; 1158 :         ca->hangup = 0;

  00487	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0048c	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0048f	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00492	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00497	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN5@telnet_thr:

; 1159 :         for (;;)
; 1160 :         {
; 1161 :             usleep(50000);

  0049a	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1162 :             if (ca->hangup)

  004a5	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  004aa	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  004ad	c1 e8 06	 shr	 eax, 6
  004b0	83 e0 01	 and	 eax, 1
  004b3	85 c0		 test	 eax, eax
  004b5	74 05		 je	 SHORT $LN15@telnet_thr

; 1163 :                 break;

  004b7	e9 8e 00 00 00	 jmp	 $LN6@telnet_thr
$LN15@telnet_thr:

; 1164 :             /* read_socket has changed from 3.04 to 3.06 - we need old way */
; 1165 : #ifdef _MSVC_
; 1166 :             rc=recv(ca->sfd,bfr,ca->unitsz-BUFPD,0);

  004bc	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  004c1	8b 80 8c 00 01
	00		 mov	 eax, DWORD PTR [rax+65676]
  004c7	83 e8 1c	 sub	 eax, 28
  004ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  004cf	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  004d3	45 33 c9	 xor	 r9d, r9d
  004d6	44 8b c0	 mov	 r8d, eax
  004d9	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR bfr$[rsp]
  004e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  004e7	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1167 : #else
; 1168 :             rc=read(ca->sfd,bfr,ca->unitsz-BUFPD);
; 1169 : #endif
; 1170 :             if (rc < 0)

  004eb	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  004f0	7d 17		 jge	 SHORT $LN16@telnet_thr

; 1171 :             {
; 1172 :                 if (0
; 1173 : #ifndef WIN32
; 1174 :                     || EAGAIN == errno
; 1175 : #endif
; 1176 :                     || HSO_EWOULDBLOCK == HSO_errno

  004f2	33 c0		 xor	 eax, eax
  004f4	85 c0		 test	 eax, eax
  004f6	75 0d		 jne	 SHORT $LN18@telnet_thr
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  004fe	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00503	75 02		 jne	 SHORT $LN17@telnet_thr
$LN18@telnet_thr:

; 1177 :                 )
; 1178 :                 {
; 1179 :                     continue;

  00505	eb 93		 jmp	 SHORT $LN5@telnet_thr
$LN17@telnet_thr:

; 1180 :                 }
; 1181 :                 break;

  00507	eb 41		 jmp	 SHORT $LN6@telnet_thr
$LN16@telnet_thr:

; 1182 :             }
; 1183 :             if (rc == 0)

  00509	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0050e	75 1e		 jne	 SHORT $LN19@telnet_thr

; 1184 :             {
; 1185 : //              make_sna_requests4(ca, 1);   // send REQDISCONT
; 1186 :                 if (ca->emu3791 == 0) {make_sna_requests5(ca);}

  00510	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  00515	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00518	c1 e8 0a	 shr	 eax, 10
  0051b	83 e0 01	 and	 eax, 1
  0051e	85 c0		 test	 eax, eax
  00520	75 0a		 jne	 SHORT $LN20@telnet_thr
  00522	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00527	e8 00 00 00 00	 call	 make_sna_requests5
$LN20@telnet_thr:

; 1187 :                 break;

  0052c	eb 1c		 jmp	 SHORT $LN6@telnet_thr
$LN19@telnet_thr:

; 1188 :             }
; 1189 :             commadpt_read_tty(ca,bfr,rc);

  0052e	44 8b 44 24 68	 mov	 r8d, DWORD PTR rc$[rsp]
  00533	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR bfr$[rsp]
  0053b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ca$[rsp]
  00540	e8 00 00 00 00	 call	 commadpt_read_tty

; 1190 :         }

  00545	e9 50 ff ff ff	 jmp	 $LN5@telnet_thr
$LN6@telnet_thr:

; 1191 :         close_socket(ca->sfd);

  0054a	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0054f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00552	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1192 :         ca->sfd = 0;

  00558	48 8b 44 24 60	 mov	 rax, QWORD PTR ca$[rsp]
  0055d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1193 :     }

  00564	e9 53 fe ff ff	 jmp	 $LN2@telnet_thr
$LN1@telnet_thr:
$LN21@telnet_thr:

; 1194 : 
; 1195 :     UNREACHABLE_CODE( return NULL );
; 1196 : }

  00569	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00571	48 33 cc	 xor	 rcx, rsp
  00574	e8 00 00 00 00	 call	 __security_check_cookie
  00579	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  00580	c3		 ret	 0
telnet_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
c$ = 96
bfr3$ = 100
tv231 = 104
i1$ = 108
tv157 = 112
eor$ = 116
tv95 = 120
tv130 = 124
tv134 = 128
tv139 = 132
tv174 = 136
tv178 = 140
tv182 = 144
tv187 = 148
tv210 = 152
tv214 = 156
tv219 = 160
tv318 = 164
tv323 = 168
ca$ = 192
bfr$ = 200
len$ = 208
commadpt_read_tty PROC

; 995  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 996  :     BYTE        bfr3[3];
; 997  :     BYTE        c;
; 998  :     int i1;
; 999  :     int eor=0;

  00016	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR eor$[rsp], 0

; 1000 :     logdump("RECV",ca->dev, bfr,len);

  0001e	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00026	4c 8b c8	 mov	 r9, rax
  00029	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR bfr$[rsp]
  00031	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00039	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168788
  00043	e8 00 00 00 00	 call	 logdump

; 1001 :     /* If there is a complete data record already in the buffer
; 1002 :        then discard it before reading more data
; 1003 :        For TTY, allow data to accumulate until CR is received */
; 1004 :     if (ca->is_3270) {

  00048	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00050	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00053	c1 e8 07	 shr	 eax, 7
  00056	83 e0 01	 and	 eax, 1
  00059	85 c0		 test	 eax, eax
  0005b	74 32		 je	 SHORT $LN7@commadpt_r

; 1005 :             if (ca->inpbufl) {

  0005d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00065	83 b8 88 00 01
	00 00		 cmp	 DWORD PTR [rax+65672], 0
  0006c	74 21		 je	 SHORT $LN8@commadpt_r

; 1006 :                 ca->rlen3270 = 0;

  0006e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00076	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [rax+100], 0

; 1007 :                 ca->inpbufl = 0;

  0007d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00085	c7 80 88 00 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+65672], 0
$LN8@commadpt_r:
$LN7@commadpt_r:

; 1008 :             }
; 1009 :         }
; 1010 :     for (i1 = 0; i1 < len; i1++) {

  0008f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i1$[rsp], 0
  00097	eb 0a		 jmp	 SHORT $LN4@commadpt_r
$LN2@commadpt_r:
  00099	8b 44 24 6c	 mov	 eax, DWORD PTR i1$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 6c	 mov	 DWORD PTR i1$[rsp], eax
$LN4@commadpt_r:
  000a3	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000aa	39 44 24 6c	 cmp	 DWORD PTR i1$[rsp], eax
  000ae	0f 8d 1a 05 00
	00		 jge	 $LN3@commadpt_r

; 1011 :         c = (unsigned char) bfr[i1];

  000b4	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i1$[rsp]
  000b9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR bfr$[rsp]
  000c1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c5	88 44 24 60	 mov	 BYTE PTR c$[rsp], al

; 1012 :         if (ca->telnet_opt) {

  000c9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  000d1	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000d4	c1 e8 03	 shr	 eax, 3
  000d7	83 e0 01	 and	 eax, 1
  000da	85 c0		 test	 eax, eax
  000dc	0f 84 62 02 00
	00		 je	 $LN9@commadpt_r

; 1013 :             ca->telnet_opt = 0;

  000e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  000ea	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000ed	83 e0 f7	 and	 eax, -9			; fffffff7H
  000f0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  000f8	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1014 :             if(ca->dev->ccwtrace)

  000fb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00103	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00106	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0010c	c1 e8 0f	 shr	 eax, 15
  0010f	83 e0 01	 and	 eax, 1
  00112	85 c0		 test	 eax, eax
  00114	0f 84 b7 00 00
	00		 je	 $LN10@commadpt_r

; 1015 :                 WRMSG(HHC01053,"D",

  0011a	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  0011f	89 44 24 78	 mov	 DWORD PTR tv95[rsp], eax
  00123	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0012b	0f b6 49 68	 movzx	 ecx, BYTE PTR [rcx+104]
  0012f	89 4c 24 7c	 mov	 DWORD PTR tv130[rsp], ecx
  00133	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0013b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0013e	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00142	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv134[rsp], edx
  00149	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR ca$[rsp]
  00151	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00154	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00159	41 d1 f8	 sar	 r8d, 1
  0015c	44 89 84 24 84
	00 00 00	 mov	 DWORD PTR tv139[rsp], r8d
  00164	b9 01 00 00 00	 mov	 ecx, 1
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0016f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv95[rsp]
  00173	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00177	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv130[rsp]
  0017b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0017f	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv134[rsp]
  00186	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  00191	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168793
  0019c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168794
  001a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168795
  001bf	ba f9 03 00 00	 mov	 edx, 1017		; 000003f9H
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168796
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@commadpt_r:

; 1016 :                     SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum,
; 1017 :                     ca->telnet_cmd, c);
; 1018 :             bfr3[0] = 0xff;  /* IAC */

  001d1	b8 01 00 00 00	 mov	 eax, 1
  001d6	48 6b c0 00	 imul	 rax, rax, 0
  001da	c6 44 04 64 ff	 mov	 BYTE PTR bfr3$[rsp+rax], 255 ; 000000ffH

; 1019 :             /* set won't/don't for all received commands */
; 1020 :             bfr3[1] = (ca->telnet_cmd == 0xfd) ? 0xfc : 0xfe;

  001df	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  001e7	0f b6 40 68	 movzx	 eax, BYTE PTR [rax+104]
  001eb	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  001f0	75 0a		 jne	 SHORT $LN32@commadpt_r
  001f2	c7 44 24 70 fc
	00 00 00	 mov	 DWORD PTR tv157[rsp], 252 ; 000000fcH
  001fa	eb 08		 jmp	 SHORT $LN33@commadpt_r
$LN32@commadpt_r:
  001fc	c7 44 24 70 fe
	00 00 00	 mov	 DWORD PTR tv157[rsp], 254 ; 000000feH
$LN33@commadpt_r:
  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	48 6b c0 01	 imul	 rax, rax, 1
  0020d	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR tv157[rsp]
  00212	88 4c 04 64	 mov	 BYTE PTR bfr3$[rsp+rax], cl

; 1021 :             bfr3[2] = c;

  00216	b8 01 00 00 00	 mov	 eax, 1
  0021b	48 6b c0 02	 imul	 rax, rax, 2
  0021f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR c$[rsp]
  00224	88 4c 04 64	 mov	 BYTE PTR bfr3$[rsp+rax], cl

; 1022 :             if (ca->sfd > 0) {

  00228	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00230	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00234	7e 1c		 jle	 SHORT $LN11@commadpt_r

; 1023 :                 write_socket(ca->sfd,bfr3,3);

  00236	41 b8 03 00 00
	00		 mov	 r8d, 3
  0023c	48 8d 54 24 64	 lea	 rdx, QWORD PTR bfr3$[rsp]
  00241	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00249	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
$LN11@commadpt_r:

; 1024 :             }
; 1025 :             if(ca->dev->ccwtrace)

  00252	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0025a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00263	c1 e8 0f	 shr	 eax, 15
  00266	83 e0 01	 and	 eax, 1
  00269	85 c0		 test	 eax, eax
  0026b	0f 84 ce 00 00
	00		 je	 $LN12@commadpt_r

; 1026 :                 WRMSG(HHC01054,"D",

  00271	b8 01 00 00 00	 mov	 eax, 1
  00276	48 6b c0 02	 imul	 rax, rax, 2
  0027a	0f b6 44 04 64	 movzx	 eax, BYTE PTR bfr3$[rsp+rax]
  0027f	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  00286	b9 01 00 00 00	 mov	 ecx, 1
  0028b	48 6b c9 01	 imul	 rcx, rcx, 1
  0028f	0f b6 4c 0c 64	 movzx	 ecx, BYTE PTR bfr3$[rsp+rcx]
  00294	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv178[rsp], ecx
  0029b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  002a3	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  002a6	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  002aa	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv182[rsp], edx
  002b1	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR ca$[rsp]
  002b9	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  002bc	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  002c1	41 d1 f8	 sar	 r8d, 1
  002c4	44 89 84 24 94
	00 00 00	 mov	 DWORD PTR tv187[rsp], r8d
  002cc	b9 01 00 00 00	 mov	 ecx, 1
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv174[rsp]
  002de	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002e2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  002e9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002ed	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  002f4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  002ff	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168799
  0030a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168800
  00316	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00320	41 b9 03 00 00
	00		 mov	 r9d, 3
  00326	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168801
  0032d	ba 04 04 00 00	 mov	 edx, 1028		; 00000404H
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168802
  00339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@commadpt_r:

; 1027 :                     SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum,
; 1028 :                     bfr3[1], bfr3[2]);
; 1029 :             continue;

  0033f	e9 55 fd ff ff	 jmp	 $LN2@commadpt_r
$LN9@commadpt_r:

; 1030 :         }
; 1031 :         if (ca->telnet_iac) {

  00344	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0034c	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0034f	c1 e8 04	 shr	 eax, 4
  00352	83 e0 01	 and	 eax, 1
  00355	85 c0		 test	 eax, eax
  00357	0f 84 a8 01 00
	00		 je	 $LN13@commadpt_r

; 1032 :             ca->telnet_iac = 0;

  0035d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00365	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00368	83 e0 ef	 and	 eax, -17		; ffffffefH
  0036b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00373	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1033 :             if(ca->dev->ccwtrace)

  00376	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0037e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00381	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00387	c1 e8 0f	 shr	 eax, 15
  0038a	83 e0 01	 and	 eax, 1
  0038d	85 c0		 test	 eax, eax
  0038f	0f 84 a2 00 00
	00		 je	 $LN14@commadpt_r

; 1034 :                 WRMSG(HHC01055, "D",

  00395	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  0039a	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv210[rsp], eax
  003a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  003a9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003ac	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003b0	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv214[rsp], ecx
  003b7	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  003bf	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  003c2	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  003c6	d1 fa		 sar	 edx, 1
  003c8	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv219[rsp], edx
  003cf	b9 01 00 00 00	 mov	 ecx, 1
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003da	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv210[rsp]
  003e1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  003e5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv214[rsp]
  003ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003f0	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv219[rsp]
  003f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168805
  00402	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168806
  0040e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00413	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00418	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168807
  00425	ba 0c 04 00 00	 mov	 edx, 1036		; 0000040cH
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168808
  00431	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@commadpt_r:

; 1035 :                     SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum,
; 1036 :                     c);
; 1037 :             switch (c) {

  00437	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  0043c	88 44 24 68	 mov	 BYTE PTR tv231[rsp], al
  00440	80 7c 24 68 ef	 cmp	 BYTE PTR tv231[rsp], 239 ; 000000efH
  00445	74 7c		 je	 SHORT $LN19@commadpt_r
  00447	80 7c 24 68 f4	 cmp	 BYTE PTR tv231[rsp], 244 ; 000000f4H
  0044c	74 45		 je	 SHORT $LN17@commadpt_r
  0044e	80 7c 24 68 fb	 cmp	 BYTE PTR tv231[rsp], 251 ; 000000fbH
  00453	74 13		 je	 SHORT $LN15@commadpt_r
  00455	80 7c 24 68 fd	 cmp	 BYTE PTR tv231[rsp], 253 ; 000000fdH
  0045a	74 0c		 je	 SHORT $LN16@commadpt_r
  0045c	80 7c 24 68 ff	 cmp	 BYTE PTR tv231[rsp], 255 ; 000000ffH
  00461	74 6a		 je	 SHORT $LN20@commadpt_r
  00463	e9 98 00 00 00	 jmp	 $LN5@commadpt_r
$LN15@commadpt_r:
$LN16@commadpt_r:

; 1038 :             case 0xFB:  /* TELNET WILL option cmd */
; 1039 :             case 0xFD:  /* TELNET DO option cmd */
; 1040 :                 ca->telnet_opt = 1;

  00468	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00470	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00473	83 c8 08	 or	 eax, 8
  00476	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0047e	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1041 :                 ca->telnet_cmd = c;

  00481	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00489	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR c$[rsp]
  0048e	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 1042 :                 break;

  00491	eb 6d		 jmp	 SHORT $LN5@commadpt_r
$LN17@commadpt_r:

; 1043 :             case 0xF4:  /* TELNET interrupt */
; 1044 :                 if (!ca->telnet_int) {

  00493	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0049b	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0049e	c1 e8 05	 shr	 eax, 5
  004a1	83 e0 01	 and	 eax, 1
  004a4	85 c0		 test	 eax, eax
  004a6	75 19		 jne	 SHORT $LN18@commadpt_r

; 1045 :                     ca->telnet_int = 1;

  004a8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  004b0	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  004b3	83 c8 20	 or	 eax, 32			; 00000020H
  004b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  004be	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN18@commadpt_r:

; 1046 :                 }
; 1047 :                 break;

  004c1	eb 3d		 jmp	 SHORT $LN5@commadpt_r
$LN19@commadpt_r:

; 1048 :             case EOR_MARK:
; 1049 :                                 eor = 1;

  004c3	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR eor$[rsp], 1

; 1050 :                 break;

  004cb	eb 33		 jmp	 SHORT $LN5@commadpt_r
$LN20@commadpt_r:

; 1051 :             case 0xFF:  /* IAC IAC */
; 1052 :                         ca->inpbuf[ca->rlen3270++] = 0xFF;

  004cd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  004d5	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  004d8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  004e0	c6 84 01 88 00
	00 00 ff	 mov	 BYTE PTR [rcx+rax+136], 255 ; 000000ffH
  004e8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  004f0	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  004f3	ff c0		 inc	 eax
  004f5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  004fd	89 41 64	 mov	 DWORD PTR [rcx+100], eax
$LN5@commadpt_r:

; 1053 :                 break;
; 1054 :             }
; 1055 :             continue;

  00500	e9 94 fb ff ff	 jmp	 $LN2@commadpt_r
$LN13@commadpt_r:

; 1056 :         }
; 1057 :         if (c == 0xFF) {  /* TELNET IAC */

  00505	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  0050a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0050f	75 20		 jne	 SHORT $LN21@commadpt_r

; 1058 :             ca->telnet_iac = 1;

  00511	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00519	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0051c	83 c8 10	 or	 eax, 16
  0051f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00527	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1059 :             continue;

  0052a	e9 6a fb ff ff	 jmp	 $LN2@commadpt_r

; 1060 :         } else {

  0052f	eb 19		 jmp	 SHORT $LN22@commadpt_r
$LN21@commadpt_r:

; 1061 :             ca->telnet_iac = 0;

  00531	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00539	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0053c	83 e0 ef	 and	 eax, -17		; ffffffefH
  0053f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00547	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN22@commadpt_r:

; 1062 :         }
; 1063 :         if (!ca->is_3270) {

  0054a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00552	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00555	c1 e8 07	 shr	 eax, 7
  00558	83 e0 01	 and	 eax, 1
  0055b	85 c0		 test	 eax, eax
  0055d	75 33		 jne	 SHORT $LN23@commadpt_r

; 1064 :             if (c == 0x0D) // CR in TTY mode ?

  0055f	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp]
  00564	83 f8 0d	 cmp	 eax, 13
  00567	75 1a		 jne	 SHORT $LN24@commadpt_r

; 1065 :                 ca->eol_flag = 1;

  00569	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00571	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00574	0f ba e8 08	 bts	 eax, 8
  00578	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00580	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN24@commadpt_r:

; 1066 :             c = host_to_guest(c);   // translate ASCII to EBCDIC for tty

  00583	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR c$[rsp]
  00588	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0058e	88 44 24 60	 mov	 BYTE PTR c$[rsp], al
$LN23@commadpt_r:

; 1067 :         }
; 1068 :         ca->inpbuf[ca->rlen3270++] = c;

  00592	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0059a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0059d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  005a5	0f b6 54 24 60	 movzx	 edx, BYTE PTR c$[rsp]
  005aa	88 94 01 88 00
	00 00		 mov	 BYTE PTR [rcx+rax+136], dl
  005b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  005b9	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  005bc	ff c0		 inc	 eax
  005be	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  005c6	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 1069 :     }

  005c9	e9 cb fa ff ff	 jmp	 $LN2@commadpt_r
$LN3@commadpt_r:

; 1070 :     /* received data (rlen3270 > 0) is sufficient for 3270,
; 1071 :        but for TTY, eol_flag must also be set */
; 1072 :     if ((ca->eol_flag || ca->is_3270) && ca->rlen3270)

  005ce	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  005d6	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  005d9	c1 e8 08	 shr	 eax, 8
  005dc	83 e0 01	 and	 eax, 1
  005df	85 c0		 test	 eax, eax
  005e1	75 19		 jne	 SHORT $LN26@commadpt_r
  005e3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  005eb	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  005ee	c1 e8 07	 shr	 eax, 7
  005f1	83 e0 01	 and	 eax, 1
  005f4	85 c0		 test	 eax, eax
  005f6	0f 84 56 01 00
	00		 je	 $LN25@commadpt_r
$LN26@commadpt_r:
  005fc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00604	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  00608	0f 84 44 01 00
	00		 je	 $LN25@commadpt_r

; 1073 :     {
; 1074 :         ca->eol_flag = 0;

  0060e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00616	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00619	0f ba f0 08	 btr	 eax, 8
  0061d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00625	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1075 :         if (ca->is_3270)

  00628	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00630	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00633	c1 e8 07	 shr	 eax, 7
  00636	83 e0 01	 and	 eax, 1
  00639	85 c0		 test	 eax, eax
  0063b	74 31		 je	 SHORT $LN27@commadpt_r

; 1076 :         {
; 1077 :             if (eor)

  0063d	83 7c 24 74 00	 cmp	 DWORD PTR eor$[rsp], 0
  00642	74 28		 je	 SHORT $LN29@commadpt_r

; 1078 :             {
; 1079 :                 ca->inpbufl = ca->rlen3270;

  00644	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0064c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00654	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  00657	89 88 88 00 01
	00		 mov	 DWORD PTR [rax+65672], ecx

; 1080 :                 ca->rlen3270 = 0; /* for next msg */

  0065d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00665	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [rax+100], 0
$LN29@commadpt_r:

; 1081 :             }
; 1082 :         }

  0066c	eb 28		 jmp	 SHORT $LN28@commadpt_r
$LN27@commadpt_r:

; 1083 :         else
; 1084 :         {
; 1085 :             ca->inpbufl = ca->rlen3270;

  0066e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00676	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0067e	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  00681	89 88 88 00 01
	00		 mov	 DWORD PTR [rax+65672], ecx

; 1086 :             ca->rlen3270 = 0; /* for next msg */

  00687	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0068f	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [rax+100], 0
$LN28@commadpt_r:

; 1087 :         }
; 1088 :         if(ca->dev->ccwtrace)

  00696	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0069e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006a1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006a7	c1 e8 0f	 shr	 eax, 15
  006aa	83 e0 01	 and	 eax, 1
  006ad	85 c0		 test	 eax, eax
  006af	0f 84 9d 00 00
	00		 je	 $LN30@commadpt_r

; 1089 :             WRMSG(HHC01056, "D",

  006b5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  006bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006c0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006c4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv318[rsp], eax
  006cb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  006d3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006d6	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  006da	d1 f9		 sar	 ecx, 1
  006dc	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv323[rsp], ecx
  006e3	b9 01 00 00 00	 mov	 ecx, 1
  006e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ee	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  006f6	8b 89 88 00 01
	00		 mov	 ecx, DWORD PTR [rcx+65672]
  006fc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00700	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv318[rsp]
  00707	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0070b	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv323[rsp]
  00712	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168825
  0071d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168826
  00729	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00733	41 b9 03 00 00
	00		 mov	 r9d, 3
  00739	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168827
  00740	ba 44 04 00 00	 mov	 edx, 1092		; 00000444H
  00745	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168828
  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@commadpt_r:
$LN25@commadpt_r:

; 1090 :                 SSID_TO_LCSS(ca->dev->ssid),
; 1091 :                 ca->dev->devnum,
; 1092 :                 ca->inpbufl);
; 1093 :     }
; 1094 : }

  00752	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00759	c3		 ret	 0
commadpt_read_tty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
namelen$ = 64
ipaddr$ = 72
client$ = 80
msgtext$ = 96
__$ArrayPad$ = 352
sfd$ = 384
na$ = 392
flag$ = 400
connect_message PROC

; 972  : static void connect_message(int sfd, int na, int flag) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 973  :     struct sockaddr_in client;
; 974  :     socklen_t namelen;
; 975  :     char *ipaddr;
; 976  :     char msgtext[256];
; 977  :     if (!sfd)

  00026	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0002e	75 05		 jne	 SHORT $LN14@connect_me

; 978  :         return;

  00030	e9 04 02 00 00	 jmp	 $LN1@connect_me
$LN14@connect_me:

; 979  :     namelen = sizeof(client);

  00035	c7 44 24 40 10
	00 00 00	 mov	 DWORD PTR namelen$[rsp], 16

; 980  :     (void)getpeername (sfd, (struct sockaddr *)&client, &namelen);

  0003d	48 63 84 24 80
	01 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00045	4c 8d 44 24 40	 lea	 r8, QWORD PTR namelen$[rsp]
  0004a	48 8d 54 24 50	 lea	 rdx, QWORD PTR client$[rsp]
  0004f	48 8b c8	 mov	 rcx, rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername

; 981  :     ipaddr = inet_ntoa(client.sin_addr);

  00058	8b 4c 24 54	 mov	 ecx, DWORD PTR client$[rsp+4]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00062	48 89 44 24 48	 mov	 QWORD PTR ipaddr$[rsp], rax

; 982  :     if (flag == 0)

  00067	83 bc 24 90 01
	00 00 00	 cmp	 DWORD PTR flag$[rsp], 0
  0006f	75 3b		 jne	 SHORT $LN15@connect_me

; 983  :         MSGBUF( msgtext, "%s:%d VTAM CONNECTION ACCEPTED - NETWORK NODE= %4.4X",

  00071	0f b7 4c 24 52	 movzx	 ecx, WORD PTR client$[rsp+2]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  0007c	0f b7 c0	 movzx	 eax, ax
  0007f	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR na$[rsp]
  00086	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0008a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008e	4c 8b 4c 24 48	 mov	 r9, QWORD PTR ipaddr$[rsp]
  00093	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168745
  0009a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0009f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgtext$[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000aa	eb 2e		 jmp	 SHORT $LN16@connect_me
$LN15@connect_me:

; 984  :                 ipaddr, (int)ntohs(client.sin_port), na);
; 985  :     else
; 986  :         MSGBUF( msgtext, "%s:%d VTAM CONNECTION TERMINATED",

  000ac	0f b7 4c 24 52	 movzx	 ecx, WORD PTR client$[rsp+2]
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  000b7	0f b7 c0	 movzx	 eax, ax
  000ba	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000be	4c 8b 4c 24 48	 mov	 r9, QWORD PTR ipaddr$[rsp]
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168746
  000ca	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000cf	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgtext$[rsp]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN16@connect_me:

; 987  :                 ipaddr, (int)ntohs(client.sin_port));
; 988  :     WRMSG( HHC01047, "I", msgtext );

  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgtext$[rsp]
  000ea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168747
  000f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168748
  00102	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00107	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00112	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168749
  00119	ba dc 03 00 00	 mov	 edx, 988		; 000003dcH
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168750
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@connect_me:

; 989  :     VERIFY(0 <= write(sfd, msgtext, (u_int)strlen(msgtext)));

  0012b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgtext$[rsp]
  00130	e8 00 00 00 00	 call	 strlen
  00135	44 8b c0	 mov	 r8d, eax
  00138	48 8d 54 24 60	 lea	 rdx, QWORD PTR msgtext$[rsp]
  0013d	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0014a	85 c0		 test	 eax, eax
  0014c	7d 5c		 jge	 SHORT $LN17@connect_me
$LN7@connect_me:
  0014e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168752
  00155	41 b8 dd 03 00
	00		 mov	 r8d, 989		; 000003ddH
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168753
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168754
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00175	85 c0		 test	 eax, eax
  00177	74 20		 je	 SHORT $LN18@connect_me
  00179	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168756
  00180	41 b8 dd 03 00
	00		 mov	 r8d, 989		; 000003ddH
  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168757
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168758
  00194	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@connect_me:
  00199	33 c0		 xor	 eax, eax
  0019b	85 c0		 test	 eax, eax
  0019d	75 af		 jne	 SHORT $LN7@connect_me
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001a5	85 c0		 test	 eax, eax
  001a7	74 01		 je	 SHORT $LN19@connect_me
  001a9	cc		 int	 3
$LN19@connect_me:
$LN17@connect_me:
  001aa	33 c0		 xor	 eax, eax
  001ac	85 c0		 test	 eax, eax
  001ae	0f 85 77 ff ff
	ff		 jne	 $LN4@connect_me
$LN10@connect_me:

; 990  :     VERIFY(2 == write(sfd, "\r\n", 2));

  001b4	41 b8 02 00 00
	00		 mov	 r8d, 2
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168761
  001c1	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  001ce	83 f8 02	 cmp	 eax, 2
  001d1	74 5c		 je	 SHORT $LN20@connect_me
$LN13@connect_me:
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168762
  001da	41 b8 de 03 00
	00		 mov	 r8d, 990		; 000003deH
  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168763
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168764
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001fa	85 c0		 test	 eax, eax
  001fc	74 20		 je	 SHORT $LN21@connect_me
  001fe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168766
  00205	41 b8 de 03 00
	00		 mov	 r8d, 990		; 000003deH
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168767
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168768
  00219	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@connect_me:
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 af		 jne	 SHORT $LN13@connect_me
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0022a	85 c0		 test	 eax, eax
  0022c	74 01		 je	 SHORT $LN22@connect_me
  0022e	cc		 int	 3
$LN22@connect_me:
$LN20@connect_me:
  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	0f 85 7b ff ff
	ff		 jne	 $LN10@connect_me
$LN1@connect_me:

; 991  : }

  00239	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00241	48 33 cc	 xor	 rcx, rsp
  00244	e8 00 00 00 00	 call	 __security_check_cookie
  00249	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  00250	c3		 ret	 0
connect_message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
he$ = 32
ia$ = 64
txt$ = 72
commadpt_getaddr PROC

; 961  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 962  :     struct hostent *he;
; 963  :     he=gethostbyname(txt);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR txt$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  00019	48 89 44 24 20	 mov	 QWORD PTR he$[rsp], rax

; 964  :     if(he==NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR he$[rsp], 0
  00024	75 07		 jne	 SHORT $LN2@commadpt_g

; 965  :     {
; 966  :         return(-1);

  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	eb 21		 jmp	 SHORT $LN1@commadpt_g
$LN2@commadpt_g:

; 967  :     }
; 968  :     memcpy(ia,he->h_addr_list[0],4);

  0002d	b8 08 00 00 00	 mov	 eax, 8
  00032	48 6b c0 00	 imul	 rax, rax, 0
  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR he$[rsp]
  0003b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003f	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ia$[rsp]
  00048	8b 00		 mov	 eax, DWORD PTR [rax]
  0004a	89 01		 mov	 DWORD PTR [rcx], eax

; 969  :     return(0);

  0004c	33 c0		 xor	 eax, eax
$LN1@commadpt_g:

; 970  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
commadpt_getaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
pno$ = 32
se$ = 40
txt$ = 64
commadpt_getport PROC

; 942  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 943  :     int pno;
; 944  :     struct servent *se;
; 945  :     pno=atoi(txt);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR txt$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00014	89 44 24 20	 mov	 DWORD PTR pno$[rsp], eax

; 946  :     if(pno==0)

  00018	83 7c 24 20 00	 cmp	 DWORD PTR pno$[rsp], 0
  0001d	75 33		 jne	 SHORT $LN2@commadpt_g

; 947  :     {
; 948  :         se=getservbyname(txt,"tcp");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168702
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR txt$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getservbyname
  00031	48 89 44 24 28	 mov	 QWORD PTR se$[rsp], rax

; 949  :         if(se==NULL)

  00036	48 83 7c 24 28
	00		 cmp	 QWORD PTR se$[rsp], 0
  0003c	75 07		 jne	 SHORT $LN3@commadpt_g

; 950  :         {
; 951  :             return -1;

  0003e	b8 ff ff ff ff	 mov	 eax, -1
  00043	eb 11		 jmp	 SHORT $LN1@commadpt_g
$LN3@commadpt_g:

; 952  :         }
; 953  :         pno=se->s_port;

  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR se$[rsp]
  0004a	0f bf 40 18	 movsx	 eax, WORD PTR [rax+24]
  0004e	89 44 24 20	 mov	 DWORD PTR pno$[rsp], eax
$LN2@commadpt_g:

; 954  :     }
; 955  :     return(pno);

  00052	8b 44 24 20	 mov	 eax, DWORD PTR pno$[rsp]
$LN1@commadpt_g:

; 956  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
commadpt_getport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
tv84 = 96
tv90 = 100
tv72 = 104
buf$1 = 112
__$ArrayPad$ = 152
dev$ = 176
commadpt_alloc_device PROC

; 922  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 923  :     dev->commadpt=malloc(sizeof(COMMADPT));

  0001f	b9 c0 00 01 00	 mov	 ecx, 65728		; 000100c0H
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0002a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	48 89 81 68 11
	00 00		 mov	 QWORD PTR [rcx+4456], rax

; 924  :     if(dev->commadpt==NULL)

  00039	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  00049	0f 85 ee 00 00
	00		 jne	 $LN2@commadpt_a

; 925  :     {
; 926  :         char buf[40];
; 927  :         MSGBUF(buf, "malloc(%d)", (int)sizeof(COMMADPT));

  0004f	41 b9 c0 00 01
	00		 mov	 r9d, 65728		; 000100c0H
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168689
  0005c	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00061	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$1[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 928  :         WRMSG(HHC01000, "E", LCSS_DEVNUM, buf, strerror(errno));

  0006c	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00075	74 12		 je	 SHORT $LN4@commadpt_a
  00077	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00083	89 44 24 60	 mov	 DWORD PTR tv84[rsp], eax
  00087	eb 08		 jmp	 SHORT $LN5@commadpt_a
$LN4@commadpt_a:
  00089	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN5@commadpt_a:
  00091	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0009a	74 14		 je	 SHORT $LN6@commadpt_a
  0009c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000a8	d1 f8		 sar	 eax, 1
  000aa	89 44 24 64	 mov	 DWORD PTR tv90[rsp], eax
  000ae	eb 08		 jmp	 SHORT $LN7@commadpt_a
$LN6@commadpt_a:
  000b0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN7@commadpt_a:
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000be	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c6	48 89 44 24 68	 mov	 QWORD PTR tv72[rsp], rax
  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv72[rsp]
  000db	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000e0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$1[rsp]
  000e5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ea	8b 4c 24 60	 mov	 ecx, DWORD PTR tv84[rsp]
  000ee	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f2	8b 4c 24 64	 mov	 ecx, DWORD PTR tv90[rsp]
  000f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168690
  00101	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168691
  0010d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168692
  00124	ba a0 03 00 00	 mov	 edx, 928		; 000003a0H
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168693
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 929  :         return -1;

  00136	b8 ff ff ff ff	 mov	 eax, -1
  0013b	eb 34		 jmp	 SHORT $LN1@commadpt_a
$LN2@commadpt_a:

; 930  :     }
; 931  :     memset(dev->commadpt,0,sizeof(COMMADPT));

  0013d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00145	48 8b b8 68 11
	00 00		 mov	 rdi, QWORD PTR [rax+4456]
  0014c	33 c0		 xor	 eax, eax
  0014e	b9 c0 00 01 00	 mov	 ecx, 65728		; 000100c0H
  00153	f3 aa		 rep stosb

; 932  :     dev->commadpt->dev=dev;

  00155	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015d	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  00164	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0016c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 933  :     return 0;

  0016f	33 c0		 xor	 eax, eax
$LN1@commadpt_a:

; 934  : }

  00171	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00179	48 33 cc	 xor	 rcx, rsp
  0017c	e8 00 00 00 00	 call	 __security_check_cookie
  00181	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
commadpt_alloc_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
tv75 = 80
tv79 = 84
tv128 = 88
tv132 = 92
dev$ = 112
commadpt_clean_device PROC

; 894  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 895  :     if(dev->commadpt!=NULL)

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  00016	0f 84 bb 00 00
	00		 je	 $LN2@commadpt_c

; 896  :     {
; 897  :         free(dev->commadpt);

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00021	48 8b 88 68 11
	00 00		 mov	 rcx, QWORD PTR [rax+4456]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 898  :         dev->commadpt=NULL;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00033	48 c7 80 68 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4456], 0

; 899  :         if(dev->ccwtrace)

  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00049	c1 e8 0f	 shr	 eax, 15
  0004c	83 e0 01	 and	 eax, 1
  0004f	85 c0		 test	 eax, eax
  00051	74 7f		 je	 SHORT $LN4@commadpt_c

; 900  :         {
; 901  :             WRMSG(HHC01052,"D",

  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00058	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0005c	89 44 24 50	 mov	 DWORD PTR tv75[rsp], eax
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00065	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00069	d1 f9		 sar	 ecx, 1
  0006b	89 4c 24 54	 mov	 DWORD PTR tv79[rsp], ecx
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168667
  00081	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00086	8b 4c 24 50	 mov	 ecx, DWORD PTR tv75[rsp]
  0008a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008e	8b 4c 24 54	 mov	 ecx, DWORD PTR tv79[rsp]
  00092	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168668
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168669
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168670
  000c0	ba 87 03 00 00	 mov	 edx, 903		; 00000387H
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168671
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@commadpt_c:

; 902  :                 SSID_TO_LCSS(dev->ssid),
; 903  :                 dev->devnum,"control block freed");
; 904  :         }
; 905  :     }

  000d2	e9 94 00 00 00	 jmp	 $LN3@commadpt_c
$LN2@commadpt_c:

; 906  :     else
; 907  :     {
; 908  :         if(dev->ccwtrace)

  000d7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000dc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e2	c1 e8 0f	 shr	 eax, 15
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	74 7f		 je	 SHORT $LN5@commadpt_c

; 909  :         {
; 910  :             WRMSG(HHC01052,"D",

  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f5	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
  000f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000fe	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00102	d1 f9		 sar	 ecx, 1
  00104	89 4c 24 5c	 mov	 DWORD PTR tv132[rsp], ecx
  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168673
  0011a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0011f	8b 4c 24 58	 mov	 ecx, DWORD PTR tv128[rsp]
  00123	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00127	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv132[rsp]
  0012b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168674
  00136	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168675
  00142	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00147	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00152	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168676
  00159	ba 90 03 00 00	 mov	 edx, 912		; 00000390H
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168677
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@commadpt_c:
$LN3@commadpt_c:

; 911  :                 SSID_TO_LCSS(dev->ssid),
; 912  :                 dev->devnum,"control block not freed: not allocated");
; 913  :         }
; 914  :     }
; 915  :     return;
; 916  : }

  0016b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0016f	c3		 ret	 0
commadpt_clean_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ca$ = 48
free_bufpool PROC

; 881  : static void free_bufpool(COMMADPT *ca) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 882  :     ca->sendq = 0;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR ca$[rsp]
  0000e	48 c7 80 a0 00
	01 00 00 00 00
	00		 mov	 QWORD PTR [rax+65696], 0

; 883  :     ca->freeq = 0;

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR ca$[rsp]
  0001e	48 c7 80 98 00
	01 00 00 00 00
	00		 mov	 QWORD PTR [rax+65688], 0

; 884  :     if (ca->poolarea) {

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR ca$[rsp]
  0002e	48 83 b8 a8 00
	01 00 00	 cmp	 QWORD PTR [rax+65704], 0
  00036	74 22		 je	 SHORT $LN2@free_bufpo

; 885  :         free(ca->poolarea);

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR ca$[rsp]
  0003d	48 8b 88 a8 00
	01 00		 mov	 rcx, QWORD PTR [rax+65704]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 886  :         ca->poolarea = 0;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR ca$[rsp]
  0004f	48 c7 80 a8 00
	01 00 00 00 00
	00		 mov	 QWORD PTR [rax+65704], 0
$LN2@free_bufpo:

; 887  :     }
; 888  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
free_bufpool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
i1$ = 32
numbufs$ = 36
bufsize$ = 40
areap$ = 48
ca$ = 80
init_bufpool PROC

; 865  : static void init_bufpool(COMMADPT *ca) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 866  :     BYTE * areap;
; 867  :     int i1;
; 868  :     int numbufs = 64;

  00009	c7 44 24 24 40
	00 00 00	 mov	 DWORD PTR numbufs$[rsp], 64 ; 00000040H

; 869  :     int bufsize = ca->unitsz+16+4;

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00016	8b 80 8c 00 01
	00		 mov	 eax, DWORD PTR [rax+65676]
  0001c	83 c0 14	 add	 eax, 20
  0001f	89 44 24 28	 mov	 DWORD PTR bufsize$[rsp], eax

; 870  :     ca->poolarea = (BYTE*)calloc (numbufs, bufsize);

  00023	48 63 44 24 28	 movsxd	 rax, DWORD PTR bufsize$[rsp]
  00028	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR numbufs$[rsp]
  0002d	48 8b d0	 mov	 rdx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ca$[rsp]
  0003b	48 89 81 a8 00
	01 00		 mov	 QWORD PTR [rcx+65704], rax

; 871  :     if (!ca->poolarea) {

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00047	48 83 b8 a8 00
	01 00 00	 cmp	 QWORD PTR [rax+65704], 0
  0004f	75 02		 jne	 SHORT $LN5@init_bufpo

; 872  :         return;

  00051	eb 5e		 jmp	 SHORT $LN1@init_bufpo
$LN5@init_bufpo:

; 873  :     }
; 874  :     areap = ca->poolarea;

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00058	48 8b 80 a8 00
	01 00		 mov	 rax, QWORD PTR [rax+65704]
  0005f	48 89 44 24 30	 mov	 QWORD PTR areap$[rsp], rax

; 875  :     for (i1 = 0; i1 < numbufs; i1++) {

  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i1$[rsp], 0
  0006c	eb 0a		 jmp	 SHORT $LN4@init_bufpo
$LN2@init_bufpo:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR i1$[rsp]
  00072	ff c0		 inc	 eax
  00074	89 44 24 20	 mov	 DWORD PTR i1$[rsp], eax
$LN4@init_bufpo:
  00078	8b 44 24 24	 mov	 eax, DWORD PTR numbufs$[rsp]
  0007c	39 44 24 20	 cmp	 DWORD PTR i1$[rsp], eax
  00080	7d 2f		 jge	 SHORT $LN3@init_bufpo

; 876  :         put_bufpool(&ca->freeq, areap);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR ca$[rsp]
  00087	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  0008d	48 8b 54 24 30	 mov	 rdx, QWORD PTR areap$[rsp]
  00092	48 8b c8	 mov	 rcx, rax
  00095	e8 00 00 00 00	 call	 put_bufpool

; 877  :         areap += (bufsize);

  0009a	48 63 44 24 28	 movsxd	 rax, DWORD PTR bufsize$[rsp]
  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR areap$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 30	 mov	 QWORD PTR areap$[rsp], rax

; 878  :     }

  000af	eb bd		 jmp	 SHORT $LN2@init_bufpo
$LN3@init_bufpo:
$LN1@init_bufpo:

; 879  : }

  000b1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b5	c3		 ret	 0
init_bufpool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
elep$ = 0
anchor$ = 32
get_bufpool PROC

; 855  : static BYTE * get_bufpool(void ** anchor) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 856  :     void ** elep = *anchor;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR anchor$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR elep$[rsp], rax

; 857  :     if (elep) {

  00015	48 83 3c 24 00	 cmp	 QWORD PTR elep$[rsp], 0
  0001a	74 11		 je	 SHORT $LN2@get_bufpoo

; 858  :         *anchor = *elep;

  0001c	48 8b 44 24 20	 mov	 rax, QWORD PTR anchor$[rsp]
  00021	48 8b 0c 24	 mov	 rcx, QWORD PTR elep$[rsp]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	48 89 08	 mov	 QWORD PTR [rax], rcx

; 859  :     } else {

  0002b	eb 0c		 jmp	 SHORT $LN3@get_bufpoo
$LN2@get_bufpoo:

; 860  :         *anchor = 0;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR anchor$[rsp]
  00032	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN3@get_bufpoo:

; 861  :     }
; 862  :     return (BYTE*)elep;

  00039	48 8b 04 24	 mov	 rax, QWORD PTR elep$[rsp]

; 863  : }

  0003d	48 83 c4 18	 add	 rsp, 24
  00041	c3		 ret	 0
get_bufpool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
elep$ = 0
anchor$ = 32
ele$ = 40
put_bufpool PROC

; 845  : static void put_bufpool(void ** anchor, BYTE * ele) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 846  :     void ** elep = anchor;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR anchor$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR elep$[rsp], rax
$LN2@put_bufpoo:

; 847  :     for (;;) {
; 848  :         if (!*elep) break;

  00017	48 8b 04 24	 mov	 rax, QWORD PTR elep$[rsp]
  0001b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001f	75 02		 jne	 SHORT $LN5@put_bufpoo
  00021	eb 0d		 jmp	 SHORT $LN3@put_bufpoo
$LN5@put_bufpoo:

; 849  :         elep = *elep;

  00023	48 8b 04 24	 mov	 rax, QWORD PTR elep$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 04 24	 mov	 QWORD PTR elep$[rsp], rax

; 850  :     }

  0002e	eb e7		 jmp	 SHORT $LN2@put_bufpoo
$LN3@put_bufpoo:

; 851  :     *elep = ele;

  00030	48 8b 04 24	 mov	 rax, QWORD PTR elep$[rsp]
  00034	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ele$[rsp]
  00039	48 89 08	 mov	 QWORD PTR [rax], rcx

; 852  :     *(void**)ele = 0;

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR ele$[rsp]
  00041	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 853  : }

  00048	48 83 c4 18	 add	 rsp, 24
  0004c	c3		 ret	 0
put_bufpool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
i$ = 96
tv72 = 104
tv78 = 108
tv95 = 112
tv133 = 116
tv157 = 120
tv163 = 124
tv202 = 128
tv208 = 132
tv231 = 136
tv237 = 140
tv261 = 144
tv272 = 148
tv278 = 152
$T1 = 160
$T2 = 168
$T3 = 176
$T4 = 184
byte$ = 192
buf$ = 208
__$ArrayPad$ = 336
txt$ = 368
dev$ = 376
bfr$ = 384
sz$ = 392
logdump	PROC

; 798  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 799  :     char buf[128];
; 800  :     char byte[5];
; 801  :     size_t i;
; 802  :     if(!dev->ccwtrace)

  0002d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0003b	c1 e8 0f	 shr	 eax, 15
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	75 05		 jne	 SHORT $LN8@logdump

; 803  :     {
; 804  :         return;

  00045	e9 3d 07 00 00	 jmp	 $LN1@logdump
$LN8@logdump:

; 805  :     }
; 806  :     WRMSG(HHC01048,"D",LCSS_DEVNUM,txt);

  0004a	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 12		 je	 SHORT $LN15@logdump
  00055	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00061	89 44 24 68	 mov	 DWORD PTR tv72[rsp], eax
  00065	eb 08		 jmp	 SHORT $LN16@logdump
$LN15@logdump:
  00067	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN16@logdump:
  0006f	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00078	74 14		 je	 SHORT $LN17@logdump
  0007a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00082	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00086	d1 f8		 sar	 eax, 1
  00088	89 44 24 6c	 mov	 DWORD PTR tv78[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN18@logdump
$LN17@logdump:
  0008e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN18@logdump:
  00096	b9 01 00 00 00	 mov	 ecx, 1
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a1	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR txt$[rsp]
  000a9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ae	8b 4c 24 68	 mov	 ecx, DWORD PTR tv72[rsp]
  000b2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b6	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv78[rsp]
  000ba	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168585
  000c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168586
  000d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168587
  000e8	ba 26 03 00 00	 mov	 edx, 806		; 00000326H
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168588
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 807  :     WRMSG(HHC01049,"D",LCSS_DEVNUM,txt,(u_int)sz,(u_int)sz);

  000fa	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00103	74 12		 je	 SHORT $LN19@logdump
  00105	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00111	89 44 24 70	 mov	 DWORD PTR tv95[rsp], eax
  00115	eb 08		 jmp	 SHORT $LN20@logdump
$LN19@logdump:
  00117	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN20@logdump:
  0011f	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00128	74 14		 je	 SHORT $LN21@logdump
  0012a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00132	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00136	d1 f8		 sar	 eax, 1
  00138	89 44 24 74	 mov	 DWORD PTR tv133[rsp], eax
  0013c	eb 08		 jmp	 SHORT $LN22@logdump
$LN21@logdump:
  0013e	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN22@logdump:
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00151	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR sz$[rsp]
  00158	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0015c	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR sz$[rsp]
  00163	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00167	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR txt$[rsp]
  0016f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00174	8b 4c 24 70	 mov	 ecx, DWORD PTR tv95[rsp]
  00178	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv133[rsp]
  00180	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168589
  0018b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168590
  00197	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168591
  001ae	ba 27 03 00 00	 mov	 edx, 807		; 00000327H
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168592
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 808  :     buf[0] = 0;

  001c0	b8 01 00 00 00	 mov	 eax, 1
  001c5	48 6b c0 00	 imul	 rax, rax, 0
  001c9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  001d1	48 81 bc 24 a0
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T1[rsp], 128	; 00000080H
  001dd	73 02		 jae	 SHORT $LN23@logdump
  001df	eb 05		 jmp	 SHORT $LN24@logdump
$LN23@logdump:
  001e1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN24@logdump:
  001e6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  001ee	c6 84 04 d0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 809  :     for(i=0;i<sz;i++)

  001f6	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001ff	eb 0d		 jmp	 SHORT $LN4@logdump
$LN2@logdump:
  00201	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00206	48 ff c0	 inc	 rax
  00209	48 89 44 24 60	 mov	 QWORD PTR i$[rsp], rax
$LN4@logdump:
  0020e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR sz$[rsp]
  00216	48 39 44 24 60	 cmp	 QWORD PTR i$[rsp], rax
  0021b	0f 83 c7 01 00
	00		 jae	 $LN3@logdump

; 810  :     {
; 811  :         if(i%16==0)

  00221	33 d2		 xor	 edx, edx
  00223	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00228	b9 10 00 00 00	 mov	 ecx, 16
  0022d	48 f7 f1	 div	 rcx
  00230	48 8b c2	 mov	 rax, rdx
  00233	48 85 c0	 test	 rax, rax
  00236	0f 85 1e 01 00
	00		 jne	 $LN9@logdump

; 812  :         {
; 813  :             if(i!=0)

  0023c	48 83 7c 24 60
	00		 cmp	 QWORD PTR i$[rsp], 0
  00242	0f 84 f3 00 00
	00		 je	 $LN10@logdump

; 814  :             {
; 815  :                 WRMSG(HHC01050,"D",LCSS_DEVNUM,txt,buf);

  00248	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00251	74 12		 je	 SHORT $LN25@logdump
  00253	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0025f	89 44 24 78	 mov	 DWORD PTR tv157[rsp], eax
  00263	eb 08		 jmp	 SHORT $LN26@logdump
$LN25@logdump:
  00265	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN26@logdump:
  0026d	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00276	74 14		 je	 SHORT $LN27@logdump
  00278	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00280	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00284	d1 f8		 sar	 eax, 1
  00286	89 44 24 7c	 mov	 DWORD PTR tv163[rsp], eax
  0028a	eb 08		 jmp	 SHORT $LN28@logdump
$LN27@logdump:
  0028c	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN28@logdump:
  00294	b9 01 00 00 00	 mov	 ecx, 1
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029f	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002a7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002ac	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR txt$[rsp]
  002b4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b9	8b 4c 24 78	 mov	 ecx, DWORD PTR tv157[rsp]
  002bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c1	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv163[rsp]
  002c5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168595
  002d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168596
  002dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168597
  002f3	ba 2f 03 00 00	 mov	 edx, 815		; 0000032fH
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168598
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 816  :                 buf[0] = 0;

  00305	b8 01 00 00 00	 mov	 eax, 1
  0030a	48 6b c0 00	 imul	 rax, rax, 0
  0030e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00316	48 81 bc 24 a8
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T2[rsp], 128	; 00000080H
  00322	73 02		 jae	 SHORT $LN29@logdump
  00324	eb 05		 jmp	 SHORT $LN30@logdump
$LN29@logdump:
  00326	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN30@logdump:
  0032b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  00333	c6 84 04 d0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN10@logdump:

; 817  :             }
; 818  :             MSGBUF(buf, ": %04X:", (unsigned) i);

  0033b	44 8b 4c 24 60	 mov	 r9d, DWORD PTR i$[rsp]
  00340	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168599
  00347	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0034c	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00354	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@logdump:

; 819  :         }
; 820  :         if(i%4==0 && i)

  0035a	33 d2		 xor	 edx, edx
  0035c	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00361	b9 04 00 00 00	 mov	 ecx, 4
  00366	48 f7 f1	 div	 rcx
  00369	48 8b c2	 mov	 rax, rdx
  0036c	48 85 c0	 test	 rax, rax
  0036f	75 23		 jne	 SHORT $LN11@logdump
  00371	48 83 7c 24 60
	00		 cmp	 QWORD PTR i$[rsp], 0
  00377	74 1b		 je	 SHORT $LN11@logdump

; 821  :         {
; 822  :             STRLCAT( buf, " " );

  00379	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168601
  00386	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN11@logdump:

; 823  :         }
; 824  :         MSGBUF(byte, "%02X", bfr[i]);

  00394	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00399	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR bfr$[rsp]
  003a1	48 03 c8	 add	 rcx, rax
  003a4	48 8b c1	 mov	 rax, rcx
  003a7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003aa	44 8b c8	 mov	 r9d, eax
  003ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168602
  003b4	ba 05 00 00 00	 mov	 edx, 5
  003b9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR byte$[rsp]
  003c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 825  :         STRLCAT( buf, byte );

  003c7	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  003cd	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR byte$[rsp]
  003d5	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 826  :     }

  003e3	e9 19 fe ff ff	 jmp	 $LN2@logdump
$LN3@logdump:

; 827  :     WRMSG(HHC01050,"D",LCSS_DEVNUM,txt,buf);

  003e8	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003f1	74 15		 je	 SHORT $LN31@logdump
  003f3	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003fb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ff	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv202[rsp], eax
  00406	eb 0b		 jmp	 SHORT $LN32@logdump
$LN31@logdump:
  00408	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv202[rsp], 0
$LN32@logdump:
  00413	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0041c	74 17		 je	 SHORT $LN33@logdump
  0041e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00426	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0042a	d1 f8		 sar	 eax, 1
  0042c	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
  00433	eb 0b		 jmp	 SHORT $LN34@logdump
$LN33@logdump:
  00435	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv208[rsp], 0
$LN34@logdump:
  00440	b9 01 00 00 00	 mov	 ecx, 1
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044b	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00453	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00458	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR txt$[rsp]
  00460	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00465	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv202[rsp]
  0046c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00470	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv208[rsp]
  00477	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0047b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168603
  00482	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00487	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168604
  0048e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00493	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00498	41 b9 03 00 00
	00		 mov	 r9d, 3
  0049e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168605
  004a5	ba 3b 03 00 00	 mov	 edx, 827		; 0000033bH
  004aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168606
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 828  :     buf[0] = 0;

  004b7	b8 01 00 00 00	 mov	 eax, 1
  004bc	48 6b c0 00	 imul	 rax, rax, 0
  004c0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  004c8	48 81 bc 24 b0
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T3[rsp], 128	; 00000080H
  004d4	73 02		 jae	 SHORT $LN35@logdump
  004d6	eb 05		 jmp	 SHORT $LN36@logdump
$LN35@logdump:
  004d8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN36@logdump:
  004dd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  004e5	c6 84 04 d0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 829  :     for(i=0;i<sz;i++)

  004ed	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  004f6	eb 0d		 jmp	 SHORT $LN7@logdump
$LN5@logdump:
  004f8	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  004fd	48 ff c0	 inc	 rax
  00500	48 89 44 24 60	 mov	 QWORD PTR i$[rsp], rax
$LN7@logdump:
  00505	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR sz$[rsp]
  0050d	48 39 44 24 60	 cmp	 QWORD PTR i$[rsp], rax
  00512	0f 83 ad 01 00
	00		 jae	 $LN6@logdump

; 830  :     {
; 831  :         if(i%16==0)

  00518	33 d2		 xor	 edx, edx
  0051a	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  0051f	b9 10 00 00 00	 mov	 ecx, 16
  00524	48 f7 f1	 div	 rcx
  00527	48 8b c2	 mov	 rax, rdx
  0052a	48 85 c0	 test	 rax, rax
  0052d	0f 85 04 01 00
	00		 jne	 $LN12@logdump

; 832  :         {
; 833  :             if(i!=0)

  00533	48 83 7c 24 60
	00		 cmp	 QWORD PTR i$[rsp], 0
  00539	0f 84 f8 00 00
	00		 je	 $LN13@logdump

; 834  :             {
; 835  :                 WRMSG(HHC01051,"D",LCSS_DEVNUM,buf);

  0053f	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00548	74 15		 je	 SHORT $LN37@logdump
  0054a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00552	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00556	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv231[rsp], eax
  0055d	eb 0b		 jmp	 SHORT $LN38@logdump
$LN37@logdump:
  0055f	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv231[rsp], 0
$LN38@logdump:
  0056a	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00573	74 17		 je	 SHORT $LN39@logdump
  00575	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0057d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00581	d1 f8		 sar	 eax, 1
  00583	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  0058a	eb 0b		 jmp	 SHORT $LN40@logdump
$LN39@logdump:
  0058c	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv237[rsp], 0
$LN40@logdump:
  00597	b9 01 00 00 00	 mov	 ecx, 1
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a2	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005aa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005af	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv231[rsp]
  005b6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005ba	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  005c1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168609
  005cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168610
  005d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168611
  005ef	ba 43 03 00 00	 mov	 edx, 835		; 00000343H
  005f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168612
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 836  :                 buf[0] = 0;

  00601	b8 01 00 00 00	 mov	 eax, 1
  00606	48 6b c0 00	 imul	 rax, rax, 0
  0060a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  00612	48 81 bc 24 b8
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T4[rsp], 128	; 00000080H
  0061e	73 02		 jae	 SHORT $LN41@logdump
  00620	eb 05		 jmp	 SHORT $LN42@logdump
$LN41@logdump:
  00622	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN42@logdump:
  00627	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  0062f	c6 84 04 d0 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN13@logdump:
$LN12@logdump:

; 837  :             }
; 838  :         }
; 839  :         MSGBUF(byte, "%c",(bfr[i] & 0x7f) < 0x20 ? '.' : (bfr[i] & 0x7f));

  00637	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  0063c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR bfr$[rsp]
  00644	48 03 c8	 add	 rcx, rax
  00647	48 8b c1	 mov	 rax, rcx
  0064a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0064d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00650	83 f8 20	 cmp	 eax, 32			; 00000020H
  00653	7d 0d		 jge	 SHORT $LN43@logdump
  00655	c7 84 24 90 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv261[rsp], 46 ; 0000002eH
  00660	eb 20		 jmp	 SHORT $LN44@logdump
$LN43@logdump:
  00662	48 8b 44 24 60	 mov	 rax, QWORD PTR i$[rsp]
  00667	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR bfr$[rsp]
  0066f	48 03 c8	 add	 rcx, rax
  00672	48 8b c1	 mov	 rax, rcx
  00675	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00678	83 e0 7f	 and	 eax, 127		; 0000007fH
  0067b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv261[rsp], eax
$LN44@logdump:
  00682	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR tv261[rsp]
  0068a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168613
  00691	ba 05 00 00 00	 mov	 edx, 5
  00696	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR byte$[rsp]
  0069e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 840  :         STRLCAT( buf, byte );

  006a4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  006aa	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR byte$[rsp]
  006b2	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  006ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 841  :     }

  006c0	e9 33 fe ff ff	 jmp	 $LN5@logdump
$LN6@logdump:

; 842  :     WRMSG(HHC01051,"D",LCSS_DEVNUM,buf);

  006c5	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006ce	74 15		 je	 SHORT $LN45@logdump
  006d0	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006d8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006dc	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  006e3	eb 0b		 jmp	 SHORT $LN46@logdump
$LN45@logdump:
  006e5	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv272[rsp], 0
$LN46@logdump:
  006f0	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006f9	74 17		 je	 SHORT $LN47@logdump
  006fb	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00703	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00707	d1 f8		 sar	 eax, 1
  00709	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv278[rsp], eax
  00710	eb 0b		 jmp	 SHORT $LN48@logdump
$LN47@logdump:
  00712	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv278[rsp], 0
$LN48@logdump:
  0071d	b9 01 00 00 00	 mov	 ecx, 1
  00722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00728	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00730	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00735	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv272[rsp]
  0073c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00740	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  00747	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0074b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168614
  00752	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00757	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168615
  0075e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00763	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00768	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168616
  00775	ba 4a 03 00 00	 mov	 edx, 842		; 0000034aH
  0077a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168617
  00781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN1@logdump:
$LN14@logdump:

; 843  : }

  00787	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0078f	48 33 cc	 xor	 rcx, rsp
  00792	e8 00 00 00 00	 call	 __security_check_cookie
  00797	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  0079e	c3		 ret	 0
logdump	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
class$ = 96
len$ = 104
csock$ = 112
extended$ = 116
model$ = 117
rc$ = 120
tv274 = 124
devnum$ = 128
namelen$ = 132
clientip$ = 136
tv159 = 144
tv167 = 152
client$ = 160
devmsg$ = 176
num_procs$ = 208
group$ = 224
hostmsg$ = 240
conmsg$ = 496
buf$ = 752
__$ArrayPad$ = 1008
csockp$ = 1040
connect_client PROC

; 683  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 08 04
	00 00		 sub	 rsp, 1032		; 00000408H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 f0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 684  : int                     rc;             /* Return code               */
; 685  : size_t                  len;            /* Data length               */
; 686  : int                     csock;          /* Socket for conversation   */
; 687  : struct sockaddr_in      client;         /* Client address structure  */
; 688  : socklen_t               namelen;        /* Length of client structure*/
; 689  : char                   *clientip;       /* Addr of client ip address */
; 690  : U16                     devnum;         /* Requested device number   */
; 691  : BYTE                    class;          /* D=3270, P=3287, K=3215/1052 */
; 692  : BYTE                    model;          /* 3270 model (2,3,4,5,X)    */
; 693  : BYTE                    extended;       /* Extended attributes (Y,N) */
; 694  : char                    buf[256];       /* Message buffer            */
; 695  : char                    conmsg[256];    /* Connection message        */
; 696  : char                    devmsg[25];     /* Device message            */
; 697  : char                    hostmsg[256];   /* Host ID message           */
; 698  : char                    num_procs[16];  /* #of processors string     */
; 699  : char                    group[16];      /* Console group             */
; 700  : 
; 701  :     /* Load the socket address from the thread parameter */
; 702  :     csock = *csockp;

  0001e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR csockp$[rsp]
  00026	8b 00		 mov	 eax, DWORD PTR [rax]
  00028	89 44 24 70	 mov	 DWORD PTR csock$[rsp], eax

; 703  : 
; 704  :     /* Obtain the client's IP address */
; 705  :     namelen = sizeof(client);

  0002c	c7 84 24 84 00
	00 00 10 00 00
	00		 mov	 DWORD PTR namelen$[rsp], 16

; 706  :     rc = getpeername (csock, (struct sockaddr *)&client, &namelen);

  00037	48 63 44 24 70	 movsxd	 rax, DWORD PTR csock$[rsp]
  0003c	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR namelen$[rsp]
  00044	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR client$[rsp]
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  00055	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 707  : 
; 708  :     /* Log the client's IP address and hostname */
; 709  :     clientip = strdup(inet_ntoa(client.sin_addr));

  00059	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR client$[rsp+4]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00066	48 8b c8	 mov	 rcx, rax
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0006f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR clientip$[rsp], rax

; 710  : 
; 711  :     TNSDEBUG1("console: DBG018: Received connection from %s\n",
; 712  :             clientip );
; 713  : 
; 714  :     /* Negotiate telnet parameters */
; 715  :     rc = negotiate (csock, &class, &model, &extended, &devnum, group);

  00077	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR group$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR devnum$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 4c 24 74	 lea	 r9, QWORD PTR extended$[rsp]
  00096	4c 8d 44 24 75	 lea	 r8, QWORD PTR model$[rsp]
  0009b	48 8d 54 24 60	 lea	 rdx, QWORD PTR class$[rsp]
  000a0	8b 4c 24 70	 mov	 ecx, DWORD PTR csock$[rsp]
  000a4	e8 00 00 00 00	 call	 negotiate
  000a9	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 716  :     if (rc != 0)

  000ad	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  000b2	74 2a		 je	 SHORT $LN14@connect_cl

; 717  :     {
; 718  :         close_socket (csock);

  000b4	8b 4c 24 70	 mov	 ecx, DWORD PTR csock$[rsp]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 719  :         if (clientip) free(clientip);

  000be	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR clientip$[rsp], 0
  000c7	74 0e		 je	 SHORT $LN15@connect_cl
  000c9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN15@connect_cl:

; 720  :         return 0;

  000d7	33 c0		 xor	 eax, eax
  000d9	e9 e7 03 00 00	 jmp	 $LN1@connect_cl
$LN14@connect_cl:

; 721  :     }
; 722  : 
; 723  :     /* Build connection message for client */
; 724  : 
; 725  :     if ( cons_hostinfo.num_procs > 1 )

  000de	83 3d b8 01 00
	00 01		 cmp	 DWORD PTR cons_hostinfo+440, 1
  000e5	7e 23		 jle	 SHORT $LN16@connect_cl

; 726  :         MSGBUF( num_procs,  "MP=%d", cons_hostinfo.num_procs );

  000e7	44 8b 0d b8 01
	00 00		 mov	 r9d, DWORD PTR cons_hostinfo+440
  000ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168518
  000f5	ba 10 00 00 00	 mov	 edx, 16
  000fa	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR num_procs$[rsp]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00108	eb 1b		 jmp	 SHORT $LN17@connect_cl
$LN16@connect_cl:

; 727  :     else
; 728  :         STRLCPY( num_procs, "UP" );

  0010a	41 b8 10 00 00
	00		 mov	 r8d, 16
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168519
  00117	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR num_procs$[rsp]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN17@connect_cl:

; 729  : 
; 730  :     MSGBUF

  00125	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR num_procs$[rsp]
  0012d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00132	48 8d 05 30 01
	00 00		 lea	 rax, OFFSET FLAT:cons_hostinfo+304
  00139	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0013e	48 8d 05 f0 00
	00 00		 lea	 rax, OFFSET FLAT:cons_hostinfo+240
  00145	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0014a	48 8d 05 b0 00
	00 00		 lea	 rax, OFFSET FLAT:cons_hostinfo+176
  00151	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00156	48 8d 05 30 00
	00 00		 lea	 rax, OFFSET FLAT:cons_hostinfo+48
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	4c 8d 0d 70 00
	00 00		 lea	 r9, OFFSET FLAT:cons_hostinfo+112
  00169	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168520
  00170	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00175	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 731  :     (
; 732  :         hostmsg,
; 733  : 
; 734  :         "running on %s (%s-%s.%s %s %s)"
; 735  : 
; 736  :         ,cons_hostinfo.nodename
; 737  :         ,cons_hostinfo.sysname
; 738  :         ,cons_hostinfo.release
; 739  :         ,cons_hostinfo.version
; 740  :         ,cons_hostinfo.machine
; 741  :         ,num_procs
; 742  :     );
; 743  :     MSGBUF (conmsg,

  00183	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168521
  0018a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168522
  00196	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168523
  001a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168524
  001a9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001ae	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR conmsg$[rsp]
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 744  :                 "Hercules version %s built on %s %s",
; 745  :                 VERSION, __DATE__, __TIME__);
; 746  : 
; 747  :     {
; 748  :         MSGBUF (devmsg, "Connected to device %4.4X",

  001bc	45 33 c9	 xor	 r9d, r9d
  001bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168525
  001c6	ba 19 00 00 00	 mov	 edx, 25
  001cb	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR devmsg$[rsp]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 749  :                   0);
; 750  :     }
; 751  : 
; 752  :     WRMSG(HHC01018, "I", 0, 0, clientip, 0x3270);

  001d9	b9 01 00 00 00	 mov	 ecx, 1
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e4	c7 44 24 50 70
	32 00 00	 mov	 DWORD PTR [rsp+80], 12912 ; 00003270H
  001ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  001f4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f9	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00202	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168526
  00212	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168527
  0021e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168528
  00235	ba f0 02 00 00	 mov	 edx, 752		; 000002f0H
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168529
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 753  : 
; 754  :     /* Send connection message to client */
; 755  :     if (class != 'K')

  00247	0f b6 44 24 60	 movzx	 eax, BYTE PTR class$[rsp]
  0024c	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0024f	0f 84 e2 01 00
	00		 je	 $LN18@connect_cl

; 756  :     {
; 757  :         len = MSGBUF (buf,

  00255	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR devmsg$[rsp]
  0025d	e8 00 00 00 00	 call	 strlen
  00262	44 8b c0	 mov	 r8d, eax
  00265	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR devmsg$[rsp]
  0026d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR devmsg$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  0027b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  00283	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  0028b	e8 00 00 00 00	 call	 strlen
  00290	44 8b c0	 mov	 r8d, eax
  00293	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR hostmsg$[rsp]
  0029b	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  002a9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
  002b1	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR conmsg$[rsp]
  002b9	e8 00 00 00 00	 call	 strlen
  002be	44 8b c0	 mov	 r8d, eax
  002c1	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR conmsg$[rsp]
  002c9	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR conmsg$[rsp]
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  002d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  002df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv167[rsp]
  002ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002f1	4c 8b c8	 mov	 r9, rax
  002f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168532
  002fb	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00300	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0030e	48 98		 cdqe
  00310	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax

; 758  :                     "\xF5\x40\x11\x40\x40\x1D\x60%s"
; 759  :                     "\x11\xC1\x50\x1D\x60%s"
; 760  :                     "\x11\xC2\x60\x1D\x60%s",
; 761  :                     prt_host_to_guest( (BYTE*) conmsg,  (BYTE*) conmsg,  strlen( conmsg  )),
; 762  :                     prt_host_to_guest( (BYTE*) hostmsg, (BYTE*) hostmsg, strlen( hostmsg )),
; 763  :                     prt_host_to_guest( (BYTE*) devmsg,  (BYTE*) devmsg,  strlen( devmsg  )));
; 764  : 
; 765  :         if (len < sizeof(buf))

  00315	48 81 7c 24 68
	00 01 00 00	 cmp	 QWORD PTR len$[rsp], 256 ; 00000100H
  0031e	73 1c		 jae	 SHORT $LN20@connect_cl

; 766  :         {
; 767  :             buf[len++] = (char) IAC;

  00320	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  00325	c6 84 04 f0 02
	00 00 ff	 mov	 BYTE PTR buf$[rsp+rax], -1
  0032d	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  00332	48 ff c0	 inc	 rax
  00335	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax

; 768  :         }

  0033a	eb 69		 jmp	 SHORT $LN21@connect_cl
$LN20@connect_cl:
$LN4@connect_cl:

; 769  :         else
; 770  :         {
; 771  :             ASSERT(FALSE);

  0033c	33 c0		 xor	 eax, eax
  0033e	83 f8 01	 cmp	 eax, 1
  00341	74 5c		 je	 SHORT $LN22@connect_cl
$LN7@connect_cl:
  00343	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168536
  0034a	41 b8 03 03 00
	00		 mov	 r8d, 771		; 00000303H
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168537
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168538
  0035e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0036a	85 c0		 test	 eax, eax
  0036c	74 20		 je	 SHORT $LN23@connect_cl
  0036e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168540
  00375	41 b8 03 03 00
	00		 mov	 r8d, 771		; 00000303H
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168541
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168542
  00389	e8 00 00 00 00	 call	 DebuggerTrace
$LN23@connect_cl:
  0038e	33 c0		 xor	 eax, eax
  00390	85 c0		 test	 eax, eax
  00392	75 af		 jne	 SHORT $LN7@connect_cl
  00394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0039a	85 c0		 test	 eax, eax
  0039c	74 01		 je	 SHORT $LN24@connect_cl
  0039e	cc		 int	 3
$LN24@connect_cl:
$LN22@connect_cl:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	75 97		 jne	 SHORT $LN4@connect_cl
$LN21@connect_cl:

; 772  :         }
; 773  : 
; 774  :         if (len < sizeof(buf))

  003a5	48 81 7c 24 68
	00 01 00 00	 cmp	 QWORD PTR len$[rsp], 256 ; 00000100H
  003ae	73 1c		 jae	 SHORT $LN25@connect_cl

; 775  :         {
; 776  :             buf[len++] = (char) EOR_MARK;

  003b0	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  003b5	c6 84 04 f0 02
	00 00 ef	 mov	 BYTE PTR buf$[rsp+rax], -17
  003bd	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  003c2	48 ff c0	 inc	 rax
  003c5	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax

; 777  :         }

  003ca	eb 69		 jmp	 SHORT $LN26@connect_cl
$LN25@connect_cl:
$LN10@connect_cl:

; 778  :         else
; 779  :         {
; 780  :             ASSERT(FALSE);

  003cc	33 c0		 xor	 eax, eax
  003ce	83 f8 01	 cmp	 eax, 1
  003d1	74 5c		 je	 SHORT $LN27@connect_cl
$LN13@connect_cl:
  003d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168547
  003da	41 b8 0c 03 00
	00		 mov	 r8d, 780		; 0000030cH
  003e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168548
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168549
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003fa	85 c0		 test	 eax, eax
  003fc	74 20		 je	 SHORT $LN28@connect_cl
  003fe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168551
  00405	41 b8 0c 03 00
	00		 mov	 r8d, 780		; 0000030cH
  0040b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168552
  00412	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168553
  00419	e8 00 00 00 00	 call	 DebuggerTrace
$LN28@connect_cl:
  0041e	33 c0		 xor	 eax, eax
  00420	85 c0		 test	 eax, eax
  00422	75 af		 jne	 SHORT $LN13@connect_cl
  00424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0042a	85 c0		 test	 eax, eax
  0042c	74 01		 je	 SHORT $LN29@connect_cl
  0042e	cc		 int	 3
$LN29@connect_cl:
$LN27@connect_cl:
  0042f	33 c0		 xor	 eax, eax
  00431	85 c0		 test	 eax, eax
  00433	75 97		 jne	 SHORT $LN10@connect_cl
$LN26@connect_cl:

; 781  :         }
; 782  :     }

  00435	eb 43		 jmp	 SHORT $LN19@connect_cl
$LN18@connect_cl:

; 783  :     else
; 784  :     {
; 785  :         len = MSGBUF (buf, "%s\r\n%s\r\n%s\r\n",

  00437	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR devmsg$[rsp]
  0043f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00444	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR hostmsg$[rsp]
  0044c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00451	4c 8d 8c 24 f0
	01 00 00	 lea	 r9, QWORD PTR conmsg$[rsp]
  00459	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168555
  00460	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00465	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00473	48 98		 cdqe
  00475	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax
$LN19@connect_cl:

; 786  :                         conmsg, hostmsg, devmsg);
; 787  :     }
; 788  : 
; 789  :     if (class != 'P')  /* do not write connection resp on 3287 */

  0047a	0f b6 44 24 60	 movzx	 eax, BYTE PTR class$[rsp]
  0047f	83 f8 50	 cmp	 eax, 80			; 00000050H
  00482	74 21		 je	 SHORT $LN30@connect_cl

; 790  :     {
; 791  :         rc = send_packet (csock, (BYTE *)buf, (int)len, "CONNECTION RESPONSE");

  00484	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168557
  0048b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00490	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00498	8b 4c 24 70	 mov	 ecx, DWORD PTR csock$[rsp]
  0049c	e8 00 00 00 00	 call	 send_packet
  004a1	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax
$LN30@connect_cl:

; 792  :     }
; 793  :     return (class == 'D') ? 1 : 0;   /* return 1 if 3270 */

  004a5	0f b6 44 24 60	 movzx	 eax, BYTE PTR class$[rsp]
  004aa	83 f8 44	 cmp	 eax, 68			; 00000044H
  004ad	75 0a		 jne	 SHORT $LN32@connect_cl
  004af	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv274[rsp], 1
  004b7	eb 08		 jmp	 SHORT $LN33@connect_cl
$LN32@connect_cl:
  004b9	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv274[rsp], 0
$LN33@connect_cl:
  004c1	8b 44 24 7c	 mov	 eax, DWORD PTR tv274[rsp]
$LN1@connect_cl:

; 794  : } /* end function connect_client */

  004c5	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004cd	48 33 cc	 xor	 rcx, rsp
  004d0	e8 00 00 00 00	 call	 __security_check_cookie
  004d5	48 81 c4 08 04
	00 00		 add	 rsp, 1032		; 00000408H
  004dc	c3		 ret	 0
connect_client ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
rc$ = 32
termtype$ = 40
c$ = 48
devnum$ = 52
s$ = 56
$T1 = 64
buf$ = 80
__$ArrayPad$ = 592
csock$ = 624
class$ = 632
model$ = 640
extatr$ = 648
devn$ = 656
group$ = 664
negotiate PROC

; 523  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 524  : int    rc;                              /* Return code               */
; 525  : char*  termtype;                        /* Pointer to terminal type  */
; 526  : char*  s;                               /* String pointer            */
; 527  : BYTE   c;                               /* Trailing character        */
; 528  : U16    devnum;                          /* Requested device number   */
; 529  : BYTE   buf[512];                        /* Telnet negotiation buffer */
; 530  : 
; 531  : static BYTE do_term   [] = { IAC, DO,   TERMINAL_TYPE };
; 532  : static BYTE will_term [] = { IAC, WILL, TERMINAL_TYPE };
; 533  : static BYTE req_type  [] = { IAC, SB,   TERMINAL_TYPE, SEND, IAC, SE };
; 534  : static BYTE type_is   [] = { IAC, SB,   TERMINAL_TYPE, IS };
; 535  : static BYTE do_eor    [] = { IAC, DO,   EOR, IAC, WILL, EOR };
; 536  : static BYTE will_eor  [] = { IAC, WILL, EOR, IAC, DO,   EOR };
; 537  : static BYTE do_bin    [] = { IAC, DO,   BINARY, IAC, WILL, BINARY };
; 538  : static BYTE will_bin  [] = { IAC, WILL, BINARY, IAC, DO,   BINARY };
; 539  : static BYTE wont_echo [] = { IAC, WONT, ECHO_OPTION };
; 540  : static BYTE dont_echo [] = { IAC, DONT, ECHO_OPTION };
; 541  : static BYTE will_naws [] = { IAC, WILL, NAWS };
; 542  : 
; 543  :     /* Perform terminal-type negotiation */
; 544  :     rc = send_packet (csock, do_term, sizeof(do_term),

  0002c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168415
  00033	41 b8 03 00 00
	00		 mov	 r8d, 3
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?do_term@?1??negotiate@@9@9
  00040	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  00047	e8 00 00 00 00	 call	 send_packet
  0004c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 545  :                         "IAC DO TERMINAL_TYPE");
; 546  :     if (rc < 0) return -1;

  00050	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00055	7d 0a		 jge	 SHORT $LN2@negotiate
  00057	b8 ff ff ff ff	 mov	 eax, -1
  0005c	e9 61 06 00 00	 jmp	 $LN1@negotiate
$LN2@negotiate:

; 547  : 
; 548  :     rc = expect (csock, will_term, sizeof(will_term),

  00061	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168417
  00068	41 b8 03 00 00
	00		 mov	 r8d, 3
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?will_term@?1??negotiate@@9@9
  00075	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  0007c	e8 00 00 00 00	 call	 expect
  00081	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 549  :                         "IAC WILL TERMINAL_TYPE");
; 550  :     if (rc < 0) return -1;

  00085	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0008a	7d 0a		 jge	 SHORT $LN3@negotiate
  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 2c 06 00 00	 jmp	 $LN1@negotiate
$LN3@negotiate:

; 551  : 
; 552  :     /* Request terminal type */
; 553  :     rc = send_packet (csock, req_type, sizeof(req_type),

  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168419
  0009d	41 b8 06 00 00
	00		 mov	 r8d, 6
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?req_type@?1??negotiate@@9@9
  000aa	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  000b1	e8 00 00 00 00	 call	 send_packet
  000b6	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 554  :                         "IAC SB TERMINAL_TYPE SEND IAC SE");
; 555  :     if (rc < 0) return -1;

  000ba	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bf	7d 0a		 jge	 SHORT $LN4@negotiate
  000c1	b8 ff ff ff ff	 mov	 eax, -1
  000c6	e9 f7 05 00 00	 jmp	 $LN1@negotiate
$LN4@negotiate:

; 556  : 
; 557  :     rc = recv_packet (csock, buf, sizeof(buf)-2, SE);

  000cb	41 b1 f0	 mov	 r9b, 240		; 000000f0H
  000ce	41 b8 fe 01 00
	00		 mov	 r8d, 510		; 000001feH
  000d4	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$[rsp]
  000d9	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  000e0	e8 00 00 00 00	 call	 recv_packet
  000e5	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 558  :     if (rc < 0) return -1;

  000e9	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ee	7d 0a		 jge	 SHORT $LN5@negotiate
  000f0	b8 ff ff ff ff	 mov	 eax, -1
  000f5	e9 c8 05 00 00	 jmp	 $LN1@negotiate
$LN5@negotiate:

; 559  : 
; 560  :     /* Ignore Negotiate About Window Size */
; 561  :     if (rc >= (int)sizeof(will_naws) &&

  000fa	83 7c 24 20 03	 cmp	 DWORD PTR rc$[rsp], 3
  000ff	7c 4f		 jl	 SHORT $LN6@negotiate
  00101	41 b8 03 00 00
	00		 mov	 r8d, 3
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?will_naws@?1??negotiate@@9@9
  0010e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00113	e8 00 00 00 00	 call	 memcmp
  00118	85 c0		 test	 eax, eax
  0011a	75 34		 jne	 SHORT $LN6@negotiate

; 562  :         memcmp (buf, will_naws, sizeof(will_naws)) == 0)
; 563  :     {
; 564  :         memmove(buf, &buf[sizeof(will_naws)], (rc - sizeof(will_naws)));

  0011c	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  00121	48 83 e8 03	 sub	 rax, 3
  00125	b9 01 00 00 00	 mov	 ecx, 1
  0012a	48 6b c9 03	 imul	 rcx, rcx, 3
  0012e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  00133	4c 8b c0	 mov	 r8, rax
  00136	48 8b d1	 mov	 rdx, rcx
  00139	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0013e	e8 00 00 00 00	 call	 memmove

; 565  :         rc -= sizeof(will_naws);

  00143	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  00148	48 83 e8 03	 sub	 rax, 3
  0014c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN6@negotiate:

; 566  :     }
; 567  : 
; 568  :     if (rc < (int)(sizeof(type_is) + 2)
; 569  :         || memcmp(buf, type_is, sizeof(type_is)) != 0
; 570  :         || buf[rc-2] != IAC || buf[rc-1] != SE) {

  00150	83 7c 24 20 06	 cmp	 DWORD PTR rc$[rsp], 6
  00155	7c 44		 jl	 SHORT $LN8@negotiate
  00157	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?type_is@?1??negotiate@@9@9
  00164	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00169	e8 00 00 00 00	 call	 memcmp
  0016e	85 c0		 test	 eax, eax
  00170	75 29		 jne	 SHORT $LN8@negotiate
  00172	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00176	83 e8 02	 sub	 eax, 2
  00179	48 98		 cdqe
  0017b	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00180	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00185	75 14		 jne	 SHORT $LN8@negotiate
  00187	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0018b	ff c8		 dec	 eax
  0018d	48 98		 cdqe
  0018f	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00194	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00199	74 0a		 je	 SHORT $LN7@negotiate
$LN8@negotiate:

; 571  :         TNSDEBUG2("console: DBG008: Expected IAC SB TERMINAL_TYPE IS\n");
; 572  :         return -1;

  0019b	b8 ff ff ff ff	 mov	 eax, -1
  001a0	e9 1d 05 00 00	 jmp	 $LN1@negotiate
$LN7@negotiate:

; 573  :     }
; 574  :     buf[rc-2] = '\0';

  001a5	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  001a9	83 e8 02	 sub	 eax, 2
  001ac	48 98		 cdqe
  001ae	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  001b3	48 81 7c 24 40
	00 02 00 00	 cmp	 QWORD PTR $T1[rsp], 512	; 00000200H
  001bc	73 02		 jae	 SHORT $LN33@negotiate
  001be	eb 05		 jmp	 SHORT $LN34@negotiate
$LN33@negotiate:
  001c0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@negotiate:
  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  001ca	c6 44 04 50 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 575  :     termtype = (char *)(buf + sizeof(type_is));

  001cf	48 8d 44 24 54	 lea	 rax, QWORD PTR buf$[rsp+4]
  001d4	48 89 44 24 28	 mov	 QWORD PTR termtype$[rsp], rax

; 576  :     TNSDEBUG2("console: DBG009: Received IAC SB TERMINAL_TYPE IS %s IAC SE\n",
; 577  :             termtype);
; 578  : 
; 579  :     /* Check terminal type string for device name suffix */
; 580  :     s = strchr (termtype, '@');

  001d9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  001e3	e8 00 00 00 00	 call	 strchr
  001e8	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 581  :     if(s!=NULL)

  001ed	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  001f3	74 3d		 je	 SHORT $LN9@negotiate

; 582  :     {
; 583  :         if(strlen(s)<16)

  001f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  001fa	e8 00 00 00 00	 call	 strlen
  001ff	48 83 f8 10	 cmp	 rax, 16
  00203	73 2b		 jae	 SHORT $LN11@negotiate

; 584  :         {
; 585  :             strlcpy(group,&s[1],16);

  00205	b8 01 00 00 00	 mov	 eax, 1
  0020a	48 6b c0 01	 imul	 rax, rax, 1
  0020e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00213	48 03 c8	 add	 rcx, rax
  00216	48 8b c1	 mov	 rax, rcx
  00219	41 b8 10 00 00
	00		 mov	 r8d, 16
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR group$[rsp]
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN11@negotiate:

; 586  :         }
; 587  :     }

  00230	eb 15		 jmp	 SHORT $LN10@negotiate
$LN9@negotiate:

; 588  :     else
; 589  :     {
; 590  :         group[0]=0;

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 00	 imul	 rax, rax, 0
  0023b	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR group$[rsp]
  00243	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN10@negotiate:

; 591  :     }
; 592  : 
; 593  :     if (s != NULL && sscanf (s, "@%hx%c", &devnum,&c) == 1)

  00247	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  0024d	74 47		 je	 SHORT $LN12@negotiate
  0024f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  00254	4c 8d 44 24 34	 lea	 r8, QWORD PTR devnum$[rsp]
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168430
  00260	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00265	e8 00 00 00 00	 call	 sscanf
  0026a	83 f8 01	 cmp	 eax, 1
  0026d	75 27		 jne	 SHORT $LN12@negotiate

; 594  :     {
; 595  :         *devn = devnum;

  0026f	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR devn$[rsp]
  00277	0f b7 4c 24 34	 movzx	 ecx, WORD PTR devnum$[rsp]
  0027c	66 89 08	 mov	 WORD PTR [rax], cx

; 596  :         group[0]=0;

  0027f	b8 01 00 00 00	 mov	 eax, 1
  00284	48 6b c0 00	 imul	 rax, rax, 0
  00288	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR group$[rsp]
  00290	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 597  :     }

  00294	eb 10		 jmp	 SHORT $LN13@negotiate
$LN12@negotiate:

; 598  :     else
; 599  :     {
; 600  :         *devn = 0xFFFF;

  00296	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0029b	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR devn$[rsp]
  002a3	66 89 01	 mov	 WORD PTR [rcx], ax
$LN13@negotiate:

; 601  :     }
; 602  : 
; 603  :     /* Test for non-display terminal type */
; 604  :     if (memcmp(termtype, "IBM-", 4) != 0)

  002a6	41 b8 04 00 00
	00		 mov	 r8d, 4
  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168432
  002b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  002b8	e8 00 00 00 00	 call	 memcmp
  002bd	85 c0		 test	 eax, eax
  002bf	0f 84 ad 00 00
	00		 je	 $LN14@negotiate

; 605  :     {
; 606  :         if (memcmp(termtype, "ANSI", 4) == 0)

  002c5	41 b8 04 00 00
	00		 mov	 r8d, 4
  002cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168434
  002d2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  002d7	e8 00 00 00 00	 call	 memcmp
  002dc	85 c0		 test	 eax, eax
  002de	75 6a		 jne	 SHORT $LN15@negotiate

; 607  :         {
; 608  :             rc = send_packet (csock, wont_echo, sizeof(wont_echo),

  002e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168435
  002e7	41 b8 03 00 00
	00		 mov	 r8d, 3
  002ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?wont_echo@?1??negotiate@@9@9
  002f4	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  002fb	e8 00 00 00 00	 call	 send_packet
  00300	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 609  :                                 "IAC WONT ECHO");
; 610  :             if (rc < 0) return -1;

  00304	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00309	7d 0a		 jge	 SHORT $LN16@negotiate
  0030b	b8 ff ff ff ff	 mov	 eax, -1
  00310	e9 ad 03 00 00	 jmp	 $LN1@negotiate
$LN16@negotiate:

; 611  : 
; 612  :             rc = expect (csock, dont_echo, sizeof(dont_echo),

  00315	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168437
  0031c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00322	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?dont_echo@?1??negotiate@@9@9
  00329	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  00330	e8 00 00 00 00	 call	 expect
  00335	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 613  :                                 "IAC DONT ECHO");
; 614  :             if (rc < 0) return -1;

  00339	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0033e	7d 0a		 jge	 SHORT $LN17@negotiate
  00340	b8 ff ff ff ff	 mov	 eax, -1
  00345	e9 78 03 00 00	 jmp	 $LN1@negotiate
$LN17@negotiate:
$LN15@negotiate:

; 615  :         }
; 616  : 
; 617  :         /* Return printer-keyboard terminal class */
; 618  :         *class = 'K';

  0034a	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR class$[rsp]
  00352	c6 00 4b	 mov	 BYTE PTR [rax], 75	; 0000004bH

; 619  :         *model = '-';

  00355	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR model$[rsp]
  0035d	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH

; 620  :         *extatr = '-';

  00360	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR extatr$[rsp]
  00368	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH

; 621  :         return 0;

  0036b	33 c0		 xor	 eax, eax
  0036d	e9 50 03 00 00	 jmp	 $LN1@negotiate
$LN14@negotiate:

; 622  :     }
; 623  : 
; 624  :     /* Determine display terminal model */
; 625  :     if (memcmp(termtype+4,"DYNAMIC",7) == 0) {

  00372	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00377	48 83 c0 04	 add	 rax, 4
  0037b	41 b8 07 00 00
	00		 mov	 r8d, 7
  00381	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168441
  00388	48 8b c8	 mov	 rcx, rax
  0038b	e8 00 00 00 00	 call	 memcmp
  00390	85 c0		 test	 eax, eax
  00392	75 1b		 jne	 SHORT $LN18@negotiate

; 626  :         *model = 'X';

  00394	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR model$[rsp]
  0039c	c6 00 58	 mov	 BYTE PTR [rax], 88	; 00000058H

; 627  :         *extatr = 'Y';

  0039f	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR extatr$[rsp]
  003a7	c6 00 59	 mov	 BYTE PTR [rax], 89	; 00000059H

; 628  :     } else {

  003aa	e9 09 02 00 00	 jmp	 $LN19@negotiate
$LN18@negotiate:

; 629  :         if (!(memcmp(termtype+4, "3277", 4) == 0

  003af	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  003b4	48 83 c0 04	 add	 rax, 4
  003b8	41 b8 04 00 00
	00		 mov	 r8d, 4
  003be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168443
  003c5	48 8b c8	 mov	 rcx, rax
  003c8	e8 00 00 00 00	 call	 memcmp
  003cd	85 c0		 test	 eax, eax
  003cf	0f 84 04 01 00
	00		 je	 $LN20@negotiate
  003d5	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  003da	48 83 c0 04	 add	 rax, 4
  003de	41 b8 04 00 00
	00		 mov	 r8d, 4
  003e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168444
  003eb	48 8b c8	 mov	 rcx, rax
  003ee	e8 00 00 00 00	 call	 memcmp
  003f3	85 c0		 test	 eax, eax
  003f5	0f 84 de 00 00
	00		 je	 $LN20@negotiate
  003fb	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00400	48 83 c0 04	 add	 rax, 4
  00404	41 b8 04 00 00
	00		 mov	 r8d, 4
  0040a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168445
  00411	48 8b c8	 mov	 rcx, rax
  00414	e8 00 00 00 00	 call	 memcmp
  00419	85 c0		 test	 eax, eax
  0041b	0f 84 b8 00 00
	00		 je	 $LN20@negotiate
  00421	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00426	48 83 c0 04	 add	 rax, 4
  0042a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168446
  00437	48 8b c8	 mov	 rcx, rax
  0043a	e8 00 00 00 00	 call	 memcmp
  0043f	85 c0		 test	 eax, eax
  00441	0f 84 92 00 00
	00		 je	 $LN20@negotiate
  00447	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  0044c	48 83 c0 04	 add	 rax, 4
  00450	41 b8 04 00 00
	00		 mov	 r8d, 4
  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168447
  0045d	48 8b c8	 mov	 rcx, rax
  00460	e8 00 00 00 00	 call	 memcmp
  00465	85 c0		 test	 eax, eax
  00467	74 70		 je	 SHORT $LN20@negotiate
  00469	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  0046e	48 83 c0 04	 add	 rax, 4
  00472	41 b8 04 00 00
	00		 mov	 r8d, 4
  00478	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168448
  0047f	48 8b c8	 mov	 rcx, rax
  00482	e8 00 00 00 00	 call	 memcmp
  00487	85 c0		 test	 eax, eax
  00489	74 4e		 je	 SHORT $LN20@negotiate
  0048b	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00490	48 83 c0 04	 add	 rax, 4
  00494	41 b8 04 00 00
	00		 mov	 r8d, 4
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168449
  004a1	48 8b c8	 mov	 rcx, rax
  004a4	e8 00 00 00 00	 call	 memcmp
  004a9	85 c0		 test	 eax, eax
  004ab	74 2c		 je	 SHORT $LN20@negotiate
  004ad	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  004b2	48 83 c0 04	 add	 rax, 4
  004b6	41 b8 04 00 00
	00		 mov	 r8d, 4
  004bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168450
  004c3	48 8b c8	 mov	 rcx, rax
  004c6	e8 00 00 00 00	 call	 memcmp
  004cb	85 c0		 test	 eax, eax
  004cd	74 0a		 je	 SHORT $LN20@negotiate

; 630  :               || memcmp(termtype+4, "3270", 4) == 0
; 631  :               || memcmp(termtype+4, "3178", 4) == 0
; 632  :               || memcmp(termtype+4, "3278", 4) == 0
; 633  :               || memcmp(termtype+4, "3179", 4) == 0
; 634  :               || memcmp(termtype+4, "3180", 4) == 0
; 635  :               || memcmp(termtype+4, "3287", 4) == 0
; 636  :               || memcmp(termtype+4, "3279", 4) == 0))
; 637  :             return -1;

  004cf	b8 ff ff ff ff	 mov	 eax, -1
  004d4	e9 e9 01 00 00	 jmp	 $LN1@negotiate
$LN20@negotiate:

; 638  : 
; 639  :         *model = '2';

  004d9	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR model$[rsp]
  004e1	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H

; 640  :         *extatr = 'N';

  004e4	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR extatr$[rsp]
  004ec	c6 00 4e	 mov	 BYTE PTR [rax], 78	; 0000004eH

; 641  : 
; 642  :         if (termtype[8]=='-') {

  004ef	b8 01 00 00 00	 mov	 eax, 1
  004f4	48 6b c0 08	 imul	 rax, rax, 8
  004f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  004fd	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00501	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00504	0f 85 ae 00 00
	00		 jne	 $LN21@negotiate

; 643  :             if (termtype[9] < '1' || termtype[9] > '5')

  0050a	b8 01 00 00 00	 mov	 eax, 1
  0050f	48 6b c0 09	 imul	 rax, rax, 9
  00513	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  00518	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0051c	83 f8 31	 cmp	 eax, 49			; 00000031H
  0051f	7c 17		 jl	 SHORT $LN23@negotiate
  00521	b8 01 00 00 00	 mov	 eax, 1
  00526	48 6b c0 09	 imul	 rax, rax, 9
  0052a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR termtype$[rsp]
  0052f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00533	83 f8 35	 cmp	 eax, 53			; 00000035H
  00536	7e 0a		 jle	 SHORT $LN22@negotiate
$LN23@negotiate:

; 644  :                 return -1;

  00538	b8 ff ff ff ff	 mov	 eax, -1
  0053d	e9 80 01 00 00	 jmp	 $LN1@negotiate
$LN22@negotiate:

; 645  :             *model = termtype[9];

  00542	b8 01 00 00 00	 mov	 eax, 1
  00547	48 6b c0 09	 imul	 rax, rax, 9
  0054b	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR model$[rsp]
  00553	48 8b 54 24 28	 mov	 rdx, QWORD PTR termtype$[rsp]
  00558	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0055c	88 01		 mov	 BYTE PTR [rcx], al

; 646  :             if (memcmp(termtype+4, "328",3) == 0) *model = '2';

  0055e	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00563	48 83 c0 04	 add	 rax, 4
  00567	41 b8 03 00 00
	00		 mov	 r8d, 3
  0056d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168455
  00574	48 8b c8	 mov	 rcx, rax
  00577	e8 00 00 00 00	 call	 memcmp
  0057c	85 c0		 test	 eax, eax
  0057e	75 0b		 jne	 SHORT $LN24@negotiate
  00580	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR model$[rsp]
  00588	c6 00 32	 mov	 BYTE PTR [rax], 50	; 00000032H
$LN24@negotiate:

; 647  :             if (memcmp(termtype+10, "-E", 2) == 0)

  0058b	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  00590	48 83 c0 0a	 add	 rax, 10
  00594	41 b8 02 00 00
	00		 mov	 r8d, 2
  0059a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168457
  005a1	48 8b c8	 mov	 rcx, rax
  005a4	e8 00 00 00 00	 call	 memcmp
  005a9	85 c0		 test	 eax, eax
  005ab	75 0b		 jne	 SHORT $LN25@negotiate

; 648  :                 *extatr = 'Y';

  005ad	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR extatr$[rsp]
  005b5	c6 00 59	 mov	 BYTE PTR [rax], 89	; 00000059H
$LN25@negotiate:
$LN21@negotiate:
$LN19@negotiate:

; 649  :         }
; 650  :     }
; 651  : 
; 652  :     /* Perform end-of-record negotiation */
; 653  :     rc = send_packet (csock, do_eor, sizeof(do_eor),

  005b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168458
  005bf	41 b8 06 00 00
	00		 mov	 r8d, 6
  005c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?do_eor@?1??negotiate@@9@9
  005cc	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  005d3	e8 00 00 00 00	 call	 send_packet
  005d8	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 654  :                         "IAC DO EOR IAC WILL EOR");
; 655  :     if (rc < 0) return -1;

  005dc	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  005e1	7d 0a		 jge	 SHORT $LN26@negotiate
  005e3	b8 ff ff ff ff	 mov	 eax, -1
  005e8	e9 d5 00 00 00	 jmp	 $LN1@negotiate
$LN26@negotiate:

; 656  : 
; 657  :     rc = expect (csock, will_eor, sizeof(will_eor),

  005ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168460
  005f4	41 b8 06 00 00
	00		 mov	 r8d, 6
  005fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?will_eor@?1??negotiate@@9@9
  00601	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  00608	e8 00 00 00 00	 call	 expect
  0060d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 658  :                         "IAC WILL EOR IAC DO EOR");
; 659  :     if (rc < 0) return -1;

  00611	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00616	7d 0a		 jge	 SHORT $LN27@negotiate
  00618	b8 ff ff ff ff	 mov	 eax, -1
  0061d	e9 a0 00 00 00	 jmp	 $LN1@negotiate
$LN27@negotiate:

; 660  : 
; 661  :     /* Perform binary negotiation */
; 662  :     rc = send_packet (csock, do_bin, sizeof(do_bin),

  00622	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168462
  00629	41 b8 06 00 00
	00		 mov	 r8d, 6
  0062f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?do_bin@?1??negotiate@@9@9
  00636	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  0063d	e8 00 00 00 00	 call	 send_packet
  00642	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 663  :                         "IAC DO BINARY IAC WILL BINARY");
; 664  :     if (rc < 0) return -1;

  00646	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0064b	7d 07		 jge	 SHORT $LN28@negotiate
  0064d	b8 ff ff ff ff	 mov	 eax, -1
  00652	eb 6e		 jmp	 SHORT $LN1@negotiate
$LN28@negotiate:

; 665  : 
; 666  :     rc = expect (csock, will_bin, sizeof(will_bin),

  00654	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168464
  0065b	41 b8 06 00 00
	00		 mov	 r8d, 6
  00661	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?will_bin@?1??negotiate@@9@9
  00668	8b 8c 24 70 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  0066f	e8 00 00 00 00	 call	 expect
  00674	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 667  :                         "IAC WILL BINARY IAC DO BINARY");
; 668  :     if (rc < 0) return -1;

  00678	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0067d	7d 07		 jge	 SHORT $LN29@negotiate
  0067f	b8 ff ff ff ff	 mov	 eax, -1
  00684	eb 3c		 jmp	 SHORT $LN1@negotiate
$LN29@negotiate:

; 669  : 
; 670  :     /* Return display terminal class */
; 671  :     if (memcmp(termtype+4,"3287",4)==0) *class='P';

  00686	48 8b 44 24 28	 mov	 rax, QWORD PTR termtype$[rsp]
  0068b	48 83 c0 04	 add	 rax, 4
  0068f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00695	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168468
  0069c	48 8b c8	 mov	 rcx, rax
  0069f	e8 00 00 00 00	 call	 memcmp
  006a4	85 c0		 test	 eax, eax
  006a6	75 0d		 jne	 SHORT $LN30@negotiate
  006a8	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR class$[rsp]
  006b0	c6 00 50	 mov	 BYTE PTR [rax], 80	; 00000050H
  006b3	eb 0b		 jmp	 SHORT $LN31@negotiate
$LN30@negotiate:

; 672  :     else *class = 'D';

  006b5	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR class$[rsp]
  006bd	c6 00 44	 mov	 BYTE PTR [rax], 68	; 00000044H
$LN31@negotiate:

; 673  :     return 0;

  006c0	33 c0		 xor	 eax, eax
$LN1@negotiate:
$LN32@negotiate:

; 674  : 
; 675  : } /* end function negotiate */

  006c2	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006ca	48 33 cc	 xor	 rcx, rsp
  006cd	e8 00 00 00 00	 call	 __security_check_cookie
  006d2	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  006d9	c3		 ret	 0
negotiate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
rc$ = 32
buf$ = 48
__$ArrayPad$ = 560
csock$ = 592
expected$ = 600
len$ = 608
caption$ = 616
expect	PROC

; 449  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@expect:

; 450  : int     rc;                             /* Return code               */
; 451  : BYTE    buf[512];                       /* Receive buffer            */
; 452  : 
; 453  : #if defined( OPTION_MVS_TELNET_WORKAROUND )
; 454  : 
; 455  :   /* TCP/IP for MVS returns the server sequence rather then the
; 456  :      client sequence during bin negotiation.   Jan Jaeger, 19/06/00  */
; 457  : 
; 458  :   static BYTE do_bin[] = { IAC, DO, BINARY, IAC, WILL, BINARY };
; 459  :   static BYTE will_bin[] = { IAC, WILL, BINARY, IAC, DO, BINARY };
; 460  : 
; 461  : #endif // defined( OPTION_MVS_TELNET_WORKAROUND )
; 462  : 
; 463  :     UNREFERENCED(caption);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN4@expect

; 464  : 
; 465  :     rc = recv_packet (csock, buf, len, 0);

  00032	45 33 c9	 xor	 r9d, r9d
  00035	44 8b 84 24 60
	02 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0003d	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00042	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR csock$[rsp]
  00049	e8 00 00 00 00	 call	 recv_packet
  0004e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 466  :     if (rc < 0)

  00052	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00057	7d 0a		 jge	 SHORT $LN5@expect

; 467  :         return -1;

  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	e9 82 00 00 00	 jmp	 $LN1@expect
$LN5@expect:

; 468  : 
; 469  : #if defined( OPTION_MVS_TELNET_WORKAROUND )
; 470  :     /* BYPASS TCP/IP FOR MVS WHICH DOES NOT COMPLY TO RFC1576 */
; 471  :     if (1
; 472  :         && memcmp(buf, expected, len) != 0
; 473  :         && !(len == sizeof(will_bin)

  00063	33 c0		 xor	 eax, eax
  00065	83 f8 01	 cmp	 eax, 1
  00068	74 79		 je	 SHORT $LN6@expect
  0006a	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00072	4c 8b c0	 mov	 r8, rax
  00075	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR expected$[rsp]
  0007d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00082	e8 00 00 00 00	 call	 memcmp
  00087	85 c0		 test	 eax, eax
  00089	74 58		 je	 SHORT $LN6@expect
  0008b	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00093	48 83 f8 06	 cmp	 rax, 6
  00097	75 43		 jne	 SHORT $LN7@expect
  00099	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000a1	4c 8b c0	 mov	 r8, rax
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?will_bin@?1??expect@@9@9
  000ab	48 8b 8c 24 58
	02 00 00	 mov	 rcx, QWORD PTR expected$[rsp]
  000b3	e8 00 00 00 00	 call	 memcmp
  000b8	85 c0		 test	 eax, eax
  000ba	75 20		 jne	 SHORT $LN7@expect
  000bc	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000c4	4c 8b c0	 mov	 r8, rax
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?do_bin@?1??expect@@9@9
  000ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000d3	e8 00 00 00 00	 call	 memcmp
  000d8	85 c0		 test	 eax, eax
  000da	74 07		 je	 SHORT $LN6@expect
$LN7@expect:

; 474  :         && memcmp(expected, will_bin, len) == 0
; 475  :         && memcmp(buf, do_bin, len) == 0)
; 476  :     )
; 477  : #else
; 478  :     if (memcmp(buf, expected, len) != 0)
; 479  : #endif // defined( OPTION_MVS_TELNET_WORKAROUND )
; 480  :     {
; 481  :         TNSDEBUG2("console: DBG006: Expected %s\n", caption);
; 482  :         return -1;

  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	eb 02		 jmp	 SHORT $LN1@expect
$LN6@expect:

; 483  :     }
; 484  :     TNSDEBUG2("console: DBG007: Received %s\n", caption);
; 485  : 
; 486  :     return 0;

  000e3	33 c0		 xor	 eax, eax
$LN1@expect:

; 487  : 
; 488  : } /* end function expect */

  000e5	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ed	48 33 cc	 xor	 rcx, rsp
  000f0	e8 00 00 00 00	 call	 __security_check_cookie
  000f5	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  000fc	c3		 ret	 0
expect	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
rcvlen$ = 80
rc$ = 84
tv72 = 88
tv75 = 96
csock$ = 128
buf$ = 136
reqlen$ = 144
delim$ = 152
recv_packet PROC

; 411  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 412  : int     rc=0;                           /* Return code               */

  00017	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 413  : int     rcvlen=0;                       /* Length of data received   */

  0001f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rcvlen$[rsp], 0
$LN2@recv_packe:

; 414  : 
; 415  :     while (rcvlen < reqlen) {

  00027	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR reqlen$[rsp]
  0002e	39 44 24 50	 cmp	 DWORD PTR rcvlen$[rsp], eax
  00032	0f 8d 3c 01 00
	00		 jge	 $LN3@recv_packe

; 416  : 
; 417  :         rc = recv (csock, buf + rcvlen, reqlen - rcvlen, 0);

  00038	8b 44 24 50	 mov	 eax, DWORD PTR rcvlen$[rsp]
  0003c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR reqlen$[rsp]
  00043	2b c8		 sub	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR rcvlen$[rsp]
  0004c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00054	48 03 d1	 add	 rdx, rcx
  00057	48 8b ca	 mov	 rcx, rdx
  0005a	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR csock$[rsp]
  00062	48 89 54 24 58	 mov	 QWORD PTR tv72[rsp], rdx
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	44 8b c0	 mov	 r8d, eax
  0006d	48 8b d1	 mov	 rdx, rcx
  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR tv72[rsp]
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  0007e	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 418  : 
; 419  :         if (rc < 0) {

  00082	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00087	7d 77		 jge	 SHORT $LN4@recv_packe

; 420  :             WRMSG(HHC01034, "E", "recv()", strerror(HSO_errno));

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0008f	8b c8		 mov	 ecx, eax
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00097	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  000ac	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168334
  000b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168335
  000c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168336
  000d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168337
  000e7	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168338
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 421  :             return -1;

  000f9	b8 ff ff ff ff	 mov	 eax, -1
  000fe	eb 78		 jmp	 SHORT $LN1@recv_packe
$LN4@recv_packe:

; 422  :         }
; 423  : 
; 424  :         if (rc == 0) {

  00100	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00105	75 07		 jne	 SHORT $LN5@recv_packe

; 425  :             TNSDEBUG1("console: DBG004: Connection closed by client\n");
; 426  :             return -1;

  00107	b8 ff ff ff ff	 mov	 eax, -1
  0010c	eb 6a		 jmp	 SHORT $LN1@recv_packe
$LN5@recv_packe:

; 427  :         }
; 428  : 
; 429  :         rcvlen += rc;

  0010e	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00112	8b 4c 24 50	 mov	 ecx, DWORD PTR rcvlen$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	89 44 24 50	 mov	 DWORD PTR rcvlen$[rsp], eax

; 430  : 
; 431  :         if (delim != '\0' && rcvlen >= 2
; 432  :             && buf[rcvlen-2] == IAC && buf[rcvlen-1] == delim)

  0011e	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR delim$[rsp]
  00126	85 c0		 test	 eax, eax
  00128	74 45		 je	 SHORT $LN6@recv_packe
  0012a	83 7c 24 50 02	 cmp	 DWORD PTR rcvlen$[rsp], 2
  0012f	7c 3e		 jl	 SHORT $LN6@recv_packe
  00131	8b 44 24 50	 mov	 eax, DWORD PTR rcvlen$[rsp]
  00135	83 e8 02	 sub	 eax, 2
  00138	48 98		 cdqe
  0013a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00142	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00146	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0014b	75 22		 jne	 SHORT $LN6@recv_packe
  0014d	8b 44 24 50	 mov	 eax, DWORD PTR rcvlen$[rsp]
  00151	ff c8		 dec	 eax
  00153	48 98		 cdqe
  00155	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0015d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00161	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR delim$[rsp]
  00169	3b c1		 cmp	 eax, ecx
  0016b	75 02		 jne	 SHORT $LN6@recv_packe

; 433  :             break;

  0016d	eb 05		 jmp	 SHORT $LN3@recv_packe
$LN6@recv_packe:

; 434  :     }

  0016f	e9 b3 fe ff ff	 jmp	 $LN2@recv_packe
$LN3@recv_packe:

; 435  : 
; 436  :     TNSDEBUG2("console: DBG005: Packet received length=%d\n", rcvlen);
; 437  :     packet_trace (buf, rcvlen);
; 438  : 
; 439  :     return rcvlen;

  00174	8b 44 24 50	 mov	 eax, DWORD PTR rcvlen$[rsp]
$LN1@recv_packe:

; 440  : 
; 441  : } /* end function recv_packet */

  00178	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0017c	c3		 ret	 0
recv_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
rc$ = 80
tv72 = 88
csock$ = 112
buf$ = 120
len$ = 128
caption$ = 136
send_packet PROC

; 372  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 373  : int     rc;                             /* Return code               */
; 374  : 
; 375  :     if (caption != NULL) {
; 376  :         TNSDEBUG2("console: DBG003: Sending %s\n", caption);
; 377  :         packet_trace (buf, len);
; 378  :     }
; 379  : 
; 380  :     rc = send (csock, buf, len, 0);

  00017	48 63 44 24 70	 movsxd	 rax, DWORD PTR csock$[rsp]
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00027	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00035	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 381  : 
; 382  :     if (rc < 0) {

  00039	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003e	7d 77		 jge	 SHORT $LN3@send_packe

; 383  :         WRMSG(HHC01034, "E", "send()", strerror(HSO_errno));

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0004e	48 89 44 24 58	 mov	 QWORD PTR tv72[rsp], rax
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0005e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv72[rsp]
  00063	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168311
  0006f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168312
  0007b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168313
  00087	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	41 b9 03 00 00
	00		 mov	 r9d, 3
  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168314
  0009e	ba 7f 01 00 00	 mov	 edx, 383		; 0000017fH
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168315
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 384  :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 02		 jmp	 SHORT $LN1@send_packe
$LN3@send_packe:

; 385  :     } /* end if(rc) */
; 386  : 
; 387  :     return 0;

  000b7	33 c0		 xor	 eax, eax
$LN1@send_packe:

; 388  : 
; 389  : } /* end function send_packet */

  000b9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000bd	c3		 ret	 0
send_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
n$ = 0
x$ = 4
m$ = 8
newlen$ = 12
buf$ = 32
len$ = 40
double_up_iac PROC

; 343  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 344  : int     m, n, x, newlen;
; 345  : 
; 346  :     /* Count the number of IAC bytes in the data */
; 347  :     for (x=0, n=0; n < len; n++)

  0000d	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR x$[rsp], 0
  00015	c7 04 24 00 00
	00 00		 mov	 DWORD PTR n$[rsp], 0
  0001c	eb 08		 jmp	 SHORT $LN4@double_up_
$LN2@double_up_:
  0001e	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00021	ff c0		 inc	 eax
  00023	89 04 24	 mov	 DWORD PTR n$[rsp], eax
$LN4@double_up_:
  00026	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0002a	39 04 24	 cmp	 DWORD PTR n$[rsp], eax
  0002d	7d 20		 jge	 SHORT $LN3@double_up_

; 348  :         if (buf[n] == IAC) x++;

  0002f	48 63 04 24	 movsxd	 rax, DWORD PTR n$[rsp]
  00033	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00038	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00041	75 0a		 jne	 SHORT $LN8@double_up_
  00043	8b 44 24 04	 mov	 eax, DWORD PTR x$[rsp]
  00047	ff c0		 inc	 eax
  00049	89 44 24 04	 mov	 DWORD PTR x$[rsp], eax
$LN8@double_up_:
  0004d	eb cf		 jmp	 SHORT $LN2@double_up_
$LN3@double_up_:

; 349  : 
; 350  :     /* Exit if nothing to do */
; 351  :     if (x == 0) return len;

  0004f	83 7c 24 04 00	 cmp	 DWORD PTR x$[rsp], 0
  00054	75 09		 jne	 SHORT $LN9@double_up_
  00056	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0005a	e9 84 00 00 00	 jmp	 $LN1@double_up_
$LN9@double_up_:

; 352  : 
; 353  :     /* Insert extra IAC bytes backwards from the end of the buffer */
; 354  :     newlen = len + x;

  0005f	8b 44 24 04	 mov	 eax, DWORD PTR x$[rsp]
  00063	8b 4c 24 28	 mov	 ecx, DWORD PTR len$[rsp]
  00067	03 c8		 add	 ecx, eax
  00069	8b c1		 mov	 eax, ecx
  0006b	89 44 24 0c	 mov	 DWORD PTR newlen$[rsp], eax

; 355  :     TNSDEBUG3("console: DBG002: %d IAC bytes added, newlen=%d\n",
; 356  :             x, newlen);
; 357  :     for (n=newlen, m=len; n > m; ) {

  0006f	8b 44 24 0c	 mov	 eax, DWORD PTR newlen$[rsp]
  00073	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00076	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0007a	89 44 24 08	 mov	 DWORD PTR m$[rsp], eax
$LN5@double_up_:
  0007e	8b 44 24 08	 mov	 eax, DWORD PTR m$[rsp]
  00082	39 04 24	 cmp	 DWORD PTR n$[rsp], eax
  00085	7e 58		 jle	 SHORT $LN6@double_up_

; 358  :         buf[--n] = buf[--m];

  00087	8b 44 24 08	 mov	 eax, DWORD PTR m$[rsp]
  0008b	ff c8		 dec	 eax
  0008d	89 44 24 08	 mov	 DWORD PTR m$[rsp], eax
  00091	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00094	ff c8		 dec	 eax
  00096	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00099	48 63 04 24	 movsxd	 rax, DWORD PTR n$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR m$[rsp]
  000a2	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  000a7	4c 8b 44 24 20	 mov	 r8, QWORD PTR buf$[rsp]
  000ac	41 0f b6 0c 08	 movzx	 ecx, BYTE PTR [r8+rcx]
  000b1	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl

; 359  :         if (buf[n] == IAC) buf[--n] = IAC;

  000b4	48 63 04 24	 movsxd	 rax, DWORD PTR n$[rsp]
  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  000bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c6	75 15		 jne	 SHORT $LN10@double_up_
  000c8	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  000cb	ff c8		 dec	 eax
  000cd	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  000d0	48 63 04 24	 movsxd	 rax, DWORD PTR n$[rsp]
  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  000d9	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN10@double_up_:

; 360  :     }

  000dd	eb 9f		 jmp	 SHORT $LN5@double_up_
$LN6@double_up_:

; 361  :     packet_trace (buf, newlen);
; 362  :     return newlen;

  000df	8b 44 24 0c	 mov	 eax, DWORD PTR newlen$[rsp]
$LN1@double_up_:

; 363  : 
; 364  : } /* end function double_up_iac */

  000e3	48 83 c4 18	 add	 rsp, 24
  000e7	c3		 ret	 0
double_up_iac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
tv71 = 84
tv76 = 88
respbuf$ = 96
ru_ptr$ = 104
eleptr$ = 112
ca$ = 144
make_sna_requests5 PROC

; 1811 : static void make_sna_requests5 (COMMADPT *ca) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1812 :     BYTE    *respbuf;
; 1813 :     BYTE    *ru_ptr;
; 1814 :     int     ru_size;
; 1815 :     void    *eleptr;
; 1816 :     eleptr = get_bufpool(&ca->freeq);

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00014	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	e8 00 00 00 00	 call	 get_bufpool
  00022	48 89 44 24 70	 mov	 QWORD PTR eleptr$[rsp], rax

; 1817 :     if (!eleptr)  {

  00027	48 83 7c 24 70
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  0002d	0f 85 90 00 00
	00		 jne	 $LN2@make_sna_r

; 1818 :         WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA request5");

  00033	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00042	89 44 24 54	 mov	 DWORD PTR tv71[rsp], eax
  00046	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00055	d1 f9		 sar	 ecx, 1
  00057	89 4c 24 58	 mov	 DWORD PTR tv76[rsp], ecx
  0005b	b9 01 00 00 00	 mov	 ecx, 1
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169297
  0006d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00072	8b 4c 24 54	 mov	 ecx, DWORD PTR tv71[rsp]
  00076	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0007a	8b 4c 24 58	 mov	 ecx, DWORD PTR tv76[rsp]
  0007e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169298
  00089	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169299
  00095	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169300
  000ac	ba 1a 07 00 00	 mov	 edx, 1818		; 0000071aH
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169301
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1819 :         return;

  000be	e9 28 02 00 00	 jmp	 $LN1@make_sna_r
$LN2@make_sna_r:

; 1820 :     }
; 1821 :     respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  000c3	48 8b 44 24 70	 mov	 rax, QWORD PTR eleptr$[rsp]
  000c8	48 83 c0 08	 add	 rax, 8
  000cc	48 89 44 24 60	 mov	 QWORD PTR respbuf$[rsp], rax

; 1822 : 
; 1823 :     /* first do the ten-byte FID1 TH */
; 1824 :     respbuf[0] = 0x1C;

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000df	c6 04 01 1c	 mov	 BYTE PTR [rcx+rax], 28

; 1825 :     respbuf[1] = 0x00;

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	48 6b c0 01	 imul	 rax, rax, 1
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000f1	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1826 :     respbuf[2] = ca->sscp_addr0;   // daf

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 02	 imul	 rax, rax, 2
  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00103	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0010b	0f b6 92 b0 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65712]
  00112	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1827 :     respbuf[3] = ca->sscp_addr1;

  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	48 6b c0 03	 imul	 rax, rax, 3
  0011e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00123	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0012b	0f b6 92 b1 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65713]
  00132	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1828 :     respbuf[4] = ca->ncp_addr0;    // oaf

  00135	b8 01 00 00 00	 mov	 eax, 1
  0013a	48 6b c0 04	 imul	 rax, rax, 4
  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0014b	0f b6 92 b2 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65714]
  00152	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1829 :     respbuf[5] = ca->ncp_addr1;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	48 6b c0 05	 imul	 rax, rax, 5
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00163	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0016b	0f b6 92 b3 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65715]
  00172	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1830 :     // set seq no.
; 1831 :     make_seq(ca, respbuf);

  00175	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0017a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00182	e8 00 00 00 00	 call	 make_seq

; 1832 :     /* do RH */
; 1833 :     respbuf[10] = 0x0B;

  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	48 6b c0 0a	 imul	 rax, rax, 10
  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00195	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11

; 1834 :     respbuf[11] = 0x00;

  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	48 6b c0 0b	 imul	 rax, rax, 11
  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001a7	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1835 :     respbuf[12] = 0x00;

  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	48 6b c0 0c	 imul	 rax, rax, 12
  001b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001b9	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1836 : 
; 1837 :     /* do RU */
; 1838 :     ru_size = 0;

  001bd	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ru_size$[rsp], 0

; 1839 :     ru_ptr = &respbuf[13];

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	48 6b c0 0d	 imul	 rax, rax, 13
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001d3	48 03 c8	 add	 rcx, rax
  001d6	48 8b c1	 mov	 rax, rcx
  001d9	48 89 44 24 68	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1840 : 
; 1841 :     ru_ptr[ru_size++] = 0x01;      // INOP

  001de	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  001e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  001e8	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  001ec	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  001f0	ff c0		 inc	 eax
  001f2	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1842 :     ru_ptr[ru_size++] = 0x02;

  001f6	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  001fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00200	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2
  00204	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00208	ff c0		 inc	 eax
  0020a	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1843 :     ru_ptr[ru_size++] = 0x81;

  0020e	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00213	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00218	c6 04 01 81	 mov	 BYTE PTR [rcx+rax], 129	; 00000081H
  0021c	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00220	ff c0		 inc	 eax
  00222	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1844 :     ru_ptr[ru_size++] = ca->pu_addr0;

  00226	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0022b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00230	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00238	0f b6 92 b4 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65716]
  0023f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00242	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00246	ff c0		 inc	 eax
  00248	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1845 :     ru_ptr[ru_size++] = ca->pu_addr1;

  0024c	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00256	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0025e	0f b6 92 b5 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65717]
  00265	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00268	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0026c	ff c0		 inc	 eax
  0026e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1846 :     ru_ptr[ru_size++] = 0x01;      // format/reason

  00272	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00277	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0027c	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00280	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00284	ff c0		 inc	 eax
  00286	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1847 : 
; 1848 :     ru_size += 3;   /* for RH */

  0028a	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0028e	83 c0 03	 add	 eax, 3
  00291	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1849 :     respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  00295	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00299	c1 f8 08	 sar	 eax, 8
  0029c	0f b6 c0	 movzx	 eax, al
  0029f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a4	b9 01 00 00 00	 mov	 ecx, 1
  002a9	48 6b c9 08	 imul	 rcx, rcx, 8
  002ad	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  002b2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1850 :     respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  002b5	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  002ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002bf	b9 01 00 00 00	 mov	 ecx, 1
  002c4	48 6b c9 09	 imul	 rcx, rcx, 9
  002c8	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  002cd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1851 : 
; 1852 :     put_bufpool(&ca->sendq, eleptr);

  002d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002d8	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  002de	48 8b 54 24 70	 mov	 rdx, QWORD PTR eleptr$[rsp]
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	e8 00 00 00 00	 call	 put_bufpool
$LN1@make_sna_r:

; 1853 : }

  002eb	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002f2	c3		 ret	 0
make_sna_requests5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
stids$ = 84
tv71 = 88
tv76 = 92
respbuf$ = 96
ru_ptr$ = 104
eleptr$ = 112
ca$ = 144
flag$ = 152
pu_type$ = 160
make_sna_requests4 PROC

; 1741 : static void make_sna_requests4 (COMMADPT *ca, int flag, BYTE pu_type) {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1742 :     /* send type flag: 0=REQCONT 1=REQDISCONT */
; 1743 :     BYTE    *respbuf;
; 1744 :     BYTE    *ru_ptr;
; 1745 :     int     ru_size;
; 1746 :     U32     stids;
; 1747 :     void    *eleptr;
; 1748 :     eleptr = get_bufpool(&ca->freeq);

  00015	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0001d	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 get_bufpool
  0002b	48 89 44 24 70	 mov	 QWORD PTR eleptr$[rsp], rax

; 1749 :     if (!eleptr)  {

  00030	48 83 7c 24 70
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  00036	0f 85 90 00 00
	00		 jne	 $LN2@make_sna_r

; 1750 :         WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA request4");

  0003c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0004b	89 44 24 58	 mov	 DWORD PTR tv71[rsp], eax
  0004f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00057	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0005e	d1 f9		 sar	 ecx, 1
  00060	89 4c 24 5c	 mov	 DWORD PTR tv76[rsp], ecx
  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169277
  00076	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0007b	8b 4c 24 58	 mov	 ecx, DWORD PTR tv71[rsp]
  0007f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00083	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv76[rsp]
  00087	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169278
  00092	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169279
  0009e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169280
  000b5	ba d6 06 00 00	 mov	 edx, 1750		; 000006d6H
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1751 :         return;

  000c7	e9 e5 03 00 00	 jmp	 $LN1@make_sna_r
$LN2@make_sna_r:

; 1752 :     }
; 1753 :     respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR eleptr$[rsp]
  000d1	48 83 c0 08	 add	 rax, 8
  000d5	48 89 44 24 60	 mov	 QWORD PTR respbuf$[rsp], rax

; 1754 : 
; 1755 :     /* first do the ten-byte FID1 TH */
; 1756 :     respbuf[0] = 0x1C;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 00	 imul	 rax, rax, 0
  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000e8	c6 04 01 1c	 mov	 BYTE PTR [rcx+rax], 28

; 1757 :     respbuf[1] = 0x00;

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	48 6b c0 01	 imul	 rax, rax, 1
  000f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000fa	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1758 :     respbuf[2] = ca->sscp_addr0;   // daf

  000fe	b8 01 00 00 00	 mov	 eax, 1
  00103	48 6b c0 02	 imul	 rax, rax, 2
  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0010c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00114	0f b6 92 b0 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65712]
  0011b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1759 :     respbuf[3] = ca->sscp_addr1;

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	48 6b c0 03	 imul	 rax, rax, 3
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0012c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00134	0f b6 92 b1 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65713]
  0013b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1760 :     // set oaf
; 1761 :     if (flag == 0) {

  0013e	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flag$[rsp], 0
  00146	75 54		 jne	 SHORT $LN3@make_sna_r

; 1762 :         respbuf[4] = ca->ncp_addr0;

  00148	b8 01 00 00 00	 mov	 eax, 1
  0014d	48 6b c0 04	 imul	 rax, rax, 4
  00151	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00156	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0015e	0f b6 92 b2 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65714]
  00165	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1763 :         respbuf[5] = ca->ncp_addr1;

  00168	b8 01 00 00 00	 mov	 eax, 1
  0016d	48 6b c0 05	 imul	 rax, rax, 5
  00171	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00176	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0017e	0f b6 92 b3 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65715]
  00185	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1764 :         make_seq(ca, respbuf);

  00188	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0018d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00195	e8 00 00 00 00	 call	 make_seq

; 1765 :     } else {

  0019a	eb 64		 jmp	 SHORT $LN4@make_sna_r
$LN3@make_sna_r:

; 1766 :         respbuf[4] = ca->pu_addr0;

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	48 6b c0 04	 imul	 rax, rax, 4
  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001aa	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  001b2	0f b6 92 b4 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65716]
  001b9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1767 :         respbuf[5] = ca->pu_addr1;

  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	48 6b c0 05	 imul	 rax, rax, 5
  001c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001ca	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  001d2	0f b6 92 b5 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65717]
  001d9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1768 :         respbuf[6] = 0x00;

  001dc	b8 01 00 00 00	 mov	 eax, 1
  001e1	48 6b c0 06	 imul	 rax, rax, 6
  001e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001ea	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1769 :         respbuf[7] = 0x01;

  001ee	b8 01 00 00 00	 mov	 eax, 1
  001f3	48 6b c0 07	 imul	 rax, rax, 7
  001f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001fc	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
$LN4@make_sna_r:

; 1770 :     }
; 1771 : 
; 1772 :     /* do RH */
; 1773 :     respbuf[10] = 0x0b;

  00200	b8 01 00 00 00	 mov	 eax, 1
  00205	48 6b c0 0a	 imul	 rax, rax, 10
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0020e	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11

; 1774 :     respbuf[11] = 0x00;

  00212	b8 01 00 00 00	 mov	 eax, 1
  00217	48 6b c0 0b	 imul	 rax, rax, 11
  0021b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00220	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1775 :     respbuf[12] = 0x00;

  00224	b8 01 00 00 00	 mov	 eax, 1
  00229	48 6b c0 0c	 imul	 rax, rax, 12
  0022d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00232	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1776 : 
; 1777 :     /* do RU */
; 1778 :     ru_size = 0;

  00236	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ru_size$[rsp], 0

; 1779 :     ru_ptr = &respbuf[13];

  0023e	b8 01 00 00 00	 mov	 eax, 1
  00243	48 6b c0 0d	 imul	 rax, rax, 13
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0024c	48 03 c8	 add	 rcx, rax
  0024f	48 8b c1	 mov	 rax, rcx
  00252	48 89 44 24 68	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1780 :     if (flag == 0) {

  00257	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flag$[rsp], 0
  0025f	0f 85 72 01 00
	00		 jne	 $LN5@make_sna_r

; 1781 :         ru_ptr[ru_size++] = 0x01;      // REQCONT (REQUEST CONTACT)

  00265	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0026a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0026f	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00273	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00277	ff c0		 inc	 eax
  00279	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1782 :         ru_ptr[ru_size++] = 0x02;

  0027d	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00282	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00287	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2
  0028b	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0028f	ff c0		 inc	 eax
  00291	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1783 :         ru_ptr[ru_size++] = 0x84;

  00295	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0029a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0029f	c6 04 01 84	 mov	 BYTE PTR [rcx+rax], 132	; 00000084H
  002a3	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002a7	ff c0		 inc	 eax
  002a9	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1784 : 
; 1785 :         ru_ptr[ru_size++] = (ca->rmtsuba >> 8); // network address of link

  002ad	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002b5	0f b7 40 56	 movzx	 eax, WORD PTR [rax+86]
  002b9	c1 f8 08	 sar	 eax, 8
  002bc	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  002c1	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  002c6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002c9	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002cd	ff c0		 inc	 eax
  002cf	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1786 :         ru_ptr[ru_size++] = 0x01;

  002d3	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  002d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  002dd	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  002e1	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  002e5	ff c0		 inc	 eax
  002e7	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1787 : 
; 1788 :         ru_ptr[ru_size++] = pu_type;      // PU type

  002eb	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  002f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  002f5	0f b6 94 24 a0
	00 00 00	 movzx	 edx, BYTE PTR pu_type$[rsp]
  002fd	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00300	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00304	ff c0		 inc	 eax
  00306	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1789 : 
; 1790 :         ru_ptr[ru_size++] = 0x00;

  0030a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0030f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00314	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00318	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0031c	ff c0		 inc	 eax
  0031e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1791 : 
; 1792 :         stids = ((ca->idblk << 20) & 0xfff00000) | (ca->idnum & 0x000fffff); // 12 bit IDBLK, 20 bit IDNUM

  00322	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0032a	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  0032d	c1 e0 14	 shl	 eax, 20
  00330	25 00 00 f0 ff	 and	 eax, -1048576		; fff00000H
  00335	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0033d	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00340	81 e1 ff ff 0f
	00		 and	 ecx, 1048575		; 000fffffH
  00346	0b c1		 or	 eax, ecx
  00348	89 44 24 54	 mov	 DWORD PTR stids$[rsp], eax

; 1793 :         ru_ptr[ru_size++] = (stids >> 24) &0xff;

  0034c	8b 44 24 54	 mov	 eax, DWORD PTR stids$[rsp]
  00350	c1 e8 18	 shr	 eax, 24
  00353	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00358	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  0035d	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  00362	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00365	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00369	ff c0		 inc	 eax
  0036b	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1794 :         ru_ptr[ru_size++] = (stids >> 16) &0xff;

  0036f	8b 44 24 54	 mov	 eax, DWORD PTR stids$[rsp]
  00373	c1 e8 10	 shr	 eax, 16
  00376	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0037b	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  00380	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  00385	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00388	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0038c	ff c0		 inc	 eax
  0038e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1795 :         ru_ptr[ru_size++] = (stids >>  8) &0xff;

  00392	8b 44 24 54	 mov	 eax, DWORD PTR stids$[rsp]
  00396	c1 e8 08	 shr	 eax, 8
  00399	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0039e	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  003a3	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  003a8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003ab	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  003af	ff c0		 inc	 eax
  003b1	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1796 :         ru_ptr[ru_size++] =  stids        &0xff;

  003b5	8b 44 24 54	 mov	 eax, DWORD PTR stids$[rsp]
  003b9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003be	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ru_size$[rsp]
  003c3	48 8b 54 24 68	 mov	 rdx, QWORD PTR ru_ptr$[rsp]
  003c8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003cb	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  003cf	ff c0		 inc	 eax
  003d1	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1797 :     } else {

  003d5	eb 60		 jmp	 SHORT $LN6@make_sna_r
$LN5@make_sna_r:

; 1798 :         ru_ptr[ru_size++] = 0x01;      // REQDISCONT (REQUEST DISCONTACT)

  003d7	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  003dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  003e1	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  003e5	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  003e9	ff c0		 inc	 eax
  003eb	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1799 :         ru_ptr[ru_size++] = 0x02;

  003ef	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  003f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  003f9	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2
  003fd	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00401	ff c0		 inc	 eax
  00403	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1800 :         ru_ptr[ru_size++] = 0x1B;

  00407	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0040c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00411	c6 04 01 1b	 mov	 BYTE PTR [rcx+rax], 27
  00415	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00419	ff c0		 inc	 eax
  0041b	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1801 :         ru_ptr[ru_size++] = 0x00;

  0041f	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00424	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00429	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0042d	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00431	ff c0		 inc	 eax
  00433	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax
$LN6@make_sna_r:

; 1802 :     }
; 1803 :     ru_size += 3;   /* for RH */

  00437	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0043b	83 c0 03	 add	 eax, 3
  0043e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1804 :     respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  00442	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00446	c1 f8 08	 sar	 eax, 8
  00449	0f b6 c0	 movzx	 eax, al
  0044c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00451	b9 01 00 00 00	 mov	 ecx, 1
  00456	48 6b c9 08	 imul	 rcx, rcx, 8
  0045a	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0045f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1805 :     respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  00462	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  00467	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0046c	b9 01 00 00 00	 mov	 ecx, 1
  00471	48 6b c9 09	 imul	 rcx, rcx, 9
  00475	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0047a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1806 : 
; 1807 :     put_bufpool(&ca->sendq, eleptr);

  0047d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00485	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  0048b	48 8b 54 24 70	 mov	 rdx, QWORD PTR eleptr$[rsp]
  00490	48 8b c8	 mov	 rcx, rax
  00493	e8 00 00 00 00	 call	 put_bufpool

; 1808 :     ca->telnet_int = 0;

  00498	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  004a0	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  004a3	83 e0 df	 and	 eax, -33		; ffffffdfH
  004a6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  004ae	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN1@make_sna_r:

; 1809 : }

  004b1	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004b8	c3		 ret	 0
make_sna_requests4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
tv75 = 84
tv80 = 88
respbuf$ = 96
ru_ptr$ = 104
eleptr$ = 112
ca$ = 144
make_sna_requests3 PROC

; 1697 : static void make_sna_requests3 (COMMADPT *ca) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1698 :     BYTE    *respbuf;
; 1699 :     BYTE    *ru_ptr;
; 1700 :     int     ru_size;
; 1701 :     void    *eleptr;
; 1702 :     if (!ca->telnet_int) return;

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00014	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00017	c1 e8 05	 shr	 eax, 5
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 05		 jne	 SHORT $LN2@make_sna_r
  00021	e9 a6 02 00 00	 jmp	 $LN1@make_sna_r
$LN2@make_sna_r:

; 1703 :     eleptr = get_bufpool(&ca->freeq);

  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0002e	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 get_bufpool
  0003c	48 89 44 24 70	 mov	 QWORD PTR eleptr$[rsp], rax

; 1704 :     if (!eleptr)  {

  00041	48 83 7c 24 70
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  00047	0f 85 90 00 00
	00		 jne	 $LN3@make_sna_r

; 1705 :         WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA request3");

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0005c	89 44 24 54	 mov	 DWORD PTR tv75[rsp], eax
  00060	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00068	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0006f	d1 f9		 sar	 ecx, 1
  00071	89 4c 24 58	 mov	 DWORD PTR tv80[rsp], ecx
  00075	b9 01 00 00 00	 mov	 ecx, 1
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169256
  00087	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0008c	8b 4c 24 54	 mov	 ecx, DWORD PTR tv75[rsp]
  00090	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00094	8b 4c 24 58	 mov	 ecx, DWORD PTR tv80[rsp]
  00098	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169257
  000a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169258
  000af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169259
  000c6	ba a9 06 00 00	 mov	 edx, 1705		; 000006a9H
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169260
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1706 :         return;

  000d8	e9 ef 01 00 00	 jmp	 $LN1@make_sna_r
$LN3@make_sna_r:

; 1707 :     }
; 1708 :     respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  000dd	48 8b 44 24 70	 mov	 rax, QWORD PTR eleptr$[rsp]
  000e2	48 83 c0 08	 add	 rax, 8
  000e6	48 89 44 24 60	 mov	 QWORD PTR respbuf$[rsp], rax

; 1709 : 
; 1710 :     /* first do the ten-byte FID1 TH */
; 1711 :     respbuf[0] = 0x1D;

  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	48 6b c0 00	 imul	 rax, rax, 0
  000f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000f9	c6 04 01 1d	 mov	 BYTE PTR [rcx+rax], 29

; 1712 :     respbuf[1] = 0x00;

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0010b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1713 :     respbuf[2] = ca->tso_addr0;   // daf

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	48 6b c0 02	 imul	 rax, rax, 2
  00118	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0011d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00125	0f b6 92 b8 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65720]
  0012c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1714 :     respbuf[3] = ca->tso_addr1;

  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	48 6b c0 03	 imul	 rax, rax, 3
  00138	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0013d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00145	0f b6 92 b9 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65721]
  0014c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1715 :     respbuf[4] = ca->lu_addr0;   // oaf

  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	48 6b c0 04	 imul	 rax, rax, 4
  00158	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0015d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00165	0f b6 92 b6 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65718]
  0016c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1716 :     respbuf[5] = ca->lu_addr1;   // oaf

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	48 6b c0 05	 imul	 rax, rax, 5
  00178	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0017d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  00185	0f b6 92 b7 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65719]
  0018c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1717 :     respbuf[6] = 0x11;

  0018f	b8 01 00 00 00	 mov	 eax, 1
  00194	48 6b c0 06	 imul	 rax, rax, 6
  00198	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0019d	c6 04 01 11	 mov	 BYTE PTR [rcx+rax], 17

; 1718 :     respbuf[7] = 0x11;

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 07	 imul	 rax, rax, 7
  001aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001af	c6 04 01 11	 mov	 BYTE PTR [rcx+rax], 17

; 1719 : 
; 1720 :     /* do RH */
; 1721 :     respbuf[10] = 0x4B;

  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	48 6b c0 0a	 imul	 rax, rax, 10
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001c1	c6 04 01 4b	 mov	 BYTE PTR [rcx+rax], 75	; 0000004bH

; 1722 :     respbuf[11] = 0x80;

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	48 6b c0 0b	 imul	 rax, rax, 11
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001d3	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H

; 1723 :     respbuf[12] = 0x00;

  001d7	b8 01 00 00 00	 mov	 eax, 1
  001dc	48 6b c0 0c	 imul	 rax, rax, 12
  001e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001e5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1724 : 
; 1725 :     /* do RU */
; 1726 :     ru_size = 0;

  001e9	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ru_size$[rsp], 0

; 1727 :     ru_ptr = &respbuf[13];

  001f1	b8 01 00 00 00	 mov	 eax, 1
  001f6	48 6b c0 0d	 imul	 rax, rax, 13
  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR respbuf$[rsp]
  001ff	48 03 c8	 add	 rcx, rax
  00202	48 8b c1	 mov	 rax, rcx
  00205	48 89 44 24 68	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1728 : 
; 1729 :     ru_ptr[ru_size++] = 0xc9;      // SIG

  0020a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0020f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00214	c6 04 01 c9	 mov	 BYTE PTR [rcx+rax], 201	; 000000c9H
  00218	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0021c	ff c0		 inc	 eax
  0021e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1730 :     ru_ptr[ru_size++] = 0x00;

  00222	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00227	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  0022c	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00230	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00234	ff c0		 inc	 eax
  00236	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1731 :     ru_ptr[ru_size++] = 0x01;

  0023a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  0023f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ru_ptr$[rsp]
  00244	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00248	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0024c	ff c0		 inc	 eax
  0024e	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1732 : 
; 1733 :     ru_size += 3;   /* for RH */

  00252	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00256	83 c0 03	 add	 eax, 3
  00259	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1734 :     respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  0025d	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00261	c1 f8 08	 sar	 eax, 8
  00264	0f b6 c0	 movzx	 eax, al
  00267	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0026c	b9 01 00 00 00	 mov	 ecx, 1
  00271	48 6b c9 08	 imul	 rcx, rcx, 8
  00275	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0027a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1735 :     respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  0027d	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  00282	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00287	b9 01 00 00 00	 mov	 ecx, 1
  0028c	48 6b c9 09	 imul	 rcx, rcx, 9
  00290	48 8b 54 24 60	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00295	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1736 : 
; 1737 :     put_bufpool(&ca->sendq, eleptr);

  00298	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002a0	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  002a6	48 8b 54 24 70	 mov	 rdx, QWORD PTR eleptr$[rsp]
  002ab	48 8b c8	 mov	 rcx, rax
  002ae	e8 00 00 00 00	 call	 put_bufpool

; 1738 :     ca->telnet_int = 0;

  002b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002bb	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  002be	83 e0 df	 and	 eax, -33		; ffffffdfH
  002c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  002c9	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN1@make_sna_r:

; 1739 : }

  002cc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002d3	c3		 ret	 0
make_sna_requests3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\comm3705.c
_TEXT	SEGMENT
ru_size$ = 80
respbuf$ = 88
bufp$ = 96
tv142 = 100
tv175 = 104
tv73 = 108
tv78 = 112
eleptr$ = 120
ru_ptr$ = 128
ca$ = 176
make_sna_requests2 PROC

; 1620 : static void make_sna_requests2 (COMMADPT *ca) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1621 :     BYTE    *respbuf;
; 1622 :     BYTE    *ru_ptr;
; 1623 :     int     ru_size;
; 1624 :     void    *eleptr;
; 1625 :     int     bufp = 0;

  0000e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR bufp$[rsp], 0
$LN2@make_sna_r:

; 1626 :     while (ca->inpbufl > 0) {

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0001e	83 b8 88 00 01
	00 00		 cmp	 DWORD PTR [rax+65672], 0
  00025	0f 8e 3b 05 00
	00		 jle	 $LN3@make_sna_r

; 1627 :         eleptr = get_bufpool(&ca->freeq);

  0002b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00033	48 05 98 00 01
	00		 add	 rax, 65688		; 00010098H
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 get_bufpool
  00041	48 89 44 24 78	 mov	 QWORD PTR eleptr$[rsp], rax

; 1628 :         if (!eleptr)  {

  00046	48 83 7c 24 78
	00		 cmp	 QWORD PTR eleptr$[rsp], 0
  0004c	0f 85 90 00 00
	00		 jne	 $LN4@make_sna_r

; 1629 :             WRMSG(HHC01020, "E", SSID_TO_LCSS(ca->dev->ssid), ca->dev->devnum, "SNA request2");

  00052	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00061	89 44 24 6c	 mov	 DWORD PTR tv73[rsp], eax
  00065	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0006d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00070	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00074	d1 f9		 sar	 ecx, 1
  00076	89 4c 24 70	 mov	 DWORD PTR tv78[rsp], ecx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169230
  0008c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00091	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv73[rsp]
  00095	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00099	8b 4c 24 70	 mov	 ecx, DWORD PTR tv78[rsp]
  0009d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169231
  000a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169232
  000b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169233
  000cb	ba 5d 06 00 00	 mov	 edx, 1629		; 0000065dH
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169234
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1630 :             return;

  000dd	e9 84 04 00 00	 jmp	 $LN1@make_sna_r
$LN4@make_sna_r:

; 1631 :         }
; 1632 :         respbuf = SIZEOF_INT_P + (BYTE*)eleptr;

  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR eleptr$[rsp]
  000e7	48 83 c0 08	 add	 rax, 8
  000eb	48 89 44 24 58	 mov	 QWORD PTR respbuf$[rsp], rax

; 1633 : 
; 1634 :         /* first do the ten-byte FID1 TH */
; 1635 :         respbuf[0] = 0x1C;

  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	48 6b c0 00	 imul	 rax, rax, 0
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  000fe	c6 04 01 1c	 mov	 BYTE PTR [rcx+rax], 28

; 1636 :         respbuf[1] = 0x00;

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	48 6b c0 01	 imul	 rax, rax, 1
  0010b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00110	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1637 :         respbuf[2] = ca->tso_addr0;   // daf

  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	48 6b c0 02	 imul	 rax, rax, 2
  0011d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00122	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0012a	0f b6 92 b8 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65720]
  00131	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1638 :         respbuf[3] = ca->tso_addr1;

  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	48 6b c0 03	 imul	 rax, rax, 3
  0013d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00142	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0014a	0f b6 92 b9 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65721]
  00151	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1639 :         respbuf[4] = ca->lu_addr0;   // oaf

  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 04	 imul	 rax, rax, 4
  0015d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00162	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0016a	0f b6 92 b6 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65718]
  00171	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1640 :         respbuf[5] = ca->lu_addr1;   // oaf

  00174	b8 01 00 00 00	 mov	 eax, 1
  00179	48 6b c0 05	 imul	 rax, rax, 5
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00182	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0018a	0f b6 92 b7 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65719]
  00191	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1641 :         respbuf[6] = (unsigned char)(++ca->lu_lu_seqn >> 8) & 0xff;

  00194	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0019c	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001a2	ff c0		 inc	 eax
  001a4	89 44 24 64	 mov	 DWORD PTR tv142[rsp], eax
  001a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  001b0	8b 4c 24 64	 mov	 ecx, DWORD PTR tv142[rsp]
  001b4	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  001ba	8b 44 24 64	 mov	 eax, DWORD PTR tv142[rsp]
  001be	c1 f8 08	 sar	 eax, 8
  001c1	0f b6 c0	 movzx	 eax, al
  001c4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c9	b9 01 00 00 00	 mov	 ecx, 1
  001ce	48 6b c9 06	 imul	 rcx, rcx, 6
  001d2	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  001d7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1642 :         respbuf[7] = (unsigned char)(  ca->lu_lu_seqn     ) & 0xff;

  001da	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  001e2	0f b6 80 84 00
	00 00		 movzx	 eax, BYTE PTR [rax+132]
  001e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ee	b9 01 00 00 00	 mov	 ecx, 1
  001f3	48 6b c9 07	 imul	 rcx, rcx, 7
  001f7	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  001fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1643 : 
; 1644 :         /* do RH */
; 1645 :         respbuf[10] = 0x00;

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	48 6b c0 0a	 imul	 rax, rax, 10
  00208	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0020d	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1646 :         if (!bufp) {

  00211	83 7c 24 60 00	 cmp	 DWORD PTR bufp$[rsp], 0
  00216	75 26		 jne	 SHORT $LN5@make_sna_r

; 1647 :             respbuf[10] |= 0x02;      /* set first in chain */

  00218	b8 01 00 00 00	 mov	 eax, 1
  0021d	48 6b c0 0a	 imul	 rax, rax, 10
  00221	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00226	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0022a	83 c8 02	 or	 eax, 2
  0022d	b9 01 00 00 00	 mov	 ecx, 1
  00232	48 6b c9 0a	 imul	 rcx, rcx, 10
  00236	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  0023b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@make_sna_r:

; 1648 :         }
; 1649 :         respbuf[11] = 0x90;

  0023e	b8 01 00 00 00	 mov	 eax, 1
  00243	48 6b c0 0b	 imul	 rax, rax, 11
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0024c	c6 04 01 90	 mov	 BYTE PTR [rcx+rax], 144	; 00000090H

; 1650 :         respbuf[12] = 0x00;

  00250	b8 01 00 00 00	 mov	 eax, 1
  00255	48 6b c0 0c	 imul	 rax, rax, 12
  00259	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  0025e	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1651 : 
; 1652 :         /* do RU */
; 1653 : 
; 1654 :         // FIXME - max. ru_size should be based on BIND settings
; 1655 :         // A true fix would also require code changes to READ CCW processing
; 1656 :         // including possibly (gasp) segmenting long PIUs into multiple BTUs
; 1657 :         // JW: still not fixed but unitsz is now an external parameter
; 1658 :         //     to allow easier modification
; 1659 :         ru_size = min(ca->unitsz-(BUFPD+10+3),ca->inpbufl);

  00262	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0026a	8b 80 8c 00 01
	00		 mov	 eax, DWORD PTR [rax+65676]
  00270	83 e8 29	 sub	 eax, 41			; 00000029H
  00273	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0027b	3b 81 88 00 01
	00		 cmp	 eax, DWORD PTR [rcx+65672]
  00281	7d 17		 jge	 SHORT $LN15@make_sna_r
  00283	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0028b	8b 80 8c 00 01
	00		 mov	 eax, DWORD PTR [rax+65676]
  00291	83 e8 29	 sub	 eax, 41			; 00000029H
  00294	89 44 24 68	 mov	 DWORD PTR tv175[rsp], eax
  00298	eb 12		 jmp	 SHORT $LN16@make_sna_r
$LN15@make_sna_r:
  0029a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002a2	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  002a8	89 44 24 68	 mov	 DWORD PTR tv175[rsp], eax
$LN16@make_sna_r:
  002ac	8b 44 24 68	 mov	 eax, DWORD PTR tv175[rsp]
  002b0	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1660 :         ru_ptr = &respbuf[13];

  002b4	b8 01 00 00 00	 mov	 eax, 1
  002b9	48 6b c0 0d	 imul	 rax, rax, 13
  002bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  002c2	48 03 c8	 add	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ru_ptr$[rsp], rax

; 1661 : 
; 1662 :         if (!ca->bindflag) {

  002d0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002d8	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  002db	c1 e8 02	 shr	 eax, 2
  002de	83 e0 01	 and	 eax, 1
  002e1	85 c0		 test	 eax, eax
  002e3	0f 85 22 01 00
	00		 jne	 $LN6@make_sna_r

; 1663 :             // send as character-coded logon to SSCP
; 1664 :             if (ru_size > 0 && (ca->inpbuf[ca->inpbufl-1] == 0x0d || ca->inpbuf[ca->inpbufl-1] == 0x25)) {

  002e9	83 7c 24 50 00	 cmp	 DWORD PTR ru_size$[rsp], 0
  002ee	7e 58		 jle	 SHORT $LN7@make_sna_r
  002f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  002f8	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  002fe	ff c8		 dec	 eax
  00300	48 98		 cdqe
  00302	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  0030a	0f b6 84 01 88
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+136]
  00312	83 f8 0d	 cmp	 eax, 13
  00315	74 27		 je	 SHORT $LN8@make_sna_r
  00317	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0031f	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  00325	ff c8		 dec	 eax
  00327	48 98		 cdqe
  00329	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00331	0f b6 84 01 88
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+136]
  00339	83 f8 25	 cmp	 eax, 37			; 00000025H
  0033c	75 0a		 jne	 SHORT $LN7@make_sna_r
$LN8@make_sna_r:

; 1665 :                 ru_size--;

  0033e	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00342	ff c8		 dec	 eax
  00344	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax
$LN7@make_sna_r:

; 1666 :             }
; 1667 :             if (ru_size > 0 && (ca->inpbuf[ca->inpbufl-1] == 0x0d || ca->inpbuf[ca->inpbufl-1] == 0x25)) {

  00348	83 7c 24 50 00	 cmp	 DWORD PTR ru_size$[rsp], 0
  0034d	7e 58		 jle	 SHORT $LN9@make_sna_r
  0034f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00357	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  0035d	ff c8		 dec	 eax
  0035f	48 98		 cdqe
  00361	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00369	0f b6 84 01 88
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+136]
  00371	83 f8 0d	 cmp	 eax, 13
  00374	74 27		 je	 SHORT $LN10@make_sna_r
  00376	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0037e	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  00384	ff c8		 dec	 eax
  00386	48 98		 cdqe
  00388	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00390	0f b6 84 01 88
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+136]
  00398	83 f8 25	 cmp	 eax, 37			; 00000025H
  0039b	75 0a		 jne	 SHORT $LN9@make_sna_r
$LN10@make_sna_r:

; 1668 :                 ru_size--;

  0039d	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  003a1	ff c8		 dec	 eax
  003a3	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax
$LN9@make_sna_r:

; 1669 :             }
; 1670 :             respbuf[2] = ca->sscp_addr0;

  003a7	b8 01 00 00 00	 mov	 eax, 1
  003ac	48 6b c0 02	 imul	 rax, rax, 2
  003b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  003b5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  003bd	0f b6 92 b0 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65712]
  003c4	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1671 :             respbuf[3] = ca->sscp_addr1;

  003c7	b8 01 00 00 00	 mov	 eax, 1
  003cc	48 6b c0 03	 imul	 rax, rax, 3
  003d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  003d5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  003dd	0f b6 92 b1 00
	01 00		 movzx	 edx, BYTE PTR [rdx+65713]
  003e4	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1672 :             respbuf[11] = 0x80;

  003e7	b8 01 00 00 00	 mov	 eax, 1
  003ec	48 6b c0 0b	 imul	 rax, rax, 11
  003f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  003f5	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H

; 1673 :             respbuf[12] = 0x00;

  003f9	b8 01 00 00 00	 mov	 eax, 1
  003fe	48 6b c0 0c	 imul	 rax, rax, 12
  00402	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  00407	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN6@make_sna_r:

; 1674 :         }
; 1675 :         memcpy(ru_ptr, &ca->inpbuf[bufp], ru_size);

  0040b	48 63 44 24 50	 movsxd	 rax, DWORD PTR ru_size$[rsp]
  00410	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR bufp$[rsp]
  00415	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ca$[rsp]
  0041d	48 8d 8c 0a 88
	00 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+136]
  00425	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR ru_ptr$[rsp]
  0042d	48 8b f1	 mov	 rsi, rcx
  00430	48 8b c8	 mov	 rcx, rax
  00433	f3 a4		 rep movsb

; 1676 :         bufp        += ru_size;

  00435	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00439	8b 4c 24 60	 mov	 ecx, DWORD PTR bufp$[rsp]
  0043d	03 c8		 add	 ecx, eax
  0043f	8b c1		 mov	 eax, ecx
  00441	89 44 24 60	 mov	 DWORD PTR bufp$[rsp], eax

; 1677 :         ca->inpbufl -= ru_size;

  00445	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0044d	8b 4c 24 50	 mov	 ecx, DWORD PTR ru_size$[rsp]
  00451	8b 80 88 00 01
	00		 mov	 eax, DWORD PTR [rax+65672]
  00457	2b c1		 sub	 eax, ecx
  00459	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ca$[rsp]
  00461	89 81 88 00 01
	00		 mov	 DWORD PTR [rcx+65672], eax

; 1678 :         if (!ca->is_3270) {

  00467	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0046f	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00472	c1 e8 07	 shr	 eax, 7
  00475	83 e0 01	 and	 eax, 1
  00478	85 c0		 test	 eax, eax
  0047a	75 12		 jne	 SHORT $LN11@make_sna_r

; 1679 :             ca->inpbufl = 0;

  0047c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00484	c7 80 88 00 01
	00 00 00 00 00	 mov	 DWORD PTR [rax+65672], 0
$LN11@make_sna_r:

; 1680 :         }
; 1681 :         if (!ca->inpbufl) {

  0048e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  00496	83 b8 88 00 01
	00 00		 cmp	 DWORD PTR [rax+65672], 0
  0049d	75 61		 jne	 SHORT $LN12@make_sna_r

; 1682 :             respbuf[10] |= 0x01;      /* set last in chain */

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 0a	 imul	 rax, rax, 10
  004a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  004ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004b1	83 c8 01	 or	 eax, 1
  004b4	b9 01 00 00 00	 mov	 ecx, 1
  004b9	48 6b c9 0a	 imul	 rcx, rcx, 10
  004bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  004c2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1683 :             if (ca->bindflag) {

  004c5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  004cd	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  004d0	c1 e8 02	 shr	 eax, 2
  004d3	83 e0 01	 and	 eax, 1
  004d6	85 c0		 test	 eax, eax
  004d8	74 26		 je	 SHORT $LN13@make_sna_r

; 1684 :                 respbuf[12] |= 0x20;      /* set CD */

  004da	b8 01 00 00 00	 mov	 eax, 1
  004df	48 6b c0 0c	 imul	 rax, rax, 12
  004e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR respbuf$[rsp]
  004e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004ec	83 c8 20	 or	 eax, 32			; 00000020H
  004ef	b9 01 00 00 00	 mov	 ecx, 1
  004f4	48 6b c9 0c	 imul	 rcx, rcx, 12
  004f8	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  004fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN13@make_sna_r:
$LN12@make_sna_r:

; 1685 :             }
; 1686 :         }
; 1687 : 
; 1688 :         /* set length field in TH */
; 1689 :         ru_size += 3;   /* for RH */

  00500	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  00504	83 c0 03	 add	 eax, 3
  00507	89 44 24 50	 mov	 DWORD PTR ru_size$[rsp], eax

; 1690 :         respbuf[8] = (unsigned char)(ru_size >> 8) & 0xff;

  0050b	8b 44 24 50	 mov	 eax, DWORD PTR ru_size$[rsp]
  0050f	c1 f8 08	 sar	 eax, 8
  00512	0f b6 c0	 movzx	 eax, al
  00515	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0051a	b9 01 00 00 00	 mov	 ecx, 1
  0051f	48 6b c9 08	 imul	 rcx, rcx, 8
  00523	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00528	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1691 :         respbuf[9] = (unsigned char)(ru_size     ) & 0xff;

  0052b	0f b6 44 24 50	 movzx	 eax, BYTE PTR ru_size$[rsp]
  00530	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00535	b9 01 00 00 00	 mov	 ecx, 1
  0053a	48 6b c9 09	 imul	 rcx, rcx, 9
  0053e	48 8b 54 24 58	 mov	 rdx, QWORD PTR respbuf$[rsp]
  00543	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1692 : 
; 1693 :         put_bufpool(&ca->sendq, eleptr);

  00546	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ca$[rsp]
  0054e	48 05 a0 00 01
	00		 add	 rax, 65696		; 000100a0H
  00554	48 8b 54 24 78	 mov	 rdx, QWORD PTR eleptr$[rsp]
  00559	48 8b c8	 mov	 rcx, rax
  0055c	e8 00 00 00 00	 call	 put_bufpool

; 1694 :     } /* end of while (ca->inpbufl > 0) */

  00561	e9 b0 fa ff ff	 jmp	 $LN2@make_sna_r
$LN3@make_sna_r:
$LN1@make_sna_r:

; 1695 : }

  00566	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0056d	5f		 pop	 rdi
  0056e	5e		 pop	 rsi
  0056f	c3		 ret	 0
make_sna_requests2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
