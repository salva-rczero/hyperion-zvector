; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	shared_ckd_init
PUBLIC	shared_fba_init
PUBLIC	shared_ckd_device_hndinfo
PUBLIC	shared_fba_device_hndinfo
EXTRN	ckd_dasd_execute_ccw:PROC
EXTRN	ckd_dasd_query_device:PROC
EXTRN	ckd_dasd_hsuspend:PROC
EXTRN	ckd_dasd_hresume:PROC
EXTRN	fba_dasd_execute_ccw:PROC
EXTRN	fba_dasd_query_device:PROC
EXTRN	fba_dasd_hsuspend:PROC
EXTRN	fba_dasd_hresume:PROC
_DATA	SEGMENT
shared_ckd_device_hndinfo DQ FLAT:shared_ckd_init
	DQ	FLAT:ckd_dasd_execute_ccw
	DQ	FLAT:shared_ckd_close
	DQ	FLAT:ckd_dasd_query_device
	DQ	0000000000000000H
	DQ	FLAT:shared_start
	DQ	FLAT:shared_end
	DQ	FLAT:shared_start
	DQ	FLAT:shared_end
	DQ	0000000000000000H
	DQ	FLAT:shared_ckd_read
	DQ	FLAT:shared_ckd_write
	DQ	FLAT:shared_used
	DQ	FLAT:shared_reserve
	DQ	FLAT:shared_release
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ckd_dasd_hsuspend
	DQ	FLAT:ckd_dasd_hresume
	ORG $+8
shared_fba_device_hndinfo DQ FLAT:shared_fba_init
	DQ	FLAT:fba_dasd_execute_ccw
	DQ	FLAT:shared_fba_close
	DQ	FLAT:fba_dasd_query_device
	DQ	0000000000000000H
	DQ	FLAT:shared_start
	DQ	FLAT:shared_end
	DQ	FLAT:shared_start
	DQ	FLAT:shared_end
	DQ	0000000000000000H
	DQ	FLAT:shared_ckd_read
	DQ	FLAT:shared_ckd_write
	DQ	FLAT:shared_used
	DQ	FLAT:shared_reserve
	DQ	FLAT:shared_release
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_hsuspend
	DQ	FLAT:fba_dasd_hresume
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	shared_update_notify
PUBLIC	shared_server
PUBLIC	shrd_cmd
PUBLIC	shared_print_trace_table
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	store_dw_noswap
PUBLIC	shutdown_shared_server
PUBLIC	shutdown_shared_server_locked
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_FormatTIMEVAL:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_socket_is_socket:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_hdl_addshut:PROC
EXTRN	__imp_hdl_delshut:PROC
EXTRN	cache_lookup:PROC
EXTRN	cache_scan:PROC
EXTRN	cache_lock:PROC
EXTRN	cache_unlock:PROC
EXTRN	cache_wait:PROC
EXTRN	cache_getkey:PROC
EXTRN	cache_setkey:PROC
EXTRN	cache_setflag:PROC
EXTRN	cache_setage:PROC
EXTRN	cache_getbuf:PROC
EXTRN	cache_getlen:PROC
EXTRN	cache_release:PROC
EXTRN	dasd_lookup:PROC
EXTRN	ckd_build_sense:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	gen_dasd_serial:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG170276 DB	01H DUP (?)
$SG170491 DB	01H DUP (?)
$SG170493 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$strupper DD imagerel strupper
	DD	imagerel strupper+114
	DD	imagerel $unwind$strupper
$pdata$shared_update_notify DD imagerel $LN16
	DD	imagerel $LN16+528
	DD	imagerel $unwind$shared_update_notify
$pdata$shared_ckd_init DD imagerel $LN107
	DD	imagerel $LN107+5221
	DD	imagerel $unwind$shared_ckd_init
$pdata$shared_fba_init DD imagerel $LN104
	DD	imagerel $LN104+4437
	DD	imagerel $unwind$shared_fba_init
$pdata$shared_server DD imagerel $LN48
	DD	imagerel $LN48+2922
	DD	imagerel $unwind$shared_server
$pdata$shrd_cmd DD imagerel $LN28
	DD	imagerel $LN28+2402
	DD	imagerel $unwind$shrd_cmd
$pdata$shared_print_trace_table DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$shared_print_trace_table
$pdata$shared_ckd_close DD imagerel shared_ckd_close
	DD	imagerel shared_ckd_close+124
	DD	imagerel $unwind$shared_ckd_close
$pdata$shared_fba_close DD imagerel shared_fba_close
	DD	imagerel shared_fba_close+124
	DD	imagerel $unwind$shared_fba_close
$pdata$shared_start DD imagerel shared_start
	DD	imagerel shared_start+722
	DD	imagerel $unwind$shared_start
$pdata$shared_end DD imagerel shared_end
	DD	imagerel shared_end+434
	DD	imagerel $unwind$shared_end
$pdata$shared_ckd_read DD imagerel shared_ckd_read
	DD	imagerel shared_ckd_read+2250
	DD	imagerel $unwind$shared_ckd_read
$pdata$shared_ckd_write DD imagerel shared_ckd_write
	DD	imagerel shared_ckd_write+549
	DD	imagerel $unwind$shared_ckd_write
$pdata$shared_ckd_trklen DD imagerel shared_ckd_trklen
	DD	imagerel shared_ckd_trklen+229
	DD	imagerel $unwind$shared_ckd_trklen
$pdata$shared_used DD imagerel shared_used
	DD	imagerel shared_used+257
	DD	imagerel $unwind$shared_used
$pdata$shared_reserve DD imagerel shared_reserve
	DD	imagerel shared_reserve+65
	DD	imagerel $unwind$shared_reserve
$pdata$shared_release DD imagerel shared_release
	DD	imagerel shared_release+65
	DD	imagerel $unwind$shared_release
$pdata$clientWrite DD imagerel clientWrite
	DD	imagerel clientWrite+1368
	DD	imagerel $unwind$clientWrite
$pdata$clientPurge DD imagerel clientPurge
	DD	imagerel clientPurge+88
	DD	imagerel $unwind$clientPurge
$pdata$clientPurgescan DD imagerel clientPurgescan
	DD	imagerel clientPurgescan+292
	DD	imagerel $unwind$clientPurgescan
$pdata$clientConnect DD imagerel clientConnect
	DD	imagerel clientConnect+2222
	DD	imagerel $unwind$clientConnect
$pdata$clientRequest DD imagerel clientRequest
	DD	imagerel clientRequest+798
	DD	imagerel $unwind$clientRequest
$pdata$clientSend DD imagerel clientSend
	DD	imagerel clientSend+1464
	DD	imagerel $unwind$clientSend
$pdata$clientRecv DD imagerel clientRecv
	DD	imagerel clientRecv+1208
	DD	imagerel $unwind$clientRecv
$pdata$recvData DD imagerel recvData
	DD	imagerel recvData+1308
	DD	imagerel $unwind$recvData
$pdata$serverRequest DD imagerel serverRequest
	DD	imagerel serverRequest+8128
	DD	imagerel $unwind$serverRequest
$pdata$serverLocate DD imagerel serverLocate
	DD	imagerel serverLocate+152
	DD	imagerel $unwind$serverLocate
$pdata$serverId DD imagerel serverId
	DD	imagerel serverId+212
	DD	imagerel $unwind$serverId
$pdata$serverError DD imagerel serverError
	DD	imagerel serverError+390
	DD	imagerel $unwind$serverError
$pdata$serverSend DD imagerel serverSend
	DD	imagerel serverSend+954
	DD	imagerel $unwind$serverSend
$pdata$serverDisconnectable DD imagerel serverDisconnectable
	DD	imagerel serverDisconnectable+161
	DD	imagerel $unwind$serverDisconnectable
$pdata$serverDisconnect DD imagerel serverDisconnect
	DD	imagerel serverDisconnect+1107
	DD	imagerel $unwind$serverDisconnect
$pdata$clientip DD imagerel clientip
	DD	imagerel clientip+87
	DD	imagerel $unwind$clientip
$pdata$findDevice DD imagerel findDevice
	DD	imagerel findDevice+78
	DD	imagerel $unwind$findDevice
$pdata$serverConnect DD imagerel serverConnect
	DD	imagerel serverConnect+4416
	DD	imagerel $unwind$serverConnect
$pdata$shrdhdrtrc DD imagerel shrdhdrtrc
	DD	imagerel shrdhdrtrc+438
	DD	imagerel $unwind$shrdhdrtrc
$pdata$shrdtrc DD imagerel shrdtrc
	DD	imagerel shrdtrc+907
	DD	imagerel $unwind$shrdtrc
$pdata$shrdcmd2str DD imagerel shrdcmd2str
	DD	imagerel shrdcmd2str+733
	DD	imagerel $unwind$shrdcmd2str
$pdata$shared_print_trace_table_locked DD imagerel shared_print_trace_table_locked
	DD	imagerel shared_print_trace_table_locked+487
	DD	imagerel $unwind$shared_print_trace_table_locked
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$shutdown_shared_server DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$shutdown_shared_server
$pdata$shutdown_shared_server_locked DD imagerel $LN19
	DD	imagerel $LN19+265
	DD	imagerel $unwind$shutdown_shared_server_locked
pdata	ENDS
_DATA	SEGMENT
$SG168857 DB	'notify %d added for id=%d, n=%d', 00H
$SG168926 DB	'%hu%c', 00H
	ORG $+2
$SG168931 DB	'%hx%c', 00H
	ORG $+2
$SG168934 DB	'readonly', 00H
	ORG $+3
$SG168935 DB	'rdonly', 00H
	ORG $+1
$SG168936 DB	'ro', 00H
	ORG $+1
$SG168939 DB	'fakewrite', 00H
	ORG $+2
$SG168941 DB	'fw', 00H
	ORG $+1
$SG168940 DB	'fakewrt', 00H
$SG168943 DB	'cu=', 00H
$SG168944 DB	'=', 00H
	ORG $+2
$SG168945 DB	' ', 09H, 00H
	ORG $+1
$SG168946 DB	'S', 00H
	ORG $+2
$SG168947 DB	'HHC00700%s Shared: parameter %s in argument %d is invali'
	DB	'd', 0aH, 00H
	ORG $+1
$SG168951 DB	'W', 00H
	ORG $+2
$SG168948 DB	'shared_ckd_init', 00H
$SG168949 DB	'shared.c', 00H
	ORG $+3
$SG168962 DB	'S', 00H
	ORG $+2
$SG168952 DB	'HHC00701%s %1d:%04X Shared: connect pending to file %s', 0aH
	DB	00H
$SG168953 DB	'shared_ckd_init', 00H
$SG168954 DB	'shared.c', 00H
	ORG $+3
$SG168970 DB	'S', 00H
	ORG $+2
$SG168963 DB	'HHC00702%s %1d:%04X Shared: error retrieving cylinders', 0aH
	DB	00H
$SG168964 DB	'shared_ckd_init', 00H
$SG168965 DB	'shared.c', 00H
	ORG $+7
$SG168972 DB	'shared_ckd_init', 00H
$SG168977 DB	'S', 00H
	ORG $+6
$SG168971 DB	'HHC00703%s %1d:%04X Shared: error retrieving device char'
	DB	'acteristics', 0aH, 00H
	ORG $+3
$SG168973 DB	'shared.c', 00H
	ORG $+3
$SG168985 DB	'S', 00H
	ORG $+2
$SG168978 DB	'HHC00704%s %1d:%04X Shared: remote device %04X is a %04X'
	DB	0aH, 00H
	ORG $+2
$SG168996 DB	'S', 00H
	ORG $+2
$SG168979 DB	'shared_ckd_init', 00H
$SG168980 DB	'shared.c', 00H
	ORG $+3
$SG169001 DB	'S', 00H
	ORG $+2
$SG168986 DB	'HHC00705%s %1d:%04X Shared: error retrieving device id', 0aH
	DB	00H
$SG168987 DB	'shared_ckd_init', 00H
$SG168988 DB	'shared.c', 00H
	ORG $+3
$SG169006 DB	'S', 00H
	ORG $+2
$SG168997 DB	'HHC00716%s %1d:%04X Shared: error retrieving serial numb'
	DB	'er', 0aH, 00H
$SG169012 DB	'I', 00H
	ORG $+2
$SG168998 DB	'shared_ckd_init', 00H
$SG168999 DB	'shared.c', 00H
	ORG $+7
$SG169002 DB	'HHC00706%s %1d:%04X Shared: device type %4.4X not found '
	DB	'in dasd table', 0aH, 00H
	ORG $+1
$SG169003 DB	'shared_ckd_init', 00H
$SG169004 DB	'shared.c', 00H
	ORG $+7
$SG169008 DB	'shared_ckd_init', 00H
$SG169091 DB	'%hu%c', 00H
	ORG $+2
$SG169007 DB	'HHC00707%s %1d:%04X Shared: control unit %s not found in'
	DB	' dasd table', 0aH, 00H
	ORG $+3
$SG169009 DB	'shared.c', 00H
	ORG $+7
$SG169014 DB	'shared_ckd_init', 00H
$SG169096 DB	'%hx%c', 00H
	ORG $+2
$SG169013 DB	'HHC00708%s %1d:%04X Shared: file %s: model %s cyls %d he'
	DB	'ads %d tracks %d trklen %d', 0aH, 00H
$SG169097 DB	'S', 00H
	ORG $+2
$SG169015 DB	'shared.c', 00H
	ORG $+3
$SG169103 DB	'W', 00H
	ORG $+2
$SG169098 DB	'HHC00700%s Shared: parameter %s in argument %d is invali'
	DB	'd', 0aH, 00H
	ORG $+1
$SG169114 DB	'S', 00H
	ORG $+2
$SG169099 DB	'shared_fba_init', 00H
$SG169100 DB	'shared.c', 00H
	ORG $+3
$SG169121 DB	'S', 00H
	ORG $+2
$SG169104 DB	'HHC00701%s %1d:%04X Shared: connect pending to file %s', 0aH
	DB	00H
$SG169105 DB	'shared_fba_init', 00H
$SG169106 DB	'shared.c', 00H
	ORG $+3
$SG169128 DB	'S', 00H
	ORG $+2
$SG169115 DB	'HHC00709%s %1d:%04X Shared: error retrieving fba origin', 0aH
	DB	00H
	ORG $+3
$SG169136 DB	'S', 00H
	ORG $+2
$SG169116 DB	'shared_fba_init', 00H
$SG169117 DB	'shared.c', 00H
	ORG $+7
$SG169122 DB	'HHC00710%s %1d:%04X Shared: error retrieving fba number '
	DB	'blocks', 0aH, 00H
$SG169123 DB	'shared_fba_init', 00H
$SG169124 DB	'shared.c', 00H
	ORG $+3
$SG169141 DB	'S', 00H
	ORG $+2
$SG169129 DB	'HHC00711%s %1d:%04X Shared: error retrieving fba block s'
	DB	'ize', 0aH, 00H
	ORG $+3
$SG169130 DB	'shared_fba_init', 00H
$SG169131 DB	'shared.c', 00H
	ORG $+3
$SG169149 DB	'S', 00H
	ORG $+2
$SG169137 DB	'HHC00705%s %1d:%04X Shared: error retrieving device id', 0aH
	DB	00H
$SG169138 DB	'shared_fba_init', 00H
$SG169139 DB	'shared.c', 00H
	ORG $+3
$SG169160 DB	'S', 00H
	ORG $+2
$SG169142 DB	'HHC00704%s %1d:%04X Shared: remote device %04X is a %04X'
	DB	0aH, 00H
	ORG $+2
$SG169165 DB	'S', 00H
	ORG $+2
$SG169143 DB	'shared_fba_init', 00H
$SG169144 DB	'shared.c', 00H
	ORG $+7
$SG169151 DB	'shared_fba_init', 00H
$SG169169 DB	'I', 00H
	ORG $+6
$SG169150 DB	'HHC00703%s %1d:%04X Shared: error retrieving device char'
	DB	'acteristics', 0aH, 00H
	ORG $+3
$SG169152 DB	'shared.c', 00H
	ORG $+3
$SG169197 DB	'E', 00H
	ORG $+2
$SG169161 DB	'HHC00716%s %1d:%04X Shared: error retrieving serial numb'
	DB	'er', 0aH, 00H
$SG169219 DB	'E', 00H
	ORG $+2
$SG169162 DB	'shared_fba_init', 00H
$SG169163 DB	'shared.c', 00H
	ORG $+7
$SG169167 DB	'shared_fba_init', 00H
$SG169195 DB	'start cur %d cache %d', 00H
	ORG $+2
$SG169166 DB	'HHC00706%s %1d:%04X Shared: device type %4.4X not found '
	DB	'in dasd table', 0aH, 00H
	ORG $+1
$SG169168 DB	'shared.c', 00H
	ORG $+7
$SG169171 DB	'shared_fba_init', 00H
$SG169215 DB	'end cur %d cache %d', 00H
	ORG $+4
$SG169170 DB	'HHC00712%s %1d:%04X Shared: file %s: model %s origin %ll'
	DB	'd blks %d', 0aH, 00H
	ORG $+1
$SG169280 DB	'E', 00H
	ORG $+2
$SG169172 DB	'shared.c', 00H
	ORG $+7
$SG169199 DB	'shared_start', 00H
	ORG $+3
$SG169220 DB	'HHC00714%s %1d:%04X Shared: error during channel program'
	DB	' end', 0aH, 00H
	ORG $+2
$SG169271 DB	'ckd read trk %d', 00H
$SG169287 DB	'E', 00H
	ORG $+6
$SG169198 DB	'HHC00713%s %1d:%04X Shared: error during channel program'
	DB	' start', 0aH, 00H
$SG169200 DB	'shared.c', 00H
	ORG $+3
$SG169343 DB	'E', 00H
	ORG $+2
$SG169221 DB	'shared_end', 00H
	ORG $+1
$SG169401 DB	'E', 00H
	ORG $+2
$SG169222 DB	'shared.c', 00H
	ORG $+3
$SG169408 DB	'E', 00H
	ORG $+2
$SG169275 DB	'ckd read trk %d cache hit %d', 00H
	ORG $+3
$SG169277 DB	'ckd read trk %d cache wait', 00H
	ORG $+1
$SG169480 DB	'E', 00H
	ORG $+2
$SG169278 DB	'ckd read trk %d cache miss %d', 00H
	ORG $+2
$SG169281 DB	'HHC00715%s %1d:%04X Shared: remote error reading track %'
	DB	'd', 0aH, 00H
	ORG $+1
$SG169486 DB	'E', 00H
	ORG $+2
$SG169282 DB	'shared_ckd_read', 00H
$SG169283 DB	'shared.c', 00H
	ORG $+3
$SG169500 DB	'I', 00H
	ORG $+2
$SG169288 DB	'HHC00715%s %1d:%04X Shared: remote error reading track %'
	DB	'd', 0aH, 00H
	ORG $+1
$SG169508 DB	'E', 00H
	ORG $+2
$SG169289 DB	'shared_ckd_read', 00H
$SG169290 DB	'shared.c', 00H
	ORG $+3
$SG169645 DB	'E', 00H
	ORG $+2
$SG169308 DB	'ckd write trk %d off %d len %d', 00H
	ORG $+1
$SG169344 DB	'HHC00717%s %1d:%04X Shared: error retrieving usage infor'
	DB	'mation', 0aH, 00H
$SG169345 DB	'shared_used', 00H
$SG169682 DB	'E', 00H
	ORG $+2
$SG169346 DB	'shared.c', 00H
	ORG $+3
$SG169688 DB	'E', 00H
	ORG $+2
$SG169399 DB	'write rcd %d off %d len %d', 00H
	ORG $+1
$SG169694 DB	'E', 00H
	ORG $+2
$SG169402 DB	'HHC00718%s %1d:%04X Shared: error writing track %d', 0aH
	DB	00H
$SG169774 DB	'E', 00H
	ORG $+2
$SG169403 DB	'clientWrite', 00H
$SG169780 DB	'E', 00H
	ORG $+2
$SG169404 DB	'shared.c', 00H
	ORG $+7
$SG169410 DB	'clientWrite', 00H
$SG169773 DB	'libz', 00H
	ORG $+7
$SG169409 DB	'HHC00719%s %1d:%04X Shared: remote error writing track %'
	DB	'd %2.2X-%2.2X', 0aH, 00H
	ORG $+1
$SG169411 DB	'shared.c', 00H
	ORG $+3
$SG169779 DB	'bzip2', 00H
	ORG $+2
$SG170252 DB	'E', 00H
	ORG $+2
$SG169445 DB	'purge %d', 00H
	ORG $+3
$SG170277 DB	'W', 00H
	ORG $+2
$SG169447 DB	'purge %d', 00H
	ORG $+3
$SG170289 DB	'I', 00H
	ORG $+2
$SG169474 DB	'Beg clientConnect sequence for dev %4.4x retry=%d', 00H
	ORG $+2
$SG170387 DB	'E', 00H
	ORG $+2
$SG169479 DB	'socket()', 00H
	ORG $+3
$SG170407 DB	'I', 00H
	ORG $+2
$SG169481 DB	'HHC00720%s %1d:%04X Shared: error in function %s: %s', 0aH
	DB	00H
	ORG $+2
$SG169482 DB	'clientConnect', 00H
	ORG $+2
$SG169483 DB	'shared.c', 00H
	ORG $+3
$SG170416 DB	'I', 00H
	ORG $+2
$SG169485 DB	'socket()', 00H
	ORG $+3
$SG170441 DB	'E', 00H
	ORG $+2
$SG169487 DB	'HHC00720%s %1d:%04X Shared: error in function %s: %s', 0aH
	DB	00H
	ORG $+2
$SG169488 DB	'clientConnect', 00H
	ORG $+2
$SG169489 DB	'shared.c', 00H
	ORG $+3
$SG170452 DB	'E', 00H
	ORG $+2
$SG169492 DB	'connect rc=%d errno=%d %s', 00H
	ORG $+2
$SG170463 DB	'I', 00H
	ORG $+2
$SG169493 DB	'connect rc=%d', 00H
	ORG $+2
$SG169514 DB	'end clientConnect sequence for dev %4.4x retry=%d', 00H
	ORG $+6
$SG169501 DB	'HHC00721%s %1d:%04X Shared: connected to v%d.%d server i'
	DB	'd %d file %s', 0aH, 00H
	ORG $+2
$SG169502 DB	'clientConnect', 00H
	ORG $+2
$SG169503 DB	'shared.c', 00H
	ORG $+3
$SG170490 DB	'%2.2x', 00H
	ORG $+2
$SG170492 DB	' ', 00H
	ORG $+2
$SG169509 DB	'HHC00722%s %1d:%04X Shared: error in connect to file %s:'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG169510 DB	'clientConnect', 00H
	ORG $+2
$SG169511 DB	'shared.c', 00H
	ORG $+3
$SG170532 DB	'I', 00H
	ORG $+2
$SG169564 DB	'client request', 00H
	ORG $+1
$SG169569 DB	'client response', 00H
$SG169635 DB	'client send', 00H
$SG170629 DB	'I', 00H
	ORG $+2
$SG169638 DB	'(compressed)', 00H
	ORG $+3
$SG169640 DB	'send rc=%d errno=%d %s', 00H
	ORG $+1
$SG169643 DB	'client send retry', 00H
	ORG $+2
$SG170635 DB	'E', 00H
	ORG $+2
$SG169646 DB	'HHC00723%s %1d:%04X Shared: error in send for %2.2X-%2.2'
	DB	'X: %s', 0aH, 00H
	ORG $+1
$SG169647 DB	'clientSend', 00H
	ORG $+1
$SG170641 DB	'W', 00H
	ORG $+2
$SG169648 DB	'shared.c', 00H
	ORG $+3
$SG170648 DB	'bind()', 00H
	ORG $+1
$SG170649 DB	'E', 00H
	ORG $+2
$SG169683 DB	'HHC00724%s %1d:%04X Shared: not connected to file %s', 0aH
	DB	00H
	ORG $+2
$SG169684 DB	'clientRecv', 00H
	ORG $+1
$SG170655 DB	'E', 00H
	ORG $+2
$SG169685 DB	'shared.c', 00H
	ORG $+3
$SG170662 DB	'W', 00H
	ORG $+2
$SG169689 DB	'HHC00725%s %1d:%04X Shared: error in receive: %s', 0aH, 00H
	ORG $+2
$SG170668 DB	'I', 00H
	ORG $+2
$SG169690 DB	'clientRecv', 00H
	ORG $+1
$SG170682 DB	'E', 00H
	ORG $+2
$SG169691 DB	'shared.c', 00H
	ORG $+3
$SG170693 DB	'E', 00H
	ORG $+2
$SG169692 DB	'client recv', 00H
$SG170699 DB	'E', 00H
	ORG $+2
$SG169695 DB	'HHC00726%s %1d:%04X Shared: remote error %2.2X-%2.2X: %s'
	DB	0aH, 00H
	ORG $+2
$SG170706 DB	'E', 00H
	ORG $+2
$SG169696 DB	'clientRecv', 00H
	ORG $+1
$SG170715 DB	'I', 00H
	ORG $+2
$SG169697 DB	'shared.c', 00H
	ORG $+3
$SG170757 DB	'E', 00H
	ORG $+2
$SG169759 DB	'recvData', 00H
	ORG $+7
$SG169786 DB	'(uncompressed)', 00H
	ORG $+1
$SG170050 DB	'server request [%d]', 00H
	ORG $+4
$SG169775 DB	'HHC00728%s Shared: data compressed using method %s is un'
	DB	'supported', 0aH, 00H
	ORG $+1
$SG170765 DB	'I', 00H
	ORG $+2
$SG169776 DB	'recvData', 00H
	ORG $+3
$SG170769 DB	'=', 00H
	ORG $+2
$SG169777 DB	'shared.c', 00H
	ORG $+7
$SG170053 DB	'device not initialized', 00H
	ORG $+1
$SG169781 DB	'HHC00728%s Shared: data compressed using method %s is un'
	DB	'supported', 0aH, 00H
	ORG $+1
$SG170770 DB	' ', 09H, 00H
	ORG $+1
$SG169782 DB	'recvData', 00H
	ORG $+3
$SG170772 DB	'E', 00H
	ORG $+2
$SG169783 DB	'shared.c', 00H
	ORG $+3
$SG170777 DB	'TRACE', 00H
	ORG $+2
$SG170783 DB	'E', 00H
	ORG $+2
$SG169787 DB	'recvData', 00H
	ORG $+3
$SG170791 DB	'E', 00H
	ORG $+2
$SG169794 DB	'CONNECT ', 00H
	ORG $+3
$SG170798 DB	'I', 00H
	ORG $+2
$SG169796 DB	'DISCONNE', 00H
	ORG $+3
$SG170806 DB	'E', 00H
	ORG $+2
$SG169798 DB	'START   ', 00H
	ORG $+3
$SG170813 DB	'E', 00H
	ORG $+2
$SG169800 DB	'END     ', 00H
	ORG $+3
$SG170820 DB	'I', 00H
	ORG $+2
$SG169802 DB	'RESUME  ', 00H
	ORG $+3
$SG170824 DB	'E', 00H
	ORG $+2
$SG169804 DB	'SUSPEND ', 00H
	ORG $+3
$SG170842 DB	'I', 00H
	ORG $+2
$SG169806 DB	'RESERVE ', 00H
	ORG $+3
$SG170848 DB	'(none)', 00H
	ORG $+1
$SG170849 DB	'I', 00H
	ORG $+2
$SG169808 DB	'RELEASE ', 00H
	ORG $+3
$SG170853 DB	'(NULL)', 00H
	ORG $+1
$SG170854 DB	'I', 00H
	ORG $+2
$SG169810 DB	'READ    ', 00H
	ORG $+7
$SG169812 DB	'WRITE   ', 00H
	ORG $+7
$SG169814 DB	'SENSE   ', 00H
	ORG $+7
$SG169816 DB	'QUERY   ', 00H
	ORG $+7
$SG169818 DB	'COMPRESS', 00H
	ORG $+7
$SG169820 DB	'OK      ', 00H
	ORG $+7
$SG169822 DB	'ERROR   ', 00H
	ORG $+7
$SG169824 DB	'IOERR   ', 00H
	ORG $+7
$SG169826 DB	'BUSY    ', 00H
	ORG $+7
$SG169828 DB	'COMP    ', 00H
	ORG $+7
$SG169830 DB	'PURGE   ', 00H
	ORG $+7
$SG169832 DB	'INVALID ', 00H
	ORG $+7
$SG169834 DB	'BADVERS ', 00H
	ORG $+7
$SG169836 DB	'NOTINIT ', 00H
	ORG $+7
$SG169838 DB	'NOTCONN ', 00H
	ORG $+7
$SG169840 DB	'NOTAVAIL', 00H
	ORG $+7
$SG169842 DB	'NOMEM   ', 00H
	ORG $+7
$SG169844 DB	'NOTACTIV', 00H
	ORG $+7
$SG169846 DB	'NODEVICE', 00H
	ORG $+7
$SG169848 DB	'ECONNECT', 00H
	ORG $+7
$SG169850 DB	'????????', 00H
	ORG $+7
$SG170055 DB	'shared version mismatch', 00H
$SG170057 DB	'shared.c:1711', 00H
	ORG $+2
$SG170062 DB	'shared.c:1724', 00H
	ORG $+2
$SG170063 DB	'shared.c:1727', 00H
	ORG $+2
$SG170066 DB	'shared.c:1733', 00H
	ORG $+2
$SG170069 DB	'server request busy id=%d shioactive=%d reserved=%d', 00H
	ORG $+4
$SG170071 DB	'shared.c:1747', 00H
	ORG $+2
$SG170072 DB	'shared.c:1759', 00H
	ORG $+2
$SG170074 DB	'shared.c:1766', 00H
	ORG $+2
$SG170075 DB	'server request active id=%d', 00H
	ORG $+4
$SG170076 DB	'shared.c:1782', 00H
	ORG $+2
$SG170088 DB	'not active on this device', 00H
	ORG $+6
$SG170092 DB	'shared.c:1825', 00H
	ORG $+2
$SG170098 DB	'shared.c:1849', 00H
	ORG $+2
$SG170099 DB	'server request inactive id=%d', 00H
	ORG $+2
$SG170100 DB	'shared.c:1853', 00H
	ORG $+2
$SG170103 DB	'not active on this device', 00H
	ORG $+6
$SG170104 DB	'shared.c:1869', 00H
	ORG $+2
$SG170105 DB	'shared.c:1871', 00H
	ORG $+2
$SG170106 DB	'server request reserved id=%d', 00H
	ORG $+2
$SG170110 DB	'not active on this device', 00H
	ORG $+6
$SG170112 DB	'shared.c:1896', 00H
	ORG $+2
$SG170113 DB	'shared.c:1898', 00H
	ORG $+2
$SG170114 DB	'server request released id=%d', 00H
	ORG $+2
$SG170117 DB	'not active on this device', 00H
	ORG $+6
$SG170118 DB	'server request read rcd %d flag %2.2x rc=%d', 00H
	ORG $+4
$SG170123 DB	'not active on this device', 00H
	ORG $+6
$SG170124 DB	'server request write rcd %d off %d len %d flag %2.2x rc='
	DB	'%d', 00H
	ORG $+5
$SG170129 DB	'not active on this device', 00H
	ORG $+6
$SG170142 DB	'invalid query request', 00H
	ORG $+2
$SG170145 DB	'invalid request', 00H
$SG170203 DB	'SERVER ERROR! %2.2x %2.2x: %s', 00H
	ORG $+2
$SG170249 DB	'server send', 00H
	ORG $+4
$SG170253 DB	'HHC00729%s %1d:%04X Shared: error in send id %d: %s', 0aH
	DB	00H
	ORG $+3
$SG170254 DB	'serverSend', 00H
	ORG $+5
$SG170255 DB	'shared.c', 00H
	ORG $+7
$SG170275 DB	'reserved', 00H
	ORG $+7
$SG170278 DB	'HHC00730%s %1d:%04X Shared: busy client being removed id'
	DB	' %d %s', 0aH, 00H
$SG170279 DB	'serverDisconnect', 00H
	ORG $+7
$SG170280 DB	'shared.c', 00H
	ORG $+7
$SG170287 DB	'shared.c:2304', 00H
	ORG $+2
$SG170290 DB	'HHC00731%s %1d:%04X Shared: %s disconnected id %d', 0aH, 00H
	ORG $+5
$SG170291 DB	'serverDisconnect', 00H
	ORG $+7
$SG170292 DB	'shared.c', 00H
	ORG $+7
$SG170385 DB	'server connect %s sock %d', 00H
	ORG $+6
$SG170388 DB	'HHC00732%s Shared: connect to IP %s failed', 0aH, 00H
	ORG $+4
$SG170389 DB	'serverConnect', 00H
	ORG $+2
$SG170390 DB	'shared.c', 00H
	ORG $+7
$SG170392 DB	'not a connect request', 00H
	ORG $+2
$SG170394 DB	'device not found', 00H
	ORG $+7
$SG170395 DB	'shared.c:2409', 00H
	ORG $+2
$SG170397 DB	'shared.c:2414', 00H
	ORG $+2
$SG170398 DB	'already connected', 00H
	ORG $+6
$SG170400 DB	'shared.c:2424', 00H
	ORG $+2
$SG170401 DB	'too many connections', 00H
	ORG $+3
$SG170403 DB	'shared.c:2434', 00H
	ORG $+2
$SG170404 DB	'calloc() failure', 00H
	ORG $+7
$SG170408 DB	'HHC00733%s %1d:%04X Shared: %s connected id %d', 0aH, 00H
$SG170409 DB	'serverConnect', 00H
	ORG $+2
$SG170410 DB	'shared.c', 00H
	ORG $+7
$SG170412 DB	'shared.c:2460', 00H
	ORG $+2
$SG170413 DB	'shrd dev %1d:%04X', 00H
	ORG $+6
$SG170415 DB	'shared.c:2470', 00H
	ORG $+2
$SG170417 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG170418 DB	'serverConnect', 00H
	ORG $+2
$SG170419 DB	'shared.c', 00H
	ORG $+7
$SG170429 DB	'select set %d id=%d', 00H
	ORG $+4
$SG170432 DB	'shared.c:2536', 00H
	ORG $+2
$SG170433 DB	'shared.c', 00H
	ORG $+7
$SG170434 DB	'shared.c:2544', 00H
	ORG $+2
$SG170435 DB	'select rc %d', 00H
	ORG $+3
$SG170440 DB	'select()', 00H
	ORG $+7
$SG170442 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170443 DB	'serverConnect', 00H
	ORG $+2
$SG170444 DB	'shared.c', 00H
	ORG $+7
$SG170446 DB	'select isset %d id=%d', 00H
	ORG $+2
$SG170447 DB	'shared.c:2589', 00H
	ORG $+2
$SG170448 DB	'select ready %d id=%d', 00H
	ORG $+2
$SG170453 DB	'HHC00734%s %1d:%04X Shared: error in receive from %s id '
	DB	'%d', 0aH, 00H
	ORG $+4
$SG170454 DB	'serverConnect', 00H
	ORG $+2
$SG170455 DB	'shared.c', 00H
	ORG $+7
$SG170456 DB	'shared.c:2610', 00H
	ORG $+2
$SG170457 DB	'shared.c:2618', 00H
	ORG $+2
$SG170460 DB	'shared.c:2636', 00H
	ORG $+2
$SG170462 DB	'shared.c:2639', 00H
	ORG $+2
$SG170464 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170465 DB	'serverConnect', 00H
	ORG $+2
$SG170466 DB	'shared.c', 00H
	ORG $+7
$SG170494 DB	'%-18s : %s(%2.2x) %2.2x dev %4.4x id %d len %d%s%s', 00H
	ORG $+5
$SG170518 DB	'shared.c:2679', 00H
	ORG $+2
$SG170520 DB	'shared.c:2683', 00H
	ORG $+2
$SG170522 DB	'shrdtrc', 00H
$SG170523 DB	'shared.c', 00H
	ORG $+7
$SG170524 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170526 DB	'shrdtrc', 00H
$SG170527 DB	'shared.c', 00H
	ORG $+7
$SG170528 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170530 DB	'  %4.4X  ', 00H
	ORG $+6
$SG170533 DB	'HHC00743%s Shared:  %s', 0aH, 00H
$SG170534 DB	'shrdtrc', 00H
$SG170535 DB	'shared.c', 00H
	ORG $+7
$SG170538 DB	'shared.c:2724', 00H
	ORG $+2
$SG170542 DB	'shared.c:2732', 00H
	ORG $+2
$SG170543 DB	'shared.c:2736', 00H
	ORG $+2
$SG170559 DB	'shared.c:2751', 00H
	ORG $+2
$SG170562 DB	'shutdown_shared_server_locked', 00H
	ORG $+2
$SG170563 DB	'shared.c', 00H
	ORG $+7
$SG170566 DB	'shutdown_shared_server_locked', 00H
	ORG $+2
$SG170627 DB	'shrd srvr %d.%d', 00H
$SG170630 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG170564 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170567 DB	'shared.c', 00H
	ORG $+7
$SG170628 DB	'shared.c:2785', 00H
	ORG $+2
$SG170642 DB	'HHC00736%s Shared: waiting for port %u to become free', 0aH
	DB	00H
	ORG $+1
$SG170568 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170631 DB	'shared_server', 00H
	ORG $+2
$SG170632 DB	'shared.c', 00H
	ORG $+7
$SG170634 DB	'socket()', 00H
	ORG $+7
$SG170636 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170637 DB	'shared_server', 00H
	ORG $+2
$SG170638 DB	'shared.c', 00H
	ORG $+7
$SG170643 DB	'shared_server', 00H
	ORG $+2
$SG170644 DB	'shared.c', 00H
	ORG $+7
$SG170650 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170651 DB	'shared_server', 00H
	ORG $+2
$SG170652 DB	'shared.c', 00H
	ORG $+7
$SG170654 DB	'listen()', 00H
	ORG $+7
$SG170656 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170657 DB	'shared_server', 00H
	ORG $+2
$SG170658 DB	'shared.c', 00H
	ORG $+7
$SG170661 DB	'listen()', 00H
	ORG $+7
$SG170663 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170664 DB	'shared_server', 00H
	ORG $+2
$SG170665 DB	'shared.c', 00H
	ORG $+7
$SG170670 DB	'shared_server', 00H
	ORG $+2
$SG170672 DB	'shutdown_shared_server', 00H
	ORG $+1
$SG170669 DB	'HHC00737%s Shared: waiting for shared device requests on'
	DB	' port %u', 0aH, 00H
	ORG $+6
$SG170671 DB	'shared.c', 00H
	ORG $+7
$SG170673 DB	'shared.c:2900', 00H
	ORG $+2
$SG170674 DB	'shared.c:2904', 00H
	ORG $+2
$SG170677 DB	'shared.c', 00H
	ORG $+7
$SG170681 DB	'select()', 00H
	ORG $+7
$SG170683 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170684 DB	'shared_server', 00H
	ORG $+2
$SG170685 DB	'shared.c', 00H
	ORG $+7
$SG170692 DB	'accept()', 00H
	ORG $+7
$SG170694 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170695 DB	'shared_server', 00H
	ORG $+2
$SG170696 DB	'shared.c', 00H
	ORG $+7
$SG170698 DB	'malloc(%d)', 00H
	ORG $+5
$SG170700 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170701 DB	'shared_server', 00H
	ORG $+2
$SG170702 DB	'shared.c', 00H
	ORG $+7
$SG170703 DB	'shared.c:2965', 00H
	ORG $+2
$SG170704 DB	'serverConnect', 00H
	ORG $+2
$SG170707 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG170708 DB	'shared_server', 00H
	ORG $+2
$SG170709 DB	'shared.c', 00H
	ORG $+7
$SG170711 DB	'shared.c:2993', 00H
	ORG $+2
$SG170712 DB	'shared.c:2996', 00H
	ORG $+2
$SG170713 DB	'shared.c:2998', 00H
	ORG $+2
$SG170714 DB	'shared.c:3000', 00H
	ORG $+2
$SG170716 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170717 DB	'shared_server', 00H
	ORG $+2
$SG170718 DB	'shared.c', 00H
	ORG $+7
$SG170758 DB	'HHC00738%s Shared: invalid or missing argument', 0aH, 00H
$SG170759 DB	'shrd_cmd', 00H
	ORG $+7
$SG170760 DB	'shared.c', 00H
	ORG $+7
$SG170762 DB	'shared.c:3033', 00H
	ORG $+2
$SG170763 DB	'TRACE=%d DTAX=%d', 00H
	ORG $+7
$SG170764 DB	'shared.c:3037', 00H
	ORG $+2
$SG170766 DB	'HHC02203%s %-14s: %s', 0aH, 00H
	ORG $+2
$SG170767 DB	'shrd_cmd', 00H
	ORG $+7
$SG170768 DB	'shared.c', 00H
	ORG $+7
$SG170773 DB	'HHC00739%s Shared: invalid or missing keyword', 0aH, 00H
	ORG $+1
$SG170774 DB	'shrd_cmd', 00H
	ORG $+7
$SG170775 DB	'shared.c', 00H
	ORG $+7
$SG170778 DB	'shared.c:3066', 00H
	ORG $+2
$SG170780 DB	'shared.c:3076', 00H
	ORG $+2
$SG170782 DB	'%d%c', 00H
	ORG $+3
$SG170784 DB	'HHC00740%s Shared: invalid or missing value %s', 0aH, 00H
$SG170785 DB	'shrd_cmd', 00H
	ORG $+7
$SG170786 DB	'shared.c', 00H
	ORG $+7
$SG170787 DB	'shared.c:3085', 00H
	ORG $+2
$SG170790 DB	'calloc(%d, %d)', 00H
	ORG $+1
$SG170792 DB	'HHC00735%s Shared: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG170793 DB	'shrd_cmd', 00H
	ORG $+7
$SG170794 DB	'shared.c', 00H
	ORG $+7
$SG170795 DB	'shared.c:3105', 00H
	ORG $+2
$SG170797 DB	'TRACE=%d', 00H
	ORG $+7
$SG170799 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
	ORG $+4
$SG170800 DB	'shrd_cmd', 00H
	ORG $+7
$SG170801 DB	'shared.c', 00H
	ORG $+7
$SG170802 DB	'shared.c:3122', 00H
	ORG $+2
$SG170804 DB	'DTAX', 00H
	ORG $+3
$SG170807 DB	'HHC00740%s Shared: invalid or missing value %s', 0aH, 00H
$SG170808 DB	'shrd_cmd', 00H
	ORG $+7
$SG170809 DB	'shared.c', 00H
	ORG $+3
$SG170812 DB	'%d%c', 00H
	ORG $+7
$SG170814 DB	'HHC00740%s Shared: invalid or missing value %s', 0aH, 00H
$SG170815 DB	'shrd_cmd', 00H
	ORG $+7
$SG170816 DB	'shared.c', 00H
	ORG $+7
$SG170817 DB	'shared.c:3146', 00H
	ORG $+2
$SG170818 DB	'shared.c:3150', 00H
	ORG $+2
$SG170819 DB	'DTAX=%d', 00H
$SG170821 DB	'HHC02204%s %-14s set to %s', 0aH, 00H
	ORG $+4
$SG170822 DB	'shrd_cmd', 00H
	ORG $+7
$SG170823 DB	'shared.c', 00H
	ORG $+7
$SG170825 DB	'HHC00741%s Shared: invalid or missing keyword %s', 0aH, 00H
	ORG $+6
$SG170826 DB	'shrd_cmd', 00H
	ORG $+7
$SG170827 DB	'shared.c', 00H
	ORG $+7
$SG170829 DB	'shared.c:3169', 00H
	ORG $+2
$SG170830 DB	'shared.c:3173', 00H
	ORG $+2
$SG170843 DB	'HHC00743%s Shared:  %s', 0aH, 00H
$SG170844 DB	'shared_print_trace_table_locked', 00H
$SG170845 DB	'shared.c', 00H
	ORG $+7
$SG170850 DB	'HHC00743%s Shared:  %s', 0aH, 00H
$SG170851 DB	'shared_print_trace_table_locked', 00H
$SG170852 DB	'shared.c', 00H
	ORG $+7
$SG170855 DB	'HHC00743%s Shared:  %s', 0aH, 00H
$SG170856 DB	'shared_print_trace_table_locked', 00H
$SG170857 DB	'shared.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shrdtrc
	DD	025H
	DD	0373H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:serverConnect
	DD	01dH
	DD	01127H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clientip
	DD	012H
	DD	045H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:serverSend
	DD	02cH
	DD	03a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:serverError
	DD	021H
	DD	0174H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:serverRequest
	DD	025H
	DD	01f3aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:recvData
	DD	02aH
	DD	0504H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clientSend
	DD	02dH
	DD	059eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clientRequest
	DD	027H
	DD	0304H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clientConnect
	DD	01aH
	DD	0896H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clientWrite
	DD	01aH
	DD	0540H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shared_ckd_read
	DD	01fH
	DD	08b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shared_start
	DD	016H
	DD	02baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shrd_cmd
	DD	01fH
	DD	094aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shared_server
	DD	01dH
	DD	0b51H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shared_fba_init
	DD	01fH
	DD	0113dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:shared_ckd_init
	DD	020H
	DD	0144cH
voltbl	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$strupper DD 010e01H
	DD	0620eH
$unwind$shared_update_notify DD 010d01H
	DD	0820dH
$unwind$shared_ckd_init DD 032819H
	DD	0b00116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0570H
$unwind$shared_fba_init DD 022719H
	DD	0ad0115H
	DD	imagerel __GSHandlerCheck
	DD	0550H
$unwind$shared_server DD 032519H
	DD	042a0113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02148H
$unwind$shrd_cmd DD 022719H
	DD	03f0115H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$shared_print_trace_table DD 010401H
	DD	04204H
$unwind$shared_ckd_close DD 010901H
	DD	08209H
$unwind$shared_fba_close DD 010901H
	DD	08209H
$unwind$shared_start DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$shared_end DD 010901H
	DD	0c209H
$unwind$shared_ckd_read DD 022719H
	DD	0190115H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$shared_ckd_write DD 031901H
	DD	070158219H
	DD	06014H
$unwind$shared_ckd_trklen DD 010e01H
	DD	0620eH
$unwind$shared_used DD 010901H
	DD	0c209H
$unwind$shared_reserve DD 010901H
	DD	0a209H
$unwind$shared_release DD 010901H
	DD	0a209H
$unwind$clientWrite DD 022219H
	DD	03b0110H
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$clientPurge DD 011201H
	DD	04212H
$unwind$clientPurgescan DD 011701H
	DD	08217H
$unwind$clientConnect DD 022219H
	DD	0210110H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$clientRequest DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$clientSend DD 043519H
	DD	0201f0123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0100e0H
$unwind$clientRecv DD 031c01H
	DD	018011cH
	DD	07015H
$unwind$recvData DD 023219H
	DD	020370120H
	DD	imagerel __GSHandlerCheck
	DD	0101a0H
$unwind$serverRequest DD 032d19H
	DD	02a011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$serverLocate DD 011201H
	DD	02212H
$unwind$serverId DD 010901H
	DD	02209H
$unwind$serverError DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$serverSend DD 043419H
	DD	020190122H
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0100b0H
$unwind$serverDisconnectable DD 010d01H
	DD	0220dH
$unwind$serverDisconnect DD 021001H
	DD	0130110H
$unwind$clientip DD 011719H
	DD	08208H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$findDevice DD 010901H
	DD	02209H
$unwind$serverConnect DD 032519H
	DD	0242a0113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	012140H
$unwind$shrdhdrtrc DD 021b01H
	DD	015011bH
$unwind$shrdtrc DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$shrdcmd2str DD 010801H
	DD	02208H
$unwind$shared_print_trace_table_locked DD 020601H
	DD	07002b206H
$unwind$shutdown_shared_server DD 010901H
	DD	04209H
$unwind$shutdown_shared_server_locked DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
unused$ = 48
shutdown_shared_server_locked PROC

; 2743 : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@shutdown_s:

; 2744 :     UNREFERENCED( unused );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@shutdown_s

; 2745 : 
; 2746 :     if (sysblk.shrdport || sysblk.shrdtid)

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0001d	85 c0		 test	 eax, eax
  0001f	75 10		 jne	 SHORT $LN12@shutdown_s
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00028	83 b8 a8 13 00
	00 00		 cmp	 DWORD PTR [rax+5032], 0
  0002f	74 4b		 je	 SHORT $LN11@shutdown_s
$LN12@shutdown_s:

; 2747 :     {
; 2748 :         sysblk.shrdport = 0;

  00031	33 c0		 xor	 eax, eax
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003a	66 89 81 ac 13
	00 00		 mov	 WORD PTR [rcx+5036], ax

; 2749 : 
; 2750 :         if (sysblk.shrdtid)

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00048	83 b8 a8 13 00
	00 00		 cmp	 DWORD PTR [rax+5032], 0
  0004f	74 2b		 je	 SHORT $LN13@shutdown_s

; 2751 :             wait_condition( &sysblk.shrdcond, &sysblk.shrdlock );

  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00058	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00065	48 81 c1 a0 13
	00 00		 add	 rcx, 5024		; 000013a0H
  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170559
  00073	48 8b d0	 mov	 rdx, rax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
$LN13@shutdown_s:
$LN11@shutdown_s:
$LN7@shutdown_s:

; 2752 :     }
; 2753 :     ASSERT( !sysblk.shrdport && !sysblk.shrdtid );

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0008a	85 c0		 test	 eax, eax
  0008c	75 10		 jne	 SHORT $LN15@shutdown_s
  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00095	83 b8 a8 13 00
	00 00		 cmp	 DWORD PTR [rax+5032], 0
  0009c	74 5c		 je	 SHORT $LN14@shutdown_s
$LN15@shutdown_s:
$LN10@shutdown_s:
  0009e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170562
  000a5	41 b8 c1 0a 00
	00		 mov	 r8d, 2753		; 00000ac1H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170563
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170564
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c5	85 c0		 test	 eax, eax
  000c7	74 20		 je	 SHORT $LN16@shutdown_s
  000c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170566
  000d0	41 b8 c1 0a 00
	00		 mov	 r8d, 2753		; 00000ac1H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170567
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170568
  000e4	e8 00 00 00 00	 call	 DebuggerTrace
$LN16@shutdown_s:
  000e9	33 c0		 xor	 eax, eax
  000eb	85 c0		 test	 eax, eax
  000ed	75 af		 jne	 SHORT $LN10@shutdown_s
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f5	85 c0		 test	 eax, eax
  000f7	74 01		 je	 SHORT $LN17@shutdown_s
  000f9	cc		 int	 3
$LN17@shutdown_s:
$LN14@shutdown_s:
  000fa	33 c0		 xor	 eax, eax
  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 78 ff ff
	ff		 jne	 $LN7@shutdown_s

; 2754 : }

  00104	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00108	c3		 ret	 0
shutdown_shared_server_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
unused$ = 48
shutdown_shared_server PROC

; 2731 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2732 :     OBTAIN_SHRDLOCK();

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170542
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2733 :     {
; 2734 :         shutdown_shared_server_locked( unused );

  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR unused$[rsp]
  0002b	e8 00 00 00 00	 call	 shutdown_shared_server_locked

; 2735 :     }
; 2736 :     RELEASE_SHRDLOCK();

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00037	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170543
  00044	48 8b c8	 mov	 rcx, rax
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2737 : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
shutdown_shared_server ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
printed$1 = 64
current$2 = 72
tv137 = 80
shared_print_trace_table_locked PROC

; 3180 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 3181 :     /* Does a trace table exist? */
; 3182 :     if (sysblk.shrdtrace)

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000d	48 83 b8 c0 13
	00 00 00	 cmp	 QWORD PTR [rax+5056], 0
  00015	0f 84 73 01 00
	00		 je	 $LN5@shared_pri

; 3183 :     {
; 3184 :         SHRD_TRACE* current = sysblk.shrdtracep;

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00022	48 8b 80 c8 13
	00 00		 mov	 rax, QWORD PTR [rax+5064]
  00029	48 89 44 24 48	 mov	 QWORD PTR current$2[rsp], rax

; 3185 :         bool printed = false;

  0002e	c6 44 24 40 00	 mov	 BYTE PTR printed$1[rsp], 0
$LN4@shared_pri:

; 3186 : 
; 3187 :         do
; 3188 :         {
; 3189 :             if (current[0][0])

  00033	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00038	48 6b c0 00	 imul	 rax, rax, 0
  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR current$2[rsp]
  00041	48 03 c8	 add	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 6b c9 00	 imul	 rcx, rcx, 0
  00050	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00054	85 c0		 test	 eax, eax
  00056	74 56		 je	 SHORT $LN7@shared_pri

; 3190 :             {
; 3191 :                 // "Shared:  %s"
; 3192 :                 WRMSG( HHC00743, "I", (char*) current );

  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR current$2[rsp]
  00068	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170842
  00074	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170843
  00080	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170844
  00097	ba 78 0c 00 00	 mov	 edx, 3192		; 00000c78H
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170845
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3193 :                 printed = true;

  000a9	c6 44 24 40 01	 mov	 BYTE PTR printed$1[rsp], 1
$LN7@shared_pri:

; 3194 :             }
; 3195 : 
; 3196 :             if (++current >= sysblk.shrdtracex)

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR current$2[rsp]
  000b3	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  000b9	48 89 44 24 48	 mov	 QWORD PTR current$2[rsp], rax
  000be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c5	48 8b 80 d0 13
	00 00		 mov	 rax, QWORD PTR [rax+5072]
  000cc	48 39 44 24 48	 cmp	 QWORD PTR current$2[rsp], rax
  000d1	72 13		 jb	 SHORT $LN8@shared_pri

; 3197 :                 current = sysblk.shrdtrace;

  000d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000da	48 8b 80 c0 13
	00 00		 mov	 rax, QWORD PTR [rax+5056]
  000e1	48 89 44 24 48	 mov	 QWORD PTR current$2[rsp], rax
$LN8@shared_pri:

; 3198 :         }
; 3199 :         while (current != sysblk.shrdtracep);

  000e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ed	48 8b 80 c8 13
	00 00		 mov	 rax, QWORD PTR [rax+5064]
  000f4	48 39 44 24 48	 cmp	 QWORD PTR current$2[rsp], rax
  000f9	0f 85 34 ff ff
	ff		 jne	 $LN4@shared_pri

; 3200 : 
; 3201 :         if (!printed)

  000ff	0f b6 44 24 40	 movzx	 eax, BYTE PTR printed$1[rsp]
  00104	85 c0		 test	 eax, eax
  00106	75 53		 jne	 SHORT $LN9@shared_pri

; 3202 :         {
; 3203 :             // "Shared:  %s"
; 3204 :             WRMSG( HHC00743, "I", "(none)" );

  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170848
  0011a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170849
  00126	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170850
  00132	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00137	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170851
  00149	ba 84 0c 00 00	 mov	 edx, 3204		; 00000c84H
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170852
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@shared_pri:

; 3205 :         }
; 3206 : 
; 3207 :         /* Now that it's been printed, reset it to empty */
; 3208 :         memset( sysblk.shrdtrace, 0, sysblk.shrdtracen * sizeof( SHRD_TRACE ));

  0015b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00162	48 63 80 d8 13
	00 00		 movsxd	 rax, DWORD PTR [rax+5080]
  00169	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00170	48 89 44 24 50	 mov	 QWORD PTR tv137[rsp], rax
  00175	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017c	48 8b b9 c0 13
	00 00		 mov	 rdi, QWORD PTR [rcx+5056]
  00183	33 c0		 xor	 eax, eax
  00185	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv137[rsp]
  0018a	f3 aa		 rep stosb

; 3209 :     }

  0018c	eb 53		 jmp	 SHORT $LN6@shared_pri
$LN5@shared_pri:

; 3210 :     else
; 3211 :         // "Shared:  %s"
; 3212 :         WRMSG( HHC00743, "I", "(NULL)" );

  0018e	b9 01 00 00 00	 mov	 ecx, 1
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170853
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170854
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170855
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170856
  001cf	ba 8c 0c 00 00	 mov	 edx, 3212		; 00000c8cH
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170857
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@shared_pri:

; 3213 : }

  001e1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001e5	5f		 pop	 rdi
  001e6	c3		 ret	 0
shared_print_trace_table_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tv65 = 0
cmd$ = 32
shrdcmd2str PROC

; 1618 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 1619 :     switch (cmd)

  00008	0f b6 44 24 20	 movzx	 eax, BYTE PTR cmd$[rsp]
  0000d	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00010	81 3c 24 f8 00
	00 00		 cmp	 DWORD PTR tv65[rsp], 248 ; 000000f8H
  00017	0f 87 45 01 00
	00		 ja	 $LN32@shrdcmd2st
  0001d	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00028	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN34@shrdcmd2st[rcx+rax]
  00030	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN35@shrdcmd2st[rcx+rax*4]
  00037	48 03 c1	 add	 rax, rcx
  0003a	ff e0		 jmp	 rax
$LN4@shrdcmd2st:

; 1620 :     {
; 1621 :         // Requests
; 1622 :         case SHRD_CONNECT:          return "CONNECT ";

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169794
  00043	e9 21 01 00 00	 jmp	 $LN1@shrdcmd2st
$LN5@shrdcmd2st:

; 1623 :         case SHRD_DISCONNECT:       return "DISCONNE";

  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169796
  0004f	e9 15 01 00 00	 jmp	 $LN1@shrdcmd2st
$LN6@shrdcmd2st:

; 1624 :         case SHRD_START:            return "START   ";

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169798
  0005b	e9 09 01 00 00	 jmp	 $LN1@shrdcmd2st
$LN7@shrdcmd2st:

; 1625 :         case SHRD_END:              return "END     ";

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169800
  00067	e9 fd 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN8@shrdcmd2st:

; 1626 :         case SHRD_RESUME:           return "RESUME  ";

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169802
  00073	e9 f1 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN9@shrdcmd2st:

; 1627 :         case SHRD_SUSPEND:          return "SUSPEND ";

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169804
  0007f	e9 e5 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN10@shrdcmd2st:

; 1628 :         case SHRD_RESERVE:          return "RESERVE ";

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169806
  0008b	e9 d9 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN11@shrdcmd2st:

; 1629 :         case SHRD_RELEASE:          return "RELEASE ";

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169808
  00097	e9 cd 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN12@shrdcmd2st:

; 1630 :         case SHRD_READ:             return "READ    ";

  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169810
  000a3	e9 c1 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN13@shrdcmd2st:

; 1631 :         case SHRD_WRITE:            return "WRITE   ";

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169812
  000af	e9 b5 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN14@shrdcmd2st:

; 1632 :         case SHRD_SENSE:            return "SENSE   ";

  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169814
  000bb	e9 a9 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN15@shrdcmd2st:

; 1633 :         case SHRD_QUERY:            return "QUERY   ";

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169816
  000c7	e9 9d 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN16@shrdcmd2st:

; 1634 :         case SHRD_COMPRESS:         return "COMPRESS";

  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169818
  000d3	e9 91 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN17@shrdcmd2st:

; 1635 : 
; 1636 :         // Response codes
; 1637 :         case SHRD_OK:               return "OK      ";

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169820
  000df	e9 85 00 00 00	 jmp	 $LN1@shrdcmd2st
$LN18@shrdcmd2st:

; 1638 :         case SHRD_ERROR:            return "ERROR   ";

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169822
  000eb	eb 7c		 jmp	 SHORT $LN1@shrdcmd2st
$LN19@shrdcmd2st:

; 1639 :         case SHRD_IOERR:            return "IOERR   ";

  000ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169824
  000f4	eb 73		 jmp	 SHORT $LN1@shrdcmd2st
$LN20@shrdcmd2st:

; 1640 :         case SHRD_BUSY:             return "BUSY    ";

  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169826
  000fd	eb 6a		 jmp	 SHORT $LN1@shrdcmd2st
$LN21@shrdcmd2st:

; 1641 :         case SHRD_COMP:             return "COMP    ";

  000ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169828
  00106	eb 61		 jmp	 SHORT $LN1@shrdcmd2st
$LN22@shrdcmd2st:

; 1642 :         case SHRD_PURGE:            return "PURGE   ";

  00108	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169830
  0010f	eb 58		 jmp	 SHORT $LN1@shrdcmd2st
$LN23@shrdcmd2st:

; 1643 : 
; 1644 :         // Error responses
; 1645 :         case SHRD_ERROR_INVALID:    return "INVALID ";

  00111	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169832
  00118	eb 4f		 jmp	 SHORT $LN1@shrdcmd2st
$LN24@shrdcmd2st:

; 1646 :         case SHRD_ERROR_BADVERS:    return "BADVERS ";

  0011a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169834
  00121	eb 46		 jmp	 SHORT $LN1@shrdcmd2st
$LN25@shrdcmd2st:

; 1647 :         case SHRD_ERROR_NOTINIT:    return "NOTINIT ";

  00123	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169836
  0012a	eb 3d		 jmp	 SHORT $LN1@shrdcmd2st
$LN26@shrdcmd2st:

; 1648 :         case SHRD_ERROR_NOTCONN:    return "NOTCONN ";

  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169838
  00133	eb 34		 jmp	 SHORT $LN1@shrdcmd2st
$LN27@shrdcmd2st:

; 1649 :         case SHRD_ERROR_NOTAVAIL:   return "NOTAVAIL";

  00135	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169840
  0013c	eb 2b		 jmp	 SHORT $LN1@shrdcmd2st
$LN28@shrdcmd2st:

; 1650 :         case SHRD_ERROR_NOMEM:      return "NOMEM   ";

  0013e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169842
  00145	eb 22		 jmp	 SHORT $LN1@shrdcmd2st
$LN29@shrdcmd2st:

; 1651 :         case SHRD_ERROR_NOTACTIVE:  return "NOTACTIV";

  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169844
  0014e	eb 19		 jmp	 SHORT $LN1@shrdcmd2st
$LN30@shrdcmd2st:

; 1652 :         case SHRD_ERROR_NODEVICE:   return "NODEVICE";

  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169846
  00157	eb 10		 jmp	 SHORT $LN1@shrdcmd2st
$LN31@shrdcmd2st:

; 1653 :         case SHRD_ERROR_CONNECTED:  return "ECONNECT";

  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169848
  00160	eb 07		 jmp	 SHORT $LN1@shrdcmd2st
$LN32@shrdcmd2st:

; 1654 : 
; 1655 :         default:                    return "????????";

  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169850
$LN1@shrdcmd2st:

; 1656 :     }
; 1657 : }

  00169	48 83 c4 18	 add	 rsp, 24
  0016d	c3		 ret	 0
  0016e	66 90		 npad	 2
$LN35@shrdcmd2st:
  00170	00 00 00 00	 DD	 $LN17@shrdcmd2st
  00174	00 00 00 00	 DD	 $LN22@shrdcmd2st
  00178	00 00 00 00	 DD	 $LN21@shrdcmd2st
  0017c	00 00 00 00	 DD	 $LN20@shrdcmd2st
  00180	00 00 00 00	 DD	 $LN19@shrdcmd2st
  00184	00 00 00 00	 DD	 $LN18@shrdcmd2st
  00188	00 00 00 00	 DD	 $LN4@shrdcmd2st
  0018c	00 00 00 00	 DD	 $LN5@shrdcmd2st
  00190	00 00 00 00	 DD	 $LN6@shrdcmd2st
  00194	00 00 00 00	 DD	 $LN7@shrdcmd2st
  00198	00 00 00 00	 DD	 $LN8@shrdcmd2st
  0019c	00 00 00 00	 DD	 $LN9@shrdcmd2st
  001a0	00 00 00 00	 DD	 $LN10@shrdcmd2st
  001a4	00 00 00 00	 DD	 $LN11@shrdcmd2st
  001a8	00 00 00 00	 DD	 $LN12@shrdcmd2st
  001ac	00 00 00 00	 DD	 $LN13@shrdcmd2st
  001b0	00 00 00 00	 DD	 $LN14@shrdcmd2st
  001b4	00 00 00 00	 DD	 $LN15@shrdcmd2st
  001b8	00 00 00 00	 DD	 $LN16@shrdcmd2st
  001bc	00 00 00 00	 DD	 $LN23@shrdcmd2st
  001c0	00 00 00 00	 DD	 $LN24@shrdcmd2st
  001c4	00 00 00 00	 DD	 $LN25@shrdcmd2st
  001c8	00 00 00 00	 DD	 $LN26@shrdcmd2st
  001cc	00 00 00 00	 DD	 $LN27@shrdcmd2st
  001d0	00 00 00 00	 DD	 $LN28@shrdcmd2st
  001d4	00 00 00 00	 DD	 $LN29@shrdcmd2st
  001d8	00 00 00 00	 DD	 $LN30@shrdcmd2st
  001dc	00 00 00 00	 DD	 $LN31@shrdcmd2st
  001e0	00 00 00 00	 DD	 $LN32@shrdcmd2st
$LN34@shrdcmd2st:
  001e4	00		 DB	 0
  001e5	1c		 DB	 28
  001e6	1c		 DB	 28
  001e7	1c		 DB	 28
  001e8	1c		 DB	 28
  001e9	1c		 DB	 28
  001ea	1c		 DB	 28
  001eb	1c		 DB	 28
  001ec	01		 DB	 1
  001ed	1c		 DB	 28
  001ee	1c		 DB	 28
  001ef	1c		 DB	 28
  001f0	1c		 DB	 28
  001f1	1c		 DB	 28
  001f2	1c		 DB	 28
  001f3	1c		 DB	 28
  001f4	02		 DB	 2
  001f5	1c		 DB	 28
  001f6	1c		 DB	 28
  001f7	1c		 DB	 28
  001f8	1c		 DB	 28
  001f9	1c		 DB	 28
  001fa	1c		 DB	 28
  001fb	1c		 DB	 28
  001fc	1c		 DB	 28
  001fd	1c		 DB	 28
  001fe	1c		 DB	 28
  001ff	1c		 DB	 28
  00200	1c		 DB	 28
  00201	1c		 DB	 28
  00202	1c		 DB	 28
  00203	1c		 DB	 28
  00204	03		 DB	 3
  00205	1c		 DB	 28
  00206	1c		 DB	 28
  00207	1c		 DB	 28
  00208	1c		 DB	 28
  00209	1c		 DB	 28
  0020a	1c		 DB	 28
  0020b	1c		 DB	 28
  0020c	1c		 DB	 28
  0020d	1c		 DB	 28
  0020e	1c		 DB	 28
  0020f	1c		 DB	 28
  00210	1c		 DB	 28
  00211	1c		 DB	 28
  00212	1c		 DB	 28
  00213	1c		 DB	 28
  00214	1c		 DB	 28
  00215	1c		 DB	 28
  00216	1c		 DB	 28
  00217	1c		 DB	 28
  00218	1c		 DB	 28
  00219	1c		 DB	 28
  0021a	1c		 DB	 28
  0021b	1c		 DB	 28
  0021c	1c		 DB	 28
  0021d	1c		 DB	 28
  0021e	1c		 DB	 28
  0021f	1c		 DB	 28
  00220	1c		 DB	 28
  00221	1c		 DB	 28
  00222	1c		 DB	 28
  00223	1c		 DB	 28
  00224	04		 DB	 4
  00225	1c		 DB	 28
  00226	1c		 DB	 28
  00227	1c		 DB	 28
  00228	1c		 DB	 28
  00229	1c		 DB	 28
  0022a	1c		 DB	 28
  0022b	1c		 DB	 28
  0022c	1c		 DB	 28
  0022d	1c		 DB	 28
  0022e	1c		 DB	 28
  0022f	1c		 DB	 28
  00230	1c		 DB	 28
  00231	1c		 DB	 28
  00232	1c		 DB	 28
  00233	1c		 DB	 28
  00234	1c		 DB	 28
  00235	1c		 DB	 28
  00236	1c		 DB	 28
  00237	1c		 DB	 28
  00238	1c		 DB	 28
  00239	1c		 DB	 28
  0023a	1c		 DB	 28
  0023b	1c		 DB	 28
  0023c	1c		 DB	 28
  0023d	1c		 DB	 28
  0023e	1c		 DB	 28
  0023f	1c		 DB	 28
  00240	1c		 DB	 28
  00241	1c		 DB	 28
  00242	1c		 DB	 28
  00243	1c		 DB	 28
  00244	1c		 DB	 28
  00245	1c		 DB	 28
  00246	1c		 DB	 28
  00247	1c		 DB	 28
  00248	1c		 DB	 28
  00249	1c		 DB	 28
  0024a	1c		 DB	 28
  0024b	1c		 DB	 28
  0024c	1c		 DB	 28
  0024d	1c		 DB	 28
  0024e	1c		 DB	 28
  0024f	1c		 DB	 28
  00250	1c		 DB	 28
  00251	1c		 DB	 28
  00252	1c		 DB	 28
  00253	1c		 DB	 28
  00254	1c		 DB	 28
  00255	1c		 DB	 28
  00256	1c		 DB	 28
  00257	1c		 DB	 28
  00258	1c		 DB	 28
  00259	1c		 DB	 28
  0025a	1c		 DB	 28
  0025b	1c		 DB	 28
  0025c	1c		 DB	 28
  0025d	1c		 DB	 28
  0025e	1c		 DB	 28
  0025f	1c		 DB	 28
  00260	1c		 DB	 28
  00261	1c		 DB	 28
  00262	1c		 DB	 28
  00263	1c		 DB	 28
  00264	05		 DB	 5
  00265	1c		 DB	 28
  00266	1c		 DB	 28
  00267	1c		 DB	 28
  00268	1c		 DB	 28
  00269	1c		 DB	 28
  0026a	1c		 DB	 28
  0026b	1c		 DB	 28
  0026c	1c		 DB	 28
  0026d	1c		 DB	 28
  0026e	1c		 DB	 28
  0026f	1c		 DB	 28
  00270	1c		 DB	 28
  00271	1c		 DB	 28
  00272	1c		 DB	 28
  00273	1c		 DB	 28
  00274	1c		 DB	 28
  00275	1c		 DB	 28
  00276	1c		 DB	 28
  00277	1c		 DB	 28
  00278	1c		 DB	 28
  00279	1c		 DB	 28
  0027a	1c		 DB	 28
  0027b	1c		 DB	 28
  0027c	1c		 DB	 28
  0027d	1c		 DB	 28
  0027e	1c		 DB	 28
  0027f	1c		 DB	 28
  00280	1c		 DB	 28
  00281	1c		 DB	 28
  00282	1c		 DB	 28
  00283	1c		 DB	 28
  00284	1c		 DB	 28
  00285	1c		 DB	 28
  00286	1c		 DB	 28
  00287	1c		 DB	 28
  00288	1c		 DB	 28
  00289	1c		 DB	 28
  0028a	1c		 DB	 28
  0028b	1c		 DB	 28
  0028c	1c		 DB	 28
  0028d	1c		 DB	 28
  0028e	1c		 DB	 28
  0028f	1c		 DB	 28
  00290	1c		 DB	 28
  00291	1c		 DB	 28
  00292	1c		 DB	 28
  00293	1c		 DB	 28
  00294	1c		 DB	 28
  00295	1c		 DB	 28
  00296	1c		 DB	 28
  00297	1c		 DB	 28
  00298	1c		 DB	 28
  00299	1c		 DB	 28
  0029a	1c		 DB	 28
  0029b	1c		 DB	 28
  0029c	1c		 DB	 28
  0029d	1c		 DB	 28
  0029e	1c		 DB	 28
  0029f	1c		 DB	 28
  002a0	1c		 DB	 28
  002a1	1c		 DB	 28
  002a2	1c		 DB	 28
  002a3	1c		 DB	 28
  002a4	1c		 DB	 28
  002a5	1c		 DB	 28
  002a6	1c		 DB	 28
  002a7	1c		 DB	 28
  002a8	1c		 DB	 28
  002a9	1c		 DB	 28
  002aa	1c		 DB	 28
  002ab	1c		 DB	 28
  002ac	1c		 DB	 28
  002ad	1c		 DB	 28
  002ae	1c		 DB	 28
  002af	1c		 DB	 28
  002b0	1c		 DB	 28
  002b1	1c		 DB	 28
  002b2	1c		 DB	 28
  002b3	1c		 DB	 28
  002b4	1c		 DB	 28
  002b5	1c		 DB	 28
  002b6	1c		 DB	 28
  002b7	1c		 DB	 28
  002b8	1c		 DB	 28
  002b9	1c		 DB	 28
  002ba	1c		 DB	 28
  002bb	1c		 DB	 28
  002bc	1c		 DB	 28
  002bd	1c		 DB	 28
  002be	1c		 DB	 28
  002bf	1c		 DB	 28
  002c0	1c		 DB	 28
  002c1	1c		 DB	 28
  002c2	1c		 DB	 28
  002c3	1c		 DB	 28
  002c4	06		 DB	 6
  002c5	07		 DB	 7
  002c6	08		 DB	 8
  002c7	09		 DB	 9
  002c8	0a		 DB	 10
  002c9	0b		 DB	 11
  002ca	0c		 DB	 12
  002cb	0d		 DB	 13
  002cc	0e		 DB	 14
  002cd	0f		 DB	 15
  002ce	10		 DB	 16
  002cf	11		 DB	 17
  002d0	12		 DB	 18
  002d1	1c		 DB	 28
  002d2	1c		 DB	 28
  002d3	1c		 DB	 28
  002d4	13		 DB	 19
  002d5	14		 DB	 20
  002d6	15		 DB	 21
  002d7	16		 DB	 22
  002d8	17		 DB	 23
  002d9	18		 DB	 24
  002da	19		 DB	 25
  002db	1a		 DB	 26
  002dc	1b		 DB	 27
shrdcmd2str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tracing$ = 64
tv69 = 68
tv71 = 72
tv146 = 76
tv$ = 80
vl$ = 88
tv161 = 96
tv168 = 104
currmsg$1 = 112
buf$ = 120
tracemsg$ = 160
__$ArrayPad$ = 288
dev$ = 320
fmt$ = 328
shrdtrc	PROC

; 2663 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2664 :     bool            tracing;
; 2665 :     struct timeval  tv;
; 2666 :     SHRD_TRACE      tracemsg;
; 2667 :     va_list         vl;
; 2668 :     char            buf[32];
; 2669 : 
; 2670 :     /* If the device is being traced or stepped, we also print a
; 2671 :        trace message (WITHOUT a timestamp) directly to the panel.
; 2672 :        Otherwise we build a trace message WITH a timestamp prefix
; 2673 :        and enter it into out trace table if one exists. If neither
; 2674 :        is true (not tracing or stepping AND no trace table) then
; 2675 :        there's nothing for us to do so we return immediately.
; 2676 :     */
; 2677 :     tracing = (dev && dev->ccwtrace);

  0002d	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00036	74 22		 je	 SHORT $LN16@shrdtrc
  00038	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00046	c1 e8 0f	 shr	 eax, 15
  00049	83 e0 01	 and	 eax, 1
  0004c	85 c0		 test	 eax, eax
  0004e	74 0a		 je	 SHORT $LN16@shrdtrc
  00050	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00058	eb 08		 jmp	 SHORT $LN17@shrdtrc
$LN16@shrdtrc:
  0005a	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN17@shrdtrc:
  00062	83 7c 24 44 00	 cmp	 DWORD PTR tv69[rsp], 0
  00067	75 0a		 jne	 SHORT $LN18@shrdtrc
  00069	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00071	eb 08		 jmp	 SHORT $LN19@shrdtrc
$LN18@shrdtrc:
  00073	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN19@shrdtrc:
  0007b	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv71[rsp]
  00080	88 44 24 40	 mov	 BYTE PTR tracing$[rsp], al

; 2678 : 
; 2679 :     OBTAIN_SHRDTRACE_LOCK();

  00084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008b	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170518
  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2680 : 
; 2681 :     if (!tracing && !sysblk.shrdtrace)

  000a1	0f b6 44 24 40	 movzx	 eax, BYTE PTR tracing$[rsp]
  000a6	85 c0		 test	 eax, eax
  000a8	75 33		 jne	 SHORT $LN8@shrdtrc
  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b1	48 83 b8 c0 13
	00 00 00	 cmp	 QWORD PTR [rax+5056], 0
  000b9	75 22		 jne	 SHORT $LN8@shrdtrc

; 2682 :     {
; 2683 :         RELEASE_SHRDTRACE_LOCK();

  000bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c2	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170520
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2684 :         return;  // (nothing for us to do!)

  000d8	e9 96 02 00 00	 jmp	 $LN1@shrdtrc
$LN8@shrdtrc:
$LN4@shrdtrc:

; 2685 :     }
; 2686 : 
; 2687 :     ASSERT( tracing || sysblk.shrdtrace );

  000dd	0f b6 44 24 40	 movzx	 eax, BYTE PTR tracing$[rsp]
  000e2	85 c0		 test	 eax, eax
  000e4	75 6d		 jne	 SHORT $LN9@shrdtrc
  000e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ed	48 83 b8 c0 13
	00 00 00	 cmp	 QWORD PTR [rax+5056], 0
  000f5	75 5c		 jne	 SHORT $LN9@shrdtrc
$LN7@shrdtrc:
  000f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170522
  000fe	41 b8 7f 0a 00
	00		 mov	 r8d, 2687		; 00000a7fH
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170523
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170524
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0011e	85 c0		 test	 eax, eax
  00120	74 20		 je	 SHORT $LN10@shrdtrc
  00122	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170526
  00129	41 b8 7f 0a 00
	00		 mov	 r8d, 2687		; 00000a7fH
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170527
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170528
  0013d	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@shrdtrc:
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 af		 jne	 SHORT $LN7@shrdtrc
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0014e	85 c0		 test	 eax, eax
  00150	74 01		 je	 SHORT $LN11@shrdtrc
  00152	cc		 int	 3
$LN11@shrdtrc:
$LN9@shrdtrc:
  00153	33 c0		 xor	 eax, eax
  00155	85 c0		 test	 eax, eax
  00157	75 84		 jne	 SHORT $LN4@shrdtrc

; 2688 : 
; 2689 :     /* Build the timestamp portion of the trace message */
; 2690 :     gettimeofday( &tv, NULL );

  00159	33 d2		 xor	 edx, edx
  0015b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 2691 :     FormatTIMEVAL( &tv, buf, sizeof( buf ));

  00166	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0016c	48 8d 54 24 78	 lea	 rdx, QWORD PTR buf$[rsp]
  00171	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatTIMEVAL

; 2692 :     STRLCPY( tracemsg, buf + 11 ); // (skip "YYYY-MM-DD ")

  0017c	48 8d 84 24 83
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+11]
  00184	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0018a	48 8b d0	 mov	 rdx, rax
  0018d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR tracemsg$[rsp]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2693 : 
; 2694 :     /* Append the devnum to the trace message */
; 2695 :     MSGBUF( buf, "  %4.4X  ", dev ? dev->devnum : 0 );

  0019b	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001a4	74 12		 je	 SHORT $LN20@shrdtrc
  001a6	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ae	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b2	89 44 24 4c	 mov	 DWORD PTR tv146[rsp], eax
  001b6	eb 08		 jmp	 SHORT $LN21@shrdtrc
$LN20@shrdtrc:
  001b8	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN21@shrdtrc:
  001c0	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR tv146[rsp]
  001c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170530
  001cc	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001d1	48 8d 4c 24 78	 lea	 rcx, QWORD PTR buf$[rsp]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2696 :     STRLCAT( tracemsg, buf );

  001dc	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  001e2	48 8d 54 24 78	 lea	 rdx, QWORD PTR buf$[rsp]
  001e7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR tracemsg$[rsp]
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2697 : 
; 2698 :     /* Now format the rest of the trace message following that part */
; 2699 :     va_start( vl, fmt );

  001f5	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  001fd	48 89 44 24 58	 mov	 QWORD PTR vl$[rsp], rax

; 2700 :     vsnprintf( (char*) tracemsg + strlen( tracemsg ),

  00202	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR tracemsg$[rsp]
  0020a	e8 00 00 00 00	 call	 strlen
  0020f	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00214	48 2b c8	 sub	 rcx, rax
  00217	48 8b c1	 mov	 rax, rcx
  0021a	48 89 44 24 60	 mov	 QWORD PTR tv161[rsp], rax
  0021f	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR tracemsg$[rsp]
  00227	e8 00 00 00 00	 call	 strlen
  0022c	48 8d 84 04 a0
	00 00 00	 lea	 rax, QWORD PTR tracemsg$[rsp+rax]
  00234	4c 8b 4c 24 58	 mov	 r9, QWORD PTR vl$[rsp]
  00239	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  00241	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv161[rsp]
  00246	48 8b d1	 mov	 rdx, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf

; 2701 :         sizeof( tracemsg ) - strlen( tracemsg ), fmt, vl );
; 2702 : 
; 2703 :     /* Log the trace message directly to the panel (WITHOUT the
; 2704 :        timestamp prefix) if the device is being traced/stepped. */
; 2705 :     if (tracing)

  00252	0f b6 44 24 40	 movzx	 eax, BYTE PTR tracing$[rsp]
  00257	85 c0		 test	 eax, eax
  00259	74 5e		 je	 SHORT $LN12@shrdtrc

; 2706 :         // "Shared:  %s"
; 2707 :         WRMSG( HHC00743, "I", tracemsg + 16 ); // (skip "HH:MM:SS.uuuuuu ")

  0025b	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR tracemsg$[rsp+16]
  00263	48 89 44 24 68	 mov	 QWORD PTR tv168[rsp], rax
  00268	b9 01 00 00 00	 mov	 ecx, 1
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00273	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv168[rsp]
  00278	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170532
  00284	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170533
  00290	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00295	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029a	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170534
  002a7	ba 93 0a 00 00	 mov	 edx, 2707		; 00000a93H
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170535
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@shrdtrc:

; 2708 : 
; 2709 :     /* Copy the trace message into the trace table (if it exists) */
; 2710 :     if (sysblk.shrdtrace)

  002b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c0	48 83 b8 c0 13
	00 00 00	 cmp	 QWORD PTR [rax+5056], 0
  002c8	0f 84 88 00 00
	00		 je	 $LN13@shrdtrc

; 2711 :     {
; 2712 :         /* Grab pointer to next available table entry and then
; 2713 :            bump the pointer to the next entry for next time.
; 2714 :         */
; 2715 :         SHRD_TRACE* currmsg = sysblk.shrdtracep++;

  002ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d5	48 8b 80 c8 13
	00 00		 mov	 rax, QWORD PTR [rax+5064]
  002dc	48 89 44 24 70	 mov	 QWORD PTR currmsg$1[rsp], rax
  002e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e8	48 8b 80 c8 13
	00 00		 mov	 rax, QWORD PTR [rax+5064]
  002ef	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  002f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002fc	48 89 81 c8 13
	00 00		 mov	 QWORD PTR [rcx+5064], rax

; 2716 : 
; 2717 :         if (sysblk.shrdtracep >= sysblk.shrdtracex)

  00303	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0030a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00311	48 8b 89 d0 13
	00 00		 mov	 rcx, QWORD PTR [rcx+5072]
  00318	48 39 88 c8 13
	00 00		 cmp	 QWORD PTR [rax+5064], rcx
  0031f	72 1c		 jb	 SHORT $LN14@shrdtrc

; 2718 :             sysblk.shrdtracep  = sysblk.shrdtrace;

  00321	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00328	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0032f	48 8b 89 c0 13
	00 00		 mov	 rcx, QWORD PTR [rcx+5056]
  00336	48 89 88 c8 13
	00 00		 mov	 QWORD PTR [rax+5064], rcx
$LN14@shrdtrc:

; 2719 : 
; 2720 :         /* Copy message (WITH timestamp) into trace table */
; 2721 :         strlcpy( (char*) currmsg, (const char*) tracemsg, sizeof( SHRD_TRACE ));

  0033d	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00343	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR tracemsg$[rsp]
  0034b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR currmsg$1[rsp]
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN13@shrdtrc:

; 2722 :     }
; 2723 : 
; 2724 :     RELEASE_SHRDTRACE_LOCK();

  00356	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035d	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170538
  0036a	48 8b c8	 mov	 rcx, rax
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@shrdtrc:

; 2725 : }

  00373	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037b	48 33 cc	 xor	 rcx, rsp
  0037e	e8 00 00 00 00	 call	 __security_check_cookie
  00383	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  0038a	c3		 ret	 0
shrdtrc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
cmd$ = 96
code$ = 97
devnum$ = 100
shdr$1 = 104
len$ = 112
id$ = 116
tv129 = 120
tv131 = 124
tv133 = 128
tv90 = 136
tv93 = 144
buf$ = 152
dev$ = 176
msg$ = 184
hdr$ = 192
msg2$ = 200
shrdhdrtrc PROC

; 2650 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@shrdhdrtrc:

; 2651 :     BYTE cmd, code; U16 devnum; int id, len; char buf[4];
; 2652 :     SHRD_GET_HDR( hdr, cmd, code, devnum, id, len );

  0001b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00023	48 89 44 24 68	 mov	 QWORD PTR shdr$1[rsp], rax
  00028	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00030	88 44 24 60	 mov	 BYTE PTR cmd$[rsp], al
  00034	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00039	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0003d	88 44 24 61	 mov	 BYTE PTR code$[rsp], al
  00041	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00046	48 83 c0 02	 add	 rax, 2
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00052	0f b7 c8	 movzx	 ecx, ax
  00055	e8 00 00 00 00	 call	 _byteswap_ushort
  0005a	66 89 44 24 64	 mov	 WORD PTR devnum$[rsp], ax
  0005f	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00064	48 83 c0 04	 add	 rax, 4
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00070	0f b7 c8	 movzx	 ecx, ax
  00073	e8 00 00 00 00	 call	 _byteswap_ushort
  00078	0f b7 c0	 movzx	 eax, ax
  0007b	89 44 24 70	 mov	 DWORD PTR len$[rsp], eax
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00084	48 83 c0 06	 add	 rax, 6
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00090	0f b7 c8	 movzx	 ecx, ax
  00093	e8 00 00 00 00	 call	 _byteswap_ushort
  00098	0f b7 c0	 movzx	 eax, ax
  0009b	89 44 24 74	 mov	 DWORD PTR id$[rsp], eax
  0009f	33 c0		 xor	 eax, eax
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 72 ff ff
	ff		 jne	 $LN4@shrdhdrtrc

; 2653 :     MSGBUF( buf, "%2.2x", cmd );

  000a9	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmd$[rsp]
  000ae	44 8b c8	 mov	 r9d, eax
  000b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170490
  000b8	ba 04 00 00 00	 mov	 edx, 4
  000bd	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2654 :     SHRDTRACE( "%-18s : %s(%2.2x) %2.2x dev %4.4x id %d len %d%s%s",

  000cb	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR msg2$[rsp], 0
  000d4	74 12		 je	 SHORT $LN6@shrdhdrtrc
  000d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR msg2$[rsp]
  000de	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000e6	eb 0f		 jmp	 SHORT $LN7@shrdhdrtrc
$LN6@shrdhdrtrc:
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170491
  000ef	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN7@shrdhdrtrc:
  000f7	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR msg2$[rsp], 0
  00100	74 11		 je	 SHORT $LN8@shrdhdrtrc
  00102	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170492
  00109	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
  00111	eb 0f		 jmp	 SHORT $LN9@shrdhdrtrc
$LN8@shrdhdrtrc:
  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170493
  0011a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
$LN9@shrdhdrtrc:
  00122	0f b7 44 24 64	 movzx	 eax, WORD PTR devnum$[rsp]
  00127	89 44 24 78	 mov	 DWORD PTR tv129[rsp], eax
  0012b	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR code$[rsp]
  00130	89 4c 24 7c	 mov	 DWORD PTR tv131[rsp], ecx
  00134	0f b6 54 24 60	 movzx	 edx, BYTE PTR cmd$[rsp]
  00139	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv133[rsp], edx
  00140	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR cmd$[rsp]
  00145	e8 00 00 00 00	 call	 shrdcmd2str
  0014a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  00152	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00157	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv93[rsp]
  0015f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00164	8b 4c 24 70	 mov	 ecx, DWORD PTR len$[rsp]
  00168	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0016c	8b 4c 24 74	 mov	 ecx, DWORD PTR id$[rsp]
  00170	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00174	8b 4c 24 78	 mov	 ecx, DWORD PTR tv129[rsp]
  00178	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0017c	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv131[rsp]
  00180	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00184	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  0018b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0018f	4c 8b c8	 mov	 r9, rax
  00192	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR msg$[rsp]
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170494
  001a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a9	e8 00 00 00 00	 call	 shrdtrc

; 2655 :         msg, shrdcmd2str( cmd ), cmd, code, devnum, id, len,
; 2656 :         msg2 ? " " : "", msg2 ? msg2 : "" );
; 2657 : }

  001ae	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001b5	c3		 ret	 0
shrdhdrtrc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
ix$ = 96
dev$ = 104
cmd$ = 112
csock$ = 116
rc$ = 120
flag$ = 124
id$ = 128
devnum$ = 132
maxfd$ = 136
tv310 = 140
tv316 = 144
tv338 = 148
tv344 = 152
tv689 = 156
tv695 = 160
shdr$1 = 168
shdr$2 = 176
ipaddr$ = 184
tv793 = 192
len$ = 196
tv352 = 200
tv357 = 204
tv788 = 208
buf$ = 216
tv203 = 224
wait$ = 232
now$ = 240
tv515 = 248
tv815 = 256
tv814 = 264
selset$ = 272
threadname$ = 8480
hdr$ = 8496
__$ArrayPad$ = 74048
psock$ = 74080
serverConnect PROC

; 2352 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	b8 50 21 01 00	 mov	 eax, 74064		; 00012150H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	48 2b e0	 sub	 rsp, rax
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 40
	21 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2353 : int             csock;                  /* Connection socket         */
; 2354 : int             rc;                     /* Return code               */
; 2355 : BYTE            cmd;                    /* Request command           */
; 2356 : BYTE            flag;                   /* Request flag              */
; 2357 : U16             devnum;                 /* Request device number     */
; 2358 : int             id;                     /* Request id                */
; 2359 : int             len;                    /* Request data length       */
; 2360 : int             ix;                     /* Client index              */
; 2361 : DEVBLK         *dev=NULL;               /* -> Device block           */

  00025	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 2362 : time_t          now;                    /* Current time              */
; 2363 : fd_set          selset;                 /* Read bit map for select   */
; 2364 : int             maxfd;                  /* Max fd for select         */
; 2365 : struct timeval  wait;                   /* Wait time for select      */
; 2366 : BYTE            hdr[SHRD_HDR_SIZE + 65536];  /* Header + buffer      */
; 2367 : BYTE           *buf = hdr + SHRD_HDR_SIZE;   /* Buffer               */

  0002e	48 8d 84 24 38
	21 00 00	 lea	 rax, QWORD PTR hdr$[rsp+8]
  00036	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 2368 : char           *ipaddr = NULL;          /* IP addr of connected peer */

  0003e	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ipaddr$[rsp], 0

; 2369 : char            threadname[16] = {0};

  0004a	48 8d 84 24 20
	21 00 00	 lea	 rax, QWORD PTR threadname$[rsp]
  00052	48 8b f8	 mov	 rdi, rax
  00055	33 c0		 xor	 eax, eax
  00057	b9 10 00 00 00	 mov	 ecx, 16
  0005c	f3 aa		 rep stosb

; 2370 : 
; 2371 :     // We are (or will be) the "dev->shrdtid" thread...
; 2372 : 
; 2373 :     csock = *(int*)psock;

  0005e	48 8b 84 24 60
	21 01 00	 mov	 rax, QWORD PTR psock$[rsp]
  00066	8b 00		 mov	 eax, DWORD PTR [rax]
  00068	89 44 24 74	 mov	 DWORD PTR csock$[rsp], eax

; 2374 :     free( psock );

  0006c	48 8b 8c 24 60
	21 01 00	 mov	 rcx, QWORD PTR psock$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2375 :     ipaddr = clientip( csock );

  0007a	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  0007e	e8 00 00 00 00	 call	 clientip
  00083	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ipaddr$[rsp], rax

; 2376 : 
; 2377 :     SHRDTRACE( "server connect %s sock %d", ipaddr, csock );

  0008b	44 8b 4c 24 74	 mov	 r9d, DWORD PTR csock$[rsp]
  00090	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR ipaddr$[rsp]
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170385
  0009f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  000a4	e8 00 00 00 00	 call	 shrdtrc

; 2378 : 
; 2379 :     rc = recvData( csock, hdr, buf, 65536, 1 );

  000a9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000b1	41 b9 00 00 01
	00		 mov	 r9d, 65536		; 00010000H
  000b7	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000bf	48 8d 94 24 30
	21 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  000c7	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  000cb	e8 00 00 00 00	 call	 recvData
  000d0	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 2380 :     if (rc < 0)

  000d4	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d9	7d 65		 jge	 SHORT $LN16@serverConn

; 2381 :     {
; 2382 :         // "Shared: connect to IP %s failed"
; 2383 :         WRMSG( HHC00732, "E", ipaddr );

  000db	b9 01 00 00 00	 mov	 ecx, 1
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ipaddr$[rsp]
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170387
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170388
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170389
  0011d	ba 4f 09 00 00	 mov	 edx, 2383		; 0000094fH
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170390
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2384 :         close_socket( csock );

  0012f	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2385 :         return NULL;

  00139	33 c0		 xor	 eax, eax
  0013b	e9 e7 0f 00 00	 jmp	 $LN1@serverConn
$LN16@serverConn:
$LN4@serverConn:

; 2386 :     }
; 2387 : 
; 2388 :     SHRD_GET_HDR( hdr, cmd, flag, devnum, id, len );

  00140	48 8d 84 24 30
	21 00 00	 lea	 rax, QWORD PTR hdr$[rsp]
  00148	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR shdr$1[rsp], rax
  00150	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00158	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0015b	88 44 24 70	 mov	 BYTE PTR cmd$[rsp], al
  0015f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00167	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0016b	88 44 24 7c	 mov	 BYTE PTR flag$[rsp], al
  0016f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00177	48 83 c0 02	 add	 rax, 2
  0017b	48 8b c8	 mov	 rcx, rax
  0017e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00183	0f b7 c8	 movzx	 ecx, ax
  00186	e8 00 00 00 00	 call	 _byteswap_ushort
  0018b	66 89 84 24 84
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  00193	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  0019b	48 83 c0 04	 add	 rax, 4
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	e8 00 00 00 00	 call	 fetch_hw_noswap
  001a7	0f b7 c8	 movzx	 ecx, ax
  001aa	e8 00 00 00 00	 call	 _byteswap_ushort
  001af	0f b7 c0	 movzx	 eax, ax
  001b2	89 84 24 c4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  001b9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  001c1	48 83 c0 06	 add	 rax, 6
  001c5	48 8b c8	 mov	 rcx, rax
  001c8	e8 00 00 00 00	 call	 fetch_hw_noswap
  001cd	0f b7 c8	 movzx	 ecx, ax
  001d0	e8 00 00 00 00	 call	 _byteswap_ushort
  001d5	0f b7 c0	 movzx	 eax, ax
  001d8	89 84 24 80 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	0f 85 57 ff ff
	ff		 jne	 $LN4@serverConn

; 2389 : 
; 2390 :     /* Error if not a connect request */
; 2391 :     if (id == 0 && cmd != SHRD_CONNECT)

  001e9	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR id$[rsp], 0
  001f1	75 46		 jne	 SHORT $LN17@serverConn
  001f3	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  001f8	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  001fd	74 3a		 je	 SHORT $LN17@serverConn

; 2392 :     {
; 2393 :         serverError( NULL, -csock, SHRD_ERROR_NOTCONN, cmd,

  001ff	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  00204	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  00208	f7 d9		 neg	 ecx
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170392
  00211	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00216	44 8b c8	 mov	 r9d, eax
  00219	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  0021f	8b d1		 mov	 edx, ecx
  00221	33 c9		 xor	 ecx, ecx
  00223	e8 00 00 00 00	 call	 serverError

; 2394 :                      "not a connect request" );
; 2395 :         close_socket( csock );

  00228	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2396 :         return NULL;

  00232	33 c0		 xor	 eax, eax
  00234	e9 ee 0e 00 00	 jmp	 $LN1@serverConn
$LN17@serverConn:

; 2397 :     }
; 2398 : 
; 2399 :     /* Locate the device */
; 2400 :     if (!(dev = findDevice( devnum )))

  00239	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  00241	e8 00 00 00 00	 call	 findDevice
  00246	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax
  0024b	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00251	75 3a		 jne	 SHORT $LN18@serverConn

; 2401 :     {
; 2402 :         serverError( NULL, -csock, SHRD_ERROR_NODEVICE, cmd,

  00253	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  00258	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  0025c	f7 d9		 neg	 ecx
  0025e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170394
  00265	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0026a	44 8b c8	 mov	 r9d, eax
  0026d	41 b8 f7 00 00
	00		 mov	 r8d, 247		; 000000f7H
  00273	8b d1		 mov	 edx, ecx
  00275	33 c9		 xor	 ecx, ecx
  00277	e8 00 00 00 00	 call	 serverError

; 2403 :                      "device not found" );
; 2404 :         close_socket( csock );

  0027c	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2405 :         return NULL;

  00286	33 c0		 xor	 eax, eax
  00288	e9 9a 0e 00 00	 jmp	 $LN1@serverConn
$LN18@serverConn:

; 2406 :     }
; 2407 : 
; 2408 :     /* Obtain the device lock */
; 2409 :     obtain_lock( &dev->lock );

  0028d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00292	48 83 c0 38	 add	 rax, 56			; 00000038H
  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170395
  0029d	48 8b c8	 mov	 rcx, rax
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2410 : 
; 2411 :     /* Find an available slot for the connection */
; 2412 :     if ((rc = serverLocate( dev, id, &ix )) >= 0)

  002a6	4c 8d 44 24 60	 lea	 r8, QWORD PTR ix$[rsp]
  002ab	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR id$[rsp]
  002b2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  002b7	e8 00 00 00 00	 call	 serverLocate
  002bc	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax
  002c0	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  002c5	7c 53		 jl	 SHORT $LN19@serverConn

; 2413 :     {
; 2414 :         release_lock( &dev->lock );

  002c7	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  002cc	48 83 c0 38	 add	 rax, 56			; 00000038H
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170397
  002d7	48 8b c8	 mov	 rcx, rax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2415 :         serverError( NULL, -csock, SHRD_ERROR_NODEVICE, cmd,

  002e0	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  002e5	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  002e9	f7 d9		 neg	 ecx
  002eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170398
  002f2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002f7	44 8b c8	 mov	 r9d, eax
  002fa	41 b8 f7 00 00
	00		 mov	 r8d, 247		; 000000f7H
  00300	8b d1		 mov	 edx, ecx
  00302	33 c9		 xor	 ecx, ecx
  00304	e8 00 00 00 00	 call	 serverError

; 2416 :                      "already connected" );
; 2417 :         close_socket( csock );

  00309	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2418 :         return NULL;

  00313	33 c0		 xor	 eax, eax
  00315	e9 0d 0e 00 00	 jmp	 $LN1@serverConn
$LN19@serverConn:

; 2419 :     }
; 2420 : 
; 2421 :     /* Error if no available slot */
; 2422 :     if (ix < 0)

  0031a	83 7c 24 60 00	 cmp	 DWORD PTR ix$[rsp], 0
  0031f	7d 53		 jge	 SHORT $LN20@serverConn

; 2423 :     {
; 2424 :         release_lock( &dev->lock );

  00321	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00326	48 83 c0 38	 add	 rax, 56			; 00000038H
  0032a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170400
  00331	48 8b c8	 mov	 rcx, rax
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2425 :         serverError( NULL, -csock, SHRD_ERROR_NOTAVAIL, cmd,

  0033a	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  0033f	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  00343	f7 d9		 neg	 ecx
  00345	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170401
  0034c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00351	44 8b c8	 mov	 r9d, eax
  00354	41 b8 f4 00 00
	00		 mov	 r8d, 244		; 000000f4H
  0035a	8b d1		 mov	 edx, ecx
  0035c	33 c9		 xor	 ecx, ecx
  0035e	e8 00 00 00 00	 call	 serverError

; 2426 :                      "too many connections" );
; 2427 :         close_socket( csock );

  00363	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  00367	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2428 :         return NULL;

  0036d	33 c0		 xor	 eax, eax
  0036f	e9 b3 0d 00 00	 jmp	 $LN1@serverConn
$LN20@serverConn:

; 2429 :     }
; 2430 : 
; 2431 :     /* Obtain SHRD block */
; 2432 :     if (!(dev->shrd[ix] = calloc( sizeof( SHRD ), 1 )))

  00374	ba 01 00 00 00	 mov	 edx, 1
  00379	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00384	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
  0038c	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00391	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00396	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv203[rsp]
  0039e	48 89 94 c1 60
	06 00 00	 mov	 QWORD PTR [rcx+rax*8+1632], rdx
  003a6	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR tv203[rsp], 0
  003af	75 53		 jne	 SHORT $LN21@serverConn

; 2433 :     {
; 2434 :         release_lock( &dev->lock );

  003b1	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  003b6	48 83 c0 38	 add	 rax, 56			; 00000038H
  003ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170403
  003c1	48 8b c8	 mov	 rcx, rax
  003c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2435 :         serverError( NULL, -csock, SHRD_ERROR_NOMEM, cmd,

  003ca	0f b6 44 24 70	 movzx	 eax, BYTE PTR cmd$[rsp]
  003cf	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  003d3	f7 d9		 neg	 ecx
  003d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170404
  003dc	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003e1	44 8b c8	 mov	 r9d, eax
  003e4	41 b8 f5 00 00
	00		 mov	 r8d, 245		; 000000f5H
  003ea	8b d1		 mov	 edx, ecx
  003ec	33 c9		 xor	 ecx, ecx
  003ee	e8 00 00 00 00	 call	 serverError

; 2436 :                      "calloc() failure" );
; 2437 :         close_socket( csock );

  003f3	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2438 :         return NULL;

  003fd	33 c0		 xor	 eax, eax
  003ff	e9 23 0d 00 00	 jmp	 $LN1@serverConn
$LN21@serverConn:

; 2439 :     }
; 2440 : 
; 2441 :     /* Initialize the SHRD block */
; 2442 :     dev->shrd[ix]->pending = 1;

  00404	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00409	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0040e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00416	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00419	83 c8 01	 or	 eax, 1
  0041c	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00421	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00426	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  0042e	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2443 :     dev->shrd[ix]->havehdr = 1;

  00431	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00436	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0043b	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00443	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00446	83 c8 04	 or	 eax, 4
  00449	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0044e	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00453	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  0045b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2444 :     if (id == 0) id = serverId( dev );

  0045e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR id$[rsp], 0
  00466	75 11		 jne	 SHORT $LN22@serverConn
  00468	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0046d	e8 00 00 00 00	 call	 serverId
  00472	89 84 24 80 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
$LN22@serverConn:

; 2445 :     dev->shrd[ix]->id      = id;

  00479	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  0047e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00483	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0048b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR id$[rsp]
  00492	89 08		 mov	 DWORD PTR [rax], ecx

; 2446 :     dev->shrd[ix]->fd      = csock;

  00494	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00499	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0049e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  004a6	8b 4c 24 74	 mov	 ecx, DWORD PTR csock$[rsp]
  004aa	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 2447 :     dev->shrd[ix]->ipaddr  = strdup(ipaddr);

  004ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ipaddr$[rsp]
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  004bb	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  004c0	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  004c5	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  004cd	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2448 :     dev->shrd[ix]->time    = time (NULL);

  004d1	33 c9		 xor	 ecx, ecx
  004d3	e8 00 00 00 00	 call	 time
  004d8	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  004dd	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  004e2	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  004ea	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2449 :     dev->shrd[ix]->purgen  = -1;

  004ee	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  004f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  004f8	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00500	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [rax+48], -1

; 2450 :     dev->shrdconn++;

  00507	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0050c	8b 80 58 06 00
	00		 mov	 eax, DWORD PTR [rax+1624]
  00512	ff c0		 inc	 eax
  00514	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00519	89 81 58 06 00
	00		 mov	 DWORD PTR [rcx+1624], eax
$LN7@serverConn:

; 2451 :     SHRD_SET_HDR( dev->shrd[ix]->hdr, cmd, flag, devnum, id, len );

  0051f	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00524	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00529	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00531	48 83 c0 28	 add	 rax, 40			; 00000028H
  00535	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR shdr$2[rsp], rax
  0053d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00545	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR cmd$[rsp]
  0054a	88 08		 mov	 BYTE PTR [rax], cl
  0054c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00554	0f b6 4c 24 7c	 movzx	 ecx, BYTE PTR flag$[rsp]
  00559	88 48 01	 mov	 BYTE PTR [rax+1], cl
  0055c	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  00564	e8 00 00 00 00	 call	 _byteswap_ushort
  00569	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00571	48 83 c1 02	 add	 rcx, 2
  00575	0f b7 d0	 movzx	 edx, ax
  00578	e8 00 00 00 00	 call	 store_hw_noswap
  0057d	0f b7 8c 24 c4
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  00585	e8 00 00 00 00	 call	 _byteswap_ushort
  0058a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00592	48 83 c1 04	 add	 rcx, 4
  00596	0f b7 d0	 movzx	 edx, ax
  00599	e8 00 00 00 00	 call	 store_hw_noswap
  0059e	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR id$[rsp]
  005a6	e8 00 00 00 00	 call	 _byteswap_ushort
  005ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  005b3	48 83 c1 06	 add	 rcx, 6
  005b7	0f b7 d0	 movzx	 edx, ax
  005ba	e8 00 00 00 00	 call	 store_hw_noswap
  005bf	33 c0		 xor	 eax, eax
  005c1	85 c0		 test	 eax, eax
  005c3	0f 85 56 ff ff
	ff		 jne	 $LN7@serverConn

; 2452 : 
; 2453 :     if (MLVL( VERBOSE ))

  005c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d0	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  005d6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  005db	85 c0		 test	 eax, eax
  005dd	0f 84 c1 00 00
	00		 je	 $LN23@serverConn

; 2454 :         // "%1d:%04X Shared: %s connected id %d"
; 2455 :         WRMSG( HHC00733, "I", LCSS_DEVNUM, ipaddr, id );

  005e3	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005e9	74 12		 je	 SHORT $LN49@serverConn
  005eb	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  005f0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005f4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
  005fb	eb 0b		 jmp	 SHORT $LN50@serverConn
$LN49@serverConn:
  005fd	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv310[rsp], 0
$LN50@serverConn:
  00608	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0060e	74 14		 je	 SHORT $LN51@serverConn
  00610	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00615	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00619	d1 f8		 sar	 eax, 1
  0061b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv316[rsp], eax
  00622	eb 0b		 jmp	 SHORT $LN52@serverConn
$LN51@serverConn:
  00624	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv316[rsp], 0
$LN52@serverConn:
  0062f	b9 01 00 00 00	 mov	 ecx, 1
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR id$[rsp]
  00641	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00645	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ipaddr$[rsp]
  0064d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00652	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv310[rsp]
  00659	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0065d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv316[rsp]
  00664	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00668	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170407
  0066f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00674	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170408
  0067b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00680	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00685	41 b9 03 00 00
	00		 mov	 r9d, 3
  0068b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170409
  00692	ba 97 09 00 00	 mov	 edx, 2455		; 00000997H
  00697	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170410
  0069e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@serverConn:

; 2456 : 
; 2457 :     /* Return if device thread already active */
; 2458 :     if (dev->shrdtid)

  006a4	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  006a9	83 b8 50 06 00
	00 00		 cmp	 DWORD PTR [rax+1616], 0
  006b0	74 20		 je	 SHORT $LN24@serverConn

; 2459 :     {
; 2460 :         release_lock( &dev->lock );

  006b2	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  006b7	48 83 c0 38	 add	 rax, 56			; 00000038H
  006bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170412
  006c2	48 8b c8	 mov	 rcx, rax
  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2461 :         return NULL;

  006cb	33 c0		 xor	 eax, eax
  006cd	e9 55 0a 00 00	 jmp	 $LN1@serverConn
$LN24@serverConn:

; 2462 :     }
; 2463 : 
; 2464 :     /* This thread will be the shared device thread (dev->shrdtid) */
; 2465 : 
; 2466 :     dev->shrdtid = thread_id();

  006d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  006d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  006dd	89 81 50 06 00
	00		 mov	 DWORD PTR [rcx+1616], eax

; 2467 : 
; 2468 :     MSGBUF( threadname, "shrd dev %1d:%04X", LCSS_DEVNUM );

  006e3	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006e9	74 12		 je	 SHORT $LN53@serverConn
  006eb	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  006f0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006f4	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv338[rsp], eax
  006fb	eb 0b		 jmp	 SHORT $LN54@serverConn
$LN53@serverConn:
  006fd	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv338[rsp], 0
$LN54@serverConn:
  00708	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0070e	74 14		 je	 SHORT $LN55@serverConn
  00710	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00715	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00719	d1 f8		 sar	 eax, 1
  0071b	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv344[rsp], eax
  00722	eb 0b		 jmp	 SHORT $LN56@serverConn
$LN55@serverConn:
  00724	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv344[rsp], 0
$LN56@serverConn:
  0072f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv338[rsp]
  00736	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0073a	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR tv344[rsp]
  00742	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170413
  00749	ba 10 00 00 00	 mov	 edx, 16
  0074e	48 8d 8c 24 20
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00756	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2469 :     if (MLVL( VERBOSE ))

  0075c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00763	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00769	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0076e	85 c0		 test	 eax, eax
  00770	0f 84 93 00 00
	00		 je	 $LN25@serverConn

; 2470 :         LOG_THREAD_BEGIN( threadname  );

  00776	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0077c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170415
  00783	8b c8		 mov	 ecx, eax
  00785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0078b	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv352[rsp], eax
  00792	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00798	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv357[rsp], eax
  0079f	b9 01 00 00 00	 mov	 ecx, 1
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007aa	48 8d 8c 24 20
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  007b2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007b7	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv352[rsp]
  007be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007c2	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv357[rsp]
  007c9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170416
  007d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170417
  007e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170418
  007f7	ba a6 09 00 00	 mov	 edx, 2470		; 000009a6H
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170419
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@serverConn:
$LN65@serverConn:
$LN64@serverConn:
$LN63@serverConn:
$LN62@serverConn:
$LN61@serverConn:
$LN8@serverConn:

; 2471 : 
; 2472 :     /* Keep looping while there are still clients connected to our device */
; 2473 :     while (dev->shrdconn)

  00809	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0080e	83 b8 58 06 00
	00 00		 cmp	 DWORD PTR [rax+1624], 0
  00815	0f 84 35 08 00
	00		 je	 $LN9@serverConn

; 2474 :     {
; 2475 :         FD_ZERO( &selset );

  0081b	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR selset$[rsp], 0

; 2476 :         maxfd = -1;

  00826	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR maxfd$[rsp], -1

; 2477 : 
; 2478 :         /* Get the current time */
; 2479 :         now = time( NULL );

  00831	33 c9		 xor	 ecx, ecx
  00833	e8 00 00 00 00	 call	 time
  00838	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR now$[rsp], rax

; 2480 : 
; 2481 :         /* For each remote system connected to our device... */
; 2482 :         for (ix = 0; ix < SHARED_MAX_SYS; ix++)

  00840	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ix$[rsp], 0
  00848	eb 0a		 jmp	 SHORT $LN12@serverConn
$LN10@serverConn:
  0084a	8b 44 24 60	 mov	 eax, DWORD PTR ix$[rsp]
  0084e	ff c0		 inc	 eax
  00850	89 44 24 60	 mov	 DWORD PTR ix$[rsp], eax
$LN12@serverConn:
  00854	83 7c 24 60 08	 cmp	 DWORD PTR ix$[rsp], 8
  00859	0f 8d 0d 02 00
	00		 jge	 $LN11@serverConn

; 2483 :         {
; 2484 :             /* Is there a client at this slot? */
; 2485 :             if (dev->shrd[ix])

  0085f	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00864	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00869	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  00872	0f 84 ef 01 00
	00		 je	 $LN26@serverConn

; 2486 :             {
; 2487 :                 /* Stop as soon as we find a pending request */
; 2488 :                 if (dev->shrd[ix]->pending && !dev->shrd[ix]->waiting)

  00878	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  0087d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00882	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0088a	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0088d	83 e0 01	 and	 eax, 1
  00890	85 c0		 test	 eax, eax
  00892	74 23		 je	 SHORT $LN27@serverConn
  00894	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00899	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0089e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  008a6	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  008a9	d1 e8		 shr	 eax, 1
  008ab	83 e0 01	 and	 eax, 1
  008ae	85 c0		 test	 eax, eax
  008b0	75 05		 jne	 SHORT $LN27@serverConn

; 2489 :                     break; // (go process pending request)

  008b2	e9 b5 01 00 00	 jmp	 $LN11@serverConn
$LN27@serverConn:

; 2490 : 
; 2491 :                 /* Disconnect if not a valid socket */
; 2492 :                 if (!socket_is_socket( dev->shrd[ix]->fd ))

  008b7	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  008bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  008c1	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  008c9	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  008cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_is_socket
  008d2	85 c0		 test	 eax, eax
  008d4	75 2f		 jne	 SHORT $LN28@serverConn

; 2493 :                     dev->shrd[ix]->disconnect = 1;

  008d6	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  008db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  008e0	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  008e8	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  008eb	83 c8 08	 or	 eax, 8
  008ee	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  008f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  008f8	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00900	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  00903	eb 73		 jmp	 SHORT $LN29@serverConn
$LN28@serverConn:

; 2494 : 
; 2495 :                 /* See if the connection can be timed out */
; 2496 :                 else if (1
; 2497 :                     && (now - dev->shrd[ix]->time) > SHARED_TIMEOUT
; 2498 :                     && serverDisconnectable( dev, ix )

  00905	33 c0		 xor	 eax, eax
  00907	83 f8 01	 cmp	 eax, 1
  0090a	74 6c		 je	 SHORT $LN30@serverConn
  0090c	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00911	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00916	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0091e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00922	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR now$[rsp]
  0092a	48 2b c8	 sub	 rcx, rax
  0092d	48 8b c1	 mov	 rax, rcx
  00930	48 83 f8 78	 cmp	 rax, 120		; 00000078H
  00934	7e 42		 jle	 SHORT $LN30@serverConn
  00936	8b 54 24 60	 mov	 edx, DWORD PTR ix$[rsp]
  0093a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0093f	e8 00 00 00 00	 call	 serverDisconnectable
  00944	0f b6 c0	 movzx	 eax, al
  00947	85 c0		 test	 eax, eax
  00949	74 2d		 je	 SHORT $LN30@serverConn

; 2499 :                 )
; 2500 :                     dev->shrd[ix]->disconnect = 1;

  0094b	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00950	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00955	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0095d	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00960	83 c8 08	 or	 eax, 8
  00963	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00968	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  0096d	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00975	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN30@serverConn:
$LN29@serverConn:

; 2501 : 
; 2502 :                 /* Disconnect if the disconnect bit is set */
; 2503 :                 if (dev->shrd[ix]->disconnect)

  00978	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  0097d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00982	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0098a	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0098d	c1 e8 03	 shr	 eax, 3
  00990	83 e0 01	 and	 eax, 1
  00993	85 c0		 test	 eax, eax
  00995	74 13		 je	 SHORT $LN31@serverConn

; 2504 :                     serverDisconnect( dev, ix );

  00997	8b 54 24 60	 mov	 edx, DWORD PTR ix$[rsp]
  0099b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009a0	e8 00 00 00 00	 call	 serverDisconnect
  009a5	e9 bd 00 00 00	 jmp	 $LN32@serverConn
$LN31@serverConn:

; 2505 : 
; 2506 :                 /* Otherwise set the fd if not waiting */
; 2507 :                 else if (!dev->shrd[ix]->waiting)

  009aa	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  009af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009b4	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  009bc	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  009bf	d1 e8		 shr	 eax, 1
  009c1	83 e0 01	 and	 eax, 1
  009c4	85 c0		 test	 eax, eax
  009c6	0f 85 9b 00 00
	00		 jne	 $LN33@serverConn

; 2508 :                 {
; 2509 :                     FD_SET( dev->shrd[ix]->fd, &selset );

  009cc	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  009d1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009d6	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  009de	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  009e6	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  009e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 2510 : 
; 2511 :                     if (dev->shrd[ix]->fd >= maxfd)

  009ef	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  009f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  009f9	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00a01	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR maxfd$[rsp]
  00a08	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  00a0b	7c 1e		 jl	 SHORT $LN34@serverConn

; 2512 :                         maxfd = dev->shrd[ix]->fd + 1;

  00a0d	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a12	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00a17	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00a1f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00a22	ff c0		 inc	 eax
  00a24	89 84 24 88 00
	00 00		 mov	 DWORD PTR maxfd$[rsp], eax
$LN34@serverConn:

; 2513 : 
; 2514 :                     SHRDTRACE( "select set %d id=%d",

  00a2b	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a30	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00a35	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00a3d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00a42	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00a47	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00a4f	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00a52	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]
  00a56	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170429
  00a5d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00a62	e8 00 00 00 00	 call	 shrdtrc
$LN33@serverConn:
$LN32@serverConn:
$LN26@serverConn:

; 2515 :                         dev->shrd[ix]->fd, dev->shrd[ix]->id );
; 2516 :                 }
; 2517 :             }
; 2518 :         }

  00a67	e9 de fd ff ff	 jmp	 $LN10@serverConn
$LN11@serverConn:

; 2519 : 
; 2520 :         /* Wait for request if all pending requests were processed */
; 2521 :         if (ix >= SHARED_MAX_SYS)

  00a6c	83 7c 24 60 08	 cmp	 DWORD PTR ix$[rsp], 8
  00a71	0f 8c 59 02 00
	00		 jl	 $LN35@serverConn

; 2522 :         {
; 2523 :             /* If our select set is empty, there are not any clients
; 2524 :                connected to our device (and dev->shrdconn SHOULD now
; 2525 :                be zero) and thus we have nothing to do. If we don't
; 2526 :                have any clients connected to our device then we are
; 2527 :                serving no purpose so we should just exit our thread.
; 2528 :             */
; 2529 :             if (maxfd < 0)      // (if nothing to select)

  00a77	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR maxfd$[rsp], 0
  00a7f	7d 05		 jge	 SHORT $LN36@serverConn

; 2530 :                 continue;       // (then exit our thread)

  00a81	e9 83 fd ff ff	 jmp	 $LN8@serverConn
$LN36@serverConn:

; 2531 : 
; 2532 :             /* Wait for a client to send us a request */
; 2533 :             wait.tv_sec = SHARED_SELECT_WAIT;

  00a86	c7 84 24 e8 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR wait$[rsp], 10

; 2534 :             wait.tv_usec = 0;

  00a91	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR wait$[rsp+4], 0

; 2535 : 
; 2536 :             release_lock( &dev->lock );

  00a9c	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00aa1	48 83 c0 38	 add	 rax, 56			; 00000038H
  00aa5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170432
  00aac	48 8b c8	 mov	 rcx, rax
  00aaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2537 :             {
; 2538 :                 dev->shrdwait = 1;

  00ab5	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00aba	c7 80 5c 06 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1628], 1

; 2539 :                 {
; 2540 :                     rc = select( maxfd, &selset, NULL, NULL, &wait );

  00ac4	c7 44 24 30 ec
	09 00 00	 mov	 DWORD PTR [rsp+48], 2540 ; 000009ecH
  00acc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170433
  00ad3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ad8	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR wait$[rsp]
  00ae0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ae5	45 33 c9	 xor	 r9d, r9d
  00ae8	45 33 c0	 xor	 r8d, r8d
  00aeb	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  00af3	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR maxfd$[rsp]
  00afa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  00b00	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 2541 :                 }
; 2542 :                 dev->shrdwait = 0;

  00b04	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b09	c7 80 5c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1628], 0

; 2543 :             }
; 2544 :             obtain_lock( &dev->lock );

  00b13	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00b18	48 83 c0 38	 add	 rax, 56			; 00000038H
  00b1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170434
  00b23	48 8b c8	 mov	 rcx, rax
  00b26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2545 : 
; 2546 :             SHRDTRACE("select rc %d", rc );

  00b2c	44 8b 44 24 78	 mov	 r8d, DWORD PTR rc$[rsp]
  00b31	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170435
  00b38	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00b3d	e8 00 00 00 00	 call	 shrdtrc

; 2547 : 
; 2548 :             /* Timeout; no one has any requests for us at this time */
; 2549 :             if (rc == 0)

  00b42	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00b47	75 05		 jne	 SHORT $LN37@serverConn

; 2550 :                 continue;

  00b49	e9 bb fc ff ff	 jmp	 $LN61@serverConn
$LN37@serverConn:

; 2551 : 
; 2552 :             /* Did the select fail? */
; 2553 :             if (rc < 0 )

  00b4e	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00b53	0f 8d 9a 00 00
	00		 jge	 $LN38@serverConn

; 2554 :             {
; 2555 :                 /* Try again if temporary error */
; 2556 :                 if (HSO_errno == HSO_EINTR || HSO_errno == HSO_EBADF)

  00b59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00b5f	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  00b64	74 0d		 je	 SHORT $LN40@serverConn
  00b66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00b6c	3d 19 27 00 00	 cmp	 eax, 10009		; 00002719H
  00b71	75 05		 jne	 SHORT $LN39@serverConn
$LN40@serverConn:

; 2557 :                     continue;

  00b73	e9 91 fc ff ff	 jmp	 $LN62@serverConn
$LN39@serverConn:

; 2558 : 
; 2559 :                 // "Shared: error in function %s: %s"
; 2560 :                 WRMSG( HHC00735, "E", "select()", strerror( HSO_errno ));

  00b78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00b7e	8b c8		 mov	 ecx, eax
  00b80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00b86	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv515[rsp], rax
  00b8e	b9 01 00 00 00	 mov	 ecx, 1
  00b93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b99	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv515[rsp]
  00ba1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ba6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170440
  00bad	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170441
  00bb9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170442
  00bc5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bcf	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170443
  00bdc	ba 00 0a 00 00	 mov	 edx, 2560		; 00000a00H
  00be1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170444
  00be8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2561 :                 break; // (exit our thread)

  00bee	e9 5d 04 00 00	 jmp	 $LN9@serverConn
$LN38@serverConn:

; 2562 :             }
; 2563 : 
; 2564 :             /* One or more sockets in our select set is ready, meaning
; 2565 :                one or more remote clients connected to our device has
; 2566 :                a request it needs us to process. Loop through our list
; 2567 :                of connected clients and set the 'pending' request bit
; 2568 :                for each one whose socket that select said is FD_ISSET.
; 2569 :             */
; 2570 :             for (ix = 0; ix < SHARED_MAX_SYS; ix++)

  00bf3	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ix$[rsp], 0
  00bfb	eb 0a		 jmp	 SHORT $LN15@serverConn
$LN13@serverConn:
  00bfd	8b 44 24 60	 mov	 eax, DWORD PTR ix$[rsp]
  00c01	ff c0		 inc	 eax
  00c03	89 44 24 60	 mov	 DWORD PTR ix$[rsp], eax
$LN15@serverConn:
  00c07	83 7c 24 60 08	 cmp	 DWORD PTR ix$[rsp], 8
  00c0c	0f 8d b9 00 00
	00		 jge	 $LN14@serverConn

; 2571 :             {
; 2572 :                 if (1
; 2573 :                     /* Is there a client at this slot? */
; 2574 :                     && dev->shrd[ix]
; 2575 :                     /* Did select() say its socket is set? */
; 2576 :                     && FD_ISSET( dev->shrd[ix]->fd, &selset )

  00c12	33 c0		 xor	 eax, eax
  00c14	83 f8 01	 cmp	 eax, 1
  00c17	0f 84 a9 00 00
	00		 je	 $LN41@serverConn
  00c1d	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00c22	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00c27	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  00c30	0f 84 90 00 00
	00		 je	 $LN41@serverConn
  00c36	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00c3b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00c40	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00c48	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  00c50	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00c53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00c59	85 c0		 test	 eax, eax
  00c5b	74 69		 je	 SHORT $LN41@serverConn

; 2577 :                 )
; 2578 :                 {
; 2579 :                     /* Indicate this client has a pending request */
; 2580 :                     dev->shrd[ix]->pending = 1;

  00c5d	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00c62	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00c67	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00c6f	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00c72	83 c8 01	 or	 eax, 1
  00c75	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00c7a	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00c7f	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00c87	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2581 :                     SHRDTRACE("select isset %d id=%d",

  00c8a	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00c8f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00c94	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00c9c	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00ca1	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00ca6	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00cae	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00cb1	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]
  00cb5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170446
  00cbc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00cc1	e8 00 00 00 00	 call	 shrdtrc
$LN41@serverConn:

; 2582 :                         dev->shrd[ix]->fd, dev->shrd[ix]->id );
; 2583 :                 }
; 2584 :             }

  00cc6	e9 32 ff ff ff	 jmp	 $LN13@serverConn
$LN14@serverConn:

; 2585 :             continue; // (re-iterate to process all pending requests)

  00ccb	e9 39 fb ff ff	 jmp	 $LN63@serverConn
$LN35@serverConn:

; 2586 :         }
; 2587 : 
; 2588 :         /* Found a pending request */
; 2589 :         release_lock( &dev->lock );

  00cd0	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00cd5	48 83 c0 38	 add	 rax, 56			; 00000038H
  00cd9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170447
  00ce0	48 8b c8	 mov	 rcx, rax
  00ce3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2590 : 
; 2591 :         SHRDTRACE("select ready %d id=%d",

  00ce9	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00cee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00cf3	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00cfb	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00d00	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00d05	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00d0d	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00d10	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]
  00d14	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170448
  00d1b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00d20	e8 00 00 00 00	 call	 shrdtrc

; 2592 :             dev->shrd[ix]->fd, dev->shrd[ix]->id );
; 2593 : 
; 2594 :         if (dev->shrd[ix]->havehdr)

  00d25	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00d2a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00d2f	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00d37	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00d3a	c1 e8 02	 shr	 eax, 2
  00d3d	83 e0 01	 and	 eax, 1
  00d40	85 c0		 test	 eax, eax
  00d42	74 7d		 je	 SHORT $LN42@serverConn

; 2595 :         {
; 2596 :             /* Copy the saved start/resume packet */
; 2597 :             memcpy( hdr, dev->shrd[ix]->hdr, SHRD_HDR_SIZE );

  00d44	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00d49	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00d4e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00d56	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d5a	48 89 84 24 30
	21 00 00	 mov	 QWORD PTR hdr$[rsp], rax

; 2598 :             dev->shrd[ix]->havehdr = 0;

  00d62	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00d67	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00d6c	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00d74	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00d77	83 e0 fb	 and	 eax, -5			; fffffffbH
  00d7a	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00d7f	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00d84	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00d8c	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2599 :             dev->shrd[ix]->waiting = 0;

  00d8f	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00d94	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00d99	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00da1	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00da4	83 e0 fd	 and	 eax, -3			; fffffffdH
  00da7	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00dac	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00db1	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00db9	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2600 :         }

  00dbc	e9 bb 01 00 00	 jmp	 $LN43@serverConn
$LN42@serverConn:

; 2601 :         else
; 2602 :         {
; 2603 :             /* Read the request packet */
; 2604 :             if ((rc = recvData( dev->shrd[ix]->fd, hdr, buf, 65536, 1 )) < 0)

  00dc1	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00dc6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00dcb	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00dd3	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00ddb	41 b9 00 00 01
	00		 mov	 r9d, 65536		; 00010000H
  00de1	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00de9	48 8d 94 24 30
	21 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  00df1	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00df4	e8 00 00 00 00	 call	 recvData
  00df9	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax
  00dfd	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e02	0f 8d 74 01 00
	00		 jge	 $LN44@serverConn

; 2605 :             {
; 2606 :                 // "%1d:%04X Shared: error in receive from %s id %d"
; 2607 :                 WRMSG( HHC00734, "E", LCSS_DEVNUM, dev->shrd[ix]->ipaddr, dev->shrd[ix]->id );

  00e08	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00e0e	74 12		 je	 SHORT $LN57@serverConn
  00e10	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00e15	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e19	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv689[rsp], eax
  00e20	eb 0b		 jmp	 SHORT $LN58@serverConn
$LN57@serverConn:
  00e22	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv689[rsp], 0
$LN58@serverConn:
  00e2d	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00e33	74 14		 je	 SHORT $LN59@serverConn
  00e35	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00e3a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00e3e	d1 f8		 sar	 eax, 1
  00e40	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv695[rsp], eax
  00e47	eb 0b		 jmp	 SHORT $LN60@serverConn
$LN59@serverConn:
  00e49	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv695[rsp], 0
$LN60@serverConn:
  00e54	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00e59	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00e5e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00e66	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv815[rsp], rax
  00e6e	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00e73	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00e78	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00e80	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv814[rsp], rcx
  00e88	b9 01 00 00 00	 mov	 ecx, 1
  00e8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e93	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv815[rsp]
  00e9b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00e9d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00ea1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv814[rsp]
  00ea9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00ead	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00eb2	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv689[rsp]
  00eb9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ebd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv695[rsp]
  00ec4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ec8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170452
  00ecf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ed4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170453
  00edb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ee0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ee5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00eeb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170454
  00ef2	ba 2f 0a 00 00	 mov	 edx, 2607		; 00000a2fH
  00ef7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170455
  00efe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2608 :                 dev->shrd[ix]->disconnect = 1;

  00f04	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00f09	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00f0e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00f16	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00f19	83 c8 08	 or	 eax, 8
  00f1c	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00f21	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00f26	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00f2e	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2609 :                 dev->shrd[ix]->pending = 0;

  00f31	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00f36	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00f3b	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00f43	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00f46	83 e0 fe	 and	 eax, -2			; fffffffeH
  00f49	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00f4e	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  00f53	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00f5b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2610 :                 obtain_lock( &dev->lock );

  00f5e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00f63	48 83 c0 38	 add	 rax, 56			; 00000038H
  00f67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170456
  00f6e	48 8b c8	 mov	 rcx, rax
  00f71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2611 :                 continue;

  00f77	e9 8d f8 ff ff	 jmp	 $LN64@serverConn
$LN44@serverConn:
$LN43@serverConn:

; 2612 :             }
; 2613 :         }
; 2614 : 
; 2615 :         /* Process the request */
; 2616 :         serverRequest( dev, ix, hdr, buf );

  00f7c	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00f84	4c 8d 84 24 30
	21 00 00	 lea	 r8, QWORD PTR hdr$[rsp]
  00f8c	8b 54 24 60	 mov	 edx, DWORD PTR ix$[rsp]
  00f90	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00f95	e8 00 00 00 00	 call	 serverRequest

; 2617 : 
; 2618 :         obtain_lock( &dev->lock );

  00f9a	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00f9f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00fa3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170457
  00faa	48 8b c8	 mov	 rcx, rax
  00fad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2619 : 
; 2620 :         /* If the 'waiting' bit is on then the start/resume request
; 2621 :            failed because the device is busy on some other remote
; 2622 :            system.  We only need to save the header because the data
; 2623 :            is ignored for start/resume.
; 2624 :         */
; 2625 :         if (dev->shrd[ix]->waiting)

  00fb3	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00fb8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00fbd	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00fc5	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00fc8	d1 e8		 shr	 eax, 1
  00fca	83 e0 01	 and	 eax, 1
  00fcd	85 c0		 test	 eax, eax
  00fcf	74 4d		 je	 SHORT $LN45@serverConn

; 2626 :         {
; 2627 :             memcpy( dev->shrd[ix]->hdr, hdr, SHRD_HDR_SIZE );

  00fd1	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00fd6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00fdb	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00fe3	48 8b 8c 24 30
	21 00 00	 mov	 rcx, QWORD PTR hdr$[rsp]
  00feb	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 2628 :             dev->shrd[ix]->havehdr = 1;

  00fef	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  00ff4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00ff9	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  01001	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  01004	83 c8 04	 or	 eax, 4
  01007	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0100c	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  01011	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  01019	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 2629 :         }

  0101c	eb 2d		 jmp	 SHORT $LN46@serverConn
$LN45@serverConn:

; 2630 :         else
; 2631 :             dev->shrd[ix]->pending = 0;

  0101e	48 63 44 24 60	 movsxd	 rax, DWORD PTR ix$[rsp]
  01023	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  01028	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  01030	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  01033	83 e0 fe	 and	 eax, -2			; fffffffeH
  01036	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0103b	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  01040	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  01048	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN46@serverConn:

; 2632 : 
; 2633 :     } /* while (dev->shrdconn) */

  0104b	e9 b9 f7 ff ff	 jmp	 $LN65@serverConn
$LN9@serverConn:

; 2634 : 
; 2635 :     dev->shrdtid = 0;

  01050	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01055	c7 80 50 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1616], 0

; 2636 :     release_lock( &dev->lock );

  0105f	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01064	48 83 c0 38	 add	 rax, 56			; 00000038H
  01068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170460
  0106f	48 8b c8	 mov	 rcx, rax
  01072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2637 : 
; 2638 :     if (MLVL( VERBOSE ))

  01078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0107f	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  01085	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0108a	85 c0		 test	 eax, eax
  0108c	0f 84 93 00 00
	00		 je	 $LN47@serverConn

; 2639 :         LOG_THREAD_END( threadname  );

  01092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  01098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170462
  0109f	8b c8		 mov	 ecx, eax
  010a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  010a7	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv788[rsp], eax
  010ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  010b4	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv793[rsp], eax
  010bb	b9 01 00 00 00	 mov	 ecx, 1
  010c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010c6	48 8d 8c 24 20
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  010ce	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010d3	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv788[rsp]
  010da	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010de	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv793[rsp]
  010e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170463
  010f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170464
  010fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01106	41 b9 03 00 00
	00		 mov	 r9d, 3
  0110c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170465
  01113	ba 4f 0a 00 00	 mov	 edx, 2639		; 00000a4fH
  01118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170466
  0111f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN47@serverConn:

; 2640 : 
; 2641 :     return NULL;

  01125	33 c0		 xor	 eax, eax
$LN1@serverConn:

; 2642 : 
; 2643 : } /* serverConnect */

  01127	48 8b 8c 24 40
	21 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0112f	48 33 cc	 xor	 rcx, rsp
  01132	e8 00 00 00 00	 call	 __security_check_cookie
  01137	48 81 c4 50 21
	01 00		 add	 rsp, 74064		; 00012150H
  0113e	5f		 pop	 rdi
  0113f	c3		 ret	 0
serverConnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
dev$ = 0
devnum$ = 32
findDevice PROC

; 2339 : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2340 : DEVBLK      *dev;                       /* -> Device block           */
; 2341 : 
; 2342 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00017	48 89 04 24	 mov	 QWORD PTR dev$[rsp], rax
  0001b	eb 0c		 jmp	 SHORT $LN4@findDevice
$LN2@findDevice:
  0001d	48 8b 04 24	 mov	 rax, QWORD PTR dev$[rsp]
  00021	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00025	48 89 04 24	 mov	 QWORD PTR dev$[rsp], rax
$LN4@findDevice:
  00029	48 83 3c 24 00	 cmp	 QWORD PTR dev$[rsp], 0
  0002e	74 15		 je	 SHORT $LN3@findDevice

; 2343 :         if (dev->devnum == devnum) break;

  00030	48 8b 04 24	 mov	 rax, QWORD PTR dev$[rsp]
  00034	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00038	0f b7 4c 24 20	 movzx	 ecx, WORD PTR devnum$[rsp]
  0003d	3b c1		 cmp	 eax, ecx
  0003f	75 02		 jne	 SHORT $LN5@findDevice
  00041	eb 02		 jmp	 SHORT $LN3@findDevice
$LN5@findDevice:
  00043	eb d8		 jmp	 SHORT $LN2@findDevice
$LN3@findDevice:

; 2344 :     return dev;

  00045	48 8b 04 24	 mov	 rax, QWORD PTR dev$[rsp]

; 2345 : 
; 2346 : } /* findDevice */

  00049	48 83 c4 18	 add	 rsp, 24
  0004d	c3		 ret	 0
findDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
namelen$ = 32
rc$ = 36
client$ = 40
__$ArrayPad$ = 56
sock$ = 80
clientip PROC

; 2324 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000f	48 33 c4	 xor	 rax, rsp
  00012	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2325 : int                     rc;             /* Return code               */
; 2326 : struct sockaddr_in      client;         /* Client address structure  */
; 2327 : socklen_t               namelen;        /* Length of client structure*/
; 2328 : 
; 2329 :     namelen = sizeof(client);

  00017	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR namelen$[rsp], 16

; 2330 :     rc = getpeername (sock, (struct sockaddr *)&client, &namelen);

  0001f	48 63 44 24 50	 movsxd	 rax, DWORD PTR sock$[rsp]
  00024	4c 8d 44 24 20	 lea	 r8, QWORD PTR namelen$[rsp]
  00029	48 8d 54 24 28	 lea	 rdx, QWORD PTR client$[rsp]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  00037	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 2331 :     return inet_ntoa(client.sin_addr);

  0003b	8b 4c 24 2c	 mov	 ecx, DWORD PTR client$[rsp+4]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa

; 2332 : 
; 2333 : } /* clientip */

  00045	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004a	48 33 cc	 xor	 rcx, rsp
  0004d	e8 00 00 00 00	 call	 __security_check_cookie
  00052	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00056	c3		 ret	 0
clientip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
i$ = 96
id$ = 100
tv81 = 104
tv87 = 108
tv194 = 112
tv200 = 116
tv75 = 120
tv239 = 128
dev$ = 160
ix$ = 168
serverDisconnect PROC

; 2261 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2262 :     int id;                             /* Client identifier         */
; 2263 :     int i;                              /* Loop index                */
; 2264 : 
; 2265 :     id = dev->shrd[ix]->id;

  00010	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00018	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00020	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	89 44 24 64	 mov	 DWORD PTR id$[rsp], eax

; 2266 : 
; 2267 : //FIXME: Handle a disconnected busy client better
; 2268 : //       Perhaps a disconnect timeout value... this will
; 2269 : //       give the client time to reconnect.
; 2270 : 
; 2271 :     /* If the device is active by the client then extricate it.
; 2272 :        This is *not* a good situation */
; 2273 :     if (dev->shioactive == id)

  0002e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	8b 4c 24 64	 mov	 ecx, DWORD PTR id$[rsp]
  0003a	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  00040	0f 85 74 02 00
	00		 jne	 $LN5@serverDisc

; 2274 :     {
; 2275 :         // "%1d:%04X Shared: busy client being removed id %d %s"
; 2276 :         WRMSG( HHC00730, "W", LCSS_DEVNUM, id, dev->reserved ? "reserved" : "" );

  00046	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00054	c1 e8 14	 shr	 eax, 20
  00057	83 e0 01	 and	 eax, 1
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN14@serverDisc
  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170275
  00065	48 89 44 24 78	 mov	 QWORD PTR tv75[rsp], rax
  0006a	eb 0c		 jmp	 SHORT $LN15@serverDisc
$LN14@serverDisc:
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170276
  00073	48 89 44 24 78	 mov	 QWORD PTR tv75[rsp], rax
$LN15@serverDisc:
  00078	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00081	74 12		 je	 SHORT $LN16@serverDisc
  00083	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0008f	89 44 24 68	 mov	 DWORD PTR tv81[rsp], eax
  00093	eb 08		 jmp	 SHORT $LN17@serverDisc
$LN16@serverDisc:
  00095	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN17@serverDisc:
  0009d	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000a6	74 14		 je	 SHORT $LN18@serverDisc
  000a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000b4	d1 f8		 sar	 eax, 1
  000b6	89 44 24 6c	 mov	 DWORD PTR tv87[rsp], eax
  000ba	eb 08		 jmp	 SHORT $LN19@serverDisc
$LN18@serverDisc:
  000bc	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN19@serverDisc:
  000c4	b9 01 00 00 00	 mov	 ecx, 1
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv75[rsp]
  000d4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d9	8b 4c 24 64	 mov	 ecx, DWORD PTR id$[rsp]
  000dd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e1	8b 4c 24 68	 mov	 ecx, DWORD PTR tv81[rsp]
  000e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e9	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv87[rsp]
  000ed	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170277
  000f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170278
  00104	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00109	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00114	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170279
  0011b	ba e4 08 00 00	 mov	 edx, 2276		; 000008e4H
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170280
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2277 : 
; 2278 :         /* Call the I/O release exit if reserved by this client */
; 2279 :         if (dev->reserved && dev->hnd->release)

  0012d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00135	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0013b	c1 e8 14	 shr	 eax, 20
  0013e	83 e0 01	 and	 eax, 1
  00141	85 c0		 test	 eax, eax
  00143	74 30		 je	 SHORT $LN6@serverDisc
  00145	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00154	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00159	74 1a		 je	 SHORT $LN6@serverDisc

; 2280 :             (dev->hnd->release) (dev);

  0015b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00163	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0016a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00172	ff 50 70	 call	 QWORD PTR [rax+112]
$LN6@serverDisc:

; 2281 : 
; 2282 :         /* Call the channel program end exit */
; 2283 :         if (dev->hnd->end)

  00175	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00184	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00189	74 1a		 je	 SHORT $LN7@serverDisc

; 2284 :             (dev->hnd->end) (dev);

  0018b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00193	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a2	ff 50 30	 call	 QWORD PTR [rax+48]
$LN7@serverDisc:

; 2285 : 
; 2286 :         /* Reset any 'waiting' bits */
; 2287 :         for (i = 0; i < SHARED_MAX_SYS; i++)

  001a5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ad	eb 0a		 jmp	 SHORT $LN4@serverDisc
$LN2@serverDisc:
  001af	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  001b3	ff c0		 inc	 eax
  001b5	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@serverDisc:
  001b9	83 7c 24 60 08	 cmp	 DWORD PTR i$[rsp], 8
  001be	7d 4d		 jge	 SHORT $LN3@serverDisc

; 2288 :             if (dev->shrd[i])

  001c0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cd	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  001d6	74 33		 je	 SHORT $LN8@serverDisc

; 2289 :                 dev->shrd[i]->waiting = 0;

  001d8	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e5	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  001ed	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  001f0	83 e0 fd	 and	 eax, -3			; fffffffdH
  001f3	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  001f8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00200	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00208	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN8@serverDisc:
  0020b	eb a2		 jmp	 SHORT $LN2@serverDisc
$LN3@serverDisc:

; 2290 : 
; 2291 :         /* Make the device available */
; 2292 :         if (dev->suspended) {

  0020d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00215	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0021b	c1 e8 15	 shr	 eax, 21
  0021e	83 e0 01	 and	 eax, 1
  00221	85 c0		 test	 eax, eax
  00223	74 34		 je	 SHORT $LN9@serverDisc

; 2293 :             dev->shioactive = DEV_SYS_LOCAL;

  00225	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022d	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 2294 :             dev->busy = 1;

  00237	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00245	0f ba e8 13	 bts	 eax, 19
  00249	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00251	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2295 :         }

  00257	eb 32		 jmp	 SHORT $LN10@serverDisc
$LN9@serverDisc:

; 2296 :         else
; 2297 :         {
; 2298 :             dev->shioactive = DEV_SYS_NONE;

  00259	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00261	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 2299 :             dev->busy = 0;

  0026b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00273	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00279	0f ba f0 13	 btr	 eax, 19
  0027d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00285	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN10@serverDisc:

; 2300 :         }
; 2301 : 
; 2302 :         /* Notify any waiters */
; 2303 :         if (dev->shiowaiters)

  0028b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00293	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  0029a	74 1e		 je	 SHORT $LN11@serverDisc

; 2304 :             signal_condition (&dev->shiocond);

  0029c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a4	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170287
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN11@serverDisc:
$LN5@serverDisc:

; 2305 :     }
; 2306 : 
; 2307 :     if (MLVL( VERBOSE ))

  002ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c1	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  002c7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002cc	85 c0		 test	 eax, eax
  002ce	0f 84 dc 00 00
	00		 je	 $LN12@serverDisc

; 2308 :         // "%1d:%04X Shared: %s disconnected id %d"
; 2309 :         WRMSG( HHC00731, "I", LCSS_DEVNUM, dev->shrd[ix]->ipaddr, id );

  002d4	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002dd	74 12		 je	 SHORT $LN20@serverDisc
  002df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002eb	89 44 24 70	 mov	 DWORD PTR tv194[rsp], eax
  002ef	eb 08		 jmp	 SHORT $LN21@serverDisc
$LN20@serverDisc:
  002f1	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN21@serverDisc:
  002f9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00302	74 14		 je	 SHORT $LN22@serverDisc
  00304	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00310	d1 f8		 sar	 eax, 1
  00312	89 44 24 74	 mov	 DWORD PTR tv200[rsp], eax
  00316	eb 08		 jmp	 SHORT $LN23@serverDisc
$LN22@serverDisc:
  00318	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN23@serverDisc:
  00320	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00328	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00338	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv239[rsp], rax
  00340	b9 01 00 00 00	 mov	 ecx, 1
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034b	8b 4c 24 64	 mov	 ecx, DWORD PTR id$[rsp]
  0034f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00353	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv239[rsp]
  0035b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0035f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00364	8b 4c 24 70	 mov	 ecx, DWORD PTR tv194[rsp]
  00368	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv200[rsp]
  00370	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170289
  0037b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170290
  00387	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00391	41 b9 03 00 00
	00		 mov	 r9d, 3
  00397	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170291
  0039e	ba 05 09 00 00	 mov	 edx, 2309		; 00000905H
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170292
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@serverDisc:

; 2310 : 
; 2311 :     /* Release the SHRD block */
; 2312 :     close_socket (dev->shrd[ix]->fd);

  003b0	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  003b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c0	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  003c8	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  003cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2313 :     free (dev->shrd[ix]->ipaddr);

  003d1	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  003d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e1	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  003e9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2314 :     free (dev->shrd[ix]);

  003f3	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  003fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00403	48 8b 8c c1 60
	06 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+1632]
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2315 :     dev->shrd[ix] = NULL;

  00411	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00419	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00421	48 c7 84 c1 60
	06 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+1632], 0

; 2316 : 
; 2317 :     dev->shrdconn--;

  0042d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00435	8b 80 58 06 00
	00		 mov	 eax, DWORD PTR [rax+1624]
  0043b	ff c8		 dec	 eax
  0043d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00445	89 81 58 06 00
	00		 mov	 DWORD PTR [rcx+1624], eax

; 2318 : } /* serverDisconnect */

  0044b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00452	c3		 ret	 0
serverDisconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tv87 = 0
tv89 = 4
dev$ = 32
ix$ = 40
serverDisconnectable PROC

; 2247 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 2248 :     return

  0000d	33 c0		 xor	 eax, eax
  0000f	83 f8 01	 cmp	 eax, 1
  00012	74 64		 je	 SHORT $LN3@serverDisc
  00014	48 63 44 24 28	 movsxd	 rax, DWORD PTR ix$[rsp]
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0001e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00026	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00029	d1 e8		 shr	 eax, 1
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	75 46		 jne	 SHORT $LN3@serverDisc
  00032	48 63 44 24 28	 movsxd	 rax, DWORD PTR ix$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0003c	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00044	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00047	83 e0 01	 and	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	75 2a		 jne	 SHORT $LN3@serverDisc
  0004e	48 63 44 24 28	 movsxd	 rax, DWORD PTR ix$[rsp]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00058	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00065	8b 00		 mov	 eax, DWORD PTR [rax]
  00067	39 81 e4 05 00
	00		 cmp	 DWORD PTR [rcx+1508], eax
  0006d	74 09		 je	 SHORT $LN3@serverDisc
  0006f	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
  00076	eb 07		 jmp	 SHORT $LN4@serverDisc
$LN3@serverDisc:
  00078	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
$LN4@serverDisc:
  0007f	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00083	75 0a		 jne	 SHORT $LN5@serverDisc
  00085	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
  0008d	eb 08		 jmp	 SHORT $LN6@serverDisc
$LN5@serverDisc:
  0008f	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
$LN6@serverDisc:
  00097	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv89[rsp]

; 2249 :     (1
; 2250 :         && !dev->shrd[ix]->waiting
; 2251 :         && !dev->shrd[ix]->pending
; 2252 :         && dev->shioactive != dev->shrd[ix]->id
; 2253 :     );
; 2254 : }

  0009c	48 83 c4 18	 add	 rsp, 24
  000a0	c3		 ret	 0
serverDisconnectable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
hdrlen$ = 96
code$ = 100
status$ = 101
sock$ = 104
tv170 = 108
tv176 = 112
rc$ = 116
shdr$1 = 120
devnum$ = 128
len$ = 132
sendlen$ = 136
id$ = 140
sendbuf$ = 144
tv162 = 152
cbuf$ = 160
__$ArrayPad$ = 65712
dev$ = 65760
ix$ = 65768
hdr$ = 65776
buf$ = 65784
buflen$ = 65792
serverSend PROC

; 2149 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	b8 c8 00 01 00	 mov	 eax, 65736		; 000100c8H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 b0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2150 : int      rc;                            /* Return code               */
; 2151 : int      sock;                          /* Socket number             */
; 2152 : BYTE     code;                          /* Header code               */
; 2153 : BYTE     status;                        /* Header status             */
; 2154 : U16      devnum;                        /* Header device number      */
; 2155 : int      id;                            /* Header identifier         */
; 2156 : int      len;                           /* Header length             */
; 2157 : int      hdrlen;                        /* Header length + other data*/
; 2158 : BYTE    *sendbuf = NULL;                /* Send buffer               */

  00034	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR sendbuf$[rsp], 0

; 2159 : int      sendlen;                       /* Send length               */
; 2160 : BYTE     cbuf[SHRD_HDR_SIZE + 65536];   /* Combined buffer           */
; 2161 : 
; 2162 :     /* Make buf, buflen consistent if no additional data to be sent  */
; 2163 :     if (buf == NULL) buflen = 0;

  00040	48 83 bc 24 f8
	00 01 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00049	75 0d		 jne	 SHORT $LN5@serverSend
  0004b	c7 84 24 00 01
	01 00 00 00 00
	00		 mov	 DWORD PTR buflen$[rsp], 0
  00056	eb 16		 jmp	 SHORT $LN6@serverSend
$LN5@serverSend:

; 2164 :     else if (buflen == 0) buf = NULL;

  00058	83 bc 24 00 01
	01 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00060	75 0c		 jne	 SHORT $LN7@serverSend
  00062	48 c7 84 24 f8
	00 01 00 00 00
	00 00		 mov	 QWORD PTR buf$[rsp], 0
$LN7@serverSend:
$LN6@serverSend:
$LN4@serverSend:

; 2165 : 
; 2166 :     /* Calculate length of header, may contain additional data */
; 2167 :     SHRD_GET_HDR(hdr, code, status, devnum, id, len);

  0006e	48 8b 84 24 f0
	00 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00076	48 89 44 24 78	 mov	 QWORD PTR shdr$1[rsp], rax
  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  00080	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00083	88 44 24 64	 mov	 BYTE PTR code$[rsp], al
  00087	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  0008c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00090	88 44 24 65	 mov	 BYTE PTR status$[rsp], al
  00094	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  00099	48 83 c0 02	 add	 rax, 2
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a5	0f b7 c8	 movzx	 ecx, ax
  000a8	e8 00 00 00 00	 call	 _byteswap_ushort
  000ad	66 89 84 24 80
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  000ba	48 83 c0 04	 add	 rax, 4
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 fetch_hw_noswap
  000c6	0f b7 c8	 movzx	 ecx, ax
  000c9	e8 00 00 00 00	 call	 _byteswap_ushort
  000ce	0f b7 c0	 movzx	 eax, ax
  000d1	89 84 24 84 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  000dd	48 83 c0 06	 add	 rax, 6
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 fetch_hw_noswap
  000e9	0f b7 c8	 movzx	 ecx, ax
  000ec	e8 00 00 00 00	 call	 _byteswap_ushort
  000f1	0f b7 c0	 movzx	 eax, ax
  000f4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	0f 85 69 ff ff
	ff		 jne	 $LN4@serverSend

; 2168 :     hdrlen = SHRD_HDR_SIZE + (len - buflen);

  00105	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0010c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00113	2b c8		 sub	 ecx, eax
  00115	8b c1		 mov	 eax, ecx
  00117	48 98		 cdqe
  00119	48 83 c0 08	 add	 rax, 8
  0011d	89 44 24 60	 mov	 DWORD PTR hdrlen$[rsp], eax

; 2169 :     sendlen = hdrlen + buflen;

  00121	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00128	8b 4c 24 60	 mov	 ecx, DWORD PTR hdrlen$[rsp]
  0012c	03 c8		 add	 ecx, eax
  0012e	8b c1		 mov	 eax, ecx
  00130	89 84 24 88 00
	00 00		 mov	 DWORD PTR sendlen$[rsp], eax

; 2170 : 
; 2171 :     /* Check if buf is adjacent to the header */
; 2172 :     if (buf && hdr + hdrlen == buf)

  00137	48 83 bc 24 f8
	00 01 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00140	74 47		 je	 SHORT $LN8@serverSend
  00142	48 63 44 24 60	 movsxd	 rax, DWORD PTR hdrlen$[rsp]
  00147	48 8b 8c 24 f0
	00 01 00	 mov	 rcx, QWORD PTR hdr$[rsp]
  0014f	48 03 c8	 add	 rcx, rax
  00152	48 8b c1	 mov	 rax, rcx
  00155	48 3b 84 24 f8
	00 01 00	 cmp	 rax, QWORD PTR buf$[rsp]
  0015d	75 2a		 jne	 SHORT $LN8@serverSend

; 2173 :     {
; 2174 :         hdrlen += buflen;

  0015f	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00166	8b 4c 24 60	 mov	 ecx, DWORD PTR hdrlen$[rsp]
  0016a	03 c8		 add	 ecx, eax
  0016c	8b c1		 mov	 eax, ecx
  0016e	89 44 24 60	 mov	 DWORD PTR hdrlen$[rsp], eax

; 2175 :         buf = NULL;

  00172	48 c7 84 24 f8
	00 01 00 00 00
	00 00		 mov	 QWORD PTR buf$[rsp], 0

; 2176 :         buflen = 0;

  0017e	c7 84 24 00 01
	01 00 00 00 00
	00		 mov	 DWORD PTR buflen$[rsp], 0
$LN8@serverSend:

; 2177 :     }
; 2178 : 
; 2179 :     /* Send only the header buffer if 'buf' is empty */
; 2180 :     if (buflen == 0)  sendbuf = hdr;

  00189	83 bc 24 00 01
	01 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00191	75 10		 jne	 SHORT $LN9@serverSend
  00193	48 8b 84 24 f0
	00 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0019b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sendbuf$[rsp], rax
$LN9@serverSend:

; 2181 : 
; 2182 :     /* Get socket number; if 'ix' < 0 we don't have a device yet */
; 2183 :     if (ix >= 0)

  001a3	83 bc 24 e8 00
	01 00 00	 cmp	 DWORD PTR ix$[rsp], 0
  001ab	7c 21		 jl	 SHORT $LN10@serverSend

; 2184 :         sock = dev->shrd[ix]->fd;

  001ad	48 63 84 24 e8
	00 01 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  001b5	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bd	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  001c5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001c8	89 44 24 68	 mov	 DWORD PTR sock$[rsp], eax
  001cc	eb 19		 jmp	 SHORT $LN11@serverSend
$LN10@serverSend:

; 2185 :     else
; 2186 :     {
; 2187 :         sock = -ix;

  001ce	8b 84 24 e8 00
	01 00		 mov	 eax, DWORD PTR ix$[rsp]
  001d5	f7 d8		 neg	 eax
  001d7	89 44 24 68	 mov	 DWORD PTR sock$[rsp], eax

; 2188 :         dev = NULL;

  001db	48 c7 84 24 e0
	00 01 00 00 00
	00 00		 mov	 QWORD PTR dev$[rsp], 0
$LN11@serverSend:

; 2189 :     }
; 2190 : 
; 2191 :     SHRDHDRTRACE( "server send", hdr );

  001e7	45 33 c9	 xor	 r9d, r9d
  001ea	4c 8b 84 24 f0
	00 01 00	 mov	 r8, QWORD PTR hdr$[rsp]
  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170249
  001f9	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00201	e8 00 00 00 00	 call	 shrdhdrtrc

; 2192 : 
; 2193 : #if defined( HAVE_ZLIB )
; 2194 :     /* Compress the buf */
; 2195 :     if (ix >= 0 && dev->shrd[ix]->comp != 0
; 2196 :      && code == SHRD_OK && status == 0
; 2197 :      && hdrlen - SHRD_HDR_SIZE <= SHRD_COMP_MAX_OFF
; 2198 :      && buflen >= SHARED_COMPRESS_MINLEN)
; 2199 :     {
; 2200 :         unsigned long newlen;
; 2201 :         int off = hdrlen - SHRD_HDR_SIZE;
; 2202 :         sendbuf = cbuf;
; 2203 :         newlen = sizeof(cbuf) - hdrlen;
; 2204 :         memcpy (cbuf, hdr, hdrlen);
; 2205 :         rc = compress2 (cbuf + hdrlen, &newlen,
; 2206 :                         buf, buflen, dev->shrd[ix]->comp);
; 2207 :         if (rc == Z_OK && (int)newlen < buflen)
; 2208 :         {
; 2209 :             /* Setup to use the compressed buffer */
; 2210 :             sendlen = hdrlen + newlen;
; 2211 :             buflen = 0;
; 2212 :             code = SHRD_COMP;
; 2213 :             status = (SHRD_LIBZ << 4) | off;
; 2214 :             SHRD_SET_HDR (cbuf, code, status, devnum, id, (U16)(newlen + off));
; 2215 :             SHRDHDRTRACE2( "server send", cbuf, "(compressed)" );
; 2216 :         }
; 2217 :     }
; 2218 : #endif
; 2219 : 
; 2220 :     /* Build combined (hdr + data) buffer */
; 2221 :     if (buflen > 0)

  00206	83 bc 24 00 01
	01 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  0020e	7e 52		 jle	 SHORT $LN12@serverSend

; 2222 :     {
; 2223 :         sendbuf = cbuf;

  00210	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR cbuf$[rsp]
  00218	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sendbuf$[rsp], rax

; 2224 :         memcpy (cbuf, hdr, hdrlen);

  00220	48 63 44 24 60	 movsxd	 rax, DWORD PTR hdrlen$[rsp]
  00225	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR cbuf$[rsp]
  0022d	48 8b f9	 mov	 rdi, rcx
  00230	48 8b b4 24 f0
	00 01 00	 mov	 rsi, QWORD PTR hdr$[rsp]
  00238	48 8b c8	 mov	 rcx, rax
  0023b	f3 a4		 rep movsb

; 2225 :         memcpy (cbuf + hdrlen, buf, buflen);

  0023d	48 63 84 24 00
	01 01 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00245	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR hdrlen$[rsp]
  0024a	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR cbuf$[rsp+rcx]
  00252	48 8b f9	 mov	 rdi, rcx
  00255	48 8b b4 24 f8
	00 01 00	 mov	 rsi, QWORD PTR buf$[rsp]
  0025d	48 8b c8	 mov	 rcx, rax
  00260	f3 a4		 rep movsb
$LN12@serverSend:

; 2226 :     }
; 2227 : 
; 2228 :     /* Send the combined header and data */
; 2229 :     rc = send (sock, sendbuf, sendlen, 0);

  00262	48 63 44 24 68	 movsxd	 rax, DWORD PTR sock$[rsp]
  00267	45 33 c9	 xor	 r9d, r9d
  0026a	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR sendlen$[rsp]
  00272	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sendbuf$[rsp]
  0027a	48 8b c8	 mov	 rcx, rax
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00283	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 2230 : 
; 2231 :     /* Process return code */
; 2232 :     if (rc < 0)

  00287	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  0028c	0f 8d 0a 01 00
	00		 jge	 $LN13@serverSend

; 2233 :     {
; 2234 :         // "%1d:%04X Shared: error in send id %d: %s"
; 2235 :         WRMSG( HHC00729, "E", LCSS_DEVNUM, id, strerror( HSO_errno ));

  00292	48 83 bc 24 e0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0029b	74 12		 je	 SHORT $LN15@serverSend
  0029d	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002a9	89 44 24 6c	 mov	 DWORD PTR tv170[rsp], eax
  002ad	eb 08		 jmp	 SHORT $LN16@serverSend
$LN15@serverSend:
  002af	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN16@serverSend:
  002b7	48 83 bc 24 e0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c0	74 14		 je	 SHORT $LN17@serverSend
  002c2	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ca	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002ce	d1 f8		 sar	 eax, 1
  002d0	89 44 24 70	 mov	 DWORD PTR tv176[rsp], eax
  002d4	eb 08		 jmp	 SHORT $LN18@serverSend
$LN17@serverSend:
  002d6	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
$LN18@serverSend:
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  002e4	8b c8		 mov	 ecx, eax
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ec	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv162[rsp], rax
  002f4	b9 01 00 00 00	 mov	 ecx, 1
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv162[rsp]
  00307	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR id$[rsp]
  00313	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00317	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv170[rsp]
  0031b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031f	8b 4c 24 70	 mov	 ecx, DWORD PTR tv176[rsp]
  00323	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170252
  0032e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170253
  0033a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00344	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170254
  00351	ba bb 08 00 00	 mov	 edx, 2235		; 000008bbH
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170255
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2236 :         dev->shrd[ix]->disconnect = 1;

  00363	48 63 84 24 e8
	00 01 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0036b	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00373	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0037b	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0037e	83 c8 08	 or	 eax, 8
  00381	48 63 8c 24 e8
	00 01 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00389	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00391	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00399	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN13@serverSend:

; 2237 :     }
; 2238 : 
; 2239 :     return rc;

  0039c	8b 44 24 74	 mov	 eax, DWORD PTR rc$[rsp]

; 2240 : 
; 2241 : } /* serverSend */

  003a0	48 8b 8c 24 b0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a8	48 33 cc	 xor	 rcx, rsp
  003ab	e8 00 00 00 00	 call	 __security_check_cookie
  003b0	48 81 c4 c8 00
	01 00		 add	 rsp, 65736		; 000100c8H
  003b7	5f		 pop	 rdi
  003b8	5e		 pop	 rsi
  003b9	c3		 ret	 0
serverSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tv74 = 48
tv92 = 52
shdr$1 = 56
len$ = 64
rc$ = 72
hdr$ = 80
__$ArrayPad$ = 88
dev$ = 112
ix$ = 120
code$ = 128
status$ = 136
msg$ = 144
serverError PROC

; 2124 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2125 :     int rc;                             /* Return code               */
; 2126 :     size_t len;                         /* Message length            */
; 2127 :     BYTE hdr[SHRD_HDR_SIZE];            /* Header                    */
; 2128 : 
; 2129 :     /* Get message length */
; 2130 :     len = strlen(msg) + 1;

  00026	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR msg$[rsp]
  0002e	e8 00 00 00 00	 call	 strlen
  00033	48 ff c0	 inc	 rax
  00036	48 89 44 24 40	 mov	 QWORD PTR len$[rsp], rax

; 2131 :     if (len > SHARED_MAX_MSGLEN)

  0003b	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR len$[rsp], 255 ; 000000ffH
  00044	76 09		 jbe	 SHORT $LN5@serverErro

; 2132 :         len = SHARED_MAX_MSGLEN;

  00046	48 c7 44 24 40
	ff 00 00 00	 mov	 QWORD PTR len$[rsp], 255 ; 000000ffH
$LN5@serverErro:
$LN4@serverErro:

; 2133 : 
; 2134 :     SHRD_SET_HDR( hdr, code, status, dev ? dev->devnum : 0,

  0004f	48 8d 44 24 50	 lea	 rax, QWORD PTR hdr$[rsp]
  00054	48 89 44 24 38	 mov	 QWORD PTR shdr$1[rsp], rax
  00059	48 8b 44 24 38	 mov	 rax, QWORD PTR shdr$1[rsp]
  0005e	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR code$[rsp]
  00066	88 08		 mov	 BYTE PTR [rax], cl
  00068	48 8b 44 24 38	 mov	 rax, QWORD PTR shdr$1[rsp]
  0006d	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR status$[rsp]
  00075	88 48 01	 mov	 BYTE PTR [rax+1], cl
  00078	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0007e	74 0f		 je	 SHORT $LN7@serverErro
  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00085	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00089	89 44 24 30	 mov	 DWORD PTR tv74[rsp], eax
  0008d	eb 08		 jmp	 SHORT $LN8@serverErro
$LN7@serverErro:
  0008f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@serverErro:
  00097	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tv74[rsp]
  0009c	e8 00 00 00 00	 call	 _byteswap_ushort
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$1[rsp]
  000a6	48 83 c1 02	 add	 rcx, 2
  000aa	0f b7 d0	 movzx	 edx, ax
  000ad	e8 00 00 00 00	 call	 store_hw_noswap
  000b2	0f b7 4c 24 40	 movzx	 ecx, WORD PTR len$[rsp]
  000b7	e8 00 00 00 00	 call	 _byteswap_ushort
  000bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$1[rsp]
  000c1	48 83 c1 04	 add	 rcx, 4
  000c5	0f b7 d0	 movzx	 edx, ax
  000c8	e8 00 00 00 00	 call	 store_hw_noswap
  000cd	83 7c 24 78 00	 cmp	 DWORD PTR ix$[rsp], 0
  000d2	7d 0a		 jge	 SHORT $LN9@serverErro
  000d4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
  000dc	eb 18		 jmp	 SHORT $LN10@serverErro
$LN9@serverErro:
  000de	48 63 44 24 78	 movsxd	 rax, DWORD PTR ix$[rsp]
  000e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000e8	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  000f0	8b 00		 mov	 eax, DWORD PTR [rax]
  000f2	89 44 24 34	 mov	 DWORD PTR tv92[rsp], eax
$LN10@serverErro:
  000f6	0f b7 4c 24 34	 movzx	 ecx, WORD PTR tv92[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ushort
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00105	48 83 c1 06	 add	 rcx, 6
  00109	0f b7 d0	 movzx	 edx, ax
  0010c	e8 00 00 00 00	 call	 store_hw_noswap
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	0f 85 34 ff ff
	ff		 jne	 $LN4@serverErro

; 2135 :                   ix < 0 ? 0 : dev->shrd[ix]->id, (U16) len );
; 2136 : 
; 2137 :     SHRDTRACE( "SERVER ERROR! %2.2x %2.2x: %s", code, status, msg );

  0011b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR msg$[rsp]
  00123	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00128	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR status$[rsp]
  00130	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR code$[rsp]
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170203
  0013f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00144	e8 00 00 00 00	 call	 shrdtrc

; 2138 : 
; 2139 :     rc = serverSend( dev, ix, hdr, (BYTE*) msg, (int) len );

  00149	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]
  0014d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00151	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR msg$[rsp]
  00159	4c 8d 44 24 50	 lea	 r8, QWORD PTR hdr$[rsp]
  0015e	8b 54 24 78	 mov	 edx, DWORD PTR ix$[rsp]
  00162	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00167	e8 00 00 00 00	 call	 serverSend
  0016c	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 2140 :     return rc;

  00170	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]

; 2141 : 
; 2142 : } /* serverError */

  00174	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00179	48 33 cc	 xor	 rcx, rsp
  0017c	e8 00 00 00 00	 call	 __security_check_cookie
  00181	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00185	c3		 ret	 0
serverError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
i$ = 0
id$ = 4
dev$ = 32
serverId PROC

; 2098 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24
$LN4@serverId:

; 2099 : int      i;                             /* Loop index                */
; 2100 : int      id;                            /* Identifier                */
; 2101 : 
; 2102 :     do {
; 2103 :         dev->shrdid += 1;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	8b 80 54 06 00
	00		 mov	 eax, DWORD PTR [rax+1620]
  00014	ff c0		 inc	 eax
  00016	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	89 81 54 06 00
	00		 mov	 DWORD PTR [rcx+1620], eax

; 2104 :         dev->shrdid &= 0xffff;

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00026	8b 80 54 06 00
	00		 mov	 eax, DWORD PTR [rax+1620]
  0002c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00036	89 81 54 06 00
	00		 mov	 DWORD PTR [rcx+1620], eax

; 2105 :         if (dev->shrdid == DEV_SYS_LOCAL
; 2106 :          || dev->shrdid == DEV_SYS_NONE)

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00041	81 b8 54 06 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1620], 65535 ; 0000ffffH
  0004b	74 0e		 je	 SHORT $LN9@serverId
  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00052	83 b8 54 06 00
	00 00		 cmp	 DWORD PTR [rax+1620], 0
  00059	75 0f		 jne	 SHORT $LN8@serverId
$LN9@serverId:

; 2107 :             dev->shrdid = 1;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00060	c7 80 54 06 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1620], 1
$LN8@serverId:

; 2108 :         id = dev->shrdid;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0006f	8b 80 54 06 00
	00		 mov	 eax, DWORD PTR [rax+1620]
  00075	89 44 24 04	 mov	 DWORD PTR id$[rsp], eax

; 2109 : 
; 2110 :         for (i = 0; i < SHARED_MAX_SYS; i++)

  00079	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00080	eb 08		 jmp	 SHORT $LN7@serverId
$LN5@serverId:
  00082	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00085	ff c0		 inc	 eax
  00087	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@serverId:
  0008a	83 3c 24 08	 cmp	 DWORD PTR i$[rsp], 8
  0008e	7d 31		 jge	 SHORT $LN6@serverId

; 2111 :             if (dev->shrd[i] && dev->shrd[i]->id == id)

  00090	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00099	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  000a2	74 1b		 je	 SHORT $LN10@serverId
  000a4	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  000ad	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  000b5	8b 4c 24 04	 mov	 ecx, DWORD PTR id$[rsp]
  000b9	39 08		 cmp	 DWORD PTR [rax], ecx
  000bb	75 02		 jne	 SHORT $LN10@serverId

; 2112 :                 break;

  000bd	eb 02		 jmp	 SHORT $LN6@serverId
$LN10@serverId:
  000bf	eb c1		 jmp	 SHORT $LN5@serverId
$LN6@serverId:

; 2113 : 
; 2114 :     } while (i < SHARED_MAX_SYS);

  000c1	83 3c 24 08	 cmp	 DWORD PTR i$[rsp], 8
  000c5	0f 8c 3e ff ff
	ff		 jl	 $LN4@serverId

; 2115 : 
; 2116 :     return id;

  000cb	8b 44 24 04	 mov	 eax, DWORD PTR id$[rsp]

; 2117 : } /* serverId */

  000cf	48 83 c4 18	 add	 rsp, 24
  000d3	c3		 ret	 0
serverId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
i$ = 0
dev$ = 32
id$ = 40
avail$ = 48
serverLocate PROC

; 2069 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 2070 :     int i;
; 2071 : 
; 2072 :     if (avail)

  00012	48 83 7c 24 30
	00		 cmp	 QWORD PTR avail$[rsp], 0
  00018	74 0b		 je	 SHORT $LN5@serverLoca

; 2073 :         *avail = -1;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR avail$[rsp]
  0001f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN5@serverLoca:

; 2074 : 
; 2075 :     for (i=0; i < SHARED_MAX_SYS; i++)

  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0002c	eb 08		 jmp	 SHORT $LN4@serverLoca
$LN2@serverLoca:
  0002e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00031	ff c0		 inc	 eax
  00033	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@serverLoca:
  00036	83 3c 24 08	 cmp	 DWORD PTR i$[rsp], 8
  0003a	7d 52		 jge	 SHORT $LN3@serverLoca

; 2076 :     {
; 2077 :         // Active slot?
; 2078 :         if (dev->shrd[i])

  0003c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00045	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  0004e	74 20		 je	 SHORT $LN6@serverLoca

; 2079 :         {
; 2080 :             // Is this the one they want?
; 2081 :             if (dev->shrd[i]->id == id)

  00050	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00059	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00061	8b 4c 24 28	 mov	 ecx, DWORD PTR id$[rsp]
  00065	39 08		 cmp	 DWORD PTR [rax], ecx
  00067	75 05		 jne	 SHORT $LN8@serverLoca

; 2082 :                 return i;

  00069	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0006c	eb 25		 jmp	 SHORT $LN1@serverLoca
$LN8@serverLoca:

; 2083 :         }

  0006e	eb 1c		 jmp	 SHORT $LN7@serverLoca
$LN6@serverLoca:

; 2084 :         else // (available slot)
; 2085 :         {
; 2086 :             if (avail && *avail < 0)

  00070	48 83 7c 24 30
	00		 cmp	 QWORD PTR avail$[rsp], 0
  00076	74 14		 je	 SHORT $LN9@serverLoca
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR avail$[rsp]
  0007d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00080	7d 0a		 jge	 SHORT $LN9@serverLoca

; 2087 :                 *avail = i;

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR avail$[rsp]
  00087	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0008a	89 08		 mov	 DWORD PTR [rax], ecx
$LN9@serverLoca:
$LN7@serverLoca:

; 2088 :         }
; 2089 :     }

  0008c	eb a0		 jmp	 SHORT $LN2@serverLoca
$LN3@serverLoca:

; 2090 : 
; 2091 :     return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
$LN1@serverLoca:

; 2092 : }

  00093	48 83 c4 18	 add	 rsp, 24
  00097	c3		 ret	 0
serverLocate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
cmd$ = 64
flag$ = 65
id$ = 68
rc$ = 72
len$ = 76
code$ = 80
i$ = 84
rcd$ = 88
tv843 = 92
tv132 = 96
shdr$1 = 104
tv668 = 112
off$ = 116
shdr$2 = 120
shdr$3 = 128
shdr$4 = 136
shdr$5 = 144
shdr$6 = 152
shdr$7 = 160
shdr$8 = 168
shdr$9 = 176
shdr$10 = 184
shdr$11 = 192
shdr$12 = 200
shdr$13 = 208
shdr$14 = 216
shdr$15 = 224
shdr$16 = 232
shdr$17 = 240
shdr$18 = 248
shdr$19 = 256
shdr$20 = 264
devnum$ = 272
tv1161 = 280
trcmsg$ = 288
__$ArrayPad$ = 320
dev$ = 352
ix$ = 360
hdr$ = 368
buf$ = 376
serverRequest PROC

; 1663 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@serverRequ:

; 1664 : int      rc;                            /* Return code               */
; 1665 : int      i;                             /* Loop index                */
; 1666 : BYTE     cmd;                           /* Header command            */
; 1667 : BYTE     flag;                          /* Header flags              */
; 1668 : U16      devnum;                        /* Header device number      */
; 1669 : int      id;                            /* Header identifier         */
; 1670 : int      len;                           /* Header length             */
; 1671 : int      code;                          /* Response code             */
; 1672 : int      rcd;                           /* Record to read/write      */
; 1673 : int      off;                           /* Offset into record        */
; 1674 : char     trcmsg[32];
; 1675 : 
; 1676 :     /* Extract header information */
; 1677 :     SHRD_GET_HDR (hdr, cmd, flag, devnum, id, len);

  0002d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00035	48 89 44 24 78	 mov	 QWORD PTR shdr$2[rsp], rax
  0003a	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$2[rsp]
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	88 44 24 40	 mov	 BYTE PTR cmd$[rsp], al
  00046	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$2[rsp]
  0004b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0004f	88 44 24 41	 mov	 BYTE PTR flag$[rsp], al
  00053	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$2[rsp]
  00058	48 83 c0 02	 add	 rax, 2
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00064	0f b7 c8	 movzx	 ecx, ax
  00067	e8 00 00 00 00	 call	 _byteswap_ushort
  0006c	66 89 84 24 10
	01 00 00	 mov	 WORD PTR devnum$[rsp], ax
  00074	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$2[rsp]
  00079	48 83 c0 04	 add	 rax, 4
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 fetch_hw_noswap
  00085	0f b7 c8	 movzx	 ecx, ax
  00088	e8 00 00 00 00	 call	 _byteswap_ushort
  0008d	0f b7 c0	 movzx	 eax, ax
  00090	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax
  00094	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$2[rsp]
  00099	48 83 c0 06	 add	 rax, 6
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a5	0f b7 c8	 movzx	 ecx, ax
  000a8	e8 00 00 00 00	 call	 _byteswap_ushort
  000ad	0f b7 c0	 movzx	 eax, ax
  000b0	89 44 24 44	 mov	 DWORD PTR id$[rsp], eax
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	0f 85 6f ff ff
	ff		 jne	 $LN4@serverRequ

; 1678 :     MSGBUF( trcmsg, "server request [%d]", ix );

  000be	44 8b 8c 24 68
	01 00 00	 mov	 r9d, DWORD PTR ix$[rsp]
  000c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170050
  000cd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d2	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR trcmsg$[rsp]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1679 :     SHRDHDRTRACE( trcmsg, hdr );

  000e0	45 33 c9	 xor	 r9d, r9d
  000e3	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  000eb	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR trcmsg$[rsp]
  000f3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000fb	e8 00 00 00 00	 call	 shrdhdrtrc

; 1680 : 
; 1681 :     /* Save time of last request (for connection timeout purposes) */
; 1682 :     dev->shrd[ix]->time = time( NULL );

  00100	33 c9		 xor	 ecx, ecx
  00102	e8 00 00 00 00	 call	 time
  00107	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0010f	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00117	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  0011f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1683 : 
; 1684 :     /* Process the request */
; 1685 :     switch (cmd) {

  00123	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00128	89 44 24 60	 mov	 DWORD PTR tv132[rsp], eax
  0012c	8b 44 24 60	 mov	 eax, DWORD PTR tv132[rsp]
  00130	2d e0 00 00 00	 sub	 eax, 224		; 000000e0H
  00135	89 44 24 60	 mov	 DWORD PTR tv132[rsp], eax
  00139	83 7c 24 60 0c	 cmp	 DWORD PTR tv132[rsp], 12
  0013e	0f 87 c8 1d 00
	00		 ja	 $LN133@serverRequ
  00144	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv132[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00150	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN138@serverRequ[rcx+rax*4]
  00157	48 03 c1	 add	 rax, rcx
  0015a	ff e0		 jmp	 rax
$LN71@serverRequ:

; 1686 : 
; 1687 :     case SHRD_CONNECT:
; 1688 :         if (dev->connecting)

  0015c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0016a	c1 e8 08	 shr	 eax, 8
  0016d	83 e0 01	 and	 eax, 1
  00170	85 c0		 test	 eax, eax
  00172	74 33		 je	 SHORT $LN72@serverRequ

; 1689 :         {
; 1690 :             serverError (dev, ix, SHRD_ERROR_NOTINIT, cmd,

  00174	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170053
  00180	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00185	44 8b c8	 mov	 r9d, eax
  00188	41 b8 f2 00 00
	00		 mov	 r8d, 242		; 000000f2H
  0018e	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00195	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0019d	e8 00 00 00 00	 call	 serverError

; 1691 :                          "device not initialized");
; 1692 :             break;

  001a2	e9 93 1d 00 00	 jmp	 $LN5@serverRequ
$LN72@serverRequ:

; 1693 :         }
; 1694 :         if ((flag >> 4) != SHARED_VERSION)

  001a7	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  001ac	c1 f8 04	 sar	 eax, 4
  001af	85 c0		 test	 eax, eax
  001b1	74 33		 je	 SHORT $LN73@serverRequ

; 1695 :         {
; 1696 :             serverError (dev, ix, SHRD_ERROR_BADVERS, cmd,

  001b3	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170055
  001bf	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001c4	44 8b c8	 mov	 r9d, eax
  001c7	41 b8 f1 00 00
	00		 mov	 r8d, 241		; 000000f1H
  001cd	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  001d4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001dc	e8 00 00 00 00	 call	 serverError

; 1697 :                          "shared version mismatch");
; 1698 :             break;

  001e1	e9 54 1d 00 00	 jmp	 $LN5@serverRequ
$LN73@serverRequ:

; 1699 :         }
; 1700 :         dev->shrd[ix]->release = flag & 0x0f;

  001e6	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  001eb	83 e0 0f	 and	 eax, 15
  001ee	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  001f6	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001fe	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00206	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN9@serverRequ:

; 1701 :         SHRD_SET_HDR (hdr, 0, (SHARED_VERSION << 4) | SHARED_RELEASE, dev->devnum, id, 2);

  00209	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00211	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR shdr$3[rsp], rax
  00219	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$3[rsp]
  00221	c6 00 00	 mov	 BYTE PTR [rax], 0
  00224	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$3[rsp]
  0022c	c6 40 01 02	 mov	 BYTE PTR [rax+1], 2
  00230	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00238	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0023c	e8 00 00 00 00	 call	 _byteswap_ushort
  00241	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  00249	48 83 c1 02	 add	 rcx, 2
  0024d	0f b7 d0	 movzx	 edx, ax
  00250	e8 00 00 00 00	 call	 store_hw_noswap
  00255	66 b9 02 00	 mov	 cx, 2
  00259	e8 00 00 00 00	 call	 _byteswap_ushort
  0025e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  00266	48 83 c1 04	 add	 rcx, 4
  0026a	0f b7 d0	 movzx	 edx, ax
  0026d	e8 00 00 00 00	 call	 store_hw_noswap
  00272	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  00277	e8 00 00 00 00	 call	 _byteswap_ushort
  0027c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  00284	48 83 c1 06	 add	 rcx, 6
  00288	0f b7 d0	 movzx	 edx, ax
  0028b	e8 00 00 00 00	 call	 store_hw_noswap
  00290	33 c0		 xor	 eax, eax
  00292	85 c0		 test	 eax, eax
  00294	0f 85 6f ff ff
	ff		 jne	 $LN9@serverRequ

; 1702 :         store_hw (buf, id);

  0029a	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  0029f	e8 00 00 00 00	 call	 _byteswap_ushort
  002a4	0f b7 d0	 movzx	 edx, ax
  002a7	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002af	e8 00 00 00 00	 call	 store_hw_noswap

; 1703 :         serverSend (dev, ix, hdr, buf, 2);

  002b4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002bc	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  002c4	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  002cc	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  002d3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002db	e8 00 00 00 00	 call	 serverSend

; 1704 :         break;

  002e0	e9 55 1c 00 00	 jmp	 $LN5@serverRequ
$LN74@serverRequ:
$LN12@serverRequ:

; 1705 : 
; 1706 :     case SHRD_DISCONNECT:
; 1707 :         SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 0);

  002e5	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  002ed	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR shdr$4[rsp], rax
  002f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$4[rsp]
  002fd	c6 00 00	 mov	 BYTE PTR [rax], 0
  00300	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$4[rsp]
  00308	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  0030c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00314	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  00318	e8 00 00 00 00	 call	 _byteswap_ushort
  0031d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR shdr$4[rsp]
  00325	48 83 c1 02	 add	 rcx, 2
  00329	0f b7 d0	 movzx	 edx, ax
  0032c	e8 00 00 00 00	 call	 store_hw_noswap
  00331	33 c9		 xor	 ecx, ecx
  00333	e8 00 00 00 00	 call	 _byteswap_ushort
  00338	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR shdr$4[rsp]
  00340	48 83 c1 04	 add	 rcx, 4
  00344	0f b7 d0	 movzx	 edx, ax
  00347	e8 00 00 00 00	 call	 store_hw_noswap
  0034c	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  00351	e8 00 00 00 00	 call	 _byteswap_ushort
  00356	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR shdr$4[rsp]
  0035e	48 83 c1 06	 add	 rcx, 6
  00362	0f b7 d0	 movzx	 edx, ax
  00365	e8 00 00 00 00	 call	 store_hw_noswap
  0036a	33 c0		 xor	 eax, eax
  0036c	85 c0		 test	 eax, eax
  0036e	0f 85 71 ff ff
	ff		 jne	 $LN12@serverRequ

; 1708 :         serverSend (dev, ix, hdr, NULL, 0);

  00374	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0037c	45 33 c9	 xor	 r9d, r9d
  0037f	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00387	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  0038e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00396	e8 00 00 00 00	 call	 serverSend

; 1709 :         dev->shrd[ix]->disconnect = 1;

  0039b	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  003a3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ab	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  003b3	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  003b6	83 c8 08	 or	 eax, 8
  003b9	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  003c1	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  003c9	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  003d1	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1710 : 
; 1711 :         obtain_lock (&dev->lock);

  003d4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	48 83 c0 38	 add	 rax, 56			; 00000038H
  003e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170057
  003e7	48 8b c8	 mov	 rcx, rax
  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1712 : 
; 1713 :         /* Make the device available if this system active on it */
; 1714 :         if (dev->shioactive == id)

  003f0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f8	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  003fc	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  00402	0f 85 8d 00 00
	00		 jne	 $LN75@serverRequ

; 1715 :         {
; 1716 :             if (!dev->suspended)

  00408	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00410	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00416	c1 e8 15	 shr	 eax, 21
  00419	83 e0 01	 and	 eax, 1
  0041c	85 c0		 test	 eax, eax
  0041e	75 34		 jne	 SHORT $LN76@serverRequ

; 1717 :             {
; 1718 :                 dev->busy = 0;

  00420	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00428	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0042e	0f ba f0 13	 btr	 eax, 19
  00432	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0043a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1719 :                 dev->shioactive = DEV_SYS_NONE;

  00440	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00448	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 1720 :             }

  00452	eb 12		 jmp	 SHORT $LN77@serverRequ
$LN76@serverRequ:

; 1721 :             else
; 1722 :                 dev->shioactive = DEV_SYS_LOCAL;

  00454	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045c	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
$LN77@serverRequ:

; 1723 :             if (dev->shiowaiters)

  00466	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046e	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  00475	74 1e		 je	 SHORT $LN78@serverRequ

; 1724 :                 signal_condition (&dev->shiocond);

  00477	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0047f	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  00485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170062
  0048c	48 8b c8	 mov	 rcx, rax
  0048f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN78@serverRequ:
$LN75@serverRequ:

; 1725 :         }
; 1726 : 
; 1727 :         release_lock (&dev->lock);

  00495	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0049d	48 83 c0 38	 add	 rax, 56			; 00000038H
  004a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170063
  004a8	48 8b c8	 mov	 rcx, rax
  004ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1728 :         break;

  004b1	e9 84 1a 00 00	 jmp	 $LN5@serverRequ
$LN79@serverRequ:
$LN80@serverRequ:

; 1729 : 
; 1730 :     case SHRD_START:
; 1731 :     case SHRD_RESUME:
; 1732 : 
; 1733 :         obtain_lock (&dev->lock);

  004b6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004be	48 83 c0 38	 add	 rax, 56			; 00000038H
  004c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170066
  004c9	48 8b c8	 mov	 rcx, rax
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1734 : 
; 1735 :         /* If the device is suspended locally then grab it */
; 1736 :         if (dev->shioactive == DEV_SYS_LOCAL && dev->suspended && !dev->reserved)

  004d2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004da	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  004e4	75 42		 jne	 SHORT $LN81@serverRequ
  004e6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ee	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004f4	c1 e8 15	 shr	 eax, 21
  004f7	83 e0 01	 and	 eax, 1
  004fa	85 c0		 test	 eax, eax
  004fc	74 2a		 je	 SHORT $LN81@serverRequ
  004fe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00506	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0050c	c1 e8 14	 shr	 eax, 20
  0050f	83 e0 01	 and	 eax, 1
  00512	85 c0		 test	 eax, eax
  00514	75 12		 jne	 SHORT $LN81@serverRequ

; 1737 :             dev->shioactive = id;

  00516	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0051e	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  00522	89 88 e4 05 00
	00		 mov	 DWORD PTR [rax+1508], ecx
$LN81@serverRequ:

; 1738 : 
; 1739 :         /* Check if the device is busy */
; 1740 :         if (dev->shioactive != id && dev->shioactive != DEV_SYS_NONE)

  00528	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00530	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  00534	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  0053a	0f 84 92 02 00
	00		 je	 $LN82@serverRequ
  00540	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00548	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  0054f	0f 84 7d 02 00
	00		 je	 $LN82@serverRequ

; 1741 :         {
; 1742 :             SHRDTRACE( "server request busy id=%d shioactive=%d reserved=%d",

  00555	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0055d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00563	c1 e8 14	 shr	 eax, 20
  00566	83 e0 01	 and	 eax, 1
  00569	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0056d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00575	44 8b 88 e4 05
	00 00		 mov	 r9d, DWORD PTR [rax+1508]
  0057c	44 8b 44 24 44	 mov	 r8d, DWORD PTR id$[rsp]
  00581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170069
  00588	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00590	e8 00 00 00 00	 call	 shrdtrc

; 1743 :                     id, dev->shioactive, dev->reserved );
; 1744 :             /* If the 'nowait' bit is on then respond 'busy' */
; 1745 :             if (flag & SHRD_NOWAIT)

  00595	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  0059a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0059f	85 c0		 test	 eax, eax
  005a1	0f 84 d7 00 00
	00		 je	 $LN83@serverRequ

; 1746 :             {
; 1747 :                 release_lock (&dev->lock);

  005a7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005af	48 83 c0 38	 add	 rax, 56			; 00000038H
  005b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170071
  005ba	48 8b c8	 mov	 rcx, rax
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN15@serverRequ:

; 1748 :                 SHRD_SET_HDR (hdr, SHRD_BUSY, 0, dev->devnum, id, 0);

  005c3	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  005cb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR shdr$5[rsp], rax
  005d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$5[rsp]
  005db	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
  005de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$5[rsp]
  005e6	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  005ea	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f2	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  005f6	e8 00 00 00 00	 call	 _byteswap_ushort
  005fb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$5[rsp]
  00603	48 83 c1 02	 add	 rcx, 2
  00607	0f b7 d0	 movzx	 edx, ax
  0060a	e8 00 00 00 00	 call	 store_hw_noswap
  0060f	33 c9		 xor	 ecx, ecx
  00611	e8 00 00 00 00	 call	 _byteswap_ushort
  00616	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$5[rsp]
  0061e	48 83 c1 04	 add	 rcx, 4
  00622	0f b7 d0	 movzx	 edx, ax
  00625	e8 00 00 00 00	 call	 store_hw_noswap
  0062a	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  0062f	e8 00 00 00 00	 call	 _byteswap_ushort
  00634	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$5[rsp]
  0063c	48 83 c1 06	 add	 rcx, 6
  00640	0f b7 d0	 movzx	 edx, ax
  00643	e8 00 00 00 00	 call	 store_hw_noswap
  00648	33 c0		 xor	 eax, eax
  0064a	85 c0		 test	 eax, eax
  0064c	0f 85 71 ff ff
	ff		 jne	 $LN15@serverRequ

; 1749 :                 serverSend (dev, ix, hdr, NULL, 0);

  00652	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0065a	45 33 c9	 xor	 r9d, r9d
  0065d	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00665	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  0066c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00674	e8 00 00 00 00	 call	 serverSend

; 1750 :                 break;

  00679	e9 bc 18 00 00	 jmp	 $LN5@serverRequ
$LN83@serverRequ:

; 1751 :             }
; 1752 : 
; 1753 :             dev->shrd[ix]->waiting = 1;

  0067e	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00686	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0068e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00696	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00699	83 c8 02	 or	 eax, 2
  0069c	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  006a4	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  006ac	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  006b4	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN16@serverRequ:

; 1754 : 
; 1755 :             /* Wait while the device is busy by the local system */
; 1756 :             while (dev->shioactive == DEV_SYS_LOCAL && !dev->suspended)

  006b7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006bf	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  006c9	0f 85 84 00 00
	00		 jne	 $LN17@serverRequ
  006cf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006d7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006dd	c1 e8 15	 shr	 eax, 21
  006e0	83 e0 01	 and	 eax, 1
  006e3	85 c0		 test	 eax, eax
  006e5	75 6c		 jne	 SHORT $LN17@serverRequ

; 1757 :             {
; 1758 :                 dev->shiowaiters++;

  006e7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ef	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  006f5	ff c0		 inc	 eax
  006f7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006ff	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 1759 :                 wait_condition (&dev->shiocond, &dev->lock);

  00705	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0070d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00711	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00719	48 81 c1 d8 05
	00 00		 add	 rcx, 1496		; 000005d8H
  00720	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170072
  00727	48 8b d0	 mov	 rdx, rax
  0072a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 1760 :                 dev->shiowaiters--;

  00730	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00738	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0073e	ff c8		 dec	 eax
  00740	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00748	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 1761 :             }

  0074e	e9 64 ff ff ff	 jmp	 $LN16@serverRequ
$LN17@serverRequ:

; 1762 : 
; 1763 :             /* Return with the 'waiting' bit on if busy by a remote system */
; 1764 :             if (dev->shioactive != DEV_SYS_NONE && dev->shioactive != DEV_SYS_LOCAL)

  00753	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0075b	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00762	74 35		 je	 SHORT $LN84@serverRequ
  00764	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0076c	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00776	74 21		 je	 SHORT $LN84@serverRequ

; 1765 :             {
; 1766 :                 release_lock (&dev->lock);

  00778	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00780	48 83 c0 38	 add	 rax, 56			; 00000038H
  00784	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170074
  0078b	48 8b c8	 mov	 rcx, rax
  0078e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1767 :                 break;

  00794	e9 a1 17 00 00	 jmp	 $LN5@serverRequ
$LN84@serverRequ:

; 1768 :             }
; 1769 : 
; 1770 :             dev->shrd[ix]->waiting = 0;

  00799	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  007a1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007a9	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  007b1	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  007b4	83 e0 fd	 and	 eax, -3			; fffffffdH
  007b7	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  007bf	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007c7	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  007cf	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN82@serverRequ:

; 1771 :         }
; 1772 : 
; 1773 :         /* Make this system active on the device */
; 1774 :         dev->shioactive = id;

  007d2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007da	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  007de	89 88 e4 05 00
	00		 mov	 DWORD PTR [rax+1508], ecx

; 1775 :         dev->busy = 1;

  007e4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007ec	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  007f2	0f ba e8 13	 bts	 eax, 19
  007f6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007fe	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1776 :         sysblk.shrdcount++;

  00804	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0080b	8b 80 b0 13 00
	00		 mov	 eax, DWORD PTR [rax+5040]
  00811	ff c0		 inc	 eax
  00813	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0081a	89 81 b0 13 00
	00		 mov	 DWORD PTR [rcx+5040], eax

; 1777 :         SHRDTRACE( "server request active id=%d", id );

  00820	44 8b 44 24 44	 mov	 r8d, DWORD PTR id$[rsp]
  00825	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170075
  0082c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00834	e8 00 00 00 00	 call	 shrdtrc

; 1778 : 
; 1779 :         /* Increment excp count */
; 1780 :         dev->excps++;

  00839	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00841	48 8b 80 00 06
	00 00		 mov	 rax, QWORD PTR [rax+1536]
  00848	48 ff c0	 inc	 rax
  0084b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00853	48 89 81 00 06
	00 00		 mov	 QWORD PTR [rcx+1536], rax

; 1781 : 
; 1782 :         release_lock(&dev->lock);

  0085a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00862	48 83 c0 38	 add	 rax, 56			; 00000038H
  00866	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170076
  0086d	48 8b c8	 mov	 rcx, rax
  00870	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1783 : 
; 1784 :         /* Call the i/o start or resume exit */
; 1785 :         if (cmd == SHRD_START && dev->hnd->start)

  00876	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  0087b	3d e2 00 00 00	 cmp	 eax, 226		; 000000e2H
  00880	75 32		 jne	 SHORT $LN85@serverRequ
  00882	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0088a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00891	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00896	74 1c		 je	 SHORT $LN85@serverRequ

; 1786 :             (dev->hnd->start) (dev);

  00898	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008a0	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  008a7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008af	ff 50 28	 call	 QWORD PTR [rax+40]
  008b2	eb 3c		 jmp	 SHORT $LN86@serverRequ
$LN85@serverRequ:

; 1787 :         else if (cmd == SHRD_RESUME && dev->hnd->resume)

  008b4	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  008b9	3d e4 00 00 00	 cmp	 eax, 228		; 000000e4H
  008be	75 30		 jne	 SHORT $LN87@serverRequ
  008c0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008c8	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  008cf	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  008d4	74 1a		 je	 SHORT $LN87@serverRequ

; 1788 :             (dev->hnd->resume) (dev);

  008d6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008de	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  008e5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008ed	ff 50 38	 call	 QWORD PTR [rax+56]
$LN87@serverRequ:
$LN86@serverRequ:

; 1789 : 
; 1790 :         /* Get the purge list */
; 1791 :         if (dev->shrd[ix]->purgen == 0)

  008f0	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  008f8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00900	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00908	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0090c	75 12		 jne	 SHORT $LN88@serverRequ

; 1792 :             code = len = 0;

  0090e	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00916	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  0091a	89 44 24 50	 mov	 DWORD PTR code$[rsp], eax
  0091e	eb 52		 jmp	 SHORT $LN89@serverRequ
$LN88@serverRequ:

; 1793 :         else
; 1794 :         {
; 1795 :             code = SHRD_PURGE;

  00920	c7 44 24 50 08
	00 00 00	 mov	 DWORD PTR code$[rsp], 8

; 1796 :             if (dev->shrd[ix]->purgen < 0)

  00928	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00930	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00938	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00940	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00944	7d 0a		 jge	 SHORT $LN90@serverRequ

; 1797 :                 len = 0;

  00946	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  0094e	eb 22		 jmp	 SHORT $LN91@serverRequ
$LN90@serverRequ:

; 1798 :             else
; 1799 :                 len = 4 * dev->shrd[ix]->purgen;

  00950	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00958	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00960	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00968	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0096b	c1 e0 02	 shl	 eax, 2
  0096e	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax
$LN91@serverRequ:
$LN89@serverRequ:
$LN20@serverRequ:

; 1800 :         }
; 1801 : 
; 1802 :         /* Send the response */
; 1803 :         SHRD_SET_HDR (hdr, code, 0, dev->devnum, id, len);

  00972	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0097a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR shdr$6[rsp], rax
  00982	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR shdr$6[rsp]
  0098a	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR code$[rsp]
  0098f	88 08		 mov	 BYTE PTR [rax], cl
  00991	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR shdr$6[rsp]
  00999	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  0099d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009a5	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  009a9	e8 00 00 00 00	 call	 _byteswap_ushort
  009ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$6[rsp]
  009b6	48 83 c1 02	 add	 rcx, 2
  009ba	0f b7 d0	 movzx	 edx, ax
  009bd	e8 00 00 00 00	 call	 store_hw_noswap
  009c2	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR len$[rsp]
  009c7	e8 00 00 00 00	 call	 _byteswap_ushort
  009cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$6[rsp]
  009d4	48 83 c1 04	 add	 rcx, 4
  009d8	0f b7 d0	 movzx	 edx, ax
  009db	e8 00 00 00 00	 call	 store_hw_noswap
  009e0	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  009e5	e8 00 00 00 00	 call	 _byteswap_ushort
  009ea	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$6[rsp]
  009f2	48 83 c1 06	 add	 rcx, 6
  009f6	0f b7 d0	 movzx	 edx, ax
  009f9	e8 00 00 00 00	 call	 store_hw_noswap
  009fe	33 c0		 xor	 eax, eax
  00a00	85 c0		 test	 eax, eax
  00a02	0f 85 6a ff ff
	ff		 jne	 $LN20@serverRequ

; 1804 :         rc = serverSend (dev, ix, hdr, (BYTE *)dev->shrd[ix]->purge, len);

  00a08	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a10	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a18	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00a20	48 83 c0 34	 add	 rax, 52			; 00000034H
  00a24	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$[rsp]
  00a28	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00a2c	4c 8b c8	 mov	 r9, rax
  00a2f	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00a37	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00a3e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a46	e8 00 00 00 00	 call	 serverSend
  00a4b	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1805 :         if (rc >= 0)

  00a4f	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a54	7c 1f		 jl	 SHORT $LN92@serverRequ

; 1806 :             dev->shrd[ix]->purgen = 0;

  00a56	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a5e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a66	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00a6e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN92@serverRequ:

; 1807 :         break;

  00a75	e9 c0 14 00 00	 jmp	 $LN5@serverRequ
$LN93@serverRequ:
$LN94@serverRequ:

; 1808 : 
; 1809 :     case SHRD_END:
; 1810 :     case SHRD_SUSPEND:
; 1811 :         /* Must be active on the device for this command */
; 1812 :         if (dev->shioactive != id)

  00a7a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a82	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  00a86	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  00a8c	74 33		 je	 SHORT $LN95@serverRequ

; 1813 :         {
; 1814 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  00a8e	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00a93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170088
  00a9a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a9f	44 8b c8	 mov	 r9d, eax
  00aa2	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  00aa8	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00aaf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ab7	e8 00 00 00 00	 call	 serverError

; 1815 :                          "not active on this device");
; 1816 :             break;

  00abc	e9 79 14 00 00	 jmp	 $LN5@serverRequ
$LN95@serverRequ:

; 1817 :         }
; 1818 : 
; 1819 :         /* Call the I/O end/suspend exit */
; 1820 :         if (cmd == SHRD_END && dev->hnd->end)

  00ac1	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00ac6	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00acb	75 32		 jne	 SHORT $LN96@serverRequ
  00acd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ad5	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00adc	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00ae1	74 1c		 je	 SHORT $LN96@serverRequ

; 1821 :             (dev->hnd->end) (dev);

  00ae3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00aeb	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00af2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00afa	ff 50 30	 call	 QWORD PTR [rax+48]
  00afd	eb 3c		 jmp	 SHORT $LN97@serverRequ
$LN96@serverRequ:

; 1822 :         else if (cmd == SHRD_SUSPEND && dev->hnd->suspend)

  00aff	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00b04	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00b09	75 30		 jne	 SHORT $LN98@serverRequ
  00b0b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b13	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b1a	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00b1f	74 1a		 je	 SHORT $LN98@serverRequ

; 1823 :             (dev->hnd->suspend) (dev);

  00b21	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b29	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00b30	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b38	ff 50 40	 call	 QWORD PTR [rax+64]
$LN98@serverRequ:
$LN97@serverRequ:

; 1824 : 
; 1825 :         obtain_lock (&dev->lock);

  00b3b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b43	48 83 c0 38	 add	 rax, 56			; 00000038H
  00b47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170092
  00b4e	48 8b c8	 mov	 rcx, rax
  00b51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1826 : 
; 1827 :         /* Make the device available if it's not reserved */
; 1828 :         if (!dev->reserved)

  00b57	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b5f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b65	c1 e8 14	 shr	 eax, 20
  00b68	83 e0 01	 and	 eax, 1
  00b6b	85 c0		 test	 eax, eax
  00b6d	0f 85 15 01 00
	00		 jne	 $LN99@serverRequ

; 1829 :         {
; 1830 :             /* If locally suspended then return the device to local */
; 1831 :             if (dev->suspended)

  00b73	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b7b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b81	c1 e8 15	 shr	 eax, 21
  00b84	83 e0 01	 and	 eax, 1
  00b87	85 c0		 test	 eax, eax
  00b89	74 34		 je	 SHORT $LN100@serverRequ

; 1832 :             {
; 1833 :                 dev->shioactive = DEV_SYS_LOCAL;

  00b8b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b93	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 1834 :                 dev->busy = 1;

  00b9d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ba5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00bab	0f ba e8 13	 bts	 eax, 19
  00baf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bb7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1835 :             }

  00bbd	eb 32		 jmp	 SHORT $LN101@serverRequ
$LN100@serverRequ:

; 1836 :             else
; 1837 :             {
; 1838 :                 dev->shioactive = DEV_SYS_NONE;

  00bbf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bc7	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 1839 :                 dev->busy = 0;

  00bd1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bd9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00bdf	0f ba f0 13	 btr	 eax, 19
  00be3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00beb	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN101@serverRequ:

; 1840 :             }
; 1841 : 
; 1842 :             /* Reset any 'waiting' bits */
; 1843 :             for (i = 0; i < SHARED_MAX_SYS; i++)

  00bf1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00bf9	eb 0a		 jmp	 SHORT $LN23@serverRequ
$LN21@serverRequ:
  00bfb	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00bff	ff c0		 inc	 eax
  00c01	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN23@serverRequ:
  00c05	83 7c 24 54 08	 cmp	 DWORD PTR i$[rsp], 8
  00c0a	7d 4d		 jge	 SHORT $LN22@serverRequ

; 1844 :                 if (dev->shrd[i])

  00c0c	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00c11	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c19	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  00c22	74 33		 je	 SHORT $LN102@serverRequ

; 1845 :                     dev->shrd[i]->waiting = 0;

  00c24	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00c29	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c31	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00c39	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00c3c	83 e0 fd	 and	 eax, -3			; fffffffdH
  00c3f	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c44	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00c4c	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  00c54	89 41 24	 mov	 DWORD PTR [rcx+36], eax
$LN102@serverRequ:
  00c57	eb a2		 jmp	 SHORT $LN21@serverRequ
$LN22@serverRequ:

; 1846 : 
; 1847 :             /* Notify any waiters */
; 1848 :             if (dev->shiowaiters)

  00c59	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c61	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  00c68	74 1e		 je	 SHORT $LN103@serverRequ

; 1849 :                 signal_condition (&dev->shiocond);

  00c6a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c72	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  00c78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170098
  00c7f	48 8b c8	 mov	 rcx, rax
  00c82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN103@serverRequ:
$LN99@serverRequ:

; 1850 :         }
; 1851 :         SHRDTRACE( "server request inactive id=%d", id );

  00c88	44 8b 44 24 44	 mov	 r8d, DWORD PTR id$[rsp]
  00c8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170099
  00c94	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c9c	e8 00 00 00 00	 call	 shrdtrc

; 1852 : 
; 1853 :         release_lock (&dev->lock);

  00ca1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ca9	48 83 c0 38	 add	 rax, 56			; 00000038H
  00cad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170100
  00cb4	48 8b c8	 mov	 rcx, rax
  00cb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN26@serverRequ:

; 1854 : 
; 1855 :         /* Send response back */
; 1856 :         SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 0);

  00cbd	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00cc5	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR shdr$7[rsp], rax
  00ccd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shdr$7[rsp]
  00cd5	c6 00 00	 mov	 BYTE PTR [rax], 0
  00cd8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR shdr$7[rsp]
  00ce0	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  00ce4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cec	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  00cf0	e8 00 00 00 00	 call	 _byteswap_ushort
  00cf5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shdr$7[rsp]
  00cfd	48 83 c1 02	 add	 rcx, 2
  00d01	0f b7 d0	 movzx	 edx, ax
  00d04	e8 00 00 00 00	 call	 store_hw_noswap
  00d09	33 c9		 xor	 ecx, ecx
  00d0b	e8 00 00 00 00	 call	 _byteswap_ushort
  00d10	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shdr$7[rsp]
  00d18	48 83 c1 04	 add	 rcx, 4
  00d1c	0f b7 d0	 movzx	 edx, ax
  00d1f	e8 00 00 00 00	 call	 store_hw_noswap
  00d24	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  00d29	e8 00 00 00 00	 call	 _byteswap_ushort
  00d2e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR shdr$7[rsp]
  00d36	48 83 c1 06	 add	 rcx, 6
  00d3a	0f b7 d0	 movzx	 edx, ax
  00d3d	e8 00 00 00 00	 call	 store_hw_noswap
  00d42	33 c0		 xor	 eax, eax
  00d44	85 c0		 test	 eax, eax
  00d46	0f 85 71 ff ff
	ff		 jne	 $LN26@serverRequ

; 1857 :         serverSend (dev, ix, hdr, NULL, 0);

  00d4c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00d54	45 33 c9	 xor	 r9d, r9d
  00d57	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00d5f	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00d66	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d6e	e8 00 00 00 00	 call	 serverSend

; 1858 :         break;

  00d73	e9 c2 11 00 00	 jmp	 $LN5@serverRequ
$LN104@serverRequ:

; 1859 : 
; 1860 :     case SHRD_RESERVE:
; 1861 :         /* Must be active on the device for this command */
; 1862 :         if (dev->shioactive != id)

  00d78	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d80	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  00d84	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  00d8a	74 33		 je	 SHORT $LN105@serverRequ

; 1863 :         {
; 1864 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  00d8c	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00d91	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170103
  00d98	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00d9d	44 8b c8	 mov	 r9d, eax
  00da0	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  00da6	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00dad	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00db5	e8 00 00 00 00	 call	 serverError

; 1865 :                          "not active on this device");
; 1866 :             break;

  00dba	e9 7b 11 00 00	 jmp	 $LN5@serverRequ
$LN105@serverRequ:

; 1867 :         }
; 1868 : 
; 1869 :         obtain_lock (&dev->lock);

  00dbf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dc7	48 83 c0 38	 add	 rax, 56			; 00000038H
  00dcb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170104
  00dd2	48 8b c8	 mov	 rcx, rax
  00dd5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1870 :         dev->reserved = 1;

  00ddb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00de3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00de9	0f ba e8 14	 bts	 eax, 20
  00ded	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00df5	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1871 :         release_lock (&dev->lock);

  00dfb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e03	48 83 c0 38	 add	 rax, 56			; 00000038H
  00e07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170105
  00e0e	48 8b c8	 mov	 rcx, rax
  00e11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1872 : 
; 1873 :         SHRDTRACE( "server request reserved id=%d", id );

  00e17	44 8b 44 24 44	 mov	 r8d, DWORD PTR id$[rsp]
  00e1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170106
  00e23	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e2b	e8 00 00 00 00	 call	 shrdtrc

; 1874 : 
; 1875 :         /* Call the I/O reserve exit */
; 1876 :         if (dev->hnd->reserve) (dev->hnd->reserve) (dev);

  00e30	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e38	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00e3f	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00e44	74 1a		 je	 SHORT $LN106@serverRequ
  00e46	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e4e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00e55	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e5d	ff 50 68	 call	 QWORD PTR [rax+104]
$LN106@serverRequ:
$LN29@serverRequ:

; 1877 : 
; 1878 :         /* Send response back */
; 1879 :         SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 0);

  00e60	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00e68	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR shdr$8[rsp], rax
  00e70	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$8[rsp]
  00e78	c6 00 00	 mov	 BYTE PTR [rax], 0
  00e7b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR shdr$8[rsp]
  00e83	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  00e87	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e8f	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  00e93	e8 00 00 00 00	 call	 _byteswap_ushort
  00e98	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR shdr$8[rsp]
  00ea0	48 83 c1 02	 add	 rcx, 2
  00ea4	0f b7 d0	 movzx	 edx, ax
  00ea7	e8 00 00 00 00	 call	 store_hw_noswap
  00eac	33 c9		 xor	 ecx, ecx
  00eae	e8 00 00 00 00	 call	 _byteswap_ushort
  00eb3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR shdr$8[rsp]
  00ebb	48 83 c1 04	 add	 rcx, 4
  00ebf	0f b7 d0	 movzx	 edx, ax
  00ec2	e8 00 00 00 00	 call	 store_hw_noswap
  00ec7	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  00ecc	e8 00 00 00 00	 call	 _byteswap_ushort
  00ed1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR shdr$8[rsp]
  00ed9	48 83 c1 06	 add	 rcx, 6
  00edd	0f b7 d0	 movzx	 edx, ax
  00ee0	e8 00 00 00 00	 call	 store_hw_noswap
  00ee5	33 c0		 xor	 eax, eax
  00ee7	85 c0		 test	 eax, eax
  00ee9	0f 85 71 ff ff
	ff		 jne	 $LN29@serverRequ

; 1880 :         serverSend (dev, ix, hdr, NULL, 0);

  00eef	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00ef7	45 33 c9	 xor	 r9d, r9d
  00efa	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00f02	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00f09	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f11	e8 00 00 00 00	 call	 serverSend

; 1881 : 
; 1882 :         break;

  00f16	e9 1f 10 00 00	 jmp	 $LN5@serverRequ
$LN107@serverRequ:

; 1883 : 
; 1884 :     case SHRD_RELEASE:
; 1885 :         /* Must be active on the device for this command */
; 1886 :         if (dev->shioactive != id)

  00f1b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f23	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  00f27	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  00f2d	74 33		 je	 SHORT $LN108@serverRequ

; 1887 :         {
; 1888 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  00f2f	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  00f34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170110
  00f3b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f40	44 8b c8	 mov	 r9d, eax
  00f43	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  00f49	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  00f50	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f58	e8 00 00 00 00	 call	 serverError

; 1889 :                          "not active on this device");
; 1890 :             break;

  00f5d	e9 d8 0f 00 00	 jmp	 $LN5@serverRequ
$LN108@serverRequ:

; 1891 :         }
; 1892 : 
; 1893 :         /* Call the I/O release exit */
; 1894 :         if (dev->hnd->release) (dev->hnd->release) (dev);

  00f62	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f6a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00f71	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00f76	74 1a		 je	 SHORT $LN109@serverRequ
  00f78	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f80	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00f87	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f8f	ff 50 70	 call	 QWORD PTR [rax+112]
$LN109@serverRequ:

; 1895 : 
; 1896 :         obtain_lock (&dev->lock);

  00f92	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f9a	48 83 c0 38	 add	 rax, 56			; 00000038H
  00f9e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170112
  00fa5	48 8b c8	 mov	 rcx, rax
  00fa8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1897 :         dev->reserved = 0;

  00fae	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fb6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00fbc	0f ba f0 14	 btr	 eax, 20
  00fc0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fc8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1898 :         release_lock (&dev->lock);

  00fce	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fd6	48 83 c0 38	 add	 rax, 56			; 00000038H
  00fda	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170113
  00fe1	48 8b c8	 mov	 rcx, rax
  00fe4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1899 : 
; 1900 :         SHRDTRACE( "server request released id=%d", id );

  00fea	44 8b 44 24 44	 mov	 r8d, DWORD PTR id$[rsp]
  00fef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170114
  00ff6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ffe	e8 00 00 00 00	 call	 shrdtrc
$LN32@serverRequ:

; 1901 : 
; 1902 :         /* Send response back */
; 1903 :         SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 0);

  01003	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0100b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR shdr$9[rsp], rax
  01013	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR shdr$9[rsp]
  0101b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0101e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR shdr$9[rsp]
  01026	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  0102a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01032	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01036	e8 00 00 00 00	 call	 _byteswap_ushort
  0103b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$9[rsp]
  01043	48 83 c1 02	 add	 rcx, 2
  01047	0f b7 d0	 movzx	 edx, ax
  0104a	e8 00 00 00 00	 call	 store_hw_noswap
  0104f	33 c9		 xor	 ecx, ecx
  01051	e8 00 00 00 00	 call	 _byteswap_ushort
  01056	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$9[rsp]
  0105e	48 83 c1 04	 add	 rcx, 4
  01062	0f b7 d0	 movzx	 edx, ax
  01065	e8 00 00 00 00	 call	 store_hw_noswap
  0106a	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  0106f	e8 00 00 00 00	 call	 _byteswap_ushort
  01074	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR shdr$9[rsp]
  0107c	48 83 c1 06	 add	 rcx, 6
  01080	0f b7 d0	 movzx	 edx, ax
  01083	e8 00 00 00 00	 call	 store_hw_noswap
  01088	33 c0		 xor	 eax, eax
  0108a	85 c0		 test	 eax, eax
  0108c	0f 85 71 ff ff
	ff		 jne	 $LN32@serverRequ

; 1904 :         serverSend (dev, ix, hdr, NULL, 0);

  01092	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0109a	45 33 c9	 xor	 r9d, r9d
  0109d	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  010a5	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  010ac	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010b4	e8 00 00 00 00	 call	 serverSend

; 1905 : 
; 1906 :         break;

  010b9	e9 7c 0e 00 00	 jmp	 $LN5@serverRequ
$LN110@serverRequ:

; 1907 : 
; 1908 :     case SHRD_READ:
; 1909 :         /* Must be active on the device for this command */
; 1910 :         if (dev->shioactive != id)

  010be	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010c6	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  010ca	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  010d0	74 33		 je	 SHORT $LN111@serverRequ

; 1911 :         {
; 1912 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  010d2	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  010d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170117
  010de	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  010e3	44 8b c8	 mov	 r9d, eax
  010e6	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  010ec	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  010f3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010fb	e8 00 00 00 00	 call	 serverError

; 1913 :                          "not active on this device");
; 1914 :             break;

  01100	e9 35 0e 00 00	 jmp	 $LN5@serverRequ
$LN111@serverRequ:

; 1915 :         }
; 1916 : 
; 1917 :         /* Set the compressions client is willing to accept */
; 1918 :         dev->comps = dev->shrd[ix]->comps;

  01105	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0110d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01115	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0111d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01125	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  01128	89 81 08 02 00
	00		 mov	 DWORD PTR [rcx+520], eax

; 1919 :         dev->comp = dev->compoff = 0;

  0112e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01136	c7 80 10 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+528], 0
  01140	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01148	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+524], 0

; 1920 : 
; 1921 :         /* Call the I/O read exit */
; 1922 :         rcd = (int)fetch_fw (buf);

  01152	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0115a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0115f	8b c8		 mov	 ecx, eax
  01161	e8 00 00 00 00	 call	 _byteswap_ulong
  01166	89 44 24 58	 mov	 DWORD PTR rcd$[rsp], eax

; 1923 :         rc = (dev->hnd->read) (dev, rcd, &flag);

  0116a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01172	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01179	4c 8d 44 24 41	 lea	 r8, QWORD PTR flag$[rsp]
  0117e	8b 54 24 58	 mov	 edx, DWORD PTR rcd$[rsp]
  01182	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0118a	ff 50 50	 call	 QWORD PTR [rax+80]
  0118d	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1924 :         SHRDTRACE( "server request read rcd %d flag %2.2x rc=%d",

  01191	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  01196	8b 4c 24 48	 mov	 ecx, DWORD PTR rc$[rsp]
  0119a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0119e	44 8b c8	 mov	 r9d, eax
  011a1	44 8b 44 24 58	 mov	 r8d, DWORD PTR rcd$[rsp]
  011a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170118
  011ad	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011b5	e8 00 00 00 00	 call	 shrdtrc

; 1925 :                 rcd, flag, rc );
; 1926 : 
; 1927 :         if (rc < 0)

  011ba	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  011bf	7d 0a		 jge	 SHORT $LN112@serverRequ

; 1928 :             code = SHRD_IOERR;

  011c1	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR code$[rsp], 64 ; 00000040H
  011c9	eb 4e		 jmp	 SHORT $LN113@serverRequ
$LN112@serverRequ:

; 1929 :         else
; 1930 :         {
; 1931 :             code = dev->comp ? SHRD_COMP : 0;

  011cb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011d3	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  011da	74 0a		 je	 SHORT $LN135@serverRequ
  011dc	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR tv668[rsp], 16
  011e4	eb 08		 jmp	 SHORT $LN136@serverRequ
$LN135@serverRequ:
  011e6	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv668[rsp], 0
$LN136@serverRequ:
  011ee	8b 44 24 70	 mov	 eax, DWORD PTR tv668[rsp]
  011f2	89 44 24 50	 mov	 DWORD PTR code$[rsp], eax

; 1932 :             flag = (dev->comp << 4) | dev->compoff;

  011f6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011fe	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [rax+524]
  01204	c1 e0 04	 shl	 eax, 4
  01207	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0120f	0b 81 10 02 00
	00		 or	 eax, DWORD PTR [rcx+528]
  01215	88 44 24 41	 mov	 BYTE PTR flag$[rsp], al
$LN113@serverRequ:

; 1933 :         }
; 1934 : 
; 1935 :         /* Reset compression stuff */
; 1936 :         dev->comps = dev->comp = dev->compoff = 0;

  01219	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01221	c7 80 10 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+528], 0
  0122b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01233	c7 80 0c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+524], 0
  0123d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01245	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+520], 0
$LN35@serverRequ:

; 1937 : 
; 1938 :         SHRD_SET_HDR (hdr, code, flag, dev->devnum, id, dev->buflen);

  0124f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01257	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR shdr$10[rsp], rax
  0125f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR shdr$10[rsp]
  01267	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR code$[rsp]
  0126c	88 08		 mov	 BYTE PTR [rax], cl
  0126e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR shdr$10[rsp]
  01276	0f b6 4c 24 41	 movzx	 ecx, BYTE PTR flag$[rsp]
  0127b	88 48 01	 mov	 BYTE PTR [rax+1], cl
  0127e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01286	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0128a	e8 00 00 00 00	 call	 _byteswap_ushort
  0128f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR shdr$10[rsp]
  01297	48 83 c1 02	 add	 rcx, 2
  0129b	0f b7 d0	 movzx	 edx, ax
  0129e	e8 00 00 00 00	 call	 store_hw_noswap
  012a3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012ab	0f b7 88 dc 01
	00 00		 movzx	 ecx, WORD PTR [rax+476]
  012b2	e8 00 00 00 00	 call	 _byteswap_ushort
  012b7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR shdr$10[rsp]
  012bf	48 83 c1 04	 add	 rcx, 4
  012c3	0f b7 d0	 movzx	 edx, ax
  012c6	e8 00 00 00 00	 call	 store_hw_noswap
  012cb	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  012d0	e8 00 00 00 00	 call	 _byteswap_ushort
  012d5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR shdr$10[rsp]
  012dd	48 83 c1 06	 add	 rcx, 6
  012e1	0f b7 d0	 movzx	 edx, ax
  012e4	e8 00 00 00 00	 call	 store_hw_noswap
  012e9	33 c0		 xor	 eax, eax
  012eb	85 c0		 test	 eax, eax
  012ed	0f 85 5c ff ff
	ff		 jne	 $LN35@serverRequ

; 1939 :         serverSend (dev, ix, hdr, dev->buf, dev->buflen);

  012f3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012fb	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  01301	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01305	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0130d	4c 8b 88 c8 01
	00 00		 mov	 r9, QWORD PTR [rax+456]
  01314	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  0131c	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01323	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0132b	e8 00 00 00 00	 call	 serverSend

; 1940 : 
; 1941 :         break;

  01330	e9 05 0c 00 00	 jmp	 $LN5@serverRequ
$LN114@serverRequ:

; 1942 : 
; 1943 :     case SHRD_WRITE:
; 1944 :         /* Must be active on the device for this command */
; 1945 :         if (dev->shioactive != id)

  01335	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0133d	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  01341	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  01347	74 33		 je	 SHORT $LN115@serverRequ

; 1946 :         {
; 1947 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  01349	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  0134e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170123
  01355	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0135a	44 8b c8	 mov	 r9d, eax
  0135d	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  01363	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  0136a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01372	e8 00 00 00 00	 call	 serverError

; 1948 :                          "not active on this device");
; 1949 :             break;

  01377	e9 be 0b 00 00	 jmp	 $LN5@serverRequ
$LN115@serverRequ:

; 1950 :         }
; 1951 : 
; 1952 :         /* Call the I/O write exit */
; 1953 :         off = fetch_hw (buf);

  0137c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01384	e8 00 00 00 00	 call	 fetch_hw_noswap
  01389	0f b7 c8	 movzx	 ecx, ax
  0138c	e8 00 00 00 00	 call	 _byteswap_ushort
  01391	0f b7 c0	 movzx	 eax, ax
  01394	89 44 24 74	 mov	 DWORD PTR off$[rsp], eax

; 1954 :         rcd = fetch_fw (buf + 2);

  01398	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  013a0	48 83 c0 02	 add	 rax, 2
  013a4	48 8b c8	 mov	 rcx, rax
  013a7	e8 00 00 00 00	 call	 fetch_fw_noswap
  013ac	8b c8		 mov	 ecx, eax
  013ae	e8 00 00 00 00	 call	 _byteswap_ulong
  013b3	89 44 24 58	 mov	 DWORD PTR rcd$[rsp], eax

; 1955 : 
; 1956 :         rc = (dev->hnd->write) (dev, rcd, off, buf + 6, len - 6, &flag);

  013b7	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  013bb	83 e8 06	 sub	 eax, 6
  013be	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  013c6	48 83 c1 06	 add	 rcx, 6
  013ca	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  013d2	48 8b 92 90 02
	00 00		 mov	 rdx, QWORD PTR [rdx+656]
  013d9	48 89 94 24 18
	01 00 00	 mov	 QWORD PTR tv1161[rsp], rdx
  013e1	4c 8d 44 24 41	 lea	 r8, QWORD PTR flag$[rsp]
  013e6	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  013eb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  013ef	4c 8b c9	 mov	 r9, rcx
  013f2	44 8b 44 24 74	 mov	 r8d, DWORD PTR off$[rsp]
  013f7	8b 54 24 58	 mov	 edx, DWORD PTR rcd$[rsp]
  013fb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01403	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv1161[rsp]
  0140b	ff 50 58	 call	 QWORD PTR [rax+88]
  0140e	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1957 :         SHRDTRACE( "server request write rcd %d off %d len %d flag %2.2x rc=%d",

  01412	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  01417	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$[rsp]
  0141b	83 e9 06	 sub	 ecx, 6
  0141e	8b 54 24 48	 mov	 edx, DWORD PTR rc$[rsp]
  01422	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  01426	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0142a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0142e	44 8b 4c 24 74	 mov	 r9d, DWORD PTR off$[rsp]
  01433	44 8b 44 24 58	 mov	 r8d, DWORD PTR rcd$[rsp]
  01438	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170124
  0143f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01447	e8 00 00 00 00	 call	 shrdtrc

; 1958 :                 rcd, off, len - 6, flag, rc );
; 1959 : 
; 1960 :         if (rc < 0)

  0144c	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  01451	7d 0a		 jge	 SHORT $LN116@serverRequ

; 1961 :             code = SHRD_IOERR;

  01453	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR code$[rsp], 64 ; 00000040H
  0145b	eb 08		 jmp	 SHORT $LN117@serverRequ
$LN116@serverRequ:

; 1962 :         else
; 1963 :             code = 0;

  0145d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0
$LN117@serverRequ:
$LN38@serverRequ:

; 1964 : 
; 1965 :         /* Send response back */
; 1966 :         SHRD_SET_HDR (hdr, code, flag, dev->devnum, id, 0);

  01465	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0146d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR shdr$11[rsp], rax
  01475	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR shdr$11[rsp]
  0147d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR code$[rsp]
  01482	88 08		 mov	 BYTE PTR [rax], cl
  01484	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR shdr$11[rsp]
  0148c	0f b6 4c 24 41	 movzx	 ecx, BYTE PTR flag$[rsp]
  01491	88 48 01	 mov	 BYTE PTR [rax+1], cl
  01494	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0149c	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  014a0	e8 00 00 00 00	 call	 _byteswap_ushort
  014a5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR shdr$11[rsp]
  014ad	48 83 c1 02	 add	 rcx, 2
  014b1	0f b7 d0	 movzx	 edx, ax
  014b4	e8 00 00 00 00	 call	 store_hw_noswap
  014b9	33 c9		 xor	 ecx, ecx
  014bb	e8 00 00 00 00	 call	 _byteswap_ushort
  014c0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR shdr$11[rsp]
  014c8	48 83 c1 04	 add	 rcx, 4
  014cc	0f b7 d0	 movzx	 edx, ax
  014cf	e8 00 00 00 00	 call	 store_hw_noswap
  014d4	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  014d9	e8 00 00 00 00	 call	 _byteswap_ushort
  014de	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR shdr$11[rsp]
  014e6	48 83 c1 06	 add	 rcx, 6
  014ea	0f b7 d0	 movzx	 edx, ax
  014ed	e8 00 00 00 00	 call	 store_hw_noswap
  014f2	33 c0		 xor	 eax, eax
  014f4	85 c0		 test	 eax, eax
  014f6	0f 85 69 ff ff
	ff		 jne	 $LN38@serverRequ

; 1967 :         serverSend (dev, ix, hdr, NULL, 0);

  014fc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  01504	45 33 c9	 xor	 r9d, r9d
  01507	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  0150f	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01516	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0151e	e8 00 00 00 00	 call	 serverSend

; 1968 : 
; 1969 :         break;

  01523	e9 12 0a 00 00	 jmp	 $LN5@serverRequ
$LN118@serverRequ:

; 1970 : 
; 1971 :     case SHRD_SENSE:
; 1972 :         /* Must be active on the device for this command */
; 1973 :         if (dev->shioactive != id)

  01528	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01530	8b 4c 24 44	 mov	 ecx, DWORD PTR id$[rsp]
  01534	39 88 e4 05 00
	00		 cmp	 DWORD PTR [rax+1508], ecx
  0153a	74 33		 je	 SHORT $LN119@serverRequ

; 1974 :         {
; 1975 :             serverError (dev, ix, SHRD_ERROR_NOTACTIVE, cmd,

  0153c	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  01541	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170129
  01548	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0154d	44 8b c8	 mov	 r9d, eax
  01550	41 b8 f6 00 00
	00		 mov	 r8d, 246		; 000000f6H
  01556	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  0155d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01565	e8 00 00 00 00	 call	 serverError

; 1976 :                          "not active on this device");
; 1977 :             break;

  0156a	e9 cb 09 00 00	 jmp	 $LN5@serverRequ
$LN119@serverRequ:
$LN41@serverRequ:

; 1978 :         }
; 1979 : 
; 1980 :         /* Send the sense */
; 1981 :         SHRD_SET_HDR (hdr, 0, CSW_CE | CSW_DE, dev->devnum, id, dev->numsense);

  0156f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01577	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR shdr$12[rsp], rax
  0157f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR shdr$12[rsp]
  01587	c6 00 00	 mov	 BYTE PTR [rax], 0
  0158a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR shdr$12[rsp]
  01592	c6 40 01 0c	 mov	 BYTE PTR [rax+1], 12
  01596	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0159e	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  015a2	e8 00 00 00 00	 call	 _byteswap_ushort
  015a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR shdr$12[rsp]
  015af	48 83 c1 02	 add	 rcx, 2
  015b3	0f b7 d0	 movzx	 edx, ax
  015b6	e8 00 00 00 00	 call	 store_hw_noswap
  015bb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015c3	0f b7 88 60 03
	00 00		 movzx	 ecx, WORD PTR [rax+864]
  015ca	e8 00 00 00 00	 call	 _byteswap_ushort
  015cf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR shdr$12[rsp]
  015d7	48 83 c1 04	 add	 rcx, 4
  015db	0f b7 d0	 movzx	 edx, ax
  015de	e8 00 00 00 00	 call	 store_hw_noswap
  015e3	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  015e8	e8 00 00 00 00	 call	 _byteswap_ushort
  015ed	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR shdr$12[rsp]
  015f5	48 83 c1 06	 add	 rcx, 6
  015f9	0f b7 d0	 movzx	 edx, ax
  015fc	e8 00 00 00 00	 call	 store_hw_noswap
  01601	33 c0		 xor	 eax, eax
  01603	85 c0		 test	 eax, eax
  01605	0f 85 64 ff ff
	ff		 jne	 $LN41@serverRequ

; 1982 :         serverSend (dev, ix, hdr, dev->sense, dev->numsense);

  0160b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01613	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  01619	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01621	8b 89 60 03 00
	00		 mov	 ecx, DWORD PTR [rcx+864]
  01627	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0162b	4c 8b c8	 mov	 r9, rax
  0162e	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01636	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  0163d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01645	e8 00 00 00 00	 call	 serverSend

; 1983 :         memset (dev->sense, 0, sizeof(dev->sense));

  0164a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01652	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  01658	48 8b f8	 mov	 rdi, rax
  0165b	33 c0		 xor	 eax, eax
  0165d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  01662	f3 aa		 rep stosb

; 1984 :         dev->sns_pending = 0;

  01664	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0166c	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  01672	83 e0 fb	 and	 eax, -5			; fffffffbH
  01675	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0167d	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 1985 :         break;

  01683	e9 b2 08 00 00	 jmp	 $LN5@serverRequ
$LN120@serverRequ:

; 1986 : 
; 1987 :     case SHRD_QUERY:
; 1988 :         switch (flag) {

  01688	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  0168d	89 44 24 5c	 mov	 DWORD PTR tv843[rsp], eax
  01691	8b 44 24 5c	 mov	 eax, DWORD PTR tv843[rsp]
  01695	83 e8 41	 sub	 eax, 65			; 00000041H
  01698	89 44 24 5c	 mov	 DWORD PTR tv843[rsp], eax
  0169c	83 7c 24 5c 0d	 cmp	 DWORD PTR tv843[rsp], 13
  016a1	0f 87 4a 07 00
	00		 ja	 $LN131@serverRequ
  016a7	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv843[rsp]
  016ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  016b3	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN137@serverRequ[rcx+rax*4]
  016ba	48 03 c1	 add	 rax, rcx
  016bd	ff e0		 jmp	 rax
$LN121@serverRequ:

; 1989 : 
; 1990 :         case SHRD_USED:
; 1991 :             if (dev->hnd->used)

  016bf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016c7	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  016ce	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  016d3	74 20		 je	 SHORT $LN122@serverRequ

; 1992 :                 rc = (dev->hnd->used) (dev);

  016d5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016dd	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  016e4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016ec	ff 50 60	 call	 QWORD PTR [rax+96]
  016ef	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax
  016f3	eb 08		 jmp	 SHORT $LN123@serverRequ
$LN122@serverRequ:

; 1993 :             else
; 1994 :                 rc = 0;

  016f5	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN123@serverRequ:

; 1995 :             store_fw (buf, rc);

  016fd	8b 4c 24 48	 mov	 ecx, DWORD PTR rc$[rsp]
  01701	e8 00 00 00 00	 call	 _byteswap_ulong
  01706	8b d0		 mov	 edx, eax
  01708	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01710	e8 00 00 00 00	 call	 store_fw_noswap
$LN46@serverRequ:

; 1996 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 4);

  01715	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0171d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR shdr$13[rsp], rax
  01725	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR shdr$13[rsp]
  0172d	c6 00 00	 mov	 BYTE PTR [rax], 0
  01730	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR shdr$13[rsp]
  01738	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  0173c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01744	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01748	e8 00 00 00 00	 call	 _byteswap_ushort
  0174d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR shdr$13[rsp]
  01755	48 83 c1 02	 add	 rcx, 2
  01759	0f b7 d0	 movzx	 edx, ax
  0175c	e8 00 00 00 00	 call	 store_hw_noswap
  01761	66 b9 04 00	 mov	 cx, 4
  01765	e8 00 00 00 00	 call	 _byteswap_ushort
  0176a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR shdr$13[rsp]
  01772	48 83 c1 04	 add	 rcx, 4
  01776	0f b7 d0	 movzx	 edx, ax
  01779	e8 00 00 00 00	 call	 store_hw_noswap
  0177e	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01783	e8 00 00 00 00	 call	 _byteswap_ushort
  01788	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR shdr$13[rsp]
  01790	48 83 c1 06	 add	 rcx, 6
  01794	0f b7 d0	 movzx	 edx, ax
  01797	e8 00 00 00 00	 call	 store_hw_noswap
  0179c	33 c0		 xor	 eax, eax
  0179e	85 c0		 test	 eax, eax
  017a0	0f 85 6f ff ff
	ff		 jne	 $LN46@serverRequ

; 1997 :             serverSend (dev, ix, hdr, buf, 4);

  017a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  017ae	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  017b6	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  017be	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  017c5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  017cd	e8 00 00 00 00	 call	 serverSend

; 1998 :             break;

  017d2	e9 48 06 00 00	 jmp	 $LN42@serverRequ
$LN124@serverRequ:
$LN49@serverRequ:

; 1999 : 
; 2000 :         case SHRD_DEVCHAR:
; 2001 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, dev->numdevchar);

  017d7	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  017df	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR shdr$14[rsp], rax
  017e7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR shdr$14[rsp]
  017ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  017f2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR shdr$14[rsp]
  017fa	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  017fe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01806	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  0180a	e8 00 00 00 00	 call	 _byteswap_ushort
  0180f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR shdr$14[rsp]
  01817	48 83 c1 02	 add	 rcx, 2
  0181b	0f b7 d0	 movzx	 edx, ax
  0181e	e8 00 00 00 00	 call	 store_hw_noswap
  01823	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0182b	0f b7 88 68 05
	00 00		 movzx	 ecx, WORD PTR [rax+1384]
  01832	e8 00 00 00 00	 call	 _byteswap_ushort
  01837	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR shdr$14[rsp]
  0183f	48 83 c1 04	 add	 rcx, 4
  01843	0f b7 d0	 movzx	 edx, ax
  01846	e8 00 00 00 00	 call	 store_hw_noswap
  0184b	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01850	e8 00 00 00 00	 call	 _byteswap_ushort
  01855	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR shdr$14[rsp]
  0185d	48 83 c1 06	 add	 rcx, 6
  01861	0f b7 d0	 movzx	 edx, ax
  01864	e8 00 00 00 00	 call	 store_hw_noswap
  01869	33 c0		 xor	 eax, eax
  0186b	85 c0		 test	 eax, eax
  0186d	0f 85 64 ff ff
	ff		 jne	 $LN49@serverRequ

; 2002 :             serverSend (dev, ix, hdr, dev->devchar, dev->numdevchar);

  01873	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0187b	48 05 6c 05 00
	00		 add	 rax, 1388		; 0000056cH
  01881	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01889	8b 89 68 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1384]
  0188f	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01893	4c 8b c8	 mov	 r9, rax
  01896	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  0189e	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  018a5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  018ad	e8 00 00 00 00	 call	 serverSend

; 2003 :             break;

  018b2	e9 68 05 00 00	 jmp	 $LN42@serverRequ
$LN125@serverRequ:
$LN52@serverRequ:

; 2004 : 
; 2005 :         case SHRD_DEVID:
; 2006 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, dev->numdevid);

  018b7	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  018bf	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR shdr$15[rsp], rax
  018c7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR shdr$15[rsp]
  018cf	c6 00 00	 mov	 BYTE PTR [rax], 0
  018d2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR shdr$15[rsp]
  018da	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  018de	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018e6	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  018ea	e8 00 00 00 00	 call	 _byteswap_ushort
  018ef	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR shdr$15[rsp]
  018f7	48 83 c1 02	 add	 rcx, 2
  018fb	0f b7 d0	 movzx	 edx, ax
  018fe	e8 00 00 00 00	 call	 store_hw_noswap
  01903	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0190b	0f b7 88 64 04
	00 00		 movzx	 ecx, WORD PTR [rax+1124]
  01912	e8 00 00 00 00	 call	 _byteswap_ushort
  01917	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR shdr$15[rsp]
  0191f	48 83 c1 04	 add	 rcx, 4
  01923	0f b7 d0	 movzx	 edx, ax
  01926	e8 00 00 00 00	 call	 store_hw_noswap
  0192b	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01930	e8 00 00 00 00	 call	 _byteswap_ushort
  01935	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR shdr$15[rsp]
  0193d	48 83 c1 06	 add	 rcx, 6
  01941	0f b7 d0	 movzx	 edx, ax
  01944	e8 00 00 00 00	 call	 store_hw_noswap
  01949	33 c0		 xor	 eax, eax
  0194b	85 c0		 test	 eax, eax
  0194d	0f 85 64 ff ff
	ff		 jne	 $LN52@serverRequ

; 2007 :             serverSend (dev, ix, hdr, dev->devid, dev->numdevid);

  01953	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0195b	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  01961	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01969	8b 89 64 04 00
	00		 mov	 ecx, DWORD PTR [rcx+1124]
  0196f	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01973	4c 8b c8	 mov	 r9, rax
  01976	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  0197e	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01985	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0198d	e8 00 00 00 00	 call	 serverSend

; 2008 :             break;

  01992	e9 88 04 00 00	 jmp	 $LN42@serverRequ
$LN126@serverRequ:
$LN55@serverRequ:

; 2009 : 
; 2010 :         case SHRD_SERIAL:
; 2011 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, sizeof( dev->serial ));

  01997	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0199f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR shdr$16[rsp], rax
  019a7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR shdr$16[rsp]
  019af	c6 00 00	 mov	 BYTE PTR [rax], 0
  019b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR shdr$16[rsp]
  019ba	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  019be	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  019c6	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  019ca	e8 00 00 00 00	 call	 _byteswap_ushort
  019cf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR shdr$16[rsp]
  019d7	48 83 c1 02	 add	 rcx, 2
  019db	0f b7 d0	 movzx	 edx, ax
  019de	e8 00 00 00 00	 call	 store_hw_noswap
  019e3	66 b9 0c 00	 mov	 cx, 12
  019e7	e8 00 00 00 00	 call	 _byteswap_ushort
  019ec	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR shdr$16[rsp]
  019f4	48 83 c1 04	 add	 rcx, 4
  019f8	0f b7 d0	 movzx	 edx, ax
  019fb	e8 00 00 00 00	 call	 store_hw_noswap
  01a00	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01a05	e8 00 00 00 00	 call	 _byteswap_ushort
  01a0a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR shdr$16[rsp]
  01a12	48 83 c1 06	 add	 rcx, 6
  01a16	0f b7 d0	 movzx	 edx, ax
  01a19	e8 00 00 00 00	 call	 store_hw_noswap
  01a1e	33 c0		 xor	 eax, eax
  01a20	85 c0		 test	 eax, eax
  01a22	0f 85 6f ff ff
	ff		 jne	 $LN55@serverRequ

; 2012 :             serverSend (dev, ix, hdr, dev->serial, (U32)sizeof( dev->serial ));

  01a28	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a30	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  01a36	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR [rsp+32], 12
  01a3e	4c 8b c8	 mov	 r9, rax
  01a41	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01a49	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01a50	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a58	e8 00 00 00 00	 call	 serverSend

; 2013 :             break;

  01a5d	e9 bd 03 00 00	 jmp	 $LN42@serverRequ
$LN127@serverRequ:

; 2014 : 
; 2015 :         case SHRD_CKDCYLS:
; 2016 :             store_fw (buf, dev->ckdcyls);

  01a62	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a6a	8b 88 b8 12 00
	00		 mov	 ecx, DWORD PTR [rax+4792]
  01a70	e8 00 00 00 00	 call	 _byteswap_ulong
  01a75	8b d0		 mov	 edx, eax
  01a77	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01a7f	e8 00 00 00 00	 call	 store_fw_noswap
$LN58@serverRequ:

; 2017 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 4);

  01a84	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01a8c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR shdr$17[rsp], rax
  01a94	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR shdr$17[rsp]
  01a9c	c6 00 00	 mov	 BYTE PTR [rax], 0
  01a9f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR shdr$17[rsp]
  01aa7	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  01aab	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ab3	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01ab7	e8 00 00 00 00	 call	 _byteswap_ushort
  01abc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR shdr$17[rsp]
  01ac4	48 83 c1 02	 add	 rcx, 2
  01ac8	0f b7 d0	 movzx	 edx, ax
  01acb	e8 00 00 00 00	 call	 store_hw_noswap
  01ad0	66 b9 04 00	 mov	 cx, 4
  01ad4	e8 00 00 00 00	 call	 _byteswap_ushort
  01ad9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR shdr$17[rsp]
  01ae1	48 83 c1 04	 add	 rcx, 4
  01ae5	0f b7 d0	 movzx	 edx, ax
  01ae8	e8 00 00 00 00	 call	 store_hw_noswap
  01aed	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01af2	e8 00 00 00 00	 call	 _byteswap_ushort
  01af7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR shdr$17[rsp]
  01aff	48 83 c1 06	 add	 rcx, 6
  01b03	0f b7 d0	 movzx	 edx, ax
  01b06	e8 00 00 00 00	 call	 store_hw_noswap
  01b0b	33 c0		 xor	 eax, eax
  01b0d	85 c0		 test	 eax, eax
  01b0f	0f 85 6f ff ff
	ff		 jne	 $LN58@serverRequ

; 2018 :             serverSend (dev, ix, hdr, buf, 4);

  01b15	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  01b1d	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  01b25	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01b2d	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01b34	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01b3c	e8 00 00 00 00	 call	 serverSend

; 2019 :             break;

  01b41	e9 d9 02 00 00	 jmp	 $LN42@serverRequ
$LN128@serverRequ:

; 2020 : 
; 2021 :         case SHRD_FBAORIGIN:
; 2022 :             store_dw( buf, dev->fbaorigin );

  01b46	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b4e	48 8b 88 90 11
	00 00		 mov	 rcx, QWORD PTR [rax+4496]
  01b55	e8 00 00 00 00	 call	 _byteswap_uint64
  01b5a	48 8b d0	 mov	 rdx, rax
  01b5d	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01b65	e8 00 00 00 00	 call	 store_dw_noswap
$LN61@serverRequ:

; 2023 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 4);

  01b6a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01b72	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR shdr$18[rsp], rax
  01b7a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR shdr$18[rsp]
  01b82	c6 00 00	 mov	 BYTE PTR [rax], 0
  01b85	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR shdr$18[rsp]
  01b8d	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  01b91	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b99	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01b9d	e8 00 00 00 00	 call	 _byteswap_ushort
  01ba2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR shdr$18[rsp]
  01baa	48 83 c1 02	 add	 rcx, 2
  01bae	0f b7 d0	 movzx	 edx, ax
  01bb1	e8 00 00 00 00	 call	 store_hw_noswap
  01bb6	66 b9 04 00	 mov	 cx, 4
  01bba	e8 00 00 00 00	 call	 _byteswap_ushort
  01bbf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR shdr$18[rsp]
  01bc7	48 83 c1 04	 add	 rcx, 4
  01bcb	0f b7 d0	 movzx	 edx, ax
  01bce	e8 00 00 00 00	 call	 store_hw_noswap
  01bd3	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01bd8	e8 00 00 00 00	 call	 _byteswap_ushort
  01bdd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR shdr$18[rsp]
  01be5	48 83 c1 06	 add	 rcx, 6
  01be9	0f b7 d0	 movzx	 edx, ax
  01bec	e8 00 00 00 00	 call	 store_hw_noswap
  01bf1	33 c0		 xor	 eax, eax
  01bf3	85 c0		 test	 eax, eax
  01bf5	0f 85 6f ff ff
	ff		 jne	 $LN61@serverRequ

; 2024 :             serverSend (dev, ix, hdr, buf, 4);

  01bfb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  01c03	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  01c0b	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01c13	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01c1a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c22	e8 00 00 00 00	 call	 serverSend

; 2025 :             break;

  01c27	e9 f3 01 00 00	 jmp	 $LN42@serverRequ
$LN129@serverRequ:

; 2026 : 
; 2027 :         case SHRD_FBANUMBLK:
; 2028 :             store_fw (buf, dev->fbanumblk);

  01c2c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01c34	8b 88 88 11 00
	00		 mov	 ecx, DWORD PTR [rax+4488]
  01c3a	e8 00 00 00 00	 call	 _byteswap_ulong
  01c3f	8b d0		 mov	 edx, eax
  01c41	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01c49	e8 00 00 00 00	 call	 store_fw_noswap
$LN64@serverRequ:

; 2029 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 4);

  01c4e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01c56	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR shdr$19[rsp], rax
  01c5e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR shdr$19[rsp]
  01c66	c6 00 00	 mov	 BYTE PTR [rax], 0
  01c69	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR shdr$19[rsp]
  01c71	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  01c75	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01c7d	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01c81	e8 00 00 00 00	 call	 _byteswap_ushort
  01c86	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR shdr$19[rsp]
  01c8e	48 83 c1 02	 add	 rcx, 2
  01c92	0f b7 d0	 movzx	 edx, ax
  01c95	e8 00 00 00 00	 call	 store_hw_noswap
  01c9a	66 b9 04 00	 mov	 cx, 4
  01c9e	e8 00 00 00 00	 call	 _byteswap_ushort
  01ca3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR shdr$19[rsp]
  01cab	48 83 c1 04	 add	 rcx, 4
  01caf	0f b7 d0	 movzx	 edx, ax
  01cb2	e8 00 00 00 00	 call	 store_hw_noswap
  01cb7	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01cbc	e8 00 00 00 00	 call	 _byteswap_ushort
  01cc1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR shdr$19[rsp]
  01cc9	48 83 c1 06	 add	 rcx, 6
  01ccd	0f b7 d0	 movzx	 edx, ax
  01cd0	e8 00 00 00 00	 call	 store_hw_noswap
  01cd5	33 c0		 xor	 eax, eax
  01cd7	85 c0		 test	 eax, eax
  01cd9	0f 85 6f ff ff
	ff		 jne	 $LN64@serverRequ

; 2030 :             serverSend (dev, ix, hdr, buf, 4);

  01cdf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  01ce7	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  01cef	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01cf7	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01cfe	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01d06	e8 00 00 00 00	 call	 serverSend

; 2031 :             break;

  01d0b	e9 0f 01 00 00	 jmp	 $LN42@serverRequ
$LN130@serverRequ:

; 2032 : 
; 2033 :         case SHRD_FBABLKSIZ:
; 2034 :             store_fw (buf, dev->fbablksiz);

  01d10	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d18	8b 88 8c 11 00
	00		 mov	 ecx, DWORD PTR [rax+4492]
  01d1e	e8 00 00 00 00	 call	 _byteswap_ulong
  01d23	8b d0		 mov	 edx, eax
  01d25	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01d2d	e8 00 00 00 00	 call	 store_fw_noswap
$LN67@serverRequ:

; 2035 :             SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 4);

  01d32	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01d3a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR shdr$20[rsp], rax
  01d42	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR shdr$20[rsp]
  01d4a	c6 00 00	 mov	 BYTE PTR [rax], 0
  01d4d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR shdr$20[rsp]
  01d55	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  01d59	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d61	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01d65	e8 00 00 00 00	 call	 _byteswap_ushort
  01d6a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR shdr$20[rsp]
  01d72	48 83 c1 02	 add	 rcx, 2
  01d76	0f b7 d0	 movzx	 edx, ax
  01d79	e8 00 00 00 00	 call	 store_hw_noswap
  01d7e	66 b9 04 00	 mov	 cx, 4
  01d82	e8 00 00 00 00	 call	 _byteswap_ushort
  01d87	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR shdr$20[rsp]
  01d8f	48 83 c1 04	 add	 rcx, 4
  01d93	0f b7 d0	 movzx	 edx, ax
  01d96	e8 00 00 00 00	 call	 store_hw_noswap
  01d9b	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01da0	e8 00 00 00 00	 call	 _byteswap_ushort
  01da5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR shdr$20[rsp]
  01dad	48 83 c1 06	 add	 rcx, 6
  01db1	0f b7 d0	 movzx	 edx, ax
  01db4	e8 00 00 00 00	 call	 store_hw_noswap
  01db9	33 c0		 xor	 eax, eax
  01dbb	85 c0		 test	 eax, eax
  01dbd	0f 85 6f ff ff
	ff		 jne	 $LN67@serverRequ

; 2036 :             serverSend (dev, ix, hdr, buf, 4);

  01dc3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  01dcb	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  01dd3	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01ddb	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01de2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01dea	e8 00 00 00 00	 call	 serverSend

; 2037 :             break;

  01def	eb 2e		 jmp	 SHORT $LN42@serverRequ
$LN131@serverRequ:

; 2038 : 
; 2039 :         default:
; 2040 :             serverError (dev, ix, SHRD_ERROR_INVALID, cmd,

  01df1	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  01df6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170142
  01dfd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01e02	44 8b c8	 mov	 r9d, eax
  01e05	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  01e0b	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01e12	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01e1a	e8 00 00 00 00	 call	 serverError
$LN42@serverRequ:

; 2041 :                          "invalid query request");
; 2042 :             break;
; 2043 :         } /* switch (flag) for SHRD_QUERY */
; 2044 :         break;

  01e1f	e9 16 01 00 00	 jmp	 $LN5@serverRequ
$LN132@serverRequ:

; 2045 : 
; 2046 :     case SHRD_COMPRESS:
; 2047 : #if defined( HAVE_ZLIB )
; 2048 :         dev->shrd[ix]->comp = (flag & 0x0f);
; 2049 :         store_hw (buf, dev->shrd[ix]->comp);
; 2050 : #else
; 2051 :         store_hw (buf, 0);

  01e24	33 c9		 xor	 ecx, ecx
  01e26	e8 00 00 00 00	 call	 _byteswap_ushort
  01e2b	0f b7 d0	 movzx	 edx, ax
  01e2e	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  01e36	e8 00 00 00 00	 call	 store_hw_noswap

; 2052 : #endif
; 2053 :         dev->shrd[ix]->comps = (flag & 0xf0) >> 4;

  01e3b	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  01e40	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01e45	c1 f8 04	 sar	 eax, 4
  01e48	48 63 8c 24 68
	01 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  01e50	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01e58	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  01e60	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN70@serverRequ:

; 2054 :         SHRD_SET_HDR (hdr, 0, 0, dev->devnum, id, 2);

  01e63	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01e6b	48 89 44 24 68	 mov	 QWORD PTR shdr$1[rsp], rax
  01e70	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  01e75	c6 00 00	 mov	 BYTE PTR [rax], 0
  01e78	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  01e7d	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  01e81	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e89	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  01e8d	e8 00 00 00 00	 call	 _byteswap_ushort
  01e92	48 8b 4c 24 68	 mov	 rcx, QWORD PTR shdr$1[rsp]
  01e97	48 83 c1 02	 add	 rcx, 2
  01e9b	0f b7 d0	 movzx	 edx, ax
  01e9e	e8 00 00 00 00	 call	 store_hw_noswap
  01ea3	66 b9 02 00	 mov	 cx, 2
  01ea7	e8 00 00 00 00	 call	 _byteswap_ushort
  01eac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR shdr$1[rsp]
  01eb1	48 83 c1 04	 add	 rcx, 4
  01eb5	0f b7 d0	 movzx	 edx, ax
  01eb8	e8 00 00 00 00	 call	 store_hw_noswap
  01ebd	0f b7 4c 24 44	 movzx	 ecx, WORD PTR id$[rsp]
  01ec2	e8 00 00 00 00	 call	 _byteswap_ushort
  01ec7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR shdr$1[rsp]
  01ecc	48 83 c1 06	 add	 rcx, 6
  01ed0	0f b7 d0	 movzx	 edx, ax
  01ed3	e8 00 00 00 00	 call	 store_hw_noswap
  01ed8	33 c0		 xor	 eax, eax
  01eda	85 c0		 test	 eax, eax
  01edc	75 85		 jne	 SHORT $LN70@serverRequ

; 2055 :         serverSend (dev, ix, hdr, buf, 2);

  01ede	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  01ee6	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  01eee	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  01ef6	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01efd	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01f05	e8 00 00 00 00	 call	 serverSend

; 2056 :         break;

  01f0a	eb 2e		 jmp	 SHORT $LN5@serverRequ
$LN133@serverRequ:

; 2057 : 
; 2058 :     default:
; 2059 :         serverError (dev, ix, SHRD_ERROR_INVALID, cmd,

  01f0c	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  01f11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170145
  01f18	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01f1d	44 8b c8	 mov	 r9d, eax
  01f20	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  01f26	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR ix$[rsp]
  01f2d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01f35	e8 00 00 00 00	 call	 serverError
$LN5@serverRequ:

; 2060 :                      "invalid request");
; 2061 :         break;
; 2062 :     } /* switch (cmd) */
; 2063 : } /* serverRequest */

  01f3a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01f42	48 33 cc	 xor	 rcx, rsp
  01f45	e8 00 00 00 00	 call	 __security_check_cookie
  01f4a	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  01f51	5f		 pop	 rdi
  01f52	c3		 ret	 0
  01f53	90		 npad	 1
$LN138@serverRequ:
  01f54	00 00 00 00	 DD	 $LN71@serverRequ
  01f58	00 00 00 00	 DD	 $LN74@serverRequ
  01f5c	00 00 00 00	 DD	 $LN79@serverRequ
  01f60	00 00 00 00	 DD	 $LN93@serverRequ
  01f64	00 00 00 00	 DD	 $LN80@serverRequ
  01f68	00 00 00 00	 DD	 $LN94@serverRequ
  01f6c	00 00 00 00	 DD	 $LN104@serverRequ
  01f70	00 00 00 00	 DD	 $LN107@serverRequ
  01f74	00 00 00 00	 DD	 $LN110@serverRequ
  01f78	00 00 00 00	 DD	 $LN114@serverRequ
  01f7c	00 00 00 00	 DD	 $LN118@serverRequ
  01f80	00 00 00 00	 DD	 $LN120@serverRequ
  01f84	00 00 00 00	 DD	 $LN132@serverRequ
$LN137@serverRequ:
  01f88	00 00 00 00	 DD	 $LN124@serverRequ
  01f8c	00 00 00 00	 DD	 $LN125@serverRequ
  01f90	00 00 00 00	 DD	 $LN121@serverRequ
  01f94	00 00 00 00	 DD	 $LN126@serverRequ
  01f98	00 00 00 00	 DD	 $LN131@serverRequ
  01f9c	00 00 00 00	 DD	 $LN131@serverRequ
  01fa0	00 00 00 00	 DD	 $LN131@serverRequ
  01fa4	00 00 00 00	 DD	 $LN127@serverRequ
  01fa8	00 00 00 00	 DD	 $LN131@serverRequ
  01fac	00 00 00 00	 DD	 $LN131@serverRequ
  01fb0	00 00 00 00	 DD	 $LN131@serverRequ
  01fb4	00 00 00 00	 DD	 $LN128@serverRequ
  01fb8	00 00 00 00	 DD	 $LN129@serverRequ
  01fbc	00 00 00 00	 DD	 $LN130@serverRequ
serverRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
cmd$ = 64
flag$ = 65
recvlen$ = 68
rc$ = 72
len$ = 76
rlen$ = 80
comp$ = 84
devnum$ = 88
tv154 = 92
tv177 = 96
shdr$1 = 104
shdr$2 = 112
off$ = 120
id$ = 124
recvbuf$ = 128
dev$ = 136
tv75 = 144
tv164 = 152
buf$3 = 160
cbuf$ = 416
__$ArrayPad$ = 65952
sock$ = 65984
hdr$ = 65992
buf$ = 66000
buflen$ = 66008
server$ = 66016
recvData PROC

; 1485 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	b8 b8 01 01 00	 mov	 eax, 65976		; 000101b8H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 a0
	01 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1486 : int                     rc;             /* Return code               */
; 1487 : int                     rlen;           /* Data length to recv       */
; 1488 : int                     recvlen;        /* Total length              */
; 1489 : BYTE                   *recvbuf;        /* Receive buffer            */
; 1490 : BYTE                    cmd;            /* Header command            */
; 1491 : BYTE                    flag;           /* Header flags              */
; 1492 : U16                     devnum;         /* Header device number      */
; 1493 : int                     id;             /* Header identifier         */
; 1494 : int                     len;            /* Header length             */
; 1495 : int                     comp = 0;       /* Compression type          */

  00032	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR comp$[rsp], 0

; 1496 : int                     off = 0;        /* Offset to compressed data */

  0003a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR off$[rsp], 0

; 1497 : DEVBLK                 *dev = NULL;     /* For 'SHRDTRACE'             */

  00042	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR dev$[rsp], 0

; 1498 : BYTE                    cbuf[65536];    /* Compressed buffer         */
; 1499 : 
; 1500 : 
; 1501 :     /* Receive the header */
; 1502 :     for (recvlen = 0; recvlen < (int)SHRD_HDR_SIZE; recvlen += rc)

  0004e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR recvlen$[rsp], 0
  00056	eb 10		 jmp	 SHORT $LN4@recvData
$LN2@recvData:
  00058	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  0005c	8b 4c 24 44	 mov	 ecx, DWORD PTR recvlen$[rsp]
  00060	03 c8		 add	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	89 44 24 44	 mov	 DWORD PTR recvlen$[rsp], eax
$LN4@recvData:
  00068	83 7c 24 44 08	 cmp	 DWORD PTR recvlen$[rsp], 8
  0006d	7d 7d		 jge	 SHORT $LN3@recvData

; 1503 :     {
; 1504 :         rc = recv (sock, hdr + recvlen, SHRD_HDR_SIZE - recvlen, 0);

  0006f	48 63 44 24 44	 movsxd	 rax, DWORD PTR recvlen$[rsp]
  00074	b9 08 00 00 00	 mov	 ecx, 8
  00079	48 2b c8	 sub	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR recvlen$[rsp]
  00084	48 8b 94 24 c8
	01 01 00	 mov	 rdx, QWORD PTR hdr$[rsp]
  0008c	48 03 d1	 add	 rdx, rcx
  0008f	48 8b ca	 mov	 rcx, rdx
  00092	48 63 94 24 c0
	01 01 00	 movsxd	 rdx, DWORD PTR sock$[rsp]
  0009a	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv75[rsp], rdx
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	44 8b c0	 mov	 r8d, eax
  000a8	48 8b d1	 mov	 rdx, rcx
  000ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  000bc	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1505 :         if (rc < 0)

  000c0	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  000c5	7d 0f		 jge	 SHORT $LN17@recvData

; 1506 :             return -HSO_errno;

  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000cd	f7 d8		 neg	 eax
  000cf	e9 30 04 00 00	 jmp	 $LN1@recvData
  000d4	eb 11		 jmp	 SHORT $LN18@recvData
$LN17@recvData:

; 1507 :         else if (rc == 0)

  000d6	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  000db	75 0a		 jne	 SHORT $LN19@recvData

; 1508 :             return -HSO_ENOTCONN;

  000dd	b8 b7 d8 ff ff	 mov	 eax, -10057		; ffffffffffffd8b7H
  000e2	e9 1d 04 00 00	 jmp	 $LN1@recvData
$LN19@recvData:
$LN18@recvData:

; 1509 :     }

  000e7	e9 6c ff ff ff	 jmp	 $LN2@recvData
$LN3@recvData:
$LN7@recvData:

; 1510 : 
; 1511 :     SHRD_GET_HDR (hdr, cmd, flag, devnum, id, len);

  000ec	48 8b 84 24 c8
	01 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  000f4	48 89 44 24 68	 mov	 QWORD PTR shdr$1[rsp], rax
  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  000fe	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00101	88 44 24 40	 mov	 BYTE PTR cmd$[rsp], al
  00105	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  0010a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0010e	88 44 24 41	 mov	 BYTE PTR flag$[rsp], al
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00117	48 83 c0 02	 add	 rax, 2
  0011b	48 8b c8	 mov	 rcx, rax
  0011e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00123	0f b7 c8	 movzx	 ecx, ax
  00126	e8 00 00 00 00	 call	 _byteswap_ushort
  0012b	66 89 44 24 58	 mov	 WORD PTR devnum$[rsp], ax
  00130	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00135	48 83 c0 04	 add	 rax, 4
  00139	48 8b c8	 mov	 rcx, rax
  0013c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00141	0f b7 c8	 movzx	 ecx, ax
  00144	e8 00 00 00 00	 call	 _byteswap_ushort
  00149	0f b7 c0	 movzx	 eax, ax
  0014c	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR shdr$1[rsp]
  00155	48 83 c0 06	 add	 rax, 6
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00161	0f b7 c8	 movzx	 ecx, ax
  00164	e8 00 00 00 00	 call	 _byteswap_ushort
  00169	0f b7 c0	 movzx	 eax, ax
  0016c	89 44 24 7c	 mov	 DWORD PTR id$[rsp], eax
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	0f 85 72 ff ff
	ff		 jne	 $LN7@recvData

; 1512 :     SHRDHDRTRACE( "recvData", hdr );

  0017a	45 33 c9	 xor	 r9d, r9d
  0017d	4c 8b 84 24 c8
	01 01 00	 mov	 r8, QWORD PTR hdr$[rsp]
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169759
  0018c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00194	e8 00 00 00 00	 call	 shrdhdrtrc

; 1513 : 
; 1514 :     /* Return if no data */
; 1515 :     if (len == 0) return 0;

  00199	83 7c 24 4c 00	 cmp	 DWORD PTR len$[rsp], 0
  0019e	75 07		 jne	 SHORT $LN20@recvData
  001a0	33 c0		 xor	 eax, eax
  001a2	e9 5d 03 00 00	 jmp	 $LN1@recvData
$LN20@recvData:

; 1516 : 
; 1517 :     /* Check for compressed data */
; 1518 :     if ((server && (cmd & SHRD_COMP))
; 1519 :      || (!server && cmd == SHRD_COMP))

  001a7	83 bc 24 e0 01
	01 00 00	 cmp	 DWORD PTR server$[rsp], 0
  001af	74 0c		 je	 SHORT $LN24@recvData
  001b1	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  001b6	83 e0 10	 and	 eax, 16
  001b9	85 c0		 test	 eax, eax
  001bb	75 14		 jne	 SHORT $LN23@recvData
$LN24@recvData:
  001bd	83 bc 24 e0 01
	01 00 00	 cmp	 DWORD PTR server$[rsp], 0
  001c5	75 50		 jne	 SHORT $LN21@recvData
  001c7	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  001cc	83 f8 10	 cmp	 eax, 16
  001cf	75 46		 jne	 SHORT $LN21@recvData
$LN23@recvData:

; 1520 :     {
; 1521 :         comp = (flag & SHRD_COMP_MASK) >> 4;

  001d1	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  001d6	83 e0 30	 and	 eax, 48			; 00000030H
  001d9	c1 f8 04	 sar	 eax, 4
  001dc	89 44 24 54	 mov	 DWORD PTR comp$[rsp], eax

; 1522 :         off = flag & SHRD_COMP_OFF;

  001e0	0f b6 44 24 41	 movzx	 eax, BYTE PTR flag$[rsp]
  001e5	83 e0 0f	 and	 eax, 15
  001e8	89 44 24 78	 mov	 DWORD PTR off$[rsp], eax

; 1523 :         cmd &= ~SHRD_COMP;

  001ec	0f b6 44 24 40	 movzx	 eax, BYTE PTR cmd$[rsp]
  001f1	83 e0 ef	 and	 eax, -17
  001f4	88 44 24 40	 mov	 BYTE PTR cmd$[rsp], al

; 1524 :         flag = 0;

  001f8	c6 44 24 41 00	 mov	 BYTE PTR flag$[rsp], 0

; 1525 :         recvbuf = cbuf;

  001fd	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR cbuf$[rsp]
  00205	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR recvbuf$[rsp], rax

; 1526 :         rlen = len;

  0020d	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  00211	89 44 24 50	 mov	 DWORD PTR rlen$[rsp], eax

; 1527 :     }

  00215	eb 3a		 jmp	 SHORT $LN22@recvData
$LN21@recvData:

; 1528 :     else
; 1529 :     {
; 1530 :         recvbuf = buf;

  00217	48 8b 84 24 d0
	01 01 00	 mov	 rax, QWORD PTR buf$[rsp]
  0021f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR recvbuf$[rsp], rax

; 1531 :         rlen = buflen < len ? buflen : len;

  00227	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  0022b	39 84 24 d8 01
	01 00		 cmp	 DWORD PTR buflen$[rsp], eax
  00232	7d 0d		 jge	 SHORT $LN37@recvData
  00234	8b 84 24 d8 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0023b	89 44 24 5c	 mov	 DWORD PTR tv154[rsp], eax
  0023f	eb 08		 jmp	 SHORT $LN38@recvData
$LN37@recvData:
  00241	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  00245	89 44 24 5c	 mov	 DWORD PTR tv154[rsp], eax
$LN38@recvData:
  00249	8b 44 24 5c	 mov	 eax, DWORD PTR tv154[rsp]
  0024d	89 44 24 50	 mov	 DWORD PTR rlen$[rsp], eax
$LN22@recvData:

; 1532 :     }
; 1533 : 
; 1534 :     /* Receive the data */
; 1535 :     for (recvlen = 0; recvlen < rlen; recvlen += rc)

  00251	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR recvlen$[rsp], 0
  00259	eb 10		 jmp	 SHORT $LN10@recvData
$LN8@recvData:
  0025b	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  0025f	8b 4c 24 44	 mov	 ecx, DWORD PTR recvlen$[rsp]
  00263	03 c8		 add	 ecx, eax
  00265	8b c1		 mov	 eax, ecx
  00267	89 44 24 44	 mov	 DWORD PTR recvlen$[rsp], eax
$LN10@recvData:
  0026b	8b 44 24 50	 mov	 eax, DWORD PTR rlen$[rsp]
  0026f	39 44 24 44	 cmp	 DWORD PTR recvlen$[rsp], eax
  00273	7d 79		 jge	 SHORT $LN9@recvData

; 1536 :     {
; 1537 :         rc = recv (sock, recvbuf + recvlen, len - recvlen, 0);

  00275	8b 44 24 44	 mov	 eax, DWORD PTR recvlen$[rsp]
  00279	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$[rsp]
  0027d	2b c8		 sub	 ecx, eax
  0027f	8b c1		 mov	 eax, ecx
  00281	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR recvlen$[rsp]
  00286	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR recvbuf$[rsp]
  0028e	48 03 d1	 add	 rdx, rcx
  00291	48 8b ca	 mov	 rcx, rdx
  00294	48 63 94 24 c0
	01 01 00	 movsxd	 rdx, DWORD PTR sock$[rsp]
  0029c	48 89 94 24 98
	00 00 00	 mov	 QWORD PTR tv164[rsp], rdx
  002a4	45 33 c9	 xor	 r9d, r9d
  002a7	44 8b c0	 mov	 r8d, eax
  002aa	48 8b d1	 mov	 rdx, rcx
  002ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv164[rsp]
  002b5	48 8b c8	 mov	 rcx, rax
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  002be	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1538 :         if (rc < 0)

  002c2	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  002c7	7d 0f		 jge	 SHORT $LN25@recvData

; 1539 :             return -HSO_errno;

  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  002cf	f7 d8		 neg	 eax
  002d1	e9 2e 02 00 00	 jmp	 $LN1@recvData
  002d6	eb 11		 jmp	 SHORT $LN26@recvData
$LN25@recvData:

; 1540 :         else if (rc == 0)

  002d8	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  002dd	75 0a		 jne	 SHORT $LN27@recvData

; 1541 :             return -HSO_ENOTCONN;

  002df	b8 b7 d8 ff ff	 mov	 eax, -10057		; ffffffffffffd8b7H
  002e4	e9 1b 02 00 00	 jmp	 $LN1@recvData
$LN27@recvData:
$LN26@recvData:

; 1542 :     }

  002e9	e9 6d ff ff ff	 jmp	 $LN8@recvData
$LN9@recvData:

; 1543 : 
; 1544 :     /* Flush any remaining data */
; 1545 :     for (; rlen < len; rlen += rc)

  002ee	eb 10		 jmp	 SHORT $LN13@recvData
$LN11@recvData:
  002f0	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  002f4	8b 4c 24 50	 mov	 ecx, DWORD PTR rlen$[rsp]
  002f8	03 c8		 add	 ecx, eax
  002fa	8b c1		 mov	 eax, ecx
  002fc	89 44 24 50	 mov	 DWORD PTR rlen$[rsp], eax
$LN13@recvData:
  00300	8b 44 24 4c	 mov	 eax, DWORD PTR len$[rsp]
  00304	39 44 24 50	 cmp	 DWORD PTR rlen$[rsp], eax
  00308	7d 7e		 jge	 SHORT $LN12@recvData

; 1546 :     {
; 1547 :         BYTE buf[256];
; 1548 :         rc = recv (sock, buf, len - rlen < 256 ? len - rlen : 256, 0);

  0030a	8b 44 24 50	 mov	 eax, DWORD PTR rlen$[rsp]
  0030e	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$[rsp]
  00312	2b c8		 sub	 ecx, eax
  00314	8b c1		 mov	 eax, ecx
  00316	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0031b	7d 12		 jge	 SHORT $LN39@recvData
  0031d	8b 44 24 50	 mov	 eax, DWORD PTR rlen$[rsp]
  00321	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$[rsp]
  00325	2b c8		 sub	 ecx, eax
  00327	8b c1		 mov	 eax, ecx
  00329	89 44 24 60	 mov	 DWORD PTR tv177[rsp], eax
  0032d	eb 08		 jmp	 SHORT $LN40@recvData
$LN39@recvData:
  0032f	c7 44 24 60 00
	01 00 00	 mov	 DWORD PTR tv177[rsp], 256 ; 00000100H
$LN40@recvData:
  00337	48 63 84 24 c0
	01 01 00	 movsxd	 rax, DWORD PTR sock$[rsp]
  0033f	45 33 c9	 xor	 r9d, r9d
  00342	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv177[rsp]
  00347	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf$3[rsp]
  0034f	48 8b c8	 mov	 rcx, rax
  00352	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  00358	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1549 :         if (rc < 0)

  0035c	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00361	7d 0f		 jge	 SHORT $LN28@recvData

; 1550 :             return -HSO_errno;

  00363	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00369	f7 d8		 neg	 eax
  0036b	e9 94 01 00 00	 jmp	 $LN1@recvData
  00370	eb 11		 jmp	 SHORT $LN29@recvData
$LN28@recvData:

; 1551 :         else if (rc == 0)

  00372	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00377	75 0a		 jne	 SHORT $LN30@recvData

; 1552 :             return -HSO_ENOTCONN;

  00379	b8 b7 d8 ff ff	 mov	 eax, -10057		; ffffffffffffd8b7H
  0037e	e9 81 01 00 00	 jmp	 $LN1@recvData
$LN30@recvData:
$LN29@recvData:

; 1553 :     }

  00383	e9 68 ff ff ff	 jmp	 $LN11@recvData
$LN12@recvData:

; 1554 : 
; 1555 :     /* Check for compression */
; 1556 :     if (comp == SHRD_LIBZ) {

  00388	83 7c 24 54 01	 cmp	 DWORD PTR comp$[rsp], 1
  0038d	75 5d		 jne	 SHORT $LN31@recvData

; 1557 : #if defined( HAVE_ZLIB )
; 1558 :         unsigned long newlen;
; 1559 : 
; 1560 :         if (off > 0)
; 1561 :             memcpy (buf, cbuf, off);
; 1562 :         newlen = buflen - off;
; 1563 :         rc = uncompress(buf + off, &newlen, cbuf + off, len - off);
; 1564 :         if (rc == Z_OK)
; 1565 :             recvlen = (int)newlen + off;
; 1566 :         else
; 1567 :         {
; 1568 :             // "Shared: decompress error %d offset %d length %d"
; 1569 :             WRMSG( HHC00727, "E", rc, off, len - off );
; 1570 :             recvlen = -1;
; 1571 :         }
; 1572 : #else
; 1573 :         // "Shared: data compressed using method %s is unsupported"
; 1574 :         WRMSG( HHC00728, "E", "libz" );

  0038f	b9 01 00 00 00	 mov	 ecx, 1
  00394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169773
  003a1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169774
  003ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169775
  003b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169776
  003d0	ba 26 06 00 00	 mov	 edx, 1574		; 00000626H
  003d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169777
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1575 :         recvlen = -1;

  003e2	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR recvlen$[rsp], -1

; 1576 : #endif
; 1577 :     }

  003ea	eb 62		 jmp	 SHORT $LN32@recvData
$LN31@recvData:

; 1578 :     else if (comp == SHRD_BZIP2)

  003ec	83 7c 24 54 02	 cmp	 DWORD PTR comp$[rsp], 2
  003f1	75 5b		 jne	 SHORT $LN33@recvData

; 1579 :     {
; 1580 : #if defined( CCKD_BZIP2 )
; 1581 :         unsigned int newlen;
; 1582 : 
; 1583 :         if (off > 0)
; 1584 :             memcpy (buf, cbuf, off);
; 1585 : 
; 1586 :         newlen = buflen - off;
; 1587 :         rc = BZ2_bzBuffToBuffDecompress((void *)(buf + off), &newlen, (void *)(cbuf + off), len - off, 0, 0);
; 1588 :         if (rc == BZ_OK)
; 1589 :             recvlen = (int)newlen + off;
; 1590 :         else
; 1591 :         {
; 1592 :             // "Shared: decompress error %d offset %d length %d"
; 1593 :             WRMSG( HHC00727, "E", rc, off, len - off );
; 1594 :             recvlen = -1;
; 1595 :         }
; 1596 : #else
; 1597 :         // "Shared: data compressed using method %s is unsupported"
; 1598 :         WRMSG( HHC00728, "E", "bzip2" );

  003f3	b9 01 00 00 00	 mov	 ecx, 1
  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  00405	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0040a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169780
  00411	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169781
  0041d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00422	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00427	41 b9 03 00 00
	00		 mov	 r9d, 3
  0042d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169782
  00434	ba 3e 06 00 00	 mov	 edx, 1598		; 0000063eH
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169783
  00440	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1599 :         recvlen = -1;

  00446	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR recvlen$[rsp], -1
$LN33@recvData:
$LN32@recvData:

; 1600 : #endif
; 1601 :     }
; 1602 : 
; 1603 :     if (recvlen > 0)

  0044e	83 7c 24 44 00	 cmp	 DWORD PTR recvlen$[rsp], 0
  00453	0f 8e a7 00 00
	00		 jle	 $LN34@recvData
$LN16@recvData:

; 1604 :     {
; 1605 :         SHRD_SET_HDR (hdr, cmd, flag, devnum, id, recvlen);

  00459	48 8b 84 24 c8
	01 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00461	48 89 44 24 70	 mov	 QWORD PTR shdr$2[rsp], rax
  00466	48 8b 44 24 70	 mov	 rax, QWORD PTR shdr$2[rsp]
  0046b	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR cmd$[rsp]
  00470	88 08		 mov	 BYTE PTR [rax], cl
  00472	48 8b 44 24 70	 mov	 rax, QWORD PTR shdr$2[rsp]
  00477	0f b6 4c 24 41	 movzx	 ecx, BYTE PTR flag$[rsp]
  0047c	88 48 01	 mov	 BYTE PTR [rax+1], cl
  0047f	0f b7 4c 24 58	 movzx	 ecx, WORD PTR devnum$[rsp]
  00484	e8 00 00 00 00	 call	 _byteswap_ushort
  00489	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shdr$2[rsp]
  0048e	48 83 c1 02	 add	 rcx, 2
  00492	0f b7 d0	 movzx	 edx, ax
  00495	e8 00 00 00 00	 call	 store_hw_noswap
  0049a	0f b7 4c 24 44	 movzx	 ecx, WORD PTR recvlen$[rsp]
  0049f	e8 00 00 00 00	 call	 _byteswap_ushort
  004a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shdr$2[rsp]
  004a9	48 83 c1 04	 add	 rcx, 4
  004ad	0f b7 d0	 movzx	 edx, ax
  004b0	e8 00 00 00 00	 call	 store_hw_noswap
  004b5	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR id$[rsp]
  004ba	e8 00 00 00 00	 call	 _byteswap_ushort
  004bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shdr$2[rsp]
  004c4	48 83 c1 06	 add	 rcx, 6
  004c8	0f b7 d0	 movzx	 edx, ax
  004cb	e8 00 00 00 00	 call	 store_hw_noswap
  004d0	33 c0		 xor	 eax, eax
  004d2	85 c0		 test	 eax, eax
  004d4	75 83		 jne	 SHORT $LN16@recvData

; 1606 :         if (comp)

  004d6	83 7c 24 54 00	 cmp	 DWORD PTR comp$[rsp], 0
  004db	74 23		 je	 SHORT $LN35@recvData

; 1607 :             SHRDHDRTRACE2( "recvData", hdr, "(uncompressed)" );

  004dd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169786
  004e4	4c 8b 84 24 c8
	01 01 00	 mov	 r8, QWORD PTR hdr$[rsp]
  004ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169787
  004f3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004fb	e8 00 00 00 00	 call	 shrdhdrtrc
$LN35@recvData:
$LN34@recvData:

; 1608 :     }
; 1609 : 
; 1610 :     return recvlen;

  00500	8b 44 24 44	 mov	 eax, DWORD PTR recvlen$[rsp]
$LN1@recvData:

; 1611 : 
; 1612 : } /* recvData */

  00504	48 8b 8c 24 a0
	01 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0050c	48 33 cc	 xor	 rcx, rsp
  0050f	e8 00 00 00 00	 call	 __security_check_cookie
  00514	48 81 c4 b8 01
	01 00		 add	 rsp, 65976		; 000101b8H
  0051b	c3		 ret	 0
recvData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
code$ = 96
status$ = 97
rc$ = 100
len$ = 104
devnum$ = 108
tv75 = 112
tv81 = 116
tv140 = 120
tv146 = 124
tv192 = 128
tv198 = 132
shdr$1 = 136
shdr$2 = 144
tv185 = 152
tv187 = 156
id$ = 160
tv70 = 168
tv133 = 176
dev$ = 208
hdr$ = 216
buf$ = 224
buflen$ = 232
clientRecv PROC

; 1428 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 1429 : int      rc;                            /* Return code               */
; 1430 : BYTE     code;                          /* Response code             */
; 1431 : BYTE     status;                        /* Response status           */
; 1432 : U16      devnum;                        /* Response device number    */
; 1433 : int      id;                            /* Response identifier       */
; 1434 : int      len;                           /* Response length           */
; 1435 : 
; 1436 :     /* Clear the header to zeroes */
; 1437 :     memset( hdr, 0, SHRD_HDR_SIZE );

  0001c	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR hdr$[rsp]
  00024	33 c0		 xor	 eax, eax
  00026	b9 08 00 00 00	 mov	 ecx, 8
  0002b	f3 aa		 rep stosb

; 1438 : 
; 1439 :     /* Return error if not connected */
; 1440 :     if (dev->fd < 0)

  0002d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0003c	0f 8d d0 00 00
	00		 jge	 $LN8@clientRecv

; 1441 :     {
; 1442 :         // "%1d:%04X Shared: not connected to file %s"
; 1443 :         WRMSG( HHC00724, "E", LCSS_DEVNUM, dev->filename );

  00042	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0004b	74 12		 je	 SHORT $LN14@clientRecv
  0004d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00059	89 44 24 70	 mov	 DWORD PTR tv75[rsp], eax
  0005d	eb 08		 jmp	 SHORT $LN15@clientRecv
$LN14@clientRecv:
  0005f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN15@clientRecv:
  00067	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00070	74 14		 je	 SHORT $LN16@clientRecv
  00072	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007e	d1 f8		 sar	 eax, 1
  00080	89 44 24 74	 mov	 DWORD PTR tv81[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN17@clientRecv
$LN16@clientRecv:
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN17@clientRecv:
  0008e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00096	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  000a4	b9 01 00 00 00	 mov	 ecx, 1
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  000b7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000bc	8b 4c 24 70	 mov	 ecx, DWORD PTR tv75[rsp]
  000c0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c4	8b 4c 24 74	 mov	 ecx, DWORD PTR tv81[rsp]
  000c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  000d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169683
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169684
  000f6	ba a3 05 00 00	 mov	 edx, 1443		; 000005a3H
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1444 :         return -1;

  00108	b8 ff ff ff ff	 mov	 eax, -1
  0010d	e9 9d 03 00 00	 jmp	 $LN1@clientRecv
$LN8@clientRecv:

; 1445 :     }
; 1446 : 
; 1447 :     /* Receive the header */
; 1448 :     rc = recvData (dev->fd, hdr, buf, buflen, 0);

  00112	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0011a	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR buflen$[rsp]
  00122	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0012a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR hdr$[rsp]
  00132	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00140	e8 00 00 00 00	 call	 recvData
  00145	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 1449 :     if (rc < 0)

  00149	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  0014e	0f 8d da 00 00
	00		 jge	 $LN9@clientRecv

; 1450 :     {
; 1451 :         if (rc != -ENOTCONN)

  00154	83 7c 24 64 82	 cmp	 DWORD PTR rc$[rsp], -126 ; ffffffffffffff82H
  00159	0f 84 c6 00 00
	00		 je	 $LN10@clientRecv

; 1452 :             // "%1d:%04X Shared: error in receive: %s"
; 1453 :             WRMSG( HHC00725, "E", LCSS_DEVNUM, strerror( -rc ));

  0015f	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00168	74 12		 je	 SHORT $LN18@clientRecv
  0016a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00172	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00176	89 44 24 78	 mov	 DWORD PTR tv140[rsp], eax
  0017a	eb 08		 jmp	 SHORT $LN19@clientRecv
$LN18@clientRecv:
  0017c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN19@clientRecv:
  00184	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018d	74 14		 je	 SHORT $LN20@clientRecv
  0018f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00197	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0019b	d1 f8		 sar	 eax, 1
  0019d	89 44 24 7c	 mov	 DWORD PTR tv146[rsp], eax
  001a1	eb 08		 jmp	 SHORT $LN21@clientRecv
$LN20@clientRecv:
  001a3	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN21@clientRecv:
  001ab	8b 44 24 64	 mov	 eax, DWORD PTR rc$[rsp]
  001af	f7 d8		 neg	 eax
  001b1	8b c8		 mov	 ecx, eax
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b9	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001c1	b9 01 00 00 00	 mov	 ecx, 1
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d9	8b 4c 24 78	 mov	 ecx, DWORD PTR tv140[rsp]
  001dd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001e1	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv146[rsp]
  001e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  001f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169689
  001fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00201	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00206	41 b9 03 00 00
	00		 mov	 r9d, 3
  0020c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169690
  00213	ba ad 05 00 00	 mov	 edx, 1453		; 000005adH
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169691
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@clientRecv:

; 1454 :         return rc;

  00225	8b 44 24 64	 mov	 eax, DWORD PTR rc$[rsp]
  00229	e9 81 02 00 00	 jmp	 $LN1@clientRecv
$LN9@clientRecv:
$LN4@clientRecv:

; 1455 :     }
; 1456 : 
; 1457 :     SHRD_GET_HDR(hdr, code, status, devnum, id, len);

  0022e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00236	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR shdr$1[rsp], rax
  0023e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00246	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00249	88 44 24 60	 mov	 BYTE PTR code$[rsp], al
  0024d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00255	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00259	88 44 24 61	 mov	 BYTE PTR status$[rsp], al
  0025d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00265	48 83 c0 02	 add	 rax, 2
  00269	48 8b c8	 mov	 rcx, rax
  0026c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00271	0f b7 c8	 movzx	 ecx, ax
  00274	e8 00 00 00 00	 call	 _byteswap_ushort
  00279	66 89 44 24 6c	 mov	 WORD PTR devnum$[rsp], ax
  0027e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  00286	48 83 c0 04	 add	 rax, 4
  0028a	48 8b c8	 mov	 rcx, rax
  0028d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00292	0f b7 c8	 movzx	 ecx, ax
  00295	e8 00 00 00 00	 call	 _byteswap_ushort
  0029a	0f b7 c0	 movzx	 eax, ax
  0029d	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax
  002a1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  002a9	48 83 c0 06	 add	 rax, 6
  002ad	48 8b c8	 mov	 rcx, rax
  002b0	e8 00 00 00 00	 call	 fetch_hw_noswap
  002b5	0f b7 c8	 movzx	 ecx, ax
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	0f b7 c0	 movzx	 eax, ax
  002c0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
  002c7	33 c0		 xor	 eax, eax
  002c9	85 c0		 test	 eax, eax
  002cb	0f 85 5d ff ff
	ff		 jne	 $LN4@clientRecv

; 1458 :     SHRDHDRTRACE( "client recv", hdr );

  002d1	45 33 c9	 xor	 r9d, r9d
  002d4	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR hdr$[rsp]
  002dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169692
  002e3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002eb	e8 00 00 00 00	 call	 shrdhdrtrc

; 1459 : 
; 1460 :     /* Handle remote logical error */
; 1461 :     if (code & SHRD_ERROR)

  002f0	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$[rsp]
  002f5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002fa	85 c0		 test	 eax, eax
  002fc	0f 84 f8 00 00
	00		 je	 $LN11@clientRecv

; 1462 :     {
; 1463 :         // "%1d:%04X Shared: remote error %2.2X-%2.2X: %s"
; 1464 :         WRMSG( HHC00726, "E", LCSS_DEVNUM, code, status, buf );

  00302	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0030b	74 15		 je	 SHORT $LN22@clientRecv
  0030d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00315	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00319	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  00320	eb 0b		 jmp	 SHORT $LN23@clientRecv
$LN22@clientRecv:
  00322	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
$LN23@clientRecv:
  0032d	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00336	74 17		 je	 SHORT $LN24@clientRecv
  00338	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00340	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00344	d1 f8		 sar	 eax, 1
  00346	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv198[rsp], eax
  0034d	eb 0b		 jmp	 SHORT $LN25@clientRecv
$LN24@clientRecv:
  0034f	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv198[rsp], 0
$LN25@clientRecv:
  0035a	0f b6 44 24 61	 movzx	 eax, BYTE PTR status$[rsp]
  0035f	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  00366	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR code$[rsp]
  0036b	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv187[rsp], ecx
  00372	b9 01 00 00 00	 mov	 ecx, 1
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0037d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00385	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0038a	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  00391	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00395	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  0039c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  003a0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  003a7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003ab	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  003b2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169694
  003bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169695
  003c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169696
  003e0	ba b8 05 00 00	 mov	 edx, 1464		; 000005b8H
  003e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169697
  003ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1465 :         len = 0;

  003f2	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN11@clientRecv:

; 1466 :     }
; 1467 : 
; 1468 :     /* Reset code/status if response was compressed */
; 1469 :     if (len > 0 && code == SHRD_COMP)

  003fa	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  003ff	7e 14		 jle	 SHORT $LN12@clientRecv
  00401	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$[rsp]
  00406	83 f8 10	 cmp	 eax, 16
  00409	75 0a		 jne	 SHORT $LN12@clientRecv

; 1470 :     {
; 1471 :         code = SHRD_OK;

  0040b	c6 44 24 60 00	 mov	 BYTE PTR code$[rsp], 0

; 1472 :         status = 0;

  00410	c6 44 24 61 00	 mov	 BYTE PTR status$[rsp], 0
$LN12@clientRecv:
$LN7@clientRecv:

; 1473 :     }
; 1474 : 
; 1475 :     /* Reset the header */
; 1476 :     SHRD_SET_HDR(hdr, code, status, devnum, id, len);

  00415	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0041d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR shdr$2[rsp], rax
  00425	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  0042d	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR code$[rsp]
  00432	88 08		 mov	 BYTE PTR [rax], cl
  00434	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  0043c	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR status$[rsp]
  00441	88 48 01	 mov	 BYTE PTR [rax+1], cl
  00444	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR devnum$[rsp]
  00449	e8 00 00 00 00	 call	 _byteswap_ushort
  0044e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00456	48 83 c1 02	 add	 rcx, 2
  0045a	0f b7 d0	 movzx	 edx, ax
  0045d	e8 00 00 00 00	 call	 store_hw_noswap
  00462	0f b7 4c 24 68	 movzx	 ecx, WORD PTR len$[rsp]
  00467	e8 00 00 00 00	 call	 _byteswap_ushort
  0046c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00474	48 83 c1 04	 add	 rcx, 4
  00478	0f b7 d0	 movzx	 edx, ax
  0047b	e8 00 00 00 00	 call	 store_hw_noswap
  00480	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR id$[rsp]
  00488	e8 00 00 00 00	 call	 _byteswap_ushort
  0048d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00495	48 83 c1 06	 add	 rcx, 6
  00499	0f b7 d0	 movzx	 edx, ax
  0049c	e8 00 00 00 00	 call	 store_hw_noswap
  004a1	33 c0		 xor	 eax, eax
  004a3	85 c0		 test	 eax, eax
  004a5	0f 85 6a ff ff
	ff		 jne	 $LN7@clientRecv

; 1477 : 
; 1478 :     return len;

  004ab	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
$LN1@clientRecv:

; 1479 : } /* clientRecv */

  004af	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  004b6	5f		 pop	 rdi
  004b7	c3		 ret	 0
clientRecv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
cmd$ = 96
flag$ = 97
rc$ = 100
devnum$ = 104
len$ = 108
hdrlen$ = 112
id$ = 116
sendlen$ = 120
tv236 = 124
tv242 = 128
shdr$1 = 136
shdr$2 = 144
shdr$3 = 152
sendbuf$ = 160
tv229 = 168
tv231 = 172
trcmsg$ = 176
off$ = 184
tv206 = 192
tv225 = 200
cbuf$ = 208
__$ArrayPad$ = 65760
dev$ = 65808
hdr$ = 65816
buf$ = 65824
buflen$ = 65832
clientSend PROC

; 1296 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 f8 00 01 00	 mov	 eax, 65784		; 000100f8H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 e0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@clientSend:

; 1297 : int      rc;                            /* Return code               */
; 1298 : BYTE     cmd;                           /* Header command            */
; 1299 : BYTE     flag;                          /* Header flags              */
; 1300 : U16      devnum;                        /* Header device number      */
; 1301 : int      len;                           /* Header length             */
; 1302 : int      id;                            /* Header identifier         */
; 1303 : int      hdrlen;                        /* Header length + other data*/
; 1304 : int      off;                           /* Offset to buffer data     */
; 1305 : BYTE*    sendbuf;                       /* Send buffer               */
; 1306 : int      sendlen;                       /* Send length               */
; 1307 : BYTE     cbuf[SHRD_HDR_SIZE + 65536];   /* Combined buffer           */
; 1308 : const char* trcmsg;                     /* Header trace message      */
; 1309 : 
; 1310 :     /* Save original hdr values */
; 1311 :     SHRD_GET_HDR( hdr, cmd, flag, devnum, id, len );

  00035	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0003d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR shdr$1[rsp], rax
  00045	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  0004d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00050	88 44 24 60	 mov	 BYTE PTR cmd$[rsp], al
  00054	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  0005c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00060	88 44 24 61	 mov	 BYTE PTR flag$[rsp], al
  00064	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  0006c	48 83 c0 02	 add	 rax, 2
  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 fetch_hw_noswap
  00078	0f b7 c8	 movzx	 ecx, ax
  0007b	e8 00 00 00 00	 call	 _byteswap_ushort
  00080	66 89 44 24 68	 mov	 WORD PTR devnum$[rsp], ax
  00085	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  0008d	48 83 c0 04	 add	 rax, 4
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 fetch_hw_noswap
  00099	0f b7 c8	 movzx	 ecx, ax
  0009c	e8 00 00 00 00	 call	 _byteswap_ushort
  000a1	0f b7 c0	 movzx	 eax, ax
  000a4	89 44 24 6c	 mov	 DWORD PTR len$[rsp], eax
  000a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  000b0	48 83 c0 06	 add	 rax, 6
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 fetch_hw_noswap
  000bc	0f b7 c8	 movzx	 ecx, ax
  000bf	e8 00 00 00 00	 call	 _byteswap_ushort
  000c4	0f b7 c0	 movzx	 eax, ax
  000c7	89 44 24 74	 mov	 DWORD PTR id$[rsp], eax
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	0f 85 60 ff ff
	ff		 jne	 $LN4@clientSend

; 1312 : 
; 1313 :     /* Connect to remote device on server if needed */
; 1314 :     if (dev->fd < 0)

  000d5	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  000e4	0f 8d e2 00 00
	00		 jge	 $LN11@clientSend

; 1315 :     {
; 1316 :         if (SHRD_DISCONNECT == cmd)

  000ea	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmd$[rsp]
  000ef	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  000f4	75 0a		 jne	 SHORT $LN12@clientSend

; 1317 :             return -1; // (already disconnected!)

  000f6	b8 ff ff ff ff	 mov	 eax, -1
  000fb	e9 9e 04 00 00	 jmp	 $LN1@clientSend
$LN12@clientSend:

; 1318 : 
; 1319 :         if ((rc = clientConnect( dev, 1 )) < 0)

  00100	ba 01 00 00 00	 mov	 edx, 1
  00105	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010d	e8 00 00 00 00	 call	 clientConnect
  00112	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax
  00116	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011b	7d 0a		 jge	 SHORT $LN13@clientSend

; 1320 :             return -1;

  0011d	b8 ff ff ff ff	 mov	 eax, -1
  00122	e9 77 04 00 00	 jmp	 $LN1@clientSend
$LN13@clientSend:

; 1321 : 
; 1322 :         /* Update values due to clientConnect */
; 1323 :         id = dev->rmtid;

  00127	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012f	8b 80 28 06 00
	00		 mov	 eax, DWORD PTR [rax+1576]
  00135	89 44 24 74	 mov	 DWORD PTR id$[rsp], eax
$LN7@clientSend:

; 1324 :         SHRD_SET_HDR( hdr, cmd, flag, devnum, id, len );

  00139	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00141	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR shdr$2[rsp], rax
  00149	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00151	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR cmd$[rsp]
  00156	88 08		 mov	 BYTE PTR [rax], cl
  00158	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00160	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR flag$[rsp]
  00165	88 48 01	 mov	 BYTE PTR [rax+1], cl
  00168	0f b7 4c 24 68	 movzx	 ecx, WORD PTR devnum$[rsp]
  0016d	e8 00 00 00 00	 call	 _byteswap_ushort
  00172	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  0017a	48 83 c1 02	 add	 rcx, 2
  0017e	0f b7 d0	 movzx	 edx, ax
  00181	e8 00 00 00 00	 call	 store_hw_noswap
  00186	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR len$[rsp]
  0018b	e8 00 00 00 00	 call	 _byteswap_ushort
  00190	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00198	48 83 c1 04	 add	 rcx, 4
  0019c	0f b7 d0	 movzx	 edx, ax
  0019f	e8 00 00 00 00	 call	 store_hw_noswap
  001a4	0f b7 4c 24 74	 movzx	 ecx, WORD PTR id$[rsp]
  001a9	e8 00 00 00 00	 call	 _byteswap_ushort
  001ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shdr$2[rsp]
  001b6	48 83 c1 06	 add	 rcx, 6
  001ba	0f b7 d0	 movzx	 edx, ax
  001bd	e8 00 00 00 00	 call	 store_hw_noswap
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	0f 85 6d ff ff
	ff		 jne	 $LN7@clientSend
$LN11@clientSend:

; 1325 :     }
; 1326 : 
; 1327 :     /* Make buf, buflen consistent if no additional data to be sent  */
; 1328 :     if (buf == NULL) buflen = 0;

  001cc	48 83 bc 24 20
	01 01 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  001d5	75 0d		 jne	 SHORT $LN14@clientSend
  001d7	c7 84 24 28 01
	01 00 00 00 00
	00		 mov	 DWORD PTR buflen$[rsp], 0
  001e2	eb 16		 jmp	 SHORT $LN15@clientSend
$LN14@clientSend:

; 1329 :     else if (buflen == 0) buf = NULL;

  001e4	83 bc 24 28 01
	01 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  001ec	75 0c		 jne	 SHORT $LN16@clientSend
  001ee	48 c7 84 24 20
	01 01 00 00 00
	00 00		 mov	 QWORD PTR buf$[rsp], 0
$LN16@clientSend:
$LN15@clientSend:

; 1330 : 
; 1331 :     /* Calculate length of header, may contain additional data */
; 1332 :     hdrlen = SHRD_HDR_SIZE + (len - buflen);

  001fa	8b 84 24 28 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00201	8b 4c 24 6c	 mov	 ecx, DWORD PTR len$[rsp]
  00205	2b c8		 sub	 ecx, eax
  00207	8b c1		 mov	 eax, ecx
  00209	48 98		 cdqe
  0020b	48 83 c0 08	 add	 rax, 8
  0020f	89 44 24 70	 mov	 DWORD PTR hdrlen$[rsp], eax

; 1333 :     off = len - buflen;

  00213	8b 84 24 28 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0021a	8b 4c 24 6c	 mov	 ecx, DWORD PTR len$[rsp]
  0021e	2b c8		 sub	 ecx, eax
  00220	8b c1		 mov	 eax, ecx
  00222	89 84 24 b8 00
	00 00		 mov	 DWORD PTR off$[rsp], eax

; 1334 : 
; 1335 : #if defined( HAVE_ZLIB )
; 1336 :     /* Compress the buf */
; 1337 :     if (1
; 1338 :         && dev->rmtcomp != 0
; 1339 :         && flag == 0
; 1340 :         && off <= SHRD_COMP_MAX_OFF
; 1341 :         && buflen >= SHARED_COMPRESS_MINLEN
; 1342 :     )
; 1343 :     {
; 1344 :         unsigned long newlen;
; 1345 :         newlen = 65536 - hdrlen;
; 1346 :         memcpy( cbuf, hdr, hdrlen );
; 1347 :         rc = compress2( cbuf + hdrlen, &newlen,
; 1348 :                         buf, buflen, dev->rmtcomp );
; 1349 :         if (rc == Z_OK && (int)newlen < buflen)
; 1350 :         {
; 1351 :             cmd |= SHRD_COMP;
; 1352 :             flag = (SHRD_LIBZ << 4) | off;
; 1353 :             hdr = cbuf;
; 1354 :             hdrlen += newlen;
; 1355 :             buf = NULL;
; 1356 :             buflen = 0;
; 1357 :         }
; 1358 :     }
; 1359 : #endif
; 1360 : 
; 1361 :     /* Combine header and data unless there's no buffer */
; 1362 :     if (buflen == 0)

  00229	83 bc 24 28 01
	01 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00231	75 1a		 jne	 SHORT $LN17@clientSend

; 1363 :     {
; 1364 :         sendbuf = hdr;

  00233	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0023b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sendbuf$[rsp], rax

; 1365 :         sendlen = hdrlen;

  00243	8b 44 24 70	 mov	 eax, DWORD PTR hdrlen$[rsp]
  00247	89 44 24 78	 mov	 DWORD PTR sendlen$[rsp], eax

; 1366 :     }

  0024b	eb 65		 jmp	 SHORT $LN18@clientSend
$LN17@clientSend:

; 1367 :     else
; 1368 :     {
; 1369 :         memcpy( cbuf, hdr, hdrlen );

  0024d	48 63 44 24 70	 movsxd	 rax, DWORD PTR hdrlen$[rsp]
  00252	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR cbuf$[rsp]
  0025a	48 8b f9	 mov	 rdi, rcx
  0025d	48 8b b4 24 18
	01 01 00	 mov	 rsi, QWORD PTR hdr$[rsp]
  00265	48 8b c8	 mov	 rcx, rax
  00268	f3 a4		 rep movsb

; 1370 :         memcpy( cbuf + hdrlen, buf, buflen );

  0026a	48 63 84 24 28
	01 01 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00272	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR hdrlen$[rsp]
  00277	48 8d 8c 0c d0
	00 00 00	 lea	 rcx, QWORD PTR cbuf$[rsp+rcx]
  0027f	48 8b f9	 mov	 rdi, rcx
  00282	48 8b b4 24 20
	01 01 00	 mov	 rsi, QWORD PTR buf$[rsp]
  0028a	48 8b c8	 mov	 rcx, rax
  0028d	f3 a4		 rep movsb

; 1371 :         sendbuf = cbuf;

  0028f	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR cbuf$[rsp]
  00297	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sendbuf$[rsp], rax

; 1372 :         sendlen = hdrlen + buflen;

  0029f	8b 84 24 28 01
	01 00		 mov	 eax, DWORD PTR buflen$[rsp]
  002a6	8b 4c 24 70	 mov	 ecx, DWORD PTR hdrlen$[rsp]
  002aa	03 c8		 add	 ecx, eax
  002ac	8b c1		 mov	 eax, ecx
  002ae	89 44 24 78	 mov	 DWORD PTR sendlen$[rsp], eax
$LN18@clientSend:

; 1373 :     }
; 1374 : 
; 1375 :     len = (sendlen - SHRD_HDR_SIZE);

  002b2	48 63 44 24 78	 movsxd	 rax, DWORD PTR sendlen$[rsp]
  002b7	48 83 e8 08	 sub	 rax, 8
  002bb	89 44 24 6c	 mov	 DWORD PTR len$[rsp], eax

; 1376 :     trcmsg = "client send";

  002bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169635
  002c6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR trcmsg$[rsp], rax
$retry$30:
$LN10@clientSend:

; 1377 : 
; 1378 : retry:
; 1379 : 
; 1380 :     /* Update hdr with final values */
; 1381 :     SHRD_SET_HDR( sendbuf, cmd, flag, devnum, id, len );

  002ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sendbuf$[rsp]
  002d6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR shdr$3[rsp], rax
  002de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR shdr$3[rsp]
  002e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR cmd$[rsp]
  002eb	88 08		 mov	 BYTE PTR [rax], cl
  002ed	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR shdr$3[rsp]
  002f5	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR flag$[rsp]
  002fa	88 48 01	 mov	 BYTE PTR [rax+1], cl
  002fd	0f b7 4c 24 68	 movzx	 ecx, WORD PTR devnum$[rsp]
  00302	e8 00 00 00 00	 call	 _byteswap_ushort
  00307	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  0030f	48 83 c1 02	 add	 rcx, 2
  00313	0f b7 d0	 movzx	 edx, ax
  00316	e8 00 00 00 00	 call	 store_hw_noswap
  0031b	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR len$[rsp]
  00320	e8 00 00 00 00	 call	 _byteswap_ushort
  00325	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  0032d	48 83 c1 04	 add	 rcx, 4
  00331	0f b7 d0	 movzx	 edx, ax
  00334	e8 00 00 00 00	 call	 store_hw_noswap
  00339	0f b7 4c 24 74	 movzx	 ecx, WORD PTR id$[rsp]
  0033e	e8 00 00 00 00	 call	 _byteswap_ushort
  00343	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR shdr$3[rsp]
  0034b	48 83 c1 06	 add	 rcx, 6
  0034f	0f b7 d0	 movzx	 edx, ax
  00352	e8 00 00 00 00	 call	 store_hw_noswap
  00357	33 c0		 xor	 eax, eax
  00359	85 c0		 test	 eax, eax
  0035b	0f 85 6d ff ff
	ff		 jne	 $LN10@clientSend

; 1382 : 
; 1383 :     /* Trace what we'll be sending */
; 1384 :     if (cmd & SHRD_COMP)

  00361	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmd$[rsp]
  00366	83 e0 10	 and	 eax, 16
  00369	85 c0		 test	 eax, eax
  0036b	74 26		 je	 SHORT $LN19@clientSend

; 1385 :         SHRDHDRTRACE2( trcmsg, sendbuf, "(compressed)" );

  0036d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169638
  00374	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR sendbuf$[rsp]
  0037c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR trcmsg$[rsp]
  00384	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0038c	e8 00 00 00 00	 call	 shrdhdrtrc
  00391	eb 20		 jmp	 SHORT $LN20@clientSend
$LN19@clientSend:

; 1386 :     else
; 1387 :         SHRDHDRTRACE(  trcmsg, sendbuf );

  00393	45 33 c9	 xor	 r9d, r9d
  00396	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR sendbuf$[rsp]
  0039e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR trcmsg$[rsp]
  003a6	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ae	e8 00 00 00 00	 call	 shrdhdrtrc
$LN20@clientSend:

; 1388 : 
; 1389 :     /* Send the header and data */
; 1390 :     if ((rc = send( dev->fd, sendbuf, sendlen, 0 )) < 0)

  003b3	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003bb	48 63 80 ac 01
	00 00		 movsxd	 rax, DWORD PTR [rax+428]
  003c2	45 33 c9	 xor	 r9d, r9d
  003c5	44 8b 44 24 78	 mov	 r8d, DWORD PTR sendlen$[rsp]
  003ca	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR sendbuf$[rsp]
  003d2	48 8b c8	 mov	 rcx, rax
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  003db	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax
  003df	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  003e4	0f 8d 91 00 00
	00		 jge	 $LN21@clientSend

; 1391 :     {
; 1392 :         /* Trace the socket error */
; 1393 :         SHRDTRACE( "send rc=%d errno=%d %s", rc, HSO_errno, strerror( HSO_errno ));

  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003f0	8b c8		 mov	 ecx, eax
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003f8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00406	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  0040e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00413	44 8b c8	 mov	 r9d, eax
  00416	44 8b 44 24 64	 mov	 r8d, DWORD PTR rc$[rsp]
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169640
  00422	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042a	e8 00 00 00 00	 call	 shrdtrc

; 1394 : 
; 1395 :         /* If the request we're trying to send to the server
; 1396 :            is a disconnect request, it doesn't make much sense
; 1397 :            to go to the time and effort to re-connect to the
; 1398 :            server only to tell it we're about to DISCONNECT!
; 1399 :         */
; 1400 :         if (SHRD_DISCONNECT != cmd)

  0042f	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmd$[rsp]
  00434	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  00439	74 40		 je	 SHORT $LN22@clientSend

; 1401 :         {
; 1402 :             if ((rc = clientConnect( dev, 0 )) >= 0)

  0043b	33 d2		 xor	 edx, edx
  0043d	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00445	e8 00 00 00 00	 call	 clientConnect
  0044a	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax
  0044e	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00453	7c 26		 jl	 SHORT $LN23@clientSend

; 1403 :             {
; 1404 :                 /* Pickup new rmtid due to clientConnect */
; 1405 :                 id = dev->rmtid;

  00455	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045d	8b 80 28 06 00
	00		 mov	 eax, DWORD PTR [rax+1576]
  00463	89 44 24 74	 mov	 DWORD PTR id$[rsp], eax

; 1406 :                 trcmsg = "client send retry";

  00467	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169643
  0046e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR trcmsg$[rsp], rax

; 1407 :                 goto retry;

  00476	e9 53 fe ff ff	 jmp	 $retry$30
$LN23@clientSend:
$LN22@clientSend:
$LN21@clientSend:

; 1408 :             }
; 1409 :         }
; 1410 :     }
; 1411 : 
; 1412 :     /* Process return code */
; 1413 :     if (rc < 0 && SHRD_DISCONNECT != cmd)

  0047b	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00480	0f 8d 14 01 00
	00		 jge	 $LN24@clientSend
  00486	0f b6 44 24 60	 movzx	 eax, BYTE PTR cmd$[rsp]
  0048b	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  00490	0f 84 04 01 00
	00		 je	 $LN24@clientSend

; 1414 :     {
; 1415 :         // "%1d:%04X Shared: error in send for %2.2X-%2.2X: %s"
; 1416 :         WRMSG( HHC00723, "E", LCSS_DEVNUM, cmd, flag, strerror( HSO_errno ));

  00496	48 83 bc 24 10
	01 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0049f	74 12		 je	 SHORT $LN26@clientSend
  004a1	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004ad	89 44 24 7c	 mov	 DWORD PTR tv236[rsp], eax
  004b1	eb 08		 jmp	 SHORT $LN27@clientSend
$LN26@clientSend:
  004b3	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN27@clientSend:
  004bb	48 83 bc 24 10
	01 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004c4	74 17		 je	 SHORT $LN28@clientSend
  004c6	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ce	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004d2	d1 f8		 sar	 eax, 1
  004d4	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv242[rsp], eax
  004db	eb 0b		 jmp	 SHORT $LN29@clientSend
$LN28@clientSend:
  004dd	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv242[rsp], 0
$LN29@clientSend:
  004e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  004ee	8b c8		 mov	 ecx, eax
  004f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004f6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  004fe	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR flag$[rsp]
  00503	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv229[rsp], ecx
  0050a	0f b6 54 24 60	 movzx	 edx, BYTE PTR cmd$[rsp]
  0050f	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv231[rsp], edx
  00516	b9 01 00 00 00	 mov	 ecx, 1
  0051b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00521	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  00529	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0052e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv229[rsp]
  00535	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00539	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv231[rsp]
  00540	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00544	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv236[rsp]
  00548	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0054c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv242[rsp]
  00553	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169645
  0055e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00563	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169646
  0056a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00574	41 b9 03 00 00
	00		 mov	 r9d, 3
  0057a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169647
  00581	ba 88 05 00 00	 mov	 edx, 1416		; 00000588H
  00586	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169648
  0058d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1417 :         return -1;

  00593	b8 ff ff ff ff	 mov	 eax, -1
  00598	eb 04		 jmp	 SHORT $LN1@clientSend
$LN24@clientSend:

; 1418 :     }
; 1419 : 
; 1420 :     return rc;

  0059a	8b 44 24 64	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@clientSend:

; 1421 : 
; 1422 : } /* clientSend */

  0059e	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005a6	48 33 cc	 xor	 rcx, rsp
  005a9	e8 00 00 00 00	 call	 __security_check_cookie
  005ae	48 81 c4 f8 00
	01 00		 add	 rsp, 65784		; 000100f8H
  005b5	5f		 pop	 rdi
  005b6	5e		 pop	 rsi
  005b7	c3		 ret	 0
clientSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rcode$ = 32
rstatus$ = 33
rc$ = 36
rc$1 = 40
rlen$ = 44
retries$ = 48
tv180 = 52
shdr$2 = 56
shdr$3 = 64
rdevnum$ = 72
tv137 = 76
rid$ = 80
hdr$ = 88
temp$ = 96
__$ArrayPad$ = 352
dev$ = 400
buf$ = 408
len$ = 416
cmd$ = 424
flags$ = 432
code$ = 440
status$ = 448
clientRequest PROC

; 1232 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1233 : int      rc;                            /* Return code               */
; 1234 : int      retries = 10;                  /* Number retries            */

  0002f	c7 44 24 30 0a
	00 00 00	 mov	 DWORD PTR retries$[rsp], 10
$retry$23:
$LN4@clientRequ:

; 1235 : BYTE     rcode;                         /* Request return code       */
; 1236 : BYTE     rstatus;                       /* Request return status     */
; 1237 : U16      rdevnum;                       /* Request return devnum     */
; 1238 : int      rid;                           /* Request return id         */
; 1239 : int      rlen;                          /* Request return length     */
; 1240 : BYTE     hdr[SHRD_HDR_SIZE];            /* Header                    */
; 1241 : BYTE     temp[256];                     /* Temporary buffer          */
; 1242 : 
; 1243 : retry:
; 1244 : 
; 1245 :     /* Send the request */
; 1246 :     SHRD_SET_HDR(hdr, cmd, flags, dev->rmtnum, dev->rmtid, 0);

  00037	48 8d 44 24 58	 lea	 rax, QWORD PTR hdr$[rsp]
  0003c	48 89 44 24 38	 mov	 QWORD PTR shdr$2[rsp], rax
  00041	48 8b 44 24 38	 mov	 rax, QWORD PTR shdr$2[rsp]
  00046	0f b6 8c 24 a8
	01 00 00	 movzx	 ecx, BYTE PTR cmd$[rsp]
  0004e	88 08		 mov	 BYTE PTR [rax], cl
  00050	48 8b 44 24 38	 mov	 rax, QWORD PTR shdr$2[rsp]
  00055	0f b6 8c 24 b0
	01 00 00	 movzx	 ecx, BYTE PTR flags$[rsp]
  0005d	88 48 01	 mov	 BYTE PTR [rax+1], cl
  00060	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00068	0f b7 88 26 06
	00 00		 movzx	 ecx, WORD PTR [rax+1574]
  0006f	e8 00 00 00 00	 call	 _byteswap_ushort
  00074	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00079	48 83 c1 02	 add	 rcx, 2
  0007d	0f b7 d0	 movzx	 edx, ax
  00080	e8 00 00 00 00	 call	 store_hw_noswap
  00085	33 c9		 xor	 ecx, ecx
  00087	e8 00 00 00 00	 call	 _byteswap_ushort
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$2[rsp]
  00091	48 83 c1 04	 add	 rcx, 4
  00095	0f b7 d0	 movzx	 edx, ax
  00098	e8 00 00 00 00	 call	 store_hw_noswap
  0009d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	0f b7 88 28 06
	00 00		 movzx	 ecx, WORD PTR [rax+1576]
  000ac	e8 00 00 00 00	 call	 _byteswap_ushort
  000b1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR shdr$2[rsp]
  000b6	48 83 c1 06	 add	 rcx, 6
  000ba	0f b7 d0	 movzx	 edx, ax
  000bd	e8 00 00 00 00	 call	 store_hw_noswap
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	0f 85 6b ff ff
	ff		 jne	 $LN4@clientRequ

; 1247 :     SHRDHDRTRACE( "client request", hdr );

  000cc	45 33 c9	 xor	 r9d, r9d
  000cf	4c 8d 44 24 58	 lea	 r8, QWORD PTR hdr$[rsp]
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169564
  000db	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e3	e8 00 00 00 00	 call	 shrdhdrtrc

; 1248 :     rc = clientSend (dev, hdr, NULL, 0);

  000e8	45 33 c9	 xor	 r9d, r9d
  000eb	45 33 c0	 xor	 r8d, r8d
  000ee	48 8d 54 24 58	 lea	 rdx, QWORD PTR hdr$[rsp]
  000f3	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000fb	e8 00 00 00 00	 call	 clientSend
  00100	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1249 :     if (rc < 0) return rc;

  00104	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00109	7d 09		 jge	 SHORT $LN13@clientRequ
  0010b	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0010f	e9 f0 01 00 00	 jmp	 $LN1@clientRequ
$LN13@clientRequ:

; 1250 : 
; 1251 :     /* Receive the response */
; 1252 :     rc = clientRecv (dev, hdr, temp, sizeof(temp));

  00114	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  0011a	4c 8d 44 24 60	 lea	 r8, QWORD PTR temp$[rsp]
  0011f	48 8d 54 24 58	 lea	 rdx, QWORD PTR hdr$[rsp]
  00124	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012c	e8 00 00 00 00	 call	 clientRecv
  00131	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1253 : 
; 1254 :     /* Retry recv errors */
; 1255 :     if (rc < 0)

  00135	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013a	0f 8d 8d 00 00
	00		 jge	 $LN14@clientRequ

; 1256 :     {
; 1257 :         if (1
; 1258 :             && cmd != SHRD_CONNECT
; 1259 :             && cmd != SHRD_DISCONNECT
; 1260 :             && retries--

  00140	33 c0		 xor	 eax, eax
  00142	83 f8 01	 cmp	 eax, 1
  00145	74 7c		 je	 SHORT $LN15@clientRequ
  00147	81 bc 24 a8 01
	00 00 e0 00 00
	00		 cmp	 DWORD PTR cmd$[rsp], 224 ; 000000e0H
  00152	74 6f		 je	 SHORT $LN15@clientRequ
  00154	81 bc 24 a8 01
	00 00 e1 00 00
	00		 cmp	 DWORD PTR cmd$[rsp], 225 ; 000000e1H
  0015f	74 62		 je	 SHORT $LN15@clientRequ
  00161	8b 44 24 30	 mov	 eax, DWORD PTR retries$[rsp]
  00165	89 44 24 4c	 mov	 DWORD PTR tv137[rsp], eax
  00169	8b 44 24 30	 mov	 eax, DWORD PTR retries$[rsp]
  0016d	ff c8		 dec	 eax
  0016f	89 44 24 30	 mov	 DWORD PTR retries$[rsp], eax
  00173	83 7c 24 4c 00	 cmp	 DWORD PTR tv137[rsp], 0
  00178	74 49		 je	 SHORT $LN15@clientRequ
$LN7@clientRequ:

; 1261 :         )
; 1262 :         {
; 1263 :             SLEEP (1);

  0017a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1
$LN8@clientRequ:
  00182	83 7c 24 28 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00187	74 1d		 je	 SHORT $LN9@clientRequ
  00189	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$1[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00193	89 44 24 28	 mov	 DWORD PTR rc$1[rsp], eax
  00197	83 7c 24 28 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0019c	74 06		 je	 SHORT $LN16@clientRequ
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN16@clientRequ:
  001a4	eb dc		 jmp	 SHORT $LN8@clientRequ
$LN9@clientRequ:
  001a6	33 c0		 xor	 eax, eax
  001a8	85 c0		 test	 eax, eax
  001aa	75 ce		 jne	 SHORT $LN7@clientRequ

; 1264 :             clientConnect (dev, 1);

  001ac	ba 01 00 00 00	 mov	 edx, 1
  001b1	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b9	e8 00 00 00 00	 call	 clientConnect

; 1265 :             goto retry;

  001be	e9 74 fe ff ff	 jmp	 $retry$23
$LN15@clientRequ:

; 1266 :         }
; 1267 :         return -1;

  001c3	b8 ff ff ff ff	 mov	 eax, -1
  001c8	e9 37 01 00 00	 jmp	 $LN1@clientRequ
$LN14@clientRequ:
$LN12@clientRequ:

; 1268 :     }
; 1269 : 
; 1270 :     /* Set code and status */
; 1271 :     SHRD_GET_HDR(hdr, rcode, rstatus, rdevnum, rid, rlen);

  001cd	48 8d 44 24 58	 lea	 rax, QWORD PTR hdr$[rsp]
  001d2	48 89 44 24 40	 mov	 QWORD PTR shdr$3[rsp], rax
  001d7	48 8b 44 24 40	 mov	 rax, QWORD PTR shdr$3[rsp]
  001dc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001df	88 44 24 20	 mov	 BYTE PTR rcode$[rsp], al
  001e3	48 8b 44 24 40	 mov	 rax, QWORD PTR shdr$3[rsp]
  001e8	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001ec	88 44 24 21	 mov	 BYTE PTR rstatus$[rsp], al
  001f0	48 8b 44 24 40	 mov	 rax, QWORD PTR shdr$3[rsp]
  001f5	48 83 c0 02	 add	 rax, 2
  001f9	48 8b c8	 mov	 rcx, rax
  001fc	e8 00 00 00 00	 call	 fetch_hw_noswap
  00201	0f b7 c8	 movzx	 ecx, ax
  00204	e8 00 00 00 00	 call	 _byteswap_ushort
  00209	66 89 44 24 48	 mov	 WORD PTR rdevnum$[rsp], ax
  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR shdr$3[rsp]
  00213	48 83 c0 04	 add	 rax, 4
  00217	48 8b c8	 mov	 rcx, rax
  0021a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0021f	0f b7 c8	 movzx	 ecx, ax
  00222	e8 00 00 00 00	 call	 _byteswap_ushort
  00227	0f b7 c0	 movzx	 eax, ax
  0022a	89 44 24 2c	 mov	 DWORD PTR rlen$[rsp], eax
  0022e	48 8b 44 24 40	 mov	 rax, QWORD PTR shdr$3[rsp]
  00233	48 83 c0 06	 add	 rax, 6
  00237	48 8b c8	 mov	 rcx, rax
  0023a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0023f	0f b7 c8	 movzx	 ecx, ax
  00242	e8 00 00 00 00	 call	 _byteswap_ushort
  00247	0f b7 c0	 movzx	 eax, ax
  0024a	89 44 24 50	 mov	 DWORD PTR rid$[rsp], eax
  0024e	33 c0		 xor	 eax, eax
  00250	85 c0		 test	 eax, eax
  00252	0f 85 75 ff ff
	ff		 jne	 $LN12@clientRequ

; 1272 :     SHRDHDRTRACE( "client response", hdr );

  00258	45 33 c9	 xor	 r9d, r9d
  0025b	4c 8d 44 24 58	 lea	 r8, QWORD PTR hdr$[rsp]
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169569
  00267	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026f	e8 00 00 00 00	 call	 shrdhdrtrc

; 1273 : 
; 1274 :     if (code)   *code   = rcode;

  00274	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR code$[rsp], 0
  0027d	74 0f		 je	 SHORT $LN17@clientRequ
  0027f	0f b6 44 24 20	 movzx	 eax, BYTE PTR rcode$[rsp]
  00284	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR code$[rsp]
  0028c	89 01		 mov	 DWORD PTR [rcx], eax
$LN17@clientRequ:

; 1275 :     if (status) *status = rstatus;

  0028e	48 83 bc 24 c0
	01 00 00 00	 cmp	 QWORD PTR status$[rsp], 0
  00297	74 0f		 je	 SHORT $LN18@clientRequ
  00299	0f b6 44 24 21	 movzx	 eax, BYTE PTR rstatus$[rsp]
  0029e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR status$[rsp]
  002a6	89 01		 mov	 DWORD PTR [rcx], eax
$LN18@clientRequ:

; 1276 : 
; 1277 :     /* Copy the data into the caller's buffer */
; 1278 :     if (buf && len > 0 && rlen > 0)

  002a8	48 83 bc 24 98
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  002b1	74 4d		 je	 SHORT $LN19@clientRequ
  002b3	83 bc 24 a0 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  002bb	7e 43		 jle	 SHORT $LN19@clientRequ
  002bd	83 7c 24 2c 00	 cmp	 DWORD PTR rlen$[rsp], 0
  002c2	7e 3c		 jle	 SHORT $LN19@clientRequ

; 1279 :         memcpy (buf, temp, len < rlen ? len : rlen);

  002c4	8b 44 24 2c	 mov	 eax, DWORD PTR rlen$[rsp]
  002c8	39 84 24 a0 01
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  002cf	7d 0d		 jge	 SHORT $LN21@clientRequ
  002d1	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002d8	89 44 24 34	 mov	 DWORD PTR tv180[rsp], eax
  002dc	eb 08		 jmp	 SHORT $LN22@clientRequ
$LN21@clientRequ:
  002de	8b 44 24 2c	 mov	 eax, DWORD PTR rlen$[rsp]
  002e2	89 44 24 34	 mov	 DWORD PTR tv180[rsp], eax
$LN22@clientRequ:
  002e6	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv180[rsp]
  002eb	48 8d 4c 24 60	 lea	 rcx, QWORD PTR temp$[rsp]
  002f0	48 8b bc 24 98
	01 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  002f8	48 8b f1	 mov	 rsi, rcx
  002fb	48 8b c8	 mov	 rcx, rax
  002fe	f3 a4		 rep movsb
$LN19@clientRequ:

; 1280 : 
; 1281 :     return rlen;

  00300	8b 44 24 2c	 mov	 eax, DWORD PTR rlen$[rsp]
$LN1@clientRequ:

; 1282 : } /* clientRequest */

  00304	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030c	48 33 cc	 xor	 rcx, rsp
  0030f	e8 00 00 00 00	 call	 __security_check_cookie
  00314	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  0031b	5f		 pop	 rdi
  0031c	5e		 pop	 rsi
  0031d	c3		 ret	 0
clientRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 112
id$ = 116
flag$1 = 120
comp$ = 124
retries$ = 128
tv93 = 132
tv131 = 136
tv161 = 140
tv167 = 144
tv258 = 148
tv264 = 152
tv308 = 156
tv314 = 160
len$ = 164
tv332 = 168
tv85 = 176
tv153 = 184
server$ = 192
tv201 = 200
tv247 = 208
tv299 = 216
tv303 = 224
iserver$ = 232
__$ArrayPad$ = 248
dev$ = 272
retry$ = 280
clientConnect PROC

; 1093 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1094 : int                rc;                  /* Return code               */
; 1095 : struct sockaddr*   server;              /* -> Server descriptor      */
; 1096 : int                len;                 /* Length server descriptor  */
; 1097 : struct sockaddr_in iserver;             /* inet server descriptor    */
; 1098 : #if defined( HAVE_SYS_UN_H )
; 1099 : struct sockaddr_un userver;             /* Unix server descriptor    */
; 1100 : #endif
; 1101 : int                retries = 10;        /* Number of retries         */

  00022	c7 84 24 80 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR retries$[rsp], 10

; 1102 : HWORD              id;                  /* Returned identifier       */
; 1103 : HWORD              comp;                /* Returned compression parm */
; 1104 : 
; 1105 :     SHRDTRACE( "Beg clientConnect sequence for dev %4.4x retry=%d", dev->devnum, retry );

  0002d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00039	44 8b 8c 24 18
	01 00 00	 mov	 r9d, DWORD PTR retry$[rsp]
  00041	44 8b c0	 mov	 r8d, eax
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169474
  0004b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00053	e8 00 00 00 00	 call	 shrdtrc
$LN4@clientConn:

; 1106 : 
; 1107 :     do
; 1108 :     {
; 1109 :         /* Close previous connection */
; 1110 :         if (dev->fd >= 0)

  00058	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00060	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00067	7c 14		 jl	 SHORT $LN5@clientConn

; 1111 :             close_socket( dev->fd );

  00069	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00071	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN5@clientConn:

; 1112 : 
; 1113 :         /* Get a new socket */
; 1114 :         if (dev->localhost)

  0007d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00085	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0008b	c1 e8 09	 shr	 eax, 9
  0008e	83 e0 01	 and	 eax, 1
  00091	85 c0		 test	 eax, eax
  00093	0f 84 40 01 00
	00		 je	 $LN6@clientConn

; 1115 :         {
; 1116 : #if defined( HAVE_SYS_UN_H )
; 1117 :             dev->fd = socket( AF_UNIX, SOCK_STREAM, 0 );
; 1118 : #else
; 1119 :             dev->fd = -1;

  00099	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a1	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 1120 : #endif
; 1121 :             dev->ckdfd[0] = dev->fd;

  000ab	b8 04 00 00 00	 mov	 eax, 4
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000bc	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000c4	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  000ca	89 94 01 c8 11
	00 00		 mov	 DWORD PTR [rcx+rax+4552], edx

; 1122 : 
; 1123 :             if (dev->fd < 0)

  000d1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d9	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  000e0	0f 8d ee 00 00
	00		 jge	 $LN8@clientConn

; 1124 :             {
; 1125 :                 // "%1d:%04X Shared: error in function %s: %s"
; 1126 :                 WRMSG( HHC00720, "E", LCSS_DEVNUM, "socket()", strerror( HSO_errno ));

  000e6	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ef	74 15		 je	 SHORT $LN25@clientConn
  000f1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000fd	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  00104	eb 0b		 jmp	 SHORT $LN26@clientConn
$LN25@clientConn:
  00106	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv93[rsp], 0
$LN26@clientConn:
  00111	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0011a	74 17		 je	 SHORT $LN27@clientConn
  0011c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00124	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00128	d1 f8		 sar	 eax, 1
  0012a	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv131[rsp], eax
  00131	eb 0b		 jmp	 SHORT $LN28@clientConn
$LN27@clientConn:
  00133	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv131[rsp], 0
$LN28@clientConn:
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00144	8b c8		 mov	 ecx, eax
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0014c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv85[rsp], rax
  00154	b9 01 00 00 00	 mov	 ecx, 1
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv85[rsp]
  00167	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169479
  00173	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00178	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv93[rsp]
  0017f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00183	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv131[rsp]
  0018a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  00195	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169481
  001a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169482
  001b8	ba 66 04 00 00	 mov	 edx, 1126		; 00000466H
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169483
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1127 :                 return -1;

  001ca	b8 ff ff ff ff	 mov	 eax, -1
  001cf	e9 c2 06 00 00	 jmp	 $LN1@clientConn
$LN8@clientConn:

; 1128 :             }
; 1129 : #if defined( HAVE_SYS_UN_H )
; 1130 :             userver.sun_family = AF_UNIX;
; 1131 :             sprintf( userver.sun_path, "/tmp/hercules_shared.%d", dev->rmtport );
; 1132 :             server = (struct sockaddr*) &userver;
; 1133 :             len = sizeof( userver );
; 1134 : #endif
; 1135 :         }

  001d4	e9 a4 01 00 00	 jmp	 $LN7@clientConn
$LN6@clientConn:

; 1136 :         else
; 1137 :         {
; 1138 :             dev->fd = socket( AF_INET, SOCK_STREAM, 0 );

  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	ba 01 00 00 00	 mov	 edx, 1
  001e1	b9 02 00 00 00	 mov	 ecx, 2
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  001ec	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f4	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 1139 :             dev->ckdfd[0] = dev->fd;

  001fa	b8 04 00 00 00	 mov	 eax, 4
  001ff	48 6b c0 00	 imul	 rax, rax, 0
  00203	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00213	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  00219	89 94 01 c8 11
	00 00		 mov	 DWORD PTR [rcx+rax+4552], edx

; 1140 : 
; 1141 :             if (dev->fd < 0)

  00220	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00228	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0022f	0f 8d ee 00 00
	00		 jge	 $LN9@clientConn

; 1142 :             {
; 1143 :                 // "%1d:%04X Shared: error in function %s: %s"
; 1144 :                 WRMSG( HHC00720, "E", LCSS_DEVNUM, "socket()", strerror( HSO_errno ));

  00235	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0023e	74 15		 je	 SHORT $LN29@clientConn
  00240	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00248	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0024c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  00253	eb 0b		 jmp	 SHORT $LN30@clientConn
$LN29@clientConn:
  00255	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv161[rsp], 0
$LN30@clientConn:
  00260	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00269	74 17		 je	 SHORT $LN31@clientConn
  0026b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00273	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00277	d1 f8		 sar	 eax, 1
  00279	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  00280	eb 0b		 jmp	 SHORT $LN32@clientConn
$LN31@clientConn:
  00282	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv167[rsp], 0
$LN32@clientConn:
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00293	8b c8		 mov	 ecx, eax
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0029b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  002a3	b9 01 00 00 00	 mov	 ecx, 1
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ae	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  002b6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169485
  002c2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  002ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  002d9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169486
  002e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169487
  002f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00300	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169488
  00307	ba 78 04 00 00	 mov	 edx, 1144		; 00000478H
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169489
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1145 :                 return -1;

  00319	b8 ff ff ff ff	 mov	 eax, -1
  0031e	e9 73 05 00 00	 jmp	 $LN1@clientConn
$LN9@clientConn:

; 1146 :             }
; 1147 : 
; 1148 :             iserver.sin_family = AF_INET;

  00323	b8 02 00 00 00	 mov	 eax, 2
  00328	66 89 84 24 e8
	00 00 00	 mov	 WORD PTR iserver$[rsp], ax

; 1149 :             iserver.sin_port   = htons( dev->rmtport );

  00330	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00338	0f b7 88 24 06
	00 00		 movzx	 ecx, WORD PTR [rax+1572]
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00345	66 89 84 24 ea
	00 00 00	 mov	 WORD PTR iserver$[rsp+2], ax

; 1150 :             memcpy( &iserver.sin_addr.s_addr, &dev->rmtaddr, sizeof( struct in_addr ));

  0034d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00355	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  0035b	89 84 24 ec 00
	00 00		 mov	 DWORD PTR iserver$[rsp+4], eax

; 1151 :             server = (struct sockaddr*) &iserver;

  00362	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR iserver$[rsp]
  0036a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR server$[rsp], rax

; 1152 :             len = sizeof( iserver );

  00372	c7 84 24 a4 00
	00 00 10 00 00
	00		 mov	 DWORD PTR len$[rsp], 16
$LN7@clientConn:

; 1153 :         }
; 1154 : 
; 1155 :         /* Connect to the server */
; 1156 :         store_hw( id, dev->rmtid );

  0037d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00385	0f b7 88 28 06
	00 00		 movzx	 ecx, WORD PTR [rax+1576]
  0038c	e8 00 00 00 00	 call	 _byteswap_ushort
  00391	0f b7 d0	 movzx	 edx, ax
  00394	48 8d 4c 24 74	 lea	 rcx, QWORD PTR id$[rsp]
  00399	e8 00 00 00 00	 call	 store_hw_noswap

; 1157 :         rc = connect( dev->fd, server, len );

  0039e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a6	48 63 80 ac 01
	00 00		 movsxd	 rax, DWORD PTR [rax+428]
  003ad	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  003b5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR server$[rsp]
  003bd	48 8b c8	 mov	 rcx, rax
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  003c6	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1158 : 
; 1159 :         if (rc < 0)

  003ca	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  003cf	7d 47		 jge	 SHORT $LN10@clientConn

; 1160 :             SHRDTRACE( "connect rc=%d errno=%d %s", rc, HSO_errno, strerror( HSO_errno ));

  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003d7	8b c8		 mov	 ecx, eax
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003df	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003ed	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv201[rsp]
  003f5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003fa	44 8b c8	 mov	 r9d, eax
  003fd	44 8b 44 24 70	 mov	 r8d, DWORD PTR rc$[rsp]
  00402	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169492
  00409	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00411	e8 00 00 00 00	 call	 shrdtrc
  00416	eb 19		 jmp	 SHORT $LN11@clientConn
$LN10@clientConn:

; 1161 :         else
; 1162 :             SHRDTRACE( "connect rc=%d", rc );

  00418	44 8b 44 24 70	 mov	 r8d, DWORD PTR rc$[rsp]
  0041d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169493
  00424	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042c	e8 00 00 00 00	 call	 shrdtrc
$LN11@clientConn:

; 1163 : 
; 1164 :         if (rc >= 0)

  00431	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00436	0f 8c c8 02 00
	00		 jl	 $LN12@clientConn

; 1165 :         {
; 1166 :             /* Request device connection (if we haven't done so yet) */
; 1167 :             if (!dev->connected)

  0043c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00444	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0044a	c1 e8 05	 shr	 eax, 5
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	0f 85 a7 02 00
	00		 jne	 $LN14@clientConn

; 1168 :             {
; 1169 :                 int flag = (SHARED_VERSION << 4) | SHARED_RELEASE;

  00458	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR flag$1[rsp], 2

; 1170 :                 rc = clientRequest( dev, id, 2, SHRD_CONNECT, flag, NULL, &flag );

  00460	48 8d 44 24 78	 lea	 rax, QWORD PTR flag$1[rsp]
  00465	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0046a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00473	8b 44 24 78	 mov	 eax, DWORD PTR flag$1[rsp]
  00477	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0047b	41 b9 e0 00 00
	00		 mov	 r9d, 224		; 000000e0H
  00481	41 b8 02 00 00
	00		 mov	 r8d, 2
  00487	48 8d 54 24 74	 lea	 rdx, QWORD PTR id$[rsp]
  0048c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00494	e8 00 00 00 00	 call	 clientRequest
  00499	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1171 :                 if (rc >= 0)

  0049d	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  004a2	0f 8c 57 02 00
	00		 jl	 $LN15@clientConn

; 1172 :                 {
; 1173 :                     dev->connected = 1;             // (SHRD_CONNECT success)

  004a8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004b0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004b6	83 c8 20	 or	 eax, 32			; 00000020H
  004b9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004c1	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1174 :                     dev->rmtid  = fetch_hw( id );   // (must only do ONCE!!!)

  004c7	48 8d 4c 24 74	 lea	 rcx, QWORD PTR id$[rsp]
  004cc	e8 00 00 00 00	 call	 fetch_hw_noswap
  004d1	0f b7 c8	 movzx	 ecx, ax
  004d4	e8 00 00 00 00	 call	 _byteswap_ushort
  004d9	0f b7 c0	 movzx	 eax, ax
  004dc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e4	89 81 28 06 00
	00		 mov	 DWORD PTR [rcx+1576], eax

; 1175 :                     dev->rmtver = flag >> 4;        // (save server version)

  004ea	8b 44 24 78	 mov	 eax, DWORD PTR flag$1[rsp]
  004ee	c1 f8 04	 sar	 eax, 4
  004f1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f9	89 81 2c 06 00
	00		 mov	 DWORD PTR [rcx+1580], eax

; 1176 :                     dev->rmtrel = flag & 0x0f;      // (save server release)

  004ff	8b 44 24 78	 mov	 eax, DWORD PTR flag$1[rsp]
  00503	83 e0 0f	 and	 eax, 15
  00506	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0050e	89 81 30 06 00
	00		 mov	 DWORD PTR [rcx+1584], eax

; 1177 : 
; 1178 :                     if (!dev->batch)

  00514	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0051c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00522	c1 e8 0a	 shr	 eax, 10
  00525	83 e0 01	 and	 eax, 1
  00528	85 c0		 test	 eax, eax
  0052a	0f 85 28 01 00
	00		 jne	 $LN16@clientConn

; 1179 :                         if (MLVL( VERBOSE ))

  00530	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00537	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0053d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00542	85 c0		 test	 eax, eax
  00544	0f 84 0e 01 00
	00		 je	 $LN17@clientConn

; 1180 :                             // "%1d:%04X Shared: connected to v%d.%d server id %d file %s"
; 1181 :                             WRMSG( HHC00721, "I", LCSS_DEVNUM, dev->rmtver,

  0054a	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00553	74 15		 je	 SHORT $LN33@clientConn
  00555	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0055d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00561	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv258[rsp], eax
  00568	eb 0b		 jmp	 SHORT $LN34@clientConn
$LN33@clientConn:
  0056a	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv258[rsp], 0
$LN34@clientConn:
  00575	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0057e	74 17		 je	 SHORT $LN35@clientConn
  00580	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00588	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0058c	d1 f8		 sar	 eax, 1
  0058e	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv264[rsp], eax
  00595	eb 0b		 jmp	 SHORT $LN36@clientConn
$LN35@clientConn:
  00597	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN36@clientConn:
  005a2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005aa	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  005b0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
  005b8	b9 01 00 00 00	 mov	 ecx, 1
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv247[rsp]
  005cb	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  005d0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005d8	8b 89 28 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1576]
  005de	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005e2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ea	8b 89 30 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1584]
  005f0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005f4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005fc	8b 89 2c 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1580]
  00602	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00606	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  0060d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00611	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  00618	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0061c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169500
  00623	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00628	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169501
  0062f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00634	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00639	41 b9 03 00 00
	00		 mov	 r9d, 3
  0063f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169502
  00646	ba 9e 04 00 00	 mov	 edx, 1182		; 0000049eH
  0064b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169503
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@clientConn:
$LN16@clientConn:

; 1182 :                                 dev->rmtrel, dev->rmtid, dev->filename );
; 1183 :                     /*
; 1184 :                      * Negotiate compression - top 4 bits have the compression
; 1185 :                      * algorithms we support (00010000 -> libz; 00100000 ->bzip2,
; 1186 :                      * 00110000 -> both) and the bottom 4 bits indicates the
; 1187 :                      * libz parm we want to use when sending data back & forth.
; 1188 :                      * If the server returns '0' back, then we won't use libz to
; 1189 :                      * compress data to the server.  What the 'compression
; 1190 :                      * algorithms we support' means is that if the data source is
; 1191 :                      * cckd or cfba then the server doesn't have to uncompress
; 1192 :                      * the data for us if we support the compression algorithm.
; 1193 :                      */
; 1194 :                     if (dev->rmtcomp || dev->rmtcomps)

  00658	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00660	83 b8 3c 06 00
	00 00		 cmp	 DWORD PTR [rax+1596], 0
  00667	75 15		 jne	 SHORT $LN19@clientConn
  00669	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00671	83 b8 40 06 00
	00 00		 cmp	 DWORD PTR [rax+1600], 0
  00678	0f 84 81 00 00
	00		 je	 $LN18@clientConn
$LN19@clientConn:

; 1195 :                     {
; 1196 :                         rc = clientRequest( dev, comp, 2, SHRD_COMPRESS,

  0067e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00686	8b 80 40 06 00
	00		 mov	 eax, DWORD PTR [rax+1600]
  0068c	c1 e0 04	 shl	 eax, 4
  0068f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00697	0b 81 3c 06 00
	00		 or	 eax, DWORD PTR [rcx+1596]
  0069d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006a6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  006af	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  006b3	41 b9 ec 00 00
	00		 mov	 r9d, 236		; 000000ecH
  006b9	41 b8 02 00 00
	00		 mov	 r8d, 2
  006bf	48 8d 54 24 7c	 lea	 rdx, QWORD PTR comp$[rsp]
  006c4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006cc	e8 00 00 00 00	 call	 clientRequest
  006d1	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1197 :                                    (dev->rmtcomps << 4) | dev->rmtcomp, NULL, NULL );
; 1198 :                         if (rc >= 0)

  006d5	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  006da	7c 23		 jl	 SHORT $LN20@clientConn

; 1199 :                             dev->rmtcomp = fetch_hw( comp );

  006dc	48 8d 4c 24 7c	 lea	 rcx, QWORD PTR comp$[rsp]
  006e1	e8 00 00 00 00	 call	 fetch_hw_noswap
  006e6	0f b7 c8	 movzx	 ecx, ax
  006e9	e8 00 00 00 00	 call	 _byteswap_ushort
  006ee	0f b7 c0	 movzx	 eax, ax
  006f1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f9	89 81 3c 06 00
	00		 mov	 DWORD PTR [rcx+1596], eax
$LN20@clientConn:
$LN18@clientConn:
$LN15@clientConn:
$LN14@clientConn:

; 1200 :                     }
; 1201 :                 }
; 1202 :             }
; 1203 :         }

  006ff	e9 0a 01 00 00	 jmp	 $LN13@clientConn
$LN12@clientConn:

; 1204 :         else if (!retry)

  00704	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0070c	0f 85 fc 00 00
	00		 jne	 $LN21@clientConn

; 1205 :             // "%1d:%04X Shared: error in connect to file %s: %s"
; 1206 :             WRMSG( HHC00722, "E", LCSS_DEVNUM, dev->filename, strerror( HSO_errno ));

  00712	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0071b	74 15		 je	 SHORT $LN37@clientConn
  0071d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00725	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00729	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv308[rsp], eax
  00730	eb 0b		 jmp	 SHORT $LN38@clientConn
$LN37@clientConn:
  00732	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv308[rsp], 0
$LN38@clientConn:
  0073d	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00746	74 17		 je	 SHORT $LN39@clientConn
  00748	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00750	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00754	d1 f8		 sar	 eax, 1
  00756	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv314[rsp], eax
  0075d	eb 0b		 jmp	 SHORT $LN40@clientConn
$LN39@clientConn:
  0075f	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv314[rsp], 0
$LN40@clientConn:
  0076a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00770	8b c8		 mov	 ecx, eax
  00772	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00778	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv299[rsp], rax
  00780	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00788	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0078f	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv303[rsp], rcx
  00797	b9 01 00 00 00	 mov	 ecx, 1
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv299[rsp]
  007aa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007af	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv303[rsp]
  007b7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007bc	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv308[rsp]
  007c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007c7	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv314[rsp]
  007ce	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169508
  007d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169509
  007e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169510
  007fc	ba b6 04 00 00	 mov	 edx, 1206		; 000004b6H
  00801	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169511
  00808	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@clientConn:
$LN13@clientConn:

; 1207 : 
; 1208 :         if (rc < 0 && retry)

  0080e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00813	7d 15		 jge	 SHORT $LN22@clientConn
  00815	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0081d	74 0b		 je	 SHORT $LN22@clientConn

; 1209 :             usleep( 20000 );    // (20ms between connect retries?!)

  0081f	b9 20 4e 00 00	 mov	 ecx, 20000		; 00004e20H
  00824	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN22@clientConn:

; 1210 :     }
; 1211 :     while (rc < 0 && retry && retries--);

  0082a	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0082f	7d 36		 jge	 SHORT $LN23@clientConn
  00831	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  00839	74 2c		 je	 SHORT $LN23@clientConn
  0083b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR retries$[rsp]
  00842	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  00849	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR retries$[rsp]
  00850	ff c8		 dec	 eax
  00852	89 84 24 80 00
	00 00		 mov	 DWORD PTR retries$[rsp], eax
  00859	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv332[rsp], 0
  00861	0f 85 f1 f7 ff
	ff		 jne	 $LN4@clientConn
$LN23@clientConn:

; 1212 : 
; 1213 :     SHRDTRACE( "end clientConnect sequence for dev %4.4x retry=%d", dev->devnum, retry );

  00867	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0086f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00873	44 8b 8c 24 18
	01 00 00	 mov	 r9d, DWORD PTR retry$[rsp]
  0087b	44 8b c0	 mov	 r8d, eax
  0087e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169514
  00885	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0088d	e8 00 00 00 00	 call	 shrdtrc

; 1214 : 
; 1215 :     return rc;

  00892	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@clientConn:

; 1216 : 
; 1217 : } /* clientConnect */

  00896	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0089e	48 33 cc	 xor	 rcx, rsp
  008a1	e8 00 00 00 00	 call	 __security_check_cookie
  008a6	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  008ad	c3		 ret	 0
clientConnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
devnum$ = 32
p$ = 36
trk$ = 40
dev$ = 48
answer$ = 80
ix$ = 88
i$ = 96
data$ = 104
clientPurgescan PROC

; 1059 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1060 : U16             devnum;                 /* Cached device number      */
; 1061 : int             trk;                    /* Cached track              */
; 1062 : int             p;                      /* Purge index               */
; 1063 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@clientPurg:

; 1064 : 
; 1065 :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@clientPurg

; 1066 :     SHRD_CACHE_GETKEY(i, devnum, trk);

  00027	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 cache_getkey
  00032	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00036	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003c	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00041	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00045	33 c9		 xor	 ecx, ecx
  00047	e8 00 00 00 00	 call	 cache_getkey
  0004c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00051	48 23 c1	 and	 rax, rcx
  00054	89 44 24 28	 mov	 DWORD PTR trk$[rsp], eax

; 1067 :     if (devnum == dev->devnum)

  00058	0f b7 44 24 20	 movzx	 eax, WORD PTR devnum$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00062	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00066	3b c1		 cmp	 eax, ecx
  00068	0f 85 af 00 00
	00		 jne	 $LN8@clientPurg

; 1068 :     {
; 1069 :         if (dev->rmtpurgen == 0) {

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00073	83 b8 44 06 00
	00 00		 cmp	 DWORD PTR [rax+1604], 0
  0007a	75 28		 jne	 SHORT $LN9@clientPurg

; 1070 :             cache_release (ix, i, 0);

  0007c	45 33 c0	 xor	 r8d, r8d
  0007f	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00083	8b 4c 24 58	 mov	 ecx, DWORD PTR ix$[rsp]
  00087	e8 00 00 00 00	 call	 cache_release

; 1071 :             SHRDTRACE("purge %d",trk);

  0008c	44 8b 44 24 28	 mov	 r8d, DWORD PTR trk$[rsp]
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169445
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0009d	e8 00 00 00 00	 call	 shrdtrc

; 1072 :         }

  000a2	eb 79		 jmp	 SHORT $LN10@clientPurg
$LN9@clientPurg:

; 1073 :         else
; 1074 :         {
; 1075 :             for (p = 0; p < dev->rmtpurgen; p++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR p$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN7@clientPurg
$LN5@clientPurg:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR p$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR p$[rsp], eax
$LN7@clientPurg:
  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000bd	8b 80 44 06 00
	00		 mov	 eax, DWORD PTR [rax+1604]
  000c3	39 44 24 24	 cmp	 DWORD PTR p$[rsp], eax
  000c7	7d 54		 jge	 SHORT $LN6@clientPurg

; 1076 :             {
; 1077 :                 if (trk == (int)fetch_fw (dev->rmtpurge[p]))

  000c9	48 63 44 24 24	 movsxd	 rax, DWORD PTR p$[rsp]
  000ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000d3	48 8b 89 48 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1608]
  000da	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000de	48 8b c8	 mov	 rcx, rax
  000e1	e8 00 00 00 00	 call	 fetch_fw_noswap
  000e6	8b c8		 mov	 ecx, eax
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	39 44 24 28	 cmp	 DWORD PTR trk$[rsp], eax
  000f1	75 28		 jne	 SHORT $LN11@clientPurg

; 1078 :                 {
; 1079 :                     SHRDTRACE("purge %d",trk);

  000f3	44 8b 44 24 28	 mov	 r8d, DWORD PTR trk$[rsp]
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169447
  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00104	e8 00 00 00 00	 call	 shrdtrc

; 1080 :                     cache_release (ix, i, 0);

  00109	45 33 c0	 xor	 r8d, r8d
  0010c	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00110	8b 4c 24 58	 mov	 ecx, DWORD PTR ix$[rsp]
  00114	e8 00 00 00 00	 call	 cache_release

; 1081 :                     break;

  00119	eb 02		 jmp	 SHORT $LN6@clientPurg
$LN11@clientPurg:

; 1082 :                 }
; 1083 :             }

  0011b	eb 91		 jmp	 SHORT $LN5@clientPurg
$LN6@clientPurg:
$LN10@clientPurg:
$LN8@clientPurg:

; 1084 :         }
; 1085 :     }
; 1086 :     return 0;

  0011d	33 c0		 xor	 eax, eax

; 1087 : } /* clientPurge */

  0011f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00123	c3		 ret	 0
clientPurgescan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
dev$ = 48
n$ = 56
buf$ = 64
clientPurge PROC

; 1051 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1052 :     cache_lock(CACHE_DEVBUF);

  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 cache_lock

; 1053 :     dev->rmtpurgen = n;

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00022	89 88 44 06 00
	00		 mov	 DWORD PTR [rax+1604], ecx

; 1054 :     dev->rmtpurge = (FWORD *)buf;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00032	48 89 88 48 06
	00 00		 mov	 QWORD PTR [rax+1608], rcx

; 1055 :     cache_scan (CACHE_DEVBUF, clientPurgescan, dev);

  00039	4c 8b 44 24 30	 mov	 r8, QWORD PTR dev$[rsp]
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:clientPurgescan
  00045	33 c9		 xor	 ecx, ecx
  00047	e8 00 00 00 00	 call	 cache_scan

; 1056 :     cache_unlock(CACHE_DEVBUF);

  0004c	33 c9		 xor	 ecx, ecx
  0004e	e8 00 00 00 00	 call	 cache_unlock

; 1057 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
clientPurge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
code$ = 96
len$ = 100
rc$ = 104
retries$ = 108
tv159 = 112
tv165 = 116
tv226 = 120
tv232 = 124
shdr$1 = 128
shdr$2 = 136
devnum$ = 144
tv217 = 148
status$ = 152
tv219 = 156
id$ = 160
hdr$ = 168
errmsg$ = 192
__$ArrayPad$ = 448
dev$ = 480
block$ = 488
clientWrite PROC

; 991  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 992  : int         rc;                         /* Return code               */
; 993  : int         retries = 10;               /* Number write retries      */

  00022	c7 44 24 6c 0a
	00 00 00	 mov	 DWORD PTR retries$[rsp], 10

; 994  : int         len;                        /* Data length               */
; 995  : BYTE        hdr[SHRD_HDR_SIZE + 2 + 4]; /* Write header              */
; 996  : BYTE        code;                       /* Response code             */
; 997  : int         status;                     /* Response status           */
; 998  : int         id;                         /* Response identifier       */
; 999  : U16         devnum;                     /* Response device number    */
; 1000 : BYTE        errmsg[SHARED_MAX_MSGLEN+1];/* Error message             */
; 1001 : 
; 1002 :     /* Calculate length to write */
; 1003 :     len = dev->bufupdhi - dev->bufupdlo;

  0002a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003a	8b 89 ec 01 00
	00		 mov	 ecx, DWORD PTR [rcx+492]
  00040	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [rax+496]
  00046	2b c1		 sub	 eax, ecx
  00048	89 44 24 64	 mov	 DWORD PTR len$[rsp], eax

; 1004 :     if (len <= 0 || dev->bufcur < 0)

  0004c	83 7c 24 64 00	 cmp	 DWORD PTR len$[rsp], 0
  00051	7e 11		 jle	 SHORT $LN9@clientWrit
  00053	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  00062	7d 2b		 jge	 SHORT $LN8@clientWrit
$LN9@clientWrit:

; 1005 :     {
; 1006 :         dev->bufupdlo = dev->bufupdhi = 0;

  00064	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  00076	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 1007 :         return 0;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 b1 04 00 00	 jmp	 $LN1@clientWrit
$LN8@clientWrit:

; 1008 :     }
; 1009 : 
; 1010 :     SHRDTRACE("write rcd %d off %d len %d",block,dev->bufupdlo,len);

  0008f	8b 44 24 64	 mov	 eax, DWORD PTR len$[rsp]
  00093	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00097	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	44 8b 88 ec 01
	00 00		 mov	 r9d, DWORD PTR [rax+492]
  000a6	44 8b 84 24 e8
	01 00 00	 mov	 r8d, DWORD PTR block$[rsp]
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169399
  000b5	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000bd	e8 00 00 00 00	 call	 shrdtrc
$write_retry$23:
$LN4@clientWrit:

; 1011 : 
; 1012 : write_retry:
; 1013 : 
; 1014 :     /* The write request contains a 2 byte offset and 4 byte id,
; 1015 :        followed by the data */
; 1016 :     SHRD_SET_HDR (hdr, SHRD_WRITE, 0, dev->rmtnum, dev->rmtid, len + 6);

  000c2	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR hdr$[rsp]
  000ca	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR shdr$1[rsp], rax
  000d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  000da	c6 00 e9	 mov	 BYTE PTR [rax], 233	; 000000e9H
  000dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$1[rsp]
  000e5	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  000e9	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	0f b7 88 26 06
	00 00		 movzx	 ecx, WORD PTR [rax+1574]
  000f8	e8 00 00 00 00	 call	 _byteswap_ushort
  000fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00105	48 83 c1 02	 add	 rcx, 2
  00109	0f b7 d0	 movzx	 edx, ax
  0010c	e8 00 00 00 00	 call	 store_hw_noswap
  00111	8b 44 24 64	 mov	 eax, DWORD PTR len$[rsp]
  00115	83 c0 06	 add	 eax, 6
  00118	0f b7 c8	 movzx	 ecx, ax
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00128	48 83 c1 04	 add	 rcx, 4
  0012c	0f b7 d0	 movzx	 edx, ax
  0012f	e8 00 00 00 00	 call	 store_hw_noswap
  00134	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013c	0f b7 88 28 06
	00 00		 movzx	 ecx, WORD PTR [rax+1576]
  00143	e8 00 00 00 00	 call	 _byteswap_ushort
  00148	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00150	48 83 c1 06	 add	 rcx, 6
  00154	0f b7 d0	 movzx	 edx, ax
  00157	e8 00 00 00 00	 call	 store_hw_noswap
  0015c	33 c0		 xor	 eax, eax
  0015e	85 c0		 test	 eax, eax
  00160	0f 85 5c ff ff
	ff		 jne	 $LN4@clientWrit

; 1017 :     store_hw (hdr + SHRD_HDR_SIZE, dev->bufupdlo);

  00166	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016e	0f b7 88 ec 01
	00 00		 movzx	 ecx, WORD PTR [rax+492]
  00175	e8 00 00 00 00	 call	 _byteswap_ushort
  0017a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR hdr$[rsp+8]
  00182	0f b7 d0	 movzx	 edx, ax
  00185	e8 00 00 00 00	 call	 store_hw_noswap

; 1018 :     store_fw (hdr + SHRD_HDR_SIZE + 2, block);

  0018a	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR block$[rsp]
  00191	e8 00 00 00 00	 call	 _byteswap_ulong
  00196	48 8d 8c 24 b2
	00 00 00	 lea	 rcx, QWORD PTR hdr$[rsp+10]
  0019e	8b d0		 mov	 edx, eax
  001a0	e8 00 00 00 00	 call	 store_fw_noswap

; 1019 : 
; 1020 :     rc = clientSend (dev, hdr, dev->buf + dev->bufupdlo, len);

  001a5	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ad	48 63 80 ec 01
	00 00		 movsxd	 rax, DWORD PTR [rax+492]
  001b4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bc	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  001c3	44 8b 4c 24 64	 mov	 r9d, DWORD PTR len$[rsp]
  001c8	4c 8b c0	 mov	 r8, rax
  001cb	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  001d3	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001db	e8 00 00 00 00	 call	 clientSend
  001e0	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1021 :     if (rc < 0)

  001e4	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  001e9	0f 8d f5 00 00
	00		 jge	 $LN10@clientWrit

; 1022 :     {
; 1023 :         // "%1d:%04X Shared: error writing track %d"
; 1024 :         WRMSG( HHC00718, "E", LCSS_DEVNUM, dev->bufcur );

  001ef	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f8	74 12		 je	 SHORT $LN15@clientWrit
  001fa	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00202	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00206	89 44 24 70	 mov	 DWORD PTR tv159[rsp], eax
  0020a	eb 08		 jmp	 SHORT $LN16@clientWrit
$LN15@clientWrit:
  0020c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@clientWrit:
  00214	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0021d	74 14		 je	 SHORT $LN17@clientWrit
  0021f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00227	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0022b	d1 f8		 sar	 eax, 1
  0022d	89 44 24 74	 mov	 DWORD PTR tv165[rsp], eax
  00231	eb 08		 jmp	 SHORT $LN18@clientWrit
$LN17@clientWrit:
  00233	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN18@clientWrit:
  0023b	b9 01 00 00 00	 mov	 ecx, 1
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00246	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024e	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+448]
  00254	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00258	8b 4c 24 70	 mov	 ecx, DWORD PTR tv159[rsp]
  0025c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00260	8b 4c 24 74	 mov	 ecx, DWORD PTR tv165[rsp]
  00264	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169401
  0026f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00274	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169402
  0027b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00280	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00285	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169403
  00292	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169404
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1025 :         dev->bufupdlo = dev->bufupdhi = 0;

  002a4	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ac	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  002b6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002be	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 1026 :         clientPurge (dev, 0, NULL);

  002c8	45 33 c0	 xor	 r8d, r8d
  002cb	33 d2		 xor	 edx, edx
  002cd	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d5	e8 00 00 00 00	 call	 clientPurge

; 1027 :         return -1;

  002da	b8 ff ff ff ff	 mov	 eax, -1
  002df	e9 5c 02 00 00	 jmp	 $LN1@clientWrit
$LN10@clientWrit:

; 1028 :     }
; 1029 : 
; 1030 :     /* Get the response */
; 1031 :     rc = clientRecv (dev, hdr, errmsg, sizeof(errmsg));

  002e4	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  002ea	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR errmsg$[rsp]
  002f2	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  002fa	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00302	e8 00 00 00 00	 call	 clientRecv
  00307	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
$LN7@clientWrit:

; 1032 :     SHRD_GET_HDR (hdr, code, status, devnum, id, len);

  0030b	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR hdr$[rsp]
  00313	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR shdr$2[rsp], rax
  0031b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00323	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00326	88 44 24 60	 mov	 BYTE PTR code$[rsp], al
  0032a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00332	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00336	89 84 24 98 00
	00 00		 mov	 DWORD PTR status$[rsp], eax
  0033d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00345	48 83 c0 02	 add	 rax, 2
  00349	48 8b c8	 mov	 rcx, rax
  0034c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00351	0f b7 c8	 movzx	 ecx, ax
  00354	e8 00 00 00 00	 call	 _byteswap_ushort
  00359	66 89 84 24 90
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  00361	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00369	48 83 c0 04	 add	 rax, 4
  0036d	48 8b c8	 mov	 rcx, rax
  00370	e8 00 00 00 00	 call	 fetch_hw_noswap
  00375	0f b7 c8	 movzx	 ecx, ax
  00378	e8 00 00 00 00	 call	 _byteswap_ushort
  0037d	0f b7 c0	 movzx	 eax, ax
  00380	89 44 24 64	 mov	 DWORD PTR len$[rsp], eax
  00384	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  0038c	48 83 c0 06	 add	 rax, 6
  00390	48 8b c8	 mov	 rcx, rax
  00393	e8 00 00 00 00	 call	 fetch_hw_noswap
  00398	0f b7 c8	 movzx	 ecx, ax
  0039b	e8 00 00 00 00	 call	 _byteswap_ushort
  003a0	0f b7 c0	 movzx	 eax, ax
  003a3	89 84 24 a0 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
  003aa	33 c0		 xor	 eax, eax
  003ac	85 c0		 test	 eax, eax
  003ae	0f 85 57 ff ff
	ff		 jne	 $LN7@clientWrit

; 1033 :     if (rc < 0 || (code & SHRD_ERROR) || (code & SHRD_IOERR))

  003b4	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  003b9	7c 1e		 jl	 SHORT $LN12@clientWrit
  003bb	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$[rsp]
  003c0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003c5	85 c0		 test	 eax, eax
  003c7	75 10		 jne	 SHORT $LN12@clientWrit
  003c9	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$[rsp]
  003ce	83 e0 40	 and	 eax, 64			; 00000040H
  003d1	85 c0		 test	 eax, eax
  003d3	0f 84 3f 01 00
	00		 je	 $LN11@clientWrit
$LN12@clientWrit:

; 1034 :     {
; 1035 :         if (rc < 0 && retries--) goto write_retry;

  003d9	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  003de	7d 24		 jge	 SHORT $LN13@clientWrit
  003e0	8b 44 24 6c	 mov	 eax, DWORD PTR retries$[rsp]
  003e4	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv217[rsp], eax
  003eb	8b 44 24 6c	 mov	 eax, DWORD PTR retries$[rsp]
  003ef	ff c8		 dec	 eax
  003f1	89 44 24 6c	 mov	 DWORD PTR retries$[rsp], eax
  003f5	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv217[rsp], 0
  003fd	74 05		 je	 SHORT $LN13@clientWrit
  003ff	e9 be fc ff ff	 jmp	 $write_retry$23
$LN13@clientWrit:

; 1036 :         // "%1d:%04X Shared: remote error writing track %d %2.2X-%2.2X"
; 1037 :         WRMSG( HHC00719, "E", LCSS_DEVNUM, dev->bufcur, code, status );

  00404	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0040d	74 12		 je	 SHORT $LN19@clientWrit
  0040f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00417	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0041b	89 44 24 78	 mov	 DWORD PTR tv226[rsp], eax
  0041f	eb 08		 jmp	 SHORT $LN20@clientWrit
$LN19@clientWrit:
  00421	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN20@clientWrit:
  00429	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00432	74 14		 je	 SHORT $LN21@clientWrit
  00434	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00440	d1 f8		 sar	 eax, 1
  00442	89 44 24 7c	 mov	 DWORD PTR tv232[rsp], eax
  00446	eb 08		 jmp	 SHORT $LN22@clientWrit
$LN21@clientWrit:
  00448	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
$LN22@clientWrit:
  00450	0f b6 44 24 60	 movzx	 eax, BYTE PTR code$[rsp]
  00455	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
  0045c	b9 01 00 00 00	 mov	 ecx, 1
  00461	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00467	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR status$[rsp]
  0046e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00472	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv219[rsp]
  00479	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0047d	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00485	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+448]
  0048b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0048f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv226[rsp]
  00493	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00497	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv232[rsp]
  0049b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169408
  004a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169409
  004b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169410
  004c9	ba 0d 04 00 00	 mov	 edx, 1037		; 0000040dH
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169411
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1038 :         dev->bufupdlo = dev->bufupdhi = 0;

  004db	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e3	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  004ed	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f5	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 1039 :         clientPurge (dev, 0, NULL);

  004ff	45 33 c0	 xor	 r8d, r8d
  00502	33 d2		 xor	 edx, edx
  00504	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0050c	e8 00 00 00 00	 call	 clientPurge

; 1040 :         return -1;

  00511	b8 ff ff ff ff	 mov	 eax, -1
  00516	eb 28		 jmp	 SHORT $LN1@clientWrit
$LN11@clientWrit:

; 1041 :     }
; 1042 : 
; 1043 :     dev->bufupdlo = dev->bufupdhi = 0;

  00518	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00520	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  0052a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00532	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 1044 :     return rc;

  0053c	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@clientWrit:

; 1045 : } /* clientWrite */

  00540	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00548	48 33 cc	 xor	 rcx, rsp
  0054b	e8 00 00 00 00	 call	 __security_check_cookie
  00550	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  00557	c3		 ret	 0
clientWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 64
dev$ = 96
shared_release PROC

; 975  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 976  : int      rc;                            /* Return code               */
; 977  : 
; 978  :     /* Issue release request */
; 979  :     rc = clientRequest (dev, NULL, 0, SHRD_RELEASE, 0, NULL, NULL);

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00012	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00023	41 b9 e7 00 00
	00		 mov	 r9d, 231		; 000000e7H
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00033	e8 00 00 00 00	 call	 clientRequest
  00038	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 980  : 
; 981  : } /* shared_release */

  0003c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00040	c3		 ret	 0
shared_release ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 64
dev$ = 96
shared_reserve PROC

; 963  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 964  : int      rc;                            /* Return code               */
; 965  : 
; 966  :     /* Issue reserve request */
; 967  :     rc = clientRequest (dev, NULL, 0, SHRD_RESERVE, 0, NULL, NULL);

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00012	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00023	41 b9 e6 00 00
	00		 mov	 r9d, 230		; 000000e6H
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00033	e8 00 00 00 00	 call	 clientRequest
  00038	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 968  : 
; 969  : } /* shared_reserve */

  0003c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00040	c3		 ret	 0
shared_reserve ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tv76 = 80
tv82 = 84
rc$ = 88
usage$ = 92
dev$ = 112
shared_used PROC

; 944  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 945  : int      rc;                            /* Return code               */
; 946  : FWORD    usage;                         /* Usage buffer              */
; 947  : 
; 948  :     /* Get usage information */
; 949  :     rc = clientRequest (dev, usage, 4, SHRD_USED, 0, NULL, NULL);

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00012	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00023	41 b9 43 00 00
	00		 mov	 r9d, 67			; 00000043H
  00029	41 b8 04 00 00
	00		 mov	 r8d, 4
  0002f	48 8d 54 24 5c	 lea	 rdx, QWORD PTR usage$[rsp]
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00039	e8 00 00 00 00	 call	 clientRequest
  0003e	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 950  :     if (rc != 4)

  00042	83 7c 24 58 04	 cmp	 DWORD PTR rc$[rsp], 4
  00047	0f 84 9e 00 00
	00		 je	 $LN2@shared_use

; 951  :     {
; 952  :         // "%1d:%04X Shared: error retrieving usage information"
; 953  :         WRMSG( HHC00717, "E", LCSS_DEVNUM );

  0004d	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 0f		 je	 SHORT $LN4@shared_use
  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0005e	89 44 24 50	 mov	 DWORD PTR tv76[rsp], eax
  00062	eb 08		 jmp	 SHORT $LN5@shared_use
$LN4@shared_use:
  00064	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@shared_use:
  0006c	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00072	74 11		 je	 SHORT $LN6@shared_use
  00074	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00079	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007d	d1 f8		 sar	 eax, 1
  0007f	89 44 24 54	 mov	 DWORD PTR tv82[rsp], eax
  00083	eb 08		 jmp	 SHORT $LN7@shared_use
$LN6@shared_use:
  00085	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN7@shared_use:
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00098	8b 4c 24 50	 mov	 ecx, DWORD PTR tv76[rsp]
  0009c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a0	8b 4c 24 54	 mov	 ecx, DWORD PTR tv82[rsp]
  000a4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169343
  000af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169344
  000bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169345
  000d2	ba b9 03 00 00	 mov	 edx, 953		; 000003b9H
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169346
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 954  :         return -1;

  000e4	b8 ff ff ff ff	 mov	 eax, -1
  000e9	eb 11		 jmp	 SHORT $LN1@shared_use
$LN2@shared_use:

; 955  :     }
; 956  :     return fetch_fw (usage);

  000eb	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR usage$[rsp]
  000f0	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f5	8b c8		 mov	 ecx, eax
  000f7	e8 00 00 00 00	 call	 _byteswap_ulong
$LN1@shared_use:

; 957  : } /* shared_used */

  000fc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00100	c3		 ret	 0
shared_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
sz$ = 32
dev$ = 64
buf$ = 72
shared_ckd_trklen PROC

; 918  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 919  : int             sz;                     /* Size so far               */
; 920  : 
; 921  :     for (sz = CKD_TRKHDR_SIZE;

  0000e	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR sz$[rsp], 5
$LN2@shared_ckd:

; 922  :          memcmp( buf + sz, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) != 0; )

  00016	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 memcmp
  0003b	85 c0		 test	 eax, eax
  0003d	74 70		 je	 SHORT $LN3@shared_ckd

; 923  :     {
; 924  :         /* add length of count, key, and data fields */
; 925  :         sz += CKD_RECHDR_SIZE +

  0003f	8b 44 24 20	 mov	 eax, DWORD PTR sz$[rsp]
  00043	83 c0 05	 add	 eax, 5
  00046	48 98		 cdqe
  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0004d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00051	8b 4c 24 20	 mov	 ecx, DWORD PTR sz$[rsp]
  00055	83 c1 06	 add	 ecx, 6
  00058	48 63 c9	 movsxd	 rcx, ecx
  0005b	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  00060	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00064	c1 e1 08	 shl	 ecx, 8
  00067	48 63 c9	 movsxd	 rcx, ecx
  0006a	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR sz$[rsp]
  00073	83 c1 07	 add	 ecx, 7
  00076	48 63 c9	 movsxd	 rcx, ecx
  00079	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  0007e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00082	48 03 c1	 add	 rax, rcx
  00085	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR sz$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 926  :                 buf[sz+5] +
; 927  :                 (buf[sz+6] << 8) + buf[sz+7];
; 928  :         if (sz > dev->ckdtrksz - 8) break;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00099	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  0009f	83 e8 08	 sub	 eax, 8
  000a2	39 44 24 20	 cmp	 DWORD PTR sz$[rsp], eax
  000a6	7e 02		 jle	 SHORT $LN5@shared_ckd
  000a8	eb 05		 jmp	 SHORT $LN3@shared_ckd
$LN5@shared_ckd:

; 929  :     }

  000aa	e9 67 ff ff ff	 jmp	 $LN2@shared_ckd
$LN3@shared_ckd:

; 930  : 
; 931  :     /* add length for end-of-track indicator */
; 932  :     sz += CKD_RECHDR_SIZE;

  000af	48 63 44 24 20	 movsxd	 rax, DWORD PTR sz$[rsp]
  000b4	48 83 c0 08	 add	 rax, 8
  000b8	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 933  : 
; 934  :     if (sz > dev->ckdtrksz)

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  000c7	39 44 24 20	 cmp	 DWORD PTR sz$[rsp], eax
  000cb	7e 0f		 jle	 SHORT $LN6@shared_ckd

; 935  :         sz = dev->ckdtrksz;

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000d2	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  000d8	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax
$LN6@shared_ckd:

; 936  : 
; 937  :     return sz;

  000dc	8b 44 24 20	 mov	 eax, DWORD PTR sz$[rsp]

; 938  : }

  000e0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e4	c3		 ret	 0
shared_ckd_trklen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 48
dev$ = 96
trk$ = 104
off$ = 112
buf$ = 120
len$ = 128
unitstat$ = 136
shared_ckd_write PROC

; 858  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 859  : int      rc;                            /* Return code               */
; 860  : 
; 861  :     /* Immediately return if fake writing */
; 862  :     if (dev->ckdfakewr)

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00024	c1 e8 14	 shr	 eax, 20
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN2@shared_ckd

; 863  :         return len;

  0002e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00035	e9 e4 01 00 00	 jmp	 $LN1@shared_ckd
$LN2@shared_ckd:

; 864  : 
; 865  :     /* Error if opened read-only */
; 866  :     if (dev->ckdrdonly)

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00045	c1 e8 12	 shr	 eax, 18
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	74 31		 je	 SHORT $LN3@shared_ckd

; 867  :     {
; 868  :         ckd_build_sense (dev, SENSE_EC, SENSE1_WRI, 0,

  0004f	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00054	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00059	45 33 c9	 xor	 r9d, r9d
  0005c	41 b0 02	 mov	 r8b, 2
  0005f	b2 10		 mov	 dl, 16
  00061	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00066	e8 00 00 00 00	 call	 ckd_build_sense

; 869  :                         FORMAT_1, MESSAGE_0);
; 870  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0006b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00073	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 871  :         return -1;

  00076	b8 ff ff ff ff	 mov	 eax, -1
  0007b	e9 9e 01 00 00	 jmp	 $LN1@shared_ckd
$LN3@shared_ckd:

; 872  :     }
; 873  : 
; 874  :     SHRDTRACE( "ckd write trk %d off %d len %d", trk, off, len );

  00080	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00087	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008b	44 8b 4c 24 70	 mov	 r9d, DWORD PTR off$[rsp]
  00090	44 8b 44 24 68	 mov	 r8d, DWORD PTR trk$[rsp]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169308
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000a1	e8 00 00 00 00	 call	 shrdtrc

; 875  : 
; 876  :     /* If the track is not current then read it */
; 877  :     if (trk != dev->bufcur)

  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ab	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000b1	39 44 24 68	 cmp	 DWORD PTR trk$[rsp], eax
  000b5	74 53		 je	 SHORT $LN4@shared_ckd

; 878  :     {
; 879  :         rc = (dev->hnd->read) (dev, trk, unitstat);

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000bc	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000c3	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000cb	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  000cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000d4	ff 50 50	 call	 QWORD PTR [rax+80]
  000d7	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 880  :         if (rc < 0)

  000db	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  000e0	7d 28		 jge	 SHORT $LN5@shared_ckd

; 881  :         {
; 882  :             dev->bufcur = dev->cache = -1;

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  000f1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000f6	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 883  :             return -1;

  00100	b8 ff ff ff ff	 mov	 eax, -1
  00105	e9 14 01 00 00	 jmp	 $LN1@shared_ckd
$LN5@shared_ckd:
$LN4@shared_ckd:

; 884  :         }
; 885  :     }
; 886  : 
; 887  :     /* Invalid track format if going past buffer end */
; 888  :     if (off + len > dev->bufoffhi)

  0010a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00111	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  00115	03 c8		 add	 ecx, eax
  00117	8b c1		 mov	 eax, ecx
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0011e	3b 81 e8 01 00
	00		 cmp	 eax, DWORD PTR [rcx+488]
  00124	7e 31		 jle	 SHORT $LN6@shared_ckd

; 889  :     {
; 890  :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  00126	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0012b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00130	45 33 c9	 xor	 r9d, r9d
  00133	41 b0 40	 mov	 r8b, 64			; 00000040H
  00136	33 d2		 xor	 edx, edx
  00138	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0013d	e8 00 00 00 00	 call	 ckd_build_sense

; 891  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00142	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0014a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 892  :         return -1;

  0014d	b8 ff ff ff ff	 mov	 eax, -1
  00152	e9 c7 00 00 00	 jmp	 $LN1@shared_ckd
$LN6@shared_ckd:

; 893  :     }
; 894  : 
; 895  :     /* Copy the data into the buffer */
; 896  :     if (buf) memcpy (dev->buf + off, buf, len);

  00157	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0015d	74 26		 je	 SHORT $LN7@shared_ckd
  0015f	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00167	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR off$[rsp]
  0016c	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00171	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00178	48 8b f9	 mov	 rdi, rcx
  0017b	48 8b 74 24 78	 mov	 rsi, QWORD PTR buf$[rsp]
  00180	48 8b c8	 mov	 rcx, rax
  00183	f3 a4		 rep movsb
$LN7@shared_ckd:

; 897  : 
; 898  :     /* Set low and high updated offsets */
; 899  :     if (!dev->bufupd || off < dev->bufupdlo)

  00185	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  00191	74 11		 je	 SHORT $LN9@shared_ckd
  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00198	8b 80 ec 01 00
	00		 mov	 eax, DWORD PTR [rax+492]
  0019e	39 44 24 70	 cmp	 DWORD PTR off$[rsp], eax
  001a2	7d 0f		 jge	 SHORT $LN8@shared_ckd
$LN9@shared_ckd:

; 900  :         dev->bufupdlo = off;

  001a4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  001ad	89 88 ec 01 00
	00		 mov	 DWORD PTR [rax+492], ecx
$LN8@shared_ckd:

; 901  :     if (dev->bufoff + len > dev->bufupdhi)

  001b3	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001b8	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  001be	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR len$[rsp]
  001c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	3b 81 f0 01 00
	00		 cmp	 eax, DWORD PTR [rcx+496]
  001d0	7e 1a		 jle	 SHORT $LN10@shared_ckd

; 902  :         dev->bufupdhi = off + len;

  001d2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001d9	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  001dd	03 c8		 add	 ecx, eax
  001df	8b c1		 mov	 eax, ecx
  001e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001e6	89 81 f0 01 00
	00		 mov	 DWORD PTR [rcx+496], eax
$LN10@shared_ckd:

; 903  : 
; 904  :     /* Indicate track image has been modified */
; 905  :     if (!dev->bufupd)

  001ec	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001f1	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  001f8	75 1d		 jne	 SHORT $LN11@shared_ckd

; 906  :     {
; 907  :         dev->bufupd = 1;

  001fa	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001ff	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 908  :         shared_update_notify (dev, trk);

  00209	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  0020d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00212	e8 00 00 00 00	 call	 shared_update_notify
$LN11@shared_ckd:

; 909  :     }
; 910  : 
; 911  :     return len;

  00217	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@shared_ckd:

; 912  : } /* shared_ckd_write */

  0021e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00222	5f		 pop	 rdi
  00223	5e		 pop	 rsi
  00224	c3		 ret	 0
shared_ckd_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
code$ = 80
lru$ = 84
cache$ = 88
rc$ = 92
retries$ = 96
tv247 = 100
tv253 = 104
tv309 = 108
tv315 = 112
shdr$1 = 120
shdr$2 = 128
devnum$ = 136
tv298 = 140
status$ = 144
len$ = 148
id$ = 152
buf$ = 160
hdr$ = 168
__$ArrayPad$ = 184
dev$ = 208
trk$ = 216
unitstat$ = 224
shared_ckd_read PROC

; 727  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 728  : int      rc;                            /* Return code               */
; 729  : int      retries = 10;                  /* Number read retries       */

  00027	c7 44 24 60 0a
	00 00 00	 mov	 DWORD PTR retries$[rsp], 10

; 730  : int      cache;                         /* Lookup index              */
; 731  : int      lru;                           /* Available index           */
; 732  : int      len;                           /* Response length           */
; 733  : int      id;                            /* Response id               */
; 734  : int      status;                        /* Response status           */
; 735  : BYTE    *buf;                           /* Cache buffer              */
; 736  : BYTE     code;                          /* Response code             */
; 737  : U16      devnum;                        /* Response device number    */
; 738  : BYTE     hdr[SHRD_HDR_SIZE + 4];        /* Read request header       */
; 739  : 
; 740  :     /* Return if reading the same track image */
; 741  :     if (trk == dev->bufcur && dev->cache >= 0)

  0002f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  0003d	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00044	75 46		 jne	 SHORT $LN8@shared_ckd
  00046	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004e	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00055	7c 35		 jl	 SHORT $LN8@shared_ckd

; 742  :     {
; 743  :         dev->bufoff = 0;

  00057	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 744  :         dev->bufoffhi = dev->ckdtrksz;

  00069	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00071	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0007f	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 745  :         return 0;

  00085	33 c0		 xor	 eax, eax
  00087	e9 26 08 00 00	 jmp	 $LN1@shared_ckd
$LN8@shared_ckd:

; 746  :     }
; 747  : 
; 748  :     SHRDTRACE( "ckd read trk %d", trk );

  0008c	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169271
  0009b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a3	e8 00 00 00 00	 call	 shrdtrc

; 749  : 
; 750  :     /* Write the previous active entry if it was updated */
; 751  :     if (dev->bufupd)

  000a8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  000b7	74 1b		 je	 SHORT $LN9@shared_ckd

; 752  :         clientWrite (dev, dev->bufcur);

  000b9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	8b 90 c0 01 00
	00		 mov	 edx, DWORD PTR [rax+448]
  000c7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000cf	e8 00 00 00 00	 call	 clientWrite
$LN9@shared_ckd:

; 753  :     dev->bufupd = 0;

  000d4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dc	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 754  : 
; 755  :     /* Reset buffer offsets */
; 756  :     dev->bufoff = 0;

  000e6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ee	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 757  :     dev->bufoffhi = dev->ckdtrksz;

  000f8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00100	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0010e	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 758  : 
; 759  :     cache_lock (CACHE_DEVBUF);

  00114	33 c9		 xor	 ecx, ecx
  00116	e8 00 00 00 00	 call	 cache_lock

; 760  : 
; 761  :     /* Inactivate the previous image */
; 762  :     if (dev->cache >= 0)

  0011b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00123	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0012a	7c 1e		 jl	 SHORT $LN10@shared_ckd

; 763  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~SHRD_CACHE_ACTIVE, 0);

  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00135	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00143	33 c9		 xor	 ecx, ecx
  00145	e8 00 00 00 00	 call	 cache_setflag
$LN10@shared_ckd:

; 764  :     dev->cache = dev->bufcur = -1;

  0014a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00152	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  0015c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
$cache_retry$27:

; 765  : 
; 766  : cache_retry:
; 767  : 
; 768  :     /* Lookup the track in the cache */
; 769  :     cache = cache_lookup (CACHE_DEVBUF, SHRD_CACHE_SETKEY(dev->devnum, trk), &lru);

  0016e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00176	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0017a	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0017e	48 63 8c 24 d8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  00186	48 0b c1	 or	 rax, rcx
  00189	4c 8d 44 24 54	 lea	 r8, QWORD PTR lru$[rsp]
  0018e	48 8b d0	 mov	 rdx, rax
  00191	33 c9		 xor	 ecx, ecx
  00193	e8 00 00 00 00	 call	 cache_lookup
  00198	89 44 24 58	 mov	 DWORD PTR cache$[rsp], eax

; 770  : 
; 771  :     /* Process cache hit */
; 772  :     if (cache >= 0)

  0019c	83 7c 24 58 00	 cmp	 DWORD PTR cache$[rsp], 0
  001a1	0f 8c 23 01 00
	00		 jl	 $LN11@shared_ckd

; 773  :     {
; 774  :         cache_setflag (CACHE_DEVBUF, cache, ~0, SHRD_CACHE_ACTIVE);

  001a7	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  001ad	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  001b3	8b 54 24 58	 mov	 edx, DWORD PTR cache$[rsp]
  001b7	33 c9		 xor	 ecx, ecx
  001b9	e8 00 00 00 00	 call	 cache_setflag

; 775  :         cache_unlock (CACHE_DEVBUF);

  001be	33 c9		 xor	 ecx, ecx
  001c0	e8 00 00 00 00	 call	 cache_unlock

; 776  :         dev->cachehits++;

  001c5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001cd	8b 80 fc 01 00
	00		 mov	 eax, DWORD PTR [rax+508]
  001d3	ff c0		 inc	 eax
  001d5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001dd	89 81 fc 01 00
	00		 mov	 DWORD PTR [rcx+508], eax

; 777  :         dev->cache = cache;

  001e3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001eb	8b 4c 24 58	 mov	 ecx, DWORD PTR cache$[rsp]
  001ef	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 778  :         dev->buf = cache_getbuf (CACHE_DEVBUF, cache, 0);

  001f5	45 33 c0	 xor	 r8d, r8d
  001f8	8b 54 24 58	 mov	 edx, DWORD PTR cache$[rsp]
  001fc	33 c9		 xor	 ecx, ecx
  001fe	e8 00 00 00 00	 call	 cache_getbuf
  00203	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020b	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 779  :         dev->bufcur = trk;

  00212	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00221	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 780  :         dev->bufoff = 0;

  00227	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022f	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 781  :         dev->bufoffhi = dev->ckdtrksz;

  00239	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00241	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00249	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0024f	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 782  :         dev->buflen = shared_ckd_trklen (dev, dev->buf);

  00255	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025d	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00264	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026c	e8 00 00 00 00	 call	 shared_ckd_trklen
  00271	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00279	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 783  :         dev->bufsize = cache_getlen (CACHE_DEVBUF, cache);

  0027f	8b 54 24 58	 mov	 edx, DWORD PTR cache$[rsp]
  00283	33 c9		 xor	 ecx, ecx
  00285	e8 00 00 00 00	 call	 cache_getlen
  0028a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00292	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 784  :         SHRDTRACE( "ckd read trk %d cache hit %d", trk, dev->cache );

  00298	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a0	44 8b 88 f8 01
	00 00		 mov	 r9d, DWORD PTR [rax+504]
  002a7	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169275
  002b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002be	e8 00 00 00 00	 call	 shrdtrc

; 785  :         return 0;

  002c3	33 c0		 xor	 eax, eax
  002c5	e9 e8 05 00 00	 jmp	 $LN1@shared_ckd
$LN11@shared_ckd:

; 786  :     }
; 787  : 
; 788  :     /* Special processing if no available cache entry */
; 789  :     if (lru < 0)

  002ca	83 7c 24 54 00	 cmp	 DWORD PTR lru$[rsp], 0
  002cf	7d 46		 jge	 SHORT $LN12@shared_ckd

; 790  :     {
; 791  :         SHRDTRACE( "ckd read trk %d cache wait", trk );

  002d1	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169277
  002e0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e8	e8 00 00 00 00	 call	 shrdtrc

; 792  :         dev->cachewaits++;

  002ed	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f5	8b 80 04 02 00
	00		 mov	 eax, DWORD PTR [rax+516]
  002fb	ff c0		 inc	 eax
  002fd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00305	89 81 04 02 00
	00		 mov	 DWORD PTR [rcx+516], eax

; 793  :         cache_wait (CACHE_DEVBUF);

  0030b	33 c9		 xor	 ecx, ecx
  0030d	e8 00 00 00 00	 call	 cache_wait

; 794  :         goto cache_retry;

  00312	e9 57 fe ff ff	 jmp	 $cache_retry$27
$LN12@shared_ckd:

; 795  :     }
; 796  : 
; 797  :     /* Process cache miss */
; 798  :     SHRDTRACE( "ckd read trk %d cache miss %d", trk, dev->cache );

  00317	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031f	44 8b 88 f8 01
	00 00		 mov	 r9d, DWORD PTR [rax+504]
  00326	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169278
  00335	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033d	e8 00 00 00 00	 call	 shrdtrc

; 799  :     dev->cachemisses++;

  00342	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0034a	8b 80 00 02 00
	00		 mov	 eax, DWORD PTR [rax+512]
  00350	ff c0		 inc	 eax
  00352	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035a	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 800  :     cache_setflag (CACHE_DEVBUF, lru, 0, SHRD_CACHE_ACTIVE|DEVBUF_TYPE_SCKD);

  00360	41 b9 82 00 00
	80		 mov	 r9d, -2147483518	; 80000082H
  00366	45 33 c0	 xor	 r8d, r8d
  00369	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  0036d	33 c9		 xor	 ecx, ecx
  0036f	e8 00 00 00 00	 call	 cache_setflag

; 801  :     cache_setkey (CACHE_DEVBUF, lru, SHRD_CACHE_SETKEY(dev->devnum, trk));

  00374	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0037c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00380	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00384	48 63 8c 24 d8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  0038c	48 0b c1	 or	 rax, rcx
  0038f	4c 8b c0	 mov	 r8, rax
  00392	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  00396	33 c9		 xor	 ecx, ecx
  00398	e8 00 00 00 00	 call	 cache_setkey

; 802  :     cache_setage (CACHE_DEVBUF, lru);

  0039d	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  003a1	33 c9		 xor	 ecx, ecx
  003a3	e8 00 00 00 00	 call	 cache_setage

; 803  :     buf = cache_getbuf (CACHE_DEVBUF, lru, dev->ckdtrksz);

  003a8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b0	44 8b 80 c4 12
	00 00		 mov	 r8d, DWORD PTR [rax+4804]
  003b7	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  003bb	33 c9		 xor	 ecx, ecx
  003bd	e8 00 00 00 00	 call	 cache_getbuf
  003c2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 804  : 
; 805  :     cache_unlock (CACHE_DEVBUF);

  003ca	33 c9		 xor	 ecx, ecx
  003cc	e8 00 00 00 00	 call	 cache_unlock
$read_retry$28:
$LN4@shared_ckd:

; 806  : 
; 807  : read_retry:
; 808  : 
; 809  :     /* Send the read request for the track to the remote host */
; 810  :     SHRD_SET_HDR (hdr, SHRD_READ, 0, dev->rmtnum, dev->rmtid, 4);

  003d1	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR hdr$[rsp]
  003d9	48 89 44 24 78	 mov	 QWORD PTR shdr$1[rsp], rax
  003de	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  003e3	c6 00 e8	 mov	 BYTE PTR [rax], 232	; 000000e8H
  003e6	48 8b 44 24 78	 mov	 rax, QWORD PTR shdr$1[rsp]
  003eb	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
  003ef	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f7	0f b7 88 26 06
	00 00		 movzx	 ecx, WORD PTR [rax+1574]
  003fe	e8 00 00 00 00	 call	 _byteswap_ushort
  00403	48 8b 4c 24 78	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00408	48 83 c1 02	 add	 rcx, 2
  0040c	0f b7 d0	 movzx	 edx, ax
  0040f	e8 00 00 00 00	 call	 store_hw_noswap
  00414	66 b9 04 00	 mov	 cx, 4
  00418	e8 00 00 00 00	 call	 _byteswap_ushort
  0041d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00422	48 83 c1 04	 add	 rcx, 4
  00426	0f b7 d0	 movzx	 edx, ax
  00429	e8 00 00 00 00	 call	 store_hw_noswap
  0042e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00436	0f b7 88 28 06
	00 00		 movzx	 ecx, WORD PTR [rax+1576]
  0043d	e8 00 00 00 00	 call	 _byteswap_ushort
  00442	48 8b 4c 24 78	 mov	 rcx, QWORD PTR shdr$1[rsp]
  00447	48 83 c1 06	 add	 rcx, 6
  0044b	0f b7 d0	 movzx	 edx, ax
  0044e	e8 00 00 00 00	 call	 store_hw_noswap
  00453	33 c0		 xor	 eax, eax
  00455	85 c0		 test	 eax, eax
  00457	0f 85 74 ff ff
	ff		 jne	 $LN4@shared_ckd

; 811  :     store_fw (hdr + SHRD_HDR_SIZE, trk);

  0045d	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00464	e8 00 00 00 00	 call	 _byteswap_ulong
  00469	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR hdr$[rsp+8]
  00471	8b d0		 mov	 edx, eax
  00473	e8 00 00 00 00	 call	 store_fw_noswap

; 812  :     rc = clientSend (dev, hdr, NULL, 0);

  00478	45 33 c9	 xor	 r9d, r9d
  0047b	45 33 c0	 xor	 r8d, r8d
  0047e	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  00486	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0048e	e8 00 00 00 00	 call	 clientSend
  00493	89 44 24 5c	 mov	 DWORD PTR rc$[rsp], eax

; 813  :     if (rc < 0)

  00497	83 7c 24 5c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0049c	0f 8d e2 00 00
	00		 jge	 $LN13@shared_ckd

; 814  :     {
; 815  :         ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  004a2	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  004a7	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  004ac	45 33 c9	 xor	 r9d, r9d
  004af	45 33 c0	 xor	 r8d, r8d
  004b2	b2 10		 mov	 dl, 16
  004b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bc	e8 00 00 00 00	 call	 ckd_build_sense

; 816  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004c1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004c9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 817  :         // "%1d:%04X Shared: remote error reading track %d"
; 818  :         WRMSG( HHC00715, "E", LCSS_DEVNUM, trk );

  004cc	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004d5	74 12		 je	 SHORT $LN19@shared_ckd
  004d7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004df	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004e3	89 44 24 64	 mov	 DWORD PTR tv247[rsp], eax
  004e7	eb 08		 jmp	 SHORT $LN20@shared_ckd
$LN19@shared_ckd:
  004e9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv247[rsp], 0
$LN20@shared_ckd:
  004f1	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004fa	74 14		 je	 SHORT $LN21@shared_ckd
  004fc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00504	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00508	d1 f8		 sar	 eax, 1
  0050a	89 44 24 68	 mov	 DWORD PTR tv253[rsp], eax
  0050e	eb 08		 jmp	 SHORT $LN22@shared_ckd
$LN21@shared_ckd:
  00510	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN22@shared_ckd:
  00518	b9 01 00 00 00	 mov	 ecx, 1
  0051d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00523	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0052a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0052e	8b 4c 24 64	 mov	 ecx, DWORD PTR tv247[rsp]
  00532	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00536	8b 4c 24 68	 mov	 ecx, DWORD PTR tv253[rsp]
  0053a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0053e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169280
  00545	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0054a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  00551	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00556	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0055b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00561	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169282
  00568	ba 32 03 00 00	 mov	 edx, 818		; 00000332H
  0056d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169283
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 819  :         return -1;

  0057a	b8 ff ff ff ff	 mov	 eax, -1
  0057f	e9 2e 03 00 00	 jmp	 $LN1@shared_ckd
$LN13@shared_ckd:

; 820  :     }
; 821  : 
; 822  :     /* Read the track from the remote host */
; 823  :     rc = clientRecv (dev, hdr, buf, dev->ckdtrksz);

  00584	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0058c	44 8b 88 c4 12
	00 00		 mov	 r9d, DWORD PTR [rax+4804]
  00593	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0059b	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR hdr$[rsp]
  005a3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ab	e8 00 00 00 00	 call	 clientRecv
  005b0	89 44 24 5c	 mov	 DWORD PTR rc$[rsp], eax
$LN7@shared_ckd:

; 824  :     SHRD_GET_HDR( hdr, code, status, devnum, id, len );

  005b4	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR hdr$[rsp]
  005bc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR shdr$2[rsp], rax
  005c4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  005cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005cf	88 44 24 50	 mov	 BYTE PTR code$[rsp], al
  005d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  005db	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005df	89 84 24 90 00
	00 00		 mov	 DWORD PTR status$[rsp], eax
  005e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  005ee	48 83 c0 02	 add	 rax, 2
  005f2	48 8b c8	 mov	 rcx, rax
  005f5	e8 00 00 00 00	 call	 fetch_hw_noswap
  005fa	0f b7 c8	 movzx	 ecx, ax
  005fd	e8 00 00 00 00	 call	 _byteswap_ushort
  00602	66 89 84 24 88
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  0060a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00612	48 83 c0 04	 add	 rax, 4
  00616	48 8b c8	 mov	 rcx, rax
  00619	e8 00 00 00 00	 call	 fetch_hw_noswap
  0061e	0f b7 c8	 movzx	 ecx, ax
  00621	e8 00 00 00 00	 call	 _byteswap_ushort
  00626	0f b7 c0	 movzx	 eax, ax
  00629	89 84 24 94 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00630	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR shdr$2[rsp]
  00638	48 83 c0 06	 add	 rax, 6
  0063c	48 8b c8	 mov	 rcx, rax
  0063f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00644	0f b7 c8	 movzx	 ecx, ax
  00647	e8 00 00 00 00	 call	 _byteswap_ushort
  0064c	0f b7 c0	 movzx	 eax, ax
  0064f	89 84 24 98 00
	00 00		 mov	 DWORD PTR id$[rsp], eax
  00656	33 c0		 xor	 eax, eax
  00658	85 c0		 test	 eax, eax
  0065a	0f 85 54 ff ff
	ff		 jne	 $LN7@shared_ckd

; 825  :     if (rc < 0 || code & SHRD_ERROR)

  00660	83 7c 24 5c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00665	7c 12		 jl	 SHORT $LN15@shared_ckd
  00667	0f b6 44 24 50	 movzx	 eax, BYTE PTR code$[rsp]
  0066c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00671	85 c0		 test	 eax, eax
  00673	0f 84 0d 01 00
	00		 je	 $LN14@shared_ckd
$LN15@shared_ckd:

; 826  :     {
; 827  :         if (rc < 0 && retries--) goto read_retry;

  00679	83 7c 24 5c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0067e	7d 24		 jge	 SHORT $LN16@shared_ckd
  00680	8b 44 24 60	 mov	 eax, DWORD PTR retries$[rsp]
  00684	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv298[rsp], eax
  0068b	8b 44 24 60	 mov	 eax, DWORD PTR retries$[rsp]
  0068f	ff c8		 dec	 eax
  00691	89 44 24 60	 mov	 DWORD PTR retries$[rsp], eax
  00695	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv298[rsp], 0
  0069d	74 05		 je	 SHORT $LN16@shared_ckd
  0069f	e9 2d fd ff ff	 jmp	 $read_retry$28
$LN16@shared_ckd:

; 828  :         ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  006a4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  006a9	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  006ae	45 33 c9	 xor	 r9d, r9d
  006b1	45 33 c0	 xor	 r8d, r8d
  006b4	b2 10		 mov	 dl, 16
  006b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006be	e8 00 00 00 00	 call	 ckd_build_sense

; 829  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  006c3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006cb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 830  :         // "%1d:%04X Shared: remote error reading track %d"
; 831  :         WRMSG( HHC00715, "E", LCSS_DEVNUM, trk );

  006ce	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006d7	74 12		 je	 SHORT $LN23@shared_ckd
  006d9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006e1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006e5	89 44 24 6c	 mov	 DWORD PTR tv309[rsp], eax
  006e9	eb 08		 jmp	 SHORT $LN24@shared_ckd
$LN23@shared_ckd:
  006eb	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv309[rsp], 0
$LN24@shared_ckd:
  006f3	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006fc	74 14		 je	 SHORT $LN25@shared_ckd
  006fe	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00706	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0070a	d1 f8		 sar	 eax, 1
  0070c	89 44 24 70	 mov	 DWORD PTR tv315[rsp], eax
  00710	eb 08		 jmp	 SHORT $LN26@shared_ckd
$LN25@shared_ckd:
  00712	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv315[rsp], 0
$LN26@shared_ckd:
  0071a	b9 01 00 00 00	 mov	 ecx, 1
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00725	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0072c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00730	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv309[rsp]
  00734	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00738	8b 4c 24 70	 mov	 ecx, DWORD PTR tv315[rsp]
  0073c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00740	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169287
  00747	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169288
  00753	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00758	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00763	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169289
  0076a	ba 3f 03 00 00	 mov	 edx, 831		; 0000033fH
  0076f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169290
  00776	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 832  :         return -1;

  0077c	b8 ff ff ff ff	 mov	 eax, -1
  00781	e9 2c 01 00 00	 jmp	 $LN1@shared_ckd
$LN14@shared_ckd:

; 833  :     }
; 834  : 
; 835  :     /* Read the sense data if an i/o error occurred */
; 836  :     if (code & SHRD_IOERR)

  00786	0f b6 44 24 50	 movzx	 eax, BYTE PTR code$[rsp]
  0078b	83 e0 40	 and	 eax, 64			; 00000040H
  0078e	85 c0		 test	 eax, eax
  00790	74 4d		 je	 SHORT $LN17@shared_ckd

; 837  :         clientRequest (dev, dev->sense, dev->numsense,

  00792	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0079a	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  007a0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007a9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  007b2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  007ba	41 b9 ea 00 00
	00		 mov	 r9d, 234		; 000000eaH
  007c0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007c8	44 8b 81 60 03
	00 00		 mov	 r8d, DWORD PTR [rcx+864]
  007cf	48 8b d0	 mov	 rdx, rax
  007d2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007da	e8 00 00 00 00	 call	 clientRequest
$LN17@shared_ckd:

; 838  :                       SHRD_SENSE, 0, NULL, NULL);
; 839  : 
; 840  :     /* Read complete */
; 841  :     dev->cache = lru;

  007df	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007e7	8b 4c 24 54	 mov	 ecx, DWORD PTR lru$[rsp]
  007eb	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 842  :     dev->buf = cache_getbuf (CACHE_DEVBUF, lru, 0);

  007f1	45 33 c0	 xor	 r8d, r8d
  007f4	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  007f8	33 c9		 xor	 ecx, ecx
  007fa	e8 00 00 00 00	 call	 cache_getbuf
  007ff	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00807	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 843  :     dev->bufcur = trk;

  0080e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00816	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0081d	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 844  :     dev->bufoff = 0;

  00823	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0082b	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 845  :     dev->bufoffhi = dev->ckdtrksz;

  00835	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0083d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00845	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0084b	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 846  :     dev->buflen = shared_ckd_trklen (dev, dev->buf);

  00851	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00859	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00860	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00868	e8 00 00 00 00	 call	 shared_ckd_trklen
  0086d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00875	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 847  :     dev->bufsize = cache_getlen (CACHE_DEVBUF, lru);

  0087b	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  0087f	33 c9		 xor	 ecx, ecx
  00881	e8 00 00 00 00	 call	 cache_getlen
  00886	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0088e	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 848  :     dev->buf[0] = 0;

  00894	b8 01 00 00 00	 mov	 eax, 1
  00899	48 6b c0 00	 imul	 rax, rax, 0
  0089d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008a5	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  008ac	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 849  : 
; 850  :     return 0;

  008b0	33 c0		 xor	 eax, eax
$LN1@shared_ckd:

; 851  : } /* shared_ckd_read */

  008b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008ba	48 33 cc	 xor	 rcx, rsp
  008bd	e8 00 00 00 00	 call	 __security_check_cookie
  008c2	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  008c9	c3		 ret	 0
shared_ckd_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
tv129 = 80
tv135 = 84
rc$ = 88
dev$ = 112
shared_end PROC

; 692  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 693  : int      rc;                            /* Return code               */
; 694  : 
; 695  :     SHRDTRACE("end cur %d cache %d",dev->bufcur,dev->cache);

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	44 8b 88 f8 01
	00 00		 mov	 r9d, DWORD PTR [rax+504]
  00015	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001a	44 8b 80 c0 01
	00 00		 mov	 r8d, DWORD PTR [rax+448]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169215
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	e8 00 00 00 00	 call	 shrdtrc

; 696  : 
; 697  :     /* Write the previous active entry if it was updated */
; 698  :     if (dev->bufupd)

  00032	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00037	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0003e	74 15		 je	 SHORT $LN2@shared_end

; 699  :         clientWrite (dev, dev->bufcur);

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00045	8b 90 c0 01 00
	00		 mov	 edx, DWORD PTR [rax+448]
  0004b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	e8 00 00 00 00	 call	 clientWrite
$LN2@shared_end:

; 700  :     dev->bufupd = 0;

  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 701  : 
; 702  :     /* Mark the active entry inactive */
; 703  :     if (dev->cache >= 0)

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00069	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00070	7c 29		 jl	 SHORT $LN3@shared_end

; 704  :     {
; 705  :         cache_lock (CACHE_DEVBUF);

  00072	33 c9		 xor	 ecx, ecx
  00074	e8 00 00 00 00	 call	 cache_lock

; 706  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~SHRD_CACHE_ACTIVE, 0);

  00079	45 33 c9	 xor	 r9d, r9d
  0007c	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00087	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0008d	33 c9		 xor	 ecx, ecx
  0008f	e8 00 00 00 00	 call	 cache_setflag

; 707  :         cache_unlock (CACHE_DEVBUF);

  00094	33 c9		 xor	 ecx, ecx
  00096	e8 00 00 00 00	 call	 cache_unlock
$LN3@shared_end:

; 708  :     }
; 709  : 
; 710  :     /* Send the END request */
; 711  :     rc = clientRequest (dev, NULL, 0, SHRD_END, 0, NULL, NULL);

  0009b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000ad	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000b5	41 b9 e3 00 00
	00		 mov	 r9d, 227		; 000000e3H
  000bb	45 33 c0	 xor	 r8d, r8d
  000be	33 d2		 xor	 edx, edx
  000c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000c5	e8 00 00 00 00	 call	 clientRequest
  000ca	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 712  :     if (rc < 0)

  000ce	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d3	0f 8d d4 00 00
	00		 jge	 $LN4@shared_end

; 713  :     {
; 714  :         // "%1d:%04X Shared: error during channel program end"
; 715  :         WRMSG( HHC00714, "E", LCSS_DEVNUM );

  000d9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000df	74 0f		 je	 SHORT $LN6@shared_end
  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000e6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ea	89 44 24 50	 mov	 DWORD PTR tv129[rsp], eax
  000ee	eb 08		 jmp	 SHORT $LN7@shared_end
$LN6@shared_end:
  000f0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN7@shared_end:
  000f8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000fe	74 11		 je	 SHORT $LN8@shared_end
  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00105	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00109	d1 f8		 sar	 eax, 1
  0010b	89 44 24 54	 mov	 DWORD PTR tv135[rsp], eax
  0010f	eb 08		 jmp	 SHORT $LN9@shared_end
$LN8@shared_end:
  00111	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN9@shared_end:
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00124	8b 4c 24 50	 mov	 ecx, DWORD PTR tv129[rsp]
  00128	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0012c	8b 4c 24 54	 mov	 ecx, DWORD PTR tv135[rsp]
  00130	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169219
  0013b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169220
  00147	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00151	41 b9 03 00 00
	00		 mov	 r9d, 3
  00157	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169221
  0015e	ba cb 02 00 00	 mov	 edx, 715		; 000002cbH
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169222
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 716  :         clientPurge (dev, 0, NULL);

  00170	45 33 c0	 xor	 r8d, r8d
  00173	33 d2		 xor	 edx, edx
  00175	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0017a	e8 00 00 00 00	 call	 clientPurge

; 717  :         dev->cache = dev->bufcur = -1;

  0017f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00184	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  0018e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00193	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 718  :         dev->buf = NULL;

  0019d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001a2	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0
$LN4@shared_end:

; 719  :         return;
; 720  :     }
; 721  : } /* shared_end */

  001ad	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b1	c3		 ret	 0
shared_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 80
devnum$ = 84
tv82 = 88
tv88 = 92
code$ = 96
trk$ = 100
buf$ = 112
__$ArrayPad$ = 176
dev$ = 208
shared_start PROC

; 643  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 644  : int      rc;                            /* Return code               */
; 645  : U16      devnum;                        /* Cache device number       */
; 646  : int      trk;                           /* Cache track number        */
; 647  : int      code;                          /* Response code             */
; 648  : BYTE     buf[SHARED_PURGE_MAX * 4];     /* Purge list                */
; 649  : 
; 650  :     SHRDTRACE("start cur %d cache %d",dev->bufcur,dev->cache);

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	44 8b 88 f8 01
	00 00		 mov	 r9d, DWORD PTR [rax+504]
  0002d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	44 8b 80 c0 01
	00 00		 mov	 r8d, DWORD PTR [rax+448]
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169195
  00043	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004b	e8 00 00 00 00	 call	 shrdtrc

; 651  : 
; 652  :     /* Send the START request */
; 653  :     rc = clientRequest (dev, buf, sizeof(buf),

  00050	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00059	48 8d 44 24 60	 lea	 rax, QWORD PTR code$[rsp]
  0005e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00063	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0006b	41 b9 e2 00 00
	00		 mov	 r9d, 226		; 000000e2H
  00071	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00077	48 8d 54 24 70	 lea	 rdx, QWORD PTR buf$[rsp]
  0007c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00084	e8 00 00 00 00	 call	 clientRequest
  00089	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 654  :                         SHRD_START, 0, &code, NULL);
; 655  :     if (rc < 0)

  0008d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00092	0f 8d f1 00 00
	00		 jge	 $LN2@shared_sta

; 656  :     {
; 657  :         // "%1d:%04X Shared: error during channel program start"
; 658  :         WRMSG( HHC00713, "E", LCSS_DEVNUM );

  00098	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000a1	74 12		 je	 SHORT $LN9@shared_sta
  000a3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ab	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000af	89 44 24 58	 mov	 DWORD PTR tv82[rsp], eax
  000b3	eb 08		 jmp	 SHORT $LN10@shared_sta
$LN9@shared_sta:
  000b5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN10@shared_sta:
  000bd	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c6	74 14		 je	 SHORT $LN11@shared_sta
  000c8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000d4	d1 f8		 sar	 eax, 1
  000d6	89 44 24 5c	 mov	 DWORD PTR tv88[rsp], eax
  000da	eb 08		 jmp	 SHORT $LN12@shared_sta
$LN11@shared_sta:
  000dc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN12@shared_sta:
  000e4	b9 01 00 00 00	 mov	 ecx, 1
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ef	8b 4c 24 58	 mov	 ecx, DWORD PTR tv82[rsp]
  000f3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f7	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv88[rsp]
  000fb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169197
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169198
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169199
  00129	ba 92 02 00 00	 mov	 edx, 658		; 00000292H
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169200
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 659  :         clientPurge (dev, 0, NULL);

  0013b	45 33 c0	 xor	 r8d, r8d
  0013e	33 d2		 xor	 edx, edx
  00140	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	e8 00 00 00 00	 call	 clientPurge

; 660  :         dev->cache = dev->bufcur = -1;

  0014d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00155	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  0015f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00167	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 661  :         dev->buf = NULL;

  00171	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00179	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 662  :         return;

  00184	e9 31 01 00 00	 jmp	 $LN1@shared_sta
$LN2@shared_sta:

; 663  :     }
; 664  : 
; 665  :     /* Check for purge */
; 666  :     if (code & SHRD_PURGE)

  00189	8b 44 24 60	 mov	 eax, DWORD PTR code$[rsp]
  0018d	83 e0 08	 and	 eax, 8
  00190	85 c0		 test	 eax, eax
  00192	74 3b		 je	 SHORT $LN3@shared_sta

; 667  :     {
; 668  :         if (rc / 4 > SHARED_PURGE_MAX) rc = 0;

  00194	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00198	99		 cdq
  00199	83 e2 03	 and	 edx, 3
  0019c	03 c2		 add	 eax, edx
  0019e	c1 f8 02	 sar	 eax, 2
  001a1	83 f8 10	 cmp	 eax, 16
  001a4	7e 08		 jle	 SHORT $LN4@shared_sta
  001a6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@shared_sta:

; 669  :         clientPurge (dev, rc / 4, buf);

  001ae	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  001b2	99		 cdq
  001b3	83 e2 03	 and	 edx, 3
  001b6	03 c2		 add	 eax, edx
  001b8	c1 f8 02	 sar	 eax, 2
  001bb	4c 8d 44 24 70	 lea	 r8, QWORD PTR buf$[rsp]
  001c0	8b d0		 mov	 edx, eax
  001c2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	e8 00 00 00 00	 call	 clientPurge
$LN3@shared_sta:

; 670  :     }
; 671  : 
; 672  :     /* Make previous active entry active again */
; 673  :     if (dev->cache >= 0)

  001cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  001de	0f 8c d6 00 00
	00		 jl	 $LN5@shared_sta

; 674  :     {
; 675  :         cache_lock (CACHE_DEVBUF);

  001e4	33 c9		 xor	 ecx, ecx
  001e6	e8 00 00 00 00	 call	 cache_lock

; 676  :         SHRD_CACHE_GETKEY (dev->cache, devnum, trk);

  001eb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f3	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001f9	33 c9		 xor	 ecx, ecx
  001fb	e8 00 00 00 00	 call	 cache_getkey
  00200	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00204	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0020a	66 89 44 24 54	 mov	 WORD PTR devnum$[rsp], ax
  0020f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00217	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0021d	33 c9		 xor	 ecx, ecx
  0021f	e8 00 00 00 00	 call	 cache_getkey
  00224	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00229	48 23 c1	 and	 rax, rcx
  0022c	89 44 24 64	 mov	 DWORD PTR trk$[rsp], eax

; 677  :         if (dev->devnum == devnum && dev->bufcur == trk)

  00230	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00238	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0023c	0f b7 4c 24 54	 movzx	 ecx, WORD PTR devnum$[rsp]
  00241	3b c1		 cmp	 eax, ecx
  00243	75 37		 jne	 SHORT $LN6@shared_sta
  00245	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024d	8b 4c 24 64	 mov	 ecx, DWORD PTR trk$[rsp]
  00251	39 88 c0 01 00
	00		 cmp	 DWORD PTR [rax+448], ecx
  00257	75 23		 jne	 SHORT $LN6@shared_sta

; 678  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~0, SHRD_CACHE_ACTIVE);

  00259	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  0025f	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00265	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00273	33 c9		 xor	 ecx, ecx
  00275	e8 00 00 00 00	 call	 cache_setflag
  0027a	eb 37		 jmp	 SHORT $LN7@shared_sta
$LN6@shared_sta:

; 679  :         else
; 680  :         {
; 681  :             dev->cache = dev->bufcur = -1;

  0027c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00284	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  0028e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00296	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 682  :             dev->buf = NULL;

  002a0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a8	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0
$LN7@shared_sta:

; 683  :         }
; 684  :         cache_unlock (CACHE_DEVBUF);

  002b3	33 c9		 xor	 ecx, ecx
  002b5	e8 00 00 00 00	 call	 cache_unlock
$LN5@shared_sta:
$LN1@shared_sta:

; 685  :     }
; 686  : } /* shared_start */

  002ba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002c2	48 33 cc	 xor	 rcx, rsp
  002c5	e8 00 00 00 00	 call	 __security_check_cookie
  002ca	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002d1	c3		 ret	 0
shared_start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
dev$ = 80
shared_fba_close PROC

; 624  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 625  :     /* Purge the cached entries */
; 626  :     clientPurge (dev, 0, NULL);

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	33 d2		 xor	 edx, edx
  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00013	e8 00 00 00 00	 call	 clientPurge

; 627  : 
; 628  :     /* Disconnect and close */
; 629  :     if (dev->fd >= 0)

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00024	7c 4f		 jl	 SHORT $LN2@shared_fba

; 630  :     {
; 631  :         clientRequest (dev, NULL, 0, SHRD_DISCONNECT, 0, NULL, NULL);

  00026	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0002f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00038	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00040	41 b9 e1 00 00
	00		 mov	 r9d, 225		; 000000e1H
  00046	45 33 c0	 xor	 r8d, r8d
  00049	33 d2		 xor	 edx, edx
  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	e8 00 00 00 00	 call	 clientRequest

; 632  :         close_socket (dev->fd);

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 633  :         dev->fd = -1;

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0006b	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN2@shared_fba:

; 634  :     }
; 635  : 
; 636  :     return 0;

  00075	33 c0		 xor	 eax, eax

; 637  : }

  00077	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007b	c3		 ret	 0
shared_fba_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
dev$ = 80
shared_ckd_close PROC

; 359  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 360  :     /* Purge the cached entries */
; 361  :     clientPurge (dev, 0, NULL);

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	33 d2		 xor	 edx, edx
  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00013	e8 00 00 00 00	 call	 clientPurge

; 362  : 
; 363  :     /* Disconnect and close */
; 364  :     if (dev->fd >= 0)

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00024	7c 4f		 jl	 SHORT $LN2@shared_ckd

; 365  :     {
; 366  :         clientRequest (dev, NULL, 0, SHRD_DISCONNECT, 0, NULL, NULL);

  00026	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0002f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00038	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00040	41 b9 e1 00 00
	00		 mov	 r9d, 225		; 000000e1H
  00046	45 33 c0	 xor	 r8d, r8d
  00049	33 d2		 xor	 edx, edx
  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	e8 00 00 00 00	 call	 clientRequest

; 367  :         close_socket (dev->fd);

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 368  :         dev->fd = -1;

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0006b	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN2@shared_ckd:

; 369  :     }
; 370  : 
; 371  :     return 0;

  00075	33 c0		 xor	 eax, eax

; 372  : } /* shared_ckd_close */

  00077	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007b	c3		 ret	 0
shared_ckd_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
shared_print_trace_table PROC

; 3168 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3169 :     OBTAIN_SHRDTRACE_LOCK();

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170829
  00018	48 8b c8	 mov	 rcx, rax
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3170 :     {
; 3171 :         shared_print_trace_table_locked();

  00021	e8 00 00 00 00	 call	 shared_print_trace_table_locked

; 3172 :     }
; 3173 :     RELEASE_SHRDTRACE_LOCK();

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002d	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170830
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3174 : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
shared_print_trace_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
c$ = 80
shrdtracen$1 = 84
dtax$2 = 88
op$ = 96
tv349 = 104
tv351 = 108
shrdtrace$3 = 112
kw$ = 120
strtok_str$ = 128
tv142 = 136
tv225 = 144
tv295 = 152
tv363 = 160
shrdtracep$4 = 168
shrdtracex$5 = 176
buf$6 = 184
buf$ = 224
__$ArrayPad$ = 480
argc$ = 512
argv$ = 520
cmdline$ = 528
shrd_cmd PROC

; 3010 : {

$LN28:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3011 :     char buf[256];
; 3012 :     char *kw, *op, c;
; 3013 :     char *strtok_str = NULL;

  00027	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0
$LN4@shrd_cmd:

; 3014 : 
; 3015 :     UNREFERENCED( cmdline );

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@shrd_cmd
$LN7@shrd_cmd:

; 3016 : 
; 3017 :     UPPER_ARGV_0( argv );

  00039	48 83 bc 24 08
	02 00 00 00	 cmp	 QWORD PTR argv$[rsp], 0
  00042	74 47		 je	 SHORT $LN8@shrd_cmd
  00044	b8 08 00 00 00	 mov	 eax, 8
  00049	48 6b c0 00	 imul	 rax, rax, 0
  0004d	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00055	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0005a	74 2f		 je	 SHORT $LN8@shrd_cmd
  0005c	b8 08 00 00 00	 mov	 eax, 8
  00061	48 6b c0 00	 imul	 rax, rax, 0
  00065	b9 08 00 00 00	 mov	 ecx, 8
  0006a	48 6b c9 00	 imul	 rcx, rcx, 0
  0006e	48 8b 94 24 08
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00076	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  0007a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00082	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00086	e8 00 00 00 00	 call	 strupper
$LN8@shrd_cmd:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 a8		 jne	 SHORT $LN7@shrd_cmd

; 3018 : 
; 3019 :     /* Get keyword and operand */
; 3020 :     if (0
; 3021 :         ||  argc < 1
; 3022 :         ||  argc > 2
; 3023 :         || (argc > 1 && strlen( argv[1] ) >= _countof( buf ))

  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 40		 jne	 SHORT $LN10@shrd_cmd
  00097	83 bc 24 00 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0009f	7c 36		 jl	 SHORT $LN10@shrd_cmd
  000a1	83 bc 24 00 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000a9	7f 2c		 jg	 SHORT $LN10@shrd_cmd
  000ab	83 bc 24 00 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000b3	7e 73		 jle	 SHORT $LN9@shrd_cmd
  000b5	b8 08 00 00 00	 mov	 eax, 8
  000ba	48 6b c0 01	 imul	 rax, rax, 1
  000be	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000c6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000ca	e8 00 00 00 00	 call	 strlen
  000cf	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000d5	72 51		 jb	 SHORT $LN9@shrd_cmd
$LN10@shrd_cmd:

; 3024 :     )
; 3025 :     {
; 3026 :         // "Shared: invalid or missing argument"
; 3027 :         WRMSG( HHC00738, "E" );

  000d7	b9 01 00 00 00	 mov	 ecx, 1
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170757
  000e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170758
  000f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00105	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170759
  0010c	ba d3 0b 00 00	 mov	 edx, 3027		; 00000bd3H
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170760
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3028 :         return -1;

  0011e	b8 ff ff ff ff	 mov	 eax, -1
  00123	e9 22 08 00 00	 jmp	 $LN1@shrd_cmd
$LN9@shrd_cmd:

; 3029 :     }
; 3030 : 
; 3031 :     if (argc < 2)

  00128	83 bc 24 00 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00130	0f 8d f9 00 00
	00		 jge	 $LN11@shrd_cmd

; 3032 :     {
; 3033 :         OBTAIN_SHRDTRACE_LOCK();

  00136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013d	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170762
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3034 :         {
; 3035 :             MSGBUF( buf, "TRACE=%d DTAX=%d", sysblk.shrdtracen, sysblk.shrddtax );

  00153	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015a	0f b6 80 dc 13
	00 00		 movzx	 eax, BYTE PTR [rax+5084]
  00161	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00165	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0016c	44 8b 88 d8 13
	00 00		 mov	 r9d, DWORD PTR [rax+5080]
  00173	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170763
  0017a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0017f	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3036 :         }
; 3037 :         RELEASE_SHRDTRACE_LOCK();

  0018d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00194	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170764
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3038 :         // "%-14s: %s"
; 3039 :         WRMSG( HHC02203, "I", argv[0], buf );

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	48 6b c0 00	 imul	 rax, rax, 0
  001b3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c6	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001ce	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001d3	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001db	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv142[rsp]
  001e3	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170765
  001f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170766
  001ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00204	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00209	41 b9 03 00 00
	00		 mov	 r9d, 3
  0020f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170767
  00216	ba df 0b 00 00	 mov	 edx, 3039		; 00000bdfH
  0021b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170768
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3040 :         return 0;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 1b 07 00 00	 jmp	 $LN1@shrd_cmd
$LN11@shrd_cmd:

; 3041 :     }
; 3042 : 
; 3043 :     // Format: "SHRD [TRACE[=nnnn]]" where nnnn is #of table entries.
; 3044 :     // Enter the command with no argument to display the current value.
; 3045 :     // Use "shrd trace" by itself to print the current table.
; 3046 : 
; 3047 :     STRLCPY( buf, argv[1] );

  0022f	b8 08 00 00 00	 mov	 eax, 8
  00234	48 6b c0 01	 imul	 rax, rax, 1
  00238	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0023e	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00246	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0024a	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3048 : 
; 3049 :     kw = strtok_r( buf, "=",    &strtok_str );

  00258	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170769
  00267	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00275	48 89 44 24 78	 mov	 QWORD PTR kw$[rsp], rax

; 3050 :     op = strtok_r( NULL, " \t", &strtok_str );

  0027a	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170770
  00289	33 c9		 xor	 ecx, ecx
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00291	48 89 44 24 60	 mov	 QWORD PTR op$[rsp], rax

; 3051 : 
; 3052 :     if (!kw)

  00296	48 83 7c 24 78
	00		 cmp	 QWORD PTR kw$[rsp], 0
  0029c	75 51		 jne	 SHORT $LN12@shrd_cmd

; 3053 :     {
; 3054 :         // "Shared: invalid or missing keyword"
; 3055 :         WRMSG( HHC00739, "E" );

  0029e	b9 01 00 00 00	 mov	 ecx, 1
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170772
  002b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170773
  002bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170774
  002d3	ba ef 0b 00 00	 mov	 edx, 3055		; 00000befH
  002d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170775
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3056 :         return -1;

  002e5	b8 ff ff ff ff	 mov	 eax, -1
  002ea	e9 5b 06 00 00	 jmp	 $LN1@shrd_cmd
$LN12@shrd_cmd:

; 3057 :     }
; 3058 : 
; 3059 :     if (strcasecmp( kw, "TRACE" ) == 0)

  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170777
  002f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR kw$[rsp]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00301	85 c0		 test	 eax, eax
  00303	0f 85 b4 03 00
	00		 jne	 $LN13@shrd_cmd

; 3060 :     {
; 3061 :         SHRD_TRACE*  shrdtrace;
; 3062 :         SHRD_TRACE*  shrdtracep;
; 3063 :         SHRD_TRACE*  shrdtracex;
; 3064 :         int          shrdtracen;
; 3065 : 
; 3066 :         OBTAIN_SHRDTRACE_LOCK();

  00309	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00310	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170778
  0031d	48 8b c8	 mov	 rcx, rax
  00320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3067 : 
; 3068 :         shrdtrace  = sysblk.shrdtrace;       // (ptr to beginning of table)

  00326	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0032d	48 8b 80 c0 13
	00 00		 mov	 rax, QWORD PTR [rax+5056]
  00334	48 89 44 24 70	 mov	 QWORD PTR shrdtrace$3[rsp], rax

; 3069 :         shrdtracep = sysblk.shrdtracep;      // (ptr to current/next entry)

  00339	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00340	48 8b 80 c8 13
	00 00		 mov	 rax, QWORD PTR [rax+5064]
  00347	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR shrdtracep$4[rsp], rax

; 3070 :         shrdtracex = sysblk.shrdtracex;      // (ptr past the end of table)

  0034f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00356	48 8b 80 d0 13
	00 00		 mov	 rax, QWORD PTR [rax+5072]
  0035d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR shrdtracex$5[rsp], rax

; 3071 : 
; 3072 :         /* Print trace table if no TRACE operand was specified */
; 3073 :         if (!op)

  00365	48 83 7c 24 60
	00		 cmp	 QWORD PTR op$[rsp], 0
  0036b	75 29		 jne	 SHORT $LN14@shrd_cmd

; 3074 :         {
; 3075 :             shared_print_trace_table_locked();

  0036d	e8 00 00 00 00	 call	 shared_print_trace_table_locked

; 3076 :             RELEASE_SHRDTRACE_LOCK();

  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00379	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170780
  00386	48 8b c8	 mov	 rcx, rax
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3077 :             return 0;

  0038f	33 c0		 xor	 eax, eax
  00391	e9 b4 05 00 00	 jmp	 $LN1@shrd_cmd
$LN14@shrd_cmd:

; 3078 :         }
; 3079 : 
; 3080 :         /* Operand specified: get size of requested table */
; 3081 :         if (sscanf( op, "%d%c", &shrdtracen, &c ) != 1)

  00396	4c 8d 4c 24 50	 lea	 r9, QWORD PTR c$[rsp]
  0039b	4c 8d 44 24 54	 lea	 r8, QWORD PTR shrdtracen$1[rsp]
  003a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170782
  003a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op$[rsp]
  003ac	e8 00 00 00 00	 call	 sscanf
  003b1	83 f8 01	 cmp	 eax, 1
  003b4	74 78		 je	 SHORT $LN15@shrd_cmd

; 3082 :         {
; 3083 :             // "Shared: invalid or missing value %s"
; 3084 :             WRMSG( HHC00740, "E", op );

  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op$[rsp]
  003c6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170783
  003d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170784
  003de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170785
  003f5	ba 0c 0c 00 00	 mov	 edx, 3084		; 00000c0cH
  003fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170786
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3085 :             RELEASE_SHRDTRACE_LOCK();

  00407	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040e	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170787
  0041b	48 8b c8	 mov	 rcx, rax
  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3086 :             return -1;

  00424	b8 ff ff ff ff	 mov	 eax, -1
  00429	e9 1c 05 00 00	 jmp	 $LN1@shrd_cmd
$LN15@shrd_cmd:

; 3087 :         }
; 3088 : 
; 3089 :         /* Free existing table */
; 3090 :         free( sysblk.shrdtrace );

  0042e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00435	48 8b 88 c0 13
	00 00		 mov	 rcx, QWORD PTR [rax+5056]
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3091 :         sysblk.shrdtrace  = NULL;

  00442	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00449	48 c7 80 c0 13
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5056], 0

; 3092 :         sysblk.shrdtracex = NULL;

  00454	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0045b	48 c7 80 d0 13
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5072], 0

; 3093 :         sysblk.shrdtracep = NULL;

  00466	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046d	48 c7 80 c8 13
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5064], 0

; 3094 :         sysblk.shrdtracen = 0;

  00478	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0047f	c7 80 d8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5080], 0

; 3095 : 
; 3096 :         /* Allocate new table */
; 3097 :         if (shrdtracen > 0)

  00489	83 7c 24 54 00	 cmp	 DWORD PTR shrdtracen$1[rsp], 0
  0048e	0f 8e 45 01 00
	00		 jle	 $LN16@shrd_cmd

; 3098 :         {
; 3099 :             if (!(shrdtrace = calloc( (size_t) shrdtracen, sizeof( SHRD_TRACE ))))

  00494	48 63 44 24 54	 movsxd	 rax, DWORD PTR shrdtracen$1[rsp]
  00499	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0049e	48 8b c8	 mov	 rcx, rax
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  004a7	48 89 44 24 70	 mov	 QWORD PTR shrdtrace$3[rsp], rax
  004ac	48 83 7c 24 70
	00		 cmp	 QWORD PTR shrdtrace$3[rsp], 0
  004b2	0f 85 c5 00 00
	00		 jne	 $LN17@shrd_cmd

; 3100 :             {
; 3101 :                 char buf[40];
; 3102 :                 MSGBUF( buf, "calloc(%d, %d)", (int) shrdtracen, (int) sizeof( SHRD_TRACE ));

  004b8	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR [rsp+32], 128	; 00000080H
  004c0	44 8b 4c 24 54	 mov	 r9d, DWORD PTR shrdtracen$1[rsp]
  004c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170790
  004cc	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  004d1	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR buf$6[rsp]
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3103 :                 // "Shared: error in function %s: %s"
; 3104 :                 WRMSG( HHC00735, "E", buf, strerror( errno ));

  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004e5	8b 08		 mov	 ecx, DWORD PTR [rax]
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004ed	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  004f5	b9 01 00 00 00	 mov	 ecx, 1
  004fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00500	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  00508	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0050d	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR buf$6[rsp]
  00515	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0051a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170791
  00521	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00526	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170792
  0052d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00532	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00537	41 b9 03 00 00
	00		 mov	 r9d, 3
  0053d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170793
  00544	ba 20 0c 00 00	 mov	 edx, 3104		; 00000c20H
  00549	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170794
  00550	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3105 :                 RELEASE_SHRDTRACE_LOCK();

  00556	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0055d	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00563	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170795
  0056a	48 8b c8	 mov	 rcx, rax
  0056d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3106 :                 return -1;

  00573	b8 ff ff ff ff	 mov	 eax, -1
  00578	e9 cd 03 00 00	 jmp	 $LN1@shrd_cmd
$LN17@shrd_cmd:

; 3107 :             }
; 3108 : 
; 3109 :             sysblk.shrdtracen = shrdtracen;

  0057d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00584	8b 4c 24 54	 mov	 ecx, DWORD PTR shrdtracen$1[rsp]
  00588	89 88 d8 13 00
	00		 mov	 DWORD PTR [rax+5080], ecx

; 3110 :             sysblk.shrdtracex = shrdtrace + shrdtracen;

  0058e	48 63 44 24 54	 movsxd	 rax, DWORD PTR shrdtracen$1[rsp]
  00593	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  0059a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shrdtrace$3[rsp]
  0059f	48 03 c8	 add	 rcx, rax
  005a2	48 8b c1	 mov	 rax, rcx
  005a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005ac	48 89 81 d0 13
	00 00		 mov	 QWORD PTR [rcx+5072], rax

; 3111 :             sysblk.shrdtrace  = shrdtrace;

  005b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shrdtrace$3[rsp]
  005bf	48 89 88 c0 13
	00 00		 mov	 QWORD PTR [rax+5056], rcx

; 3112 :             sysblk.shrdtracep = shrdtrace;

  005c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR shrdtrace$3[rsp]
  005d2	48 89 88 c8 13
	00 00		 mov	 QWORD PTR [rax+5064], rcx
$LN16@shrd_cmd:

; 3113 :         }
; 3114 : 
; 3115 :         if (MLVL( VERBOSE ))

  005d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e0	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  005e6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  005eb	85 c0		 test	 eax, eax
  005ed	0f 84 a6 00 00
	00		 je	 $LN18@shrd_cmd

; 3116 :         {
; 3117 :             // "%-14s set to %s"
; 3118 :             MSGBUF( buf, "TRACE=%d", sysblk.shrdtracen );

  005f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005fa	44 8b 88 d8 13
	00 00		 mov	 r9d, DWORD PTR [rax+5080]
  00601	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170797
  00608	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0060d	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3119 :             WRMSG( HHC02204, "I", argv[0], buf );

  0061b	b8 08 00 00 00	 mov	 eax, 8
  00620	48 6b c0 00	 imul	 rax, rax, 0
  00624	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
  0062c	b9 01 00 00 00	 mov	 ecx, 1
  00631	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00637	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0063f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00644	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0064c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv295[rsp]
  00654	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00658	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170798
  00664	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170799
  00670	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00675	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00680	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170800
  00687	ba 2f 0c 00 00	 mov	 edx, 3119		; 00000c2fH
  0068c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170801
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@shrd_cmd:

; 3120 :         }
; 3121 : 
; 3122 :         RELEASE_SHRDTRACE_LOCK();

  00699	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006a0	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  006a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170802
  006ad	48 8b c8	 mov	 rcx, rax
  006b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3123 :         return 0;

  006b6	33 c0		 xor	 eax, eax
  006b8	e9 8d 02 00 00	 jmp	 $LN1@shrd_cmd
$LN13@shrd_cmd:

; 3124 :     }
; 3125 : 
; 3126 :     if (strcasecmp( kw, "DTAX" ) == 0)  // Dump Table At Exit

  006bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170804
  006c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR kw$[rsp]
  006c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006cf	85 c0		 test	 eax, eax
  006d1	0f 85 1d 02 00
	00		 jne	 $LN19@shrd_cmd

; 3127 :     {
; 3128 :         int dtax;
; 3129 : 
; 3130 :         if (!op)

  006d7	48 83 7c 24 60
	00		 cmp	 QWORD PTR op$[rsp], 0
  006dd	75 5b		 jne	 SHORT $LN20@shrd_cmd

; 3131 :         {
; 3132 :             // "Shared: invalid or missing value %s"
; 3133 :             WRMSG( HHC00740, "E", kw );

  006df	b9 01 00 00 00	 mov	 ecx, 1
  006e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR kw$[rsp]
  006ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170806
  006fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00700	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170807
  00707	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0070c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00711	41 b9 03 00 00
	00		 mov	 r9d, 3
  00717	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170808
  0071e	ba 3d 0c 00 00	 mov	 edx, 3133		; 00000c3dH
  00723	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170809
  0072a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3134 :             return -1;

  00730	b8 ff ff ff ff	 mov	 eax, -1
  00735	e9 10 02 00 00	 jmp	 $LN1@shrd_cmd
$LN20@shrd_cmd:

; 3135 :         }
; 3136 :         if (0
; 3137 :             || sscanf( op, "%d%c", &dtax, &c ) != 1
; 3138 :             || (dtax != 0 && dtax != 1)

  0073a	33 c0		 xor	 eax, eax
  0073c	85 c0		 test	 eax, eax
  0073e	75 2e		 jne	 SHORT $LN22@shrd_cmd
  00740	4c 8d 4c 24 50	 lea	 r9, QWORD PTR c$[rsp]
  00745	4c 8d 44 24 58	 lea	 r8, QWORD PTR dtax$2[rsp]
  0074a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170812
  00751	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op$[rsp]
  00756	e8 00 00 00 00	 call	 sscanf
  0075b	83 f8 01	 cmp	 eax, 1
  0075e	75 0e		 jne	 SHORT $LN22@shrd_cmd
  00760	83 7c 24 58 00	 cmp	 DWORD PTR dtax$2[rsp], 0
  00765	74 62		 je	 SHORT $LN21@shrd_cmd
  00767	83 7c 24 58 01	 cmp	 DWORD PTR dtax$2[rsp], 1
  0076c	74 5b		 je	 SHORT $LN21@shrd_cmd
$LN22@shrd_cmd:

; 3139 :         )
; 3140 :         {
; 3141 :             // "Shared: invalid or missing value %s"
; 3142 :             WRMSG( HHC00740, "E", op );

  0076e	b9 01 00 00 00	 mov	 ecx, 1
  00773	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00779	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op$[rsp]
  0077e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00783	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170813
  0078a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0078f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170814
  00796	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0079b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  007a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170815
  007ad	ba 46 0c 00 00	 mov	 edx, 3142		; 00000c46H
  007b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170816
  007b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3143 :             return -1;

  007bf	b8 ff ff ff ff	 mov	 eax, -1
  007c4	e9 81 01 00 00	 jmp	 $LN1@shrd_cmd
$LN21@shrd_cmd:

; 3144 :         }
; 3145 : 
; 3146 :         OBTAIN_SHRDTRACE_LOCK();

  007c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007d0	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  007d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170817
  007dd	48 8b c8	 mov	 rcx, rax
  007e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3147 :         {
; 3148 :             sysblk.shrddtax = dtax ? true : false;

  007e6	83 7c 24 58 00	 cmp	 DWORD PTR dtax$2[rsp], 0
  007eb	74 0a		 je	 SHORT $LN24@shrd_cmd
  007ed	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv349[rsp], 1
  007f5	eb 08		 jmp	 SHORT $LN25@shrd_cmd
$LN24@shrd_cmd:
  007f7	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv349[rsp], 0
$LN25@shrd_cmd:
  007ff	83 7c 24 68 00	 cmp	 DWORD PTR tv349[rsp], 0
  00804	75 0a		 jne	 SHORT $LN26@shrd_cmd
  00806	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv351[rsp], 0
  0080e	eb 08		 jmp	 SHORT $LN27@shrd_cmd
$LN26@shrd_cmd:
  00810	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv351[rsp], 1
$LN27@shrd_cmd:
  00818	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0081f	0f b6 4c 24 6c	 movzx	 ecx, BYTE PTR tv351[rsp]
  00824	88 88 dc 13 00
	00		 mov	 BYTE PTR [rax+5084], cl

; 3149 :         }
; 3150 :         RELEASE_SHRDTRACE_LOCK();

  0082a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00831	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00837	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170818
  0083e	48 8b c8	 mov	 rcx, rax
  00841	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3151 : 
; 3152 :         // "%-14s set to %s"
; 3153 :         MSGBUF( buf, "DTAX=%d", sysblk.shrddtax );

  00847	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0084e	0f b6 80 dc 13
	00 00		 movzx	 eax, BYTE PTR [rax+5084]
  00855	44 8b c8	 mov	 r9d, eax
  00858	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170819
  0085f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00864	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0086c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3154 :         WRMSG( HHC02204, "I", argv[0], buf );

  00872	b8 08 00 00 00	 mov	 eax, 8
  00877	48 6b c0 00	 imul	 rax, rax, 0
  0087b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
  00883	b9 01 00 00 00	 mov	 ecx, 1
  00888	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0088e	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00896	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0089b	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008a3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv363[rsp]
  008ab	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  008af	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170820
  008bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170821
  008c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  008d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170822
  008de	ba 52 0c 00 00	 mov	 edx, 3154		; 00000c52H
  008e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170823
  008ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3155 : 
; 3156 :         return 0;

  008f0	33 c0		 xor	 eax, eax
  008f2	eb 56		 jmp	 SHORT $LN1@shrd_cmd
$LN19@shrd_cmd:

; 3157 :     }
; 3158 : 
; 3159 :     // "Shared: invalid or missing keyword %s"
; 3160 :     WRMSG( HHC00741, "E", kw );

  008f4	b9 01 00 00 00	 mov	 ecx, 1
  008f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR kw$[rsp]
  00904	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00909	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170824
  00910	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00915	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170825
  0091c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00921	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00926	41 b9 03 00 00
	00		 mov	 r9d, 3
  0092c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170826
  00933	ba 58 0c 00 00	 mov	 edx, 3160		; 00000c58H
  00938	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170827
  0093f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3161 :     return -1;

  00945	b8 ff ff ff ff	 mov	 eax, -1
$LN1@shrd_cmd:

; 3162 : }

  0094a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00952	48 33 cc	 xor	 rcx, rsp
  00955	e8 00 00 00 00	 call	 __security_check_cookie
  0095a	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00961	c3		 ret	 0
shrd_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
usock$ = 80
rc$ = 84
lsock$ = 88
shutdown$ = 92
csock$ = 96
rc$1 = 100
rsock$ = 104
tv306 = 108
tv308 = 112
hi$ = 116
tv79 = 120
tv84 = 124
optval$ = 128
tv171 = 132
tv253 = 136
tv472 = 140
tv477 = 144
timeout$ = 152
psock$ = 160
tid$ = 168
tv132 = 176
tv191 = 184
tv212 = 192
tv234 = 200
tv364 = 208
tv393 = 216
tv413 = 224
tv441 = 232
server$ = 240
selset$ = 256
threadname$ = 8464
buf$2 = 8480
__$ArrayPad$ = 8520
arg$ = 8544
shared_server PROC

; 2760 : {

$LN48:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	b8 50 21 00 00	 mov	 eax, 8528		; 00002150H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	48 2b e0	 sub	 rsp, rax
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 48
	21 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2761 : bool                    shutdown=false; /* shutdown flag             */

  00025	c6 44 24 5c 00	 mov	 BYTE PTR shutdown$[rsp], 0

; 2762 : int                     rc = -32767;    /* Return code               */

  0002a	c7 44 24 54 01
	80 ff ff	 mov	 DWORD PTR rc$[rsp], -32767 ; ffffffffffff8001H

; 2763 : int                     hi;             /* Hi fd for select          */
; 2764 : int                     lsock;          /* inet socket for listening */
; 2765 : int                     usock;          /* unix socket for listening */
; 2766 : int                     rsock;          /* Ready socket              */
; 2767 : int                     csock;          /* Socket for conversation   */
; 2768 : int                    *psock;          /* Pointer to socket         */
; 2769 : struct sockaddr_in      server;         /* Server address structure  */
; 2770 : #if defined( HAVE_SYS_UN_H )
; 2771 : struct sockaddr_un      userver;        /* Unix address structure    */
; 2772 : #endif
; 2773 : int                     optval;         /* Argument for setsockopt   */
; 2774 : fd_set                  selset;         /* Read bit map for select   */
; 2775 : TID                     tid;            /* Negotiation thread id     */
; 2776 : char                    threadname[16] = {0};

  00032	48 8d 84 24 10
	21 00 00	 lea	 rax, QWORD PTR threadname$[rsp]
  0003a	48 8b f8	 mov	 rdi, rax
  0003d	33 c0		 xor	 eax, eax
  0003f	b9 10 00 00 00	 mov	 ecx, 16
  00044	f3 aa		 rep stosb

; 2777 : struct timeval          timeout = {0};

  00046	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR timeout$[rsp]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	33 c0		 xor	 eax, eax
  00053	b9 08 00 00 00	 mov	 ecx, 8
  00058	f3 aa		 rep stosb
$LN4@shared_ser:

; 2778 : 
; 2779 :     // We are the "sysblk.shrdtid" thread...
; 2780 : 
; 2781 :     UNREFERENCED( arg );

  0005a	33 c0		 xor	 eax, eax
  0005c	85 c0		 test	 eax, eax
  0005e	75 fa		 jne	 SHORT $LN4@shared_ser

; 2782 : 
; 2783 :     /* Display thread started message on control panel */
; 2784 :     MSGBUF( threadname, "shrd srvr %d.%d", SHARED_VERSION, SHARED_RELEASE );

  00060	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00068	45 33 c9	 xor	 r9d, r9d
  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170627
  00072	ba 10 00 00 00	 mov	 edx, 16
  00077	48 8d 8c 24 10
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2785 :     LOG_THREAD_BEGIN( threadname  );

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170628
  00092	8b c8		 mov	 ecx, eax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0009a	89 44 24 78	 mov	 DWORD PTR tv79[rsp], eax
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000a4	89 44 24 7c	 mov	 DWORD PTR tv84[rsp], eax
  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b3	48 8d 8c 24 10
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  000bb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000c0	8b 4c 24 78	 mov	 ecx, DWORD PTR tv79[rsp]
  000c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c8	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv84[rsp]
  000cc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170629
  000d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170630
  000e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170631
  000fa	ba e1 0a 00 00	 mov	 edx, 2785		; 00000ae1H
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170632
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2786 : 
; 2787 :     /* Obtain a internet socket */
; 2788 :     if ((lsock = socket( AF_INET, SOCK_STREAM, 0 )) < 0)

  0010c	45 33 c0	 xor	 r8d, r8d
  0010f	ba 01 00 00 00	 mov	 edx, 1
  00114	b9 02 00 00 00	 mov	 ecx, 2
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  0011f	89 44 24 58	 mov	 DWORD PTR lsock$[rsp], eax
  00123	83 7c 24 58 00	 cmp	 DWORD PTR lsock$[rsp], 0
  00128	7d 7d		 jge	 SHORT $LN14@shared_ser

; 2789 :     {
; 2790 :         // "Shared: error in function %s: %s"
; 2791 :         WRMSG( HHC00735, "E", "socket()", strerror( HSO_errno ));

  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00130	8b c8		 mov	 ecx, eax
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00138	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00140	b9 01 00 00 00	 mov	 ecx, 1
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00153	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170634
  0015f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170635
  0016b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170636
  00177	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00181	41 b9 03 00 00
	00		 mov	 r9d, 3
  00187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170637
  0018e	ba e7 0a 00 00	 mov	 edx, 2791		; 00000ae7H
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170638
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2792 :         return NULL;

  001a0	33 c0		 xor	 eax, eax
  001a2	e9 aa 09 00 00	 jmp	 $LN1@shared_ser
$LN14@shared_ser:

; 2793 :     }
; 2794 : 
; 2795 :     /* Obtain a unix socket */
; 2796 : #if defined( HAVE_SYS_UN_H )
; 2797 :     if ((usock = socket( AF_UNIX, SOCK_STREAM, 0 )) < 0)
; 2798 :     {
; 2799 :         // "Shared: error in function %s: %s"
; 2800 :         WRMSG( HHC00735, "W", "socket()", strerror( HSO_errno ));
; 2801 :     }
; 2802 : #else
; 2803 :     usock = -1;

  001a7	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR usock$[rsp], -1

; 2804 : #endif
; 2805 : 
; 2806 :     /* Allow previous instance of socket to be reused */
; 2807 :     optval = 1;

  001af	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR optval$[rsp], 1

; 2808 :     setsockopt( lsock, SOL_SOCKET, SO_REUSEADDR,

  001ba	48 63 44 24 58	 movsxd	 rax, DWORD PTR lsock$[rsp]
  001bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001c7	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR optval$[rsp]
  001cf	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d5	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  001da	48 8b c8	 mov	 rcx, rax
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 2809 :                 (GETSET_SOCKOPT_T*) &optval, sizeof( optval ));
; 2810 : 
; 2811 :     /* Prepare the sockaddr structure for the bind */
; 2812 :     memset( &server, 0, sizeof(server) );

  001e3	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR server$[rsp]
  001eb	48 8b f8	 mov	 rdi, rax
  001ee	33 c0		 xor	 eax, eax
  001f0	b9 10 00 00 00	 mov	 ecx, 16
  001f5	f3 aa		 rep stosb

; 2813 :     server.sin_family      = AF_INET;

  001f7	b8 02 00 00 00	 mov	 eax, 2
  001fc	66 89 84 24 f0
	00 00 00	 mov	 WORD PTR server$[rsp], ax

; 2814 :     server.sin_addr.s_addr = INADDR_ANY;

  00204	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR server$[rsp+4], 0

; 2815 :     server.sin_port        = htons( sysblk.shrdport );

  0020f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00216	0f b7 88 ac 13
	00 00		 movzx	 ecx, WORD PTR [rax+5036]
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00223	66 89 84 24 f2
	00 00 00	 mov	 WORD PTR server$[rsp+2], ax
$LN5@shared_ser:

; 2816 : 
; 2817 :     /* Attempt to bind the internet socket to the port */
; 2818 :     while (sysblk.shrdport)

  0022b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00232	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  00239	85 c0		 test	 eax, eax
  0023b	0f 84 d7 00 00
	00		 je	 $LN6@shared_ser

; 2819 :     {
; 2820 :         rc = bind( lsock, (struct sockaddr*) &server, sizeof( server ));

  00241	48 63 44 24 58	 movsxd	 rax, DWORD PTR lsock$[rsp]
  00246	41 b8 10 00 00
	00		 mov	 r8d, 16
  0024c	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR server$[rsp]
  00254	48 8b c8	 mov	 rcx, rax
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0025d	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2821 :         if (rc == 0 || HSO_errno != HSO_EADDRINUSE)

  00261	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00266	74 0d		 je	 SHORT $LN16@shared_ser
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0026e	3d 40 27 00 00	 cmp	 eax, 10048		; 00002740H
  00273	74 05		 je	 SHORT $LN15@shared_ser
$LN16@shared_ser:

; 2822 :             break;

  00275	e9 9e 00 00 00	 jmp	 $LN6@shared_ser
$LN15@shared_ser:

; 2823 :         // "Shared: waiting for port %u to become free"
; 2824 :         WRMSG( HHC00736, "W", sysblk.shrdport );

  0027a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00281	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  00288	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  002a1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170641
  002ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170642
  002b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170643
  002cf	ba 08 0b 00 00	 mov	 edx, 2824		; 00000b08H
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170644
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@shared_ser:

; 2825 :         SLEEP( 10 );

  002e1	c7 44 24 64 0a
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 10
$LN10@shared_ser:
  002e9	83 7c 24 64 00	 cmp	 DWORD PTR rc$1[rsp], 0
  002ee	74 1d		 je	 SHORT $LN11@shared_ser
  002f0	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$1[rsp]
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  002fa	89 44 24 64	 mov	 DWORD PTR rc$1[rsp], eax
  002fe	83 7c 24 64 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00303	74 06		 je	 SHORT $LN17@shared_ser
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN17@shared_ser:
  0030b	eb dc		 jmp	 SHORT $LN10@shared_ser
$LN11@shared_ser:
  0030d	33 c0		 xor	 eax, eax
  0030f	85 c0		 test	 eax, eax
  00311	75 ce		 jne	 SHORT $LN9@shared_ser

; 2826 :     } /* end while */

  00313	e9 13 ff ff ff	 jmp	 $LN5@shared_ser
$LN6@shared_ser:

; 2827 : 
; 2828 :     if (rc != 0 || !sysblk.shrdport)

  00318	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0031d	75 16		 jne	 SHORT $LN19@shared_ser
  0031f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00326	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0032d	85 c0		 test	 eax, eax
  0032f	0f 85 91 00 00
	00		 jne	 $LN18@shared_ser
$LN19@shared_ser:

; 2829 :     {
; 2830 :         // "Shared: error in function %s: %s"
; 2831 :         WRMSG( HHC00735, "E", "bind()", strerror( HSO_errno ));

  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0033b	8b c8		 mov	 ecx, eax
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00343	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  0034b	b9 01 00 00 00	 mov	 ecx, 1
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00356	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv191[rsp]
  0035e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170648
  0036a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170649
  00376	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170650
  00382	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00387	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00392	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170651
  00399	ba 0f 0b 00 00	 mov	 edx, 2831		; 00000b0fH
  0039e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170652
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2832 :         close_socket( lsock );

  003ab	8b 4c 24 58	 mov	 ecx, DWORD PTR lsock$[rsp]
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2833 :         close_socket( usock );

  003b5	8b 4c 24 50	 mov	 ecx, DWORD PTR usock$[rsp]
  003b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2834 :         return NULL;

  003bf	33 c0		 xor	 eax, eax
  003c1	e9 8b 07 00 00	 jmp	 $LN1@shared_ser
$LN18@shared_ser:

; 2835 :     }
; 2836 : 
; 2837 : #if defined( HAVE_SYS_UN_H )
; 2838 :     /* Bind the unix socket */
; 2839 :     if (usock >= 0)
; 2840 :     {
; 2841 :         userver.sun_family = AF_UNIX;
; 2842 :         sprintf( userver.sun_path, "/tmp/hercules_shared.%d", sysblk.shrdport );
; 2843 :         unlink( userver.sun_path );
; 2844 :         fchmod( usock, 0700 );
; 2845 : 
; 2846 :         rc = bind( usock, (struct sockaddr*) &userver, sizeof( userver ));
; 2847 : 
; 2848 :         if (rc < 0)
; 2849 :         {
; 2850 :             // "Shared: error in function %s: %s"
; 2851 :             WRMSG( HHC00735, "W", "bind()", strerror( errno ));
; 2852 :             close( usock );
; 2853 :             usock = -1;
; 2854 :         }
; 2855 :     }
; 2856 : #endif // defined( HAVE_SYS_UN_H )
; 2857 : 
; 2858 :     /* Put the sockets into listening state */
; 2859 :     rc = listen( lsock, SHARED_MAX_SYS );

  003c6	48 63 44 24 58	 movsxd	 rax, DWORD PTR lsock$[rsp]
  003cb	ba 08 00 00 00	 mov	 edx, 8
  003d0	48 8b c8	 mov	 rcx, rax
  003d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  003d9	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2860 : 
; 2861 :     if (rc < 0)

  003dd	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  003e2	0f 8d 91 00 00
	00		 jge	 $LN20@shared_ser

; 2862 :     {
; 2863 :         // "Shared: error in function %s: %s"
; 2864 :         WRMSG( HHC00735, "E", "listen()", strerror( HSO_errno ));

  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003ee	8b c8		 mov	 ecx, eax
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003f6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  003fe	b9 01 00 00 00	 mov	 ecx, 1
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00409	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv212[rsp]
  00411	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170654
  0041d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00422	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170655
  00429	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170656
  00435	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0043a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00445	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170657
  0044c	ba 30 0b 00 00	 mov	 edx, 2864		; 00000b30H
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170658
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2865 :         close_socket( lsock );

  0045e	8b 4c 24 58	 mov	 ecx, DWORD PTR lsock$[rsp]
  00462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2866 :         close_socket( usock );

  00468	8b 4c 24 50	 mov	 ecx, DWORD PTR usock$[rsp]
  0046c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2867 :         return NULL;

  00472	33 c0		 xor	 eax, eax
  00474	e9 d8 06 00 00	 jmp	 $LN1@shared_ser
$LN20@shared_ser:

; 2868 :     }
; 2869 : 
; 2870 :     if (usock >= 0)

  00479	83 7c 24 50 00	 cmp	 DWORD PTR usock$[rsp], 0
  0047e	0f 8c aa 00 00
	00		 jl	 $LN21@shared_ser

; 2871 :     {
; 2872 :         rc = listen( usock, SHARED_MAX_SYS );

  00484	48 63 44 24 50	 movsxd	 rax, DWORD PTR usock$[rsp]
  00489	ba 08 00 00 00	 mov	 edx, 8
  0048e	48 8b c8	 mov	 rcx, rax
  00491	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  00497	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2873 : 
; 2874 :         if (rc < 0)

  0049b	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  004a0	0f 8d 88 00 00
	00		 jge	 $LN22@shared_ser

; 2875 :         {
; 2876 :             // "Shared: error in function %s: %s"
; 2877 :             WRMSG( HHC00735, "W", "listen()", strerror( HSO_errno ));

  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  004ac	8b c8		 mov	 ecx, eax
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004b4	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv234[rsp], rax
  004bc	b9 01 00 00 00	 mov	 ecx, 1
  004c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv234[rsp]
  004cf	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170661
  004db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170662
  004e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170663
  004f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00503	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170664
  0050a	ba 3d 0b 00 00	 mov	 edx, 2877		; 00000b3dH
  0050f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170665
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2878 :             close_socket( usock );

  0051c	8b 4c 24 50	 mov	 ecx, DWORD PTR usock$[rsp]
  00520	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2879 :             usock = -1;

  00526	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR usock$[rsp], -1
$LN22@shared_ser:
$LN21@shared_ser:

; 2880 :         }
; 2881 :     }
; 2882 : 
; 2883 :     csock = -1;

  0052e	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR csock$[rsp], -1

; 2884 : 
; 2885 :     if (lsock < usock)

  00536	8b 44 24 50	 mov	 eax, DWORD PTR usock$[rsp]
  0053a	39 44 24 58	 cmp	 DWORD PTR lsock$[rsp], eax
  0053e	7d 0c		 jge	 SHORT $LN23@shared_ser

; 2886 :         hi = usock + 1;

  00540	8b 44 24 50	 mov	 eax, DWORD PTR usock$[rsp]
  00544	ff c0		 inc	 eax
  00546	89 44 24 74	 mov	 DWORD PTR hi$[rsp], eax
  0054a	eb 0a		 jmp	 SHORT $LN24@shared_ser
$LN23@shared_ser:

; 2887 :     else
; 2888 :         hi = lsock + 1;

  0054c	8b 44 24 58	 mov	 eax, DWORD PTR lsock$[rsp]
  00550	ff c0		 inc	 eax
  00552	89 44 24 74	 mov	 DWORD PTR hi$[rsp], eax
$LN24@shared_ser:

; 2889 : 
; 2890 :     // "Shared: waiting for shared device requests on port %u"
; 2891 :     WRMSG( HHC00737, "I", sysblk.shrdport );

  00556	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0055d	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  00564	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv253[rsp], eax
  0056b	b9 01 00 00 00	 mov	 ecx, 1
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00576	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  0057d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170668
  00588	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170669
  00594	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00599	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059e	41 b9 03 00 00
	00		 mov	 r9d, 3
  005a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170670
  005ab	ba 4b 0b 00 00	 mov	 edx, 2891		; 00000b4bH
  005b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170671
  005b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2892 : 
; 2893 :     /* Define shared server thread shutdown routine */
; 2894 :     hdl_addshut( "shutdown_shared_server", shutdown_shared_server, NULL );

  005bd	45 33 c0	 xor	 r8d, r8d
  005c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:shutdown_shared_server
  005c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170672
  005ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_addshut
$LN47@shared_ser:
$LN46@shared_ser:
$LN45@shared_ser:
$LN44@shared_ser:
$LN12@shared_ser:

; 2895 : 
; 2896 :     /* Handle connection requests and attention interrupts */
; 2897 :     while (1)

  005d4	33 c0		 xor	 eax, eax
  005d6	83 f8 01	 cmp	 eax, 1
  005d9	0f 84 45 04 00
	00		 je	 $LN13@shared_ser

; 2898 :     {
; 2899 :         /* Continue running (looping) as long as shrdport is defined */
; 2900 :         OBTAIN_SHRDLOCK();

  005df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e6	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  005ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170673
  005f3	48 8b c8	 mov	 rcx, rax
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2901 :         {
; 2902 :             shutdown = (sysblk.shrdport ? false : true);

  005fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00603	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0060a	85 c0		 test	 eax, eax
  0060c	74 0a		 je	 SHORT $LN40@shared_ser
  0060e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv306[rsp], 0
  00616	eb 08		 jmp	 SHORT $LN41@shared_ser
$LN40@shared_ser:
  00618	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv306[rsp], 1
$LN41@shared_ser:
  00620	83 7c 24 6c 00	 cmp	 DWORD PTR tv306[rsp], 0
  00625	75 0a		 jne	 SHORT $LN42@shared_ser
  00627	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv308[rsp], 0
  0062f	eb 08		 jmp	 SHORT $LN43@shared_ser
$LN42@shared_ser:
  00631	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv308[rsp], 1
$LN43@shared_ser:
  00639	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv308[rsp]
  0063e	88 44 24 5c	 mov	 BYTE PTR shutdown$[rsp], al

; 2903 :         }
; 2904 :         RELEASE_SHRDLOCK();

  00642	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00649	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  0064f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170674
  00656	48 8b c8	 mov	 rcx, rax
  00659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2905 : 
; 2906 :         if (shutdown)

  0065f	0f b6 44 24 5c	 movzx	 eax, BYTE PTR shutdown$[rsp]
  00664	85 c0		 test	 eax, eax
  00666	74 05		 je	 SHORT $LN25@shared_ser

; 2907 :             break;

  00668	e9 b7 03 00 00	 jmp	 $LN13@shared_ser
$LN25@shared_ser:

; 2908 : 
; 2909 :         /* Initialize the select parameters */
; 2910 :         FD_ZERO( &selset );

  0066d	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR selset$[rsp], 0

; 2911 :         FD_SET( lsock, &selset );

  00678	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  00680	8b 4c 24 58	 mov	 ecx, DWORD PTR lsock$[rsp]
  00684	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 2912 : 
; 2913 :         if (usock >= 0)

  0068a	83 7c 24 50 00	 cmp	 DWORD PTR usock$[rsp], 0
  0068f	7c 12		 jl	 SHORT $LN26@shared_ser

; 2914 :             FD_SET( usock, &selset );

  00691	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  00699	8b 4c 24 50	 mov	 ecx, DWORD PTR usock$[rsp]
  0069d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
$LN26@shared_ser:

; 2915 : 
; 2916 :         /* Wait for a file descriptor to become ready */
; 2917 :         timeout.tv_sec  = 0;

  006a3	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR timeout$[rsp], 0

; 2918 :         timeout.tv_usec = 500000;  // 0.5 seconds

  006ae	c7 84 24 9c 00
	00 00 20 a1 07
	00		 mov	 DWORD PTR timeout$[rsp+4], 500000 ; 0007a120H

; 2919 :         rc = select( hi, &selset, NULL, NULL, &timeout );

  006b9	c7 44 24 30 67
	0b 00 00	 mov	 DWORD PTR [rsp+48], 2919 ; 00000b67H
  006c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170677
  006c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006cd	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR timeout$[rsp]
  006d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006da	45 33 c9	 xor	 r9d, r9d
  006dd	45 33 c0	 xor	 r8d, r8d
  006e0	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  006e8	8b 4c 24 74	 mov	 ecx, DWORD PTR hi$[rsp]
  006ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  006f2	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2920 : 
; 2921 :         if (rc == 0)

  006f6	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  006fb	75 05		 jne	 SHORT $LN27@shared_ser

; 2922 :             continue;

  006fd	e9 d2 fe ff ff	 jmp	 $LN12@shared_ser
$LN27@shared_ser:

; 2923 : 
; 2924 :         if (rc < 0 )

  00702	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00707	0f 8d 8d 00 00
	00		 jge	 $LN28@shared_ser

; 2925 :         {
; 2926 :             if (HSO_errno == HSO_EINTR)

  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00713	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  00718	75 05		 jne	 SHORT $LN29@shared_ser

; 2927 :                 continue;

  0071a	e9 b5 fe ff ff	 jmp	 $LN44@shared_ser
$LN29@shared_ser:

; 2928 : 
; 2929 :             // "Shared: error in function %s: %s"
; 2930 :             WRMSG( HHC00735, "E", "select()", strerror( HSO_errno ));

  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00725	8b c8		 mov	 ecx, eax
  00727	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0072d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv364[rsp], rax
  00735	b9 01 00 00 00	 mov	 ecx, 1
  0073a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00740	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv364[rsp]
  00748	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170681
  00754	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00759	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170682
  00760	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00765	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170683
  0076c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00771	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00776	41 b9 03 00 00
	00		 mov	 r9d, 3
  0077c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170684
  00783	ba 72 0b 00 00	 mov	 edx, 2930		; 00000b72H
  00788	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170685
  0078f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2931 :             break;

  00795	e9 8a 02 00 00	 jmp	 $LN13@shared_ser
$LN28@shared_ser:

; 2932 :         }
; 2933 : 
; 2934 :         /* If a client connection request has arrived then accept it */
; 2935 :         if (FD_ISSET( lsock, &selset ))

  0079a	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  007a2	8b 4c 24 58	 mov	 ecx, DWORD PTR lsock$[rsp]
  007a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  007ac	85 c0		 test	 eax, eax
  007ae	74 0a		 je	 SHORT $LN30@shared_ser

; 2936 :             rsock = lsock;

  007b0	8b 44 24 58	 mov	 eax, DWORD PTR lsock$[rsp]
  007b4	89 44 24 68	 mov	 DWORD PTR rsock$[rsp], eax
  007b8	eb 2f		 jmp	 SHORT $LN31@shared_ser
$LN30@shared_ser:

; 2937 :         else if (usock >= 0 && FD_ISSET( usock, &selset ))

  007ba	83 7c 24 50 00	 cmp	 DWORD PTR usock$[rsp], 0
  007bf	7c 20		 jl	 SHORT $LN32@shared_ser
  007c1	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR selset$[rsp]
  007c9	8b 4c 24 50	 mov	 ecx, DWORD PTR usock$[rsp]
  007cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  007d3	85 c0		 test	 eax, eax
  007d5	74 0a		 je	 SHORT $LN32@shared_ser

; 2938 :             rsock = usock;

  007d7	8b 44 24 50	 mov	 eax, DWORD PTR usock$[rsp]
  007db	89 44 24 68	 mov	 DWORD PTR rsock$[rsp], eax
  007df	eb 08		 jmp	 SHORT $LN33@shared_ser
$LN32@shared_ser:

; 2939 :         else
; 2940 :             rsock = -1;

  007e1	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR rsock$[rsp], -1
$LN33@shared_ser:
$LN31@shared_ser:

; 2941 : 
; 2942 :         /* Accept the connection and create conversation socket */
; 2943 :         if (rsock > 0)

  007e9	83 7c 24 68 00	 cmp	 DWORD PTR rsock$[rsp], 0
  007ee	0f 8e 2b 02 00
	00		 jle	 $LN34@shared_ser

; 2944 :         {
; 2945 :             if ((csock = accept( rsock, NULL, NULL )) < 0)

  007f4	45 33 c0	 xor	 r8d, r8d
  007f7	33 d2		 xor	 edx, edx
  007f9	8b 4c 24 68	 mov	 ecx, DWORD PTR rsock$[rsp]
  007fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  00803	89 44 24 60	 mov	 DWORD PTR csock$[rsp], eax
  00807	83 7c 24 60 00	 cmp	 DWORD PTR csock$[rsp], 0
  0080c	7d 7b		 jge	 SHORT $LN35@shared_ser

; 2946 :             {
; 2947 :                 // "Shared: error in function %s: %s"
; 2948 :                 WRMSG( HHC00735, "E", "accept()", strerror( HSO_errno ));

  0080e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00814	8b c8		 mov	 ecx, eax
  00816	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0081c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv393[rsp], rax
  00824	b9 01 00 00 00	 mov	 ecx, 1
  00829	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0082f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv393[rsp]
  00837	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0083c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170692
  00843	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00848	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170693
  0084f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00854	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170694
  0085b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00860	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00865	41 b9 03 00 00
	00		 mov	 r9d, 3
  0086b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170695
  00872	ba 84 0b 00 00	 mov	 edx, 2948		; 00000b84H
  00877	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170696
  0087e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2949 :                 continue;

  00884	e9 4b fd ff ff	 jmp	 $LN45@shared_ser
$LN35@shared_ser:

; 2950 :             }
; 2951 : 
; 2952 :             if (!(psock = malloc( sizeof( csock ))))

  00889	b9 04 00 00 00	 mov	 ecx, 4
  0088e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00894	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR psock$[rsp], rax
  0089c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR psock$[rsp], 0
  008a5	0f 85 a6 00 00
	00		 jne	 $LN36@shared_ser

; 2953 :             {
; 2954 :                 char buf[40];
; 2955 :                 MSGBUF( buf, "malloc(%d)", (int) sizeof( csock ));

  008ab	41 b9 04 00 00
	00		 mov	 r9d, 4
  008b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170698
  008b8	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  008bd	48 8d 8c 24 20
	21 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  008c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2956 :                 // "Shared: error in function %s: %s"
; 2957 :                 WRMSG( HHC00735, "E", buf, strerror( HSO_errno ));

  008cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  008d1	8b c8		 mov	 ecx, eax
  008d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  008d9	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv413[rsp], rax
  008e1	b9 01 00 00 00	 mov	 ecx, 1
  008e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ec	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv413[rsp]
  008f4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  008f9	48 8d 8c 24 20
	21 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00901	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00906	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170699
  0090d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00912	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170700
  00919	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00923	41 b9 03 00 00
	00		 mov	 r9d, 3
  00929	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170701
  00930	ba 8d 0b 00 00	 mov	 edx, 2957		; 00000b8dH
  00935	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170702
  0093c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2958 :                 close_socket( csock );

  00942	8b 4c 24 60	 mov	 ecx, DWORD PTR csock$[rsp]
  00946	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2959 :                 continue;

  0094c	e9 83 fc ff ff	 jmp	 $LN46@shared_ser
$LN36@shared_ser:

; 2960 :             }
; 2961 :             *psock = csock;

  00951	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR psock$[rsp]
  00959	8b 4c 24 60	 mov	 ecx, DWORD PTR csock$[rsp]
  0095d	89 08		 mov	 DWORD PTR [rax], ecx

; 2962 : 
; 2963 :             /* Create a thread to complete the client connection */
; 2964 :             rc = create_thread( &tid, DETACHED,

  0095f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00966	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0096c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170703
  00973	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00978	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170704
  0097f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00984	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR psock$[rsp]
  0098c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:serverConnect
  00993	48 8b d0	 mov	 rdx, rax
  00996	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  0099e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  009a4	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2965 :                                 serverConnect, psock, "serverConnect" );
; 2966 :             if (rc)

  009a8	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  009ad	74 70		 je	 SHORT $LN37@shared_ser

; 2967 :             {
; 2968 :                 // "Error in function create_thread(): %s"
; 2969 :                 WRMSG( HHC00102, "E", strerror( rc ));

  009af	8b 4c 24 54	 mov	 ecx, DWORD PTR rc$[rsp]
  009b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009b9	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv441[rsp], rax
  009c1	b9 01 00 00 00	 mov	 ecx, 1
  009c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009cc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv441[rsp]
  009d4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170706
  009e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170707
  009ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  009fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170708
  00a03	ba 99 0b 00 00	 mov	 edx, 2969		; 00000b99H
  00a08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170709
  00a0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2970 :                 close_socket( csock );

  00a15	8b 4c 24 60	 mov	 ecx, DWORD PTR csock$[rsp]
  00a19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN37@shared_ser:
$LN34@shared_ser:

; 2971 :             }
; 2972 : 
; 2973 :         } /* end if(rsock) */
; 2974 : 
; 2975 :     } /* end while (1) */

  00a1f	e9 b0 fb ff ff	 jmp	 $LN47@shared_ser
$LN13@shared_ser:

; 2976 : 
; 2977 :     /* Remove shut entry so we can do a new 'hdl_addshut' next time */
; 2978 :     if (!sysblk.shutdown)

  00a24	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a2b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00a31	c1 e8 0b	 shr	 eax, 11
  00a34	83 e0 01	 and	 eax, 1
  00a37	85 c0		 test	 eax, eax
  00a39	75 0f		 jne	 SHORT $LN38@shared_ser

; 2979 :         hdl_delshut( shutdown_shared_server, NULL );

  00a3b	33 d2		 xor	 edx, edx
  00a3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:shutdown_shared_server
  00a44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_delshut
$LN38@shared_ser:

; 2980 : 
; 2981 :     /* Close the listening sockets */
; 2982 :     close_socket( lsock );

  00a4a	8b 4c 24 58	 mov	 ecx, DWORD PTR lsock$[rsp]
  00a4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2983 : 
; 2984 : #if defined( HAVE_SYS_UN_H )
; 2985 :     if (usock >= 0)
; 2986 :     {
; 2987 :         close_socket( usock );
; 2988 :         unlink( userver.sun_path );
; 2989 :     }
; 2990 : #endif
; 2991 : 
; 2992 :     /* Notify "shutdown_shared_server" that we've exited */
; 2993 :     OBTAIN_SHRDLOCK();

  00a54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a5b	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00a61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170711
  00a68	48 8b c8	 mov	 rcx, rax
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2994 :     {
; 2995 :         sysblk.shrdtid = 0;

  00a71	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a78	c7 80 a8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5032], 0

; 2996 :         signal_condition( &sysblk.shrdcond );

  00a82	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a89	48 05 a0 13 00
	00		 add	 rax, 5024		; 000013a0H
  00a8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170712
  00a96	48 8b c8	 mov	 rcx, rax
  00a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2997 :     }
; 2998 :     RELEASE_SHRDLOCK();

  00a9f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa6	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00aac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170713
  00ab3	48 8b c8	 mov	 rcx, rax
  00ab6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2999 : 
; 3000 :     LOG_THREAD_END( threadname  );

  00abc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00ac2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170714
  00ac9	8b c8		 mov	 ecx, eax
  00acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00ad1	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv472[rsp], eax
  00ad8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00ade	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv477[rsp], eax
  00ae5	b9 01 00 00 00	 mov	 ecx, 1
  00aea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00af0	48 8d 8c 24 10
	21 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00af8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00afd	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv472[rsp]
  00b04	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b08	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv477[rsp]
  00b0f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170715
  00b1a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170716
  00b26	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b2b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b30	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b36	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170717
  00b3d	ba b8 0b 00 00	 mov	 edx, 3000		; 00000bb8H
  00b42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170718
  00b49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3001 : 
; 3002 :     return NULL;

  00b4f	33 c0		 xor	 eax, eax
$LN1@shared_ser:

; 3003 : 
; 3004 : } /* end function shared_server */

  00b51	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b59	48 33 cc	 xor	 rcx, rsp
  00b5c	e8 00 00 00 00	 call	 __security_check_cookie
  00b61	48 81 c4 50 21
	00 00		 add	 rsp, 8528		; 00002150H
  00b68	5f		 pop	 rdi
  00b69	c3		 ret	 0
shared_server ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 112
c$ = 116
i$ = 120
rc$1 = 124
retry$ = 128
p$ = 136
tv199 = 144
tv232 = 148
tv238 = 152
tv268 = 156
tv274 = 160
tv303 = 164
tv309 = 168
tv348 = 172
tv354 = 176
tv390 = 180
tv396 = 184
tv422 = 188
tv428 = 192
tv495 = 196
tv501 = 200
tv533 = 204
tv539 = 208
tv565 = 212
tv571 = 216
tv193 = 220
port$ = 224
rmtnum$ = 232
origin$ = 240
numblks$ = 244
blksiz$ = 248
tv367 = 252
tv382 = 256
tv385 = 260
tv528 = 264
tv163 = 268
he$ = 272
op$ = 280
ipname$ = 288
tv165 = 296
tv188 = 304
tv585 = 312
tv560 = 320
kw$ = 328
buf$ = 336
__$ArrayPad$ = 1360
dev$ = 1392
argc$ = 1400
argv$ = 1408
shared_fba_init PROC

; 378  : {

$LN104:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 68 05
	00 00		 sub	 rsp, 1384		; 00000568H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 50
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 379  : int      rc;                            /* Return code               */
; 380  : int      i;                             /* Loop index                */
; 381  : int      retry;                         /* 1=Connection being retried*/
; 382  : char    *ipname;                        /* Remote name or address    */
; 383  : char    *port = NULL;                   /* Remote port               */

  00027	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR port$[rsp], 0

; 384  : char    *rmtnum = NULL;                 /* Remote device number      */

  00033	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rmtnum$[rsp], 0

; 385  : struct   hostent *he;                   /* -> hostent structure      */
; 386  : char    *kw;                            /* Argument keyword          */
; 387  : char    *op;                            /* Argument operand          */
; 388  : char     c;                             /* Work for sscanf           */
; 389  : FWORD    origin;                        /* FBA origin                */
; 390  : FWORD    numblks;                       /* FBA number blocks         */
; 391  : FWORD    blksiz;                        /* FBA block size            */
; 392  : char    *p, buf[1024];                  /* Work buffer               */
; 393  : #if defined( HAVE_ZLIB )
; 394  : char    *strtok_str = NULL;             /* last token                */
; 395  : #endif
; 396  : 
; 397  :     /* Process the arguments */
; 398  :     if (!(retry = dev->connecting))

  0003f	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00047	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0004d	c1 e8 08	 shr	 eax, 8
  00050	83 e0 01	 and	 eax, 1
  00053	89 84 24 80 00
	00 00		 mov	 DWORD PTR retry$[rsp], eax
  0005a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  00062	0f 85 20 03 00
	00		 jne	 $LN13@shared_fba

; 399  :     {
; 400  :         dev->connected = 0;             /* SHRD_CONNECT not done yet */

  00068	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00070	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00076	83 e0 df	 and	 eax, -33		; ffffffdfH
  00079	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00081	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 401  : 
; 402  :         kw = op = NULL;

  00087	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op$[rsp], 0
  00093	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR op$[rsp]
  0009b	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR kw$[rsp], rax

; 403  : 
; 404  :         if (argc < 1 || strlen(argv[0]) >= sizeof(buf))

  000a3	83 bc 24 78 05
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000ab	7c 22		 jl	 SHORT $LN15@shared_fba
  000ad	b8 08 00 00 00	 mov	 eax, 8
  000b2	48 6b c0 00	 imul	 rax, rax, 0
  000b6	48 8b 8c 24 80
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000be	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000c2	e8 00 00 00 00	 call	 strlen
  000c7	48 3d 00 04 00
	00		 cmp	 rax, 1024		; 00000400H
  000cd	72 0a		 jb	 SHORT $LN14@shared_fba
$LN15@shared_fba:

; 405  :             return -1;

  000cf	b8 ff ff ff ff	 mov	 eax, -1
  000d4	e9 64 10 00 00	 jmp	 $LN1@shared_fba
$LN14@shared_fba:

; 406  :         STRLCPY( buf, argv[0] );

  000d9	b8 08 00 00 00	 mov	 eax, 8
  000de	48 6b c0 00	 imul	 rax, rax, 0
  000e2	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000e8	48 8b 8c 24 80
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000f0	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000f4	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 407  : 
; 408  :         /* First argument is 'ipname:port:devnum' */
; 409  :         ipname = buf;

  00102	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0010a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR ipname$[rsp], rax

; 410  :         p = strchr (buf, ':');

  00112	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00117	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 strchr
  00124	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$[rsp], rax

; 411  :         if (p)

  0012c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00135	74 38		 je	 SHORT $LN16@shared_fba

; 412  :         {
; 413  :             *p = '\0';

  00137	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0013f	c6 00 00	 mov	 BYTE PTR [rax], 0

; 414  :             port = p + 1;

  00142	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0014a	48 ff c0	 inc	 rax
  0014d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR port$[rsp], rax

; 415  :             p = strchr (port, ':');

  00155	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0015a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  00162	e8 00 00 00 00	 call	 strchr
  00167	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$[rsp], rax
$LN16@shared_fba:

; 416  :         }
; 417  :         if (p)

  0016f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00178	74 1e		 je	 SHORT $LN17@shared_fba

; 418  :         {
; 419  :             *p = '\0';

  0017a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00182	c6 00 00	 mov	 BYTE PTR [rax], 0

; 420  :             rmtnum = p + 1;

  00185	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0018d	48 ff c0	 inc	 rax
  00190	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR rmtnum$[rsp], rax
$LN17@shared_fba:

; 421  :         }
; 422  : 
; 423  :         if ( (he = gethostbyname (ipname)) == NULL )

  00198	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR ipname$[rsp]
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  001a6	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR he$[rsp], rax
  001ae	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR he$[rsp], 0
  001b7	75 0a		 jne	 SHORT $LN18@shared_fba

; 424  :             return -1;

  001b9	b8 ff ff ff ff	 mov	 eax, -1
  001be	e9 7a 0f 00 00	 jmp	 $LN1@shared_fba
$LN18@shared_fba:

; 425  :         memcpy(&dev->rmtaddr, he->h_addr_list[0], sizeof(dev->rmtaddr));

  001c3	b8 08 00 00 00	 mov	 eax, 8
  001c8	48 6b c0 00	 imul	 rax, rax, 0
  001cc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR he$[rsp]
  001d4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001d8	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  001dc	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e4	8b 00		 mov	 eax, DWORD PTR [rax]
  001e6	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 426  : 
; 427  :         if (port)

  001ec	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR port$[rsp], 0
  001f5	74 3b		 je	 SHORT $LN19@shared_fba

; 428  :         {
; 429  :             if (sscanf(port, "%hu%c", &dev->rmtport, &c) != 1)

  001f7	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ff	48 05 24 06 00
	00		 add	 rax, 1572		; 00000624H
  00205	4c 8d 4c 24 74	 lea	 r9, QWORD PTR c$[rsp]
  0020a	4c 8b c0	 mov	 r8, rax
  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169091
  00214	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  0021c	e8 00 00 00 00	 call	 sscanf
  00221	83 f8 01	 cmp	 eax, 1
  00224	74 0a		 je	 SHORT $LN21@shared_fba

; 430  :                 return -1;

  00226	b8 ff ff ff ff	 mov	 eax, -1
  0022b	e9 0d 0f 00 00	 jmp	 $LN1@shared_fba
$LN21@shared_fba:

; 431  :         }

  00230	eb 14		 jmp	 SHORT $LN20@shared_fba
$LN19@shared_fba:

; 432  :         else
; 433  :             dev->rmtport = SHARED_DEFAULT_PORT;

  00232	b8 96 0f 00 00	 mov	 eax, 3990		; 00000f96H
  00237	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023f	66 89 81 24 06
	00 00		 mov	 WORD PTR [rcx+1572], ax
$LN20@shared_fba:

; 434  : 
; 435  :         if (rmtnum)

  00246	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR rmtnum$[rsp], 0
  0024f	74 4d		 je	 SHORT $LN22@shared_fba

; 436  :         {
; 437  :             if (strlen (rmtnum) > 4
; 438  :              || sscanf (rmtnum, "%hx%c", &dev->rmtnum, &c) != 0)

  00251	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR rmtnum$[rsp]
  00259	e8 00 00 00 00	 call	 strlen
  0025e	48 83 f8 04	 cmp	 rax, 4
  00262	77 2e		 ja	 SHORT $LN25@shared_fba
  00264	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026c	48 05 26 06 00
	00		 add	 rax, 1574		; 00000626H
  00272	4c 8d 4c 24 74	 lea	 r9, QWORD PTR c$[rsp]
  00277	4c 8b c0	 mov	 r8, rax
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169096
  00281	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR rmtnum$[rsp]
  00289	e8 00 00 00 00	 call	 sscanf
  0028e	85 c0		 test	 eax, eax
  00290	74 0a		 je	 SHORT $LN24@shared_fba
$LN25@shared_fba:

; 439  :                 return -1;

  00292	b8 ff ff ff ff	 mov	 eax, -1
  00297	e9 a1 0e 00 00	 jmp	 $LN1@shared_fba
$LN24@shared_fba:

; 440  :         }

  0029c	eb 1b		 jmp	 SHORT $LN23@shared_fba
$LN22@shared_fba:

; 441  :         else
; 442  :             dev->rmtnum = dev->devnum;

  0029e	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a6	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ae	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002b2	66 89 88 26 06
	00 00		 mov	 WORD PTR [rax+1574], cx
$LN23@shared_fba:

; 443  : 
; 444  :         /* Process the remaining arguments */
; 445  :         rc = 0;

  002b9	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 446  :         for (i = 1; i < argc; i++)

  002c1	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  002c9	eb 0a		 jmp	 SHORT $LN4@shared_fba
$LN2@shared_fba:
  002cb	8b 44 24 78	 mov	 eax, DWORD PTR i$[rsp]
  002cf	ff c0		 inc	 eax
  002d1	89 44 24 78	 mov	 DWORD PTR i$[rsp], eax
$LN4@shared_fba:
  002d5	8b 84 24 78 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  002dc	39 44 24 78	 cmp	 DWORD PTR i$[rsp], eax
  002e0	0f 8d 92 00 00
	00		 jge	 $LN3@shared_fba

; 447  :         {
; 448  : #if defined( HAVE_ZLIB )
; 449  :             if (strlen (argv[i]) > 5
; 450  :              && memcmp("comp=", argv[i], 5) == 0)
; 451  :             {
; 452  :                 kw = strtok_r (argv[i], "=", &strtok_str );
; 453  :                 op = strtok_r (NULL, " \t", &strtok_str );
; 454  :                 dev->rmtcomp = atoi (op);
; 455  :                 if (dev->rmtcomp < 0 || dev->rmtcomp > 9)
; 456  :                     dev->rmtcomp = 0;
; 457  :                 continue;
; 458  :             }
; 459  : #endif
; 460  :             // "Shared: parameter %s in argument %d is invalid"
; 461  :             WRMSG( HHC00700, "S", argv[i], i + 1 );

  002e6	8b 44 24 78	 mov	 eax, DWORD PTR i$[rsp]
  002ea	ff c0		 inc	 eax
  002ec	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  002f3	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR i$[rsp]
  002f8	48 89 8c 24 28
	01 00 00	 mov	 QWORD PTR tv165[rsp], rcx
  00300	b9 01 00 00 00	 mov	 ecx, 1
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030b	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	48 8b 8c 24 80
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0031e	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR tv165[rsp]
  00326	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0032a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169097
  00336	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0033b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169098
  00342	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00347	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00352	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169099
  00359	ba cd 01 00 00	 mov	 edx, 461		; 000001cdH
  0035e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169100
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 462  :             rc = -1;

  0036b	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 463  :         }

  00373	e9 53 ff ff ff	 jmp	 $LN2@shared_fba
$LN3@shared_fba:

; 464  :         if (rc)

  00378	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0037d	74 09		 je	 SHORT $LN26@shared_fba

; 465  :             return rc;

  0037f	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
  00383	e9 b5 0d 00 00	 jmp	 $LN1@shared_fba
$LN26@shared_fba:
$LN13@shared_fba:

; 466  :     }
; 467  : 
; 468  :     /* Set suported compression */
; 469  :     dev->rmtcomps = 0;

  00388	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00390	c7 80 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1600], 0

; 470  : #if defined( HAVE_ZLIB )
; 471  :     dev->rmtcomps |= SHRD_LIBZ;
; 472  : #endif
; 473  : #if defined( CCKD_BZIP2 )
; 474  :     dev->rmtcomps |= SHRD_BZIP2;
; 475  : #endif
; 476  : 
; 477  :     /* Update the device handler vector */
; 478  :     dev->hnd = &shared_fba_device_hndinfo;

  0039a	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:shared_fba_device_hndinfo
  003a9	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 479  : 
; 480  :     dev->connecting = 1;

  003b0	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003be	0f ba e8 08	 bts	 eax, 8
  003c2	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ca	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN103@shared_fba:
$LN102@shared_fba:
$LN101@shared_fba:
$LN100@shared_fba:
$LN99@shared_fba:
$init_retry$105:
$LN7@shared_fba:

; 481  : 
; 482  : init_retry:
; 483  : 
; 484  :     do {
; 485  :         rc = clientConnect (dev, retry);

  003d0	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR retry$[rsp]
  003d7	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003df	e8 00 00 00 00	 call	 clientConnect
  003e4	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 486  :         if (rc < 0)

  003e8	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  003ed	0f 8d 14 01 00
	00		 jge	 $LN27@shared_fba

; 487  :         {
; 488  :             // "%1d:%04X Shared: connect pending to file %s"
; 489  :             WRMSG( HHC00701, "W", LCSS_DEVNUM, dev->filename );

  003f3	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003fc	74 15		 je	 SHORT $LN59@shared_fba
  003fe	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00406	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0040a	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  00411	eb 0b		 jmp	 SHORT $LN60@shared_fba
$LN59@shared_fba:
  00413	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv193[rsp], 0
$LN60@shared_fba:
  0041e	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00427	74 17		 je	 SHORT $LN61@shared_fba
  00429	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00431	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00435	d1 f8		 sar	 eax, 1
  00437	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv199[rsp], eax
  0043e	eb 0b		 jmp	 SHORT $LN62@shared_fba
$LN61@shared_fba:
  00440	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv199[rsp], 0
$LN62@shared_fba:
  0044b	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00453	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00459	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv188[rsp], rax
  00461	b9 01 00 00 00	 mov	 ecx, 1
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0046c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv188[rsp]
  00474	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00479	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  00480	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00484	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv199[rsp]
  0048b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169103
  00496	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169104
  004a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169105
  004b9	ba e9 01 00 00	 mov	 edx, 489		; 000001e9H
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169106
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 490  :             if (retry) SLEEP(5);

  004cb	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  004d3	74 32		 je	 SHORT $LN28@shared_fba
$LN10@shared_fba:
  004d5	c7 44 24 7c 05
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 5
$LN11@shared_fba:
  004dd	83 7c 24 7c 00	 cmp	 DWORD PTR rc$1[rsp], 0
  004e2	74 1d		 je	 SHORT $LN12@shared_fba
  004e4	8b 4c 24 7c	 mov	 ecx, DWORD PTR rc$1[rsp]
  004e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  004ee	89 44 24 7c	 mov	 DWORD PTR rc$1[rsp], eax
  004f2	83 7c 24 7c 00	 cmp	 DWORD PTR rc$1[rsp], 0
  004f7	74 06		 je	 SHORT $LN29@shared_fba
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN29@shared_fba:
  004ff	eb dc		 jmp	 SHORT $LN11@shared_fba
$LN12@shared_fba:
  00501	33 c0		 xor	 eax, eax
  00503	85 c0		 test	 eax, eax
  00505	75 ce		 jne	 SHORT $LN10@shared_fba
$LN28@shared_fba:
$LN27@shared_fba:

; 491  :         }
; 492  :     } while (retry && rc < 0);

  00507	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0050f	74 0b		 je	 SHORT $LN30@shared_fba
  00511	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00516	0f 8c b4 fe ff
	ff		 jl	 $LN7@shared_fba
$LN30@shared_fba:

; 493  : 
; 494  :     /* Return if unable to connect */
; 495  :     if (rc < 0) return 0;

  0051c	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00521	7d 07		 jge	 SHORT $LN31@shared_fba
  00523	33 c0		 xor	 eax, eax
  00525	e9 13 0c 00 00	 jmp	 $LN1@shared_fba
$LN31@shared_fba:

; 496  : 
; 497  :     /* Get the fba origin */
; 498  :     rc = clientRequest (dev, origin, 4, SHRD_QUERY, SHRD_FBAORIGIN, NULL, NULL);

  0052a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00533	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0053c	c7 44 24 20 4c
	00 00 00	 mov	 DWORD PTR [rsp+32], 76	; 0000004cH
  00544	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  0054a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00550	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR origin$[rsp]
  00558	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00560	e8 00 00 00 00	 call	 clientRequest
  00565	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 499  :     if (rc < 0)

  00569	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0056e	7d 0a		 jge	 SHORT $LN32@shared_fba

; 500  :         goto init_retry;

  00570	e9 5b fe ff ff	 jmp	 $init_retry$105
  00575	e9 ca 00 00 00	 jmp	 $LN33@shared_fba
$LN32@shared_fba:

; 501  :     else if (rc != 4)

  0057a	83 7c 24 70 04	 cmp	 DWORD PTR rc$[rsp], 4
  0057f	0f 84 bf 00 00
	00		 je	 $LN34@shared_fba

; 502  :     {
; 503  :         // "%1d:%04X Shared: error retrieving fba origin"
; 504  :         WRMSG( HHC00709, "S", LCSS_DEVNUM );

  00585	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0058e	74 15		 je	 SHORT $LN63@shared_fba
  00590	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00598	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0059c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv232[rsp], eax
  005a3	eb 0b		 jmp	 SHORT $LN64@shared_fba
$LN63@shared_fba:
  005a5	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv232[rsp], 0
$LN64@shared_fba:
  005b0	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005b9	74 17		 je	 SHORT $LN65@shared_fba
  005bb	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  005c7	d1 f8		 sar	 eax, 1
  005c9	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv238[rsp], eax
  005d0	eb 0b		 jmp	 SHORT $LN66@shared_fba
$LN65@shared_fba:
  005d2	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv238[rsp], 0
$LN66@shared_fba:
  005dd	b9 01 00 00 00	 mov	 ecx, 1
  005e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  005ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f3	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv238[rsp]
  005fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169114
  00605	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  00611	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00616	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0061b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00621	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169116
  00628	ba f8 01 00 00	 mov	 edx, 504		; 000001f8H
  0062d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169117
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 505  :         return -1;

  0063a	b8 ff ff ff ff	 mov	 eax, -1
  0063f	e9 f9 0a 00 00	 jmp	 $LN1@shared_fba
$LN34@shared_fba:
$LN33@shared_fba:

; 506  :     }
; 507  :     dev->fbaorigin = fetch_fw (origin);

  00644	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR origin$[rsp]
  0064c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00651	8b c8		 mov	 ecx, eax
  00653	e8 00 00 00 00	 call	 _byteswap_ulong
  00658	8b c0		 mov	 eax, eax
  0065a	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00662	48 89 81 90 11
	00 00		 mov	 QWORD PTR [rcx+4496], rax

; 508  : 
; 509  :     /* Get the number of blocks */
; 510  :     rc = clientRequest (dev, numblks, 4, SHRD_QUERY, SHRD_FBANUMBLK, NULL, NULL);

  00669	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00672	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0067b	c7 44 24 20 4d
	00 00 00	 mov	 DWORD PTR [rsp+32], 77	; 0000004dH
  00683	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00689	41 b8 04 00 00
	00		 mov	 r8d, 4
  0068f	48 8d 94 24 f4
	00 00 00	 lea	 rdx, QWORD PTR numblks$[rsp]
  00697	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069f	e8 00 00 00 00	 call	 clientRequest
  006a4	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 511  :     if (rc < 0)

  006a8	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  006ad	7d 0a		 jge	 SHORT $LN35@shared_fba

; 512  :         goto init_retry;

  006af	e9 1c fd ff ff	 jmp	 $LN99@shared_fba
  006b4	e9 ca 00 00 00	 jmp	 $LN36@shared_fba
$LN35@shared_fba:

; 513  :     else if (rc != 4)

  006b9	83 7c 24 70 04	 cmp	 DWORD PTR rc$[rsp], 4
  006be	0f 84 bf 00 00
	00		 je	 $LN37@shared_fba

; 514  :     {
; 515  :         // "%1d:%04X Shared: error retrieving fba number blocks"
; 516  :         WRMSG( HHC00710, "S", LCSS_DEVNUM );

  006c4	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006cd	74 15		 je	 SHORT $LN67@shared_fba
  006cf	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006d7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006db	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv268[rsp], eax
  006e2	eb 0b		 jmp	 SHORT $LN68@shared_fba
$LN67@shared_fba:
  006e4	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv268[rsp], 0
$LN68@shared_fba:
  006ef	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006f8	74 17		 je	 SHORT $LN69@shared_fba
  006fa	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00702	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00706	d1 f8		 sar	 eax, 1
  00708	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv274[rsp], eax
  0070f	eb 0b		 jmp	 SHORT $LN70@shared_fba
$LN69@shared_fba:
  00711	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv274[rsp], 0
$LN70@shared_fba:
  0071c	b9 01 00 00 00	 mov	 ecx, 1
  00721	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00727	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv268[rsp]
  0072e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00732	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  00739	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0073d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169121
  00744	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169122
  00750	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00755	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00760	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169123
  00767	ba 04 02 00 00	 mov	 edx, 516		; 00000204H
  0076c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169124
  00773	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 517  :         return -1;

  00779	b8 ff ff ff ff	 mov	 eax, -1
  0077e	e9 ba 09 00 00	 jmp	 $LN1@shared_fba
$LN37@shared_fba:
$LN36@shared_fba:

; 518  :     }
; 519  :     dev->fbanumblk = fetch_fw (numblks);

  00783	48 8d 8c 24 f4
	00 00 00	 lea	 rcx, QWORD PTR numblks$[rsp]
  0078b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00790	8b c8		 mov	 ecx, eax
  00792	e8 00 00 00 00	 call	 _byteswap_ulong
  00797	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0079f	89 81 88 11 00
	00		 mov	 DWORD PTR [rcx+4488], eax

; 520  : 
; 521  :     /* Get the block size */
; 522  :     rc = clientRequest (dev, blksiz, 4, SHRD_QUERY, SHRD_FBABLKSIZ, NULL, NULL);

  007a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007ae	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  007b7	c7 44 24 20 4e
	00 00 00	 mov	 DWORD PTR [rsp+32], 78	; 0000004eH
  007bf	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  007c5	41 b8 04 00 00
	00		 mov	 r8d, 4
  007cb	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR blksiz$[rsp]
  007d3	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007db	e8 00 00 00 00	 call	 clientRequest
  007e0	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 523  :     if (rc < 0)

  007e4	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  007e9	7d 0a		 jge	 SHORT $LN38@shared_fba

; 524  :         goto init_retry;

  007eb	e9 e0 fb ff ff	 jmp	 $LN100@shared_fba
  007f0	e9 ca 00 00 00	 jmp	 $LN39@shared_fba
$LN38@shared_fba:

; 525  :     else if (rc != 4)

  007f5	83 7c 24 70 04	 cmp	 DWORD PTR rc$[rsp], 4
  007fa	0f 84 bf 00 00
	00		 je	 $LN40@shared_fba

; 526  :     {
; 527  :         // "%1d:%04X Shared: error retrieving fba block size"
; 528  :         WRMSG( HHC00711, "S", LCSS_DEVNUM );

  00800	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00809	74 15		 je	 SHORT $LN71@shared_fba
  0080b	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00813	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00817	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv303[rsp], eax
  0081e	eb 0b		 jmp	 SHORT $LN72@shared_fba
$LN71@shared_fba:
  00820	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv303[rsp], 0
$LN72@shared_fba:
  0082b	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00834	74 17		 je	 SHORT $LN73@shared_fba
  00836	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0083e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00842	d1 f8		 sar	 eax, 1
  00844	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv309[rsp], eax
  0084b	eb 0b		 jmp	 SHORT $LN74@shared_fba
$LN73@shared_fba:
  0084d	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv309[rsp], 0
$LN74@shared_fba:
  00858	b9 01 00 00 00	 mov	 ecx, 1
  0085d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00863	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv303[rsp]
  0086a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0086e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv309[rsp]
  00875	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00879	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169128
  00880	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00885	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169129
  0088c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00891	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00896	41 b9 03 00 00
	00		 mov	 r9d, 3
  0089c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169130
  008a3	ba 10 02 00 00	 mov	 edx, 528		; 00000210H
  008a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169131
  008af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 529  :         return -1;

  008b5	b8 ff ff ff ff	 mov	 eax, -1
  008ba	e9 7e 08 00 00	 jmp	 $LN1@shared_fba
$LN40@shared_fba:
$LN39@shared_fba:

; 530  :     }
; 531  :     dev->fbablksiz = fetch_fw (blksiz);

  008bf	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR blksiz$[rsp]
  008c7	e8 00 00 00 00	 call	 fetch_fw_noswap
  008cc	8b c8		 mov	 ecx, eax
  008ce	e8 00 00 00 00	 call	 _byteswap_ulong
  008d3	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008db	89 81 8c 11 00
	00		 mov	 DWORD PTR [rcx+4492], eax

; 532  :     dev->fbaend = (dev->fbaorigin + dev->fbanumblk) * dev->fbablksiz;

  008e1	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e9	48 63 80 88 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4488]
  008f0	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008f8	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  008ff	48 03 c8	 add	 rcx, rax
  00902	48 8b c1	 mov	 rax, rcx
  00905	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0090d	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  00914	48 0f af c1	 imul	 rax, rcx
  00918	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00920	48 89 81 a0 11
	00 00		 mov	 QWORD PTR [rcx+4512], rax

; 533  : 
; 534  :     /* Get the device id */
; 535  :     rc = clientRequest (dev, dev->devid, sizeof(dev->devid),

  00927	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0092f	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00935	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0093e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00947	c7 44 24 20 42
	00 00 00	 mov	 DWORD PTR [rsp+32], 66	; 00000042H
  0094f	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00955	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0095b	48 8b d0	 mov	 rdx, rax
  0095e	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00966	e8 00 00 00 00	 call	 clientRequest
  0096b	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 536  :                         SHRD_QUERY, SHRD_DEVID, NULL, NULL);
; 537  :     if (rc < 0)

  0096f	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00974	7d 0a		 jge	 SHORT $LN41@shared_fba

; 538  :         goto init_retry;

  00976	e9 55 fa ff ff	 jmp	 $LN101@shared_fba
  0097b	e9 d4 00 00 00	 jmp	 $LN42@shared_fba
$LN41@shared_fba:

; 539  :     else if (rc == 0 || rc > (int)sizeof(dev->devid))

  00980	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00985	74 0e		 je	 SHORT $LN44@shared_fba
  00987	81 7c 24 70 00
	01 00 00	 cmp	 DWORD PTR rc$[rsp], 256	; 00000100H
  0098f	0f 8e bf 00 00
	00		 jle	 $LN43@shared_fba
$LN44@shared_fba:

; 540  :     {
; 541  :         // "%1d:%04X Shared: error retrieving device id"
; 542  :         WRMSG( HHC00705, "S", LCSS_DEVNUM );

  00995	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0099e	74 15		 je	 SHORT $LN75@shared_fba
  009a0	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009a8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009ac	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv348[rsp], eax
  009b3	eb 0b		 jmp	 SHORT $LN76@shared_fba
$LN75@shared_fba:
  009b5	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv348[rsp], 0
$LN76@shared_fba:
  009c0	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009c9	74 17		 je	 SHORT $LN77@shared_fba
  009cb	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009d3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  009d7	d1 f8		 sar	 eax, 1
  009d9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv354[rsp], eax
  009e0	eb 0b		 jmp	 SHORT $LN78@shared_fba
$LN77@shared_fba:
  009e2	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv354[rsp], 0
$LN78@shared_fba:
  009ed	b9 01 00 00 00	 mov	 ecx, 1
  009f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009f8	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv348[rsp]
  009ff	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a03	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv354[rsp]
  00a0a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169136
  00a15	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169137
  00a21	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a26	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a2b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a31	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169138
  00a38	ba 1e 02 00 00	 mov	 edx, 542		; 0000021eH
  00a3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  00a44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 543  :         return -1;

  00a4a	b8 ff ff ff ff	 mov	 eax, -1
  00a4f	e9 e9 06 00 00	 jmp	 $LN1@shared_fba
$LN43@shared_fba:
$LN42@shared_fba:

; 544  :     }
; 545  :     dev->numdevid = rc;

  00a54	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a5c	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$[rsp]
  00a60	89 88 64 04 00
	00		 mov	 DWORD PTR [rax+1124], ecx

; 546  : 
; 547  :     /* Check the device type */
; 548  :     if (dev->devtype != fetch_hw (dev->devid + 4))

  00a66	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a6e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00a72	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
  00a79	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a81	48 81 c1 6c 04
	00 00		 add	 rcx, 1132		; 0000046cH
  00a88	e8 00 00 00 00	 call	 fetch_hw_noswap
  00a8d	0f b7 c8	 movzx	 ecx, ax
  00a90	e8 00 00 00 00	 call	 _byteswap_ushort
  00a95	0f b7 c0	 movzx	 eax, ax
  00a98	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv367[rsp]
  00a9f	3b c8		 cmp	 ecx, eax
  00aa1	0f 84 13 01 00
	00		 je	 $LN45@shared_fba

; 549  :     {
; 550  :         // "%1d:%04X Shared: remote device %04X is a %04X"
; 551  :         WRMSG( HHC00704, "S", LCSS_DEVNUM, dev->rmtnum, fetch_hw( dev->devid + 4 ));

  00aa7	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ab0	74 15		 je	 SHORT $LN79@shared_fba
  00ab2	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00aba	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00abe	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv390[rsp], eax
  00ac5	eb 0b		 jmp	 SHORT $LN80@shared_fba
$LN79@shared_fba:
  00ac7	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv390[rsp], 0
$LN80@shared_fba:
  00ad2	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00adb	74 17		 je	 SHORT $LN81@shared_fba
  00add	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ae5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ae9	d1 f8		 sar	 eax, 1
  00aeb	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv396[rsp], eax
  00af2	eb 0b		 jmp	 SHORT $LN82@shared_fba
$LN81@shared_fba:
  00af4	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv396[rsp], 0
$LN82@shared_fba:
  00aff	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b07	48 05 6c 04 00
	00		 add	 rax, 1132		; 0000046cH
  00b0d	48 8b c8	 mov	 rcx, rax
  00b10	e8 00 00 00 00	 call	 fetch_hw_noswap
  00b15	0f b7 c8	 movzx	 ecx, ax
  00b18	e8 00 00 00 00	 call	 _byteswap_ushort
  00b1d	0f b7 c0	 movzx	 eax, ax
  00b20	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv382[rsp], eax
  00b27	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b2f	0f b7 89 26 06
	00 00		 movzx	 ecx, WORD PTR [rcx+1574]
  00b36	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv385[rsp], ecx
  00b3d	b9 01 00 00 00	 mov	 ecx, 1
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b48	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv382[rsp]
  00b4f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00b53	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv385[rsp]
  00b5a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00b5e	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv390[rsp]
  00b65	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b69	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv396[rsp]
  00b70	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169141
  00b7b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b80	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169142
  00b87	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b8c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b91	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b97	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169143
  00b9e	ba 27 02 00 00	 mov	 edx, 551		; 00000227H
  00ba3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169144
  00baa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 552  :         return -1;

  00bb0	b8 ff ff ff ff	 mov	 eax, -1
  00bb5	e9 83 05 00 00	 jmp	 $LN1@shared_fba
$LN45@shared_fba:

; 553  :     }
; 554  : 
; 555  :     /* Get the device characteristics */
; 556  :     rc = clientRequest (dev, dev->devchar, sizeof(dev->devchar),

  00bba	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bc2	48 05 6c 05 00
	00		 add	 rax, 1388		; 0000056cH
  00bc8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00bd1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00bda	c7 44 24 20 41
	00 00 00	 mov	 DWORD PTR [rsp+32], 65	; 00000041H
  00be2	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00be8	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00bee	48 8b d0	 mov	 rdx, rax
  00bf1	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bf9	e8 00 00 00 00	 call	 clientRequest
  00bfe	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 557  :                         SHRD_QUERY, SHRD_DEVCHAR, NULL, NULL);
; 558  :     if (rc < 0)

  00c02	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c07	7d 0a		 jge	 SHORT $LN46@shared_fba

; 559  :         goto init_retry;

  00c09	e9 c2 f7 ff ff	 jmp	 $LN102@shared_fba
  00c0e	e9 d1 00 00 00	 jmp	 $LN47@shared_fba
$LN46@shared_fba:

; 560  :     else if (rc == 0 || rc > (int)sizeof(dev->devchar))

  00c13	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c18	74 0b		 je	 SHORT $LN49@shared_fba
  00c1a	83 7c 24 70 40	 cmp	 DWORD PTR rc$[rsp], 64	; 00000040H
  00c1f	0f 8e bf 00 00
	00		 jle	 $LN48@shared_fba
$LN49@shared_fba:

; 561  :     {
; 562  :         // "%1d:%04X Shared: error retrieving device characteristics"
; 563  :         WRMSG( HHC00703, "S", LCSS_DEVNUM );

  00c25	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c2e	74 15		 je	 SHORT $LN83@shared_fba
  00c30	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c38	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c3c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv422[rsp], eax
  00c43	eb 0b		 jmp	 SHORT $LN84@shared_fba
$LN83@shared_fba:
  00c45	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv422[rsp], 0
$LN84@shared_fba:
  00c50	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c59	74 17		 je	 SHORT $LN85@shared_fba
  00c5b	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c63	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00c67	d1 f8		 sar	 eax, 1
  00c69	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv428[rsp], eax
  00c70	eb 0b		 jmp	 SHORT $LN86@shared_fba
$LN85@shared_fba:
  00c72	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv428[rsp], 0
$LN86@shared_fba:
  00c7d	b9 01 00 00 00	 mov	 ecx, 1
  00c82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c88	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv422[rsp]
  00c8f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c93	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv428[rsp]
  00c9a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169149
  00ca5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00caa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169150
  00cb1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cb6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cbb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cc1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169151
  00cc8	ba 33 02 00 00	 mov	 edx, 563		; 00000233H
  00ccd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169152
  00cd4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 564  :         return -1;

  00cda	b8 ff ff ff ff	 mov	 eax, -1
  00cdf	e9 59 04 00 00	 jmp	 $LN1@shared_fba
$LN48@shared_fba:
$LN47@shared_fba:

; 565  :     }
; 566  :     dev->numdevchar = rc;

  00ce4	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cec	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$[rsp]
  00cf0	89 88 68 05 00
	00		 mov	 DWORD PTR [rax+1384], ecx

; 567  : 
; 568  :     /* Get the serial number if the server supports such a query */
; 569  : 
; 570  :     if (dev->rmtver <  SHARED_VERSION ||

  00cf6	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cfe	83 b8 2c 06 00
	00 00		 cmp	 DWORD PTR [rax+1580], 0
  00d05	7c 22		 jl	 SHORT $LN52@shared_fba
  00d07	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d0f	83 b8 2c 06 00
	00 00		 cmp	 DWORD PTR [rax+1580], 0
  00d16	75 2c		 jne	 SHORT $LN50@shared_fba
  00d18	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d20	83 b8 30 06 00
	00 02		 cmp	 DWORD PTR [rax+1584], 2
  00d27	7d 1b		 jge	 SHORT $LN50@shared_fba
$LN52@shared_fba:

; 571  :        (dev->rmtver == SHARED_VERSION &&
; 572  :         dev->rmtrel <  SHARED_RELEASE))
; 573  :     {
; 574  :         /* Generate a random serial number */
; 575  :         gen_dasd_serial( dev->serial );

  00d29	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d31	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00d37	48 8b c8	 mov	 rcx, rax
  00d3a	e8 00 00 00 00	 call	 gen_dasd_serial

; 576  :     }

  00d3f	e9 2a 01 00 00	 jmp	 $LN51@shared_fba
$LN50@shared_fba:

; 577  :     else /* (server SHOULD support the SHRD_SERIAL query) */
; 578  :     {
; 579  :         rc = clientRequest (dev, dev->serial, sizeof(dev->serial),

  00d44	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d4c	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00d52	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d5b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00d64	c7 44 24 20 44
	00 00 00	 mov	 DWORD PTR [rsp+32], 68	; 00000044H
  00d6c	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00d72	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00d78	48 8b d0	 mov	 rdx, rax
  00d7b	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d83	e8 00 00 00 00	 call	 clientRequest
  00d88	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 580  :                             SHRD_QUERY, SHRD_SERIAL, NULL, NULL);
; 581  :         if (rc < 0)

  00d8c	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d91	7d 0a		 jge	 SHORT $LN53@shared_fba

; 582  :             goto init_retry;

  00d93	e9 38 f6 ff ff	 jmp	 $LN103@shared_fba
  00d98	e9 d1 00 00 00	 jmp	 $LN54@shared_fba
$LN53@shared_fba:

; 583  :         else if (rc == 0 || rc > (int)sizeof(dev->serial))

  00d9d	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00da2	74 0b		 je	 SHORT $LN56@shared_fba
  00da4	83 7c 24 70 0c	 cmp	 DWORD PTR rc$[rsp], 12
  00da9	0f 8e bf 00 00
	00		 jle	 $LN55@shared_fba
$LN56@shared_fba:

; 584  :         {
; 585  :             // "%1d:%04X Shared: error retrieving serial number"
; 586  :             WRMSG( HHC00716, "S", LCSS_DEVNUM );

  00daf	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00db8	74 15		 je	 SHORT $LN87@shared_fba
  00dba	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dc2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00dc6	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv495[rsp], eax
  00dcd	eb 0b		 jmp	 SHORT $LN88@shared_fba
$LN87@shared_fba:
  00dcf	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv495[rsp], 0
$LN88@shared_fba:
  00dda	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00de3	74 17		 je	 SHORT $LN89@shared_fba
  00de5	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ded	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00df1	d1 f8		 sar	 eax, 1
  00df3	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv501[rsp], eax
  00dfa	eb 0b		 jmp	 SHORT $LN90@shared_fba
$LN89@shared_fba:
  00dfc	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv501[rsp], 0
$LN90@shared_fba:
  00e07	b9 01 00 00 00	 mov	 ecx, 1
  00e0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e12	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv495[rsp]
  00e19	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e1d	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv501[rsp]
  00e24	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e28	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169160
  00e2f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  00e3b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e40	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e45	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e4b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169162
  00e52	ba 4a 02 00 00	 mov	 edx, 586		; 0000024aH
  00e57	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169163
  00e5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 587  :             return -1;

  00e64	b8 ff ff ff ff	 mov	 eax, -1
  00e69	e9 cf 02 00 00	 jmp	 $LN1@shared_fba
$LN55@shared_fba:
$LN54@shared_fba:
$LN51@shared_fba:

; 588  :         }
; 589  :     }
; 590  : 
; 591  :     /* Indicate no active track */
; 592  :     dev->cache = dev->bufcur = -1;

  00e6e	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e76	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  00e80	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e88	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 593  :     dev->buf = NULL;

  00e92	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e9a	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 594  : 
; 595  :     /* Set number of sense bytes */
; 596  :     dev->numsense = 32;

  00ea5	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ead	c7 80 60 03 00
	00 20 00 00 00	 mov	 DWORD PTR [rax+864], 32	; 00000020H

; 597  : 
; 598  :     /* Locate the FBA dasd table entry */
; 599  :     dev->fbatab = dasd_lookup (DASD_FBADEV, NULL, dev->devtype, dev->fbanumblk);

  00eb7	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ebf	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00ec3	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ecb	44 8b 89 88 11
	00 00		 mov	 r9d, DWORD PTR [rcx+4488]
  00ed2	44 8b c0	 mov	 r8d, eax
  00ed5	33 d2		 xor	 edx, edx
  00ed7	b9 03 00 00 00	 mov	 ecx, 3
  00edc	e8 00 00 00 00	 call	 dasd_lookup
  00ee1	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ee9	48 89 81 80 11
	00 00		 mov	 QWORD PTR [rcx+4480], rax

; 600  :     if (dev->fbatab == NULL)

  00ef0	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ef8	48 83 b8 80 11
	00 00 00	 cmp	 QWORD PTR [rax+4480], 0
  00f00	0f 85 dd 00 00
	00		 jne	 $LN57@shared_fba

; 601  :     {
; 602  :         // "%1d:%04X Shared: device type %4.4X not found in dasd table"
; 603  :         WRMSG( HHC00706, "S", LCSS_DEVNUM, dev->devtype );

  00f06	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f0f	74 15		 je	 SHORT $LN91@shared_fba
  00f11	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f19	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f1d	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv533[rsp], eax
  00f24	eb 0b		 jmp	 SHORT $LN92@shared_fba
$LN91@shared_fba:
  00f26	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv533[rsp], 0
$LN92@shared_fba:
  00f31	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f3a	74 17		 je	 SHORT $LN93@shared_fba
  00f3c	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f44	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f48	d1 f8		 sar	 eax, 1
  00f4a	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv539[rsp], eax
  00f51	eb 0b		 jmp	 SHORT $LN94@shared_fba
$LN93@shared_fba:
  00f53	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv539[rsp], 0
$LN94@shared_fba:
  00f5e	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f66	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f6a	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv528[rsp], eax
  00f71	b9 01 00 00 00	 mov	 ecx, 1
  00f76	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f7c	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv528[rsp]
  00f83	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00f87	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv533[rsp]
  00f8e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f92	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv539[rsp]
  00f99	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  00fa4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fa9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  00fb0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fb5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fba	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fc0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169167
  00fc7	ba 5b 02 00 00	 mov	 edx, 603		; 0000025bH
  00fcc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169168
  00fd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 604  :         return -1;

  00fd9	b8 ff ff ff ff	 mov	 eax, -1
  00fde	e9 5a 01 00 00	 jmp	 $LN1@shared_fba
$LN57@shared_fba:

; 605  :     }
; 606  : 
; 607  :     /* Purge the cache */
; 608  :     clientPurge (dev, 0, NULL);

  00fe3	45 33 c0	 xor	 r8d, r8d
  00fe6	33 d2		 xor	 edx, edx
  00fe8	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ff0	e8 00 00 00 00	 call	 clientPurge

; 609  : 
; 610  :     /* Log the device geometry */
; 611  :     // "%1d:%04X Shared: file %s: model %s origin %"PRId64" blks %d"
; 612  :     WRMSG( HHC00712, "I", LCSS_DEVNUM, dev->filename, dev->fbatab->name,

  00ff5	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ffe	74 15		 je	 SHORT $LN95@shared_fba
  01000	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01008	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0100c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv565[rsp], eax
  01013	eb 0b		 jmp	 SHORT $LN96@shared_fba
$LN95@shared_fba:
  01015	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv565[rsp], 0
$LN96@shared_fba:
  01020	48 83 bc 24 70
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01029	74 17		 je	 SHORT $LN97@shared_fba
  0102b	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01033	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01037	d1 f8		 sar	 eax, 1
  01039	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv571[rsp], eax
  01040	eb 0b		 jmp	 SHORT $LN98@shared_fba
$LN97@shared_fba:
  01042	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv571[rsp], 0
$LN98@shared_fba:
  0104d	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01055	48 8b 80 80 11
	00 00		 mov	 rax, QWORD PTR [rax+4480]
  0105c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv585[rsp], rax
  01064	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0106c	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01073	48 89 8c 24 40
	01 00 00	 mov	 QWORD PTR tv560[rsp], rcx
  0107b	b9 01 00 00 00	 mov	 ecx, 1
  01080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01086	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0108e	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  01094	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01098	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010a0	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  010a7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  010ac	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv585[rsp]
  010b4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  010b7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  010bc	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv560[rsp]
  010c4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010c9	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv565[rsp]
  010d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010d4	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv571[rsp]
  010db	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169169
  010e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169170
  010f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  01102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169171
  01109	ba 65 02 00 00	 mov	 edx, 613		; 00000265H
  0110e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169172
  01115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 613  :         dev->fbaorigin, dev->fbanumblk );
; 614  : 
; 615  :     dev->connecting = 0;

  0111b	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01123	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01129	0f ba f0 08	 btr	 eax, 8
  0112d	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01135	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 616  : 
; 617  :     return 0;

  0113b	33 c0		 xor	 eax, eax
$LN1@shared_fba:

; 618  : }

  0113d	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01145	48 33 cc	 xor	 rcx, rsp
  01148	e8 00 00 00 00	 call	 __security_check_cookie
  0114d	48 81 c4 68 05
	00 00		 add	 rsp, 1384		; 00000568H
  01154	c3		 ret	 0
shared_fba_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
rc$ = 128
i$ = 132
c$ = 136
rc$1 = 140
retry$ = 144
p$ = 152
tv287 = 160
tv325 = 164
tv331 = 168
tv362 = 172
tv368 = 176
tv430 = 180
tv436 = 184
tv462 = 188
tv468 = 192
tv535 = 196
tv541 = 200
tv573 = 204
tv579 = 208
tv616 = 212
tv622 = 216
tv671 = 220
tv677 = 224
tv281 = 228
port$ = 232
rmtnum$ = 240
cu$ = 248
tv425 = 256
tv568 = 260
tv252 = 264
cyls$ = 268
tv407 = 272
tv422 = 276
ipname$ = 280
he$ = 288
strtok_str$ = 296
tv603 = 304
tv611 = 312
op$ = 320
tv254 = 328
tv276 = 336
tv691 = 344
tv666 = 352
kw$ = 360
buf$ = 368
__$ArrayPad$ = 1392
dev$ = 1424
argc$ = 1432
argv$ = 1440
shared_ckd_init PROC

; 79   : {

$LN107:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 80 05
	00 00		 sub	 rsp, 1408		; 00000580H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 70
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 80   : int      rc;                            /* Return code               */
; 81   : int      i;                             /* Loop index                */
; 82   : int      retry;                         /* 1=Connection being retried*/
; 83   : char    *ipname;                        /* Remote name or address    */
; 84   : char    *port = NULL;                   /* Remote port               */

  00028	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR port$[rsp], 0

; 85   : char    *rmtnum = NULL;                 /* Remote device number      */

  00034	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rmtnum$[rsp], 0

; 86   : struct   hostent *he;                   /* -> hostent structure      */
; 87   : char    *kw;                            /* Argument keyword          */
; 88   : char    *op;                            /* Argument operand          */
; 89   : BYTE     c;                             /* Used for parsing          */
; 90   : char    *cu = NULL;                     /* Specified control unit    */

  00040	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR cu$[rsp], 0

; 91   : FWORD    cyls;                          /* Remote number cylinders   */
; 92   : char    *p, buf[1024];                  /* Work buffer               */
; 93   : char    *strtok_str = NULL;             /* last position             */

  0004c	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0

; 94   : 
; 95   :     /* Process the arguments */
; 96   :     if (!(retry = dev->connecting))

  00058	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00060	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00066	c1 e8 08	 shr	 eax, 8
  00069	83 e0 01	 and	 eax, 1
  0006c	89 84 24 90 00
	00 00		 mov	 DWORD PTR retry$[rsp], eax
  00073	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0007b	0f 85 3d 05 00
	00		 jne	 $LN13@shared_ckd

; 97   :     {
; 98   :         dev->connected = 0;             /* SHRD_CONNECT not done yet */

  00081	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00089	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0008f	83 e0 df	 and	 eax, -33		; ffffffdfH
  00092	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 99   : 
; 100  :         if (argc < 1 || strlen(argv[0]) >= sizeof(buf))

  000a0	83 bc 24 98 05
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000a8	7c 22		 jl	 SHORT $LN15@shared_ckd
  000aa	b8 08 00 00 00	 mov	 eax, 8
  000af	48 6b c0 00	 imul	 rax, rax, 0
  000b3	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000bb	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000bf	e8 00 00 00 00	 call	 strlen
  000c4	48 3d 00 04 00
	00		 cmp	 rax, 1024		; 00000400H
  000ca	72 0a		 jb	 SHORT $LN14@shared_ckd
$LN15@shared_ckd:

; 101  :             return -1;

  000cc	b8 ff ff ff ff	 mov	 eax, -1
  000d1	e9 76 13 00 00	 jmp	 $LN1@shared_ckd
$LN14@shared_ckd:

; 102  :         STRLCPY( buf, argv[0] );

  000d6	b8 08 00 00 00	 mov	 eax, 8
  000db	48 6b c0 00	 imul	 rax, rax, 0
  000df	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000e5	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ed	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000f1	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 103  : 
; 104  :         /* First argument is 'ipname:port:devnum' */
; 105  :         ipname = buf;

  000ff	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00107	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR ipname$[rsp], rax

; 106  :         if (strchr(ipname,'/') || strchr(ipname,'\\'))

  0010f	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00114	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipname$[rsp]
  0011c	e8 00 00 00 00	 call	 strchr
  00121	48 85 c0	 test	 rax, rax
  00124	75 17		 jne	 SHORT $LN17@shared_ckd
  00126	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0012b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipname$[rsp]
  00133	e8 00 00 00 00	 call	 strchr
  00138	48 85 c0	 test	 rax, rax
  0013b	74 0a		 je	 SHORT $LN16@shared_ckd
$LN17@shared_ckd:

; 107  :             return -1;

  0013d	b8 ff ff ff ff	 mov	 eax, -1
  00142	e9 05 13 00 00	 jmp	 $LN1@shared_ckd
$LN16@shared_ckd:

; 108  :         p = strchr (buf, ':');

  00147	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0014c	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00154	e8 00 00 00 00	 call	 strchr
  00159	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$[rsp], rax

; 109  :         if (p)

  00161	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  0016a	74 38		 je	 SHORT $LN18@shared_ckd

; 110  :         {
; 111  :             *p = '\0';

  0016c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00174	c6 00 00	 mov	 BYTE PTR [rax], 0

; 112  :             port = p + 1;

  00177	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0017f	48 ff c0	 inc	 rax
  00182	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR port$[rsp], rax

; 113  :             p = strchr (port, ':');

  0018a	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0018f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  00197	e8 00 00 00 00	 call	 strchr
  0019c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$[rsp], rax
$LN18@shared_ckd:

; 114  :         }
; 115  :         if (p)

  001a4	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  001ad	74 1e		 je	 SHORT $LN19@shared_ckd

; 116  :         {
; 117  :             *p = '\0';

  001af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001b7	c6 00 00	 mov	 BYTE PTR [rax], 0

; 118  :             rmtnum = p + 1;

  001ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001c2	48 ff c0	 inc	 rax
  001c5	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR rmtnum$[rsp], rax
$LN19@shared_ckd:

; 119  :         }
; 120  : 
; 121  : #if defined( HAVE_SYS_UN_H )
; 122  :         if ( strcmp (ipname, "localhost") == 0)
; 123  :             dev->localhost = 1;
; 124  :         else
; 125  : #endif
; 126  :         {
; 127  :             if ( (he = gethostbyname (ipname)) == NULL )

  001cd	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipname$[rsp]
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  001db	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR he$[rsp], rax
  001e3	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR he$[rsp], 0
  001ec	75 0a		 jne	 SHORT $LN20@shared_ckd

; 128  :                 return -1;

  001ee	b8 ff ff ff ff	 mov	 eax, -1
  001f3	e9 54 12 00 00	 jmp	 $LN1@shared_ckd
$LN20@shared_ckd:

; 129  :             memcpy(&dev->rmtaddr, he->h_addr_list[0], sizeof(dev->rmtaddr));

  001f8	b8 08 00 00 00	 mov	 eax, 8
  001fd	48 6b c0 00	 imul	 rax, rax, 0
  00201	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR he$[rsp]
  00209	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0020d	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00211	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00219	8b 00		 mov	 eax, DWORD PTR [rax]
  0021b	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 130  :         }
; 131  : 
; 132  :         if (port && strlen(port))

  00221	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR port$[rsp], 0
  0022a	74 50		 je	 SHORT $LN21@shared_ckd
  0022c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  00234	e8 00 00 00 00	 call	 strlen
  00239	48 85 c0	 test	 rax, rax
  0023c	74 3e		 je	 SHORT $LN21@shared_ckd

; 133  :         {
; 134  :             if (sscanf(port, "%hu%c", &dev->rmtport, &c) != 1)

  0023e	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00246	48 05 24 06 00
	00		 add	 rax, 1572		; 00000624H
  0024c	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR c$[rsp]
  00254	4c 8b c0	 mov	 r8, rax
  00257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168926
  0025e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  00266	e8 00 00 00 00	 call	 sscanf
  0026b	83 f8 01	 cmp	 eax, 1
  0026e	74 0a		 je	 SHORT $LN23@shared_ckd

; 135  :                 return -1;

  00270	b8 ff ff ff ff	 mov	 eax, -1
  00275	e9 d2 11 00 00	 jmp	 $LN1@shared_ckd
$LN23@shared_ckd:

; 136  :         }

  0027a	eb 14		 jmp	 SHORT $LN22@shared_ckd
$LN21@shared_ckd:

; 137  :         else
; 138  :             dev->rmtport = SHARED_DEFAULT_PORT;

  0027c	b8 96 0f 00 00	 mov	 eax, 3990		; 00000f96H
  00281	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00289	66 89 81 24 06
	00 00		 mov	 WORD PTR [rcx+1572], ax
$LN22@shared_ckd:

; 139  : 
; 140  :         if (rmtnum && strlen(rmtnum))

  00290	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR rmtnum$[rsp], 0
  00299	74 63		 je	 SHORT $LN24@shared_ckd
  0029b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR rmtnum$[rsp]
  002a3	e8 00 00 00 00	 call	 strlen
  002a8	48 85 c0	 test	 rax, rax
  002ab	74 51		 je	 SHORT $LN24@shared_ckd

; 141  :         {
; 142  :             if (strlen (rmtnum) > 4
; 143  :              || sscanf (rmtnum, "%hx%c", &dev->rmtnum, &c) != 1)

  002ad	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR rmtnum$[rsp]
  002b5	e8 00 00 00 00	 call	 strlen
  002ba	48 83 f8 04	 cmp	 rax, 4
  002be	77 32		 ja	 SHORT $LN27@shared_ckd
  002c0	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002c8	48 05 26 06 00
	00		 add	 rax, 1574		; 00000626H
  002ce	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR c$[rsp]
  002d6	4c 8b c0	 mov	 r8, rax
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168931
  002e0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR rmtnum$[rsp]
  002e8	e8 00 00 00 00	 call	 sscanf
  002ed	83 f8 01	 cmp	 eax, 1
  002f0	74 0a		 je	 SHORT $LN26@shared_ckd
$LN27@shared_ckd:

; 144  :                 return -1;

  002f2	b8 ff ff ff ff	 mov	 eax, -1
  002f7	e9 50 11 00 00	 jmp	 $LN1@shared_ckd
$LN26@shared_ckd:

; 145  :         }

  002fc	eb 1b		 jmp	 SHORT $LN25@shared_ckd
$LN24@shared_ckd:

; 146  :         else
; 147  :             dev->rmtnum = dev->devnum;

  002fe	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00306	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0030e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00312	66 89 88 26 06
	00 00		 mov	 WORD PTR [rax+1574], cx
$LN25@shared_ckd:

; 148  : 
; 149  :         /* Process the remaining arguments */
; 150  :         for (i = 1; i < argc; i++)

  00319	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  00324	eb 10		 jmp	 SHORT $LN4@shared_ckd
$LN2@shared_ckd:
  00326	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0032d	ff c0		 inc	 eax
  0032f	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@shared_ckd:
  00336	8b 84 24 98 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0033d	39 84 24 84 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00344	0f 8d 74 02 00
	00		 jge	 $LN3@shared_ckd

; 151  :         {
; 152  :             if (strcasecmp ("readonly", argv[i]) == 0 ||
; 153  :                 strcasecmp ("rdonly",   argv[i]) == 0 ||

  0034a	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00352	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0035a	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0035e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168934
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0036b	85 c0		 test	 eax, eax
  0036d	74 4a		 je	 SHORT $LN29@shared_ckd
  0036f	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00377	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0037f	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168935
  0038a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00390	85 c0		 test	 eax, eax
  00392	74 25		 je	 SHORT $LN29@shared_ckd
  00394	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0039c	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003a4	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168936
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003b5	85 c0		 test	 eax, eax
  003b7	75 25		 jne	 SHORT $LN28@shared_ckd
$LN29@shared_ckd:

; 154  :                 strcasecmp ("ro",       argv[i]) == 0)
; 155  :             {
; 156  :                 dev->ckdrdonly = 1;

  003b9	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  003c7	0f ba e8 12	 bts	 eax, 18
  003cb	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 157  :                 continue;

  003d9	e9 48 ff ff ff	 jmp	 $LN2@shared_ckd
$LN28@shared_ckd:

; 158  :             }
; 159  :             if (strcasecmp ("fakewrite", argv[i]) == 0 ||
; 160  :                 strcasecmp ("fakewrt",   argv[i]) == 0 ||

  003de	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  003e6	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003ee	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168939
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003ff	85 c0		 test	 eax, eax
  00401	74 4a		 je	 SHORT $LN31@shared_ckd
  00403	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0040b	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00413	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00417	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168940
  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00424	85 c0		 test	 eax, eax
  00426	74 25		 je	 SHORT $LN31@shared_ckd
  00428	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00430	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00438	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168941
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00449	85 c0		 test	 eax, eax
  0044b	75 25		 jne	 SHORT $LN30@shared_ckd
$LN31@shared_ckd:

; 161  :                 strcasecmp ("fw",        argv[i]) == 0)
; 162  :             {
; 163  :                 dev->ckdfakewr = 1;

  0044d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00455	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0045b	0f ba e8 14	 bts	 eax, 20
  0045f	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00467	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 164  :                 continue;

  0046d	e9 b4 fe ff ff	 jmp	 $LN2@shared_ckd
$LN30@shared_ckd:

; 165  :             }
; 166  :             if (strlen (argv[i]) > 3
; 167  :              && memcmp("cu=", argv[i], 3) == 0)

  00472	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0047a	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00482	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00486	e8 00 00 00 00	 call	 strlen
  0048b	48 83 f8 03	 cmp	 rax, 3
  0048f	0f 86 8f 00 00
	00		 jbe	 $LN32@shared_ckd
  00495	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0049d	41 b8 03 00 00
	00		 mov	 r8d, 3
  004a3	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004ab	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168943
  004b6	e8 00 00 00 00	 call	 memcmp
  004bb	85 c0		 test	 eax, eax
  004bd	75 65		 jne	 SHORT $LN32@shared_ckd

; 168  :             {
; 169  :                 kw = strtok_r (argv[i], "=", &strtok_str );

  004bf	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  004c7	4c 8d 84 24 28
	01 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168944
  004d6	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004de	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  004e8	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR kw$[rsp], rax

; 170  :                 op = strtok_r (NULL, " \t", &strtok_str );

  004f0	4c 8d 84 24 28
	01 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168945
  004ff	33 c9		 xor	 ecx, ecx
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00507	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR op$[rsp], rax

; 171  :                 cu = op;

  0050f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR op$[rsp]
  00517	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR cu$[rsp], rax

; 172  :                 continue;

  0051f	e9 02 fe ff ff	 jmp	 $LN2@shared_ckd
$LN32@shared_ckd:

; 173  :             }
; 174  : #if defined( HAVE_ZLIB )
; 175  :             if (strlen (argv[i]) > 5
; 176  :              && memcmp("comp=", argv[i], 5) == 0)
; 177  :             {
; 178  :                 kw = strtok_r (argv[i], "=", &strtok_str );
; 179  :                 op = strtok_r (NULL, " \t", &strtok_str );
; 180  :                 dev->rmtcomp = atoi (op);
; 181  :                 if (dev->rmtcomp < 0 || dev->rmtcomp > 9)
; 182  :                     dev->rmtcomp = 0;
; 183  :                 continue;
; 184  :             }
; 185  : #endif
; 186  :             // "Shared: parameter %s in argument %d is invalid"
; 187  :             WRMSG( HHC00700, "S", argv[i], i + 1 );

  00524	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0052b	ff c0		 inc	 eax
  0052d	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv252[rsp], eax
  00534	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0053c	48 89 8c 24 48
	01 00 00	 mov	 QWORD PTR tv254[rsp], rcx
  00544	b9 01 00 00 00	 mov	 ecx, 1
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0054f	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  00556	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0055a	48 8b 8c 24 a0
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00562	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR tv254[rsp]
  0056a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0056e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00573	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168946
  0057a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0057f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168947
  00586	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0058b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00590	41 b9 03 00 00
	00		 mov	 r9d, 3
  00596	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168948
  0059d	ba bb 00 00 00	 mov	 edx, 187		; 000000bbH
  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168949
  005a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 188  :             return -1;

  005af	b8 ff ff ff ff	 mov	 eax, -1
  005b4	e9 93 0e 00 00	 jmp	 $LN1@shared_ckd

; 189  :         }

  005b9	e9 68 fd ff ff	 jmp	 $LN2@shared_ckd
$LN3@shared_ckd:
$LN13@shared_ckd:

; 190  :     }
; 191  : 
; 192  :     /* Set suported compression */
; 193  :     dev->rmtcomps = 0;

  005be	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c6	c7 80 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1600], 0

; 194  : #if defined( HAVE_ZLIB )
; 195  :     dev->rmtcomps |= SHRD_LIBZ;
; 196  : #endif
; 197  : #if defined( CCKD_BZIP2 )
; 198  :     dev->rmtcomps |= SHRD_BZIP2;
; 199  : #endif
; 200  : 
; 201  :     /* Update the device handler vector */
; 202  :     dev->hnd = &shared_ckd_device_hndinfo;

  005d0	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:shared_ckd_device_hndinfo
  005df	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx

; 203  : 
; 204  :     dev->connecting = 1;

  005e6	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ee	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005f4	0f ba e8 08	 bts	 eax, 8
  005f8	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00600	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN106@shared_ckd:
$LN105@shared_ckd:
$LN104@shared_ckd:
$init_retry$108:
$LN7@shared_ckd:

; 205  : 
; 206  : init_retry:
; 207  : 
; 208  :     do {
; 209  :         rc = clientConnect (dev, retry);

  00606	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR retry$[rsp]
  0060d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00615	e8 00 00 00 00	 call	 clientConnect
  0061a	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 210  :         if (rc < 0)

  00621	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00629	0f 8d 23 01 00
	00		 jge	 $LN33@shared_ckd

; 211  :         {
; 212  :             // "%1d:%04X Shared: connect pending to file %s"
; 213  :             WRMSG( HHC00701, "W", LCSS_DEVNUM, dev->filename );

  0062f	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00638	74 15		 je	 SHORT $LN64@shared_ckd
  0063a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00642	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00646	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv281[rsp], eax
  0064d	eb 0b		 jmp	 SHORT $LN65@shared_ckd
$LN64@shared_ckd:
  0064f	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv281[rsp], 0
$LN65@shared_ckd:
  0065a	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00663	74 17		 je	 SHORT $LN66@shared_ckd
  00665	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0066d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00671	d1 f8		 sar	 eax, 1
  00673	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  0067a	eb 0b		 jmp	 SHORT $LN67@shared_ckd
$LN66@shared_ckd:
  0067c	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv287[rsp], 0
$LN67@shared_ckd:
  00687	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068f	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00695	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv276[rsp], rax
  0069d	b9 01 00 00 00	 mov	 ecx, 1
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  006b0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006b5	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  006bc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006c0	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  006c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168951
  006d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168952
  006de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168953
  006f5	ba d5 00 00 00	 mov	 edx, 213		; 000000d5H
  006fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168954
  00701	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 214  :             if (retry) SLEEP(5);

  00707	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0070f	74 41		 je	 SHORT $LN34@shared_ckd
$LN10@shared_ckd:
  00711	c7 84 24 8c 00
	00 00 05 00 00
	00		 mov	 DWORD PTR rc$1[rsp], 5
$LN11@shared_ckd:
  0071c	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00724	74 26		 je	 SHORT $LN12@shared_ckd
  00726	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR rc$1[rsp]
  0072d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00733	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax
  0073a	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00742	74 06		 je	 SHORT $LN35@shared_ckd
  00744	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN35@shared_ckd:
  0074a	eb d0		 jmp	 SHORT $LN11@shared_ckd
$LN12@shared_ckd:
  0074c	33 c0		 xor	 eax, eax
  0074e	85 c0		 test	 eax, eax
  00750	75 bf		 jne	 SHORT $LN10@shared_ckd
$LN34@shared_ckd:
$LN33@shared_ckd:

; 215  :         }
; 216  :     } while (retry && rc < 0);

  00752	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0075a	74 0e		 je	 SHORT $LN36@shared_ckd
  0075c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00764	0f 8c 9c fe ff
	ff		 jl	 $LN7@shared_ckd
$LN36@shared_ckd:

; 217  : 
; 218  :     /* Return if unable to connect */
; 219  :     if (rc < 0) return 0;

  0076a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00772	7d 07		 jge	 SHORT $LN37@shared_ckd
  00774	33 c0		 xor	 eax, eax
  00776	e9 d1 0c 00 00	 jmp	 $LN1@shared_ckd
$LN37@shared_ckd:

; 220  : 
; 221  :     dev->ckdnumfd = 1;

  0077b	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00783	c7 80 c4 11 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4548], 1

; 222  :     dev->ckdfd[0] = dev->fd;

  0078d	b8 04 00 00 00	 mov	 eax, 4
  00792	48 6b c0 00	 imul	 rax, rax, 0
  00796	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0079e	48 8b 94 24 90
	05 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007a6	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  007ac	89 94 01 c8 11
	00 00		 mov	 DWORD PTR [rcx+rax+4552], edx

; 223  : 
; 224  :     /* Get the number of cylinders */
; 225  :     rc = clientRequest (dev, cyls, 4, SHRD_QUERY, SHRD_CKDCYLS, NULL, NULL);

  007b3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007bc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  007c5	c7 44 24 20 48
	00 00 00	 mov	 DWORD PTR [rsp+32], 72	; 00000048H
  007cd	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  007d3	41 b8 04 00 00
	00		 mov	 r8d, 4
  007d9	48 8d 94 24 0c
	01 00 00	 lea	 rdx, QWORD PTR cyls$[rsp]
  007e1	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007e9	e8 00 00 00 00	 call	 clientRequest
  007ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 226  :     if (rc < 0)

  007f5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  007fd	7d 0a		 jge	 SHORT $LN38@shared_ckd

; 227  :         goto init_retry;

  007ff	e9 02 fe ff ff	 jmp	 $init_retry$108
  00804	e9 cd 00 00 00	 jmp	 $LN39@shared_ckd
$LN38@shared_ckd:

; 228  :     else if (rc != 4)

  00809	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR rc$[rsp], 4
  00811	0f 84 bf 00 00
	00		 je	 $LN40@shared_ckd

; 229  :     {
; 230  :         // "%1d:%04X Shared: error retrieving cylinders"
; 231  :         WRMSG( HHC00702, "S", LCSS_DEVNUM );

  00817	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00820	74 15		 je	 SHORT $LN68@shared_ckd
  00822	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0082a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0082e	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv325[rsp], eax
  00835	eb 0b		 jmp	 SHORT $LN69@shared_ckd
$LN68@shared_ckd:
  00837	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv325[rsp], 0
$LN69@shared_ckd:
  00842	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0084b	74 17		 je	 SHORT $LN70@shared_ckd
  0084d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00855	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00859	d1 f8		 sar	 eax, 1
  0085b	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv331[rsp], eax
  00862	eb 0b		 jmp	 SHORT $LN71@shared_ckd
$LN70@shared_ckd:
  00864	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv331[rsp], 0
$LN71@shared_ckd:
  0086f	b9 01 00 00 00	 mov	 ecx, 1
  00874	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0087a	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv325[rsp]
  00881	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00885	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv331[rsp]
  0088c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00890	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168962
  00897	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168963
  008a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168964
  008ba	ba e7 00 00 00	 mov	 edx, 231		; 000000e7H
  008bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168965
  008c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 232  :         return -1;

  008cc	b8 ff ff ff ff	 mov	 eax, -1
  008d1	e9 76 0b 00 00	 jmp	 $LN1@shared_ckd
$LN40@shared_ckd:
$LN39@shared_ckd:

; 233  :     }
; 234  :     dev->ckdcyls = fetch_fw (cyls);

  008d6	48 8d 8c 24 0c
	01 00 00	 lea	 rcx, QWORD PTR cyls$[rsp]
  008de	e8 00 00 00 00	 call	 fetch_fw_noswap
  008e3	8b c8		 mov	 ecx, eax
  008e5	e8 00 00 00 00	 call	 _byteswap_ulong
  008ea	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008f2	89 81 b8 12 00
	00		 mov	 DWORD PTR [rcx+4792], eax

; 235  : 
; 236  :     /* Get the device characteristics */
; 237  :     rc = clientRequest (dev, dev->devchar, sizeof(dev->devchar),

  008f8	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00900	48 05 6c 05 00
	00		 add	 rax, 1388		; 0000056cH
  00906	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0090f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00918	c7 44 24 20 41
	00 00 00	 mov	 DWORD PTR [rsp+32], 65	; 00000041H
  00920	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00926	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0092c	48 8b d0	 mov	 rdx, rax
  0092f	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00937	e8 00 00 00 00	 call	 clientRequest
  0093c	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 238  :                         SHRD_QUERY, SHRD_DEVCHAR, NULL, NULL);
; 239  :     if (rc < 0)

  00943	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0094b	7d 0a		 jge	 SHORT $LN41@shared_ckd

; 240  :         goto init_retry;

  0094d	e9 b4 fc ff ff	 jmp	 $LN104@shared_ckd
  00952	e9 d7 00 00 00	 jmp	 $LN42@shared_ckd
$LN41@shared_ckd:

; 241  :     else if (rc == 0 || rc > (int)sizeof(dev->devchar))

  00957	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0095f	74 0e		 je	 SHORT $LN44@shared_ckd
  00961	83 bc 24 80 00
	00 00 40	 cmp	 DWORD PTR rc$[rsp], 64	; 00000040H
  00969	0f 8e bf 00 00
	00		 jle	 $LN43@shared_ckd
$LN44@shared_ckd:

; 242  :     {
; 243  :         // "%1d:%04X Shared: error retrieving device characteristics"
; 244  :         WRMSG( HHC00703, "S", LCSS_DEVNUM );

  0096f	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00978	74 15		 je	 SHORT $LN72@shared_ckd
  0097a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00982	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00986	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv362[rsp], eax
  0098d	eb 0b		 jmp	 SHORT $LN73@shared_ckd
$LN72@shared_ckd:
  0098f	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv362[rsp], 0
$LN73@shared_ckd:
  0099a	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009a3	74 17		 je	 SHORT $LN74@shared_ckd
  009a5	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009ad	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  009b1	d1 f8		 sar	 eax, 1
  009b3	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv368[rsp], eax
  009ba	eb 0b		 jmp	 SHORT $LN75@shared_ckd
$LN74@shared_ckd:
  009bc	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv368[rsp], 0
$LN75@shared_ckd:
  009c7	b9 01 00 00 00	 mov	 ecx, 1
  009cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009d2	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv362[rsp]
  009d9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009dd	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv368[rsp]
  009e4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168970
  009ef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168971
  009fb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a00	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a05	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a0b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168972
  00a12	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00a17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168973
  00a1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 245  :         return -1;

  00a24	b8 ff ff ff ff	 mov	 eax, -1
  00a29	e9 1e 0a 00 00	 jmp	 $LN1@shared_ckd
$LN43@shared_ckd:
$LN42@shared_ckd:

; 246  :     }
; 247  :     dev->numdevchar = rc;

  00a2e	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a36	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00a3d	89 88 68 05 00
	00		 mov	 DWORD PTR [rax+1384], ecx

; 248  : 
; 249  :     /* Get number of heads from devchar */
; 250  :     dev->ckdheads = fetch_hw (dev->devchar + 14);

  00a43	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a4b	48 05 7a 05 00
	00		 add	 rax, 1402		; 0000057aH
  00a51	48 8b c8	 mov	 rcx, rax
  00a54	e8 00 00 00 00	 call	 fetch_hw_noswap
  00a59	0f b7 c8	 movzx	 ecx, ax
  00a5c	e8 00 00 00 00	 call	 _byteswap_ushort
  00a61	0f b7 c0	 movzx	 eax, ax
  00a64	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a6c	89 81 c0 12 00
	00		 mov	 DWORD PTR [rcx+4800], eax

; 251  : 
; 252  :     /* Calculate number of tracks */
; 253  :     dev->ckdtrks = dev->ckdcyls * dev->ckdheads;

  00a72	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a7a	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a82	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  00a88	0f af 81 c0 12
	00 00		 imul	 eax, DWORD PTR [rcx+4800]
  00a8f	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a97	89 81 bc 12 00
	00		 mov	 DWORD PTR [rcx+4796], eax

; 254  :     dev->ckdhitrk[0] = dev->ckdtrks;

  00a9d	b8 04 00 00 00	 mov	 eax, 4
  00aa2	48 6b c0 00	 imul	 rax, rax, 0
  00aa6	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aae	48 8b 94 24 90
	05 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00ab6	8b 92 bc 12 00
	00		 mov	 edx, DWORD PTR [rdx+4796]
  00abc	89 94 01 34 12
	00 00		 mov	 DWORD PTR [rcx+rax+4660], edx

; 255  : 
; 256  :     /* Check the device type */
; 257  :     if (dev->devtype == 0)

  00ac3	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00acb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00acf	85 c0		 test	 eax, eax
  00ad1	75 2f		 jne	 SHORT $LN45@shared_ckd

; 258  :         dev->devtype = fetch_hw (dev->devchar + 3);

  00ad3	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00adb	48 05 6f 05 00
	00		 add	 rax, 1391		; 0000056fH
  00ae1	48 8b c8	 mov	 rcx, rax
  00ae4	e8 00 00 00 00	 call	 fetch_hw_noswap
  00ae9	0f b7 c8	 movzx	 ecx, ax
  00aec	e8 00 00 00 00	 call	 _byteswap_ushort
  00af1	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00af9	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
  00afd	e9 54 01 00 00	 jmp	 $LN46@shared_ckd
$LN45@shared_ckd:

; 259  :     else if (dev->devtype != fetch_hw (dev->devchar + 3))

  00b02	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b0a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00b0e	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv407[rsp], eax
  00b15	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b1d	48 81 c1 6f 05
	00 00		 add	 rcx, 1391		; 0000056fH
  00b24	e8 00 00 00 00	 call	 fetch_hw_noswap
  00b29	0f b7 c8	 movzx	 ecx, ax
  00b2c	e8 00 00 00 00	 call	 _byteswap_ushort
  00b31	0f b7 c0	 movzx	 eax, ax
  00b34	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv407[rsp]
  00b3b	3b c8		 cmp	 ecx, eax
  00b3d	0f 84 13 01 00
	00		 je	 $LN47@shared_ckd

; 260  :     {
; 261  :         // "%1d:%04X Shared: remote device %04X is a %04X"
; 262  :         WRMSG( HHC00704, "S", LCSS_DEVNUM, dev->rmtnum, fetch_hw( dev->devchar + 3 ));

  00b43	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b4c	74 15		 je	 SHORT $LN76@shared_ckd
  00b4e	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b56	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b5a	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv430[rsp], eax
  00b61	eb 0b		 jmp	 SHORT $LN77@shared_ckd
$LN76@shared_ckd:
  00b63	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv430[rsp], 0
$LN77@shared_ckd:
  00b6e	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b77	74 17		 je	 SHORT $LN78@shared_ckd
  00b79	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b81	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b85	d1 f8		 sar	 eax, 1
  00b87	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv436[rsp], eax
  00b8e	eb 0b		 jmp	 SHORT $LN79@shared_ckd
$LN78@shared_ckd:
  00b90	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv436[rsp], 0
$LN79@shared_ckd:
  00b9b	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ba3	48 05 6f 05 00
	00		 add	 rax, 1391		; 0000056fH
  00ba9	48 8b c8	 mov	 rcx, rax
  00bac	e8 00 00 00 00	 call	 fetch_hw_noswap
  00bb1	0f b7 c8	 movzx	 ecx, ax
  00bb4	e8 00 00 00 00	 call	 _byteswap_ushort
  00bb9	0f b7 c0	 movzx	 eax, ax
  00bbc	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv422[rsp], eax
  00bc3	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bcb	0f b7 89 26 06
	00 00		 movzx	 ecx, WORD PTR [rcx+1574]
  00bd2	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv425[rsp], ecx
  00bd9	b9 01 00 00 00	 mov	 ecx, 1
  00bde	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00be4	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv422[rsp]
  00beb	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00bef	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv425[rsp]
  00bf6	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00bfa	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv430[rsp]
  00c01	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c05	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv436[rsp]
  00c0c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168977
  00c17	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c1c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168978
  00c23	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c28	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c2d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c33	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168979
  00c3a	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  00c3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168980
  00c46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 263  :         return -1;

  00c4c	b8 ff ff ff ff	 mov	 eax, -1
  00c51	e9 f6 07 00 00	 jmp	 $LN1@shared_ckd
$LN47@shared_ckd:
$LN46@shared_ckd:

; 264  :     }
; 265  : 
; 266  :     /* Get the device id */
; 267  :     rc = clientRequest (dev, dev->devid, sizeof(dev->devid),

  00c56	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c5e	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00c64	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c6d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00c76	c7 44 24 20 42
	00 00 00	 mov	 DWORD PTR [rsp+32], 66	; 00000042H
  00c7e	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00c84	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00c8a	48 8b d0	 mov	 rdx, rax
  00c8d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c95	e8 00 00 00 00	 call	 clientRequest
  00c9a	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 268  :                         SHRD_QUERY, SHRD_DEVID, NULL, NULL);
; 269  :     if (rc < 0)

  00ca1	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00ca9	7d 0a		 jge	 SHORT $LN48@shared_ckd

; 270  :         goto init_retry;

  00cab	e9 56 f9 ff ff	 jmp	 $LN105@shared_ckd
  00cb0	e9 da 00 00 00	 jmp	 $LN49@shared_ckd
$LN48@shared_ckd:

; 271  :     else if (rc == 0 || rc > (int)sizeof(dev->devid))

  00cb5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00cbd	74 11		 je	 SHORT $LN51@shared_ckd
  00cbf	81 bc 24 80 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR rc$[rsp], 256	; 00000100H
  00cca	0f 8e bf 00 00
	00		 jle	 $LN50@shared_ckd
$LN51@shared_ckd:

; 272  :     {
; 273  :         // "%1d:%04X Shared: error retrieving device id"
; 274  :         WRMSG( HHC00705, "S", LCSS_DEVNUM );

  00cd0	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cd9	74 15		 je	 SHORT $LN80@shared_ckd
  00cdb	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ce3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ce7	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv462[rsp], eax
  00cee	eb 0b		 jmp	 SHORT $LN81@shared_ckd
$LN80@shared_ckd:
  00cf0	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv462[rsp], 0
$LN81@shared_ckd:
  00cfb	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d04	74 17		 je	 SHORT $LN82@shared_ckd
  00d06	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d0e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d12	d1 f8		 sar	 eax, 1
  00d14	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
  00d1b	eb 0b		 jmp	 SHORT $LN83@shared_ckd
$LN82@shared_ckd:
  00d1d	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv468[rsp], 0
$LN83@shared_ckd:
  00d28	b9 01 00 00 00	 mov	 ecx, 1
  00d2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d33	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv462[rsp]
  00d3a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d3e	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv468[rsp]
  00d45	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  00d50	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168986
  00d5c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d61	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d66	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168987
  00d73	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  00d78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168988
  00d7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 275  :         return -1;

  00d85	b8 ff ff ff ff	 mov	 eax, -1
  00d8a	e9 bd 06 00 00	 jmp	 $LN1@shared_ckd
$LN50@shared_ckd:
$LN49@shared_ckd:

; 276  :     }
; 277  :     dev->numdevid = rc;

  00d8f	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d97	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00d9e	89 88 64 04 00
	00		 mov	 DWORD PTR [rax+1124], ecx

; 278  : 
; 279  :     /* Get the serial number if the server supports such a query */
; 280  : 
; 281  :     if (dev->rmtver <  SHARED_VERSION ||

  00da4	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dac	83 b8 2c 06 00
	00 00		 cmp	 DWORD PTR [rax+1580], 0
  00db3	7c 22		 jl	 SHORT $LN54@shared_ckd
  00db5	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dbd	83 b8 2c 06 00
	00 00		 cmp	 DWORD PTR [rax+1580], 0
  00dc4	75 2c		 jne	 SHORT $LN52@shared_ckd
  00dc6	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dce	83 b8 30 06 00
	00 02		 cmp	 DWORD PTR [rax+1584], 2
  00dd5	7d 1b		 jge	 SHORT $LN52@shared_ckd
$LN54@shared_ckd:

; 282  :        (dev->rmtver == SHARED_VERSION &&
; 283  :         dev->rmtrel <  SHARED_RELEASE))
; 284  :     {
; 285  :         /* Generate a random serial number */
; 286  :         gen_dasd_serial( dev->serial );

  00dd7	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ddf	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00de5	48 8b c8	 mov	 rcx, rax
  00de8	e8 00 00 00 00	 call	 gen_dasd_serial

; 287  :     }

  00ded	e9 36 01 00 00	 jmp	 $LN53@shared_ckd
$LN52@shared_ckd:

; 288  :     else /* (server SHOULD support the SHRD_SERIAL query) */
; 289  :     {
; 290  :         rc = clientRequest (dev, dev->serial, sizeof(dev->serial),

  00df2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dfa	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00e00	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00e09	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00e12	c7 44 24 20 44
	00 00 00	 mov	 DWORD PTR [rsp+32], 68	; 00000044H
  00e1a	41 b9 eb 00 00
	00		 mov	 r9d, 235		; 000000ebH
  00e20	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00e26	48 8b d0	 mov	 rdx, rax
  00e29	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e31	e8 00 00 00 00	 call	 clientRequest
  00e36	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 291  :                             SHRD_QUERY, SHRD_SERIAL, NULL, NULL);
; 292  :         if (rc < 0)

  00e3d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e45	7d 0a		 jge	 SHORT $LN55@shared_ckd

; 293  :             goto init_retry;

  00e47	e9 ba f7 ff ff	 jmp	 $LN106@shared_ckd
  00e4c	e9 d7 00 00 00	 jmp	 $LN56@shared_ckd
$LN55@shared_ckd:

; 294  :         else if (rc == 0 || rc > (int)sizeof(dev->serial))

  00e51	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e59	74 0e		 je	 SHORT $LN58@shared_ckd
  00e5b	83 bc 24 80 00
	00 00 0c	 cmp	 DWORD PTR rc$[rsp], 12
  00e63	0f 8e bf 00 00
	00		 jle	 $LN57@shared_ckd
$LN58@shared_ckd:

; 295  :         {
; 296  :             // "%1d:%04X Shared: error retrieving serial number"
; 297  :             WRMSG( HHC00716, "S", LCSS_DEVNUM );

  00e69	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e72	74 15		 je	 SHORT $LN84@shared_ckd
  00e74	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e7c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e80	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv535[rsp], eax
  00e87	eb 0b		 jmp	 SHORT $LN85@shared_ckd
$LN84@shared_ckd:
  00e89	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv535[rsp], 0
$LN85@shared_ckd:
  00e94	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e9d	74 17		 je	 SHORT $LN86@shared_ckd
  00e9f	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ea7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00eab	d1 f8		 sar	 eax, 1
  00ead	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv541[rsp], eax
  00eb4	eb 0b		 jmp	 SHORT $LN87@shared_ckd
$LN86@shared_ckd:
  00eb6	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv541[rsp], 0
$LN87@shared_ckd:
  00ec1	b9 01 00 00 00	 mov	 ecx, 1
  00ec6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ecc	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv535[rsp]
  00ed3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ed7	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv541[rsp]
  00ede	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ee2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168996
  00ee9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00eee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  00ef5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00efa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00eff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f05	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168998
  00f0c	ba 29 01 00 00	 mov	 edx, 297		; 00000129H
  00f11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168999
  00f18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 298  :             return -1;

  00f1e	b8 ff ff ff ff	 mov	 eax, -1
  00f23	e9 24 05 00 00	 jmp	 $LN1@shared_ckd
$LN57@shared_ckd:
$LN56@shared_ckd:
$LN53@shared_ckd:

; 299  :         }
; 300  :     }
; 301  : 
; 302  :     /* Indicate no active track */
; 303  :     dev->cache = dev->bufcur = -1;

  00f28	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f30	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
  00f3a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f42	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 304  :     dev->buf = NULL;

  00f4c	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f54	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 305  : 
; 306  :     /* Set number of sense bytes */
; 307  :     dev->numsense = 32;

  00f5f	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f67	c7 80 60 03 00
	00 20 00 00 00	 mov	 DWORD PTR [rax+864], 32	; 00000020H

; 308  : 
; 309  :     /* Locate the CKD dasd table entry */
; 310  :     dev->ckdtab = dasd_lookup (DASD_CKDDEV, NULL, dev->devtype, dev->ckdcyls);

  00f71	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f79	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f7d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f85	44 8b 89 b8 12
	00 00		 mov	 r9d, DWORD PTR [rcx+4792]
  00f8c	44 8b c0	 mov	 r8d, eax
  00f8f	33 d2		 xor	 edx, edx
  00f91	b9 01 00 00 00	 mov	 ecx, 1
  00f96	e8 00 00 00 00	 call	 dasd_lookup
  00f9b	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fa3	48 89 81 a0 12
	00 00		 mov	 QWORD PTR [rcx+4768], rax

; 311  :     if (dev->ckdtab == NULL)

  00faa	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fb2	48 83 b8 a0 12
	00 00 00	 cmp	 QWORD PTR [rax+4768], 0
  00fba	0f 85 dd 00 00
	00		 jne	 $LN59@shared_ckd

; 312  :     {
; 313  :         // "%1d:%04X Shared: device type %4.4X not found in dasd table"
; 314  :         WRMSG( HHC00706, "S", LCSS_DEVNUM, dev->devtype );

  00fc0	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00fc9	74 15		 je	 SHORT $LN88@shared_ckd
  00fcb	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fd3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00fd7	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv573[rsp], eax
  00fde	eb 0b		 jmp	 SHORT $LN89@shared_ckd
$LN88@shared_ckd:
  00fe0	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv573[rsp], 0
$LN89@shared_ckd:
  00feb	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ff4	74 17		 je	 SHORT $LN90@shared_ckd
  00ff6	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ffe	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01002	d1 f8		 sar	 eax, 1
  01004	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv579[rsp], eax
  0100b	eb 0b		 jmp	 SHORT $LN91@shared_ckd
$LN90@shared_ckd:
  0100d	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv579[rsp], 0
$LN91@shared_ckd:
  01018	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01020	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01024	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv568[rsp], eax
  0102b	b9 01 00 00 00	 mov	 ecx, 1
  01030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01036	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv568[rsp]
  0103d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01041	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv573[rsp]
  01048	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0104c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv579[rsp]
  01053	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169001
  0105e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169002
  0106a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0106f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01074	41 b9 03 00 00
	00		 mov	 r9d, 3
  0107a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169003
  01081	ba 3a 01 00 00	 mov	 edx, 314		; 0000013aH
  01086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169004
  0108d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 315  :         return -1;

  01093	b8 ff ff ff ff	 mov	 eax, -1
  01098	e9 af 03 00 00	 jmp	 $LN1@shared_ckd
$LN59@shared_ckd:

; 316  :     }
; 317  : 
; 318  :     /* Set the track size */
; 319  :     dev->ckdtrksz = (dev->ckdtab->r1 + 511) & ~511;

  0109d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010a5	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  010ac	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  010b0	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  010b5	25 00 fe ff ff	 and	 eax, -512		; fffffffffffffe00H
  010ba	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010c2	89 81 c4 12 00
	00		 mov	 DWORD PTR [rcx+4804], eax

; 320  : 
; 321  :     /* Locate the CKD control unit dasd table entry */
; 322  :     dev->ckdcu = dasd_lookup (DASD_CKDCU, cu ? cu : dev->ckdtab->cu, 0, 0);

  010c8	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR cu$[rsp], 0
  010d1	74 12		 je	 SHORT $LN92@shared_ckd
  010d3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR cu$[rsp]
  010db	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv603[rsp], rax
  010e3	eb 1b		 jmp	 SHORT $LN93@shared_ckd
$LN92@shared_ckd:
  010e5	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010ed	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  010f4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  010f8	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv603[rsp], rax
$LN93@shared_ckd:
  01100	45 33 c9	 xor	 r9d, r9d
  01103	45 33 c0	 xor	 r8d, r8d
  01106	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR tv603[rsp]
  0110e	b9 02 00 00 00	 mov	 ecx, 2
  01113	e8 00 00 00 00	 call	 dasd_lookup
  01118	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01120	48 89 81 a8 12
	00 00		 mov	 QWORD PTR [rcx+4776], rax

; 323  :     if (dev->ckdcu == NULL)

  01127	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0112f	48 83 b8 a8 12
	00 00 00	 cmp	 QWORD PTR [rax+4776], 0
  01137	0f 85 04 01 00
	00		 jne	 $LN60@shared_ckd

; 324  :     {
; 325  :         // "%1d:%04X Shared: control unit %s not found in dasd table"
; 326  :         WRMSG( HHC00707, "S", LCSS_DEVNUM, cu ? cu : dev->ckdtab->cu );

  0113d	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR cu$[rsp], 0
  01146	74 12		 je	 SHORT $LN94@shared_ckd
  01148	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR cu$[rsp]
  01150	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv611[rsp], rax
  01158	eb 1b		 jmp	 SHORT $LN95@shared_ckd
$LN94@shared_ckd:
  0115a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01162	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  01169	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0116d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv611[rsp], rax
$LN95@shared_ckd:
  01175	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0117e	74 15		 je	 SHORT $LN96@shared_ckd
  01180	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01188	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0118c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv616[rsp], eax
  01193	eb 0b		 jmp	 SHORT $LN97@shared_ckd
$LN96@shared_ckd:
  01195	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv616[rsp], 0
$LN97@shared_ckd:
  011a0	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  011a9	74 17		 je	 SHORT $LN98@shared_ckd
  011ab	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011b3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  011b7	d1 f8		 sar	 eax, 1
  011b9	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv622[rsp], eax
  011c0	eb 0b		 jmp	 SHORT $LN99@shared_ckd
$LN98@shared_ckd:
  011c2	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv622[rsp], 0
$LN99@shared_ckd:
  011cd	b9 01 00 00 00	 mov	 ecx, 1
  011d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011d8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv611[rsp]
  011e0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  011e5	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv616[rsp]
  011ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011f0	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv622[rsp]
  011f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  011fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169006
  01202	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169007
  0120e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01213	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01218	41 b9 03 00 00
	00		 mov	 r9d, 3
  0121e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169008
  01225	ba 46 01 00 00	 mov	 edx, 326		; 00000146H
  0122a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169009
  01231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 327  :         return -1;

  01237	b8 ff ff ff ff	 mov	 eax, -1
  0123c	e9 0b 02 00 00	 jmp	 $LN1@shared_ckd
$LN60@shared_ckd:

; 328  :     }
; 329  : 
; 330  :     /* Set flag bit if 3990 controller */
; 331  :     if (dev->ckdcu->devt == 0x3990)

  01241	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01249	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  01250	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  01254	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  01259	75 1f		 jne	 SHORT $LN61@shared_ckd

; 332  :         dev->ckd3990 = 1;

  0125b	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01263	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01269	83 c8 01	 or	 eax, 1
  0126c	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01274	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN61@shared_ckd:

; 333  : 
; 334  :     /* Clear the DPA */
; 335  :     memset(dev->pgid, 0, sizeof(dev->pgid));

  0127a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01282	48 05 ad 05 00
	00		 add	 rax, 1453		; 000005adH
  01288	48 8b f8	 mov	 rdi, rax
  0128b	33 c0		 xor	 eax, eax
  0128d	b9 0b 00 00 00	 mov	 ecx, 11
  01292	f3 aa		 rep stosb

; 336  : 
; 337  :     /* Request the channel to merge data chained write CCWs into
; 338  :        a single buffer before passing data to the device handler */
; 339  :     dev->cdwmerge = 1;

  01294	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0129c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  012a2	0f ba e8 10	 bts	 eax, 16
  012a6	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012ae	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 340  : 
; 341  :     /* Purge the cache */
; 342  :     clientPurge (dev, 0, NULL);

  012b4	45 33 c0	 xor	 r8d, r8d
  012b7	33 d2		 xor	 edx, edx
  012b9	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012c1	e8 00 00 00 00	 call	 clientPurge

; 343  : 
; 344  :     /* Log the device geometry */
; 345  :     if (!dev->batch)

  012c6	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012ce	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  012d4	c1 e8 0a	 shr	 eax, 10
  012d7	83 e0 01	 and	 eax, 1
  012da	85 c0		 test	 eax, eax
  012dc	0f 85 48 01 00
	00		 jne	 $LN62@shared_ckd

; 346  :         // "%1d:%04X Shared: file %s: model %s cyls %d heads %d tracks %d trklen %d"
; 347  :         WRMSG( HHC00708, "I", LCSS_DEVNUM, dev->filename, dev->ckdtab->name,

  012e2	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  012eb	74 15		 je	 SHORT $LN100@shared_ckd
  012ed	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012f5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  012f9	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv671[rsp], eax
  01300	eb 0b		 jmp	 SHORT $LN101@shared_ckd
$LN100@shared_ckd:
  01302	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv671[rsp], 0
$LN101@shared_ckd:
  0130d	48 83 bc 24 90
	05 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01316	74 17		 je	 SHORT $LN102@shared_ckd
  01318	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01320	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01324	d1 f8		 sar	 eax, 1
  01326	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv677[rsp], eax
  0132d	eb 0b		 jmp	 SHORT $LN103@shared_ckd
$LN102@shared_ckd:
  0132f	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv677[rsp], 0
$LN103@shared_ckd:
  0133a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01342	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  01349	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv691[rsp], rax
  01351	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01359	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01360	48 89 8c 24 60
	01 00 00	 mov	 QWORD PTR tv666[rsp], rcx
  01368	b9 01 00 00 00	 mov	 ecx, 1
  0136d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01373	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0137b	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  01381	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  01385	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0138d	8b 89 bc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4796]
  01393	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01397	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0139f	8b 89 c0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4800]
  013a5	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  013a9	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013b1	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  013b7	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  013bb	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv691[rsp]
  013c3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  013c6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  013cb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv666[rsp]
  013d3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  013d8	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv671[rsp]
  013df	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013e3	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv677[rsp]
  013ea	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169012
  013f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169013
  01401	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01406	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0140b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01411	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169014
  01418	ba 5c 01 00 00	 mov	 edx, 348		; 0000015cH
  0141d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169015
  01424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN62@shared_ckd:

; 348  :             dev->ckdcyls, dev->ckdheads, dev->ckdtrks, dev->ckdtrksz );
; 349  : 
; 350  :     dev->connecting = 0;

  0142a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01432	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01438	0f ba f0 08	 btr	 eax, 8
  0143c	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01444	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 351  : 
; 352  :     return 0;

  0144a	33 c0		 xor	 eax, eax
$LN1@shared_ckd:

; 353  : } /* shared_ckd_init */

  0144c	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01454	48 33 cc	 xor	 rcx, rsp
  01457	e8 00 00 00 00	 call	 __security_check_cookie
  0145c	48 81 c4 80 05
	00 00		 add	 rsp, 1408		; 00000580H
  01463	5f		 pop	 rdi
  01464	c3		 ret	 0
shared_ckd_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\shared.c
_TEXT	SEGMENT
i$ = 48
j$ = 52
tv182 = 56
dev$ = 80
block$ = 88
shared_update_notify PROC

; 36   : {

$LN16:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 37   : int      i, j;                          /* Indexes                   */
; 38   : 
; 39   :     /* Return if no remotes are connected */
; 40   :     if (dev->shrdconn == 0)

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00012	83 b8 58 06 00
	00 00		 cmp	 DWORD PTR [rax+1624], 0
  00019	75 07		 jne	 SHORT $LN8@shared_upd

; 41   :         return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 e9 01 00 00	 jmp	 $LN1@shared_upd
$LN8@shared_upd:

; 42   : 
; 43   :     for (i = 0; i < SHARED_MAX_SYS; i++)

  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 0a		 jmp	 SHORT $LN4@shared_upd
$LN2@shared_upd:
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@shared_upd:
  00036	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0003b	0f 8d c8 01 00
	00		 jge	 $LN3@shared_upd

; 44   :     {
; 45   : 
; 46   :         /* Ignore the entry if it doesn't exist or if it's ours
; 47   :            our if it's already maxed out */
; 48   :         if (dev->shrd[i] == NULL || dev->shrd[i]->id == dev->shioactive
; 49   :          || dev->shrd[i]->purgen < 0)

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0004b	48 83 bc c1 60
	06 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1632], 0
  00054	74 39		 je	 SHORT $LN10@shared_upd
  00056	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00060	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0006d	8b 89 e4 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1508]
  00073	39 08		 cmp	 DWORD PTR [rax], ecx
  00075	74 18		 je	 SHORT $LN10@shared_upd
  00077	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00081	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00089	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0008d	7d 02		 jge	 SHORT $LN9@shared_upd
$LN10@shared_upd:

; 50   :             continue;

  0008f	eb 9b		 jmp	 SHORT $LN2@shared_upd
$LN9@shared_upd:

; 51   : 
; 52   :         /* Check if the block is already entered */
; 53   :         for (j = 0; j < dev->shrd[i]->purgen; j++)

  00091	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00099	eb 0a		 jmp	 SHORT $LN7@shared_upd
$LN5@shared_upd:
  0009b	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0009f	ff c0		 inc	 eax
  000a1	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN7@shared_upd:
  000a5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  000b7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000ba	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  000be	7d 35		 jge	 SHORT $LN6@shared_upd

; 54   :             if (fetch_fw(dev->shrd[i]->purge[j]) == (U32)block) break;

  000c0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000ca	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  000d2	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000d7	48 8d 44 88 34	 lea	 rax, QWORD PTR [rax+rcx*4+52]
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 fetch_fw_noswap
  000e4	8b c8		 mov	 ecx, eax
  000e6	e8 00 00 00 00	 call	 _byteswap_ulong
  000eb	3b 44 24 58	 cmp	 eax, DWORD PTR block$[rsp]
  000ef	75 02		 jne	 SHORT $LN11@shared_upd
  000f1	eb 02		 jmp	 SHORT $LN6@shared_upd
$LN11@shared_upd:
  000f3	eb a6		 jmp	 SHORT $LN5@shared_upd
$LN6@shared_upd:

; 55   : 
; 56   :         /* Add the block if it's not already there */
; 57   :         if (j >= dev->shrd[i]->purgen)

  000f5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000ff	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00107	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0010a	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  0010e	0f 8c f0 00 00
	00		 jl	 $LN12@shared_upd

; 58   :         {
; 59   :             if (dev->shrd[i]->purgen >= SHARED_PURGE_MAX)

  00114	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00119	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0011e	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00126	83 78 30 10	 cmp	 DWORD PTR [rax+48], 16
  0012a	7c 1b		 jl	 SHORT $LN13@shared_upd

; 60   :                 dev->shrd[i]->purgen = -1;

  0012c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00136	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  0013e	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [rax+48], -1
  00145	eb 79		 jmp	 SHORT $LN14@shared_upd
$LN13@shared_upd:

; 61   :             else
; 62   :                 store_fw (dev->shrd[i]->purge[dev->shrd[i]->purgen++],

  00147	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0014c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00151	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00159	48 83 c0 34	 add	 rax, 52			; 00000034H
  0015d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00162	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00167	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  0016f	48 63 49 30	 movsxd	 rcx, DWORD PTR [rcx+48]
  00173	48 c1 e1 02	 shl	 rcx, 2
  00177	48 03 c1	 add	 rax, rcx
  0017a	48 89 44 24 38	 mov	 QWORD PTR tv182[rsp], rax
  0017f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00184	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00189	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  00191	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00194	ff c0		 inc	 eax
  00196	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0019b	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  001a0	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  001a8	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  001ab	8b 4c 24 58	 mov	 ecx, DWORD PTR block$[rsp]
  001af	e8 00 00 00 00	 call	 _byteswap_ulong
  001b4	8b d0		 mov	 edx, eax
  001b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv182[rsp]
  001bb	e8 00 00 00 00	 call	 store_fw_noswap
$LN14@shared_upd:

; 63   :                           block);
; 64   :            SHRDTRACE("notify %d added for id=%d, n=%d",

  001c0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	48 8b 84 c1 60
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+1632]
  001d2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  001d7	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  001dc	48 8b 8c ca 60
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+1632]
  001e4	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001e7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001eb	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  001ee	44 8b 44 24 58	 mov	 r8d, DWORD PTR block$[rsp]
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168857
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001ff	e8 00 00 00 00	 call	 shrdtrc
$LN12@shared_upd:

; 65   :                    block, dev->shrd[i]->id, dev->shrd[i]->purgen);
; 66   :         }
; 67   : 
; 68   :     } /* for each possible remote system */

  00204	e9 23 fe ff ff	 jmp	 $LN2@shared_upd
$LN3@shared_upd:

; 69   : 
; 70   :     return 0;

  00209	33 c0		 xor	 eax, eax
$LN1@shared_upd:

; 71   : 
; 72   : } /* shared_update_notify */

  0020b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020f	c3		 ret	 0
shared_update_notify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
s$ = 32
r$ = 40
result$ = 64
string$ = 72
strupper PROC

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     register char *r = result;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 159  :     register char *s = string;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 160  :     for (; *s; r++, s++)

  00022	eb 1a		 jmp	 SHORT $LN4@strupper
$LN2@strupper:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 ff c0	 inc	 rax
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@strupper:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	85 c0		 test	 eax, eax
  00048	74 16		 je	 SHORT $LN3@strupper

; 161  :     {
; 162  :         *r = asciitoupper(*s);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00052	e8 00 00 00 00	 call	 asciitoupper
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$[rsp]
  0005c	88 01		 mov	 BYTE PTR [rcx], al

; 163  :     }

  0005e	eb c4		 jmp	 SHORT $LN2@strupper
$LN3@strupper:

; 164  :     *r = 0;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 165  :     return result;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 166  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
