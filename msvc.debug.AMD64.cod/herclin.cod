; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	hercules_has_exited
_BSS	SEGMENT
hercules_has_exited DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	kb_lock:QWORD
COMM	kb_read_cond:QWORD
COMM	kb_data_cond:QWORD
COMM	kb_tid:DWORD
COMM	cmdbuf:QWORD
COMM	cmd:QWORD
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	log_callback
PUBLIC	kb_thread
PUBLIC	main
EXTRN	strlen:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_impl:PROC
EXTRN	__imp_registerLogCallback:PROC
EXTRN	__imp_getCommandHandler:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_sysblk:BYTE
pdata	SEGMENT
$pdata$log_callback DD imagerel $LN7
	DD	imagerel $LN7+137
	DD	imagerel $unwind$log_callback
$pdata$kb_thread DD imagerel $LN9
	DD	imagerel $LN9+184
	DD	imagerel $unwind$kb_thread
$pdata$main DD	imagerel $LN10
	DD	imagerel $LN10+559
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159078 DB	'herclin.c:73', 00H
	ORG $+3
$SG159079 DB	'herclin.c:78', 00H
	ORG $+3
$SG159080 DB	'herclin.c:79', 00H
	ORG $+3
$SG159081 DB	'herclin.c:81', 00H
	ORG $+3
$SG159098 DB	'herclin.c:131', 00H
	ORG $+2
$SG159099 DB	'&kb_lock', 00H
	ORG $+3
$SG159105 DB	'S', 00H
	ORG $+2
$SG159100 DB	'herclin.c:132', 00H
	ORG $+2
$SG159101 DB	'herclin.c:133', 00H
	ORG $+2
$SG159102 DB	'herclin.c:144', 00H
	ORG $+2
$SG159103 DB	'keyboard thread', 00H
$SG159106 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG159107 DB	'main', 00H
	ORG $+7
$SG159108 DB	'herclin.c', 00H
	ORG $+6
$SG159109 DB	'herclin.c:156', 00H
	ORG $+2
$SG159110 DB	'herclin.c:161', 00H
	ORG $+2
$SG159111 DB	'herclin.c:173', 00H
	ORG $+2
$SG159113 DB	'herclin.c:185', 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$log_callback DD 010e01H
	DD	0420eH
$unwind$kb_thread DD 010901H
	DD	04209H
$unwind$main DD	010d01H
	DD	0c20dH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\herclin.c
_TEXT	SEGMENT
rc$ = 64
tv94 = 72
process_command$ = 80
argc$ = 112
argv$ = 120
main	PROC

; 89   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 90   :     int rc;
; 91   : 
; 92   :     /*****************************************/
; 93   :     /* COMMANDHANDLER is the function type   */
; 94   :     /* of the engine's panel command handler */
; 95   :     /* this MUST be resolved at run time     */
; 96   :     /* since some HDL module might have      */
; 97   :     /* redirected the initial engine function*/
; 98   :     /*****************************************/
; 99   : 
; 100  :     COMMANDHANDLER  process_command;
; 101  : 
; 102  : #if defined( HDL_USE_LIBTOOL )
; 103  :     /* LTDL Preloaded symbols for HDL using libtool */
; 104  :     LTDL_SET_PRELOADED_SYMBOLS();
; 105  : #endif
; 106  : 
; 107  :     /******************************************/
; 108  :     /* Register the 'log_callback' function   */
; 109  :     /* as the log message callback routine    */
; 110  :     /******************************************/
; 111  :     registerLogCallback( log_callback );

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:log_callback
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_registerLogCallback

; 112  : 
; 113  :     /******************************************/
; 114  :     /* Initialize the HERCULE Engine          */
; 115  :     /******************************************/
; 116  :     if ((rc = impl( argc, argv )) == 0)

  0001a	48 8b 54 24 78	 mov	 rdx, QWORD PTR argv$[rsp]
  0001f	8b 4c 24 70	 mov	 ecx, DWORD PTR argc$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_impl
  00029	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  0002d	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00032	0f 85 ee 01 00
	00		 jne	 $LN6@main

; 117  :     {
; 118  :         sysblk.panel_init = 1;

  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00045	83 c8 08	 or	 eax, 8
  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004f	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 119  : 
; 120  :         /******************************************/
; 121  :         /* Get the command handler function       */
; 122  :         /* This MUST be done after IML            */
; 123  :         /******************************************/
; 124  :         process_command = getCommandHandler();

  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getCommandHandler
  0005b	48 89 44 24 50	 mov	 QWORD PTR process_command$[rsp], rax

; 125  : 
; 126  :         /******************************************/
; 127  :         /* Create locks, conditions and buffers   */
; 128  :         /* needed by the keyboard thread...       */
; 129  :         /******************************************/
; 130  : 
; 131  :         initialize_lock( &kb_lock );

  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159098
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159099
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_lock
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 132  :         initialize_condition( &kb_read_cond );

  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159100
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_read_cond
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 133  :         initialize_condition( &kb_data_cond );

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159101
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_data_cond
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 134  : 
; 135  :         cmdbuf = (char*) malloc( CMDBUFSIZ );

  000a3	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR cmdbuf, rax

; 136  : 
; 137  :         /******************************************/
; 138  :         /* Create a worker thread to read from    */
; 139  :         /* the keyboard so we don't block forever */
; 140  :         /* waiting for keyboard during shutdown.  */
; 141  :         /******************************************/
; 142  : 
; 143  :         rc = create_thread( &kb_tid, DETACHED,

  000b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bc	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159102
  000c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159103
  000d5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000da	45 33 c9	 xor	 r9d, r9d
  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:kb_thread
  000e4	48 8b d0	 mov	 rdx, rax
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_tid
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000f4	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 144  :              kb_thread, NULL, HERCLIN_KB_THREAD );
; 145  :         if (rc)

  000f8	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000fd	74 6a		 je	 SHORT $LN7@main

; 146  :         {
; 147  :             // "Error in function create_thread(): %s"
; 148  :             WRMSG( HHC00102, "S", strerror( rc ));

  000ff	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00109	48 89 44 24 48	 mov	 QWORD PTR tv94[rsp], rax
  0010e	b9 01 00 00 00	 mov	 ecx, 1
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00119	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv94[rsp]
  0011e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159105
  0012a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159106
  00136	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	41 b9 03 00 00
	00		 mov	 r9d, 3
  00146	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159107
  0014d	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159108
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :             return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	e9 c1 00 00 00	 jmp	 $LN1@main
$LN7@main:

; 150  :         }
; 151  : 
; 152  :         /******************************************/
; 153  :         /* Read keyboard, pass to Command Handler */
; 154  :         /******************************************/
; 155  : 
; 156  :         obtain_lock( &kb_lock );

  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159109
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_lock
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@main:

; 157  :         {
; 158  :             while (!hercules_has_exited)

  0017d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hercules_has_exited
  00184	85 c0		 test	 eax, eax
  00186	75 6d		 jne	 SHORT $LN3@main

; 159  :             {
; 160  :                 /* Request more keyboard data */
; 161  :                 broadcast_condition( &kb_read_cond );

  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159110
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_read_cond
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN4@main:

; 162  : 
; 163  :                 /* Wait for data to arrive */
; 164  :                 while
; 165  :                 (1
; 166  :                     && !hercules_has_exited
; 167  :                     && timed_wait_condition_relative_usecs

  0019c	33 c0		 xor	 eax, eax
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	74 3a		 je	 SHORT $LN5@main
  001a3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hercules_has_exited
  001aa	85 c0		 test	 eax, eax
  001ac	75 2f		 jne	 SHORT $LN5@main
  001ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159111
  001b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ba	45 33 c9	 xor	 r9d, r9d
  001bd	41 b8 50 c3 00
	00		 mov	 r8d, 50000		; 0000c350H
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:kb_lock
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_data_cond
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  001d7	85 c0		 test	 eax, eax
  001d9	74 02		 je	 SHORT $LN5@main

; 168  :                        (
; 169  :                            &kb_data_cond,
; 170  :                            &kb_lock,
; 171  :                            PANEL_REFRESH_RATE_FAST * 1000,
; 172  :                            NULL
; 173  :                        )
; 174  :                        != 0
; 175  :                 )
; 176  :                 {
; 177  :                     ;  // (do nothing! keep waiting!)
; 178  :                 }

  001db	eb bf		 jmp	 SHORT $LN4@main
$LN5@main:

; 179  : 
; 180  :                 /* Process keyboard data */
; 181  :                 if (!hercules_has_exited)

  001dd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hercules_has_exited
  001e4	85 c0		 test	 eax, eax
  001e6	75 0b		 jne	 SHORT $LN8@main

; 182  :                     process_command( cmd );

  001e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cmd
  001ef	ff 54 24 50	 call	 QWORD PTR process_command$[rsp]
$LN8@main:

; 183  :             }

  001f3	eb 88		 jmp	 SHORT $LN2@main
$LN3@main:

; 184  :         }
; 185  :         release_lock( &kb_lock );

  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159113
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_lock
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 186  : 
; 187  :         sysblk.panel_init = 0;

  00209	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00210	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00216	83 e0 f7	 and	 eax, -9			; fffffff7H
  00219	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00220	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN6@main:

; 188  :     }
; 189  : 
; 190  :     return rc;

  00226	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 191  : }

  0022a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022e	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\herclin.c
_TEXT	SEGMENT
argp$ = 48
kb_thread PROC

; 66   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@kb_thread:

; 67   :     UNREFERENCED( argp );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@kb_thread
$LN5@kb_thread:

; 68   : 
; 69   :     while (1)

  0000f	33 c0		 xor	 eax, eax

; 70   :     {
; 71   :         if ((cmd = fgets( cmdbuf, CMDBUFSIZ, stdin )))

  00011	33 c9		 xor	 ecx, ecx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00019	4c 8b c0	 mov	 r8, rax
  0001c	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cmdbuf
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  0002e	48 89 05 00 00
	00 00		 mov	 QWORD PTR cmd, rax
  00035	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR cmd, 0
  0003d	74 6f		 je	 SHORT $LN7@kb_thread

; 72   :         {
; 73   :             obtain_lock( &kb_lock );

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159078
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_lock
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 74   :             {
; 75   :                 /* (remove newline) */
; 76   :                 cmd[ strlen( cmd ) - 1 ] = 0;

  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cmd
  0005a	e8 00 00 00 00	 call	 strlen
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cmd
  00066	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 77   : 
; 78   :                 broadcast_condition( &kb_data_cond );

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159079
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_data_cond
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 79   :                 wait_condition( &kb_read_cond, &kb_lock );

  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159080
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:kb_lock
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_read_cond
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 80   :             }
; 81   :             release_lock( &kb_lock );

  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159081
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kb_lock
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN7@kb_thread:

; 82   :         }
; 83   :     }

  000ae	e9 5c ff ff ff	 jmp	 $LN5@kb_thread
$LN8@kb_thread:

; 84   : 
; 85   :     UNREACHABLE_CODE( return NULL );
; 86   : }

  000b3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b7	c3		 ret	 0
kb_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\herclin.c
_TEXT	SEGMENT
msg$ = 48
msglen$ = 56
log_callback PROC

; 34   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@log_callba:

; 35   :     UNREFERENCED( msg );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@log_callba

; 36   : 
; 37   :     if (!msglen)

  00014	48 83 7c 24 38
	00		 cmp	 QWORD PTR msglen$[rsp], 0
  0001a	75 09		 jne	 SHORT $LN5@log_callba

; 38   :     {
; 39   :         hercules_has_exited = true;

  0001c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR hercules_has_exited, 1

; 40   :         return;

  00023	eb 5f		 jmp	 SHORT $LN1@log_callba
$LN5@log_callba:

; 41   :     }
; 42   : 
; 43   :     fflush( stdout );

  00025	b9 01 00 00 00	 mov	 ecx, 1
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00030	48 8b c8	 mov	 rcx, rax
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 44   :     fwrite( msg, 1, msglen, stdout );

  00039	b9 01 00 00 00	 mov	 ecx, 1
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00044	4c 8b c8	 mov	 r9, rax
  00047	4c 8b 44 24 38	 mov	 r8, QWORD PTR msglen$[rsp]
  0004c	ba 01 00 00 00	 mov	 edx, 1
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR msg$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite

; 45   :     fflush( stdout );

  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	48 8b c8	 mov	 rcx, rax
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 46   :     fflush( stderr );

  00070	b9 02 00 00 00	 mov	 ecx, 2
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN1@log_callba:

; 47   : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
log_callback ENDP
_TEXT	ENDS
END
