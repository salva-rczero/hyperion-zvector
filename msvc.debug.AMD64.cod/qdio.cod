; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_fw_noswap
PUBLIC	s390_signal_adapter
PUBLIC	z900_signal_adapter
PUBLIC	z900_set_queue_buffer_state
PUBLIC	z900_extract_queue_buffer_state
PUBLIC	z900_set_vector_summary
PUBLIC	z900_maddr_l
PUBLIC	z900_vstoreb
PUBLIC	z900_vfetchb
EXTRN	_byteswap_ulong:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	find_device_by_subchan:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__imp_pttclass:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$s390_signal_adapter DD imagerel $LN56
	DD	imagerel $LN56+2092
	DD	imagerel $unwind$s390_signal_adapter
$pdata$z900_signal_adapter DD imagerel $LN66
	DD	imagerel $LN66+2407
	DD	imagerel $unwind$z900_signal_adapter
$pdata$z900_set_queue_buffer_state DD imagerel $LN46
	DD	imagerel $LN46+1719
	DD	imagerel $unwind$z900_set_queue_buffer_state
$pdata$z900_extract_queue_buffer_state DD imagerel $LN41
	DD	imagerel $LN41+1484
	DD	imagerel $unwind$z900_extract_queue_buffer_state
$pdata$z900_set_vector_summary DD imagerel $LN21
	DD	imagerel $LN21+384
	DD	imagerel $unwind$z900_set_vector_summary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_vfetchb
pdata	ENDS
_DATA	SEGMENT
$SG179646 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:50', 00H
	ORG $+3
$SG179647 DB	'SIGA', 00H
	ORG $+7
$SG179654 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:80', 00H
	ORG $+3
$SG179655 DB	'*SIGA', 00H
	ORG $+6
$SG179656 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:89', 00H
	ORG $+7
$SG179659 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:94', 00H
	ORG $+3
$SG179660 DB	'*SIGA', 00H
	ORG $+6
$SG179661 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:95', 00H
	ORG $+7
$SG179666 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:111', 00H
	ORG $+2
$SG179667 DB	'*SIGA', 00H
	ORG $+6
$SG179672 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:121', 00H
	ORG $+2
$SG179673 DB	'*SIGA', 00H
	ORG $+6
$SG179678 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:132', 00H
	ORG $+2
$SG179679 DB	'*SIGA', 00H
	ORG $+6
$SG179682 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:155', 00H
	ORG $+2
$SG179683 DB	'*SIGA', 00H
	ORG $+6
$SG179684 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:159', 00H
	ORG $+6
$SG192709 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:42', 00H
	ORG $+7
$SG192713 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:50', 00H
	ORG $+3
$SG192714 DB	'SIGA', 00H
	ORG $+7
$SG192723 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:80', 00H
	ORG $+3
$SG192724 DB	'*SIGA', 00H
	ORG $+6
$SG192725 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:89', 00H
	ORG $+7
$SG192728 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:94', 00H
	ORG $+3
$SG192729 DB	'*SIGA', 00H
	ORG $+6
$SG192730 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:95', 00H
	ORG $+7
$SG192735 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:111', 00H
	ORG $+2
$SG192736 DB	'*SIGA', 00H
	ORG $+6
$SG192741 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:121', 00H
	ORG $+2
$SG192742 DB	'*SIGA', 00H
	ORG $+6
$SG192747 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:132', 00H
	ORG $+2
$SG192748 DB	'*SIGA', 00H
	ORG $+6
$SG192751 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:155', 00H
	ORG $+2
$SG192752 DB	'*SIGA', 00H
	ORG $+6
$SG192753 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:159', 00H
	ORG $+6
$SG192831 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:188', 00H
	ORG $+6
$SG192835 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:196', 00H
	ORG $+2
$SG192836 DB	'SQBS', 00H
	ORG $+7
$SG192840 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:207', 00H
	ORG $+2
$SG192841 DB	'*SQBS', 00H
	ORG $+6
$SG192921 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:282', 00H
	ORG $+6
$SG192925 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:290', 00H
	ORG $+2
$SG192926 DB	'EQBS', 00H
	ORG $+7
$SG192930 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:301', 00H
	ORG $+2
$SG192931 DB	'*EQBS', 00H
	ORG $+6
$SG192960 DB	'C:\papa\MyGit\hyperion-zvector\qdio.c:376', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchb DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
xdata	SEGMENT
$unwind$s390_signal_adapter DD 021101H
	DD	0110111H
$unwind$z900_signal_adapter DD 021101H
	DD	0110111H
$unwind$z900_set_queue_buffer_state DD 021101H
	DD	0150111H
$unwind$z900_extract_queue_buffer_state DD 021101H
	DD	0150111H
$unwind$z900_set_vector_summary DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
z900_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qdio.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
tv143 = 40
r2$ = 44
inst$ = 64
regs$ = 72
z900_set_vector_summary PROC

; 372  : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 373  : int     r1, r2;                /* Register numbers                   */
; 374  : 
; 375  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_set_v:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN13@z900_set_v
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN13@z900_set_v:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_set_v
$LN7@z900_set_v:

; 376  :     TXF_INSTR_CHECK( regs );

  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN14@z900_set_v
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0c	 bts	 eax, 12
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192960
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN14@z900_set_v:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_set_v

; 377  :     PRIV_CHECK(regs);

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000c1	83 e0 01	 and	 eax, 1
  000c4	85 c0		 test	 eax, eax
  000c6	74 15		 je	 SHORT $LN15@z900_set_v
  000c8	ba 02 00 00 00	 mov	 edx, 2
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_set_v:
$LN10@z900_set_v:

; 378  :     SIE_INTERCEPT(regs);

  000dd	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e8	d1 e8		 shr	 eax, 1
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	74 18		 je	 SHORT $LN16@z900_set_v
  000f1	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000fc	ba fc ff ff ff	 mov	 edx, -4
  00101	48 8b c8	 mov	 rcx, rax
  00104	e8 00 00 00 00	 call	 longjmp
$LN16@z900_set_v:
  00109	33 c0		 xor	 eax, eax
  0010b	85 c0		 test	 eax, eax
  0010d	75 ce		 jne	 SHORT $LN10@z900_set_v

; 379  :     ODD_CHECK(r1, regs);

  0010f	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00113	83 e0 01	 and	 eax, 1
  00116	85 c0		 test	 eax, eax
  00118	74 15		 je	 SHORT $LN17@z900_set_v
  0011a	ba 06 00 00 00	 mov	 edx, 6
  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00129	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_set_v:

; 380  : 
; 381  :     switch(regs->GR_L(1)) {

  0012f	b8 08 00 00 00	 mov	 eax, 8
  00134	48 6b c0 01	 imul	 rax, rax, 1
  00138	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00144	89 44 24 28	 mov	 DWORD PTR tv143[rsp], eax
  00148	83 7c 24 28 03	 cmp	 DWORD PTR tv143[rsp], 3
  0014d	74 02		 je	 SHORT $LN18@z900_set_v
  0014f	eb 1b		 jmp	 SHORT $LN19@z900_set_v
$LN18@z900_set_v:

; 382  : 
; 383  :         case 3:   // Clear Global Summary
; 384  :             regs->GR(r1+1) = 0;

  00151	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00155	ff c0		 inc	 eax
  00157	48 98		 cdqe
  00159	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 c7 84 c1 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+640], 0

; 385  :             break;

  0016a	eb 0f		 jmp	 SHORT $LN11@z900_set_v
$LN19@z900_set_v:

; 386  : 
; 387  :         default:
; 388  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0016c	ba 06 00 00 00	 mov	 edx, 6
  00171	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_set_v:
$LN20@z900_set_v:

; 389  :      }
; 390  : }

  0017b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017f	c3		 ret	 0
z900_set_vector_summary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qdio.c
_TEXT	SEGMENT
nextstate$ = 64
state$ = 65
bidx$ = 68
count$ = 72
dev$ = 80
temp$1 = 88
qidx$ = 92
r1$ = 96
r3$ = 100
tv244 = 104
r2$ = 108
tv308 = 112
queues$ = 116
autoack$ = 120
slsba$ = 128
effective_addr2$ = 136
m4$ = 144
tv278 = 148
inst$ = 176
regs$ = 184
z900_extract_queue_buffer_state PROC

; 263  : {

$LN41:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 264  : int     r1, r2, r3, m4;       /* Register numbers                    */
; 265  : VADR    effective_addr2 = 0;  /* effective address                   */

  00011	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR effective_addr2$[rsp], 0

; 266  : 
; 267  : DEVBLK  *dev;                 /* Data device DEVBLK                  */
; 268  : 
; 269  : int     autoack;              /* Flag for auto-acknowkledgement      */
; 270  : BYTE    state;                /* State extracted from first buffer   */
; 271  : BYTE    nextstate;            /*    next buffer                      */
; 272  : U32     queues;               /* Total number of queues              */
; 273  : U32     count;                /* Number of buffers to set            */
; 274  : U32     qidx;                 /* Queue index                         */
; 275  : U32     bidx;                 /* SLSB buffer state index             */
; 276  : U64     slsba;                /* Storage list state block address    */
; 277  : 
; 278  :     RRF_RM(inst, regs, r1, r2, r3, m4);

  0001d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 6c	 mov	 DWORD PTR r2$[rsp], eax
  00040	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	c1 e8 04	 shr	 eax, 4
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 60	 mov	 DWORD PTR r1$[rsp], eax
  0004e	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00052	c1 e8 08	 shr	 eax, 8
  00055	83 e0 0f	 and	 eax, 15
  00058	89 84 24 90 00
	00 00		 mov	 DWORD PTR m4$[rsp], eax
  0005f	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00063	c1 e8 0c	 shr	 eax, 12
  00066	83 e0 0f	 and	 eax, 15
  00069	89 44 24 64	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_extra:
  0006d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00079	48 83 c0 04	 add	 rax, 4
  0007d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00089	33 c0		 xor	 eax, eax
  0008b	83 f8 04	 cmp	 eax, 4
  0008e	74 0f		 je	 SHORT $LN21@z900_extra
  00090	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00098	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN21@z900_extra:
  0009f	33 c0		 xor	 eax, eax
  000a1	85 c0		 test	 eax, eax
  000a3	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 279  : 
; 280  : //  ARCH_DEP(display_inst) (regs, inst);
; 281  :     FACILITY_CHECK( HERC_QEBSM, regs );

  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  000ae	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  000be	83 e0 08	 and	 eax, 8
  000c1	85 c0		 test	 eax, eax
  000c3	75 1b		 jne	 SHORT $LN22@z900_extra
  000c5	ba 01 00 00 00	 mov	 edx, 1
  000ca	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN22@z900_extra:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 bf		 jne	 SHORT $LN7@z900_extra
$LN10@z900_extra:

; 282  :     TXF_INSTR_CHECK( regs );

  000e6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000f5	85 c0		 test	 eax, eax
  000f7	74 3f		 je	 SHORT $LN23@z900_extra
  000f9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00107	0f ba e8 0c	 bts	 eax, 12
  0010b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00119	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192921
  00120	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00126	ba 02 00 00 00	 mov	 edx, 2
  0012b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	e8 00 00 00 00	 call	 z900_abort_transaction
$LN23@z900_extra:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	75 a8		 jne	 SHORT $LN10@z900_extra

; 283  :     PRIV_CHECK(regs);

  0013e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00146	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 1b		 je	 SHORT $LN24@z900_extra
  00151	ba 02 00 00 00	 mov	 edx, 2
  00156	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@z900_extra:

; 284  : 
; 285  : #if defined(_FEATURE_SIE)
; 286  :     if(SIE_STATE_BIT_OFF(regs, EC3, SIGA))

  0016c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017a	d1 e8		 shr	 eax, 1
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 3f		 je	 SHORT $LN25@z900_extra
  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00192	b9 01 00 00 00	 mov	 ecx, 1
  00197	48 6b c9 03	 imul	 rcx, rcx, 3
  0019b	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001a0	83 e0 04	 and	 eax, 4
  001a3	85 c0		 test	 eax, eax
  001a5	75 1b		 jne	 SHORT $LN25@z900_extra

; 287  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  001a7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001b5	ba fc ff ff ff	 mov	 edx, -4
  001ba	48 8b c8	 mov	 rcx, rax
  001bd	e8 00 00 00 00	 call	 longjmp
$LN25@z900_extra:
$LN13@z900_extra:

; 288  : #endif /*defined(_FEATURE_SIE)*/
; 289  : 
; 290  :     PTIO(INF,"EQBS");

  001c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cc	48 83 e0 08	 and	 rax, 8
  001d0	48 85 c0	 test	 rax, rax
  001d3	74 6e		 je	 SHORT $LN26@z900_extra
  001d5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001e3	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001e8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001f0	48 23 d1	 and	 rdx, rcx
  001f3	48 8b ca	 mov	 rcx, rdx
  001f6	8b c9		 mov	 ecx, ecx
  001f8	ba 08 00 00 00	 mov	 edx, 8
  001fd	48 6b d2 01	 imul	 rdx, rdx, 1
  00201	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00209	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00211	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192925
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	44 8b c9	 mov	 r9d, ecx
  0022e	44 8b c2	 mov	 r8d, edx
  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192926
  00238	b9 08 00 00 00	 mov	 ecx, 8
  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@z900_extra:
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	0f 85 75 ff ff
	ff		 jne	 $LN13@z900_extra

; 291  : 
; 292  :     dev = find_device_by_subchan(TKN2IOID(regs->GR_G(1)));

  0024d	b8 08 00 00 00	 mov	 eax, 8
  00252	48 6b c0 01	 imul	 rax, rax, 1
  00256	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00266	48 f7 d0	 not	 rax
  00269	8b c8		 mov	 ecx, eax
  0026b	e8 00 00 00 00	 call	 find_device_by_subchan
  00270	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 293  : 
; 294  :     /* Condition code 3 if subchannel does not exist,
; 295  :        is not valid, or is not enabled or is not a QDIO subchannel */
; 296  :     if (dev == NULL
; 297  :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 298  :         || (dev->pmcw.flag5 & PMCW5_E) == 0
; 299  :         || (dev->pmcw.flag4 & PMCW4_Q) == 0)

  00275	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0027b	74 41		 je	 SHORT $LN28@z900_extra
  0027d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00282	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 2e		 je	 SHORT $LN28@z900_extra
  00290	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00295	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0029c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002a1	85 c0		 test	 eax, eax
  002a3	74 19		 je	 SHORT $LN28@z900_extra
  002a5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002aa	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  002b1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002b6	85 c0		 test	 eax, eax
  002b8	0f 85 9c 00 00
	00		 jne	 $LN27@z900_extra
$LN28@z900_extra:
$LN16@z900_extra:

; 300  :     {
; 301  :         PTIO(ERR,"*EQBS");

  002be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c8	48 83 e0 10	 and	 rax, 16
  002cc	48 85 c0	 test	 rax, rax
  002cf	74 6e		 je	 SHORT $LN29@z900_extra
  002d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002df	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  002e4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002ec	48 23 d1	 and	 rdx, rcx
  002ef	48 8b ca	 mov	 rcx, rdx
  002f2	8b c9		 mov	 ecx, ecx
  002f4	ba 08 00 00 00	 mov	 edx, 8
  002f9	48 6b d2 01	 imul	 rdx, rdx, 1
  002fd	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00305	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0030d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00316	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0031b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192930
  00322	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00327	44 8b c9	 mov	 r9d, ecx
  0032a	44 8b c2	 mov	 r8d, edx
  0032d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192931
  00334	b9 10 00 00 00	 mov	 ecx, 16
  00339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@z900_extra:
  0033f	33 c0		 xor	 eax, eax
  00341	85 c0		 test	 eax, eax
  00343	0f 85 75 ff ff
	ff		 jne	 $LN16@z900_extra

; 302  : #if defined(_FEATURE_QUEUED_DIRECT_IO_ASSIST)
; 303  :         SIE_INTERCEPT(regs);
; 304  : #endif
; 305  :         regs->psw.cc = 2;

  00349	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00351	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 306  :         return;

  00355	e9 6a 02 00 00	 jmp	 $LN1@z900_extra
$LN27@z900_extra:

; 307  :     }
; 308  : 
; 309  : #if 0
; 310  :     /* Check that device is QDIO active */
; 311  :     if ((dev->scsw.flag2 & SCSW2_Q) == 0)
; 312  :     {
; 313  :         PTIO(ERR,"*EQBS");
; 314  :         regs->psw.cc = 2;
; 315  :         return;
; 316  :     }
; 317  : #endif
; 318  : 
; 319  :     qidx  = regs->GR_H(r1);                           /* Queue index */

  0035a	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	8b 84 c1 84 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+644]
  0036e	89 44 24 5c	 mov	 DWORD PTR qidx$[rsp], eax

; 320  :     bidx  = regs->GR_L(r1);                          /* Buffer index */

  00372	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00377	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00386	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax

; 321  :     autoack = (regs->GR_H(r2) & 0x80000000);

  0038a	48 63 44 24 6c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0038f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00397	8b 84 c1 84 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+644]
  0039e	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a3	89 44 24 78	 mov	 DWORD PTR autoack$[rsp], eax

; 322  :     count = regs->GR_L(r3) < 128 ? regs->GR_L(r3) : 128; /* Number of buffers */

  003a7	48 63 44 24 64	 movsxd	 rax, DWORD PTR r3$[rsp]
  003ac	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	81 bc c1 80 02
	00 00 80 00 00
	00		 cmp	 DWORD PTR [rcx+rax*8+640], 128 ; 00000080H
  003bf	73 1a		 jae	 SHORT $LN37@z900_extra
  003c1	48 63 44 24 64	 movsxd	 rax, DWORD PTR r3$[rsp]
  003c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003d5	89 44 24 68	 mov	 DWORD PTR tv244[rsp], eax
  003d9	eb 08		 jmp	 SHORT $LN38@z900_extra
$LN37@z900_extra:
  003db	c7 44 24 68 80
	00 00 00	 mov	 DWORD PTR tv244[rsp], 128 ; 00000080H
$LN38@z900_extra:
  003e3	8b 44 24 68	 mov	 eax, DWORD PTR tv244[rsp]
  003e7	89 44 24 48	 mov	 DWORD PTR count$[rsp], eax

; 323  : 
; 324  :     queues = (U32)(dev->qdio.i_qcnt + dev->qdio.o_qcnt);

  003eb	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003f0	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  003f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  003fb	03 81 c4 13 00
	00		 add	 eax, DWORD PTR [rcx+5060]
  00401	89 44 24 74	 mov	 DWORD PTR queues$[rsp], eax

; 325  : 
; 326  :     if ( (qidx >= queues) || (bidx > 127) )

  00405	8b 44 24 74	 mov	 eax, DWORD PTR queues$[rsp]
  00409	39 44 24 5c	 cmp	 DWORD PTR qidx$[rsp], eax
  0040d	73 07		 jae	 SHORT $LN31@z900_extra
  0040f	83 7c 24 44 7f	 cmp	 DWORD PTR bidx$[rsp], 127 ; 0000007fH
  00414	76 12		 jbe	 SHORT $LN30@z900_extra
$LN31@z900_extra:

; 327  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00416	ba 06 00 00 00	 mov	 edx, 6
  0041b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00423	e8 00 00 00 00	 call	 z900_program_interrupt
$LN30@z900_extra:

; 328  : 
; 329  :     if (qidx < (U32)dev->qdio.i_qcnt)

  00428	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0042d	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00433	39 44 24 5c	 cmp	 DWORD PTR qidx$[rsp], eax
  00437	73 1b		 jae	 SHORT $LN32@z900_extra

; 330  :         slsba = dev->qdio.i_slsbla[qidx];

  00439	8b 44 24 5c	 mov	 eax, DWORD PTR qidx$[rsp]
  0043d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00442	48 8b 84 c1 d8
	16 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+5848]
  0044a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR slsba$[rsp], rax
  00452	eb 2a		 jmp	 SHORT $LN33@z900_extra
$LN32@z900_extra:

; 331  :     else
; 332  :         slsba = dev->qdio.o_slsbla[qidx - dev->qdio.i_qcnt];

  00454	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00459	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  0045f	8b 4c 24 5c	 mov	 ecx, DWORD PTR qidx$[rsp]
  00463	2b c8		 sub	 ecx, eax
  00465	8b c1		 mov	 eax, ecx
  00467	8b c0		 mov	 eax, eax
  00469	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0046e	48 8b 84 c1 58
	1a 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+6744]
  00476	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR slsba$[rsp], rax
$LN33@z900_extra:

; 333  : 
; 334  :     state = nextstate = ARCH_DEP(wfetchb)((VADR)(slsba+bidx), USE_REAL_ADDR, regs);

  0047e	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  00482	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR slsba$[rsp]
  0048a	48 03 c8	 add	 rcx, rax
  0048d	48 8b c1	 mov	 rax, rcx
  00490	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00498	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0049f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004a7	ba fe ff ff ff	 mov	 edx, -2
  004ac	48 8b c8	 mov	 rcx, rax
  004af	e8 00 00 00 00	 call	 z900_vfetchb
  004b4	88 44 24 40	 mov	 BYTE PTR nextstate$[rsp], al
  004b8	0f b6 44 24 40	 movzx	 eax, BYTE PTR nextstate$[rsp]
  004bd	88 44 24 41	 mov	 BYTE PTR state$[rsp], al
$LN17@z900_extra:

; 335  : 
; 336  :     while(count && state == nextstate)

  004c1	83 7c 24 48 00	 cmp	 DWORD PTR count$[rsp], 0
  004c6	0f 84 86 00 00
	00		 je	 $LN18@z900_extra
  004cc	0f b6 44 24 41	 movzx	 eax, BYTE PTR state$[rsp]
  004d1	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR nextstate$[rsp]
  004d6	3b c1		 cmp	 eax, ecx
  004d8	75 78		 jne	 SHORT $LN18@z900_extra

; 337  :     {
; 338  :         if (autoack)

  004da	83 7c 24 78 00	 cmp	 DWORD PTR autoack$[rsp], 0
  004df	74 0c		 je	 SHORT $LN34@z900_extra

; 339  :             switch(nextstate) {

  004e1	0f b6 44 24 40	 movzx	 eax, BYTE PTR nextstate$[rsp]
  004e6	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv278[rsp], eax
$LN34@z900_extra:

; 340  : 
; 341  : #if 0
; 342  :                 case SLSBE_INPUT_COMPLETED:
; 343  :                     ARCH_DEP(wstoreb)
; 344  :                         (SLSBE_INPUT_ACKED, (VADR)(slsba+bidx), USE_REAL_ADDR, regs);
; 345  :                     break;
; 346  :                 case SLSBE_OUTPUT_COMPLETED:
; 347  :                     ARCH_DEP(wstoreb)
; 348  :                         (SLSBE_OUTPUT_PRIMED, (VADR)(slsba+bidx), USE_REAL_ADDR, regs);
; 349  :                     break;
; 350  : #endif
; 351  :             }
; 352  : 
; 353  :         bidx++; bidx &= 0x7F;              /* Advance and wrap index */

  004ed	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  004f1	ff c0		 inc	 eax
  004f3	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax
  004f7	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  004fb	83 e0 7f	 and	 eax, 127		; 0000007fH
  004fe	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax

; 354  :         count--;

  00502	8b 44 24 48	 mov	 eax, DWORD PTR count$[rsp]
  00506	ff c8		 dec	 eax
  00508	89 44 24 48	 mov	 DWORD PTR count$[rsp], eax

; 355  : 
; 356  :         if(count)

  0050c	83 7c 24 48 00	 cmp	 DWORD PTR count$[rsp], 0
  00511	74 3a		 je	 SHORT $LN35@z900_extra

; 357  :             nextstate = ARCH_DEP(wfetchb)((VADR)(slsba+bidx), USE_REAL_ADDR, regs);

  00513	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  00517	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR slsba$[rsp]
  0051f	48 03 c8	 add	 rcx, rax
  00522	48 8b c1	 mov	 rax, rcx
  00525	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00534	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0053c	ba fe ff ff ff	 mov	 edx, -2
  00541	48 8b c8	 mov	 rcx, rax
  00544	e8 00 00 00 00	 call	 z900_vfetchb
  00549	88 44 24 40	 mov	 BYTE PTR nextstate$[rsp], al
$LN35@z900_extra:

; 358  :     }

  0054d	e9 6f ff ff ff	 jmp	 $LN17@z900_extra
$LN18@z900_extra:

; 359  : 
; 360  :     regs->GR_L(r1) = bidx;

  00552	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  00557	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055f	8b 54 24 44	 mov	 edx, DWORD PTR bidx$[rsp]
  00563	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 361  :     regs->GR_LHLCL(r2) = state;

  0056a	48 63 44 24 6c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0056f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00577	0f b6 54 24 41	 movzx	 edx, BYTE PTR state$[rsp]
  0057c	88 94 c1 80 02
	00 00		 mov	 BYTE PTR [rcx+rax*8+640], dl

; 362  :     regs->GR_L(r3) = count;

  00583	48 63 44 24 64	 movsxd	 rax, DWORD PTR r3$[rsp]
  00588	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00590	8b 54 24 48	 mov	 edx, DWORD PTR count$[rsp]
  00594	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 363  :     regs->psw.cc = count ? 1 : 0;

  0059b	83 7c 24 48 00	 cmp	 DWORD PTR count$[rsp], 0
  005a0	74 0a		 je	 SHORT $LN39@z900_extra
  005a2	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv308[rsp], 1
  005aa	eb 08		 jmp	 SHORT $LN40@z900_extra
$LN39@z900_extra:
  005ac	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv308[rsp], 0
$LN40@z900_extra:
  005b4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bc	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR tv308[rsp]
  005c1	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN1@z900_extra:
$LN36@z900_extra:

; 364  : }

  005c4	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005cb	c3		 ret	 0
z900_extract_queue_buffer_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qdio.c
_TEXT	SEGMENT
nextstate$ = 64
bidx$ = 68
oldstate$ = 72
state$ = 73
disp2$1 = 76
count$ = 80
dev$ = 88
temp$2 = 96
qidx$ = 100
effective_addr2$ = 104
r1$ = 112
r3$ = 116
b2$ = 120
tv92 = 124
tv270 = 128
tv336 = 132
slsba$ = 136
queues$ = 144
inst$ = 176
regs$ = 184
z900_set_queue_buffer_state PROC

; 168  : {

$LN46:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 169  : int     r1, r3;                /* Register numbers                   */
; 170  : int     b2;                    /* effective address base             */
; 171  : VADR    effective_addr2;       /* effective address                  */
; 172  : 
; 173  : DEVBLK  *dev;                  /* Data device DEVBLK                 */
; 174  : 
; 175  : BYTE    state;                 /* Target buffer state                */
; 176  : BYTE    oldstate;              /* Current buffer state               */
; 177  : BYTE    nextstate;             /* Next buffer's state                */
; 178  : U32     queues;                /* Total number of queues             */
; 179  : U32     count;                 /* Number of buffers to set           */
; 180  : U32     qidx;                  /* Queue index                        */
; 181  : U32     bidx;                  /* SLSB buffer state index            */
; 182  : U64     slsba;                 /* Storage list state block address   */
; 183  : 
; 184  :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  00011	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 60	 mov	 DWORD PTR temp$2[rsp], eax
  00029	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  00032	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 4c	 mov	 DWORD PTR disp2$1[rsp], eax
  0003f	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 78	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 74	 mov	 DWORD PTR r3$[rsp], eax
  0005b	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 70	 mov	 DWORD PTR r1$[rsp], eax
  00069	83 7c 24 78 00	 cmp	 DWORD PTR b2$[rsp], 0
  0006e	74 25		 je	 SHORT $LN19@z900_set_q
  00070	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  00075	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN19@z900_set_q:
  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	48 6b c0 04	 imul	 rax, rax, 4
  0009e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000aa	85 c0		 test	 eax, eax
  000ac	74 0a		 je	 SHORT $LN40@z900_set_q
  000ae	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b6	eb 08		 jmp	 SHORT $LN41@z900_set_q
$LN40@z900_set_q:
  000b8	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN41@z900_set_q:
  000c0	83 7c 24 7c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c5	74 3e		 je	 SHORT $LN20@z900_set_q
  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	48 6b c0 04	 imul	 rax, rax, 4
  000d0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000dc	c1 e0 0c	 shl	 eax, 12
  000df	8b 4c 24 4c	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000e3	0b c8		 or	 ecx, eax
  000e5	8b c1		 mov	 eax, ecx
  000e7	89 44 24 4c	 mov	 DWORD PTR disp2$1[rsp], eax
  000eb	8b 44 24 4c	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ef	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000f4	85 c0		 test	 eax, eax
  000f6	74 0d		 je	 SHORT $LN21@z900_set_q
  000f8	8b 44 24 4c	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fc	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00101	89 44 24 4c	 mov	 DWORD PTR disp2$1[rsp], eax
$LN21@z900_set_q:
$LN20@z900_set_q:
  00105	48 63 44 24 4c	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  0010a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0010f	48 03 c8	 add	 rcx, rax
  00112	48 8b c1	 mov	 rax, rcx
  00115	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0011a	33 c0		 xor	 eax, eax
  0011c	83 f8 06	 cmp	 eax, 6
  0011f	74 1f		 je	 SHORT $LN22@z900_set_q
  00121	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00129	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00130	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00135	48 23 c8	 and	 rcx, rax
  00138	48 8b c1	 mov	 rax, rcx
  0013b	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN22@z900_set_q:
$LN4@z900_set_q:
  00140	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00148	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014c	48 83 c0 06	 add	 rax, 6
  00150	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0015c	33 c0		 xor	 eax, eax
  0015e	83 f8 06	 cmp	 eax, 6
  00161	74 0f		 je	 SHORT $LN23@z900_set_q
  00163	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN23@z900_set_q:
  00172	33 c0		 xor	 eax, eax
  00174	85 c0		 test	 eax, eax
  00176	75 c8		 jne	 SHORT $LN4@z900_set_q
$LN7@z900_set_q:

; 185  : 
; 186  : //  ARCH_DEP(display_inst) (regs, inst);
; 187  :     FACILITY_CHECK( HERC_QEBSM, regs );

  00178	b8 01 00 00 00	 mov	 eax, 1
  0017d	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00181	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00191	83 e0 08	 and	 eax, 8
  00194	85 c0		 test	 eax, eax
  00196	75 1b		 jne	 SHORT $LN24@z900_set_q
  00198	ba 01 00 00 00	 mov	 edx, 1
  0019d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ad	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@z900_set_q:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	75 bf		 jne	 SHORT $LN7@z900_set_q
$LN10@z900_set_q:

; 188  :     TXF_INSTR_CHECK( regs );

  001b9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001c8	85 c0		 test	 eax, eax
  001ca	74 3f		 je	 SHORT $LN25@z900_set_q
  001cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001da	0f ba e8 0c	 bts	 eax, 12
  001de	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192831
  001f3	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001f9	ba 02 00 00 00	 mov	 edx, 2
  001fe	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00206	e8 00 00 00 00	 call	 z900_abort_transaction
$LN25@z900_set_q:
  0020b	33 c0		 xor	 eax, eax
  0020d	85 c0		 test	 eax, eax
  0020f	75 a8		 jne	 SHORT $LN10@z900_set_q

; 189  :     PRIV_CHECK(regs);

  00211	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0021d	83 e0 01	 and	 eax, 1
  00220	85 c0		 test	 eax, eax
  00222	74 1b		 je	 SHORT $LN26@z900_set_q
  00224	ba 02 00 00 00	 mov	 edx, 2
  00229	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00239	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@z900_set_q:

; 190  : 
; 191  : #if defined(_FEATURE_SIE)
; 192  :     if(SIE_STATE_BIT_OFF(regs, EC3, SIGA))

  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0024d	d1 e8		 shr	 eax, 1
  0024f	83 e0 01	 and	 eax, 1
  00252	85 c0		 test	 eax, eax
  00254	74 3f		 je	 SHORT $LN27@z900_set_q
  00256	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00265	b9 01 00 00 00	 mov	 ecx, 1
  0026a	48 6b c9 03	 imul	 rcx, rcx, 3
  0026e	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00273	83 e0 04	 and	 eax, 4
  00276	85 c0		 test	 eax, eax
  00278	75 1b		 jne	 SHORT $LN27@z900_set_q

; 193  :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0027a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00282	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00288	ba fc ff ff ff	 mov	 edx, -4
  0028d	48 8b c8	 mov	 rcx, rax
  00290	e8 00 00 00 00	 call	 longjmp
$LN27@z900_set_q:
$LN13@z900_set_q:

; 194  : #endif /*defined(_FEATURE_SIE)*/
; 195  : 
; 196  :     PTIO(INF,"SQBS");

  00295	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0029c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0029f	48 83 e0 08	 and	 rax, 8
  002a3	48 85 c0	 test	 rax, rax
  002a6	74 6b		 je	 SHORT $LN28@z900_set_q
  002a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b0	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002b6	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  002bb	48 8b 54 24 68	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002c0	48 23 d1	 and	 rdx, rcx
  002c3	48 8b ca	 mov	 rcx, rdx
  002c6	8b c9		 mov	 ecx, ecx
  002c8	ba 08 00 00 00	 mov	 edx, 8
  002cd	48 6b d2 01	 imul	 rdx, rdx, 1
  002d1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d9	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192835
  002f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fb	44 8b c9	 mov	 r9d, ecx
  002fe	44 8b c2	 mov	 r8d, edx
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192836
  00308	b9 08 00 00 00	 mov	 ecx, 8
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_set_q:
  00313	33 c0		 xor	 eax, eax
  00315	85 c0		 test	 eax, eax
  00317	0f 85 78 ff ff
	ff		 jne	 $LN13@z900_set_q

; 197  : 
; 198  :     dev = find_device_by_subchan(TKN2IOID(regs->GR_G(1)));

  0031d	b8 08 00 00 00	 mov	 eax, 8
  00322	48 6b c0 01	 imul	 rax, rax, 1
  00326	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032e	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00336	48 f7 d0	 not	 rax
  00339	8b c8		 mov	 ecx, eax
  0033b	e8 00 00 00 00	 call	 find_device_by_subchan
  00340	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 199  : 
; 200  :     /* Condition code 3 if subchannel does not exist,
; 201  :        is not valid, or is not enabled or is not a QDIO subchannel */
; 202  :     if (dev == NULL
; 203  :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 204  :         || (dev->pmcw.flag5 & PMCW5_E) == 0
; 205  :         || (dev->pmcw.flag4 & PMCW4_Q) == 0)

  00345	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0034b	74 41		 je	 SHORT $LN30@z900_set_q
  0034d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00352	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00359	83 e0 01	 and	 eax, 1
  0035c	85 c0		 test	 eax, eax
  0035e	74 2e		 je	 SHORT $LN30@z900_set_q
  00360	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00365	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0036c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00371	85 c0		 test	 eax, eax
  00373	74 19		 je	 SHORT $LN30@z900_set_q
  00375	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0037a	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00381	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00386	85 c0		 test	 eax, eax
  00388	0f 85 99 00 00
	00		 jne	 $LN29@z900_set_q
$LN30@z900_set_q:
$LN16@z900_set_q:

; 206  :     {
; 207  :         PTIO(ERR,"*SQBS");

  0038e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00395	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00398	48 83 e0 10	 and	 rax, 16
  0039c	48 85 c0	 test	 rax, rax
  0039f	74 6b		 je	 SHORT $LN31@z900_set_q
  003a1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003af	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003b4	48 8b 54 24 68	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003b9	48 23 d1	 and	 rdx, rcx
  003bc	48 8b ca	 mov	 rcx, rdx
  003bf	8b c9		 mov	 ecx, ecx
  003c1	ba 08 00 00 00	 mov	 edx, 8
  003c6	48 6b d2 01	 imul	 rdx, rdx, 1
  003ca	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d2	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003da	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192840
  003ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f4	44 8b c9	 mov	 r9d, ecx
  003f7	44 8b c2	 mov	 r8d, edx
  003fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192841
  00401	b9 10 00 00 00	 mov	 ecx, 16
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@z900_set_q:
  0040c	33 c0		 xor	 eax, eax
  0040e	85 c0		 test	 eax, eax
  00410	0f 85 78 ff ff
	ff		 jne	 $LN16@z900_set_q

; 208  : #if defined(_FEATURE_QUEUED_DIRECT_IO_ASSIST)
; 209  :         SIE_INTERCEPT(regs);
; 210  : #endif
; 211  :         regs->psw.cc = 2;

  00416	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041e	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 212  :         return;

  00422	e9 88 02 00 00	 jmp	 $LN1@z900_set_q
$LN29@z900_set_q:

; 213  :     }
; 214  : 
; 215  : #if 0
; 216  :     /* Check that device is QDIO active */
; 217  :     if ((dev->scsw.flag2 & SCSW2_Q) == 0)
; 218  :     {
; 219  :         PTIO(ERR,"*SQBS");
; 220  :         regs->psw.cc = 2;
; 221  :         return;
; 222  :     }
; 223  : #endif
; 224  : 
; 225  :     qidx  = regs->GR_H(r1);       /* Queue index */

  00427	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  0042c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00434	8b 84 c1 84 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+644]
  0043b	89 44 24 64	 mov	 DWORD PTR qidx$[rsp], eax

; 226  :     bidx  = regs->GR_L(r1);       /* Buffer index */

  0043f	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  00444	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00453	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax

; 227  :     count = regs->GR_L(r3) < 128 ? regs->GR_L(r3) : 128; /* Number of buffers */

  00457	48 63 44 24 74	 movsxd	 rax, DWORD PTR r3$[rsp]
  0045c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00464	81 bc c1 80 02
	00 00 80 00 00
	00		 cmp	 DWORD PTR [rcx+rax*8+640], 128 ; 00000080H
  0046f	73 1d		 jae	 SHORT $LN42@z900_set_q
  00471	48 63 44 24 74	 movsxd	 rax, DWORD PTR r3$[rsp]
  00476	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00485	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv270[rsp], eax
  0048c	eb 0b		 jmp	 SHORT $LN43@z900_set_q
$LN42@z900_set_q:
  0048e	c7 84 24 80 00
	00 00 80 00 00
	00		 mov	 DWORD PTR tv270[rsp], 128 ; 00000080H
$LN43@z900_set_q:
  00499	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv270[rsp]
  004a0	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax

; 228  :     state = effective_addr2 & 0xFF;

  004a4	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  004a9	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  004af	88 44 24 49	 mov	 BYTE PTR state$[rsp], al

; 229  : 
; 230  :     queues = (U32)(dev->qdio.i_qcnt + dev->qdio.o_qcnt);

  004b3	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004b8	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  004be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  004c3	03 81 c4 13 00
	00		 add	 eax, DWORD PTR [rcx+5060]
  004c9	89 84 24 90 00
	00 00		 mov	 DWORD PTR queues$[rsp], eax

; 231  : 
; 232  :     if ( (qidx >= queues) || (bidx > 127) )

  004d0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR queues$[rsp]
  004d7	39 44 24 64	 cmp	 DWORD PTR qidx$[rsp], eax
  004db	73 07		 jae	 SHORT $LN33@z900_set_q
  004dd	83 7c 24 44 7f	 cmp	 DWORD PTR bidx$[rsp], 127 ; 0000007fH
  004e2	76 12		 jbe	 SHORT $LN32@z900_set_q
$LN33@z900_set_q:

; 233  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  004e4	ba 06 00 00 00	 mov	 edx, 6
  004e9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN32@z900_set_q:

; 234  : 
; 235  :     if (qidx < (U32)dev->qdio.i_qcnt)

  004f6	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004fb	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00501	39 44 24 64	 cmp	 DWORD PTR qidx$[rsp], eax
  00505	73 1b		 jae	 SHORT $LN34@z900_set_q

; 236  :         slsba = dev->qdio.i_slsbla[qidx];

  00507	8b 44 24 64	 mov	 eax, DWORD PTR qidx$[rsp]
  0050b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00510	48 8b 84 c1 d8
	16 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+5848]
  00518	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR slsba$[rsp], rax
  00520	eb 2a		 jmp	 SHORT $LN35@z900_set_q
$LN34@z900_set_q:

; 237  :     else
; 238  :         slsba = dev->qdio.o_slsbla[qidx - dev->qdio.i_qcnt];

  00522	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00527	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  0052d	8b 4c 24 64	 mov	 ecx, DWORD PTR qidx$[rsp]
  00531	2b c8		 sub	 ecx, eax
  00533	8b c1		 mov	 eax, ecx
  00535	8b c0		 mov	 eax, eax
  00537	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  0053c	48 8b 84 c1 58
	1a 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+6744]
  00544	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR slsba$[rsp], rax
$LN35@z900_set_q:

; 239  : 
; 240  :     oldstate = nextstate = ARCH_DEP(wfetchb)((VADR)(slsba+bidx), USE_REAL_ADDR, regs);

  0054c	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  00550	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR slsba$[rsp]
  00558	48 03 c8	 add	 rcx, rax
  0055b	48 8b c1	 mov	 rax, rcx
  0055e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00566	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0056d	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00575	ba fe ff ff ff	 mov	 edx, -2
  0057a	48 8b c8	 mov	 rcx, rax
  0057d	e8 00 00 00 00	 call	 z900_vfetchb
  00582	88 44 24 40	 mov	 BYTE PTR nextstate$[rsp], al
  00586	0f b6 44 24 40	 movzx	 eax, BYTE PTR nextstate$[rsp]
  0058b	88 44 24 48	 mov	 BYTE PTR oldstate$[rsp], al
$LN17@z900_set_q:

; 241  : 
; 242  :     while (count && oldstate == nextstate)

  0058f	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  00594	0f 84 b3 00 00
	00		 je	 $LN18@z900_set_q
  0059a	0f b6 44 24 48	 movzx	 eax, BYTE PTR oldstate$[rsp]
  0059f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR nextstate$[rsp]
  005a4	3b c1		 cmp	 eax, ecx
  005a6	0f 85 a1 00 00
	00		 jne	 $LN18@z900_set_q

; 243  :     {
; 244  :         ARCH_DEP(wstoreb)(state, (VADR)(slsba+bidx), USE_REAL_ADDR, regs);

  005ac	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  005b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR slsba$[rsp]
  005b8	48 03 c8	 add	 rcx, rax
  005bb	48 8b c1	 mov	 rax, rcx
  005be	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  005cd	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005d5	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  005db	48 8b d0	 mov	 rdx, rax
  005de	0f b6 4c 24 49	 movzx	 ecx, BYTE PTR state$[rsp]
  005e3	e8 00 00 00 00	 call	 z900_vstoreb

; 245  : 
; 246  :         bidx++; bidx &= 0x7F;              /* Advance and wrap index */

  005e8	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  005ec	ff c0		 inc	 eax
  005ee	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax
  005f2	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  005f6	83 e0 7f	 and	 eax, 127		; 0000007fH
  005f9	89 44 24 44	 mov	 DWORD PTR bidx$[rsp], eax

; 247  :         count--;

  005fd	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  00601	ff c8		 dec	 eax
  00603	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax

; 248  : 
; 249  :         if(count)

  00607	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  0060c	74 3a		 je	 SHORT $LN36@z900_set_q

; 250  :             nextstate = ARCH_DEP(wfetchb)((VADR)(slsba+bidx), USE_REAL_ADDR, regs);

  0060e	8b 44 24 44	 mov	 eax, DWORD PTR bidx$[rsp]
  00612	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR slsba$[rsp]
  0061a	48 03 c8	 add	 rcx, rax
  0061d	48 8b c1	 mov	 rax, rcx
  00620	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00628	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0062f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00637	ba fe ff ff ff	 mov	 edx, -2
  0063c	48 8b c8	 mov	 rcx, rax
  0063f	e8 00 00 00 00	 call	 z900_vfetchb
  00644	88 44 24 40	 mov	 BYTE PTR nextstate$[rsp], al
$LN36@z900_set_q:

; 251  :     }

  00648	e9 42 ff ff ff	 jmp	 $LN17@z900_set_q
$LN18@z900_set_q:

; 252  : 
; 253  :     regs->GR_L(r1) = bidx;              /* Return buffer state index */

  0064d	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  00652	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0065a	8b 54 24 44	 mov	 edx, DWORD PTR bidx$[rsp]
  0065e	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 254  :     regs->GR_L(r3) = count;    /* Return number of unchanged buffers */

  00665	48 63 44 24 74	 movsxd	 rax, DWORD PTR r3$[rsp]
  0066a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00672	8b 54 24 50	 mov	 edx, DWORD PTR count$[rsp]
  00676	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 255  :     regs->psw.cc = count ? 1 : 0;

  0067d	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  00682	74 0d		 je	 SHORT $LN44@z900_set_q
  00684	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv336[rsp], 1
  0068f	eb 0b		 jmp	 SHORT $LN45@z900_set_q
$LN44@z900_set_q:
  00691	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv336[rsp], 0
$LN45@z900_set_q:
  0069c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a4	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR tv336[rsp]
  006ac	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN1@z900_set_q:
$LN37@z900_set_q:

; 256  : }

  006af	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  006b6	c3		 ret	 0
z900_set_queue_buffer_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qdio.c
_TEXT	SEGMENT
dev$ = 64
effective_addr2$ = 72
tv307 = 80
temp$1 = 84
b2$ = 88
tv181 = 92
tv304 = 96
tv448 = 104
tv446 = 112
tv441 = 120
inst$ = 144
regs$ = 152
z900_signal_adapter PROC

; 34   : {

$LN66:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 35   : int     b2;
; 36   : RADR    effective_addr2;
; 37   : DEVBLK *dev;                            /* -> device block           */
; 38   : 
; 39   :     S(inst, regs, b2, effective_addr2);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00032	8b c0		 mov	 eax, eax
  00034	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00039	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 58	 mov	 DWORD PTR b2$[rsp], eax
  00047	83 7c 24 58 00	 cmp	 DWORD PTR b2$[rsp], 0
  0004c	74 44		 je	 SHORT $LN31@z900_signa
  0004e	48 63 44 24 58	 movsxd	 rax, DWORD PTR b2$[rsp]
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00073	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00087	48 23 c8	 and	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN31@z900_signa:
$LN4@z900_signa:
  00092	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009e	48 83 c0 04	 add	 rax, 4
  000a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 04	 cmp	 eax, 4
  000b3	74 0f		 je	 SHORT $LN32@z900_signa
  000b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN32@z900_signa:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 c8		 jne	 SHORT $LN4@z900_signa
$LN7@z900_signa:

; 40   : 
; 41   : //  ARCH_DEP(display_inst) (regs, inst);
; 42   :     TXF_INSTR_CHECK( regs );

  000ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000d9	85 c0		 test	 eax, eax
  000db	74 3f		 je	 SHORT $LN33@z900_signa
  000dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000eb	0f ba e8 0c	 bts	 eax, 12
  000ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192709
  00104	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010a	ba 02 00 00 00	 mov	 edx, 2
  0010f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	e8 00 00 00 00	 call	 z900_abort_transaction
$LN33@z900_signa:
  0011c	33 c0		 xor	 eax, eax
  0011e	85 c0		 test	 eax, eax
  00120	75 a8		 jne	 SHORT $LN7@z900_signa

; 43   :     PRIV_CHECK(regs);

  00122	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012e	83 e0 01	 and	 eax, 1
  00131	85 c0		 test	 eax, eax
  00133	74 1b		 je	 SHORT $LN34@z900_signa
  00135	ba 02 00 00 00	 mov	 edx, 2
  0013a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00142	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@z900_signa:

; 44   : 
; 45   : #if defined(_FEATURE_SIE)
; 46   :     if(SIE_STATE_BIT_OFF(regs, EC3, SIGA))

  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015e	d1 e8		 shr	 eax, 1
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	74 3f		 je	 SHORT $LN35@z900_signa
  00167	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	48 6b c9 03	 imul	 rcx, rcx, 3
  0017f	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00184	83 e0 04	 and	 eax, 4
  00187	85 c0		 test	 eax, eax
  00189	75 1b		 jne	 SHORT $LN35@z900_signa

; 47   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  0018b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00199	ba fc ff ff ff	 mov	 edx, -4
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	e8 00 00 00 00	 call	 longjmp
$LN35@z900_signa:
$LN10@z900_signa:

; 48   : #endif /*defined(_FEATURE_SIE)*/
; 49   : 
; 50   :     PTIO(IO,"SIGA");

  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b0	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001b6	48 85 c0	 test	 rax, rax
  001b9	74 6b		 je	 SHORT $LN36@z900_signa
  001bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001c9	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001ce	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001d3	48 23 d1	 and	 rdx, rcx
  001d6	48 8b ca	 mov	 rcx, rdx
  001d9	8b c9		 mov	 ecx, ecx
  001db	ba 08 00 00 00	 mov	 edx, 8
  001e0	48 6b d2 01	 imul	 rdx, rdx, 1
  001e4	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ec	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00202	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192713
  00209	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020e	44 8b c9	 mov	 r9d, ecx
  00211	44 8b c2	 mov	 r8d, edx
  00214	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192714
  0021b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_signa:
  00226	33 c0		 xor	 eax, eax
  00228	85 c0		 test	 eax, eax
  0022a	0f 85 76 ff ff
	ff		 jne	 $LN10@z900_signa

; 51   : 
; 52   :     /* Specification exception if invalid function code */
; 53   :     if((regs->GR_L(0)
; 54   : #if defined(FEATURE_QEBSM)
; 55   :                       & ~(FACILITY_ENABLED( HERC_QEBSM, regs ) ? SIGA_TOKEN : 0)
; 56   : #endif /*defined(FEATURE_QEBSM)*/
; 57   :                       ) > SIGA_FC_MAX)

  00230	b8 01 00 00 00	 mov	 eax, 1
  00235	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  00239	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00249	83 e0 08	 and	 eax, 8
  0024c	85 c0		 test	 eax, eax
  0024e	74 0a		 je	 SHORT $LN62@z900_signa
  00250	c7 44 24 5c 80
	00 00 00	 mov	 DWORD PTR tv181[rsp], 128 ; 00000080H
  00258	eb 08		 jmp	 SHORT $LN63@z900_signa
$LN62@z900_signa:
  0025a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN63@z900_signa:
  00262	b8 08 00 00 00	 mov	 eax, 8
  00267	48 6b c0 00	 imul	 rax, rax, 0
  0026b	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv181[rsp]
  0026f	f7 d1		 not	 ecx
  00271	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00279	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  00280	23 c1		 and	 eax, ecx
  00282	83 f8 02	 cmp	 eax, 2
  00285	76 12		 jbe	 SHORT $LN37@z900_signa

; 58   :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00287	ba 06 00 00 00	 mov	 edx, 6
  0028c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	e8 00 00 00 00	 call	 z900_program_interrupt
$LN37@z900_signa:

; 59   : 
; 60   :     /* Locate the device block for this subchannel */
; 61   : #if defined(FEATURE_QEBSM)
; 62   :     if (FACILITY_ENABLED( HERC_QEBSM, regs )
; 63   :       && (regs->GR_L(0) & SIGA_TOKEN))

  00299	b8 01 00 00 00	 mov	 eax, 1
  0029e	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  002a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  002b2	83 e0 08	 and	 eax, 8
  002b5	85 c0		 test	 eax, eax
  002b7	74 4b		 je	 SHORT $LN38@z900_signa
  002b9	b8 08 00 00 00	 mov	 eax, 8
  002be	48 6b c0 00	 imul	 rax, rax, 0
  002c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ca	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d6	85 c0		 test	 eax, eax
  002d8	74 2a		 je	 SHORT $LN38@z900_signa

; 64   :         dev = find_device_by_subchan (TKN2IOID(regs->GR_G(1)));

  002da	b8 08 00 00 00	 mov	 eax, 8
  002df	48 6b c0 01	 imul	 rax, rax, 1
  002e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002f3	48 f7 d0	 not	 rax
  002f6	8b c8		 mov	 ecx, eax
  002f8	e8 00 00 00 00	 call	 find_device_by_subchan
  002fd	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax
  00302	eb 7b		 jmp	 SHORT $LN39@z900_signa
$LN38@z900_signa:

; 65   :     else
; 66   : #endif /*defined(FEATURE_QEBSM)*/
; 67   :     {
; 68   :         /* Program check if the ssid including lcss is invalid */
; 69   :         SSID_CHECK(regs);

  00304	b8 08 00 00 00	 mov	 eax, 8
  00309	48 6b c0 01	 imul	 rax, rax, 1
  0030d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00315	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0031d	83 e0 01	 and	 eax, 1
  00320	85 c0		 test	 eax, eax
  00322	74 1e		 je	 SHORT $LN41@z900_signa
  00324	b8 08 00 00 00	 mov	 eax, 8
  00329	48 6b c0 01	 imul	 rax, rax, 1
  0032d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00335	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0033d	83 f8 03	 cmp	 eax, 3
  00340	7e 1b		 jle	 SHORT $LN40@z900_signa
$LN41@z900_signa:
  00342	ba 15 00 00 00	 mov	 edx, 21
  00347	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00357	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@z900_signa:

; 70   :         dev = find_device_by_subchan (regs->GR_L(1));

  0035d	b8 08 00 00 00	 mov	 eax, 8
  00362	48 6b c0 01	 imul	 rax, rax, 1
  00366	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036e	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00375	e8 00 00 00 00	 call	 find_device_by_subchan
  0037a	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax
$LN39@z900_signa:

; 71   :     }
; 72   : 
; 73   :     /* Condition code 3 if subchannel does not exist,
; 74   :        is not valid, or is not enabled or is not a QDIO subchannel */
; 75   :     if (dev == NULL
; 76   :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 77   :         || (dev->pmcw.flag5 & PMCW5_E) == 0
; 78   :         || (dev->pmcw.flag4 & PMCW4_Q) == 0)

  0037f	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00385	74 41		 je	 SHORT $LN43@z900_signa
  00387	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0038c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00393	83 e0 01	 and	 eax, 1
  00396	85 c0		 test	 eax, eax
  00398	74 2e		 je	 SHORT $LN43@z900_signa
  0039a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0039f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ab	85 c0		 test	 eax, eax
  003ad	74 19		 je	 SHORT $LN43@z900_signa
  003af	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003b4	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  003bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003c0	85 c0		 test	 eax, eax
  003c2	0f 85 99 00 00
	00		 jne	 $LN42@z900_signa
$LN43@z900_signa:
$LN13@z900_signa:

; 79   :     {
; 80   :         PTIO(ERR,"*SIGA");

  003c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d2	48 83 e0 10	 and	 rax, 16
  003d6	48 85 c0	 test	 rax, rax
  003d9	74 6b		 je	 SHORT $LN44@z900_signa
  003db	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003e9	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003ee	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003f3	48 23 d1	 and	 rdx, rcx
  003f6	48 8b ca	 mov	 rcx, rdx
  003f9	8b c9		 mov	 ecx, ecx
  003fb	ba 08 00 00 00	 mov	 edx, 8
  00400	48 6b d2 01	 imul	 rdx, rdx, 1
  00404	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0040c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00414	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0041d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00422	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192723
  00429	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0042e	44 8b c9	 mov	 r9d, ecx
  00431	44 8b c2	 mov	 r8d, edx
  00434	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192724
  0043b	b9 10 00 00 00	 mov	 ecx, 16
  00440	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@z900_signa:
  00446	33 c0		 xor	 eax, eax
  00448	85 c0		 test	 eax, eax
  0044a	0f 85 78 ff ff
	ff		 jne	 $LN13@z900_signa

; 81   : #if defined(_FEATURE_QUEUED_DIRECT_IO_ASSIST)
; 82   :         SIE_INTERCEPT(regs);
; 83   : #endif
; 84   :         regs->psw.cc = 3;

  00450	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00458	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 85   :         return;

  0045c	e9 fe 04 00 00	 jmp	 $LN1@z900_signa
$LN42@z900_signa:

; 86   :     }
; 87   : 
; 88   :     /* Obtain the device lock */
; 89   :     obtain_lock (&dev->lock);

  00461	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00466	48 83 c0 38	 add	 rax, 56			; 00000038H
  0046a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192725
  00471	48 8b c8	 mov	 rcx, rax
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 90   : 
; 91   :     /* Check that device is QDIO active */
; 92   :     if ((dev->scsw.flag2 & SCSW2_Q) == 0)

  0047a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0047f	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00486	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0048b	85 c0		 test	 eax, eax
  0048d	0f 85 b2 00 00
	00		 jne	 $LN45@z900_signa
$LN16@z900_signa:

; 93   :     {
; 94   :         PTIO(ERR,"*SIGA");

  00493	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049d	48 83 e0 10	 and	 rax, 16
  004a1	48 85 c0	 test	 rax, rax
  004a4	74 6b		 je	 SHORT $LN46@z900_signa
  004a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ae	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004b4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  004b9	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  004be	48 23 d1	 and	 rdx, rcx
  004c1	48 8b ca	 mov	 rcx, rdx
  004c4	8b c9		 mov	 ecx, ecx
  004c6	ba 08 00 00 00	 mov	 edx, 8
  004cb	48 6b d2 01	 imul	 rdx, rdx, 1
  004cf	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004d7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004df	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004e8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192728
  004f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f9	44 8b c9	 mov	 r9d, ecx
  004fc	44 8b c2	 mov	 r8d, edx
  004ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192729
  00506	b9 10 00 00 00	 mov	 ecx, 16
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@z900_signa:
  00511	33 c0		 xor	 eax, eax
  00513	85 c0		 test	 eax, eax
  00515	0f 85 78 ff ff
	ff		 jne	 $LN16@z900_signa

; 95   :         release_lock (&dev->lock);

  0051b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00520	48 83 c0 38	 add	 rax, 56			; 00000038H
  00524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192730
  0052b	48 8b c8	 mov	 rcx, rax
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 96   :         regs->psw.cc = 1;

  00534	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053c	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 97   :         return;

  00540	e9 1a 04 00 00	 jmp	 $LN1@z900_signa
$LN45@z900_signa:

; 98   :     }
; 99   : 
; 100  :     switch(

  00545	b8 01 00 00 00	 mov	 eax, 1
  0054a	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  0054e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00556	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0055e	83 e0 08	 and	 eax, 8
  00561	85 c0		 test	 eax, eax
  00563	74 0a		 je	 SHORT $LN64@z900_signa
  00565	c7 44 24 60 80
	00 00 00	 mov	 DWORD PTR tv304[rsp], 128 ; 00000080H
  0056d	eb 08		 jmp	 SHORT $LN65@z900_signa
$LN64@z900_signa:
  0056f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv304[rsp], 0
$LN65@z900_signa:
  00577	b8 08 00 00 00	 mov	 eax, 8
  0057c	48 6b c0 00	 imul	 rax, rax, 0
  00580	8b 4c 24 60	 mov	 ecx, DWORD PTR tv304[rsp]
  00584	f7 d1		 not	 ecx
  00586	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0058e	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  00595	23 c1		 and	 eax, ecx
  00597	89 44 24 50	 mov	 DWORD PTR tv307[rsp], eax
  0059b	83 7c 24 50 00	 cmp	 DWORD PTR tv307[rsp], 0
  005a0	0f 84 0f 01 00
	00		 je	 $LN51@z900_signa
  005a6	83 7c 24 50 01	 cmp	 DWORD PTR tv307[rsp], 1
  005ab	74 10		 je	 SHORT $LN47@z900_signa
  005ad	83 7c 24 50 02	 cmp	 DWORD PTR tv307[rsp], 2
  005b2	0f 84 f5 01 00
	00		 je	 $LN55@z900_signa
  005b8	e9 01 03 00 00	 jmp	 $LN59@z900_signa
$LN47@z900_signa:

; 101  :            regs->GR_L(0)
; 102  : #if defined(FEATURE_QEBSM)
; 103  :                          & ~(FACILITY_ENABLED( HERC_QEBSM, regs ) ? SIGA_TOKEN : 0)
; 104  : #endif /*defined(FEATURE_QEBSM)*/
; 105  :                          ) {
; 106  :     case SIGA_FC_R:
; 107  :         if(dev->hnd->siga_r)

  005bd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005c2	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  005c9	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  005d1	74 49		 je	 SHORT $LN48@z900_signa

; 108  :             regs->psw.cc = (dev->hnd->siga_r) (dev, regs->GR_L(2) );

  005d3	b8 08 00 00 00	 mov	 eax, 8
  005d8	48 6b c0 02	 imul	 rax, rax, 2
  005dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  005e1	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  005e8	48 89 4c 24 68	 mov	 QWORD PTR tv448[rsp], rcx
  005ed	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005f5	8b 94 02 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax+640]
  005fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00601	48 8b 44 24 68	 mov	 rax, QWORD PTR tv448[rsp]
  00606	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0060c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00614	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  00617	e9 94 00 00 00	 jmp	 $LN49@z900_signa
$LN48@z900_signa:
$LN21@z900_signa:

; 109  :         else
; 110  :         {
; 111  :             PTIO(ERR,"*SIGA");

  0061c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00623	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00626	48 83 e0 10	 and	 rax, 16
  0062a	48 85 c0	 test	 rax, rax
  0062d	74 6b		 je	 SHORT $LN50@z900_signa
  0062f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00637	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0063d	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00642	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00647	48 23 d1	 and	 rdx, rcx
  0064a	48 8b ca	 mov	 rcx, rdx
  0064d	8b c9		 mov	 ecx, ecx
  0064f	ba 08 00 00 00	 mov	 edx, 8
  00654	48 6b d2 01	 imul	 rdx, rdx, 1
  00658	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00660	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00668	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00671	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00676	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192735
  0067d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00682	44 8b c9	 mov	 r9d, ecx
  00685	44 8b c2	 mov	 r8d, edx
  00688	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192736
  0068f	b9 10 00 00 00	 mov	 ecx, 16
  00694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_signa:
  0069a	33 c0		 xor	 eax, eax
  0069c	85 c0		 test	 eax, eax
  0069e	0f 85 78 ff ff
	ff		 jne	 $LN21@z900_signa

; 112  :             regs->psw.cc = 3;

  006a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ac	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN49@z900_signa:

; 113  :         }
; 114  :         break;

  006b0	e9 91 02 00 00	 jmp	 $LN17@z900_signa
$LN51@z900_signa:

; 115  : 
; 116  :     case SIGA_FC_W:
; 117  :         if(dev->hnd->siga_w)

  006b5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006ba	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  006c1	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  006c9	74 49		 je	 SHORT $LN52@z900_signa

; 118  :             regs->psw.cc = (dev->hnd->siga_w) (dev, regs->GR_L(2) );

  006cb	b8 08 00 00 00	 mov	 eax, 8
  006d0	48 6b c0 02	 imul	 rax, rax, 2
  006d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  006d9	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  006e0	48 89 4c 24 70	 mov	 QWORD PTR tv446[rsp], rcx
  006e5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006ed	8b 94 02 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax+640]
  006f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  006f9	48 8b 44 24 70	 mov	 rax, QWORD PTR tv446[rsp]
  006fe	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00704	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070c	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  0070f	e9 94 00 00 00	 jmp	 $LN53@z900_signa
$LN52@z900_signa:
$LN24@z900_signa:

; 119  :         else
; 120  :         {
; 121  :             PTIO(ERR,"*SIGA");

  00714	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0071b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0071e	48 83 e0 10	 and	 rax, 16
  00722	48 85 c0	 test	 rax, rax
  00725	74 6b		 je	 SHORT $LN54@z900_signa
  00727	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00735	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0073a	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0073f	48 23 d1	 and	 rdx, rcx
  00742	48 8b ca	 mov	 rcx, rdx
  00745	8b c9		 mov	 ecx, ecx
  00747	ba 08 00 00 00	 mov	 edx, 8
  0074c	48 6b d2 01	 imul	 rdx, rdx, 1
  00750	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00758	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00760	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00769	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0076e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192741
  00775	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0077a	44 8b c9	 mov	 r9d, ecx
  0077d	44 8b c2	 mov	 r8d, edx
  00780	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192742
  00787	b9 10 00 00 00	 mov	 ecx, 16
  0078c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@z900_signa:
  00792	33 c0		 xor	 eax, eax
  00794	85 c0		 test	 eax, eax
  00796	0f 85 78 ff ff
	ff		 jne	 $LN24@z900_signa

; 122  :             regs->psw.cc = 3;

  0079c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a4	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN53@z900_signa:

; 123  :         }
; 124  :         break;

  007a8	e9 99 01 00 00	 jmp	 $LN17@z900_signa
$LN55@z900_signa:

; 125  : 
; 126  :     case SIGA_FC_S:
; 127  : #if SIGA_FC_MAX >= SIGA_FC_S
; 128  :         if(dev->hnd->siga_s)

  007ad	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007b2	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  007b9	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  007c1	74 62		 je	 SHORT $LN56@z900_signa

; 129  :             regs->psw.cc = (dev->hnd->siga_s) (dev, regs->GR_L(2), regs->GR_L(3) );

  007c3	b8 08 00 00 00	 mov	 eax, 8
  007c8	48 6b c0 03	 imul	 rax, rax, 3
  007cc	b9 08 00 00 00	 mov	 ecx, 8
  007d1	48 6b c9 02	 imul	 rcx, rcx, 2
  007d5	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  007da	48 8b 92 90 02
	00 00		 mov	 rdx, QWORD PTR [rdx+656]
  007e1	48 89 54 24 78	 mov	 QWORD PTR tv441[rsp], rdx
  007e6	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  007ee	45 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax+640]
  007f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007fe	8b 94 08 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx+640]
  00805	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0080a	48 8b 44 24 78	 mov	 rax, QWORD PTR tv441[rsp]
  0080f	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00815	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0081d	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  00820	e9 94 00 00 00	 jmp	 $LN57@z900_signa
$LN56@z900_signa:
$LN27@z900_signa:

; 130  :         else
; 131  :         {
; 132  :             PTIO(ERR,"*SIGA");

  00825	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0082c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0082f	48 83 e0 10	 and	 rax, 16
  00833	48 85 c0	 test	 rax, rax
  00836	74 6b		 je	 SHORT $LN58@z900_signa
  00838	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00840	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00846	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0084b	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00850	48 23 d1	 and	 rdx, rcx
  00853	48 8b ca	 mov	 rcx, rdx
  00856	8b c9		 mov	 ecx, ecx
  00858	ba 08 00 00 00	 mov	 edx, 8
  0085d	48 6b d2 01	 imul	 rdx, rdx, 1
  00861	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00869	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00871	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0087a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0087f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192747
  00886	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088b	44 8b c9	 mov	 r9d, ecx
  0088e	44 8b c2	 mov	 r8d, edx
  00891	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192748
  00898	b9 10 00 00 00	 mov	 ecx, 16
  0089d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN58@z900_signa:
  008a3	33 c0		 xor	 eax, eax
  008a5	85 c0		 test	 eax, eax
  008a7	0f 85 78 ff ff
	ff		 jne	 $LN27@z900_signa

; 133  :             regs->psw.cc = 3;

  008ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b5	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN57@z900_signa:

; 134  :         }
; 135  : #else
; 136  :         /* No signalling required for sync requests as we emulate
; 137  :            a real machine */
; 138  :         regs->psw.cc = 0;
; 139  : #endif
; 140  :         break;

  008b9	e9 88 00 00 00	 jmp	 $LN17@z900_signa
$LN59@z900_signa:
$LN30@z900_signa:

; 141  : 
; 142  : #if SIGA_FC_MAX >= SIGA_FC_M
; 143  :     case SIGA_FC_M:
; 144  :         if(dev->hnd->siga_m)
; 145  :             regs->psw.cc = (dev->hnd->siga_m) (dev, regs->GR_L(2) );
; 146  :         else
; 147  :         {
; 148  :             PTIO(ERR,"*SIGA");
; 149  :             regs->psw.cc = 3;
; 150  :         }
; 151  :         break;
; 152  : #endif
; 153  : 
; 154  :     default:
; 155  :         PTIO(ERR,"*SIGA");

  008be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008c8	48 83 e0 10	 and	 rax, 16
  008cc	48 85 c0	 test	 rax, rax
  008cf	74 6b		 je	 SHORT $LN60@z900_signa
  008d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  008df	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  008e4	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  008e9	48 23 d1	 and	 rdx, rcx
  008ec	48 8b ca	 mov	 rcx, rdx
  008ef	8b c9		 mov	 ecx, ecx
  008f1	ba 08 00 00 00	 mov	 edx, 8
  008f6	48 6b d2 01	 imul	 rdx, rdx, 1
  008fa	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00902	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0090a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00913	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00918	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192751
  0091f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00924	44 8b c9	 mov	 r9d, ecx
  00927	44 8b c2	 mov	 r8d, edx
  0092a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192752
  00931	b9 10 00 00 00	 mov	 ecx, 16
  00936	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN60@z900_signa:
  0093c	33 c0		 xor	 eax, eax
  0093e	85 c0		 test	 eax, eax
  00940	0f 85 78 ff ff
	ff		 jne	 $LN30@z900_signa
$LN17@z900_signa:

; 156  : 
; 157  :     }
; 158  : 
; 159  :     release_lock (&dev->lock);

  00946	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0094b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0094f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192753
  00956	48 8b c8	 mov	 rcx, rax
  00959	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@z900_signa:
$LN61@z900_signa:

; 160  : }

  0095f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00966	c3		 ret	 0
z900_signal_adapter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qdio.c
_TEXT	SEGMENT
tv260 = 64
temp$1 = 68
b2$ = 72
dev$ = 80
effective_addr2$ = 88
tv401 = 96
tv399 = 104
tv394 = 112
inst$ = 144
regs$ = 152
s390_signal_adapter PROC

; 34   : {

$LN56:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 35   : int     b2;
; 36   : RADR    effective_addr2;
; 37   : DEVBLK *dev;                            /* -> device block           */
; 38   : 
; 39   :     S(inst, regs, b2, effective_addr2);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00032	8b c0		 mov	 eax, eax
  00034	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00039	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00047	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0004c	74 42		 je	 SHORT $LN28@s390_signa
  0004e	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00062	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00067	48 03 c8	 add	 rcx, rax
  0006a	48 8b c1	 mov	 rax, rcx
  0006d	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00072	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00080	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00085	48 23 c8	 and	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN28@s390_signa:
$LN4@s390_signa:
  00090	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00098	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009c	48 83 c0 04	 add	 rax, 4
  000a0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ac	33 c0		 xor	 eax, eax
  000ae	83 f8 04	 cmp	 eax, 4
  000b1	74 0f		 je	 SHORT $LN29@s390_signa
  000b3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN29@s390_signa:
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 c8		 jne	 SHORT $LN4@s390_signa

; 40   : 
; 41   : //  ARCH_DEP(display_inst) (regs, inst);
; 42   :     TXF_INSTR_CHECK( regs );
; 43   :     PRIV_CHECK(regs);

  000c8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000d4	83 e0 01	 and	 eax, 1
  000d7	85 c0		 test	 eax, eax
  000d9	74 1b		 je	 SHORT $LN30@s390_signa
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@s390_signa:

; 44   : 
; 45   : #if defined(_FEATURE_SIE)
; 46   :     if(SIE_STATE_BIT_OFF(regs, EC3, SIGA))

  000f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00104	d1 e8		 shr	 eax, 1
  00106	83 e0 01	 and	 eax, 1
  00109	85 c0		 test	 eax, eax
  0010b	74 3f		 je	 SHORT $LN31@s390_signa
  0010d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	48 6b c9 03	 imul	 rcx, rcx, 3
  00125	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0012a	83 e0 04	 and	 eax, 4
  0012d	85 c0		 test	 eax, eax
  0012f	75 1b		 jne	 SHORT $LN31@s390_signa

; 47   :         longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  00131	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0013f	ba fc ff ff ff	 mov	 edx, -4
  00144	48 8b c8	 mov	 rcx, rax
  00147	e8 00 00 00 00	 call	 longjmp
$LN31@s390_signa:
$LN7@s390_signa:

; 48   : #endif /*defined(_FEATURE_SIE)*/
; 49   : 
; 50   :     PTIO(IO,"SIGA");

  0014c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00153	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00156	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0015c	48 85 c0	 test	 rax, rax
  0015f	74 6b		 je	 SHORT $LN32@s390_signa
  00161	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0016f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00174	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00179	48 23 d1	 and	 rdx, rcx
  0017c	48 8b ca	 mov	 rcx, rdx
  0017f	8b c9		 mov	 ecx, ecx
  00181	ba 08 00 00 00	 mov	 edx, 8
  00186	48 6b d2 01	 imul	 rdx, rdx, 1
  0018a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00192	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0019a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179646
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	44 8b c9	 mov	 r9d, ecx
  001b7	44 8b c2	 mov	 r8d, edx
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179647
  001c1	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@s390_signa:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 76 ff ff
	ff		 jne	 $LN7@s390_signa

; 51   : 
; 52   :     /* Specification exception if invalid function code */
; 53   :     if((regs->GR_L(0)
; 54   : #if defined(FEATURE_QEBSM)
; 55   :                       & ~(FACILITY_ENABLED( HERC_QEBSM, regs ) ? SIGA_TOKEN : 0)
; 56   : #endif /*defined(FEATURE_QEBSM)*/
; 57   :                       ) > SIGA_FC_MAX)

  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	48 6b c0 00	 imul	 rax, rax, 0
  001df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	83 bc 01 80 02
	00 00 02	 cmp	 DWORD PTR [rcx+rax+640], 2
  001ef	76 12		 jbe	 SHORT $LN33@s390_signa

; 58   :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001f1	ba 06 00 00 00	 mov	 edx, 6
  001f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	e8 00 00 00 00	 call	 s390_program_interrupt
$LN33@s390_signa:

; 59   : 
; 60   :     /* Locate the device block for this subchannel */
; 61   : #if defined(FEATURE_QEBSM)
; 62   :     if (FACILITY_ENABLED( HERC_QEBSM, regs )
; 63   :       && (regs->GR_L(0) & SIGA_TOKEN))
; 64   :         dev = find_device_by_subchan (TKN2IOID(regs->GR_G(1)));
; 65   :     else
; 66   : #endif /*defined(FEATURE_QEBSM)*/
; 67   :     {
; 68   :         /* Program check if the ssid including lcss is invalid */
; 69   :         SSID_CHECK(regs);

  00203	b8 08 00 00 00	 mov	 eax, 8
  00208	48 6b c0 01	 imul	 rax, rax, 1
  0020c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00214	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0021c	83 e0 01	 and	 eax, 1
  0021f	85 c0		 test	 eax, eax
  00221	74 1e		 je	 SHORT $LN35@s390_signa
  00223	b8 08 00 00 00	 mov	 eax, 8
  00228	48 6b c0 01	 imul	 rax, rax, 1
  0022c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0023c	83 f8 03	 cmp	 eax, 3
  0023f	7e 1b		 jle	 SHORT $LN34@s390_signa
$LN35@s390_signa:
  00241	ba 15 00 00 00	 mov	 edx, 21
  00246	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00256	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@s390_signa:

; 70   :         dev = find_device_by_subchan (regs->GR_L(1));

  0025c	b8 08 00 00 00	 mov	 eax, 8
  00261	48 6b c0 01	 imul	 rax, rax, 1
  00265	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026d	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00274	e8 00 00 00 00	 call	 find_device_by_subchan
  00279	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 71   :     }
; 72   : 
; 73   :     /* Condition code 3 if subchannel does not exist,
; 74   :        is not valid, or is not enabled or is not a QDIO subchannel */
; 75   :     if (dev == NULL
; 76   :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 77   :         || (dev->pmcw.flag5 & PMCW5_E) == 0
; 78   :         || (dev->pmcw.flag4 & PMCW4_Q) == 0)

  0027e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00284	74 41		 je	 SHORT $LN37@s390_signa
  00286	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0028b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00292	83 e0 01	 and	 eax, 1
  00295	85 c0		 test	 eax, eax
  00297	74 2e		 je	 SHORT $LN37@s390_signa
  00299	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0029e	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  002a5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002aa	85 c0		 test	 eax, eax
  002ac	74 19		 je	 SHORT $LN37@s390_signa
  002ae	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002b3	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  002ba	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002bf	85 c0		 test	 eax, eax
  002c1	0f 85 99 00 00
	00		 jne	 $LN36@s390_signa
$LN37@s390_signa:
$LN10@s390_signa:

; 79   :     {
; 80   :         PTIO(ERR,"*SIGA");

  002c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d1	48 83 e0 10	 and	 rax, 16
  002d5	48 85 c0	 test	 rax, rax
  002d8	74 6b		 je	 SHORT $LN38@s390_signa
  002da	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002e8	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  002ed	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002f2	48 23 d1	 and	 rdx, rcx
  002f5	48 8b ca	 mov	 rcx, rdx
  002f8	8b c9		 mov	 ecx, ecx
  002fa	ba 08 00 00 00	 mov	 edx, 8
  002ff	48 6b d2 01	 imul	 rdx, rdx, 1
  00303	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0030b	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00313	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0031c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00321	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179654
  00328	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032d	44 8b c9	 mov	 r9d, ecx
  00330	44 8b c2	 mov	 r8d, edx
  00333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179655
  0033a	b9 10 00 00 00	 mov	 ecx, 16
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@s390_signa:
  00345	33 c0		 xor	 eax, eax
  00347	85 c0		 test	 eax, eax
  00349	0f 85 78 ff ff
	ff		 jne	 $LN10@s390_signa

; 81   : #if defined(_FEATURE_QUEUED_DIRECT_IO_ASSIST)
; 82   :         SIE_INTERCEPT(regs);
; 83   : #endif
; 84   :         regs->psw.cc = 3;

  0034f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00357	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 85   :         return;

  0035b	e9 c4 04 00 00	 jmp	 $LN1@s390_signa
$LN36@s390_signa:

; 86   :     }
; 87   : 
; 88   :     /* Obtain the device lock */
; 89   :     obtain_lock (&dev->lock);

  00360	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00365	48 83 c0 38	 add	 rax, 56			; 00000038H
  00369	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179656
  00370	48 8b c8	 mov	 rcx, rax
  00373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 90   : 
; 91   :     /* Check that device is QDIO active */
; 92   :     if ((dev->scsw.flag2 & SCSW2_Q) == 0)

  00379	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0037e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00385	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0038a	85 c0		 test	 eax, eax
  0038c	0f 85 b2 00 00
	00		 jne	 $LN39@s390_signa
$LN13@s390_signa:

; 93   :     {
; 94   :         PTIO(ERR,"*SIGA");

  00392	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00399	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0039c	48 83 e0 10	 and	 rax, 16
  003a0	48 85 c0	 test	 rax, rax
  003a3	74 6b		 je	 SHORT $LN40@s390_signa
  003a5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ad	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003b3	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003b8	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003bd	48 23 d1	 and	 rdx, rcx
  003c0	48 8b ca	 mov	 rcx, rdx
  003c3	8b c9		 mov	 ecx, ecx
  003c5	ba 08 00 00 00	 mov	 edx, 8
  003ca	48 6b d2 01	 imul	 rdx, rdx, 1
  003ce	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d6	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003de	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179659
  003f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f8	44 8b c9	 mov	 r9d, ecx
  003fb	44 8b c2	 mov	 r8d, edx
  003fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179660
  00405	b9 10 00 00 00	 mov	 ecx, 16
  0040a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@s390_signa:
  00410	33 c0		 xor	 eax, eax
  00412	85 c0		 test	 eax, eax
  00414	0f 85 78 ff ff
	ff		 jne	 $LN13@s390_signa

; 95   :         release_lock (&dev->lock);

  0041a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0041f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179661
  0042a	48 8b c8	 mov	 rcx, rax
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 96   :         regs->psw.cc = 1;

  00433	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043b	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 97   :         return;

  0043f	e9 e0 03 00 00	 jmp	 $LN1@s390_signa
$LN39@s390_signa:

; 98   :     }
; 99   : 
; 100  :     switch(

  00444	b8 08 00 00 00	 mov	 eax, 8
  00449	48 6b c0 00	 imul	 rax, rax, 0
  0044d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0045c	89 44 24 40	 mov	 DWORD PTR tv260[rsp], eax
  00460	83 7c 24 40 00	 cmp	 DWORD PTR tv260[rsp], 0
  00465	0f 84 0f 01 00
	00		 je	 $LN45@s390_signa
  0046b	83 7c 24 40 01	 cmp	 DWORD PTR tv260[rsp], 1
  00470	74 10		 je	 SHORT $LN41@s390_signa
  00472	83 7c 24 40 02	 cmp	 DWORD PTR tv260[rsp], 2
  00477	0f 84 f5 01 00
	00		 je	 $LN49@s390_signa
  0047d	e9 01 03 00 00	 jmp	 $LN53@s390_signa
$LN41@s390_signa:

; 101  :            regs->GR_L(0)
; 102  : #if defined(FEATURE_QEBSM)
; 103  :                          & ~(FACILITY_ENABLED( HERC_QEBSM, regs ) ? SIGA_TOKEN : 0)
; 104  : #endif /*defined(FEATURE_QEBSM)*/
; 105  :                          ) {
; 106  :     case SIGA_FC_R:
; 107  :         if(dev->hnd->siga_r)

  00482	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00487	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0048e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00496	74 49		 je	 SHORT $LN42@s390_signa

; 108  :             regs->psw.cc = (dev->hnd->siga_r) (dev, regs->GR_L(2) );

  00498	b8 08 00 00 00	 mov	 eax, 8
  0049d	48 6b c0 02	 imul	 rax, rax, 2
  004a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  004a6	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  004ad	48 89 4c 24 60	 mov	 QWORD PTR tv401[rsp], rcx
  004b2	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ba	8b 94 02 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax+640]
  004c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  004c6	48 8b 44 24 60	 mov	 rax, QWORD PTR tv401[rsp]
  004cb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004d1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d9	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  004dc	e9 94 00 00 00	 jmp	 $LN43@s390_signa
$LN42@s390_signa:
$LN18@s390_signa:

; 109  :         else
; 110  :         {
; 111  :             PTIO(ERR,"*SIGA");

  004e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004eb	48 83 e0 10	 and	 rax, 16
  004ef	48 85 c0	 test	 rax, rax
  004f2	74 6b		 je	 SHORT $LN44@s390_signa
  004f4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00502	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00507	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0050c	48 23 d1	 and	 rdx, rcx
  0050f	48 8b ca	 mov	 rcx, rdx
  00512	8b c9		 mov	 ecx, ecx
  00514	ba 08 00 00 00	 mov	 edx, 8
  00519	48 6b d2 01	 imul	 rdx, rdx, 1
  0051d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00525	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0052d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00536	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0053b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179666
  00542	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00547	44 8b c9	 mov	 r9d, ecx
  0054a	44 8b c2	 mov	 r8d, edx
  0054d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179667
  00554	b9 10 00 00 00	 mov	 ecx, 16
  00559	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@s390_signa:
  0055f	33 c0		 xor	 eax, eax
  00561	85 c0		 test	 eax, eax
  00563	0f 85 78 ff ff
	ff		 jne	 $LN18@s390_signa

; 112  :             regs->psw.cc = 3;

  00569	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN43@s390_signa:

; 113  :         }
; 114  :         break;

  00575	e9 91 02 00 00	 jmp	 $LN14@s390_signa
$LN45@s390_signa:

; 115  : 
; 116  :     case SIGA_FC_W:
; 117  :         if(dev->hnd->siga_w)

  0057a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0057f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00586	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0058e	74 49		 je	 SHORT $LN46@s390_signa

; 118  :             regs->psw.cc = (dev->hnd->siga_w) (dev, regs->GR_L(2) );

  00590	b8 08 00 00 00	 mov	 eax, 8
  00595	48 6b c0 02	 imul	 rax, rax, 2
  00599	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0059e	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  005a5	48 89 4c 24 68	 mov	 QWORD PTR tv399[rsp], rcx
  005aa	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b2	8b 94 02 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax+640]
  005b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  005be	48 8b 44 24 68	 mov	 rax, QWORD PTR tv399[rsp]
  005c3	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  005c9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d1	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  005d4	e9 94 00 00 00	 jmp	 $LN47@s390_signa
$LN46@s390_signa:
$LN21@s390_signa:

; 119  :         else
; 120  :         {
; 121  :             PTIO(ERR,"*SIGA");

  005d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e3	48 83 e0 10	 and	 rax, 16
  005e7	48 85 c0	 test	 rax, rax
  005ea	74 6b		 je	 SHORT $LN48@s390_signa
  005ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005fa	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  005ff	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00604	48 23 d1	 and	 rdx, rcx
  00607	48 8b ca	 mov	 rcx, rdx
  0060a	8b c9		 mov	 ecx, ecx
  0060c	ba 08 00 00 00	 mov	 edx, 8
  00611	48 6b d2 01	 imul	 rdx, rdx, 1
  00615	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0061d	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00625	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0062e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00633	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179672
  0063a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063f	44 8b c9	 mov	 r9d, ecx
  00642	44 8b c2	 mov	 r8d, edx
  00645	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179673
  0064c	b9 10 00 00 00	 mov	 ecx, 16
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN48@s390_signa:
  00657	33 c0		 xor	 eax, eax
  00659	85 c0		 test	 eax, eax
  0065b	0f 85 78 ff ff
	ff		 jne	 $LN21@s390_signa

; 122  :             regs->psw.cc = 3;

  00661	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00669	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN47@s390_signa:

; 123  :         }
; 124  :         break;

  0066d	e9 99 01 00 00	 jmp	 $LN14@s390_signa
$LN49@s390_signa:

; 125  : 
; 126  :     case SIGA_FC_S:
; 127  : #if SIGA_FC_MAX >= SIGA_FC_S
; 128  :         if(dev->hnd->siga_s)

  00672	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00677	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0067e	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00686	74 62		 je	 SHORT $LN50@s390_signa

; 129  :             regs->psw.cc = (dev->hnd->siga_s) (dev, regs->GR_L(2), regs->GR_L(3) );

  00688	b8 08 00 00 00	 mov	 eax, 8
  0068d	48 6b c0 03	 imul	 rax, rax, 3
  00691	b9 08 00 00 00	 mov	 ecx, 8
  00696	48 6b c9 02	 imul	 rcx, rcx, 2
  0069a	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  0069f	48 8b 92 90 02
	00 00		 mov	 rdx, QWORD PTR [rdx+656]
  006a6	48 89 54 24 70	 mov	 QWORD PTR tv394[rsp], rdx
  006ab	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  006b3	45 8b 84 00 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax+640]
  006bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c3	8b 94 08 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx+640]
  006ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  006cf	48 8b 44 24 70	 mov	 rax, QWORD PTR tv394[rsp]
  006d4	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  006da	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e2	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  006e5	e9 94 00 00 00	 jmp	 $LN51@s390_signa
$LN50@s390_signa:
$LN24@s390_signa:

; 130  :         else
; 131  :         {
; 132  :             PTIO(ERR,"*SIGA");

  006ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006f1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006f4	48 83 e0 10	 and	 rax, 16
  006f8	48 85 c0	 test	 rax, rax
  006fb	74 6b		 je	 SHORT $LN52@s390_signa
  006fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00705	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0070b	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00710	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00715	48 23 d1	 and	 rdx, rcx
  00718	48 8b ca	 mov	 rcx, rdx
  0071b	8b c9		 mov	 ecx, ecx
  0071d	ba 08 00 00 00	 mov	 edx, 8
  00722	48 6b d2 01	 imul	 rdx, rdx, 1
  00726	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0072e	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00736	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0073f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00744	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179678
  0074b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00750	44 8b c9	 mov	 r9d, ecx
  00753	44 8b c2	 mov	 r8d, edx
  00756	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179679
  0075d	b9 10 00 00 00	 mov	 ecx, 16
  00762	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN52@s390_signa:
  00768	33 c0		 xor	 eax, eax
  0076a	85 c0		 test	 eax, eax
  0076c	0f 85 78 ff ff
	ff		 jne	 $LN24@s390_signa

; 133  :             regs->psw.cc = 3;

  00772	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077a	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN51@s390_signa:

; 134  :         }
; 135  : #else
; 136  :         /* No signalling required for sync requests as we emulate
; 137  :            a real machine */
; 138  :         regs->psw.cc = 0;
; 139  : #endif
; 140  :         break;

  0077e	e9 88 00 00 00	 jmp	 $LN14@s390_signa
$LN53@s390_signa:
$LN27@s390_signa:

; 141  : 
; 142  : #if SIGA_FC_MAX >= SIGA_FC_M
; 143  :     case SIGA_FC_M:
; 144  :         if(dev->hnd->siga_m)
; 145  :             regs->psw.cc = (dev->hnd->siga_m) (dev, regs->GR_L(2) );
; 146  :         else
; 147  :         {
; 148  :             PTIO(ERR,"*SIGA");
; 149  :             regs->psw.cc = 3;
; 150  :         }
; 151  :         break;
; 152  : #endif
; 153  : 
; 154  :     default:
; 155  :         PTIO(ERR,"*SIGA");

  00783	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0078a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0078d	48 83 e0 10	 and	 rax, 16
  00791	48 85 c0	 test	 rax, rax
  00794	74 6b		 je	 SHORT $LN54@s390_signa
  00796	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  007a4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  007a9	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  007ae	48 23 d1	 and	 rdx, rcx
  007b1	48 8b ca	 mov	 rcx, rdx
  007b4	8b c9		 mov	 ecx, ecx
  007b6	ba 08 00 00 00	 mov	 edx, 8
  007bb	48 6b d2 01	 imul	 rdx, rdx, 1
  007bf	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  007c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  007cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179682
  007e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e9	44 8b c9	 mov	 r9d, ecx
  007ec	44 8b c2	 mov	 r8d, edx
  007ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179683
  007f6	b9 10 00 00 00	 mov	 ecx, 16
  007fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@s390_signa:
  00801	33 c0		 xor	 eax, eax
  00803	85 c0		 test	 eax, eax
  00805	0f 85 78 ff ff
	ff		 jne	 $LN27@s390_signa
$LN14@s390_signa:

; 156  : 
; 157  :     }
; 158  : 
; 159  :     release_lock (&dev->lock);

  0080b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00810	48 83 c0 38	 add	 rax, 56			; 00000038H
  00814	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179684
  0081b	48 8b c8	 mov	 rcx, rax
  0081e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@s390_signa:
$LN55@s390_signa:

; 160  : }

  00824	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0082b	c3		 ret	 0
s390_signal_adapter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
END
