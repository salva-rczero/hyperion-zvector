; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	cachestats_cmd
PUBLIC	cache_nbr
PUBLIC	cache_busy
PUBLIC	cache_empty
PUBLIC	cache_waiters
PUBLIC	cache_size
PUBLIC	cache_hits
PUBLIC	cache_misses
PUBLIC	cache_busy_percent
PUBLIC	cache_empty_percent
PUBLIC	cache_hit_percent
PUBLIC	cache_lookup
PUBLIC	cache_scan
PUBLIC	cache_lock
PUBLIC	cache_unlock
PUBLIC	cache_wait
PUBLIC	cache_getkey
PUBLIC	cache_setkey
PUBLIC	cache_getflag
PUBLIC	cache_setflag
PUBLIC	cache_getage
PUBLIC	cache_setage
PUBLIC	cache_getbuf
PUBLIC	cache_setbuf
PUBLIC	cache_getlen
PUBLIC	cache_getval
PUBLIC	cache_setval
PUBLIC	cache_release
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp__ctime64:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_destroy_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
cacheblk DB	0380H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ctime DD	imagerel ctime
	DD	imagerel ctime+25
	DD	imagerel $unwind$ctime
$pdata$cachestats_cmd DD imagerel $LN28
	DD	imagerel $LN28+2988
	DD	imagerel $unwind$cachestats_cmd
$pdata$cache_nbr DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$cache_nbr
$pdata$cache_busy DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$cache_busy
$pdata$cache_empty DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$cache_empty
$pdata$cache_waiters DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$cache_waiters
$pdata$cache_size DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$cache_size
$pdata$cache_hits DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$cache_hits
$pdata$cache_misses DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$cache_misses
$pdata$cache_busy_percent DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$cache_busy_percent
$pdata$cache_empty_percent DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$cache_empty_percent
$pdata$cache_hit_percent DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$cache_hit_percent
$pdata$cache_lookup DD imagerel $LN23
	DD	imagerel $LN23+768
	DD	imagerel $unwind$cache_lookup
$pdata$cache_scan DD imagerel $LN8
	DD	imagerel $LN8+139
	DD	imagerel $unwind$cache_scan
$pdata$cache_lock DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$cache_lock
$pdata$cache_unlock DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$cache_unlock
$pdata$cache_wait DD imagerel $LN5
	DD	imagerel $LN5+272
	DD	imagerel $unwind$cache_wait
$pdata$cache_getkey DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$cache_getkey
$pdata$cache_setkey DD imagerel $LN7
	DD	imagerel $LN7+285
	DD	imagerel $unwind$cache_setkey
$pdata$cache_getflag DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$cache_getflag
$pdata$cache_setflag DD imagerel $LN11
	DD	imagerel $LN11+625
	DD	imagerel $unwind$cache_setflag
$pdata$cache_getage DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$cache_getage
$pdata$cache_setage DD imagerel $LN5
	DD	imagerel $LN5+252
	DD	imagerel $unwind$cache_setage
$pdata$cache_getbuf DD imagerel $LN6
	DD	imagerel $LN6+439
	DD	imagerel $unwind$cache_getbuf
$pdata$cache_setbuf DD imagerel $LN4
	DD	imagerel $LN4+304
	DD	imagerel $unwind$cache_setbuf
$pdata$cache_getlen DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$cache_getlen
$pdata$cache_getval DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$cache_getval
$pdata$cache_setval DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$cache_setval
$pdata$cache_release DD imagerel $LN8
	DD	imagerel $LN8+543
	DD	imagerel $unwind$cache_release
$pdata$cache_destroy DD imagerel cache_destroy
	DD	imagerel cache_destroy+88
	DD	imagerel $unwind$cache_destroy
$pdata$cache_check_cache DD imagerel cache_check_cache
	DD	imagerel cache_check_cache+152
	DD	imagerel $unwind$cache_check_cache
$pdata$cache_check DD imagerel cache_check
	DD	imagerel cache_check+72
	DD	imagerel $unwind$cache_check
$pdata$cache_isbusy DD imagerel cache_isbusy
	DD	imagerel cache_isbusy+79
	DD	imagerel $unwind$cache_isbusy
$pdata$cache_isempty DD imagerel cache_isempty
	DD	imagerel cache_isempty+148
	DD	imagerel $unwind$cache_isempty
$pdata$cache_allocbuf DD imagerel cache_allocbuf
	DD	imagerel cache_allocbuf+852
	DD	imagerel $unwind$cache_allocbuf
$pdata$cache_destroy_locked DD imagerel cache_destroy_locked
	DD	imagerel cache_destroy_locked+265
	DD	imagerel $unwind$cache_destroy_locked
$pdata$cache_create_locked DD imagerel cache_create_locked
	DD	imagerel cache_create_locked+529
	DD	imagerel $unwind$cache_create_locked
pdata	ENDS
_DATA	SEGMENT
$SG159178 DB	'cache.c:175', 00H
$SG159357 DB	'I', 00H
	ORG $+2
$SG159183 DB	'cache.c:182', 00H
$SG159362 DB	'I', 00H
	ORG $+2
$SG159190 DB	'cache.c:208', 00H
$SG159367 DB	'I', 00H
	ORG $+2
$SG159234 DB	'cache.c:258', 00H
$SG159372 DB	'I', 00H
	ORG $+2
$SG159324 DB	'cache.c:366', 00H
$SG159377 DB	'I', 00H
	ORG $+2
$SG159354 DB	'cache.c:383', 00H
$SG159382 DB	'I', 00H
	ORG $+2
$SG159356 DB	'Cache[%d] ....... not created', 00H
	ORG $+2
$SG159358 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159359 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159360 DB	'cache.c', 00H
$SG159361 DB	'Cache............ %10d', 00H
	ORG $+1
$SG159363 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159364 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159365 DB	'cache.c', 00H
$SG159366 DB	'nbr ............. %10d', 00H
	ORG $+1
$SG159368 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159369 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159370 DB	'cache.c', 00H
$SG159371 DB	'busy ............ %10d', 00H
	ORG $+1
$SG159373 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159374 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159375 DB	'cache.c', 00H
$SG159376 DB	'busy%% ........... %10d', 00H
$SG159378 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159379 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159380 DB	'cache.c', 00H
$SG159381 DB	'empty ........... %10d', 00H
	ORG $+1
$SG159383 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159384 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159385 DB	'cache.c', 00H
$SG159386 DB	'waiters ......... %10d', 00H
	ORG $+1
$SG159387 DB	'I', 00H
	ORG $+2
$SG159392 DB	'I', 00H
	ORG $+2
$SG159388 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159389 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159390 DB	'cache.c', 00H
$SG159391 DB	'waits ........... %10d', 00H
	ORG $+1
$SG159393 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159394 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159395 DB	'cache.c', 00H
$SG159396 DB	'buf size ........ %10lld', 00H
	ORG $+3
$SG159397 DB	'I', 00H
	ORG $+2
$SG159398 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159399 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159400 DB	'cache.c', 00H
$SG159401 DB	'hits ............ %10lld', 00H
	ORG $+3
$SG159402 DB	'I', 00H
	ORG $+2
$SG159403 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159404 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159405 DB	'cache.c', 00H
$SG159406 DB	'fast hits ....... %10lld', 00H
	ORG $+3
$SG159407 DB	'I', 00H
	ORG $+2
$SG159408 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159409 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159410 DB	'cache.c', 00H
$SG159411 DB	'misses .......... %10lld', 00H
	ORG $+3
$SG159412 DB	'I', 00H
	ORG $+2
$SG159413 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159414 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159415 DB	'cache.c', 00H
$SG159416 DB	'hit%% ............ %10d', 00H
$SG159417 DB	'I', 00H
	ORG $+2
$SG159422 DB	'I', 00H
	ORG $+2
$SG159418 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159419 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159420 DB	'cache.c', 00H
$SG159421 DB	'age ............. %10lld', 00H
	ORG $+3
$SG159426 DB	'none', 0aH, 00H
	ORG $+2
$SG159428 DB	'I', 00H
	ORG $+2
$SG159423 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159424 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159425 DB	'cache.c', 00H
$SG159427 DB	'last adjusted ... %s', 00H
	ORG $+3
$SG159429 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159430 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159431 DB	'cache.c', 00H
$SG159432 DB	'none', 0aH, 00H
	ORG $+2
$SG159433 DB	'last wait ....... %s', 00H
	ORG $+3
$SG159434 DB	'I', 00H
	ORG $+2
$SG159439 DB	'I', 00H
	ORG $+2
$SG159435 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159436 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159437 DB	'cache.c', 00H
$SG159438 DB	'adjustments ..... %10d', 00H
	ORG $+1
$SG159440 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159441 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159442 DB	'cache.c', 00H
$SG159444 DB	'[%4d] %16.16llx %8.8x %10p %6d %10lld', 00H
	ORG $+2
$SG159445 DB	'I', 00H
	ORG $+2
$SG159477 DB	'E', 00H
	ORG $+2
$SG159446 DB	'HHC02294%s %s', 0aH, 00H
	ORG $+1
$SG159447 DB	'cachestats_cmd', 00H
	ORG $+1
$SG159448 DB	'cache.c', 00H
$SG159449 DB	'cache.c:457', 00H
$SG159535 DB	'E', 00H
	ORG $+2
$SG159461 DB	'cache.c:469', 00H
$SG159539 DB	'W', 00H
	ORG $+2
$SG159472 DB	'cache.c:496', 00H
$SG159546 DB	'E', 00H
	ORG $+2
$SG159473 DB	'&cacheblk[ix].lock', 00H
	ORG $+5
$SG159474 DB	'cache.c:497', 00H
	ORG $+4
$SG159476 DB	'cache()', 00H
$SG159478 DB	'HHC00011%s Function %s failed; cache %d size %d: [%02d] '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG159479 DB	'cache_create_locked', 00H
	ORG $+4
$SG159480 DB	'cache.c', 00H
$SG159485 DB	'cache.c:515', 00H
	ORG $+4
$SG159486 DB	'cache.c:519', 00H
	ORG $+4
$SG159502 DB	'cache.c:543', 00H
	ORG $+4
$SG159503 DB	'cache.c:548', 00H
	ORG $+4
$SG159534 DB	'calloc()', 00H
	ORG $+7
$SG159536 DB	'HHC00011%s Function %s failed; cache %d size %d: [%02d] '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG159537 DB	'cache_allocbuf', 00H
	ORG $+1
$SG159538 DB	'cache.c', 00H
$SG159540 DB	'HHC00012%s Releasing inactive buffer storage', 0aH, 00H
	ORG $+2
$SG159541 DB	'cache_allocbuf', 00H
	ORG $+1
$SG159542 DB	'cache.c', 00H
$SG159545 DB	'calloc()', 00H
	ORG $+7
$SG159547 DB	'HHC00011%s Function %s failed; cache %d size %d: [%02d] '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG159548 DB	'cache_allocbuf', 00H
	ORG $+1
$SG159549 DB	'cache.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cachestats_cmd
	DD	023H
	DD	0b90H
voltbl	ENDS
xdata	SEGMENT
$unwind$ctime DD 010901H
	DD	04209H
$unwind$cachestats_cmd DD 062b19H
	DD	0230119H
	DD	060117012H
	DD	0300f5010H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$cache_nbr DD 010801H
	DD	04208H
$unwind$cache_busy DD 010801H
	DD	04208H
$unwind$cache_empty DD 010801H
	DD	04208H
$unwind$cache_waiters DD 010801H
	DD	04208H
$unwind$cache_size DD 010801H
	DD	04208H
$unwind$cache_hits DD 010801H
	DD	04208H
$unwind$cache_misses DD 010801H
	DD	04208H
$unwind$cache_busy_percent DD 010801H
	DD	06208H
$unwind$cache_empty_percent DD 010801H
	DD	06208H
$unwind$cache_hit_percent DD 010801H
	DD	06208H
$unwind$cache_lookup DD 011201H
	DD	06212H
$unwind$cache_scan DD 011201H
	DD	06212H
$unwind$cache_lock DD 010801H
	DD	04208H
$unwind$cache_unlock DD 010801H
	DD	04208H
$unwind$cache_wait DD 010801H
	DD	04208H
$unwind$cache_getkey DD 010c01H
	DD	0420cH
$unwind$cache_setkey DD 011101H
	DD	06211H
$unwind$cache_getflag DD 010c01H
	DD	0420cH
$unwind$cache_setflag DD 011601H
	DD	06216H
$unwind$cache_getage DD 010c01H
	DD	0420cH
$unwind$cache_setage DD 010c01H
	DD	0820cH
$unwind$cache_getbuf DD 011101H
	DD	04211H
$unwind$cache_setbuf DD 011601H
	DD	06216H
$unwind$cache_getlen DD 010c01H
	DD	0420cH
$unwind$cache_getval DD 010c01H
	DD	0420cH
$unwind$cache_setval DD 011101H
	DD	06211H
$unwind$cache_release DD 021201H
	DD	0700e7212H
$unwind$cache_destroy DD 010801H
	DD	06208H
$unwind$cache_check_cache DD 010801H
	DD	06208H
$unwind$cache_check DD 010c01H
	DD	0420cH
$unwind$cache_isbusy DD 010c01H
	DD	0220cH
$unwind$cache_isempty DD 010c01H
	DD	0220cH
$unwind$cache_allocbuf DD 021401H
	DD	0110114H
$unwind$cache_destroy_locked DD 020901H
	DD	070055209H
$unwind$cache_create_locked DD 020b01H
	DD	011010bH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv74 = 96
tv158 = 100
tv148 = 104
tv152 = 112
ix$ = 144
cache_create_locked PROC

; 485  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 486  :     cache_destroy_locked (ix);

  0000b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  00012	e8 00 00 00 00	 call	 cache_destroy_locked

; 487  :     cacheblk[ix].magic = CACHE_MAGIC;

  00017	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0001f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002a	c7 04 01 10 ce
	ca 01		 mov	 DWORD PTR [rcx+rax], 30068240 ; 01cace10H

; 488  : 
; 489  :     // FIXME: See the note in cache.h about CACHE_DEFAULT_L2_NBR
; 490  : 
; 491  :     cacheblk[ix].nbr = ix != CACHE_L2 ? CACHE_DEFAULT_NBR

  00031	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR ix$[rsp], 1
  00039	74 0a		 je	 SHORT $LN4@cache_crea
  0003b	c7 44 24 60 e5
	00 00 00	 mov	 DWORD PTR tv74[rsp], 229 ; 000000e5H
  00043	eb 08		 jmp	 SHORT $LN5@cache_crea
$LN4@cache_crea:
  00045	c7 44 24 60 07
	04 00 00	 mov	 DWORD PTR tv74[rsp], 1031 ; 00000407H
$LN5@cache_crea:
  0004d	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00055	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00060	8b 54 24 60	 mov	 edx, DWORD PTR tv74[rsp]
  00064	89 54 01 04	 mov	 DWORD PTR [rcx+rax+4], edx

; 492  :                                       : CACHE_DEFAULT_L2_NBR;
; 493  : 
; 494  :     cacheblk[ix].empty = cacheblk[ix].nbr;

  00068	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00070	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0007b	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR ix$[rsp]
  00083	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  00087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  0008e	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00092	41 89 44 10 0c	 mov	 DWORD PTR [r8+rdx+12], eax

; 495  : 
; 496  :     initialize_lock (&cacheblk[ix].lock);

  00097	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0009f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000aa	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  000af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159472
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159473
  000bd	48 8b c8	 mov	 rcx, rax
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 497  :     initialize_condition (&cacheblk[ix].waitcond);

  000c6	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  000ce	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000d9	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159474
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 498  : 
; 499  :     cacheblk[ix].cache = calloc (cacheblk[ix].nbr, sizeof(CACHE));

  000ee	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  000f6	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00101	48 63 44 01 04	 movsxd	 rax, DWORD PTR [rcx+rax+4]
  00106	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00114	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0011c	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00127	48 89 44 0a 50	 mov	 QWORD PTR [rdx+rcx+80], rax

; 500  : 
; 501  :     if (cacheblk[ix].cache == NULL)

  0012c	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00134	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0013f	48 83 7c 01 50
	00		 cmp	 QWORD PTR [rcx+rax+80], 0
  00145	0f 85 bc 00 00
	00		 jne	 $LN2@cache_crea

; 502  :     {
; 503  :         // "Function %s failed; cache %d size %d: [%02d] %s"
; 504  :         WRMSG (HHC00011, "E", "cache()", ix,

  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00151	8b 08		 mov	 ecx, DWORD PTR [rax]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00159	48 89 44 24 68	 mov	 QWORD PTR tv148[rsp], rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00164	48 89 44 24 70	 mov	 QWORD PTR tv152[rsp], rax
  00169	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00171	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  0017c	6b 4c 0a 04 28	 imul	 ecx, DWORD PTR [rdx+rcx+4], 40 ; 00000028H
  00181	89 4c 24 64	 mov	 DWORD PTR tv158[rsp], ecx
  00185	b9 01 00 00 00	 mov	 ecx, 1
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00190	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv148[rsp]
  00195	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0019a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv152[rsp]
  0019f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001a1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001a5	8b 4c 24 64	 mov	 ecx, DWORD PTR tv158[rsp]
  001a9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001ad	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  001b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159476
  001bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159477
  001cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159478
  001d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159479
  001ee	ba fa 01 00 00	 mov	 edx, 506		; 000001faH
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159480
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 505  :             (int)(cacheblk[ix].nbr * (int)sizeof(CACHE)),
; 506  :             errno, strerror(errno));
; 507  :         return -1;

  00200	b8 ff ff ff ff	 mov	 eax, -1
  00205	eb 02		 jmp	 SHORT $LN1@cache_crea
$LN2@cache_crea:

; 508  :     }
; 509  :     return 0;

  00207	33 c0		 xor	 eax, eax
$LN1@cache_crea:

; 510  : }

  00209	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00210	c3		 ret	 0
cache_create_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
i$ = 32
ix$ = 64
cache_destroy_locked PROC

; 465  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 466  :     int i;
; 467  :     if (cacheblk[ix].magic == CACHE_MAGIC)

  00009	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0000e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00019	81 3c 01 10 ce
	ca 01		 cmp	 DWORD PTR [rcx+rax], 30068240 ; 01cace10H
  00020	0f 85 b9 00 00
	00		 jne	 $LN5@cache_dest

; 468  :     {
; 469  :         destroy_lock (&cacheblk[ix].lock);

  00026	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0002b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00036	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159461
  00042	48 8b c8	 mov	 rcx, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 470  :         destroy_condition (&cacheblk[ix].waitcond);

  0004b	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00050	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0005b	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  00060	48 8b c8	 mov	 rcx, rax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 471  : 
; 472  :         if (cacheblk[ix].cache)

  00069	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0006e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00079	48 83 7c 01 50
	00		 cmp	 QWORD PTR [rcx+rax+80], 0
  0007f	74 5e		 je	 SHORT $LN6@cache_dest

; 473  :         {
; 474  :             for (i = 0; i < cacheblk[ix].nbr; i++)

  00081	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00089	eb 0a		 jmp	 SHORT $LN4@cache_dest
$LN2@cache_dest:
  0008b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@cache_dest:
  00095	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0009a	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000a5	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  000a9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000ad	7d 15		 jge	 SHORT $LN3@cache_dest

; 475  :                 cache_release(ix, i, CACHE_FREEBUF);

  000af	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b5	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000b9	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  000bd	e8 00 00 00 00	 call	 cache_release
  000c2	eb c7		 jmp	 SHORT $LN2@cache_dest
$LN3@cache_dest:

; 476  : 
; 477  :             free (cacheblk[ix].cache);

  000c4	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000c9	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000d4	48 8b 4c 01 50	 mov	 rcx, QWORD PTR [rcx+rax+80]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@cache_dest:
$LN5@cache_dest:

; 478  :         }
; 479  :     }
; 480  :     memset(&cacheblk[ix], 0, sizeof(CACHEBLK));

  000df	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000e4	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	48 8b f8	 mov	 rdi, rax
  000f8	33 c0		 xor	 eax, eax
  000fa	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000ff	f3 aa		 rep stosb

; 481  :     return 0;

  00101	33 c0		 xor	 eax, eax

; 482  : }

  00103	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
cache_destroy_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv88 = 96
tv92 = 104
tv184 = 112
tv188 = 120
ix$ = 144
i$ = 152
len$ = 160
cache_allocbuf PROC

; 572  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 573  :     cacheblk[ix].cache[i].buf = calloc (len, 1);

  00014	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0001c	ba 01 00 00 00	 mov	 edx, 1
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002a	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00032	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  0003d	4c 63 84 24 98
	00 00 00	 movsxd	 r8, DWORD PTR i$[rsp]
  00045	4d 6b c0 28	 imul	 r8, r8, 40		; 00000028H
  00049	48 8b 4c 0a 50	 mov	 rcx, QWORD PTR [rdx+rcx+80]
  0004e	4a 89 44 01 10	 mov	 QWORD PTR [rcx+r8+16], rax

; 574  :     if (cacheblk[ix].cache[i].buf == NULL) {

  00053	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0005b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00066	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  0006e	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00072	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00077	48 83 7c 10 10
	00		 cmp	 QWORD PTR [rax+rdx+16], 0
  0007d	0f 85 5f 02 00
	00		 jne	 $LN5@cache_allo

; 575  :         WRMSG (HHC00011, "E", "calloc()", ix, len, errno, strerror(errno));

  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00089	8b 08		 mov	 ecx, DWORD PTR [rax]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00091	48 89 44 24 60	 mov	 QWORD PTR tv88[rsp], rax
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009c	48 89 44 24 68	 mov	 QWORD PTR tv92[rsp], rax
  000a1	b9 01 00 00 00	 mov	 ecx, 1
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv88[rsp]
  000b1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv92[rsp]
  000bb	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000bd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000c1	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  000c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000cc	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  000d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159534
  000de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159535
  000ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159536
  000f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	41 b9 03 00 00
	00		 mov	 r9d, 3
  00106	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159537
  0010d	ba 3f 02 00 00	 mov	 edx, 575		; 0000023fH
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159538
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 576  :         WRMSG (HHC00012, "W");

  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159539
  00131	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159540
  0013d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00142	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00147	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159541
  00154	ba 40 02 00 00	 mov	 edx, 576		; 00000240H
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159542
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 577  :         for (i = 0; i < cacheblk[ix].nbr; i++)

  00166	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00171	eb 10		 jmp	 SHORT $LN4@cache_allo
$LN2@cache_allo:
  00173	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@cache_allo:
  00183	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0018b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00196	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0019a	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  001a1	7d 32		 jge	 SHORT $LN3@cache_allo

; 578  :             if (!cache_isbusy(ix, i)) cache_release(ix, i, CACHE_FREEBUF);

  001a3	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001aa	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  001b1	e8 00 00 00 00	 call	 cache_isbusy
  001b6	85 c0		 test	 eax, eax
  001b8	75 19		 jne	 SHORT $LN6@cache_allo
  001ba	41 b8 01 00 00
	00		 mov	 r8d, 1
  001c0	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001c7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  001ce	e8 00 00 00 00	 call	 cache_release
$LN6@cache_allo:
  001d3	eb 9e		 jmp	 SHORT $LN2@cache_allo
$LN3@cache_allo:

; 579  :         cacheblk[ix].cache[i].buf = calloc (len, 1);

  001d5	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001dd	ba 01 00 00 00	 mov	 edx, 1
  001e2	48 8b c8	 mov	 rcx, rax
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  001eb	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  001f3	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  001fe	4c 63 84 24 98
	00 00 00	 movsxd	 r8, DWORD PTR i$[rsp]
  00206	4d 6b c0 28	 imul	 r8, r8, 40		; 00000028H
  0020a	48 8b 4c 0a 50	 mov	 rcx, QWORD PTR [rdx+rcx+80]
  0020f	4a 89 44 01 10	 mov	 QWORD PTR [rcx+r8+16], rax

; 580  :         if (cacheblk[ix].cache[i].buf == NULL) {

  00214	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  0021c	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00227	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  0022f	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00233	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00238	48 83 7c 10 10
	00		 cmp	 QWORD PTR [rax+rdx+16], 0
  0023e	0f 85 9e 00 00
	00		 jne	 $LN7@cache_allo

; 581  :             WRMSG (HHC00011, "E", "calloc()", ix, len, errno, strerror(errno));

  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0024a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00252	48 89 44 24 70	 mov	 QWORD PTR tv184[rsp], rax
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0025d	48 89 44 24 78	 mov	 QWORD PTR tv188[rsp], rax
  00262	b9 01 00 00 00	 mov	 ecx, 1
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv184[rsp]
  00272	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00277	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv188[rsp]
  0027c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0027e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00282	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00289	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0028d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ix$[rsp]
  00294	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00298	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159545
  0029f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159546
  002ab	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159547
  002b7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159548
  002ce	ba 45 02 00 00	 mov	 edx, 581		; 00000245H
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159549
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 582  :             return;

  002e0	eb 6a		 jmp	 SHORT $LN1@cache_allo
$LN7@cache_allo:
$LN5@cache_allo:

; 583  :         }
; 584  :     }
; 585  :     cacheblk[ix].cache[i].len = len;

  002e2	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  002ea	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  002f5	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  002fd	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00301	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00306	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0030d	89 4c 10 0c	 mov	 DWORD PTR [rax+rdx+12], ecx

; 586  :     cacheblk[ix].size += len;

  00311	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ix$[rsp]
  00319	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0031d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00324	48 63 94 24 a0
	00 00 00	 movsxd	 rdx, DWORD PTR len$[rsp]
  0032c	48 03 54 01 18	 add	 rdx, QWORD PTR [rcx+rax+24]
  00331	48 8b c2	 mov	 rax, rdx
  00334	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0033c	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00340	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00347	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax
$LN1@cache_allo:

; 587  : }

  0034c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00353	c3		 ret	 0
cache_allocbuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv91 = 0
ix$ = 32
i$ = 40
cache_isempty PROC

; 565  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 566  :     return (cacheblk[ix].cache[i].key  == 0

  0000c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00011	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0001c	48 63 54 24 28	 movsxd	 rdx, DWORD PTR i$[rsp]
  00021	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00025	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0002a	48 83 3c 10 00	 cmp	 QWORD PTR [rax+rdx], 0
  0002f	75 54		 jne	 SHORT $LN3@cache_isem
  00031	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00036	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00041	48 63 54 24 28	 movsxd	 rdx, DWORD PTR i$[rsp]
  00046	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0004a	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0004f	83 7c 10 08 00	 cmp	 DWORD PTR [rax+rdx+8], 0
  00054	75 2f		 jne	 SHORT $LN3@cache_isem
  00056	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0005b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00066	48 63 54 24 28	 movsxd	 rdx, DWORD PTR i$[rsp]
  0006b	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0006f	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00074	48 83 7c 10 20
	00		 cmp	 QWORD PTR [rax+rdx+32], 0
  0007a	75 09		 jne	 SHORT $LN3@cache_isem
  0007c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv91[rsp], 1
  00083	eb 07		 jmp	 SHORT $LN4@cache_isem
$LN3@cache_isem:
  00085	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv91[rsp], 0
$LN4@cache_isem:
  0008c	8b 04 24	 mov	 eax, DWORD PTR tv91[rsp]

; 567  :          && cacheblk[ix].cache[i].flag == 0
; 568  :          && cacheblk[ix].cache[i].age  == 0);
; 569  : }

  0008f	48 83 c4 18	 add	 rsp, 24
  00093	c3		 ret	 0
cache_isempty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv74 = 0
ix$ = 32
i$ = 40
cache_isbusy PROC

; 560  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 561  :     return ((cacheblk[ix].cache[i].flag & CACHE_BUSY) != 0);

  0000c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00011	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0001c	48 63 54 24 28	 movsxd	 rdx, DWORD PTR i$[rsp]
  00021	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00025	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0002a	8b 44 10 08	 mov	 eax, DWORD PTR [rax+rdx+8]
  0002e	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00033	85 c0		 test	 eax, eax
  00035	74 09		 je	 SHORT $LN3@cache_isbu
  00037	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv74[rsp], 1
  0003e	eb 07		 jmp	 SHORT $LN4@cache_isbu
$LN3@cache_isbu:
  00040	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN4@cache_isbu:
  00047	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]

; 562  : }

  0004a	48 83 c4 18	 add	 rsp, 24
  0004e	c3		 ret	 0
cache_isbusy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_check PROC

; 553  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 554  :     if (cache_check_ix(ix) || i < 0 || i >= cacheblk[ix].nbr)

  0000c	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00010	e8 00 00 00 00	 call	 cache_check_ix
  00015	85 c0		 test	 eax, eax
  00017	75 21		 jne	 SHORT $LN3@cache_chec
  00019	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  0001e	7c 1a		 jl	 SHORT $LN3@cache_chec
  00020	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00025	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00030	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00034	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00038	7c 07		 jl	 SHORT $LN2@cache_chec
$LN3@cache_chec:

; 555  :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	eb 02		 jmp	 SHORT $LN1@cache_chec
$LN2@cache_chec:

; 556  :     return 0;

  00041	33 c0		 xor	 eax, eax
$LN1@cache_chec:

; 557  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
cache_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv78 = 32
rc$ = 36
ix$ = 64
cache_check_cache PROC

; 541  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 542  :     int rc;
; 543  :     OBTAIN_GLOBAL_CACHE_LOCK();

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000f	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159502
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 544  :     {
; 545  :         rc = cache_check_ix(ix) ||

  00025	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00029	e8 00 00 00 00	 call	 cache_check_ix
  0002e	85 c0		 test	 eax, eax
  00030	75 30		 jne	 SHORT $LN4@cache_chec
  00032	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00037	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00042	81 3c 01 10 ce
	ca 01		 cmp	 DWORD PTR [rcx+rax], 30068240 ; 01cace10H
  00049	74 0d		 je	 SHORT $LN3@cache_chec
  0004b	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0004f	e8 00 00 00 00	 call	 cache_create_locked
  00054	85 c0		 test	 eax, eax
  00056	75 0a		 jne	 SHORT $LN4@cache_chec
$LN3@cache_chec:
  00058	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00060	eb 08		 jmp	 SHORT $LN5@cache_chec
$LN4@cache_chec:
  00062	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN5@cache_chec:
  0006a	8b 44 24 20	 mov	 eax, DWORD PTR tv78[rsp]
  0006e	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 546  :             (cacheblk[ix].magic != CACHE_MAGIC && cache_create_locked(ix));
; 547  :     }
; 548  :     RELEASE_GLOBAL_CACHE_LOCK();

  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00079	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159503
  00086	48 8b c8	 mov	 rcx, rax
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 549  :     return rc;

  0008f	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]

; 550  : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
cache_check_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 8
cache_check_ix PROC

; 535  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 536  :     if (ix < 0 || ix >= CACHE_MAX_INDEX) return -1;

  00004	83 7c 24 08 00	 cmp	 DWORD PTR ix$[rsp], 0
  00009	7c 07		 jl	 SHORT $LN3@cache_chec
  0000b	83 7c 24 08 08	 cmp	 DWORD PTR ix$[rsp], 8
  00010	7c 07		 jl	 SHORT $LN2@cache_chec
$LN3@cache_chec:
  00012	b8 ff ff ff ff	 mov	 eax, -1
  00017	eb 02		 jmp	 SHORT $LN1@cache_chec
$LN2@cache_chec:

; 537  :     return 0;

  00019	33 c0		 xor	 eax, eax
$LN1@cache_chec:

; 538  : }

  0001b	c3		 ret	 0
cache_check_ix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
rc$ = 32
ix$ = 64
cache_destroy PROC

; 513  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 514  :     int rc;
; 515  :     OBTAIN_GLOBAL_CACHE_LOCK();

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000f	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159485
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 516  :     {
; 517  :         rc = cache_destroy_locked(ix);

  00025	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00029	e8 00 00 00 00	 call	 cache_destroy_locked
  0002e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 518  :     }
; 519  :     RELEASE_GLOBAL_CACHE_LOCK();

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00039	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159486
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 520  :     return rc;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 521  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
cache_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
len$ = 32
empty$ = 36
busy$ = 40
buf$ = 48
ix$ = 80
i$ = 88
flag$ = 96
cache_release PROC

; 339  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 340  :     void *buf;
; 341  :     int   len;
; 342  :     int   empty;
; 343  :     int   busy;
; 344  : 
; 345  :     if (cache_check(ix,i)) return -1;

  00012	8b 54 24 58	 mov	 edx, DWORD PTR i$[rsp]
  00016	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  0001a	e8 00 00 00 00	 call	 cache_check
  0001f	85 c0		 test	 eax, eax
  00021	74 0a		 je	 SHORT $LN2@cache_rele
  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 ec 01 00 00	 jmp	 $LN1@cache_rele
$LN2@cache_rele:

; 346  : 
; 347  :     empty = cache_isempty(ix, i);

  0002d	8b 54 24 58	 mov	 edx, DWORD PTR i$[rsp]
  00031	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00035	e8 00 00 00 00	 call	 cache_isempty
  0003a	89 44 24 24	 mov	 DWORD PTR empty$[rsp], eax

; 348  :     busy = cache_isbusy(ix, i);

  0003e	8b 54 24 58	 mov	 edx, DWORD PTR i$[rsp]
  00042	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00046	e8 00 00 00 00	 call	 cache_isbusy
  0004b	89 44 24 28	 mov	 DWORD PTR busy$[rsp], eax

; 349  : 
; 350  :     buf = cacheblk[ix].cache[i].buf;

  0004f	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00054	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0005f	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  00064	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00068	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0006d	48 8b 44 10 10	 mov	 rax, QWORD PTR [rax+rdx+16]
  00072	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 351  :     len = cacheblk[ix].cache[i].len;

  00077	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0007c	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00087	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  0008c	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00090	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00095	8b 44 10 0c	 mov	 eax, DWORD PTR [rax+rdx+12]
  00099	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 352  : 
; 353  :     memset(&cacheblk[ix].cache[i], 0, sizeof(CACHE));

  0009d	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  000a2	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000ad	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  000b2	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000b6	48 03 54 01 50	 add	 rdx, QWORD PTR [rcx+rax+80]
  000bb	48 8b c2	 mov	 rax, rdx
  000be	48 8b f8	 mov	 rdi, rax
  000c1	33 c0		 xor	 eax, eax
  000c3	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000c8	f3 aa		 rep stosb

; 354  : 
; 355  :     if ((flag & CACHE_FREEBUF) && buf != NULL) {

  000ca	8b 44 24 60	 mov	 eax, DWORD PTR flag$[rsp]
  000ce	83 e0 01	 and	 eax, 1
  000d1	85 c0		 test	 eax, eax
  000d3	74 56		 je	 SHORT $LN3@cache_rele
  000d5	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000db	74 4e		 je	 SHORT $LN3@cache_rele

; 356  :         free (buf);

  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 357  :         cacheblk[ix].size -= len;

  000e8	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  000ed	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000f8	48 63 54 24 20	 movsxd	 rdx, DWORD PTR len$[rsp]
  000fd	48 8b 44 01 18	 mov	 rax, QWORD PTR [rcx+rax+24]
  00102	48 2b c2	 sub	 rax, rdx
  00105	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0010a	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00115	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 358  :         buf = NULL;

  0011a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR buf$[rsp], 0

; 359  :         len = 0;

  00123	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN3@cache_rele:

; 360  :     }
; 361  : 
; 362  :     cacheblk[ix].cache[i].buf = buf;

  0012b	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00130	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0013b	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  00140	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00144	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00149	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  0014e	48 89 4c 10 10	 mov	 QWORD PTR [rax+rdx+16], rcx

; 363  :     cacheblk[ix].cache[i].len = len;

  00153	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00158	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00163	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  00168	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0016c	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00171	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00175	89 4c 10 0c	 mov	 DWORD PTR [rax+rdx+12], ecx

; 364  : 
; 365  :     if (cacheblk[ix].waiters > 0)

  00179	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0017e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00189	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0018e	7e 25		 jle	 SHORT $LN4@cache_rele

; 366  :         signal_condition(&cacheblk[ix].waitcond);

  00190	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00195	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  001a0	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  001a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159324
  001ac	48 8b c8	 mov	 rcx, rax
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN4@cache_rele:

; 367  : 
; 368  :     if (!empty) cacheblk[ix].empty++;

  001b5	83 7c 24 24 00	 cmp	 DWORD PTR empty$[rsp], 0
  001ba	75 2a		 jne	 SHORT $LN5@cache_rele
  001bc	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  001c1	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  001cc	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  001d0	ff c0		 inc	 eax
  001d2	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ix$[rsp]
  001d7	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  001e2	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
$LN5@cache_rele:

; 369  :     if (busy) cacheblk[ix].busy--;

  001e6	83 7c 24 28 00	 cmp	 DWORD PTR busy$[rsp], 0
  001eb	74 2a		 je	 SHORT $LN6@cache_rele
  001ed	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  001f2	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  001fd	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  00201	ff c8		 dec	 eax
  00203	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00208	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00213	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax
$LN6@cache_rele:

; 370  : 
; 371  :     return 0;

  00217	33 c0		 xor	 eax, eax
$LN1@cache_rele:

; 372  : }

  00219	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0021d	5f		 pop	 rdi
  0021e	c3		 ret	 0
cache_release ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
rc$ = 32
ix$ = 64
i$ = 72
val$ = 80
cache_setval PROC

; 330  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 331  :     int rc;
; 332  :     if (cache_check(ix,i)) return -1;

  00011	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00019	e8 00 00 00 00	 call	 cache_check
  0001e	85 c0		 test	 eax, eax
  00020	74 07		 je	 SHORT $LN2@cache_setv
  00022	b8 ff ff ff ff	 mov	 eax, -1
  00027	eb 50		 jmp	 SHORT $LN1@cache_setv
$LN2@cache_setv:

; 333  :     rc = cacheblk[ix].cache[i].value;

  00029	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0002e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00039	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  0003e	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00042	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00047	8b 44 10 18	 mov	 eax, DWORD PTR [rax+rdx+24]
  0004b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 334  :     cacheblk[ix].cache[i].value = val;

  0004f	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00054	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0005f	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  00064	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00068	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0006d	8b 4c 24 50	 mov	 ecx, DWORD PTR val$[rsp]
  00071	89 4c 10 18	 mov	 DWORD PTR [rax+rdx+24], ecx

; 335  :     return rc;

  00075	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cache_setv:

; 336  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
cache_setval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_getval PROC

; 324  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 325  :     if (cache_check(ix,i)) return -1;

  0000c	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN2@cache_getv
  0001d	b8 ff ff ff ff	 mov	 eax, -1
  00022	eb 22		 jmp	 SHORT $LN1@cache_getv
$LN2@cache_getv:

; 326  :     return cacheblk[ix].cache[i].value;

  00024	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00029	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00034	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00039	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0003d	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00042	8b 44 10 18	 mov	 eax, DWORD PTR [rax+rdx+24]
$LN1@cache_getv:

; 327  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
cache_getval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_getlen PROC

; 318  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 319  :     if (cache_check(ix,i)) return -1;

  0000c	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN2@cache_getl
  0001d	b8 ff ff ff ff	 mov	 eax, -1
  00022	eb 22		 jmp	 SHORT $LN1@cache_getl
$LN2@cache_getl:

; 320  :     return cacheblk[ix].cache[i].len;

  00024	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00029	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00034	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00039	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0003d	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00042	8b 44 10 0c	 mov	 eax, DWORD PTR [rax+rdx+12]
$LN1@cache_getl:

; 321  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
cache_getlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
oldbuf$ = 32
ix$ = 64
i$ = 72
buf$ = 80
len$ = 88
cache_setbuf PROC

; 306  : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 307  :     void *oldbuf;
; 308  :     if (cache_check(ix,i)) return NULL;

  00016	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0001e	e8 00 00 00 00	 call	 cache_check
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN2@cache_setb
  00027	33 c0		 xor	 eax, eax
  00029	e9 fd 00 00 00	 jmp	 $LN1@cache_setb
$LN2@cache_setb:

; 309  :     oldbuf = cacheblk[ix].cache[i].buf;

  0002e	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00033	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0003e	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  00043	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00047	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0004c	48 8b 44 10 10	 mov	 rax, QWORD PTR [rax+rdx+16]
  00051	48 89 44 24 20	 mov	 QWORD PTR oldbuf$[rsp], rax

; 310  :     cacheblk[ix].size -= cacheblk[ix].cache[i].len;

  00056	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0005b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00066	48 63 54 24 40	 movsxd	 rdx, DWORD PTR ix$[rsp]
  0006b	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  0006f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  00076	4c 63 4c 24 48	 movsxd	 r9, DWORD PTR i$[rsp]
  0007b	4d 6b c9 28	 imul	 r9, r9, 40		; 00000028H
  0007f	49 8b 54 10 50	 mov	 rdx, QWORD PTR [r8+rdx+80]
  00084	4a 63 54 0a 0c	 movsxd	 rdx, DWORD PTR [rdx+r9+12]
  00089	48 8b 44 01 18	 mov	 rax, QWORD PTR [rcx+rax+24]
  0008e	48 2b c2	 sub	 rax, rdx
  00091	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00096	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000a1	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 311  :     cacheblk[ix].cache[i].buf = buf;

  000a6	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000ab	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000b6	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  000bb	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000bf	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  000c9	48 89 4c 10 10	 mov	 QWORD PTR [rax+rdx+16], rcx

; 312  :     cacheblk[ix].cache[i].len = len;

  000ce	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000d3	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000de	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  000e3	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000e7	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  000ec	8b 4c 24 58	 mov	 ecx, DWORD PTR len$[rsp]
  000f0	89 4c 10 0c	 mov	 DWORD PTR [rax+rdx+12], ecx

; 313  :     cacheblk[ix].size += len;

  000f4	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000f9	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00104	48 63 54 24 58	 movsxd	 rdx, DWORD PTR len$[rsp]
  00109	48 03 54 01 18	 add	 rdx, QWORD PTR [rcx+rax+24]
  0010e	48 8b c2	 mov	 rax, rdx
  00111	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00116	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00121	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 314  :     return oldbuf;

  00126	48 8b 44 24 20	 mov	 rax, QWORD PTR oldbuf$[rsp]
$LN1@cache_setb:

; 315  : }

  0012b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012f	c3		 ret	 0
cache_setbuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
len$ = 64
cache_getbuf PROC

; 290  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  :     if (cache_check(ix,i)) return NULL;

  00011	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00015	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00019	e8 00 00 00 00	 call	 cache_check
  0001e	85 c0		 test	 eax, eax
  00020	74 07		 je	 SHORT $LN2@cache_getb
  00022	33 c0		 xor	 eax, eax
  00024	e9 89 01 00 00	 jmp	 $LN1@cache_getb
$LN2@cache_getb:

; 292  :     if (len > 0
; 293  :      && cacheblk[ix].cache[i].buf != NULL
; 294  :      && cacheblk[ix].cache[i].len < len) {

  00029	83 7c 24 40 00	 cmp	 DWORD PTR len$[rsp], 0
  0002e	0f 8e 1c 01 00
	00		 jle	 $LN3@cache_getb
  00034	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00039	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00044	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00049	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0004d	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00052	48 83 7c 10 10
	00		 cmp	 QWORD PTR [rax+rdx+16], 0
  00058	0f 84 f2 00 00
	00		 je	 $LN3@cache_getb
  0005e	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00063	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0006e	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00073	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00077	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0007c	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00080	39 4c 10 0c	 cmp	 DWORD PTR [rax+rdx+12], ecx
  00084	0f 8d c6 00 00
	00		 jge	 $LN3@cache_getb

; 295  :         cacheblk[ix].size -= cacheblk[ix].cache[i].len;

  0008a	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  0008f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0009a	48 63 54 24 30	 movsxd	 rdx, DWORD PTR ix$[rsp]
  0009f	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  000a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  000aa	4c 63 4c 24 38	 movsxd	 r9, DWORD PTR i$[rsp]
  000af	4d 6b c9 28	 imul	 r9, r9, 40		; 00000028H
  000b3	49 8b 54 10 50	 mov	 rdx, QWORD PTR [r8+rdx+80]
  000b8	4a 63 54 0a 0c	 movsxd	 rdx, DWORD PTR [rdx+r9+12]
  000bd	48 8b 44 01 18	 mov	 rax, QWORD PTR [rcx+rax+24]
  000c2	48 2b c2	 sub	 rax, rdx
  000c5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000ca	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000d5	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 296  :         free (cacheblk[ix].cache[i].buf);

  000da	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  000df	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000ea	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  000ef	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000f3	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  000f8	48 8b 4c 10 10	 mov	 rcx, QWORD PTR [rax+rdx+16]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 297  :         cacheblk[ix].cache[i].buf = NULL;

  00103	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00108	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00113	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00118	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0011c	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00121	48 c7 44 10 10
	00 00 00 00	 mov	 QWORD PTR [rax+rdx+16], 0

; 298  :         cacheblk[ix].cache[i].len = 0;

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  0012f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0013a	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  0013f	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00143	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00148	c7 44 10 0c 00
	00 00 00	 mov	 DWORD PTR [rax+rdx+12], 0
$LN3@cache_getb:

; 299  :     }
; 300  :     if (cacheblk[ix].cache[i].buf == NULL && len > 0)

  00150	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00155	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00160	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00165	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00169	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0016e	48 83 7c 10 10
	00		 cmp	 QWORD PTR [rax+rdx+16], 0
  00174	75 19		 jne	 SHORT $LN4@cache_getb
  00176	83 7c 24 40 00	 cmp	 DWORD PTR len$[rsp], 0
  0017b	7e 12		 jle	 SHORT $LN4@cache_getb

; 301  :         cache_allocbuf (ix, i, len);

  0017d	44 8b 44 24 40	 mov	 r8d, DWORD PTR len$[rsp]
  00182	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00186	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0018a	e8 00 00 00 00	 call	 cache_allocbuf
$LN4@cache_getb:

; 302  :     return cacheblk[ix].cache[i].buf;

  0018f	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00194	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0019f	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  001a4	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  001a8	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  001ad	48 8b 44 10 10	 mov	 rax, QWORD PTR [rax+rdx+16]
$LN1@cache_getb:

; 303  : }

  001b2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001b6	c3		 ret	 0
cache_getbuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
empty$ = 32
tv95 = 40
oldage$ = 48
ix$ = 80
i$ = 88
cache_setage PROC

; 277  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 278  :     U64 oldage;
; 279  :     int empty;
; 280  : 
; 281  :     if (cache_check(ix,i)) return (U64)-1;

  0000c	8b 54 24 58	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 0c		 je	 SHORT $LN2@cache_seta
  0001d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00024	e9 ce 00 00 00	 jmp	 $LN1@cache_seta
$LN2@cache_seta:

; 282  :     empty = cache_isempty(ix, i);

  00029	8b 54 24 58	 mov	 edx, DWORD PTR i$[rsp]
  0002d	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00031	e8 00 00 00 00	 call	 cache_isempty
  00036	89 44 24 20	 mov	 DWORD PTR empty$[rsp], eax

; 283  :     oldage = cacheblk[ix].cache[i].age;

  0003a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0003f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0004a	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  0004f	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00053	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00058	48 8b 44 10 20	 mov	 rax, QWORD PTR [rax+rdx+32]
  0005d	48 89 44 24 30	 mov	 QWORD PTR oldage$[rsp], rax

; 284  :     cacheblk[ix].cache[i].age = ++cacheblk[ix].age;

  00062	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00067	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00072	48 8b 44 01 38	 mov	 rax, QWORD PTR [rcx+rax+56]
  00077	48 ff c0	 inc	 rax
  0007a	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0007f	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00084	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0008f	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv95[rsp]
  00094	48 89 54 01 38	 mov	 QWORD PTR [rcx+rax+56], rdx
  00099	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0009e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000a9	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  000ae	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000b2	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv95[rsp]
  000bc	48 89 4c 10 20	 mov	 QWORD PTR [rax+rdx+32], rcx

; 285  :     if (empty) cacheblk[ix].empty--;

  000c1	83 7c 24 20 00	 cmp	 DWORD PTR empty$[rsp], 0
  000c6	74 2a		 je	 SHORT $LN3@cache_seta
  000c8	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  000cd	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000d8	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  000dc	ff c8		 dec	 eax
  000de	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000e3	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000ee	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
$LN3@cache_seta:

; 286  :     return oldage;

  000f2	48 8b 44 24 30	 mov	 rax, QWORD PTR oldage$[rsp]
$LN1@cache_seta:

; 287  : }

  000f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fb	c3		 ret	 0
cache_setage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_getage PROC

; 271  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 272  :     if (cache_check(ix,i)) return (U64)-1;

  0000c	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 09		 je	 SHORT $LN2@cache_geta
  0001d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00024	eb 23		 jmp	 SHORT $LN1@cache_geta
$LN2@cache_geta:

; 273  :     return cacheblk[ix].cache[i].age;

  00026	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  0002b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00036	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  0003b	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0003f	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00044	48 8b 44 10 20	 mov	 rax, QWORD PTR [rax+rdx+32]
$LN1@cache_geta:

; 274  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
cache_getage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
busy$ = 32
empty$ = 36
oldflags$ = 40
ix$ = 64
i$ = 72
andbits$ = 80
orbits$ = 88
cache_setflag PROC

; 243  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 244  :     U32 oldflags;
; 245  :     int empty;
; 246  :     int busy;
; 247  : 
; 248  :     if (cache_check(ix,i)) return (U32)-1;

  00016	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0001e	e8 00 00 00 00	 call	 cache_check
  00023	85 c0		 test	 eax, eax
  00025	74 0a		 je	 SHORT $LN2@cache_setf
  00027	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0002c	e9 3b 02 00 00	 jmp	 $LN1@cache_setf
$LN2@cache_setf:

; 249  : 
; 250  :     empty = cache_isempty(ix, i);

  00031	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00035	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00039	e8 00 00 00 00	 call	 cache_isempty
  0003e	89 44 24 24	 mov	 DWORD PTR empty$[rsp], eax

; 251  :     busy = cache_isbusy(ix, i);

  00042	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00046	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0004a	e8 00 00 00 00	 call	 cache_isbusy
  0004f	89 44 24 20	 mov	 DWORD PTR busy$[rsp], eax

; 252  :     oldflags = cacheblk[ix].cache[i].flag;

  00053	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00058	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00063	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  00068	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0006c	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00071	8b 44 10 08	 mov	 eax, DWORD PTR [rax+rdx+8]
  00075	89 44 24 28	 mov	 DWORD PTR oldflags$[rsp], eax

; 253  : 
; 254  :     cacheblk[ix].cache[i].flag &= andbits;

  00079	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0007e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00089	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  0008e	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00092	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00097	8b 4c 24 50	 mov	 ecx, DWORD PTR andbits$[rsp]
  0009b	8b 44 10 08	 mov	 eax, DWORD PTR [rax+rdx+8]
  0009f	23 c1		 and	 eax, ecx
  000a1	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000a6	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000b1	4c 63 44 24 48	 movsxd	 r8, DWORD PTR i$[rsp]
  000b6	4d 6b c0 28	 imul	 r8, r8, 40		; 00000028H
  000ba	48 8b 4c 0a 50	 mov	 rcx, QWORD PTR [rdx+rcx+80]
  000bf	42 89 44 01 08	 mov	 DWORD PTR [rcx+r8+8], eax

; 255  :     cacheblk[ix].cache[i].flag |= orbits;

  000c4	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000c9	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000d4	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  000d9	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  000dd	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  000e2	8b 4c 24 58	 mov	 ecx, DWORD PTR orbits$[rsp]
  000e6	8b 44 10 08	 mov	 eax, DWORD PTR [rax+rdx+8]
  000ea	0b c1		 or	 eax, ecx
  000ec	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000f1	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000fc	4c 63 44 24 48	 movsxd	 r8, DWORD PTR i$[rsp]
  00101	4d 6b c0 28	 imul	 r8, r8, 40		; 00000028H
  00105	48 8b 4c 0a 50	 mov	 rcx, QWORD PTR [rdx+rcx+80]
  0010a	42 89 44 01 08	 mov	 DWORD PTR [rcx+r8+8], eax

; 256  : 
; 257  :     if (!cache_isbusy(ix, i) && cacheblk[ix].waiters > 0)

  0010f	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00113	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00117	e8 00 00 00 00	 call	 cache_isbusy
  0011c	85 c0		 test	 eax, eax
  0011e	75 3c		 jne	 SHORT $LN3@cache_setf
  00120	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00125	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00130	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  00135	7e 25		 jle	 SHORT $LN3@cache_setf

; 258  :         signal_condition(&cacheblk[ix].waitcond);

  00137	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0013c	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00147	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159234
  00153	48 8b c8	 mov	 rcx, rax
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN3@cache_setf:

; 259  :     if (busy && !cache_isbusy(ix, i))

  0015c	83 7c 24 20 00	 cmp	 DWORD PTR busy$[rsp], 0
  00161	74 3d		 je	 SHORT $LN4@cache_setf
  00163	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00167	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0016b	e8 00 00 00 00	 call	 cache_isbusy
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN4@cache_setf

; 260  :         cacheblk[ix].busy--;

  00174	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00179	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00184	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  00188	ff c8		 dec	 eax
  0018a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0018f	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  0019a	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax
  0019e	eb 42		 jmp	 SHORT $LN5@cache_setf
$LN4@cache_setf:

; 261  :     else if (!busy && cache_isbusy(ix, i))

  001a0	83 7c 24 20 00	 cmp	 DWORD PTR busy$[rsp], 0
  001a5	75 3b		 jne	 SHORT $LN6@cache_setf
  001a7	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  001ab	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  001af	e8 00 00 00 00	 call	 cache_isbusy
  001b4	85 c0		 test	 eax, eax
  001b6	74 2a		 je	 SHORT $LN6@cache_setf

; 262  :         cacheblk[ix].busy++;

  001b8	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  001bd	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  001c8	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  001cc	ff c0		 inc	 eax
  001ce	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  001d3	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  001de	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax
$LN6@cache_setf:
$LN5@cache_setf:

; 263  :     if (empty && !cache_isempty(ix, i))

  001e2	83 7c 24 24 00	 cmp	 DWORD PTR empty$[rsp], 0
  001e7	74 3d		 je	 SHORT $LN7@cache_setf
  001e9	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  001ed	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  001f1	e8 00 00 00 00	 call	 cache_isempty
  001f6	85 c0		 test	 eax, eax
  001f8	75 2c		 jne	 SHORT $LN7@cache_setf

; 264  :         cacheblk[ix].empty--;

  001fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  001ff	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0020a	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  0020e	ff c8		 dec	 eax
  00210	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00215	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00219	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00220	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
  00224	eb 42		 jmp	 SHORT $LN8@cache_setf
$LN7@cache_setf:

; 265  :     else if (!empty && cache_isempty(ix, i))

  00226	83 7c 24 24 00	 cmp	 DWORD PTR empty$[rsp], 0
  0022b	75 3b		 jne	 SHORT $LN9@cache_setf
  0022d	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00231	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00235	e8 00 00 00 00	 call	 cache_isempty
  0023a	85 c0		 test	 eax, eax
  0023c	74 2a		 je	 SHORT $LN9@cache_setf

; 266  :         cacheblk[ix].empty++;

  0023e	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00243	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0024e	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00252	ff c0		 inc	 eax
  00254	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00259	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00264	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
$LN9@cache_setf:
$LN8@cache_setf:

; 267  :     return oldflags;

  00268	8b 44 24 28	 mov	 eax, DWORD PTR oldflags$[rsp]
$LN1@cache_setf:

; 268  : }

  0026c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00270	c3		 ret	 0
cache_setflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_getflag PROC

; 237  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 238  :     if (cache_check(ix,i)) return (U32)-1;

  0000c	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN2@cache_getf
  0001d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00022	eb 22		 jmp	 SHORT $LN1@cache_getf
$LN2@cache_getf:

; 239  :     return cacheblk[ix].cache[i].flag;

  00024	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00029	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00034	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  00039	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0003d	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00042	8b 44 10 08	 mov	 eax, DWORD PTR [rax+rdx+8]
$LN1@cache_getf:

; 240  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
cache_getflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
empty$ = 32
oldkey$ = 40
ix$ = 64
i$ = 72
key$ = 80
cache_setkey PROC

; 221  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 222  :     U64 oldkey;
; 223  :     int empty;
; 224  : 
; 225  :     if (cache_check(ix,i)) return (U64)-1;

  00011	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00019	e8 00 00 00 00	 call	 cache_check
  0001e	85 c0		 test	 eax, eax
  00020	74 0c		 je	 SHORT $LN2@cache_setk
  00022	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00029	e9 ea 00 00 00	 jmp	 $LN1@cache_setk
$LN2@cache_setk:

; 226  :     empty = cache_isempty(ix, i);

  0002e	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00032	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00036	e8 00 00 00 00	 call	 cache_isempty
  0003b	89 44 24 20	 mov	 DWORD PTR empty$[rsp], eax

; 227  :     oldkey = cacheblk[ix].cache[i].key;

  0003f	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00044	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0004f	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  00054	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00058	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0005d	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  00061	48 89 44 24 28	 mov	 QWORD PTR oldkey$[rsp], rax

; 228  :     cacheblk[ix].cache[i].key = key;

  00066	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0006b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00076	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  0007b	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0007f	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR key$[rsp]
  00089	48 89 0c 10	 mov	 QWORD PTR [rax+rdx], rcx

; 229  :     if (empty && !cache_isempty(ix, i))

  0008d	83 7c 24 20 00	 cmp	 DWORD PTR empty$[rsp], 0
  00092	74 3d		 je	 SHORT $LN3@cache_setk
  00094	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00098	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0009c	e8 00 00 00 00	 call	 cache_isempty
  000a1	85 c0		 test	 eax, eax
  000a3	75 2c		 jne	 SHORT $LN3@cache_setk

; 230  :         cacheblk[ix].empty--;

  000a5	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000aa	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000b5	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  000b9	ff c8		 dec	 eax
  000bb	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000c0	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000cb	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
  000cf	eb 42		 jmp	 SHORT $LN4@cache_setk
$LN3@cache_setk:

; 231  :     else if (!empty && cache_isempty(ix, i))

  000d1	83 7c 24 20 00	 cmp	 DWORD PTR empty$[rsp], 0
  000d6	75 3b		 jne	 SHORT $LN5@cache_setk
  000d8	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  000dc	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  000e0	e8 00 00 00 00	 call	 cache_isempty
  000e5	85 c0		 test	 eax, eax
  000e7	74 2a		 je	 SHORT $LN5@cache_setk

; 232  :         cacheblk[ix].empty++;

  000e9	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000ee	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000f9	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  000fd	ff c0		 inc	 eax
  000ff	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00104	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  0010f	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
$LN5@cache_setk:
$LN4@cache_setk:

; 233  :     return oldkey;

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR oldkey$[rsp]
$LN1@cache_setk:

; 234  : }

  00118	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011c	c3		 ret	 0
cache_setkey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
i$ = 56
cache_getkey PROC

; 215  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     if (cache_check(ix,i)) return (U64)-1;

  0000c	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00010	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00014	e8 00 00 00 00	 call	 cache_check
  00019	85 c0		 test	 eax, eax
  0001b	74 09		 je	 SHORT $LN2@cache_getk
  0001d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00024	eb 22		 jmp	 SHORT $LN1@cache_getk
$LN2@cache_getk:

; 217  :     return cacheblk[ix].cache[i].key;

  00026	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  0002b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00036	48 63 54 24 38	 movsxd	 rdx, DWORD PTR i$[rsp]
  0003b	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0003f	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00044	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
$LN1@cache_getk:

; 218  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
cache_getkey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_wait PROC

; 189  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 0a		 je	 SHORT $LN2@cache_wait
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	e9 ec 00 00 00	 jmp	 $LN1@cache_wait
$LN2@cache_wait:

; 191  :     if (cacheblk[ix].busy < cacheblk[ix].nbr)

  0001f	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00024	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002f	48 63 54 24 30	 movsxd	 rdx, DWORD PTR ix$[rsp]
  00034	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  0003f	41 8b 54 10 04	 mov	 edx, DWORD PTR [r8+rdx+4]
  00044	39 54 01 08	 cmp	 DWORD PTR [rcx+rax+8], edx
  00048	7d 07		 jge	 SHORT $LN3@cache_wait

; 192  :         return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 ba 00 00 00	 jmp	 $LN1@cache_wait
$LN3@cache_wait:

; 193  : 
; 194  :     cacheblk[ix].waiters++; cacheblk[ix].waits++;

  00051	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00056	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00061	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  00065	ff c0		 inc	 eax
  00067	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0006c	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00077	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax
  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00080	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0008b	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0008f	ff c0		 inc	 eax
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00096	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000a1	89 44 0a 14	 mov	 DWORD PTR [rdx+rcx+20], eax

; 195  : 
; 196  : #if FALSE
; 197  :     {
; 198  :     struct timeval  now;
; 199  :     struct timespec tm;
; 200  :         gettimeofday (&now, NULL);
; 201  :         tm.tv_sec = now.tv_sec;
; 202  :         tm.tv_nsec = (now.tv_usec + CACHE_WAITTIME) * 1000;
; 203  :         tm.tv_sec += tm.tv_nsec / 1000000000;
; 204  :         tm.tv_nsec = tm.tv_nsec % 1000000000;
; 205  :         timed_wait_condition(&cacheblk[ix].waitcond, &cacheblk[ix].lock, &tm);
; 206  :     }
; 207  : #else
; 208  :     wait_condition(&cacheblk[ix].waitcond, &cacheblk[ix].lock);

  000a5	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  000aa	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000b5	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  000ba	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000bf	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000ca	48 8d 4c 0a 48	 lea	 rcx, QWORD PTR [rdx+rcx+72]
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159190
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 209  : #endif
; 210  :     cacheblk[ix].waiters--;

  000df	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  000e4	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000ef	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  000f3	ff c8		 dec	 eax
  000f5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000fa	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00105	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax

; 211  :     return 0;

  00109	33 c0		 xor	 eax, eax
$LN1@cache_wait:

; 212  : }

  0010b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010f	c3		 ret	 0
cache_wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_unlock PROC

; 180  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 181  :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_unlo
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 5b		 jmp	 SHORT $LN1@cache_unlo
$LN2@cache_unlo:

; 182  :     release_lock(&cacheblk[ix].lock);

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159183
  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 183  :     if (cacheblk[ix].empty == cacheblk[ix].nbr)

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00046	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00051	48 63 54 24 30	 movsxd	 rdx, DWORD PTR ix$[rsp]
  00056	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  0005a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  00061	41 8b 54 10 04	 mov	 edx, DWORD PTR [r8+rdx+4]
  00066	39 54 01 0c	 cmp	 DWORD PTR [rcx+rax+12], edx
  0006a	75 09		 jne	 SHORT $LN3@cache_unlo

; 184  :         cache_destroy(ix);

  0006c	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  00070	e8 00 00 00 00	 call	 cache_destroy
$LN3@cache_unlo:

; 185  :     return 0;

  00075	33 c0		 xor	 eax, eax
$LN1@cache_unlo:

; 186  : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
cache_unlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_lock PROC

; 173  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 174  :     if (cache_check_cache(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_cache
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_lock
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 27		 jmp	 SHORT $LN1@cache_lock
$LN2@cache_lock:

; 175  :     obtain_lock(&cacheblk[ix].lock);

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159178
  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 176  :     return 0;

  00041	33 c0		 xor	 eax, eax
$LN1@cache_lock:

; 177  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
cache_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
i$ = 32
answer$ = 36
rc$ = 40
ix$ = 64
rtn$ = 72
data$ = 80
cache_scan PROC

; 159  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 160  : int      i;                             /* Cache index               */
; 161  : int      rc;                            /* Return code               */
; 162  : int      answer = -1;                   /* Answer from routine       */

  00012	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR answer$[rsp], -1

; 163  : 
; 164  :     if (cache_check_ix(ix)) return -1;

  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0001e	e8 00 00 00 00	 call	 cache_check_ix
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN5@cache_scan
  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 58		 jmp	 SHORT $LN1@cache_scan
$LN5@cache_scan:

; 165  :     for (i = 0; i < cacheblk[ix].nbr; i++) {

  0002e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00036	eb 0a		 jmp	 SHORT $LN4@cache_scan
$LN2@cache_scan:
  00038	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003c	ff c0		 inc	 eax
  0003e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@cache_scan:
  00042	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00047	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00052	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00056	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005a	7d 26		 jge	 SHORT $LN3@cache_scan

; 166  :         rc = (rtn)(&answer, ix, i, data);

  0005c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR data$[rsp]
  00061	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  00066	8b 54 24 40	 mov	 edx, DWORD PTR ix$[rsp]
  0006a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR answer$[rsp]
  0006f	ff 54 24 48	 call	 QWORD PTR rtn$[rsp]
  00073	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 167  :         if (rc != 0) break;

  00077	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007c	74 02		 je	 SHORT $LN6@cache_scan
  0007e	eb 02		 jmp	 SHORT $LN3@cache_scan
$LN6@cache_scan:

; 168  :     }

  00080	eb b6		 jmp	 SHORT $LN2@cache_scan
$LN3@cache_scan:

; 169  :     return answer;

  00082	8b 44 24 24	 mov	 eax, DWORD PTR answer$[rsp]
$LN1@cache_scan:

; 170  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
cache_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
i$ = 32
p$ = 36
tv72 = 40
ix$ = 64
key$ = 72
oldest_entry$ = 80
cache_lookup PROC

; 104  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 105  :     int i,p;
; 106  : 
; 107  :     if (oldest_entry)

  00012	48 83 7c 24 50
	00		 cmp	 QWORD PTR oldest_entry$[rsp], 0
  00018	74 0b		 je	 SHORT $LN5@cache_look

; 108  :         *oldest_entry = -1;

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  0001f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN5@cache_look:

; 109  :     if (cache_check_ix(ix))

  00025	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00029	e8 00 00 00 00	 call	 cache_check_ix
  0002e	85 c0		 test	 eax, eax
  00030	74 0a		 je	 SHORT $LN6@cache_look

; 110  :         return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	e9 bf 02 00 00	 jmp	 $LN1@cache_look
$LN6@cache_look:

; 111  :     /* `p' is the preferred index */
; 112  :     p = (int)(key % cacheblk[ix].nbr);

  0003c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00041	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0004c	48 63 44 01 04	 movsxd	 rax, DWORD PTR [rcx+rax+4]
  00051	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00056	33 d2		 xor	 edx, edx
  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00062	48 f7 f1	 div	 rcx
  00065	48 8b c2	 mov	 rax, rdx
  00068	89 44 24 24	 mov	 DWORD PTR p$[rsp], eax

; 113  : 
; 114  :     if (cacheblk[ix].cache[p].key == key)

  0006c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00071	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0007c	48 63 54 24 24	 movsxd	 rdx, DWORD PTR p$[rsp]
  00081	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00085	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0008a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0008f	48 39 0c 10	 cmp	 QWORD PTR [rax+rdx], rcx
  00093	75 4b		 jne	 SHORT $LN7@cache_look

; 115  :     {
; 116  :         i = p;

  00095	8b 44 24 24	 mov	 eax, DWORD PTR p$[rsp]
  00099	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 117  :         if (!cache_isempty(ix, i))

  0009d	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000a1	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  000a5	e8 00 00 00 00	 call	 cache_isempty
  000aa	85 c0		 test	 eax, eax
  000ac	75 2d		 jne	 SHORT $LN9@cache_look

; 118  :         {
; 119  :             cacheblk[ix].fasthits++;

  000ae	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000b3	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  000be	48 8b 44 01 28	 mov	 rax, QWORD PTR [rcx+rax+40]
  000c3	48 ff c0	 inc	 rax
  000c6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  000cb	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  000d6	48 89 44 0a 28	 mov	 QWORD PTR [rdx+rcx+40], rax
$LN9@cache_look:

; 120  :         }
; 121  :     }

  000db	e9 53 01 00 00	 jmp	 $LN8@cache_look
$LN7@cache_look:

; 122  :     else
; 123  :     {
; 124  :         if (cache_isbusy(ix, p) || cacheblk[ix].age - cacheblk[ix].cache[p].age < 20)

  000e0	8b 54 24 24	 mov	 edx, DWORD PTR p$[rsp]
  000e4	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  000e8	e8 00 00 00 00	 call	 cache_isbusy
  000ed	85 c0		 test	 eax, eax
  000ef	75 41		 jne	 SHORT $LN11@cache_look
  000f1	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  000f6	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00101	48 63 54 24 40	 movsxd	 rdx, DWORD PTR ix$[rsp]
  00106	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  0010a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  00111	4c 63 4c 24 24	 movsxd	 r9, DWORD PTR p$[rsp]
  00116	4d 6b c9 28	 imul	 r9, r9, 40		; 00000028H
  0011a	49 8b 54 10 50	 mov	 rdx, QWORD PTR [r8+rdx+80]
  0011f	4a 8b 54 0a 20	 mov	 rdx, QWORD PTR [rdx+r9+32]
  00124	48 8b 44 01 38	 mov	 rax, QWORD PTR [rcx+rax+56]
  00129	48 2b c2	 sub	 rax, rdx
  0012c	48 83 f8 14	 cmp	 rax, 20
  00130	73 08		 jae	 SHORT $LN10@cache_look
$LN11@cache_look:

; 125  :             p = -2;

  00132	c7 44 24 24 fe
	ff ff ff	 mov	 DWORD PTR p$[rsp], -2
$LN10@cache_look:

; 126  :         for (i = 0; i < cacheblk[ix].nbr; i++)

  0013a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00142	eb 0a		 jmp	 SHORT $LN4@cache_look
$LN2@cache_look:
  00144	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00148	ff c0		 inc	 eax
  0014a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@cache_look:
  0014e	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00153	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0015e	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00162	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00166	0f 8d c7 00 00
	00		 jge	 $LN3@cache_look

; 127  :         {
; 128  :             if (cacheblk[ix].cache[i].key == key) break;

  0016c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00171	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0017c	48 63 54 24 20	 movsxd	 rdx, DWORD PTR i$[rsp]
  00181	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00185	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  0018a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0018f	48 39 0c 10	 cmp	 QWORD PTR [rax+rdx], rcx
  00193	75 05		 jne	 SHORT $LN12@cache_look
  00195	e9 99 00 00 00	 jmp	 $LN3@cache_look
$LN12@cache_look:

; 129  :             if (oldest_entry && !cache_isbusy(ix, i)
; 130  :              && (*oldest_entry < 0 || i == p || cacheblk[ix].cache[i].age < cacheblk[ix].cache[*oldest_entry].age))

  0019a	48 83 7c 24 50
	00		 cmp	 QWORD PTR oldest_entry$[rsp], 0
  001a0	0f 84 88 00 00
	00		 je	 $LN13@cache_look
  001a6	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  001aa	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  001ae	e8 00 00 00 00	 call	 cache_isbusy
  001b3	85 c0		 test	 eax, eax
  001b5	75 77		 jne	 SHORT $LN13@cache_look
  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  001bc	83 38 00	 cmp	 DWORD PTR [rax], 0
  001bf	7c 55		 jl	 SHORT $LN14@cache_look
  001c1	8b 44 24 24	 mov	 eax, DWORD PTR p$[rsp]
  001c5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001c9	74 4b		 je	 SHORT $LN14@cache_look
  001cb	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  001d0	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  001db	48 63 54 24 20	 movsxd	 rdx, DWORD PTR i$[rsp]
  001e0	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  001e4	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  001e9	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  001ee	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  001f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  001f9	4c 8b 4c 24 50	 mov	 r9, QWORD PTR oldest_entry$[rsp]
  001fe	4d 63 09	 movsxd	 r9, DWORD PTR [r9]
  00201	4d 6b c9 28	 imul	 r9, r9, 40		; 00000028H
  00205	49 8b 4c 08 50	 mov	 rcx, QWORD PTR [r8+rcx+80]
  0020a	4a 8b 4c 09 20	 mov	 rcx, QWORD PTR [rcx+r9+32]
  0020f	48 39 4c 10 20	 cmp	 QWORD PTR [rax+rdx+32], rcx
  00214	73 18		 jae	 SHORT $LN13@cache_look
$LN14@cache_look:

; 131  :                 if (*oldest_entry != p) *oldest_entry = i;

  00216	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  0021b	8b 4c 24 24	 mov	 ecx, DWORD PTR p$[rsp]
  0021f	39 08		 cmp	 DWORD PTR [rax], ecx
  00221	74 0b		 je	 SHORT $LN15@cache_look
  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  00228	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0022c	89 08		 mov	 DWORD PTR [rax], ecx
$LN15@cache_look:
$LN13@cache_look:

; 132  :         }

  0022e	e9 11 ff ff ff	 jmp	 $LN2@cache_look
$LN3@cache_look:
$LN8@cache_look:

; 133  :     }
; 134  : 
; 135  :     if (i >= cacheblk[ix].nbr)

  00233	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00238	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00243	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00247	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0024b	7c 0a		 jl	 SHORT $LN16@cache_look

; 136  :     {
; 137  :         i = -1;

  0024d	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$[rsp], -1

; 138  :     }

  00255	eb 3d		 jmp	 SHORT $LN17@cache_look
$LN16@cache_look:

; 139  :     else if ( i >= 0 && cache_isempty(ix, i) )

  00257	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0025c	7c 36		 jl	 SHORT $LN18@cache_look
  0025e	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00262	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  00266	e8 00 00 00 00	 call	 cache_isempty
  0026b	85 c0		 test	 eax, eax
  0026d	74 25		 je	 SHORT $LN18@cache_look

; 140  :     {
; 141  :         if ( oldest_entry && *oldest_entry < 0 )

  0026f	48 83 7c 24 50
	00		 cmp	 QWORD PTR oldest_entry$[rsp], 0
  00275	74 15		 je	 SHORT $LN19@cache_look
  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  0027c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0027f	7d 0b		 jge	 SHORT $LN19@cache_look

; 142  :         {
; 143  :             *oldest_entry = i;

  00281	48 8b 44 24 50	 mov	 rax, QWORD PTR oldest_entry$[rsp]
  00286	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0028a	89 08		 mov	 DWORD PTR [rax], ecx
$LN19@cache_look:

; 144  :         }
; 145  :         i = -1;

  0028c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$[rsp], -1
$LN18@cache_look:
$LN17@cache_look:

; 146  :     }
; 147  :     if ( i >= 0 )

  00294	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00299	7c 2f		 jl	 SHORT $LN20@cache_look

; 148  :     {
; 149  :         cacheblk[ix].hits++;

  0029b	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  002a0	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  002ab	48 8b 44 01 20	 mov	 rax, QWORD PTR [rcx+rax+32]
  002b0	48 ff c0	 inc	 rax
  002b3	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  002b8	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  002c3	48 89 44 0a 20	 mov	 QWORD PTR [rdx+rcx+32], rax

; 150  :     }

  002c8	eb 2d		 jmp	 SHORT $LN21@cache_look
$LN20@cache_look:

; 151  :     else
; 152  :     {
; 153  :         cacheblk[ix].misses++;

  002ca	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  002cf	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  002da	48 8b 44 01 30	 mov	 rax, QWORD PTR [rcx+rax+48]
  002df	48 ff c0	 inc	 rax
  002e2	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  002e7	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  002eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  002f2	48 89 44 0a 30	 mov	 QWORD PTR [rdx+rcx+48], rax
$LN21@cache_look:

; 154  :     }
; 155  :     return i;

  002f7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
$LN1@cache_look:

; 156  : }

  002fb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002ff	c3		 ret	 0
cache_lookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
total$ = 32
ix$ = 64
cache_hit_percent PROC

; 95   : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 96   :     S64 total;
; 97   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_hit_
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 5b		 jmp	 SHORT $LN1@cache_hit_
$LN2@cache_hit_:

; 98   :     total = cacheblk[ix].hits + cacheblk[ix].misses;

  0001c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	48 63 54 24 40	 movsxd	 rdx, DWORD PTR ix$[rsp]
  00031	48 6b d2 70	 imul	 rdx, rdx, 112		; 00000070H
  00035	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  0003c	48 8b 44 01 20	 mov	 rax, QWORD PTR [rcx+rax+32]
  00041	49 03 44 10 30	 add	 rax, QWORD PTR [r8+rdx+48]
  00046	48 89 44 24 20	 mov	 QWORD PTR total$[rsp], rax

; 99   :     if (total == 0) return -1;

  0004b	48 83 7c 24 20
	00		 cmp	 QWORD PTR total$[rsp], 0
  00051	75 07		 jne	 SHORT $LN3@cache_hit_
  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	eb 1d		 jmp	 SHORT $LN1@cache_hit_
$LN3@cache_hit_:

; 100  :     return (int)((cacheblk[ix].hits * 100) / total);

  0005a	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  0005f	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0006a	48 6b 44 01 20
	64		 imul	 rax, QWORD PTR [rcx+rax+32], 100 ; 00000064H
  00070	48 99		 cdq
  00072	48 f7 7c 24 20	 idiv	 QWORD PTR total$[rsp]
$LN1@cache_hit_:

; 101  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
cache_hit_percent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv78 = 32
ix$ = 64
cache_empty_percent PROC

; 89   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_empt
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 35		 jmp	 SHORT $LN1@cache_empt
$LN2@cache_empt:

; 91   :     return (cacheblk[ix].empty * 100) / cacheblk[ix].nbr;

  0001c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	6b 44 01 0c 64	 imul	 eax, DWORD PTR [rcx+rax+12], 100 ; 00000064H
  00031	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00036	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00041	48 89 54 24 20	 mov	 QWORD PTR tv78[rsp], rdx
  00046	99		 cdq
  00047	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv78[rsp]
  0004c	41 f7 7c 08 04	 idiv	 DWORD PTR [r8+rcx+4]
$LN1@cache_empt:

; 92   : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
cache_empty_percent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
tv78 = 32
ix$ = 64
cache_busy_percent PROC

; 83   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 84   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_busy
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 35		 jmp	 SHORT $LN1@cache_busy
$LN2@cache_busy:

; 85   :     return (cacheblk[ix].busy * 100) / cacheblk[ix].nbr;

  0001c	48 63 44 24 40	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	6b 44 01 08 64	 imul	 eax, DWORD PTR [rcx+rax+8], 100 ; 00000064H
  00031	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00036	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cacheblk
  00041	48 89 54 24 20	 mov	 QWORD PTR tv78[rsp], rdx
  00046	99		 cdq
  00047	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv78[rsp]
  0004c	41 f7 7c 08 04	 idiv	 DWORD PTR [r8+rcx+4]
$LN1@cache_busy:

; 86   : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
cache_busy_percent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_misses PROC

; 77   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 78   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN2@cache_miss
  00015	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001c	eb 15		 jmp	 SHORT $LN1@cache_miss
$LN2@cache_miss:

; 79   :     return cacheblk[ix].misses;

  0001e	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00023	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002e	48 8b 44 01 30	 mov	 rax, QWORD PTR [rcx+rax+48]
$LN1@cache_miss:

; 80   : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
cache_misses ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_hits PROC

; 71   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 72   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN2@cache_hits
  00015	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001c	eb 15		 jmp	 SHORT $LN1@cache_hits
$LN2@cache_hits:

; 73   :     return cacheblk[ix].hits;

  0001e	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00023	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002e	48 8b 44 01 20	 mov	 rax, QWORD PTR [rcx+rax+32]
$LN1@cache_hits:

; 74   : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
cache_hits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_size PROC

; 65   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 66   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN2@cache_size
  00015	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001c	eb 15		 jmp	 SHORT $LN1@cache_size
$LN2@cache_size:

; 67   :     return cacheblk[ix].size;

  0001e	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00023	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002e	48 8b 44 01 18	 mov	 rax, QWORD PTR [rcx+rax+24]
$LN1@cache_size:

; 68   : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
cache_size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_waiters PROC

; 59   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 60   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_wait
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 14		 jmp	 SHORT $LN1@cache_wait
$LN2@cache_wait:

; 61   :     return cacheblk[ix].waiters;

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
$LN1@cache_wait:

; 62   : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
cache_waiters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_empty PROC

; 53   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 54   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_empt
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 14		 jmp	 SHORT $LN1@cache_empt
$LN2@cache_empt:

; 55   :     return cacheblk[ix].empty;

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
$LN1@cache_empt:

; 56   : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
cache_empty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_busy PROC

; 47   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 48   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_busy
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 14		 jmp	 SHORT $LN1@cache_busy
$LN2@cache_busy:

; 49   :     return cacheblk[ix].busy;

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
$LN1@cache_busy:

; 50   : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
cache_busy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 48
cache_nbr PROC

; 41   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 42   :     if (cache_check_ix(ix)) return -1;

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR ix$[rsp]
  0000c	e8 00 00 00 00	 call	 cache_check_ix
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $LN2@cache_nbr
  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 14		 jmp	 SHORT $LN1@cache_nbr
$LN2@cache_nbr:

; 43   :     return cacheblk[ix].nbr;

  0001c	48 63 44 24 30	 movsxd	 rax, DWORD PTR ix$[rsp]
  00021	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0002c	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
$LN1@cache_nbr:

; 44   : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
cache_nbr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cache.c
_TEXT	SEGMENT
ix$ = 80
i$ = 84
tv425 = 88
$T1 = 96
tv456 = 104
$T2 = 112
buf$ = 128
__$ArrayPad$ = 256
argc$ = 320
argv$ = 328
cmdline$ = 336
cachestats_cmd PROC

; 375  : {

$LN28:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	53		 push	 rbx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cachestats:

; 376  :     int ix, i;
; 377  :     char buf[128];
; 378  : 
; 379  :     UNREFERENCED(cmdline);

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN4@cachestats
$LN7@cachestats:

; 380  :     UNREFERENCED(argc);

  00031	33 c0		 xor	 eax, eax
  00033	85 c0		 test	 eax, eax
  00035	75 fa		 jne	 SHORT $LN7@cachestats
$LN10@cachestats:

; 381  :     UNREFERENCED(argv);

  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 fa		 jne	 SHORT $LN10@cachestats

; 382  : 
; 383  :     OBTAIN_GLOBAL_CACHE_LOCK();

  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00044	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159354
  00051	48 8b c8	 mov	 rcx, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 384  : 
; 385  :     for (ix = 0; ix < CACHE_MAX_INDEX; ix++)

  0005a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ix$[rsp], 0
  00062	eb 0a		 jmp	 SHORT $LN13@cachestats
$LN11@cachestats:
  00064	8b 44 24 50	 mov	 eax, DWORD PTR ix$[rsp]
  00068	ff c0		 inc	 eax
  0006a	89 44 24 50	 mov	 DWORD PTR ix$[rsp], eax
$LN13@cachestats:
  0006e	83 7c 24 50 08	 cmp	 DWORD PTR ix$[rsp], 8
  00073	0f 8d f8 0a 00
	00		 jge	 $LN12@cachestats

; 386  :     {
; 387  :         if (cacheblk[ix].magic != CACHE_MAGIC)

  00079	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0007e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00089	81 3c 01 10 ce
	ca 01		 cmp	 DWORD PTR [rcx+rax], 30068240 ; 01cace10H
  00090	74 78		 je	 SHORT $LN17@cachestats

; 388  :         {
; 389  :             MSGBUF(buf, "Cache[%d] ....... not created", ix);

  00092	44 8b 4c 24 50	 mov	 r9d, DWORD PTR ix$[rsp]
  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159356
  0009e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  000a3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 390  :             WRMSG(HHC02294, "I", buf);

  000b1	b9 01 00 00 00	 mov	 ecx, 1
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bc	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  000c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159357
  000d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159358
  000dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159359
  000f3	ba 86 01 00 00	 mov	 edx, 390		; 00000186H
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159360
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 391  :             continue;

  00105	e9 5a ff ff ff	 jmp	 $LN11@cachestats
$LN17@cachestats:

; 392  :         }
; 393  : 
; 394  :         MSGBUF( buf, "Cache............ %10d", ix);

  0010a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR ix$[rsp]
  0010f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159361
  00116	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0011b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 395  :         WRMSG(HHC02294, "I", buf);

  00129	b9 01 00 00 00	 mov	 ecx, 1
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00134	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0013c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159362
  00148	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159363
  00154	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00159	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00164	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159364
  0016b	ba 8b 01 00 00	 mov	 edx, 395		; 0000018bH
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159365
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 396  : 
; 397  :         MSGBUF( buf, "nbr ............. %10d", cacheblk[ix].nbr);

  0017d	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00182	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0018d	44 8b 4c 01 04	 mov	 r9d, DWORD PTR [rcx+rax+4]
  00192	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159366
  00199	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0019e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 398  :         WRMSG(HHC02294, "I", buf);

  001ac	b9 01 00 00 00	 mov	 ecx, 1
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159367
  001cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159368
  001d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159369
  001ee	ba 8e 01 00 00	 mov	 edx, 398		; 0000018eH
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159370
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 399  : 
; 400  :         MSGBUF( buf, "busy ............ %10d", cacheblk[ix].busy);

  00200	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00205	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00210	44 8b 4c 01 08	 mov	 r9d, DWORD PTR [rcx+rax+8]
  00215	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159371
  0021c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00221	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 401  :         WRMSG(HHC02294, "I", buf);

  0022f	b9 01 00 00 00	 mov	 ecx, 1
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00242	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159372
  0024e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159373
  0025a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00264	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159374
  00271	ba 91 01 00 00	 mov	 edx, 401		; 00000191H
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159375
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 402  : 
; 403  :         MSGBUF( buf, "busy%% ........... %10d",cache_busy_percent(ix));

  00283	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00287	e8 00 00 00 00	 call	 cache_busy_percent
  0028c	44 8b c8	 mov	 r9d, eax
  0028f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159376
  00296	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0029b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 404  :         WRMSG(HHC02294, "I", buf);

  002a9	b9 01 00 00 00	 mov	 ecx, 1
  002ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b4	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159377
  002c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159378
  002d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002de	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159379
  002eb	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159380
  002f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  : 
; 406  :         MSGBUF( buf, "empty ........... %10d", cacheblk[ix].empty);

  002fd	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00302	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0030d	44 8b 4c 01 0c	 mov	 r9d, DWORD PTR [rcx+rax+12]
  00312	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159381
  00319	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0031e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00326	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 407  :         WRMSG(HHC02294, "I", buf);

  0032c	b9 01 00 00 00	 mov	 ecx, 1
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00337	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0033f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159382
  0034b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159383
  00357	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0035c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00361	41 b9 03 00 00
	00		 mov	 r9d, 3
  00367	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159384
  0036e	ba 97 01 00 00	 mov	 edx, 407		; 00000197H
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159385
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 408  : 
; 409  :         MSGBUF( buf, "waiters ......... %10d", cacheblk[ix].waiters);

  00380	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00385	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00390	44 8b 4c 01 10	 mov	 r9d, DWORD PTR [rcx+rax+16]
  00395	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159386
  0039c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  003a1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 410  :         WRMSG(HHC02294, "I", buf);

  003af	b9 01 00 00 00	 mov	 ecx, 1
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003ba	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003c2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159387
  003ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159388
  003da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159389
  003f1	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  003f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159390
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 411  : 
; 412  :         MSGBUF( buf, "waits ........... %10d", cacheblk[ix].waits);

  00403	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00408	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00413	44 8b 4c 01 14	 mov	 r9d, DWORD PTR [rcx+rax+20]
  00418	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159391
  0041f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00424	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0042c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 413  :         WRMSG(HHC02294, "I", buf);

  00432	b9 01 00 00 00	 mov	 ecx, 1
  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0043d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00445	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0044a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159392
  00451	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159393
  0045d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00462	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00467	41 b9 03 00 00
	00		 mov	 r9d, 3
  0046d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159394
  00474	ba 9d 01 00 00	 mov	 edx, 413		; 0000019dH
  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159395
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 414  : 
; 415  :         MSGBUF( buf, "buf size ........ %10"PRId64, cacheblk[ix].size);

  00486	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0048b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00496	4c 8b 4c 01 18	 mov	 r9, QWORD PTR [rcx+rax+24]
  0049b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159396
  004a2	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  004a7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 416  :         WRMSG(HHC02294, "I", buf);

  004b5	b9 01 00 00 00	 mov	 ecx, 1
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004c8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159397
  004d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159398
  004e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159399
  004f7	ba a0 01 00 00	 mov	 edx, 416		; 000001a0H
  004fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159400
  00503	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 417  : 
; 418  :         MSGBUF( buf, "hits ............ %10"PRId64, cacheblk[ix].hits);

  00509	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  0050e	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00512	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00519	4c 8b 4c 01 20	 mov	 r9, QWORD PTR [rcx+rax+32]
  0051e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159401
  00525	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0052a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 419  :         WRMSG(HHC02294, "I", buf);

  00538	b9 01 00 00 00	 mov	 ecx, 1
  0053d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00543	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0054b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00550	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159402
  00557	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159403
  00563	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00568	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00573	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159404
  0057a	ba a3 01 00 00	 mov	 edx, 419		; 000001a3H
  0057f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159405
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 420  : 
; 421  :         MSGBUF( buf, "fast hits ....... %10"PRId64, cacheblk[ix].fasthits);

  0058c	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00591	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0059c	4c 8b 4c 01 28	 mov	 r9, QWORD PTR [rcx+rax+40]
  005a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159406
  005a8	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  005ad	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 422  :         WRMSG(HHC02294, "I", buf);

  005bb	b9 01 00 00 00	 mov	 ecx, 1
  005c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159407
  005da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159408
  005e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159409
  005fd	ba a6 01 00 00	 mov	 edx, 422		; 000001a6H
  00602	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159410
  00609	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 423  : 
; 424  :         MSGBUF( buf, "misses .......... %10"PRId64, cacheblk[ix].misses);

  0060f	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00614	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00618	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0061f	4c 8b 4c 01 30	 mov	 r9, QWORD PTR [rcx+rax+48]
  00624	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159411
  0062b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00630	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00638	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 425  :         WRMSG(HHC02294, "I", buf);

  0063e	b9 01 00 00 00	 mov	 ecx, 1
  00643	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00649	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00651	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00656	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159412
  0065d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00662	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159413
  00669	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0066e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00673	41 b9 03 00 00
	00		 mov	 r9d, 3
  00679	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159414
  00680	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159415
  0068c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  : 
; 427  :         MSGBUF( buf, "hit%% ............ %10d", cache_hit_percent(ix));

  00692	8b 4c 24 50	 mov	 ecx, DWORD PTR ix$[rsp]
  00696	e8 00 00 00 00	 call	 cache_hit_percent
  0069b	44 8b c8	 mov	 r9d, eax
  0069e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159416
  006a5	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  006aa	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  006b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 428  :         WRMSG(HHC02294, "I", buf);

  006b8	b9 01 00 00 00	 mov	 ecx, 1
  006bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  006cb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159417
  006d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159418
  006e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159419
  006fa	ba ac 01 00 00	 mov	 edx, 428		; 000001acH
  006ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159420
  00706	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 429  : 
; 430  :         MSGBUF( buf, "age ............. %10"PRId64, cacheblk[ix].age);

  0070c	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00711	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00715	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0071c	4c 8b 4c 01 38	 mov	 r9, QWORD PTR [rcx+rax+56]
  00721	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159421
  00728	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0072d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00735	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 431  :         WRMSG(HHC02294, "I", buf);

  0073b	b9 01 00 00 00	 mov	 ecx, 1
  00740	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00746	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0074e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159422
  0075a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159423
  00766	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0076b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00770	41 b9 03 00 00
	00		 mov	 r9d, 3
  00776	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159424
  0077d	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  00782	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159425
  00789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 432  : 
; 433  :         MSGBUF( buf, "last adjusted ... %s", cacheblk[ix].atime == 0 ? "none\n" : ctime(&cacheblk[ix].atime));

  0078f	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00794	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00798	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0079f	48 83 7c 01 58
	00		 cmp	 QWORD PTR [rcx+rax+88], 0
  007a5	75 0e		 jne	 SHORT $LN20@cachestats
  007a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159426
  007ae	48 89 44 24 58	 mov	 QWORD PTR tv425[rsp], rax
  007b3	eb 22		 jmp	 SHORT $LN21@cachestats
$LN20@cachestats:
  007b5	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  007ba	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  007be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  007c5	48 8d 44 01 58	 lea	 rax, QWORD PTR [rcx+rax+88]
  007ca	48 8b c8	 mov	 rcx, rax
  007cd	e8 00 00 00 00	 call	 ctime
  007d2	48 89 44 24 58	 mov	 QWORD PTR tv425[rsp], rax
$LN21@cachestats:
  007d7	4c 8b 4c 24 58	 mov	 r9, QWORD PTR tv425[rsp]
  007dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159427
  007e3	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  007e8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 434  :         buf[strlen(buf)-1] = '\0';

  007f6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007fe	e8 00 00 00 00	 call	 strlen
  00803	48 ff c8	 dec	 rax
  00806	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  0080b	48 81 7c 24 60
	80 00 00 00	 cmp	 QWORD PTR $T1[rsp], 128	; 00000080H
  00814	73 02		 jae	 SHORT $LN22@cachestats
  00816	eb 05		 jmp	 SHORT $LN23@cachestats
$LN22@cachestats:
  00818	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@cachestats:
  0081d	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00822	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 435  :         WRMSG(HHC02294, "I", buf);

  0082a	b9 01 00 00 00	 mov	 ecx, 1
  0082f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00835	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0083d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00842	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159428
  00849	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0084e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159429
  00855	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0085a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0085f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00865	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159430
  0086c	ba b3 01 00 00	 mov	 edx, 435		; 000001b3H
  00871	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159431
  00878	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 436  : 
; 437  :         MSGBUF( buf, "last wait ....... %s", cacheblk[ix].wtime == 0 ? "none\n" : ctime(&cacheblk[ix].wtime));

  0087e	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00883	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00887	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0088e	48 83 7c 01 60
	00		 cmp	 QWORD PTR [rcx+rax+96], 0
  00894	75 0e		 jne	 SHORT $LN24@cachestats
  00896	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159432
  0089d	48 89 44 24 68	 mov	 QWORD PTR tv456[rsp], rax
  008a2	eb 22		 jmp	 SHORT $LN25@cachestats
$LN24@cachestats:
  008a4	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  008a9	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  008ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  008b4	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  008b9	48 8b c8	 mov	 rcx, rax
  008bc	e8 00 00 00 00	 call	 ctime
  008c1	48 89 44 24 68	 mov	 QWORD PTR tv456[rsp], rax
$LN25@cachestats:
  008c6	4c 8b 4c 24 68	 mov	 r9, QWORD PTR tv456[rsp]
  008cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159433
  008d2	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  008d7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  008df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 438  :         buf[strlen(buf)-1] = '\0';

  008e5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  008ed	e8 00 00 00 00	 call	 strlen
  008f2	48 ff c8	 dec	 rax
  008f5	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  008fa	48 81 7c 24 70
	80 00 00 00	 cmp	 QWORD PTR $T2[rsp], 128	; 00000080H
  00903	73 02		 jae	 SHORT $LN26@cachestats
  00905	eb 05		 jmp	 SHORT $LN27@cachestats
$LN26@cachestats:
  00907	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN27@cachestats:
  0090c	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp]
  00911	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 439  :         WRMSG(HHC02294, "I", buf);

  00919	b9 01 00 00 00	 mov	 ecx, 1
  0091e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00924	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0092c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00931	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159434
  00938	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0093d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159435
  00944	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00949	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0094e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00954	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159436
  0095b	ba b7 01 00 00	 mov	 edx, 439		; 000001b7H
  00960	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159437
  00967	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 440  : 
; 441  :         MSGBUF( buf, "adjustments ..... %10d", cacheblk[ix].adjusts);

  0096d	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00972	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00976	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  0097d	44 8b 4c 01 68	 mov	 r9d, DWORD PTR [rcx+rax+104]
  00982	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159438
  00989	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0098e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00996	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 442  :         WRMSG(HHC02294, "I", buf);

  0099c	b9 01 00 00 00	 mov	 ecx, 1
  009a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009a7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  009af	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159439
  009bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159440
  009c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  009d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159441
  009de	ba ba 01 00 00	 mov	 edx, 442		; 000001baH
  009e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159442
  009ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 443  : 
; 444  :         if (argc > 1)

  009f0	83 bc 24 40 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  009f8	0f 8e 6e 01 00
	00		 jle	 $LN18@cachestats

; 445  :         {
; 446  :             for (i = 0; i < cacheblk[ix].nbr; i++)

  009fe	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a06	eb 0a		 jmp	 SHORT $LN16@cachestats
$LN14@cachestats:
  00a08	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00a0c	ff c0		 inc	 eax
  00a0e	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN16@cachestats:
  00a12	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a17	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00a1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00a22	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00a26	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00a2a	0f 8d 3c 01 00
	00		 jge	 $LN15@cachestats

; 447  :             {
; 448  :                 MSGBUF( buf, "[%4d] %16.16"PRIx64" %8.8x %10p %6d %10"PRId64,

  00a30	48 63 44 24 50	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a35	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00a39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cacheblk
  00a40	48 63 54 24 54	 movsxd	 rdx, DWORD PTR i$[rsp]
  00a45	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00a49	48 8b 44 01 50	 mov	 rax, QWORD PTR [rcx+rax+80]
  00a4e	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00a53	48 6b c9 70	 imul	 rcx, rcx, 112		; 00000070H
  00a57	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cacheblk
  00a5e	4c 63 4c 24 54	 movsxd	 r9, DWORD PTR i$[rsp]
  00a63	4d 6b c9 28	 imul	 r9, r9, 40		; 00000028H
  00a67	49 8b 4c 08 50	 mov	 rcx, QWORD PTR [r8+rcx+80]
  00a6c	4c 63 44 24 50	 movsxd	 r8, DWORD PTR ix$[rsp]
  00a71	4d 6b c0 70	 imul	 r8, r8, 112		; 00000070H
  00a75	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:cacheblk
  00a7c	4c 63 5c 24 54	 movsxd	 r11, DWORD PTR i$[rsp]
  00a81	4d 6b db 28	 imul	 r11, r11, 40		; 00000028H
  00a85	4f 8b 44 02 50	 mov	 r8, QWORD PTR [r10+r8+80]
  00a8a	4c 63 54 24 50	 movsxd	 r10, DWORD PTR ix$[rsp]
  00a8f	4d 6b d2 70	 imul	 r10, r10, 112		; 00000070H
  00a93	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:cacheblk
  00a9a	48 63 7c 24 54	 movsxd	 rdi, DWORD PTR i$[rsp]
  00a9f	48 6b ff 28	 imul	 rdi, rdi, 40		; 00000028H
  00aa3	4a 8b 5c 13 50	 mov	 rbx, QWORD PTR [rbx+r10+80]
  00aa8	4c 63 54 24 50	 movsxd	 r10, DWORD PTR ix$[rsp]
  00aad	4d 6b d2 70	 imul	 r10, r10, 112		; 00000070H
  00ab1	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:cacheblk
  00ab8	48 63 6c 24 54	 movsxd	 rbp, DWORD PTR i$[rsp]
  00abd	48 6b ed 28	 imul	 rbp, rbp, 40		; 00000028H
  00ac1	4a 8b 74 16 50	 mov	 rsi, QWORD PTR [rsi+r10+80]
  00ac6	48 8b 44 10 20	 mov	 rax, QWORD PTR [rax+rdx+32]
  00acb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00ad0	42 8b 44 09 0c	 mov	 eax, DWORD PTR [rcx+r9+12]
  00ad5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00ad9	4b 8b 44 18 10	 mov	 rax, QWORD PTR [r8+r11+16]
  00ade	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ae3	8b 44 3b 08	 mov	 eax, DWORD PTR [rbx+rdi+8]
  00ae7	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00aeb	48 8b 04 2e	 mov	 rax, QWORD PTR [rsi+rbp]
  00aef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00af4	44 8b 4c 24 54	 mov	 r9d, DWORD PTR i$[rsp]
  00af9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159444
  00b00	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00b05	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00b0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 449  :                     i, cacheblk[ix].cache[i].key, cacheblk[ix].cache[i].flag,
; 450  :                     cacheblk[ix].cache[i].buf, cacheblk[ix].cache[i].len,
; 451  :                     cacheblk[ix].cache[i].age);
; 452  :                 WRMSG(HHC02294, "I", buf);

  00b13	b9 01 00 00 00	 mov	 ecx, 1
  00b18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b1e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00b26	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159445
  00b32	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159446
  00b3e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b43	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b48	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b4e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159447
  00b55	ba c4 01 00 00	 mov	 edx, 452		; 000001c4H
  00b5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159448
  00b61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 453  :             }

  00b67	e9 9c fe ff ff	 jmp	 $LN14@cachestats
$LN15@cachestats:
$LN18@cachestats:

; 454  :         }
; 455  :     }

  00b6c	e9 f3 f4 ff ff	 jmp	 $LN11@cachestats
$LN12@cachestats:

; 456  : 
; 457  :     RELEASE_GLOBAL_CACHE_LOCK();

  00b71	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b78	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  00b7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159449
  00b85	48 8b c8	 mov	 rcx, rax
  00b88	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 458  :     return 0;

  00b8e	33 c0		 xor	 eax, eax
$LN19@cachestats:

; 459  : }

  00b90	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b98	48 33 cc	 xor	 rcx, rsp
  00b9b	e8 00 00 00 00	 call	 __security_check_cookie
  00ba0	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00ba7	5f		 pop	 rdi
  00ba8	5e		 pop	 rsi
  00ba9	5d		 pop	 rbp
  00baa	5b		 pop	 rbx
  00bab	c3		 ret	 0
cachestats_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
ctime	PROC

; 474  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 475  :             return _ctime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ctime64

; 476  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
ctime	ENDP
_TEXT	ENDS
END
