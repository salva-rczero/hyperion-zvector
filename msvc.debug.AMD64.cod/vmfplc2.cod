; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG169205 DB	'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@+-:_', 00H
	ORG $+4
$SG169207 DB	'0123456', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
PLCH_hdr DB	02H
	DB	0d7H
	DB	0d3H
	DB	0c3H
	DB	0c8H
	ORG $+3
PLCD_hdr DB	02H
	DB	0d7H
	DB	0d3H
	DB	0c3H
	DB	0c4H
	ORG $+3
CMS__hdr DB	02H
	DB	0c3H
	DB	0d4H
	DB	0e2H
	DB	040H
	ORG $+3
CMSN_hdr DB	02H
	DB	0c3H
	DB	0d4H
	DB	0e2H
	DB	0d5H
	ORG $+3
empty_adt	ORG $+6
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	tape_write_block
PUBLIC	main
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_parse_args:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_query_codepage:PROC
EXTRN	__imp_valid_codepage_name:PROC
EXTRN	__imp_set_codepage:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_buf_guest_to_host:PROC
EXTRN	__imp_str_guest_to_host:PROC
EXTRN	__imp_str_host_to_guest:PROC
EXTRN	__imp_het_error:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_open_awstape:PROC
EXTRN	__imp_close_awstape:PROC
EXTRN	__imp_rewind_awstape:PROC
EXTRN	__imp_write_awsmark:PROC
EXTRN	__imp_fsb_awstape:PROC
EXTRN	__imp_read_awstape:PROC
EXTRN	__imp_write_awstape:PROC
EXTRN	__imp_open_het:PROC
EXTRN	__imp_close_het:PROC
EXTRN	__imp_rewind_het:PROC
EXTRN	__imp_write_hetmark:PROC
EXTRN	__imp_fsb_het:PROC
EXTRN	__imp_read_het:PROC
EXTRN	__imp_write_het:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
pgm	DQ	01H DUP (?)
bfr	DB	0ffffH DUP (?)
	ALIGN	4

wrk	DB	0ffffH DUP (?)
	ALIGN	8

defaultcp DQ	01H DUP (?)
?msg@?1??validate_cmsfile@@9@9 DB 0200H DUP (?)		; `validate_cmsfile'::`2'::msg
ctltab	DQ	01H DUP (?)
numctl	DD	01H DUP (?)
?buf@?BE@??parse_ctlfile_stmt@@9@9 DB 040H DUP (?)	; `parse_ctlfile_stmt'::`20'::buf
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$strcaseabbrev DD imagerel strcaseabbrev
	DD	imagerel strcaseabbrev+320
	DD	imagerel $unwind$strcaseabbrev
$pdata$strupper DD imagerel strupper
	DD	imagerel strupper+114
	DD	imagerel $unwind$strupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+97
	DD	imagerel $unwind$syntax
$pdata$parse_parms DD imagerel parse_parms
	DD	imagerel parse_parms+2517
	DD	imagerel $unwind$parse_parms
$pdata$tape_close DD imagerel tape_close
	DD	imagerel tape_close+65
	DD	imagerel $unwind$tape_close
$pdata$tape_open DD imagerel tape_open
	DD	imagerel tape_open+935
	DD	imagerel $unwind$tape_open
$pdata$tape_rewind DD imagerel tape_rewind
	DD	imagerel tape_rewind+361
	DD	imagerel $unwind$tape_rewind
$pdata$tape_fsb DD imagerel tape_fsb
	DD	imagerel tape_fsb+361
	DD	imagerel $unwind$tape_fsb
$pdata$tape_set_position DD imagerel tape_set_position
	DD	imagerel tape_set_position+147
	DD	imagerel $unwind$tape_set_position
$pdata$tape_read DD imagerel tape_read
	DD	imagerel tape_read+375
	DD	imagerel $unwind$tape_read
$pdata$tape_write_mark DD imagerel tape_write_mark
	DD	imagerel tape_write_mark+361
	DD	imagerel $unwind$tape_write_mark
$pdata$tape_write_block DD imagerel $LN7
	DD	imagerel $LN7+407
	DD	imagerel $unwind$tape_write_block
$pdata$write_TAPE_BLOCK DD imagerel write_TAPE_BLOCK
	DD	imagerel write_TAPE_BLOCK+163
	DD	imagerel $unwind$write_TAPE_BLOCK
$pdata$write_TAPE_BLOCKS DD imagerel write_TAPE_BLOCKS
	DD	imagerel write_TAPE_BLOCKS+109
	DD	imagerel $unwind$write_TAPE_BLOCKS
$pdata$init_blocks DD imagerel init_blocks
	DD	imagerel init_blocks+156
	DD	imagerel $unwind$init_blocks
$pdata$append_data DD imagerel append_data
	DD	imagerel append_data+617
	DD	imagerel $unwind$append_data
$pdata$free_blocks DD imagerel free_blocks
	DD	imagerel free_blocks+108
	DD	imagerel $unwind$free_blocks
$pdata$initrecs DD imagerel initrecs
	DD	imagerel initrecs+185
	DD	imagerel $unwind$initrecs
$pdata$addrecs DD imagerel addrecs
	DD	imagerel addrecs+303
	DD	imagerel $unwind$addrecs
$pdata$flushrecs DD imagerel flushrecs
	DD	imagerel flushrecs+491
	DD	imagerel $unwind$flushrecs
$pdata$dump_binary_file DD imagerel dump_binary_file
	DD	imagerel dump_binary_file+807
	DD	imagerel $unwind$dump_binary_file
$pdata$dump_text_file DD imagerel dump_text_file
	DD	imagerel dump_text_file+1273
	DD	imagerel $unwind$dump_text_file
$pdata$dump_structured_file DD imagerel dump_structured_file
	DD	imagerel dump_structured_file+1375
	DD	imagerel $unwind$dump_structured_file
$pdata$dump_file DD imagerel dump_file
	DD	imagerel dump_file+352
	DD	imagerel $unwind$dump_file
$pdata$to_dcb DD imagerel to_dcb
	DD	imagerel to_dcb+56
	DD	imagerel $unwind$to_dcb
$pdata$dcb_to_str DD imagerel dcb_to_str
	DD	imagerel dcb_to_str+350
	DD	imagerel $unwind$dcb_to_str
$pdata$build_fst_block DD imagerel build_fst_block
	DD	imagerel build_fst_block+1101
	DD	imagerel $unwind$build_fst_block
$pdata$build_cms_block DD imagerel build_cms_block
	DD	imagerel build_cms_block+679
	DD	imagerel $unwind$build_cms_block
$pdata$format_fst_datetime DD imagerel format_fst_datetime
	DD	imagerel format_fst_datetime+782
	DD	imagerel $unwind$format_fst_datetime
$pdata$format_cms_datetime DD imagerel format_cms_datetime
	DD	imagerel format_cms_datetime+348
	DD	imagerel $unwind$format_cms_datetime
$pdata$format_fst_info DD imagerel format_fst_info
	DD	imagerel format_fst_info+578
	DD	imagerel $unwind$format_fst_info
$pdata$format_cms_info DD imagerel format_cms_info
	DD	imagerel format_cms_info+500
	DD	imagerel $unwind$format_cms_info
$pdata$validate_fnft DD imagerel validate_fnft
	DD	imagerel validate_fnft+154
	DD	imagerel $unwind$validate_fnft
$pdata$validate_cmsfile DD imagerel validate_cmsfile
	DD	imagerel validate_cmsfile+420
	DD	imagerel $unwind$validate_cmsfile
$pdata$add_ctltab_entry DD imagerel add_ctltab_entry
	DD	imagerel add_ctltab_entry+133
	DD	imagerel $unwind$add_ctltab_entry
$pdata$find_ctltab_entry DD imagerel find_ctltab_entry
	DD	imagerel find_ctltab_entry+271
	DD	imagerel $unwind$find_ctltab_entry
$pdata$parse_ctlfile_stmt DD imagerel parse_ctlfile_stmt
	DD	imagerel parse_ctlfile_stmt+2816
	DD	imagerel $unwind$parse_ctlfile_stmt
$pdata$parse_ctlfile DD imagerel parse_ctlfile
	DD	imagerel parse_ctlfile+676
	DD	imagerel $unwind$parse_ctlfile
$pdata$dodump DD imagerel dodump
	DD	imagerel dodump+2145
	DD	imagerel $unwind$dodump
$pdata$doscan DD imagerel doscan
	DD	imagerel doscan+902
	DD	imagerel $unwind$doscan
$pdata$write_siz DD imagerel write_siz
	DD	imagerel write_siz+212
	DD	imagerel $unwind$write_siz
$pdata$write_rec DD imagerel write_rec
	DD	imagerel write_rec+335
	DD	imagerel $unwind$write_rec
$pdata$endof_rec DD imagerel endof_rec
	DD	imagerel endof_rec+205
	DD	imagerel $unwind$endof_rec
$pdata$log_loaded DD imagerel log_loaded
	DD	imagerel log_loaded+308
	DD	imagerel $unwind$log_loaded
$pdata$log_cms_loaded DD imagerel log_cms_loaded
	DD	imagerel log_cms_loaded+106
	DD	imagerel $unwind$log_cms_loaded
$pdata$log_fst_loaded DD imagerel log_fst_loaded
	DD	imagerel log_fst_loaded+106
	DD	imagerel $unwind$log_fst_loaded
$pdata$log_skipped DD imagerel log_skipped
	DD	imagerel log_skipped+249
	DD	imagerel $unwind$log_skipped
$pdata$log_cms_skipped DD imagerel log_cms_skipped
	DD	imagerel log_cms_skipped+101
	DD	imagerel $unwind$log_cms_skipped
$pdata$log_fst_skipped DD imagerel log_fst_skipped
	DD	imagerel log_fst_skipped+101
	DD	imagerel $unwind$log_fst_skipped
$pdata$load_file DD imagerel load_file
	DD	imagerel load_file+2215
	DD	imagerel $unwind$load_file
$pdata$doload_cms DD imagerel doload_cms
	DD	imagerel doload_cms+2210
	DD	imagerel $unwind$doload_cms
$pdata$doload DD imagerel doload
	DD	imagerel doload+2010
	DD	imagerel $unwind$doload
$pdata$main DD	imagerel $LN10
	DD	imagerel $LN10+351
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
validchars DQ	FLAT:$SG169205
validfmnum DQ	FLAT:$SG169207
$SG169228 DB	'DUMP', 00H
	ORG $+3
$SG169230 DB	'LOAD', 00H
	ORG $+3
$SG169232 DB	'SCAN', 00H
	ORG $+3
$SG169233 DB	'???', 00H
$SG169236 DB	'I', 00H
	ORG $+2
$SG169238 DB	'syntax', 00H
	ORG $+1
$SG169237 DB	'HHC02620%s Usage: %s [options] VERB [<ctlfile>] <tapein>'
	DB	' | <tapeout>', 0aH, 'HHC02620I   VERB      desired action    '
	DB	'           (DUMP/LOAD/SCAN)', 0aH, 'HHC02620I   ctlfile   fil'
	DB	'ename of control file     (DUMP/LOAD only)', 0aH, 'HHC02620I '
	DB	'  tapein    filename of input tape file  (LOAD/SCAN only)', 0aH
	DB	'HHC02620I   tapeout   filename of output tape file (DUMP only'
	DB	')', 0aH, 'HHC02620I Options:', 0aH, 'HHC02620I   -c cp     de'
	DB	'sired translation codepage', 0aH, 'HHC02620I   -t        read'
	DB	'/write tape in CMS ''TAPE'' DUMP format', 0aH, 'HHC02620I   -'
	DB	'v        don''t suppress certain informational messages', 0aH
	DB	'HHC02620I   -u        create uncompressed .aws output', 0aH, 'H'
	DB	'HC02620I   -z        create compressed .het using zlib (defau'
	DB	'lt)', 0aH, 'HHC02620I   -b        create compressed .het usin'
	DB	'g bzip2', 0aH, 'HHC02620I   -4        desired compression lev'
	DB	'el (-1, -2 ... -9)', 0aH, 00H
$SG169267 DB	'E', 00H
	ORG $+2
$SG169239 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169273 DB	'E', 00H
	ORG $+2
$SG169266 DB	'code page', 00H
	ORG $+2
$SG169279 DB	'option', 00H
	ORG $+1
$SG169280 DB	'E', 00H
	ORG $+2
$SG169268 DB	'HHC02622%s %s not specified', 0aH, 00H
	ORG $+3
$SG169269 DB	'parse_parms', 00H
$SG169286 DB	'E', 00H
	ORG $+2
$SG169270 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169300 DB	'E', 00H
	ORG $+2
$SG169272 DB	'code page', 00H
	ORG $+2
$SG169307 DB	'E', 00H
	ORG $+2
$SG169274 DB	'HHC02621%s Invalid %s "%s"', 0aH, 00H
$SG169315 DB	'E', 00H
	ORG $+2
$SG169275 DB	'parse_parms', 00H
$SG169322 DB	'E', 00H
	ORG $+2
$SG169276 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169321 DB	'infile', 00H
	ORG $+1
$SG169328 DB	'E', 00H
	ORG $+2
$SG169281 DB	'HHC02621%s Invalid %s "%s"', 0aH, 00H
$SG169336 DB	'I', 00H
	ORG $+2
$SG169282 DB	'parse_parms', 00H
$SG169369 DB	'E', 00H
	ORG $+2
$SG169283 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169285 DB	'VERB', 00H
	ORG $+3
$SG169334 DB	'Output', 00H
	ORG $+1
$SG169375 DB	'E', 00H
	ORG $+2
$SG169287 DB	'HHC02622%s %s not specified', 0aH, 00H
	ORG $+3
$SG169288 DB	'parse_parms', 00H
$SG169388 DB	'E', 00H
	ORG $+2
$SG169289 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169292 DB	'DUMP', 00H
	ORG $+3
$SG169295 DB	'SCAN', 00H
	ORG $+3
$SG169298 DB	'LOAD', 00H
	ORG $+3
$SG169335 DB	'Input', 00H
	ORG $+2
$SG169394 DB	'E', 00H
	ORG $+2
$SG169299 DB	'function', 00H
	ORG $+3
$SG169407 DB	'E', 00H
	ORG $+2
$SG169301 DB	'HHC02621%s Invalid %s "%s"', 0aH, 00H
$SG169413 DB	'E', 00H
	ORG $+2
$SG169302 DB	'parse_parms', 00H
$SG169440 DB	'E', 00H
	ORG $+2
$SG169303 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169446 DB	'E', 00H
	ORG $+2
$SG169306 DB	'tape file', 00H
	ORG $+2
$SG169459 DB	'E', 00H
	ORG $+2
$SG169308 DB	'HHC02622%s %s not specified', 0aH, 00H
	ORG $+3
$SG169309 DB	'parse_parms', 00H
$SG169465 DB	'E', 00H
	ORG $+2
$SG169310 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169482 DB	'E', 00H
	ORG $+2
$SG169314 DB	'ctlfile', 00H
$SG169316 DB	'HHC02622%s %s not specified', 0aH, 00H
	ORG $+3
$SG169317 DB	'parse_parms', 00H
$SG169488 DB	'E', 00H
	ORG $+2
$SG169318 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169678 DB	'rb', 00H
	ORG $+1
$SG169320 DB	'outfile', 00H
$SG169323 DB	'HHC02622%s %s not specified', 0aH, 00H
	ORG $+3
$SG169324 DB	'parse_parms', 00H
$SG169679 DB	'E', 00H
	ORG $+2
$SG169325 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169685 DB	'E', 00H
	ORG $+2
$SG169327 DB	'argument', 00H
	ORG $+3
$SG169752 DB	'r', 00H
	ORG $+2
$SG169329 DB	'HHC02621%s Invalid %s "%s"', 0aH, 00H
$SG169753 DB	'E', 00H
	ORG $+2
$SG169330 DB	'parse_parms', 00H
$SG169766 DB	'E', 00H
	ORG $+2
$SG169331 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169789 DB	'W', 00H
	ORG $+2
$SG169332 DB	'CMS TAPE', 00H
	ORG $+3
$SG169845 DB	'rb', 00H
	ORG $+1
$SG169333 DB	'VMFPLC2', 00H
$SG169337 DB	'HHC02637%s %s tape format set to %s', 0aH, 00H
	ORG $+3
$SG169338 DB	'parse_parms', 00H
$SG169846 DB	'E', 00H
	ORG $+2
$SG169339 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169853 DB	'E', 00H
	ORG $+2
$SG169368 DB	'open_het()', 00H
	ORG $+1
$SG169857 DB	'E', 00H
	ORG $+2
$SG169370 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169371 DB	'tape_open', 00H
	ORG $+2
$SG169875 DB	'E', 00H
	ORG $+2
$SG169372 DB	'vmfplc2.c', 00H
	ORG $+2
$SG169879 DB	'E', 00H
	ORG $+2
$SG169374 DB	'open_awstape()', 00H
	ORG $+1
$SG169376 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169377 DB	'tape_open', 00H
	ORG $+2
$SG169926 DB	'E', 00H
	ORG $+2
$SG169378 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170132 DB	'20', 00H
	ORG $+1
$SG169387 DB	'rewind_het()', 00H
	ORG $+3
$SG169389 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169390 DB	'tape_rewind', 00H
$SG170133 DB	'19', 00H
	ORG $+1
$SG169391 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170136 DB	'00', 00H
	ORG $+1
$SG169393 DB	'rewind_awstape()', 00H
	ORG $+3
$SG170069 DB	'%2.2u', 00H
	ORG $+2
$SG170273 DB	'@TM', 00H
$SG169395 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169396 DB	'tape_rewind', 00H
$SG170347 DB	'@TM', 00H
$SG169397 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170348 DB	'@TM', 00H
$SG169406 DB	'fsb_het()', 00H
	ORG $+2
$SG170382 DB	'BINARY', 00H
	ORG $+1
$SG170384 DB	'TXT', 00H
$SG169408 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169409 DB	'tape_fsb', 00H
	ORG $+3
$SG170116 DB	'%2.2u', 00H
	ORG $+2
$SG170401 DB	'E', 00H
	ORG $+2
$SG169410 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170405 DB	'E', 00H
	ORG $+2
$SG169412 DB	'fsb_awstape()', 00H
	ORG $+2
$SG169414 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169415 DB	'tape_fsb', 00H
	ORG $+3
$SG170366 DB	'FIXED', 00H
	ORG $+2
$SG170409 DB	'E', 00H
	ORG $+2
$SG169416 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170432 DB	'r', 00H
	ORG $+2
$SG169439 DB	'read_het()', 00H
	ORG $+1
$SG170433 DB	'E', 00H
	ORG $+2
$SG169441 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169442 DB	'tape_read', 00H
	ORG $+2
$SG170439 DB	'E', 00H
	ORG $+2
$SG169443 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170453 DB	'W', 00H
	ORG $+2
$SG169445 DB	'read_awstape()', 00H
	ORG $+1
$SG169447 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169448 DB	'tape_read', 00H
	ORG $+2
$SG170487 DB	'I', 00H
	ORG $+2
$SG169449 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170489 DB	'dodump', 00H
	ORG $+1
$SG170494 DB	'@TM', 00H
$SG169458 DB	'write_hetmark()', 00H
$SG169460 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169461 DB	'tape_write_mark', 00H
$SG169462 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170496 DB	'@TM', 00H
$SG169464 DB	'write_awsmark()', 00H
$SG169466 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169467 DB	'tape_write_mark', 00H
$SG169468 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170497 DB	'I', 00H
	ORG $+2
$SG169481 DB	'write_het()', 00H
$SG170503 DB	'I', 00H
	ORG $+2
$SG169483 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169484 DB	'tape_write_block', 00H
	ORG $+3
$SG170499 DB	'dodump', 00H
	ORG $+1
$SG170520 DB	'I', 00H
	ORG $+2
$SG169485 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170505 DB	'dodump', 00H
	ORG $+1
$SG170528 DB	'@TM', 00H
$SG169487 DB	'write_awstape()', 00H
$SG169489 DB	'HHC02624%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169490 DB	'tape_write_block', 00H
	ORG $+3
$SG170522 DB	'dodump', 00H
	ORG $+1
$SG170529 DB	'I', 00H
	ORG $+2
$SG169491 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170531 DB	'dodump', 00H
	ORG $+1
$SG170535 DB	'@TM', 00H
$SG169680 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG169681 DB	'dump_binary_file', 00H
	ORG $+3
$SG170536 DB	'I', 00H
	ORG $+2
$SG169682 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170538 DB	'dodump', 00H
	ORG $+1
$SG170541 DB	'I', 00H
	ORG $+2
$SG169686 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG169687 DB	'dump_binary_file', 00H
	ORG $+3
$SG170543 DB	'dodump', 00H
	ORG $+1
$SG170546 DB	'I', 00H
	ORG $+2
$SG169688 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170548 DB	'dodump', 00H
	ORG $+1
$SG170565 DB	'I', 00H
	ORG $+2
$SG169690 DB	'dump_binary_file', 00H
	ORG $+3
$SG170567 DB	'doscan', 00H
	ORG $+1
$SG170574 DB	'I', 00H
	ORG $+2
$SG169691 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169694 DB	'dump_binary_file', 00H
	ORG $+7
$SG169692 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169695 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169699 DB	'dump_binary_file', 00H
	ORG $+7
$SG169696 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169700 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169703 DB	'dump_binary_file', 00H
	ORG $+7
$SG169701 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169704 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169754 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG169705 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169755 DB	'dump_text_file', 00H
	ORG $+1
$SG169756 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170576 DB	'doscan', 00H
	ORG $+1
$SG170579 DB	'I', 00H
	ORG $+2
$SG169767 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG169768 DB	'dump_text_file', 00H
	ORG $+1
$SG169769 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170581 DB	'doscan', 00H
	ORG $+1
$SG170583 DB	'@TM', 00H
$SG169771 DB	'dump_text_file', 00H
	ORG $+1
$SG169772 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169773 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169775 DB	'dump_text_file', 00H
	ORG $+1
$SG169776 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169780 DB	'dump_text_file', 00H
	ORG $+1
$SG169847 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG169777 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169781 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169784 DB	'dump_text_file', 00H
	ORG $+1
$SG169848 DB	'dump_structured_file', 00H
	ORG $+3
$SG169782 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169785 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169791 DB	'dump_text_file', 00H
	ORG $+1
$SG169854 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG169786 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169855 DB	'dump_structured_file', 00H
	ORG $+3
$SG169790 DB	'HHC02628%s lrecl %u less than %u; one or more records tr'
	DB	'uncated', 0aH, 00H
	ORG $+3
$SG170584 DB	'I', 00H
	ORG $+2
$SG169792 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170586 DB	'doscan', 00H
	ORG $+1
$SG170589 DB	'I', 00H
	ORG $+2
$SG169849 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170591 DB	'doscan', 00H
	ORG $+1
$SG170608 DB	'E', 00H
	ORG $+2
$SG169856 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169859 DB	'dump_structured_file', 00H
	ORG $+3
$SG169858 DB	'HHC02629%s Expected %d bytes from file "%s", but only %d'
	DB	' bytes read', 0aH, 00H
	ORG $+3
$SG169860 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170636 DB	'E', 00H
	ORG $+2
$SG169862 DB	'dump_structured_file', 00H
	ORG $+3
$SG169863 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169864 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169866 DB	'dump_structured_file', 00H
	ORG $+3
$SG169867 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169868 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169877 DB	'dump_structured_file', 00H
	ORG $+3
$SG169876 DB	'HHC02629%s Expected %d bytes from file "%s", but only %d'
	DB	' bytes read', 0aH, 00H
	ORG $+3
$SG169878 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170651 DB	0dH, 0aH, 00H
	ORG $+1
$SG169880 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG169881 DB	'dump_structured_file', 00H
	ORG $+3
$SG169882 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170652 DB	'E', 00H
	ORG $+2
$SG169884 DB	'dump_structured_file', 00H
	ORG $+3
$SG169885 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169886 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169888 DB	'dump_structured_file', 00H
	ORG $+3
$SG169889 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169890 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169893 DB	'dump_structured_file', 00H
	ORG $+3
$SG169894 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169895 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169897 DB	'dump_structured_file', 00H
	ORG $+3
$SG169898 DB	'vmfplc2.c', 00H
	ORG $+6
$SG169899 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169925 DB	'0001', 00H
	ORG $+3
$SG169927 DB	'HHC02634%s INTERNAL ERROR %s', 0aH, 00H
	ORG $+2
$SG169928 DB	'dump_file', 00H
	ORG $+2
$SG170666 DB	'I', 00H
	ORG $+2
$SG169929 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170672 DB	'I', 00H
	ORG $+2
$SG170016 DB	'dcb_to_str', 00H
	ORG $+1
$SG170700 DB	'I', 00H
	ORG $+2
$SG170017 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170018 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170020 DB	'dcb_to_str', 00H
	ORG $+1
$SG170705 DB	'I', 00H
	ORG $+2
$SG170021 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170026 DB	'%02u', 00H
	ORG $+7
$SG170022 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170137 DB	'%2.2s%2.2s-%2.2s-%2.2s %2.2s:%2.2s:%2.2s', 00H
	ORG $+3
$SG170859 DB	'I', 00H
	ORG $+2
$SG170151 DB	'%s/%s/%s %s:%s', 00H
	ORG $+1
$SG170170 DB	'%-8s %-8s %-2s %c %-5u %s recs %4u blks %u', 00H
	ORG $+1
$SG170885 DB	'wb', 00H
	ORG $+1
$SG170188 DB	'%-8s %-8s %-2s %c %-5u %s recs %4u blks %u', 00H
	ORG $+1
$SG170886 DB	'E', 00H
	ORG $+2
$SG170218 DB	'CMS File name too long', 00H
	ORG $+1
$SG170220 DB	'CMS File type too long', 00H
	ORG $+1
$SG170222 DB	'CMS File mode too long', 00H
	ORG $+1
$SG170224 DB	'name', 00H
	ORG $+3
$SG170225 DB	'Invalid character in CMS file %s at position %d', 00H
$SG170227 DB	'type', 00H
	ORG $+3
$SG170228 DB	'Invalid character in CMS file %s at position %d', 00H
$SG170230 DB	'CMS File mode must start with a letter', 00H
	ORG $+1
$SG170233 DB	'CMS File mode number must be 0-6', 00H
	ORG $+3
$SG170904 DB	'W', 00H
	ORG $+2
$SG170343 DB	'Invalid codepage', 00H
	ORG $+3
$SG170908 DB	'@TM', 00H
$SG170345 DB	'File name missing', 00H
	ORG $+2
$SG170909 DB	'I', 00H
	ORG $+2
$SG170350 DB	'parse_ctlfile_stmt', 00H
	ORG $+1
$SG170924 DB	'I', 00H
	ORG $+2
$SG170351 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170354 DB	'parse_ctlfile_stmt', 00H
	ORG $+5
$SG170352 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170355 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170359 DB	'File type missing', 00H
	ORG $+6
$SG170356 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170361 DB	'File mode missing', 00H
	ORG $+2
$SG170978 DB	'I', 00H
	ORG $+2
$SG170364 DB	'Record format missing', 00H
	ORG $+2
$SG170367 DB	'VARIABLE', 00H
	ORG $+3
$SG170980 DB	'doload', 00H
	ORG $+1
$SG171003 DB	'wb', 00H
	ORG $+1
$SG170368 DB	'Record format must be ''F''ixed or ''V''ariable', 00H
$SG171004 DB	'E', 00H
	ORG $+2
$SG170372 DB	'Logical Record Length missing for ''F''ixed record forma'
	DB	't file', 00H
	ORG $+3
$SG170375 DB	'Logical Record Length must be a numeric value', 00H
	ORG $+2
$SG170378 DB	'Logical Record Length must be between 1 and %u', 00H
	ORG $+1
$SG170380 DB	'File format is missing', 00H
	ORG $+1
$SG170383 DB	'TEXTUAL', 00H
$SG170385 DB	'STRUCTURED', 00H
	ORG $+1
$SG171011 DB	'W', 00H
	ORG $+2
$SG170386 DB	'File format must be either ''B''inary, ''T''extual or '''
	DB	'S''tructured', 00H
	ORG $+1
$SG170388 DB	'Input file name missing', 00H
$SG170393 DB	'parse_ctlfile_stmt', 00H
	ORG $+5
$SG170390 DB	'Dumping structured input to anything other than RECFM V '
	DB	'is not supported', 00H
	ORG $+3
$SG170990 DB	'doload', 00H
	ORG $+1
$SG171015 DB	'@TM', 00H
$SG170394 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170397 DB	'parse_ctlfile_stmt', 00H
	ORG $+5
$SG170395 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170398 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170402 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170399 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170403 DB	'parse_ctlfile_stmt', 00H
	ORG $+1
$SG171016 DB	'I', 00H
	ORG $+2
$SG170404 DB	'vmfplc2.c', 00H
	ORG $+2
$SG170994 DB	'doload', 00H
	ORG $+1
$SG171031 DB	'I', 00H
	ORG $+2
$SG170406 DB	'HHC02632%s     Bad entry at line %d in file "%s"', 0aH, 00H
	ORG $+2
$SG171006 DB	'doload', 00H
	ORG $+1
$SG171053 DB	'E', 00H
	ORG $+2
$SG170407 DB	'parse_ctlfile_stmt', 00H
	ORG $+5
$SG170408 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170410 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170411 DB	'parse_ctlfile_stmt', 00H
	ORG $+5
$SG170412 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170434 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG170435 DB	'parse_ctlfile', 00H
	ORG $+2
$SG170436 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170440 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG170441 DB	'parse_ctlfile', 00H
	ORG $+2
$SG170442 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170444 DB	'parse_ctlfile', 00H
	ORG $+2
$SG170445 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170446 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170448 DB	'parse_ctlfile', 00H
	ORG $+2
$SG170449 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170454 DB	'HHC02630%s %d errors encountered', 0aH, 00H
	ORG $+6
$SG170450 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170455 DB	'parse_ctlfile', 00H
	ORG $+2
$SG170456 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170486 DB	'DUMPING...', 00H
	ORG $+5
$SG170488 DB	'HHC02625%s %s', 0aH, 00H
	ORG $+1
$SG170490 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170498 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170500 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170504 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170506 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170521 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170523 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170530 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170532 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170537 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170539 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170542 DB	'HHC02631%s %s complete', 0aH, 00H
$SG170544 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170547 DB	'HHC02635%s Tape "%s" created', 0aH, 00H
	ORG $+2
$SG170549 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170564 DB	'SCANNING...', 00H
	ORG $+4
$SG170566 DB	'HHC02625%s %s', 0aH, 00H
	ORG $+1
$SG170568 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170575 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170577 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170580 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170582 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170585 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170587 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170590 DB	'HHC02631%s %s complete', 0aH, 00H
$SG170592 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170609 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG170610 DB	'write_siz', 00H
	ORG $+6
$SG170611 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170637 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG170638 DB	'write_rec', 00H
	ORG $+6
$SG170639 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170653 DB	'HHC02627%s I/O error on file "%s": %s', 0aH, 00H
	ORG $+1
$SG170654 DB	'endof_rec', 00H
	ORG $+6
$SG170655 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170665 DB	'LOADING:    %s', 00H
	ORG $+1
$SG170667 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170668 DB	'log_loaded', 00H
	ORG $+5
$SG170669 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170671 DB	'     to:    %s', 00H
	ORG $+1
$SG170673 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170674 DB	'log_loaded', 00H
	ORG $+5
$SG170675 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170699 DB	'SKIPPED:    %s', 00H
	ORG $+1
$SG170701 DB	'HHC02626%s >>> %s', 0aH, 00H
	ORG $+5
$SG170702 DB	'log_skipped', 00H
	ORG $+4
$SG170703 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170704 DB	'            (no matching ctlfile entry)', 00H
$SG170706 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170707 DB	'log_skipped', 00H
	ORG $+4
$SG170708 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170784 DB	'load_file', 00H
	ORG $+6
$SG170785 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170858 DB	'LOADING...', 00H
	ORG $+5
$SG170860 DB	'HHC02625%s %s', 0aH, 00H
	ORG $+1
$SG170887 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG170786 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170788 DB	'load_file', 00H
	ORG $+6
$SG170789 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170861 DB	'doload_cms', 00H
	ORG $+5
$SG170905 DB	'HHC02636%s Invalid block encountered @ %d:%d', 0aH, 00H
	ORG $+2
$SG170910 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170790 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170862 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170874 DB	'doload_cms', 00H
	ORG $+5
$SG170875 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170878 DB	'doload_cms', 00H
	ORG $+5
$SG170925 DB	'HHC02631%s %s complete', 0aH, 00H
$SG170876 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170879 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170888 DB	'doload_cms', 00H
	ORG $+5
$SG170979 DB	'HHC02625%s %s', 0aH, 00H
	ORG $+1
$SG171005 DB	'HHC02623%s File open error: "%s": %s', 0aH, 00H
	ORG $+2
$SG170880 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170889 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170894 DB	'doload_cms', 00H
	ORG $+5
$SG170895 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170898 DB	'doload_cms', 00H
	ORG $+5
$SG171012 DB	'HHC02636%s Invalid block encountered @ %d:%d', 0aH, 00H
	ORG $+2
$SG171013 DB	'doload', 00H
	ORG $+1
$SG170896 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170899 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170906 DB	'doload_cms', 00H
	ORG $+5
$SG171017 DB	'HHC02633%s     %s', 0aH, 00H
	ORG $+5
$SG170900 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170907 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170911 DB	'doload_cms', 00H
	ORG $+5
$SG170912 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170915 DB	'doload_cms', 00H
	ORG $+5
$SG170916 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170919 DB	'doload_cms', 00H
	ORG $+1
$SG171018 DB	'doload', 00H
	ORG $+5
$SG170917 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170920 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170926 DB	'doload_cms', 00H
	ORG $+1
$SG171022 DB	'doload', 00H
	ORG $+5
$SG170921 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170927 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170977 DB	'LOADING...', 00H
	ORG $+5
$SG170981 DB	'vmfplc2.c', 00H
	ORG $+6
$SG170991 DB	'vmfplc2.c', 00H
	ORG $+2
$SG171026 DB	'doload', 00H
	ORG $+5
$SG170992 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170995 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171032 DB	'HHC02631%s %s complete', 0aH, 00H
$SG170996 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171007 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171014 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171019 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171023 DB	'vmfplc2.c', 00H
	ORG $+2
$SG171033 DB	'doload', 00H
	ORG $+5
$SG171024 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171027 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171045 DB	'VM/CMS VMFPLC2/TAPE Utility', 00H
$SG171052 DB	'0002', 00H
	ORG $+7
$SG171028 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171034 DB	'vmfplc2.c', 00H
	ORG $+6
$SG171046 DB	'vmfplc2', 00H
$SG171054 DB	'HHC02634%s INTERNAL ERROR %s', 0aH, 00H
	ORG $+2
$SG171055 DB	'main', 00H
	ORG $+3
$SG171056 DB	'vmfplc2.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	021H
	DD	0146H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:doload
	DD	018H
	DD	07c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:doload_cms
	DD	018H
	DD	0888H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_fst_skipped
	DD	01bH
	DD	050H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_cms_skipped
	DD	01bH
	DD	050H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_skipped
	DD	016H
	DD	0e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_fst_loaded
	DD	020H
	DD	055H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_cms_loaded
	DD	020H
	DD	055H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_loaded
	DD	020H
	DD	011cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:doscan
	DD	018H
	DD	036cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dodump
	DD	016H
	DD	0849H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:parse_ctlfile_stmt
	DD	027H
	DD	0ae7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:format_cms_info
	DD	021H
	DD	01dbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:format_fst_info
	DD	021H
	DD	0229H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$strcaseabbrev DD 011301H
	DD	08213H
$unwind$strupper DD 010e01H
	DD	0620eH
$unwind$syntax DD 010401H
	DD	08204H
$unwind$parse_parms DD 021501H
	DD	0150115H
$unwind$tape_close DD 010901H
	DD	04209H
$unwind$tape_open DD 010901H
	DD	0e209H
$unwind$tape_rewind DD 010901H
	DD	0e209H
$unwind$tape_fsb DD 010901H
	DD	0e209H
$unwind$tape_set_position DD 010d01H
	DD	0620dH
$unwind$tape_read DD 010901H
	DD	0e209H
$unwind$tape_write_mark DD 010901H
	DD	0e209H
$unwind$tape_write_block DD 011301H
	DD	0e213H
$unwind$write_TAPE_BLOCK DD 011801H
	DD	06218H
$unwind$write_TAPE_BLOCKS DD 010e01H
	DD	0620eH
$unwind$init_blocks DD 011801H
	DD	06218H
$unwind$append_data DD 031501H
	DD	070118215H
	DD	06010H
$unwind$free_blocks DD 010901H
	DD	06209H
$unwind$initrecs DD 011701H
	DD	08217H
$unwind$addrecs DD 011301H
	DD	06213H
$unwind$flushrecs DD 021901H
	DD	070159219H
$unwind$dump_binary_file DD 021b01H
	DD	013011bH
$unwind$dump_text_file DD 031c01H
	DD	016011cH
	DD	07015H
$unwind$dump_structured_file DD 021b01H
	DD	017011bH
$unwind$dump_file DD 011801H
	DD	0a218H
$unwind$to_dcb DD 010801H
	DD	02208H
$unwind$dcb_to_str DD 021901H
	DD	070155219H
$unwind$build_fst_block DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$build_cms_block DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$format_fst_datetime DD 021701H
	DD	07010f217H
$unwind$format_cms_datetime DD 021401H
	DD	07010b214H
$unwind$format_fst_info DD 032919H
	DD	0180117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$format_cms_info DD 032919H
	DD	0180117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$validate_fnft DD 010901H
	DD	02209H
$unwind$validate_cmsfile DD 011301H
	DD	08213H
$unwind$add_ctltab_entry DD 030b01H
	DD	07007620bH
	DD	06006H
$unwind$find_ctltab_entry DD 011301H
	DD	06213H
$unwind$parse_ctlfile_stmt DD 032f19H
	DD	0432011dH
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	02180H
$unwind$parse_ctlfile DD 020c01H
	DD	011010cH
$unwind$dodump DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$doscan DD 042019H
	DD	031010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$write_siz DD 011801H
	DD	0c218H
$unwind$write_rec DD 011801H
	DD	0c218H
$unwind$endof_rec DD 011201H
	DD	0c212H
$unwind$log_loaded DD 022819H
	DD	0370116H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$log_cms_loaded DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$log_fst_loaded DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$log_skipped DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$log_cms_skipped DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$log_fst_skipped DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$load_file DD 021b01H
	DD	011011bH
$unwind$doload_cms DD 042019H
	DD	02b010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$doload DD 042019H
	DD	027010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$main DD	032919H
	DD	03860117H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	01c20H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 64
tv80 = 68
opts$ = 80
__$ArrayPad$ = 7200
argc$ = 7232
argv$ = 7240
main	PROC

; 2804 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	b8 30 1c 00 00	 mov	 eax, 7216		; 00001c30H
  0000f	e8 00 00 00 00	 call	 __chkstk
  00014	48 2b e0	 sub	 rsp, rax
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 20
	1c 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2805 :     int      rc;
; 2806 :     OPTIONS  opts  = {0};

  00029	48 8d 44 24 50	 lea	 rax, QWORD PTR opts$[rsp]
  0002e	48 8b f8	 mov	 rdi, rax
  00031	33 c0		 xor	 eax, eax
  00033	b9 d0 1b 00 00	 mov	 ecx, 7120		; 00001bd0H
  00038	f3 aa		 rep stosb

; 2807 : 
; 2808 :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:pgm
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171045
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171046
  00054	48 8b 94 24 48
	1c 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0005c	8b 8c 24 40 1c
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00069	89 84 24 40 1c
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 2809 : 
; 2810 :     if (parse_parms( argc, argv, &opts ) != 0)

  00070	4c 8d 44 24 50	 lea	 r8, QWORD PTR opts$[rsp]
  00075	48 8b 94 24 48
	1c 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0007d	8b 8c 24 40 1c
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00084	e8 00 00 00 00	 call	 parse_parms
  00089	85 c0		 test	 eax, eax
  0008b	74 0a		 je	 SHORT $LN4@main

; 2811 :         return -1;

  0008d	b8 ff ff ff ff	 mov	 eax, -1
  00092	e9 af 00 00 00	 jmp	 $LN1@main
$LN4@main:

; 2812 : 
; 2813 :     switch (opts.verb)

  00097	0f b6 44 24 6d	 movzx	 eax, BYTE PTR opts$[rsp+29]
  0009c	88 44 24 44	 mov	 BYTE PTR tv80[rsp], al
  000a0	80 7c 24 44 00	 cmp	 BYTE PTR tv80[rsp], 0
  000a5	74 10		 je	 SHORT $LN5@main
  000a7	80 7c 24 44 01	 cmp	 BYTE PTR tv80[rsp], 1
  000ac	74 29		 je	 SHORT $LN7@main
  000ae	80 7c 24 44 02	 cmp	 BYTE PTR tv80[rsp], 2
  000b3	74 12		 je	 SHORT $LN6@main
  000b5	eb 30		 jmp	 SHORT $LN8@main
$LN5@main:

; 2814 :     {
; 2815 :         case DUMP_VERB: rc = dodump( &opts ); break;

  000b7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR opts$[rsp]
  000bc	e8 00 00 00 00	 call	 dodump
  000c1	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000c5	eb 7b		 jmp	 SHORT $LN2@main
$LN6@main:

; 2816 :         case SCAN_VERB: rc = doscan( &opts ); break;

  000c7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR opts$[rsp]
  000cc	e8 00 00 00 00	 call	 doscan
  000d1	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000d5	eb 6b		 jmp	 SHORT $LN2@main
$LN7@main:

; 2817 :         case LOAD_VERB: rc = doload( &opts ); break;

  000d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR opts$[rsp]
  000dc	e8 00 00 00 00	 call	 doload
  000e1	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000e5	eb 5b		 jmp	 SHORT $LN2@main
$LN8@main:

; 2818 : 
; 2819 :         default:
; 2820 :             // "INTERNAL ERROR %s"
; 2821 :             FWRMSG( stderr, HHC02634, "E", "0002" );

  000e7	b9 02 00 00 00	 mov	 ecx, 2
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171052
  000f9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171053
  00105	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171054
  00111	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00116	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00121	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171055
  00128	ba 05 0b 00 00	 mov	 edx, 2821		; 00000b05H
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171056
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2822 :             rc = -1;

  0013a	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN2@main:

; 2823 :             break;
; 2824 :     }
; 2825 : 
; 2826 :     return rc;

  00142	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 2827 : }

  00146	48 8b 8c 24 20
	1c 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014e	48 33 cc	 xor	 rcx, rsp
  00151	e8 00 00 00 00	 call	 __security_check_cookie
  00156	48 81 c4 30 1c
	00 00		 add	 rsp, 7216		; 00001c30H
  0015d	5f		 pop	 rdi
  0015e	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
recfm$ = 84
i$ = 88
rszsplit$ = 92
blksize$ = 96
tapemark_count$ = 100
ctl$ = 104
ofile$ = 112
rsz1$ = 120
recs$ = 124
recrem$ = 128
fm$ = 132
recl$ = 136
tv282 = 140
$T1 = 144
$T2 = 152
tv244 = 160
tv356 = 168
fst$ = 176
ft$ = 256
fn$ = 272
__$ArrayPad$ = 288
opts$ = 336
doload	PROC

; 2650 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2651 :     FILE*    ofile = NULL;

  00020	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR ofile$[rsp], 0

; 2652 :     CTLTAB*  ctl;
; 2653 :     FST      fst;
; 2654 : 
; 2655 :     int   i, rc = 0;

  00029	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2656 :     int   blksize;              // (size of current tape block)
; 2657 :     int   recrem = 0;           // (unwritten record bytes remaining)

  00031	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR recrem$[rsp], 0

; 2658 :     int   recl, recs;
; 2659 :     int   tapemark_count = 0;

  0003c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2660 : 
; 2661 :     char  fn [ sizeof( fst.fn ) + 1 ]  = {0};

  00044	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR fn$[rsp]
  0004c	48 8b f8	 mov	 rdi, rax
  0004f	33 c0		 xor	 eax, eax
  00051	b9 09 00 00 00	 mov	 ecx, 9
  00056	f3 aa		 rep stosb

; 2662 :     char  ft [ sizeof( fst.ft ) + 1 ]  = {0};

  00058	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR ft$[rsp]
  00060	48 8b f8	 mov	 rdi, rax
  00063	33 c0		 xor	 eax, eax
  00065	b9 09 00 00 00	 mov	 ecx, 9
  0006a	f3 aa		 rep stosb

; 2663 :     char  fm [ sizeof( fst.fm ) + 1 ]  = {0};

  0006c	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR fm$[rsp]
  00074	48 8b f8	 mov	 rdi, rax
  00077	33 c0		 xor	 eax, eax
  00079	b9 03 00 00 00	 mov	 ecx, 3
  0007e	f3 aa		 rep stosb

; 2664 :     char  recfm;
; 2665 : 
; 2666 :     bool  rszsplit = false;     // (SPECIAL: rsz split across 2 blocks)

  00080	c6 44 24 5c 00	 mov	 BYTE PTR rszsplit$[rsp], 0

; 2667 :     BYTE  rsz1;                 // (SPECIAL: 1st byte of record size)
; 2668 : 
; 2669 : 
; 2670 :     /* Process CMS 'TAPE' formatted dump tape if requested */
; 2671 :     if (opts->cms)

  00085	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0008d	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00091	85 c0		 test	 eax, eax
  00093	74 12		 je	 SHORT $LN22@doload

; 2672 :         return doload_cms( opts );

  00095	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0009d	e8 00 00 00 00	 call	 doload_cms
  000a2	e9 19 07 00 00	 jmp	 $LN1@doload
$LN22@doload:

; 2673 : 
; 2674 :     // "%s"
; 2675 :     WRMSG( HHC02625, "I", "LOADING..." );

  000a7	b9 01 00 00 00	 mov	 ecx, 1
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170977
  000b9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170978
  000c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170979
  000d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170980
  000e8	ba 73 0a 00 00	 mov	 edx, 2675		; 00000a73H
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170981
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2676 : 
; 2677 :     /* Parse the DUMP control file */
; 2678 :     if ((rc = parse_ctlfile( opts )) != 0)

  000fa	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00102	e8 00 00 00 00	 call	 parse_ctlfile
  00107	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0010b	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00110	74 09		 je	 SHORT $LN23@doload

; 2679 :         return rc;

  00112	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00116	e9 a5 06 00 00	 jmp	 $LN1@doload
$LN23@doload:

; 2680 : 
; 2681 :     /* Open the input tape file */
; 2682 :     if ((rc = tape_open( opts )) != 0)

  0011b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00123	e8 00 00 00 00	 call	 tape_open
  00128	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0012c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00131	74 09		 je	 SHORT $LN24@doload

; 2683 :         return rc;

  00133	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00137	e9 84 06 00 00	 jmp	 $LN1@doload
$LN24@doload:
$LN53@doload:
$LN52@doload:
$LN51@doload:
$LN2@doload:

; 2684 : 
; 2685 :     /* Read tape until end-of-tape reached (two tapemarks in a row) */
; 2686 :     while (1
; 2687 :         && rc >= 0
; 2688 :         && tapemark_count < 2
; 2689 :         && (rc = tape_read( opts )) >= 0

  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 01	 cmp	 eax, 1
  00141	0f 84 7f 05 00
	00		 je	 $LN3@doload
  00147	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0014c	0f 8c 74 05 00
	00		 jl	 $LN3@doload
  00152	83 7c 24 64 02	 cmp	 DWORD PTR tapemark_count$[rsp], 2
  00157	0f 8d 69 05 00
	00		 jge	 $LN3@doload
  0015d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00165	e8 00 00 00 00	 call	 tape_read
  0016a	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0016e	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00173	0f 8c 4d 05 00
	00		 jl	 $LN3@doload

; 2690 :     )
; 2691 :     {
; 2692 :         blksize = rc;

  00179	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  0017d	89 44 24 60	 mov	 DWORD PTR blksize$[rsp], eax

; 2693 : 
; 2694 :         if (blksize)

  00181	83 7c 24 60 00	 cmp	 DWORD PTR blksize$[rsp], 0
  00186	0f 84 d8 04 00
	00		 je	 $LN25@doload

; 2695 :         {
; 2696 :             tapemark_count = 0;

  0018c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2697 : 
; 2698 :             /* Is this a PLCH header (FST) block? */
; 2699 :             if (1
; 2700 :                 && blksize >= BLK_HDRSIZE
; 2701 :                 && memcmp( bfr, PLCH_hdr, BLK_HDRSIZE ) == 0

  00194	33 c0		 xor	 eax, eax
  00196	83 f8 01	 cmp	 eax, 1
  00199	0f 84 a6 03 00
	00		 je	 $LN27@doload
  0019f	83 7c 24 60 05	 cmp	 DWORD PTR blksize$[rsp], 5
  001a4	0f 8c 9b 03 00
	00		 jl	 $LN27@doload
  001aa	41 b8 05 00 00
	00		 mov	 r8d, 5
  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PLCH_hdr
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  001be	e8 00 00 00 00	 call	 memcmp
  001c3	85 c0		 test	 eax, eax
  001c5	0f 85 7a 03 00
	00		 jne	 $LN27@doload

; 2702 :             )
; 2703 :             {
; 2704 :                 /* Close output file if opened */
; 2705 :                 if (ofile)

  001cb	48 83 7c 24 70
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  001d1	74 7a		 je	 SHORT $LN29@doload
$LN6@doload:

; 2706 :                 {
; 2707 :                     VERIFY( fclose( ofile ) == 0 );

  001d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ofile$[rsp]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  001de	85 c0		 test	 eax, eax
  001e0	74 5c		 je	 SHORT $LN30@doload
$LN9@doload:
  001e2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170990
  001e9	41 b8 93 0a 00
	00		 mov	 r8d, 2707		; 00000a93H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170991
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170992
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00209	85 c0		 test	 eax, eax
  0020b	74 20		 je	 SHORT $LN31@doload
  0020d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170994
  00214	41 b8 93 0a 00
	00		 mov	 r8d, 2707		; 00000a93H
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170995
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170996
  00228	e8 00 00 00 00	 call	 DebuggerTrace
$LN31@doload:
  0022d	33 c0		 xor	 eax, eax
  0022f	85 c0		 test	 eax, eax
  00231	75 af		 jne	 SHORT $LN9@doload
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00239	85 c0		 test	 eax, eax
  0023b	74 01		 je	 SHORT $LN32@doload
  0023d	cc		 int	 3
$LN32@doload:
$LN30@doload:
  0023e	33 c0		 xor	 eax, eax
  00240	85 c0		 test	 eax, eax
  00242	75 8f		 jne	 SHORT $LN6@doload

; 2708 :                     ofile = NULL;

  00244	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR ofile$[rsp], 0
$LN29@doload:

; 2709 :                 }
; 2710 : 
; 2711 :                 /* Extract needed FST information */
; 2712 :                 memcpy( &fst, &bfr[ BLK_HDRSIZE ], sizeof( FST ));

  0024d	b8 01 00 00 00	 mov	 eax, 1
  00252	48 6b c0 05	 imul	 rax, rax, 5
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  0025d	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR fst$[rsp]
  00265	48 8b fa	 mov	 rdi, rdx
  00268	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0026c	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00271	f3 a4		 rep movsb

; 2713 : 
; 2714 :                 str_guest_to_host( fst.fn, fn, sizeof( fst.fn ));

  00273	41 b8 08 00 00
	00		 mov	 r8d, 8
  00279	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR fn$[rsp]
  00281	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp]
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2715 :                 str_guest_to_host( fst.ft, ft, sizeof( fst.ft ));

  0028f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00295	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ft$[rsp]
  0029d	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp+8]
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2716 :                 str_guest_to_host( fst.fm, fm, sizeof( fst.fm ));

  002ab	41 b8 02 00 00
	00		 mov	 r8d, 2
  002b1	48 8d 94 24 84
	00 00 00	 lea	 rdx, QWORD PTR fm$[rsp]
  002b9	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp+24]
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2717 : 
; 2718 :                 /* Remove trailing blanks from fn and ft */
; 2719 :                 for (i=(int)(sizeof( fst.fn ) - 1); i >= 0 && fn[i] == ' '; fn[i]=0, i--);

  002c7	c7 44 24 58 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  002cf	eb 39		 jmp	 SHORT $LN12@doload
$LN10@doload:
  002d1	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  002d6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  002de	48 83 bc 24 90
	00 00 00 09	 cmp	 QWORD PTR $T1[rsp], 9
  002e7	73 02		 jae	 SHORT $LN47@doload
  002e9	eb 05		 jmp	 SHORT $LN48@doload
$LN47@doload:
  002eb	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN48@doload:
  002f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  002f8	c6 84 04 10 01
	00 00 00	 mov	 BYTE PTR fn$[rsp+rax], 0
  00300	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00304	ff c8		 dec	 eax
  00306	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN12@doload:
  0030a	83 7c 24 58 00	 cmp	 DWORD PTR i$[rsp], 0
  0030f	7c 14		 jl	 SHORT $LN11@doload
  00311	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00316	0f be 84 04 10
	01 00 00	 movsx	 eax, BYTE PTR fn$[rsp+rax]
  0031e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00321	75 02		 jne	 SHORT $LN11@doload
  00323	eb ac		 jmp	 SHORT $LN10@doload
$LN11@doload:

; 2720 :                 for (i=(int)(sizeof( fst.ft ) - 1); i >= 0 && ft[i] == ' '; ft[i]=0, i--);

  00325	c7 44 24 58 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  0032d	eb 39		 jmp	 SHORT $LN15@doload
$LN13@doload:
  0032f	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00334	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  0033c	48 83 bc 24 98
	00 00 00 09	 cmp	 QWORD PTR $T2[rsp], 9
  00345	73 02		 jae	 SHORT $LN49@doload
  00347	eb 05		 jmp	 SHORT $LN50@doload
$LN49@doload:
  00349	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN50@doload:
  0034e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  00356	c6 84 04 00 01
	00 00 00	 mov	 BYTE PTR ft$[rsp+rax], 0
  0035e	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00362	ff c8		 dec	 eax
  00364	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN15@doload:
  00368	83 7c 24 58 00	 cmp	 DWORD PTR i$[rsp], 0
  0036d	7c 14		 jl	 SHORT $LN14@doload
  0036f	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00374	0f be 84 04 00
	01 00 00	 movsx	 eax, BYTE PTR ft$[rsp+rax]
  0037c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0037f	75 02		 jne	 SHORT $LN14@doload
  00381	eb ac		 jmp	 SHORT $LN13@doload
$LN14@doload:

; 2721 : 
; 2722 :                 recfm = (char) guest_to_host( fst.recfm );

  00383	0f b6 8c 24 ce
	00 00 00	 movzx	 ecx, BYTE PTR fst$[rsp+30]
  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00391	88 44 24 54	 mov	 BYTE PTR recfm$[rsp], al

; 2723 : 
; 2724 :                 recl = fetch_fw( fst.lrecl );

  00395	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp+32]
  0039d	e8 00 00 00 00	 call	 fetch_fw_noswap
  003a2	8b c8		 mov	 ecx, eax
  003a4	e8 00 00 00 00	 call	 _byteswap_ulong
  003a9	89 84 24 88 00
	00 00		 mov	 DWORD PTR recl$[rsp], eax

; 2725 : 
; 2726 :                 if (!(recs = fetch_fw( fst.aic )))

  003b0	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp+56]
  003b8	e8 00 00 00 00	 call	 fetch_fw_noswap
  003bd	8b c8		 mov	 ecx, eax
  003bf	e8 00 00 00 00	 call	 _byteswap_ulong
  003c4	89 44 24 7c	 mov	 DWORD PTR recs$[rsp], eax
  003c8	83 7c 24 7c 00	 cmp	 DWORD PTR recs$[rsp], 0
  003cd	75 1c		 jne	 SHORT $LN33@doload

; 2727 :                     recs = fetch_hw( fst.reccount );

  003cf	48 8d 8c 24 ca
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp+26]
  003d7	e8 00 00 00 00	 call	 fetch_hw_noswap
  003dc	0f b7 c8	 movzx	 ecx, ax
  003df	e8 00 00 00 00	 call	 _byteswap_ushort
  003e4	0f b7 c0	 movzx	 eax, ax
  003e7	89 44 24 7c	 mov	 DWORD PTR recs$[rsp], eax
$LN33@doload:

; 2728 : 
; 2729 :                 /* Find corresponding CTLTAB entry */
; 2730 :                 if (!(ctl = find_ctltab_entry( fn, ft, recfm )))

  003eb	44 0f b6 44 24
	54		 movzx	 r8d, BYTE PTR recfm$[rsp]
  003f1	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ft$[rsp]
  003f9	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR fn$[rsp]
  00401	e8 00 00 00 00	 call	 find_ctltab_entry
  00406	48 89 44 24 68	 mov	 QWORD PTR ctl$[rsp], rax
  0040b	48 83 7c 24 68
	00		 cmp	 QWORD PTR ctl$[rsp], 0
  00411	75 1a		 jne	 SHORT $LN34@doload

; 2731 :                 {
; 2732 :                     /* No match in ctlfile; skip loading this file ... */
; 2733 :                     log_fst_skipped( &fst, opts );

  00413	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR opts$[rsp]
  0041b	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp]
  00423	e8 00 00 00 00	 call	 log_fst_skipped

; 2734 :                     continue; // (skip this file)

  00428	e9 0f fd ff ff	 jmp	 $LN2@doload
$LN34@doload:

; 2735 :                 }
; 2736 : 
; 2737 :                 /* Show them the DUMPed file on the tape that we are LOADing... */
; 2738 :                 log_fst_loaded( &fst, ctl, opts );

  0042d	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR opts$[rsp]
  00435	48 8b 54 24 68	 mov	 rdx, QWORD PTR ctl$[rsp]
  0043a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR fst$[rsp]
  00442	e8 00 00 00 00	 call	 log_fst_loaded

; 2739 :                 ctl->loaded = true;

  00447	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  0044c	c6 40 3e 01	 mov	 BYTE PTR [rax+62], 1

; 2740 : 
; 2741 :                 /* Set translation codepage if file is TEXT format */
; 2742 :                 if (ctl->filefmt == 'T')

  00450	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  00455	0f be 40 3d	 movsx	 eax, BYTE PTR [rax+61]
  00459	83 f8 54	 cmp	 eax, 84			; 00000054H
  0045c	75 2b		 jne	 SHORT $LN35@doload

; 2743 :                     if (strcasecmp( ctl->codepage, query_codepage()) != 0)

  0045e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_query_codepage
  00464	48 8b d0	 mov	 rdx, rax
  00467	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  0046c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00476	85 c0		 test	 eax, eax
  00478	74 0f		 je	 SHORT $LN36@doload

; 2744 :                         set_codepage( ctl->codepage );

  0047a	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  0047f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage
$LN36@doload:
$LN35@doload:

; 2745 : 
; 2746 :                 /* Create the empty host output file */
; 2747 :                 if (!(ofile = fopen( ctl->hostfile, "wb" )))

  00489	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171003
  00490	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  00495	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0049f	48 89 44 24 70	 mov	 QWORD PTR ofile$[rsp], rax
  004a4	48 83 7c 24 70
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  004aa	0f 85 85 00 00
	00		 jne	 $LN37@doload

; 2748 :                 {
; 2749 :                     // "File open error: \"%s\": %s"
; 2750 :                     FWRMSG( stderr, HHC02623, "E", ctl->hostfile, strerror( errno ));

  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004b6	8b 08		 mov	 ecx, DWORD PTR [rax]
  004b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004be	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
  004c6	b9 02 00 00 00	 mov	 ecx, 2
  004cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv244[rsp]
  004d9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctl$[rsp]
  004e3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  004e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171004
  004f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171005
  004ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00504	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00509	41 b9 03 00 00
	00		 mov	 r9d, 3
  0050f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171006
  00516	ba be 0a 00 00	 mov	 edx, 2750		; 00000abeH
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171007
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2751 :                     rc = -1;

  00528	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 2752 :                     continue;

  00530	e9 07 fc ff ff	 jmp	 $LN51@doload
$LN37@doload:

; 2753 :                 }
; 2754 : 
; 2755 :                 /* Reset unwritten record bytes */
; 2756 :                 recrem = 0;

  00535	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR recrem$[rsp], 0

; 2757 :             }

  00540	e9 1d 01 00 00	 jmp	 $LN28@doload
$LN27@doload:

; 2758 :             /* Is this a PLCD header (DATA) block? */
; 2759 :             else if (1
; 2760 :                 && blksize >= BLK_HDRSIZE
; 2761 :                 && memcmp( bfr, PLCD_hdr, BLK_HDRSIZE ) == 0

  00545	33 c0		 xor	 eax, eax
  00547	83 f8 01	 cmp	 eax, 1
  0054a	0f 84 8b 00 00
	00		 je	 $LN38@doload
  00550	83 7c 24 60 05	 cmp	 DWORD PTR blksize$[rsp], 5
  00555	0f 8c 80 00 00
	00		 jl	 $LN38@doload
  0055b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00561	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PLCD_hdr
  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  0056f	e8 00 00 00 00	 call	 memcmp
  00574	85 c0		 test	 eax, eax
  00576	75 63		 jne	 SHORT $LN38@doload

; 2762 :             )
; 2763 :             {
; 2764 :                 /* Continue writing the file if selected */
; 2765 :                 if (ofile)

  00578	48 83 7c 24 70
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  0057e	74 56		 je	 SHORT $LN40@doload

; 2766 :                     rc = load_file( ctl, ofile, recfm, blksize,

  00580	48 8d 44 24 78	 lea	 rax, QWORD PTR rsz1$[rsp]
  00585	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0058a	48 8d 44 24 5c	 lea	 rax, QWORD PTR rszsplit$[rsp]
  0058f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00594	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR recrem$[rsp]
  0059c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005a1	48 8d 44 24 7c	 lea	 rax, QWORD PTR recs$[rsp]
  005a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005ab	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR recl$[rsp]
  005b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005b8	44 8b 4c 24 60	 mov	 r9d, DWORD PTR blksize$[rsp]
  005bd	44 0f b6 44 24
	54		 movzx	 r8d, BYTE PTR recfm$[rsp]
  005c3	48 8b 54 24 70	 mov	 rdx, QWORD PTR ofile$[rsp]
  005c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctl$[rsp]
  005cd	e8 00 00 00 00	 call	 load_file
  005d2	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN40@doload:

; 2767 :                         &recl, &recs, &recrem, &rszsplit, &rsz1 );
; 2768 :             }

  005d6	e9 87 00 00 00	 jmp	 $LN39@doload
$LN38@doload:

; 2769 :             else
; 2770 :             {
; 2771 :                 // "Invalid block encountered @ %d:%d"
; 2772 :                 FWRMSG( stderr, HHC02636, "W",

  005db	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  005e3	0f b7 80 22 10
	00 00		 movzx	 eax, WORD PTR [rax+4130]
  005ea	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv282[rsp], eax
  005f1	b9 02 00 00 00	 mov	 ecx, 2
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00604	8b 89 24 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4132]
  0060a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0060e	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv282[rsp]
  00615	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00619	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171011
  00620	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00625	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171012
  0062c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00631	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00636	41 b9 03 00 00
	00		 mov	 r9d, 3
  0063c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171013
  00643	ba d5 0a 00 00	 mov	 edx, 2773		; 00000ad5H
  00648	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171014
  0064f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2773 :                     opts->devblk.curfilen, opts->devblk.blockid );
; 2774 :                 rc = -1;

  00655	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 2775 :                 continue;

  0065d	e9 da fa ff ff	 jmp	 $LN52@doload
$LN39@doload:
$LN28@doload:

; 2776 :             }
; 2777 :         }

  00662	eb 5d		 jmp	 SHORT $LN26@doload
$LN25@doload:

; 2778 :         else
; 2779 :         {
; 2780 :             // "    %s"
; 2781 :             WRMSG( HHC02633, "I", "@TM" );

  00664	b9 01 00 00 00	 mov	 ecx, 1
  00669	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0066f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171015
  00676	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0067b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171016
  00682	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171017
  0068e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00693	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00698	41 b9 03 00 00
	00		 mov	 r9d, 3
  0069e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171018
  006a5	ba dd 0a 00 00	 mov	 edx, 2781		; 00000addH
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171019
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2782 :             tapemark_count++;

  006b7	8b 44 24 64	 mov	 eax, DWORD PTR tapemark_count$[rsp]
  006bb	ff c0		 inc	 eax
  006bd	89 44 24 64	 mov	 DWORD PTR tapemark_count$[rsp], eax
$LN26@doload:

; 2783 :         }
; 2784 :     }

  006c1	e9 76 fa ff ff	 jmp	 $LN53@doload
$LN3@doload:

; 2785 : 
; 2786 :     /* Close host output file if opened */
; 2787 :     if (ofile)

  006c6	48 83 7c 24 70
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  006cc	74 71		 je	 SHORT $LN41@doload
$LN18@doload:

; 2788 :         VERIFY( fclose( ofile ) == 0 );

  006ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ofile$[rsp]
  006d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  006d9	85 c0		 test	 eax, eax
  006db	74 5c		 je	 SHORT $LN42@doload
$LN21@doload:
  006dd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171022
  006e4	41 b8 e4 0a 00
	00		 mov	 r8d, 2788		; 00000ae4H
  006ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171023
  006f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171024
  006f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  006fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00704	85 c0		 test	 eax, eax
  00706	74 20		 je	 SHORT $LN43@doload
  00708	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171026
  0070f	41 b8 e4 0a 00
	00		 mov	 r8d, 2788		; 00000ae4H
  00715	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171027
  0071c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171028
  00723	e8 00 00 00 00	 call	 DebuggerTrace
$LN43@doload:
  00728	33 c0		 xor	 eax, eax
  0072a	85 c0		 test	 eax, eax
  0072c	75 af		 jne	 SHORT $LN21@doload
  0072e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00734	85 c0		 test	 eax, eax
  00736	74 01		 je	 SHORT $LN44@doload
  00738	cc		 int	 3
$LN44@doload:
$LN42@doload:
  00739	33 c0		 xor	 eax, eax
  0073b	85 c0		 test	 eax, eax
  0073d	75 8f		 jne	 SHORT $LN18@doload
$LN41@doload:

; 2789 : 
; 2790 :     /* Close input tape and issue completion message */
; 2791 :     tape_close( opts );

  0073f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00747	e8 00 00 00 00	 call	 tape_close

; 2792 : 
; 2793 :     if (rc == 0)

  0074c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00751	75 69		 jne	 SHORT $LN45@doload

; 2794 :         // "%s complete"
; 2795 :         WRMSG( HHC02631, "I", verb( opts ));

  00753	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0075b	e8 00 00 00 00	 call	 verb
  00760	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  00768	b9 01 00 00 00	 mov	 ecx, 1
  0076d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00773	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  0077b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00780	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171031
  00787	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0078c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171032
  00793	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00798	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0079d	41 b9 03 00 00
	00		 mov	 r9d, 3
  007a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171033
  007aa	ba eb 0a 00 00	 mov	 edx, 2795		; 00000aebH
  007af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171034
  007b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN45@doload:

; 2796 : 
; 2797 :     return rc;

  007bc	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@doload:
$LN46@doload:

; 2798 : }

  007c0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007c8	48 33 cc	 xor	 rcx, rsp
  007cb	e8 00 00 00 00	 call	 __security_check_cookie
  007d0	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  007d7	5f		 pop	 rdi
  007d8	5e		 pop	 rsi
  007d9	c3		 ret	 0
doload	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
loading$ = 80
rc$ = 84
gotblkid$ = 88
recfm$ = 89
i$ = 92
rszsplit$ = 96
blockid$ = 100
ctl$ = 104
blksize$ = 112
tapemark_count$ = 116
ofile$ = 120
rsz1$ = 128
recrem$ = 132
fm$ = 136
recs$ = 140
recl$ = 144
tv299 = 148
$T1 = 152
$T2 = 160
tv236 = 168
tv373 = 176
cms$ = 192
ft$ = 288
fn$ = 304
__$ArrayPad$ = 320
opts$ = 368
doload_cms PROC

; 2442 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2443 :     // CHALLENGES: the tape block containing the name of the file
; 2444 :     // that was dumped is written FOLLOWING (comes AFTER) all of
; 2445 :     // its data blocks, so as you read the tape during a LOAD op-
; 2446 :     // eration you're reading data blocks but you don't know what
; 2447 :     // file they're for until it's too late! (You need to know what
; 2448 :     // file you're reading BEFOREHAND so you can determine whether
; 2449 :     // it's a Text file or not so you can know whether to translate
; 2450 :     // from EBCDIC to ASCII or not as well as whether to write line
; 2451 :     // endings (LF/CRLF) or trim trailing blanks or not! You don't
; 2452 :     // want to do that for Binary or Structured files, just as you
; 2453 :     // don't want to NOT do that for Text files!)
; 2454 : 
; 2455 :     // To resolve this dilemma, we save the current tape position
; 2456 :     // whenever we read a file's very first data block and continue
; 2457 :     // reading and ignoring all data blocks we read until we reach
; 2458 :     // the name block. Once the name block is reached (and we have
; 2459 :     // all the information we need), we position the tape back to
; 2460 :     // the file's first data block and THIS time process each one
; 2461 :     // normally.
; 2462 : 
; 2463 :     // Yes, it's inefficient to keep seeking all over the place but
; 2464 :     // it's really the only way we can hope to accomplish our goal!
; 2465 : 
; 2466 :     FILE*    ofile = NULL;

  00020	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR ofile$[rsp], 0

; 2467 :     CTLTAB*  ctl = NULL;

  00029	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR ctl$[rsp], 0

; 2468 :     CMS      cms;
; 2469 : 
; 2470 :     int   i, rc = 0;

  00032	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2471 :     int   blksize;              // (size of current tape block)
; 2472 :     int   recrem = 0;           // (unwritten record bytes remaining)

  0003a	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR recrem$[rsp], 0

; 2473 :     int   recl, recs;
; 2474 :     int   tapemark_count = 0;

  00045	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2475 : 
; 2476 :     char  fn [ sizeof( cms.fn ) + 1 ]  = {0};

  0004d	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR fn$[rsp]
  00055	48 8b f8	 mov	 rdi, rax
  00058	33 c0		 xor	 eax, eax
  0005a	b9 09 00 00 00	 mov	 ecx, 9
  0005f	f3 aa		 rep stosb

; 2477 :     char  ft [ sizeof( cms.ft ) + 1 ]  = {0};

  00061	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR ft$[rsp]
  00069	48 8b f8	 mov	 rdi, rax
  0006c	33 c0		 xor	 eax, eax
  0006e	b9 09 00 00 00	 mov	 ecx, 9
  00073	f3 aa		 rep stosb

; 2478 :     char  fm [ sizeof( cms.fm ) + 1 ]  = {0};

  00075	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR fm$[rsp]
  0007d	48 8b f8	 mov	 rdi, rax
  00080	33 c0		 xor	 eax, eax
  00082	b9 03 00 00 00	 mov	 ecx, 3
  00087	f3 aa		 rep stosb

; 2479 :     char  recfm = 'F';

  00089	c6 44 24 59 46	 mov	 BYTE PTR recfm$[rsp], 70 ; 00000046H

; 2480 : 
; 2481 :     bool  rszsplit = false;     // (SPECIAL: rsz split across 2 blocks)

  0008e	c6 44 24 60 00	 mov	 BYTE PTR rszsplit$[rsp], 0

; 2482 :     BYTE  rsz1;                 // (SPECIAL: 1st byte of record size)
; 2483 : 
; 2484 :     U32   blockid = 0;          // (current file starting data block)

  00093	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR blockid$[rsp], 0

; 2485 :     bool  gotblkid = false;     // (false until first data block read)

  0009b	c6 44 24 58 00	 mov	 BYTE PTR gotblkid$[rsp], 0

; 2486 :     bool  loading  = false;     // (false until name block is read)

  000a0	c6 44 24 50 00	 mov	 BYTE PTR loading$[rsp], 0

; 2487 : 
; 2488 :     // "%s"
; 2489 :     WRMSG( HHC02625, "I", "LOADING..." );

  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170858
  000b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170859
  000c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170860
  000cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170861
  000e6	ba b9 09 00 00	 mov	 edx, 2489		; 000009b9H
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170862
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2490 : 
; 2491 :     /* Parse the DUMP control file */
; 2492 :     if ((rc = parse_ctlfile( opts )) != 0)

  000f8	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00100	e8 00 00 00 00	 call	 parse_ctlfile
  00105	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  00109	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0010e	74 09		 je	 SHORT $LN28@doload_cms

; 2493 :         return rc;

  00110	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00114	e9 6f 07 00 00	 jmp	 $LN1@doload_cms
$LN28@doload_cms:

; 2494 : 
; 2495 :     /* Open the input tape file */
; 2496 :     if ((rc = tape_open( opts )) != 0)

  00119	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00121	e8 00 00 00 00	 call	 tape_open
  00126	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  0012a	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0012f	74 09		 je	 SHORT $LN29@doload_cms

; 2497 :         return rc;

  00131	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00135	e9 4e 07 00 00	 jmp	 $LN1@doload_cms
$LN29@doload_cms:
$LN66@doload_cms:
$LN65@doload_cms:
$LN64@doload_cms:
$LN63@doload_cms:
$LN62@doload_cms:
$LN2@doload_cms:

; 2498 : 
; 2499 :     /* Read tape until end-of-tape reached (two tapemarks in a row) */
; 2500 :     while (1
; 2501 :         && rc >= 0
; 2502 :         && tapemark_count < 2
; 2503 :         && (rc = tape_read( opts )) >= 0

  0013a	33 c0		 xor	 eax, eax
  0013c	83 f8 01	 cmp	 eax, 1
  0013f	0f 84 49 06 00
	00		 je	 $LN3@doload_cms
  00145	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0014a	0f 8c 3e 06 00
	00		 jl	 $LN3@doload_cms
  00150	83 7c 24 74 02	 cmp	 DWORD PTR tapemark_count$[rsp], 2
  00155	0f 8d 33 06 00
	00		 jge	 $LN3@doload_cms
  0015b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00163	e8 00 00 00 00	 call	 tape_read
  00168	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  0016c	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00171	0f 8c 17 06 00
	00		 jl	 $LN3@doload_cms

; 2504 :     )
; 2505 :     {
; 2506 :         blksize = rc;

  00177	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  0017b	89 44 24 70	 mov	 DWORD PTR blksize$[rsp], eax

; 2507 : 
; 2508 :         if (blksize)

  0017f	83 7c 24 70 00	 cmp	 DWORD PTR blksize$[rsp], 0
  00184	0f 84 a2 05 00
	00		 je	 $LN30@doload_cms

; 2509 :         {
; 2510 :             tapemark_count = 0;

  0018a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2511 : 
; 2512 :             /* Is this a CMSN (name) block? */
; 2513 :             if (1
; 2514 :                 && blksize >= BLK_HDRSIZE
; 2515 :                 && memcmp( bfr, CMSN_hdr, BLK_HDRSIZE ) == 0

  00192	33 c0		 xor	 eax, eax
  00194	83 f8 01	 cmp	 eax, 1
  00197	0f 84 c2 03 00
	00		 je	 $LN32@doload_cms
  0019d	83 7c 24 70 05	 cmp	 DWORD PTR blksize$[rsp], 5
  001a2	0f 8c b7 03 00
	00		 jl	 $LN32@doload_cms
  001a8	41 b8 05 00 00
	00		 mov	 r8d, 5
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CMSN_hdr
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  001bc	e8 00 00 00 00	 call	 memcmp
  001c1	85 c0		 test	 eax, eax
  001c3	0f 85 96 03 00
	00		 jne	 $LN32@doload_cms

; 2516 :             )
; 2517 :             {
; 2518 :                 gotblkid = false;  // (reset)

  001c9	c6 44 24 58 00	 mov	 BYTE PTR gotblkid$[rsp], 0

; 2519 : 
; 2520 :                 /* Are we scanning or loading? */
; 2521 :                 if (!loading)

  001ce	0f b6 44 24 50	 movzx	 eax, BYTE PTR loading$[rsp]
  001d3	85 c0		 test	 eax, eax
  001d5	0f 85 c6 01 00
	00		 jne	 $LN34@doload_cms

; 2522 :                 {
; 2523 :                     /* Extract needed CMS information */
; 2524 :                     memcpy( &cms, &bfr[ BLK_HDRSIZE ], sizeof( CMS ));

  001db	b8 01 00 00 00	 mov	 eax, 1
  001e0	48 6b c0 05	 imul	 rax, rax, 5
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  001eb	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR cms$[rsp]
  001f3	48 8b fa	 mov	 rdi, rdx
  001f6	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  001fa	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  001ff	f3 a4		 rep movsb

; 2525 : 
; 2526 :                     str_guest_to_host( cms.fn, fn, sizeof( cms.fn ));

  00201	41 b8 08 00 00
	00		 mov	 r8d, 8
  00207	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR fn$[rsp]
  0020f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR cms$[rsp+64]
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2527 :                     str_guest_to_host( cms.ft, ft, sizeof( cms.ft ));

  0021d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00223	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR ft$[rsp]
  0022b	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR cms$[rsp+72]
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2528 :                     str_guest_to_host( cms.fm, fm, sizeof( cms.fm ));

  00239	41 b8 02 00 00
	00		 mov	 r8d, 2
  0023f	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR fm$[rsp]
  00247	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR cms$[rsp+80]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 2529 : 
; 2530 :                     /* Remove trailing blanks from fn and ft */
; 2531 :                     for (i=(int)(sizeof( cms.fn ) - 1); i >= 0 && fn[i] == ' '; fn[i]=0, i--);

  00255	c7 44 24 5c 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  0025d	eb 39		 jmp	 SHORT $LN6@doload_cms
$LN4@doload_cms:
  0025f	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00264	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0026c	48 83 bc 24 98
	00 00 00 09	 cmp	 QWORD PTR $T1[rsp], 9
  00275	73 02		 jae	 SHORT $LN58@doload_cms
  00277	eb 05		 jmp	 SHORT $LN59@doload_cms
$LN58@doload_cms:
  00279	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN59@doload_cms:
  0027e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00286	c6 84 04 30 01
	00 00 00	 mov	 BYTE PTR fn$[rsp+rax], 0
  0028e	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  00292	ff c8		 dec	 eax
  00294	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN6@doload_cms:
  00298	83 7c 24 5c 00	 cmp	 DWORD PTR i$[rsp], 0
  0029d	7c 14		 jl	 SHORT $LN5@doload_cms
  0029f	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  002a4	0f be 84 04 30
	01 00 00	 movsx	 eax, BYTE PTR fn$[rsp+rax]
  002ac	83 f8 20	 cmp	 eax, 32			; 00000020H
  002af	75 02		 jne	 SHORT $LN5@doload_cms
  002b1	eb ac		 jmp	 SHORT $LN4@doload_cms
$LN5@doload_cms:

; 2532 :                     for (i=(int)(sizeof( cms.ft ) - 1); i >= 0 && ft[i] == ' '; ft[i]=0, i--);

  002b3	c7 44 24 5c 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  002bb	eb 39		 jmp	 SHORT $LN9@doload_cms
$LN7@doload_cms:
  002bd	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  002c2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  002ca	48 83 bc 24 a0
	00 00 00 09	 cmp	 QWORD PTR $T2[rsp], 9
  002d3	73 02		 jae	 SHORT $LN60@doload_cms
  002d5	eb 05		 jmp	 SHORT $LN61@doload_cms
$LN60@doload_cms:
  002d7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN61@doload_cms:
  002dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  002e4	c6 84 04 20 01
	00 00 00	 mov	 BYTE PTR ft$[rsp+rax], 0
  002ec	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  002f0	ff c8		 dec	 eax
  002f2	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN9@doload_cms:
  002f6	83 7c 24 5c 00	 cmp	 DWORD PTR i$[rsp], 0
  002fb	7c 14		 jl	 SHORT $LN8@doload_cms
  002fd	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00302	0f be 84 04 20
	01 00 00	 movsx	 eax, BYTE PTR ft$[rsp+rax]
  0030a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0030d	75 02		 jne	 SHORT $LN8@doload_cms
  0030f	eb ac		 jmp	 SHORT $LN7@doload_cms
$LN8@doload_cms:

; 2533 : 
; 2534 :                     recfm = (char) guest_to_host( cms.recfm );

  00311	0f b6 8c 24 ca
	00 00 00	 movzx	 ecx, BYTE PTR cms$[rsp+10]
  00319	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0031f	88 44 24 59	 mov	 BYTE PTR recfm$[rsp], al

; 2535 : 
; 2536 :                     recl = fetch_fw( cms.lrecl    );

  00323	48 8d 8c 24 cc
	00 00 00	 lea	 rcx, QWORD PTR cms$[rsp+12]
  0032b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00330	8b c8		 mov	 ecx, eax
  00332	e8 00 00 00 00	 call	 _byteswap_ulong
  00337	89 84 24 90 00
	00 00		 mov	 DWORD PTR recl$[rsp], eax

; 2537 :                     recs = fetch_hw( cms.reccount );

  0033e	48 8d 8c 24 c6
	00 00 00	 lea	 rcx, QWORD PTR cms$[rsp+6]
  00346	e8 00 00 00 00	 call	 fetch_hw_noswap
  0034b	0f b7 c8	 movzx	 ecx, ax
  0034e	e8 00 00 00 00	 call	 _byteswap_ushort
  00353	0f b7 c0	 movzx	 eax, ax
  00356	89 84 24 8c 00
	00 00		 mov	 DWORD PTR recs$[rsp], eax

; 2538 : 
; 2539 :                     /* Find corresponding CTLTAB entry */
; 2540 :                     if (!(ctl = find_ctltab_entry( fn, ft, recfm )))

  0035d	44 0f b6 44 24
	59		 movzx	 r8d, BYTE PTR recfm$[rsp]
  00363	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR ft$[rsp]
  0036b	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR fn$[rsp]
  00373	e8 00 00 00 00	 call	 find_ctltab_entry
  00378	48 89 44 24 68	 mov	 QWORD PTR ctl$[rsp], rax
  0037d	48 83 7c 24 68
	00		 cmp	 QWORD PTR ctl$[rsp], 0
  00383	75 1a		 jne	 SHORT $LN36@doload_cms

; 2541 :                     {
; 2542 :                         /* No match in ctlfile; skip loading this file ... */
; 2543 :                         log_cms_skipped( &cms, opts );

  00385	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR opts$[rsp]
  0038d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cms$[rsp]
  00395	e8 00 00 00 00	 call	 log_cms_skipped

; 2544 :                         continue; // (skip this file)

  0039a	e9 9b fd ff ff	 jmp	 $LN2@doload_cms
$LN36@doload_cms:

; 2545 :                     }
; 2546 :                 }

  0039f	eb 0a		 jmp	 SHORT $LN35@doload_cms
$LN34@doload_cms:

; 2547 :                 else /* We WERE loading, but now we're DONE loading */
; 2548 :                 {
; 2549 :                     loading = false;

  003a1	c6 44 24 50 00	 mov	 BYTE PTR loading$[rsp], 0

; 2550 :                     continue;

  003a6	e9 8f fd ff ff	 jmp	 $LN62@doload_cms
$LN35@doload_cms:

; 2551 :                 }
; 2552 : 
; 2553 :                 /* Show them the DUMPed file on the tape that we are LOADing... */
; 2554 :                 log_cms_loaded( &cms, ctl, opts );

  003ab	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR opts$[rsp]
  003b3	48 8b 54 24 68	 mov	 rdx, QWORD PTR ctl$[rsp]
  003b8	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cms$[rsp]
  003c0	e8 00 00 00 00	 call	 log_cms_loaded

; 2555 :                 ctl->loaded = true;

  003c5	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  003ca	c6 40 3e 01	 mov	 BYTE PTR [rax+62], 1

; 2556 : 
; 2557 :                 /* Close output file if opened */
; 2558 :                 if (ofile)

  003ce	48 83 7c 24 78
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  003d4	74 7a		 je	 SHORT $LN37@doload_cms
$LN12@doload_cms:

; 2559 :                 {
; 2560 :                     VERIFY( fclose( ofile ) == 0 );

  003d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ofile$[rsp]
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  003e1	85 c0		 test	 eax, eax
  003e3	74 5c		 je	 SHORT $LN38@doload_cms
$LN15@doload_cms:
  003e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170874
  003ec	41 b8 00 0a 00
	00		 mov	 r8d, 2560		; 00000a00H
  003f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170875
  003f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170876
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0040c	85 c0		 test	 eax, eax
  0040e	74 20		 je	 SHORT $LN39@doload_cms
  00410	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170878
  00417	41 b8 00 0a 00
	00		 mov	 r8d, 2560		; 00000a00H
  0041d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170879
  00424	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170880
  0042b	e8 00 00 00 00	 call	 DebuggerTrace
$LN39@doload_cms:
  00430	33 c0		 xor	 eax, eax
  00432	85 c0		 test	 eax, eax
  00434	75 af		 jne	 SHORT $LN15@doload_cms
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0043c	85 c0		 test	 eax, eax
  0043e	74 01		 je	 SHORT $LN40@doload_cms
  00440	cc		 int	 3
$LN40@doload_cms:
$LN38@doload_cms:
  00441	33 c0		 xor	 eax, eax
  00443	85 c0		 test	 eax, eax
  00445	75 8f		 jne	 SHORT $LN12@doload_cms

; 2561 :                     ofile = NULL;

  00447	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR ofile$[rsp], 0
$LN37@doload_cms:

; 2562 :                 }
; 2563 : 
; 2564 :                 /* Set translation codepage if file is TEXT format */
; 2565 :                 if (ctl->filefmt == 'T')

  00450	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  00455	0f be 40 3d	 movsx	 eax, BYTE PTR [rax+61]
  00459	83 f8 54	 cmp	 eax, 84			; 00000054H
  0045c	75 2b		 jne	 SHORT $LN41@doload_cms

; 2566 :                     if (strcasecmp( ctl->codepage, query_codepage()) != 0)

  0045e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_query_codepage
  00464	48 8b d0	 mov	 rdx, rax
  00467	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  0046c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00476	85 c0		 test	 eax, eax
  00478	74 0f		 je	 SHORT $LN42@doload_cms

; 2567 :                         set_codepage( ctl->codepage );

  0047a	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  0047f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage
$LN42@doload_cms:
$LN41@doload_cms:

; 2568 : 
; 2569 :                 /* Create the empty host output file */
; 2570 :                 if (!(ofile = fopen( ctl->hostfile, "wb" )))

  00489	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170885
  00490	48 8b 44 24 68	 mov	 rax, QWORD PTR ctl$[rsp]
  00495	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0049f	48 89 44 24 78	 mov	 QWORD PTR ofile$[rsp], rax
  004a4	48 83 7c 24 78
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  004aa	0f 85 85 00 00
	00		 jne	 $LN43@doload_cms

; 2571 :                 {
; 2572 :                     // "File open error: \"%s\": %s"
; 2573 :                     FWRMSG( stderr, HHC02623, "E", ctl->hostfile, strerror( errno ));

  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004b6	8b 08		 mov	 ecx, DWORD PTR [rax]
  004b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004be	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv236[rsp], rax
  004c6	b9 02 00 00 00	 mov	 ecx, 2
  004cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv236[rsp]
  004d9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctl$[rsp]
  004e3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  004e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170886
  004f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170887
  004ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00504	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00509	41 b9 03 00 00
	00		 mov	 r9d, 3
  0050f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170888
  00516	ba 0d 0a 00 00	 mov	 edx, 2573		; 00000a0dH
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170889
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2574 :                     rc = -1;

  00528	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 2575 :                     continue;

  00530	e9 05 fc ff ff	 jmp	 $LN63@doload_cms
$LN43@doload_cms:

; 2576 :                 }
; 2577 : 
; 2578 :                 /* Reset unwritten record bytes */
; 2579 :                 recrem = 0;

  00535	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR recrem$[rsp], 0

; 2580 : 
; 2581 :                 /* Reposition tape and begin loading this file */
; 2582 :                 rc = tape_set_position( opts, blockid );

  00540	8b 54 24 64	 mov	 edx, DWORD PTR blockid$[rsp]
  00544	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0054c	e8 00 00 00 00	 call	 tape_set_position
  00551	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2583 :                 loading = true;

  00555	c6 44 24 50 01	 mov	 BYTE PTR loading$[rsp], 1

; 2584 :             }

  0055a	e9 cb 01 00 00	 jmp	 $LN33@doload_cms
$LN32@doload_cms:

; 2585 :             /* Is this a CMSb header (DATA) block? */
; 2586 :             else if (1
; 2587 :                 && blksize >= BLK_HDRSIZE
; 2588 :                 && memcmp( bfr, CMS__hdr, BLK_HDRSIZE ) == 0

  0055f	33 c0		 xor	 eax, eax
  00561	83 f8 01	 cmp	 eax, 1
  00564	0f 84 39 01 00
	00		 je	 $LN44@doload_cms
  0056a	83 7c 24 70 05	 cmp	 DWORD PTR blksize$[rsp], 5
  0056f	0f 8c 2e 01 00
	00		 jl	 $LN44@doload_cms
  00575	41 b8 05 00 00
	00		 mov	 r8d, 5
  0057b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CMS__hdr
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00589	e8 00 00 00 00	 call	 memcmp
  0058e	85 c0		 test	 eax, eax
  00590	0f 85 0d 01 00
	00		 jne	 $LN44@doload_cms

; 2589 :             )
; 2590 :             {
; 2591 :                 /* Save tape position of first data block */
; 2592 :                 if (!gotblkid)

  00596	0f b6 44 24 58	 movzx	 eax, BYTE PTR gotblkid$[rsp]
  0059b	85 c0		 test	 eax, eax
  0059d	0f 85 89 00 00
	00		 jne	 $LN46@doload_cms

; 2593 :                 {
; 2594 :                     blockid = tape_get_position( opts );

  005a3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  005ab	e8 00 00 00 00	 call	 tape_get_position
  005b0	89 44 24 64	 mov	 DWORD PTR blockid$[rsp], eax
$LN18@doload_cms:

; 2595 : 
; 2596 :                     /* PROGRAMMING NOTE: the blockid is updated after
; 2597 :                        the block is read. Thus to re-read the block
; 2598 :                        we just read, we need to save the blockid of
; 2599 :                        the PREVIOUS block.
; 2600 :                     */
; 2601 :                     ASSERT( blockid >= 1 );  // (sanity check)

  005b4	83 7c 24 64 01	 cmp	 DWORD PTR blockid$[rsp], 1
  005b9	73 5c		 jae	 SHORT $LN47@doload_cms
$LN21@doload_cms:
  005bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170894
  005c2	41 b8 29 0a 00
	00		 mov	 r8d, 2601		; 00000a29H
  005c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170895
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170896
  005d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005e2	85 c0		 test	 eax, eax
  005e4	74 20		 je	 SHORT $LN48@doload_cms
  005e6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170898
  005ed	41 b8 29 0a 00
	00		 mov	 r8d, 2601		; 00000a29H
  005f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170899
  005fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170900
  00601	e8 00 00 00 00	 call	 DebuggerTrace
$LN48@doload_cms:
  00606	33 c0		 xor	 eax, eax
  00608	85 c0		 test	 eax, eax
  0060a	75 af		 jne	 SHORT $LN21@doload_cms
  0060c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00612	85 c0		 test	 eax, eax
  00614	74 01		 je	 SHORT $LN49@doload_cms
  00616	cc		 int	 3
$LN49@doload_cms:
$LN47@doload_cms:
  00617	33 c0		 xor	 eax, eax
  00619	85 c0		 test	 eax, eax
  0061b	75 97		 jne	 SHORT $LN18@doload_cms

; 2602 :                     blockid--;

  0061d	8b 44 24 64	 mov	 eax, DWORD PTR blockid$[rsp]
  00621	ff c8		 dec	 eax
  00623	89 44 24 64	 mov	 DWORD PTR blockid$[rsp], eax

; 2603 :                     gotblkid = true;

  00627	c6 44 24 58 01	 mov	 BYTE PTR gotblkid$[rsp], 1
$LN46@doload_cms:

; 2604 :                 }
; 2605 : 
; 2606 :                 /* Ignore data blocks if not loading file */
; 2607 :                 if (!loading)

  0062c	0f b6 44 24 50	 movzx	 eax, BYTE PTR loading$[rsp]
  00631	85 c0		 test	 eax, eax
  00633	75 05		 jne	 SHORT $LN50@doload_cms

; 2608 :                     continue;

  00635	e9 00 fb ff ff	 jmp	 $LN64@doload_cms
$LN50@doload_cms:

; 2609 : 
; 2610 :                 /* Continue writing the file if selected */
; 2611 :                 if (ofile)

  0063a	48 83 7c 24 78
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  00640	74 5c		 je	 SHORT $LN51@doload_cms

; 2612 :                     rc = load_file( ctl, ofile, recfm, blksize,

  00642	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR rsz1$[rsp]
  0064a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0064f	48 8d 44 24 60	 lea	 rax, QWORD PTR rszsplit$[rsp]
  00654	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00659	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR recrem$[rsp]
  00661	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00666	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR recs$[rsp]
  0066e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00673	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR recl$[rsp]
  0067b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00680	44 8b 4c 24 70	 mov	 r9d, DWORD PTR blksize$[rsp]
  00685	44 0f b6 44 24
	59		 movzx	 r8d, BYTE PTR recfm$[rsp]
  0068b	48 8b 54 24 78	 mov	 rdx, QWORD PTR ofile$[rsp]
  00690	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctl$[rsp]
  00695	e8 00 00 00 00	 call	 load_file
  0069a	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
$LN51@doload_cms:

; 2613 :                         &recl, &recs, &recrem, &rszsplit, &rsz1 );
; 2614 :             }

  0069e	e9 87 00 00 00	 jmp	 $LN45@doload_cms
$LN44@doload_cms:

; 2615 :             else
; 2616 :             {
; 2617 :                 // "Invalid block encountered @ %d:%d"
; 2618 :                 FWRMSG( stderr, HHC02636, "W",

  006a3	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  006ab	0f b7 80 22 10
	00 00		 movzx	 eax, WORD PTR [rax+4130]
  006b2	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv299[rsp], eax
  006b9	b9 02 00 00 00	 mov	 ecx, 2
  006be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c4	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  006cc	8b 89 24 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4132]
  006d2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d6	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv299[rsp]
  006dd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170904
  006e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170905
  006f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00704	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170906
  0070b	ba 3b 0a 00 00	 mov	 edx, 2619		; 00000a3bH
  00710	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170907
  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2619 :                     opts->devblk.curfilen, opts->devblk.blockid );
; 2620 :                 rc = -1;

  0071d	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 2621 :                 continue;

  00725	e9 10 fa ff ff	 jmp	 $LN65@doload_cms
$LN45@doload_cms:
$LN33@doload_cms:

; 2622 :             }
; 2623 :         }

  0072a	eb 5d		 jmp	 SHORT $LN31@doload_cms
$LN30@doload_cms:

; 2624 :         else
; 2625 :         {
; 2626 :             // "    %s"
; 2627 :             WRMSG( HHC02633, "I", "@TM" );

  0072c	b9 01 00 00 00	 mov	 ecx, 1
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00737	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170908
  0073e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00743	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170909
  0074a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170910
  00756	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0075b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00760	41 b9 03 00 00
	00		 mov	 r9d, 3
  00766	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170911
  0076d	ba 43 0a 00 00	 mov	 edx, 2627		; 00000a43H
  00772	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170912
  00779	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2628 :             tapemark_count++;

  0077f	8b 44 24 74	 mov	 eax, DWORD PTR tapemark_count$[rsp]
  00783	ff c0		 inc	 eax
  00785	89 44 24 74	 mov	 DWORD PTR tapemark_count$[rsp], eax
$LN31@doload_cms:

; 2629 :         }
; 2630 :     }

  00789	e9 ac f9 ff ff	 jmp	 $LN66@doload_cms
$LN3@doload_cms:

; 2631 : 
; 2632 :     /* Close host output file if opened */
; 2633 :     if (ofile)

  0078e	48 83 7c 24 78
	00		 cmp	 QWORD PTR ofile$[rsp], 0
  00794	74 71		 je	 SHORT $LN52@doload_cms
$LN24@doload_cms:

; 2634 :         VERIFY( fclose( ofile ) == 0 );

  00796	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ofile$[rsp]
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  007a1	85 c0		 test	 eax, eax
  007a3	74 5c		 je	 SHORT $LN53@doload_cms
$LN27@doload_cms:
  007a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170915
  007ac	41 b8 4a 0a 00
	00		 mov	 r8d, 2634		; 00000a4aH
  007b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170916
  007b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170917
  007c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  007c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007cc	85 c0		 test	 eax, eax
  007ce	74 20		 je	 SHORT $LN54@doload_cms
  007d0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170919
  007d7	41 b8 4a 0a 00
	00		 mov	 r8d, 2634		; 00000a4aH
  007dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170920
  007e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170921
  007eb	e8 00 00 00 00	 call	 DebuggerTrace
$LN54@doload_cms:
  007f0	33 c0		 xor	 eax, eax
  007f2	85 c0		 test	 eax, eax
  007f4	75 af		 jne	 SHORT $LN27@doload_cms
  007f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007fc	85 c0		 test	 eax, eax
  007fe	74 01		 je	 SHORT $LN55@doload_cms
  00800	cc		 int	 3
$LN55@doload_cms:
$LN53@doload_cms:
  00801	33 c0		 xor	 eax, eax
  00803	85 c0		 test	 eax, eax
  00805	75 8f		 jne	 SHORT $LN24@doload_cms
$LN52@doload_cms:

; 2635 : 
; 2636 :     /* Close input tape and issue completion message */
; 2637 :     tape_close( opts );

  00807	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0080f	e8 00 00 00 00	 call	 tape_close

; 2638 : 
; 2639 :     if (rc == 0)

  00814	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00819	75 69		 jne	 SHORT $LN56@doload_cms

; 2640 :         // "%s complete"
; 2641 :         WRMSG( HHC02631, "I", verb( opts ));

  0081b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00823	e8 00 00 00 00	 call	 verb
  00828	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv373[rsp], rax
  00830	b9 01 00 00 00	 mov	 ecx, 1
  00835	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0083b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv373[rsp]
  00843	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00848	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170924
  0084f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00854	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170925
  0085b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00860	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00865	41 b9 03 00 00
	00		 mov	 r9d, 3
  0086b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170926
  00872	ba 51 0a 00 00	 mov	 edx, 2641		; 00000a51H
  00877	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170927
  0087e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@doload_cms:

; 2642 : 
; 2643 :     return rc;

  00884	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@doload_cms:
$LN57@doload_cms:

; 2644 : }

  00888	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00890	48 33 cc	 xor	 rcx, rsp
  00893	e8 00 00 00 00	 call	 __security_check_cookie
  00898	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0089f	5f		 pop	 rdi
  008a0	5e		 pop	 rsi
  008a1	c3		 ret	 0
doload_cms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rem$ = 48
rc$ = 52
endofrec$ = 56
rec$ = 64
recremblk$ = 72
recsize$1 = 76
rsz$2 = 80
tv305 = 84
tv71 = 88
tv73 = 92
tv75 = 96
tv176 = 100
tv178 = 104
tv180 = 108
tv303 = 112
ctl$ = 144
ofile$ = 152
recfm$ = 160
blksize$ = 168
recl$ = 176
recs$ = 184
recrem$ = 192
rszsplit$ = 200
rsz1$ = 208
load_file PROC

; 2249 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2250 :     BYTE*  rec = &bfr[ BLK_HDRSIZE ];

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	48 6b c0 05	 imul	 rax, rax, 5
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  0002b	48 03 c8	 add	 rcx, rax
  0002e	48 8b c1	 mov	 rax, rcx
  00031	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2251 :     int    rem = blksize - BLK_HDRSIZE;

  00036	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blksize$[rsp]
  0003d	83 e8 05	 sub	 eax, 5
  00040	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2252 :     bool   endofrec = false;

  00044	c6 44 24 38 00	 mov	 BYTE PTR endofrec$[rsp], 0

; 2253 :     int    recremblk = 0;

  00049	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR recremblk$[rsp], 0

; 2254 :     int    rc = 0;

  00051	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2255 : 
; 2256 :     if (recfm == 'F')   /* Fixed */

  00059	0f be 84 24 a0
	00 00 00	 movsx	 eax, BYTE PTR recfm$[rsp]
  00061	83 f8 46	 cmp	 eax, 70			; 00000046H
  00064	0f 85 18 03 00
	00		 jne	 $LN12@load_file

; 2257 :     {
; 2258 :         /* Finish writing previous record if incomplete */
; 2259 :         if (*recrem)

  0006a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  00072	83 38 00	 cmp	 DWORD PTR [rax], 0
  00075	0f 84 6a 01 00
	00		 je	 $LN14@load_file

; 2260 :         {
; 2261 :             /* How much of record bytes remain in this block */
; 2262 :             recremblk = MIN( *recrem, rem );

  0007b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  00083	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  00087	39 08		 cmp	 DWORD PTR [rax], ecx
  00089	7d 10		 jge	 SHORT $LN41@load_file
  0008b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	89 44 24 58	 mov	 DWORD PTR tv71[rsp], eax
  00099	eb 08		 jmp	 SHORT $LN42@load_file
$LN41@load_file:
  0009b	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  0009f	89 44 24 58	 mov	 DWORD PTR tv71[rsp], eax
$LN42@load_file:
  000a3	8b 44 24 58	 mov	 eax, DWORD PTR tv71[rsp]
  000a7	89 44 24 48	 mov	 DWORD PTR recremblk$[rsp], eax

; 2263 :             endofrec  = (recremblk >= *recrem);

  000ab	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  000b3	8b 00		 mov	 eax, DWORD PTR [rax]
  000b5	39 44 24 48	 cmp	 DWORD PTR recremblk$[rsp], eax
  000b9	7c 0a		 jl	 SHORT $LN43@load_file
  000bb	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  000c3	eb 08		 jmp	 SHORT $LN44@load_file
$LN43@load_file:
  000c5	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN44@load_file:
  000cd	83 7c 24 5c 00	 cmp	 DWORD PTR tv73[rsp], 0
  000d2	75 0a		 jne	 SHORT $LN45@load_file
  000d4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  000dc	eb 08		 jmp	 SHORT $LN46@load_file
$LN45@load_file:
  000de	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN46@load_file:
  000e6	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv75[rsp]
  000eb	88 44 24 38	 mov	 BYTE PTR endofrec$[rsp], al

; 2264 : 
; 2265 :             if ((rc = write_rec( ofile, rec, recremblk, endofrec,
; 2266 :                 ctl->filefmt, ctl->hostfile )) < 0)

  000ef	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  000f7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000fb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00100	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00108	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  0010c	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00110	44 0f b6 4c 24
	38		 movzx	 r9d, BYTE PTR endofrec$[rsp]
  00116	44 8b 44 24 48	 mov	 r8d, DWORD PTR recremblk$[rsp]
  0011b	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  00120	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00128	e8 00 00 00 00	 call	 write_rec
  0012d	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00131	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00136	7d 09		 jge	 SHORT $LN15@load_file

; 2267 :                 return rc;

  00138	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  0013c	e9 5e 07 00 00	 jmp	 $LN1@load_file
$LN15@load_file:

; 2268 : 
; 2269 :             if (endofrec && (rc = endof_rec( ofile,

  00141	0f b6 44 24 38	 movzx	 eax, BYTE PTR endofrec$[rsp]
  00146	85 c0		 test	 eax, eax
  00148	74 39		 je	 SHORT $LN16@load_file
  0014a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00152	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00156	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0015e	0f b6 50 3d	 movzx	 edx, BYTE PTR [rax+61]
  00162	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  0016a	e8 00 00 00 00	 call	 endof_rec
  0016f	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00173	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00178	7d 09		 jge	 SHORT $LN16@load_file

; 2270 :                 ctl->filefmt, ctl->hostfile )) < 0)
; 2271 :                 return rc;

  0017a	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  0017e	e9 1c 07 00 00	 jmp	 $LN1@load_file
$LN16@load_file:

; 2272 : 
; 2273 :             /* Adjust record pointer and bytes remaining */
; 2274 :             rec     +=  recremblk;

  00183	48 63 44 24 48	 movsxd	 rax, DWORD PTR recremblk$[rsp]
  00188	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  0018d	48 03 c8	 add	 rcx, rax
  00190	48 8b c1	 mov	 rax, rcx
  00193	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2275 :             rem     -=  recremblk;

  00198	8b 44 24 48	 mov	 eax, DWORD PTR recremblk$[rsp]
  0019c	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  001a0	2b c8		 sub	 ecx, eax
  001a2	8b c1		 mov	 eax, ecx
  001a4	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2276 :             *recrem -=  recremblk;

  001a8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  001b0	8b 4c 24 48	 mov	 ecx, DWORD PTR recremblk$[rsp]
  001b4	8b 00		 mov	 eax, DWORD PTR [rax]
  001b6	2b c1		 sub	 eax, ecx
  001b8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR recrem$[rsp]
  001c0	89 01		 mov	 DWORD PTR [rcx], eax

; 2277 : 
; 2278 :             /* Adjust records remaining if record now complete */
; 2279 :             if (*recrem == 0)

  001c2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  001ca	83 38 00	 cmp	 DWORD PTR [rax], 0
  001cd	75 16		 jne	 SHORT $LN17@load_file

; 2280 :                 --*recs;

  001cf	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  001d7	8b 00		 mov	 eax, DWORD PTR [rax]
  001d9	ff c8		 dec	 eax
  001db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR recs$[rsp]
  001e3	89 01		 mov	 DWORD PTR [rcx], eax
$LN17@load_file:
$LN14@load_file:
$LN2@load_file:

; 2281 :         }
; 2282 : 
; 2283 :         /* Write fixed length recs until end of block */
; 2284 :         while (rc >= 0 && rem && *recs)

  001e5	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ea	0f 8c 8d 01 00
	00		 jl	 $LN3@load_file
  001f0	83 7c 24 30 00	 cmp	 DWORD PTR rem$[rsp], 0
  001f5	0f 84 82 01 00
	00		 je	 $LN3@load_file
  001fb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  00203	83 38 00	 cmp	 DWORD PTR [rax], 0
  00206	0f 84 71 01 00
	00		 je	 $LN3@load_file

; 2285 :         {
; 2286 :             /* Can we write a complete record? */
; 2287 :             if (rem >= *recl)

  0020c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00214	8b 00		 mov	 eax, DWORD PTR [rax]
  00216	39 44 24 30	 cmp	 DWORD PTR rem$[rsp], eax
  0021a	0f 8c d3 00 00
	00		 jl	 $LN18@load_file

; 2288 :             {
; 2289 :                 if (1
; 2290 :                     && (rc = write_rec( ofile,
; 2291 :                                         rec, *recl,
; 2292 :                                         true,
; 2293 :                                         ctl->filefmt, ctl->hostfile )) == 0
; 2294 : 
; 2295 :                     && (rc = endof_rec( ofile,

  00220	33 c0		 xor	 eax, eax
  00222	83 f8 01	 cmp	 eax, 1
  00225	0f 84 c3 00 00
	00		 je	 $LN20@load_file
  0022b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00233	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00237	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00244	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00248	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0024c	41 b1 01	 mov	 r9b, 1
  0024f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00257	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0025a	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  0025f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00267	e8 00 00 00 00	 call	 write_rec
  0026c	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00270	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00275	75 77		 jne	 SHORT $LN20@load_file
  00277	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0027f	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  00283	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0028b	0f b6 50 3d	 movzx	 edx, BYTE PTR [rax+61]
  0028f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00297	e8 00 00 00 00	 call	 endof_rec
  0029c	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  002a0	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  002a5	75 47		 jne	 SHORT $LN20@load_file

; 2296 :                                         ctl->filefmt, ctl->hostfile )) == 0
; 2297 :                 )
; 2298 :                 {
; 2299 :                     /* Adjust record pointer and bytes remaining */
; 2300 :                     rec += *recl;

  002a7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  002af	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  002b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  002b7	48 03 c8	 add	 rcx, rax
  002ba	48 8b c1	 mov	 rax, rcx
  002bd	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2301 :                     rem -= *recl;

  002c2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  002ca	8b 00		 mov	 eax, DWORD PTR [rax]
  002cc	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  002d0	2b c8		 sub	 ecx, eax
  002d2	8b c1		 mov	 eax, ecx
  002d4	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2302 : 
; 2303 :                     /* Adjust records remaining */
; 2304 :                     --*recs;

  002d8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  002e0	8b 00		 mov	 eax, DWORD PTR [rax]
  002e2	ff c8		 dec	 eax
  002e4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR recs$[rsp]
  002ec	89 01		 mov	 DWORD PTR [rcx], eax
$LN20@load_file:

; 2305 :                 }
; 2306 :             }

  002ee	e9 85 00 00 00	 jmp	 $LN19@load_file
$LN18@load_file:

; 2307 :             else /* (rem < *recl): Write incomplete record */
; 2308 :             {
; 2309 :                 if ((rc = write_rec( ofile,
; 2310 :                                      rec, rem,
; 2311 :                                      false,
; 2312 :                                      ctl->filefmt, ctl->hostfile )) == 0)

  002f3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  002fb	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00304	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0030c	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00310	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00314	45 33 c9	 xor	 r9d, r9d
  00317	44 8b 44 24 30	 mov	 r8d, DWORD PTR rem$[rsp]
  0031c	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  00321	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00329	e8 00 00 00 00	 call	 write_rec
  0032e	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00332	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00337	75 3f		 jne	 SHORT $LN21@load_file

; 2313 :                 {
; 2314 :                     /* Save unwritten bytes in next block */
; 2315 :                     *recrem = *recl - rem;

  00339	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00341	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  00345	8b 00		 mov	 eax, DWORD PTR [rax]
  00347	2b c1		 sub	 eax, ecx
  00349	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR recrem$[rsp]
  00351	89 01		 mov	 DWORD PTR [rcx], eax

; 2316 : 
; 2317 :                     /* Adjust record pointer and bytes remaining */
; 2318 :                     rec += rem;

  00353	48 63 44 24 30	 movsxd	 rax, DWORD PTR rem$[rsp]
  00358	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  0035d	48 03 c8	 add	 rcx, rax
  00360	48 8b c1	 mov	 rax, rcx
  00363	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2319 :                     rem -= rem;

  00368	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  0036c	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  00370	2b c8		 sub	 ecx, eax
  00372	8b c1		 mov	 eax, ecx
  00374	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax
$LN21@load_file:
$LN19@load_file:

; 2320 :                 }
; 2321 :             }
; 2322 :         }

  00378	e9 68 fe ff ff	 jmp	 $LN2@load_file
$LN3@load_file:

; 2323 :     }

  0037d	e9 19 05 00 00	 jmp	 $LN13@load_file
$LN12@load_file:

; 2324 :     else // (recfm == 'V')  /* Variable */
; 2325 :     {
; 2326 :         /* Finish writing previous record if incomplete */
; 2327 :         if (*recrem)

  00382	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  0038a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0038d	0f 84 6a 01 00
	00		 je	 $LN22@load_file

; 2328 :         {
; 2329 :             /* How much of record bytes remain in this block */
; 2330 :             recremblk = MIN( *recrem, rem );

  00393	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  0039b	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  0039f	39 08		 cmp	 DWORD PTR [rax], ecx
  003a1	7d 10		 jge	 SHORT $LN47@load_file
  003a3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  003ab	8b 00		 mov	 eax, DWORD PTR [rax]
  003ad	89 44 24 64	 mov	 DWORD PTR tv176[rsp], eax
  003b1	eb 08		 jmp	 SHORT $LN48@load_file
$LN47@load_file:
  003b3	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  003b7	89 44 24 64	 mov	 DWORD PTR tv176[rsp], eax
$LN48@load_file:
  003bb	8b 44 24 64	 mov	 eax, DWORD PTR tv176[rsp]
  003bf	89 44 24 48	 mov	 DWORD PTR recremblk$[rsp], eax

; 2331 :             endofrec  = (recremblk >= *recrem);

  003c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  003cb	8b 00		 mov	 eax, DWORD PTR [rax]
  003cd	39 44 24 48	 cmp	 DWORD PTR recremblk$[rsp], eax
  003d1	7c 0a		 jl	 SHORT $LN49@load_file
  003d3	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  003db	eb 08		 jmp	 SHORT $LN50@load_file
$LN49@load_file:
  003dd	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN50@load_file:
  003e5	83 7c 24 68 00	 cmp	 DWORD PTR tv178[rsp], 0
  003ea	75 0a		 jne	 SHORT $LN51@load_file
  003ec	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
  003f4	eb 08		 jmp	 SHORT $LN52@load_file
$LN51@load_file:
  003f6	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
$LN52@load_file:
  003fe	0f b6 44 24 6c	 movzx	 eax, BYTE PTR tv180[rsp]
  00403	88 44 24 38	 mov	 BYTE PTR endofrec$[rsp], al

; 2332 : 
; 2333 :             if ((rc = write_rec( ofile, rec, recremblk, endofrec,
; 2334 :                 ctl->filefmt, ctl->hostfile )) < 0)

  00407	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0040f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00413	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00418	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00420	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  00424	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00428	44 0f b6 4c 24
	38		 movzx	 r9d, BYTE PTR endofrec$[rsp]
  0042e	44 8b 44 24 48	 mov	 r8d, DWORD PTR recremblk$[rsp]
  00433	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  00438	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00440	e8 00 00 00 00	 call	 write_rec
  00445	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00449	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  0044e	7d 09		 jge	 SHORT $LN23@load_file

; 2335 :                 return rc;

  00450	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  00454	e9 46 04 00 00	 jmp	 $LN1@load_file
$LN23@load_file:

; 2336 : 
; 2337 :             if (endofrec && (rc = endof_rec( ofile,

  00459	0f b6 44 24 38	 movzx	 eax, BYTE PTR endofrec$[rsp]
  0045e	85 c0		 test	 eax, eax
  00460	74 39		 je	 SHORT $LN24@load_file
  00462	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0046a	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0046e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00476	0f b6 50 3d	 movzx	 edx, BYTE PTR [rax+61]
  0047a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00482	e8 00 00 00 00	 call	 endof_rec
  00487	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  0048b	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00490	7d 09		 jge	 SHORT $LN24@load_file

; 2338 :                 ctl->filefmt, ctl->hostfile )) < 0)
; 2339 :                 return rc;

  00492	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  00496	e9 04 04 00 00	 jmp	 $LN1@load_file
$LN24@load_file:

; 2340 : 
; 2341 :             /* Adjust record pointer and bytes remaining */
; 2342 :             rec     +=  recremblk;

  0049b	48 63 44 24 48	 movsxd	 rax, DWORD PTR recremblk$[rsp]
  004a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  004a5	48 03 c8	 add	 rcx, rax
  004a8	48 8b c1	 mov	 rax, rcx
  004ab	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2343 :             rem     -=  recremblk;

  004b0	8b 44 24 48	 mov	 eax, DWORD PTR recremblk$[rsp]
  004b4	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  004b8	2b c8		 sub	 ecx, eax
  004ba	8b c1		 mov	 eax, ecx
  004bc	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2344 :             *recrem -=  recremblk;

  004c0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  004c8	8b 4c 24 48	 mov	 ecx, DWORD PTR recremblk$[rsp]
  004cc	8b 00		 mov	 eax, DWORD PTR [rax]
  004ce	2b c1		 sub	 eax, ecx
  004d0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR recrem$[rsp]
  004d8	89 01		 mov	 DWORD PTR [rcx], eax

; 2345 : 
; 2346 :             /* Adjust records remaining if record now complete */
; 2347 :             if (*recrem == 0)

  004da	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recrem$[rsp]
  004e2	83 38 00	 cmp	 DWORD PTR [rax], 0
  004e5	75 16		 jne	 SHORT $LN25@load_file

; 2348 :                 --*recs;

  004e7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  004ef	8b 00		 mov	 eax, DWORD PTR [rax]
  004f1	ff c8		 dec	 eax
  004f3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR recs$[rsp]
  004fb	89 01		 mov	 DWORD PTR [rcx], eax
$LN25@load_file:
$LN22@load_file:
$LN4@load_file:

; 2349 :         }
; 2350 : 
; 2351 :         /* Write variable len recs until end of block */
; 2352 :         while (rc >= 0 && *recs && rem >= (int) sizeof( HWORD ))

  004fd	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00502	0f 8c 23 03 00
	00		 jl	 $LN5@load_file
  00508	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  00510	83 38 00	 cmp	 DWORD PTR [rax], 0
  00513	0f 84 12 03 00
	00		 je	 $LN5@load_file
  00519	83 7c 24 30 02	 cmp	 DWORD PTR rem$[rsp], 2
  0051e	0f 8c 07 03 00
	00		 jl	 $LN5@load_file

; 2353 :         {
; 2354 :             HWORD recsize;
; 2355 :             int rsz;
; 2356 : 
; 2357 :             /* Get size of this record */
; 2358 :             if (*rszsplit)

  00524	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rszsplit$[rsp]
  0052c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0052f	85 c0		 test	 eax, eax
  00531	74 50		 je	 SHORT $LN26@load_file

; 2359 :             {
; 2360 :                 recsize[0] = *rsz1;

  00533	b8 01 00 00 00	 mov	 eax, 1
  00538	48 6b c0 00	 imul	 rax, rax, 0
  0053c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR rsz1$[rsp]
  00544	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00547	88 4c 04 4c	 mov	 BYTE PTR recsize$1[rsp+rax], cl

; 2361 :                 recsize[1] = rec[0];

  0054b	b8 01 00 00 00	 mov	 eax, 1
  00550	48 6b c0 00	 imul	 rax, rax, 0
  00554	b9 01 00 00 00	 mov	 ecx, 1
  00559	48 6b c9 01	 imul	 rcx, rcx, 1
  0055d	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  00562	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00566	88 44 0c 4c	 mov	 BYTE PTR recsize$1[rsp+rcx], al

; 2362 :                 --rec;

  0056a	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$[rsp]
  0056f	48 ff c8	 dec	 rax
  00572	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2363 :                 ++rem;

  00577	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  0057b	ff c0		 inc	 eax
  0057d	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2364 :             }

  00581	eb 3e		 jmp	 SHORT $LN27@load_file
$LN26@load_file:

; 2365 :             else
; 2366 :             {
; 2367 :                 recsize[0] = rec[0];

  00583	b8 01 00 00 00	 mov	 eax, 1
  00588	48 6b c0 00	 imul	 rax, rax, 0
  0058c	b9 01 00 00 00	 mov	 ecx, 1
  00591	48 6b c9 00	 imul	 rcx, rcx, 0
  00595	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  0059a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0059e	88 44 0c 4c	 mov	 BYTE PTR recsize$1[rsp+rcx], al

; 2368 :                 recsize[1] = rec[1];

  005a2	b8 01 00 00 00	 mov	 eax, 1
  005a7	48 6b c0 01	 imul	 rax, rax, 1
  005ab	b9 01 00 00 00	 mov	 ecx, 1
  005b0	48 6b c9 01	 imul	 rcx, rcx, 1
  005b4	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  005b9	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  005bd	88 44 0c 4c	 mov	 BYTE PTR recsize$1[rsp+rcx], al
$LN27@load_file:

; 2369 :             }
; 2370 :             *rszsplit = false;

  005c1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rszsplit$[rsp]
  005c9	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2371 :             rsz = fetch_hw( recsize );

  005cc	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR recsize$1[rsp]
  005d1	e8 00 00 00 00	 call	 fetch_hw_noswap
  005d6	0f b7 c8	 movzx	 ecx, ax
  005d9	e8 00 00 00 00	 call	 _byteswap_ushort
  005de	0f b7 c0	 movzx	 eax, ax
  005e1	89 44 24 50	 mov	 DWORD PTR rsz$2[rsp], eax
$LN8@load_file:

; 2372 :             ASSERT( rsz > 0 && rsz <= *recl );

  005e5	83 7c 24 50 00	 cmp	 DWORD PTR rsz$2[rsp], 0
  005ea	7e 10		 jle	 SHORT $LN29@load_file
  005ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  005f4	8b 00		 mov	 eax, DWORD PTR [rax]
  005f6	39 44 24 50	 cmp	 DWORD PTR rsz$2[rsp], eax
  005fa	7e 5c		 jle	 SHORT $LN28@load_file
$LN29@load_file:
$LN11@load_file:
  005fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170784
  00603	41 b8 44 09 00
	00		 mov	 r8d, 2372		; 00000944H
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170785
  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170786
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0061d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00623	85 c0		 test	 eax, eax
  00625	74 20		 je	 SHORT $LN30@load_file
  00627	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170788
  0062e	41 b8 44 09 00
	00		 mov	 r8d, 2372		; 00000944H
  00634	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170789
  0063b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170790
  00642	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@load_file:
  00647	33 c0		 xor	 eax, eax
  00649	85 c0		 test	 eax, eax
  0064b	75 af		 jne	 SHORT $LN11@load_file
  0064d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00653	85 c0		 test	 eax, eax
  00655	74 01		 je	 SHORT $LN31@load_file
  00657	cc		 int	 3
$LN31@load_file:
$LN28@load_file:
  00658	33 c0		 xor	 eax, eax
  0065a	85 c0		 test	 eax, eax
  0065c	75 87		 jne	 SHORT $LN8@load_file

; 2373 : 
; 2374 :             if ((rc = write_siz( ofile, recsize, ctl->filefmt, ctl->hostfile )) == 0)

  0065e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00666	4c 8b 48 28	 mov	 r9, QWORD PTR [rax+40]
  0066a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00672	44 0f b6 40 3d	 movzx	 r8d, BYTE PTR [rax+61]
  00677	48 8d 54 24 4c	 lea	 rdx, QWORD PTR recsize$1[rsp]
  0067c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00684	e8 00 00 00 00	 call	 write_siz
  00689	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  0068d	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00692	0f 85 8e 01 00
	00		 jne	 $LN32@load_file

; 2375 :             {
; 2376 :                 rec  +=  sizeof( HWORD );

  00698	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$[rsp]
  0069d	48 83 c0 02	 add	 rax, 2
  006a1	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2377 :                 rem  -=  sizeof( HWORD );

  006a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR rem$[rsp]
  006ab	48 83 e8 02	 sub	 rax, 2
  006af	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2378 : 
; 2379 :                 /* Can we write a complete record? */
; 2380 :                 if (rem >= rsz)

  006b3	8b 44 24 50	 mov	 eax, DWORD PTR rsz$2[rsp]
  006b7	39 44 24 30	 cmp	 DWORD PTR rem$[rsp], eax
  006bb	0f 8c c1 00 00
	00		 jl	 $LN33@load_file

; 2381 :                 {
; 2382 :                     if (1
; 2383 :                         && (rc = write_rec( ofile,
; 2384 :                                             rec, rsz,
; 2385 :                                             true,
; 2386 :                                             ctl->filefmt, ctl->hostfile )) == 0
; 2387 : 
; 2388 :                         && (rc = endof_rec( ofile,

  006c1	33 c0		 xor	 eax, eax
  006c3	83 f8 01	 cmp	 eax, 1
  006c6	0f 84 b1 00 00
	00		 je	 $LN35@load_file
  006cc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  006d4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  006d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006dd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  006e5	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  006e9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  006ed	41 b1 01	 mov	 r9b, 1
  006f0	44 8b 44 24 50	 mov	 r8d, DWORD PTR rsz$2[rsp]
  006f5	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  006fa	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00702	e8 00 00 00 00	 call	 write_rec
  00707	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  0070b	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00710	75 6b		 jne	 SHORT $LN35@load_file
  00712	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  0071a	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0071e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00726	0f b6 50 3d	 movzx	 edx, BYTE PTR [rax+61]
  0072a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  00732	e8 00 00 00 00	 call	 endof_rec
  00737	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  0073b	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00740	75 3b		 jne	 SHORT $LN35@load_file

; 2389 :                                             ctl->filefmt, ctl->hostfile )) == 0
; 2390 :                     )
; 2391 :                     {
; 2392 :                         /* Adjust record pointer and bytes remaining */
; 2393 :                         rec += rsz;

  00742	48 63 44 24 50	 movsxd	 rax, DWORD PTR rsz$2[rsp]
  00747	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  0074c	48 03 c8	 add	 rcx, rax
  0074f	48 8b c1	 mov	 rax, rcx
  00752	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2394 :                         rem -= rsz;

  00757	8b 44 24 50	 mov	 eax, DWORD PTR rsz$2[rsp]
  0075b	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  0075f	2b c8		 sub	 ecx, eax
  00761	8b c1		 mov	 eax, ecx
  00763	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax

; 2395 : 
; 2396 :                         /* Adjust records remaining */
; 2397 :                         --*recs;

  00767	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  0076f	8b 00		 mov	 eax, DWORD PTR [rax]
  00771	ff c8		 dec	 eax
  00773	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR recs$[rsp]
  0077b	89 01		 mov	 DWORD PTR [rcx], eax
$LN35@load_file:

; 2398 :                     }
; 2399 :                 }

  0077d	e9 a4 00 00 00	 jmp	 $LN34@load_file
$LN33@load_file:

; 2400 :                 else /* (rem < rsz): Write incomplete record */
; 2401 :                 {
; 2402 :                     /* Are ANY record bytes remaining in this block? */
; 2403 :                     if (rem)

  00782	83 7c 24 30 00	 cmp	 DWORD PTR rem$[rsp], 0
  00787	0f 84 83 00 00
	00		 je	 $LN36@load_file

; 2404 :                     {
; 2405 :                         if ((rc = write_rec( ofile,
; 2406 :                                              rec, rem,
; 2407 :                                              false,
; 2408 :                                              ctl->filefmt, ctl->hostfile )) == 0)

  0078d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  00795	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00799	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0079e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  007a6	0f b6 40 3d	 movzx	 eax, BYTE PTR [rax+61]
  007aa	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  007ae	45 33 c9	 xor	 r9d, r9d
  007b1	44 8b 44 24 30	 mov	 r8d, DWORD PTR rem$[rsp]
  007b6	48 8b 54 24 40	 mov	 rdx, QWORD PTR rec$[rsp]
  007bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ofile$[rsp]
  007c3	e8 00 00 00 00	 call	 write_rec
  007c8	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  007cc	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  007d1	75 3b		 jne	 SHORT $LN38@load_file

; 2409 :                         {
; 2410 :                             /* Save unwritten bytes in next block */
; 2411 :                             *recrem = rsz - rem;

  007d3	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  007d7	8b 4c 24 50	 mov	 ecx, DWORD PTR rsz$2[rsp]
  007db	2b c8		 sub	 ecx, eax
  007dd	8b c1		 mov	 eax, ecx
  007df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR recrem$[rsp]
  007e7	89 01		 mov	 DWORD PTR [rcx], eax

; 2412 : 
; 2413 :                             /* Adjust record pointer and bytes remaining */
; 2414 :                             rec += rem;

  007e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR rem$[rsp]
  007ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  007f3	48 03 c8	 add	 rcx, rax
  007f6	48 8b c1	 mov	 rax, rcx
  007f9	48 89 44 24 40	 mov	 QWORD PTR rec$[rsp], rax

; 2415 :                             rem -= rem;

  007fe	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  00802	8b 4c 24 30	 mov	 ecx, DWORD PTR rem$[rsp]
  00806	2b c8		 sub	 ecx, eax
  00808	8b c1		 mov	 eax, ecx
  0080a	89 44 24 30	 mov	 DWORD PTR rem$[rsp], eax
$LN38@load_file:

; 2416 :                         }
; 2417 :                     }

  0080e	eb 16		 jmp	 SHORT $LN37@load_file
$LN36@load_file:

; 2418 :                     else // (rem == 0)
; 2419 :                     {
; 2420 :                         /* Save unwritten bytes in next block */
; 2421 :                         *recrem = rsz - rem;

  00810	8b 44 24 30	 mov	 eax, DWORD PTR rem$[rsp]
  00814	8b 4c 24 50	 mov	 ecx, DWORD PTR rsz$2[rsp]
  00818	2b c8		 sub	 ecx, eax
  0081a	8b c1		 mov	 eax, ecx
  0081c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR recrem$[rsp]
  00824	89 01		 mov	 DWORD PTR [rcx], eax
$LN37@load_file:
$LN34@load_file:
$LN32@load_file:

; 2422 :                     }
; 2423 :                 }
; 2424 :             }
; 2425 :         }

  00826	e9 d2 fc ff ff	 jmp	 $LN4@load_file
$LN5@load_file:

; 2426 : 
; 2427 :         /* Did we exit our loop because there weren't
; 2428 :            enough bytes in the buffer to fetch_hw the
; 2429 :            next record's HWORD rsz record size value?
; 2430 :         */
; 2431 :         if ((*rszsplit = (rc >= 0 && *recs && 1 == rem)))

  0082b	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00830	7c 1e		 jl	 SHORT $LN53@load_file
  00832	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recs$[rsp]
  0083a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0083d	74 11		 je	 SHORT $LN53@load_file
  0083f	83 7c 24 30 01	 cmp	 DWORD PTR rem$[rsp], 1
  00844	75 0a		 jne	 SHORT $LN53@load_file
  00846	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv303[rsp], 1
  0084e	eb 08		 jmp	 SHORT $LN54@load_file
$LN53@load_file:
  00850	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv303[rsp], 0
$LN54@load_file:
  00858	83 7c 24 70 00	 cmp	 DWORD PTR tv303[rsp], 0
  0085d	75 0a		 jne	 SHORT $LN55@load_file
  0085f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv305[rsp], 0
  00867	eb 08		 jmp	 SHORT $LN56@load_file
$LN55@load_file:
  00869	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv305[rsp], 1
$LN56@load_file:
  00871	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR rszsplit$[rsp]
  00879	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv305[rsp]
  0087e	88 08		 mov	 BYTE PTR [rax], cl
  00880	0f b6 44 24 54	 movzx	 eax, BYTE PTR tv305[rsp]
  00885	85 c0		 test	 eax, eax
  00887	74 12		 je	 SHORT $LN39@load_file

; 2432 :             *rsz1 = *rec;

  00889	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR rsz1$[rsp]
  00891	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rec$[rsp]
  00896	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00899	88 08		 mov	 BYTE PTR [rax], cl
$LN39@load_file:
$LN13@load_file:

; 2433 :     }
; 2434 : 
; 2435 :     return rc;

  0089b	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@load_file:

; 2436 : }

  0089f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  008a6	c3		 ret	 0
load_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
info$ = 32
__$ArrayPad$ = 112
fst$ = 144
opts$ = 152
log_fst_skipped PROC

; 2228 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2229 :     char info[80];
; 2230 :     if (!opts->quiet)

  00020	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00028	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  0002c	85 c0		 test	 eax, eax
  0002e	75 20		 jne	 SHORT $LN2@log_fst_sk

; 2231 :         log_skipped( format_fst_info( fst, info, sizeof( info )));

  00030	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00036	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  0003b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fst$[rsp]
  00043	e8 00 00 00 00	 call	 format_fst_info
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 log_skipped
$LN2@log_fst_sk:

; 2232 : }

  00050	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00055	48 33 cc	 xor	 rcx, rsp
  00058	e8 00 00 00 00	 call	 __security_check_cookie
  0005d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00064	c3		 ret	 0
log_fst_skipped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
info$ = 32
__$ArrayPad$ = 112
cms$ = 144
opts$ = 152
log_cms_skipped PROC

; 2222 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2223 :     char info[80];
; 2224 :     if (!opts->quiet)

  00020	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00028	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  0002c	85 c0		 test	 eax, eax
  0002e	75 20		 jne	 SHORT $LN2@log_cms_sk

; 2225 :         log_skipped( format_cms_info( cms, info, sizeof( info )));

  00030	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00036	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  0003b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cms$[rsp]
  00043	e8 00 00 00 00	 call	 format_cms_info
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 log_skipped
$LN2@log_cms_sk:

; 2226 : }

  00050	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00055	48 33 cc	 xor	 rcx, rsp
  00058	e8 00 00 00 00	 call	 __security_check_cookie
  0005d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00064	c3		 ret	 0
log_cms_skipped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
msgbuf$ = 64
__$ArrayPad$ = 416
info$ = 448
log_skipped PROC

; 2212 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2213 :     char msgbuf[80+MAX_PATH];
; 2214 :     MSGBUF( msgbuf, "SKIPPED:    %s", info );

  0001e	4c 8b 8c 24 c0
	01 00 00	 mov	 r9, QWORD PTR info$[rsp]
  00026	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170699
  0002d	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  00032	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2215 :     // ">>> %s"
; 2216 :     WRMSG( HHC02626, "I", msgbuf );

  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00048	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0004d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170700
  00059	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170701
  00065	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0006a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170702
  0007c	ba a8 08 00 00	 mov	 edx, 2216		; 000008a8H
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170703
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2217 :     /* Show them why file is being skipped... */
; 2218 :     // "    %s"
; 2219 :     WRMSG( HHC02633, "I", "            (no matching ctlfile entry)");

  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170704
  000a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170705
  000ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170706
  000b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170707
  000cf	ba ab 08 00 00	 mov	 edx, 2219		; 000008abH
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170708
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2220 : }

  000e1	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e9	48 33 cc	 xor	 rcx, rsp
  000ec	e8 00 00 00 00	 call	 __security_check_cookie
  000f1	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  000f8	c3		 ret	 0
log_skipped ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
info$ = 32
__$ArrayPad$ = 112
fst$ = 144
ctl$ = 152
opts$ = 160
log_fst_loaded PROC

; 2203 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2204 :     char info[80];
; 2205 :     log_loaded( opts, ctl, format_fst_info( fst, info, sizeof( info )));

  00025	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0002b	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  00030	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fst$[rsp]
  00038	e8 00 00 00 00	 call	 format_fst_info
  0003d	4c 8b c0	 mov	 r8, rax
  00040	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ctl$[rsp]
  00048	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00050	e8 00 00 00 00	 call	 log_loaded

; 2206 : }

  00055	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005a	48 33 cc	 xor	 rcx, rsp
  0005d	e8 00 00 00 00	 call	 __security_check_cookie
  00062	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00069	c3		 ret	 0
log_fst_loaded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
info$ = 32
__$ArrayPad$ = 112
cms$ = 144
ctl$ = 152
opts$ = 160
log_cms_loaded PROC

; 2198 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2199 :     char info[80];
; 2200 :     log_loaded( opts, ctl, format_cms_info( cms, info, sizeof( info )));

  00025	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0002b	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  00030	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cms$[rsp]
  00038	e8 00 00 00 00	 call	 format_cms_info
  0003d	4c 8b c0	 mov	 r8, rax
  00040	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ctl$[rsp]
  00048	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00050	e8 00 00 00 00	 call	 log_loaded

; 2201 : }

  00055	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0005a	48 33 cc	 xor	 rcx, rsp
  0005d	e8 00 00 00 00	 call	 __security_check_cookie
  00062	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00069	c3		 ret	 0
log_cms_loaded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
msgbuf$ = 64
__$ArrayPad$ = 416
opts$ = 448
ctl$ = 456
info$ = 464
log_loaded PROC

; 2184 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2185 :     char msgbuf[80+MAX_PATH];
; 2186 :     // ">>> %s"
; 2187 :     MSGBUF( msgbuf, "LOADING:    %s", info );

  00028	4c 8b 8c 24 d0
	01 00 00	 mov	 r9, QWORD PTR info$[rsp]
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170665
  00037	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  0003c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2188 :     WRMSG( HHC02626, "I", msgbuf );

  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00052	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00057	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170666
  00063	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170667
  0006f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00074	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00079	41 b9 03 00 00
	00		 mov	 r9d, 3
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170668
  00086	ba 8c 08 00 00	 mov	 edx, 2188		; 0000088cH
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170669
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2189 :     if (!opts->quiet)

  00098	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000a0	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  000a4	85 c0		 test	 eax, eax
  000a6	75 74		 jne	 SHORT $LN2@log_loaded

; 2190 :     {
; 2191 :         /* Show them where file is being loaded to... */
; 2192 :         // "    %s"
; 2193 :         MSGBUF( msgbuf, "     to:    %s", ctl->hostfile );

  000a8	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  000b0	4c 8b 48 28	 mov	 r9, QWORD PTR [rax+40]
  000b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170671
  000bb	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  000c0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2194 :         WRMSG( HHC02633, "I", msgbuf );

  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  000db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170672
  000e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170673
  000f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00103	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170674
  0010a	ba 92 08 00 00	 mov	 edx, 2194		; 00000892H
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170675
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@log_loaded:

; 2195 :     }
; 2196 : }

  0011c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00133	c3		 ret	 0
log_loaded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv72 = 88
ofile$ = 112
filefmt$ = 120
name$ = 128
endof_rec PROC

; 2162 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2163 :     int rc = 0;

  00012	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2164 :     if (filefmt == 'T')  // ('T'extual)

  0001a	0f be 44 24 78	 movsx	 eax, BYTE PTR filefmt$[rsp]
  0001f	83 f8 54	 cmp	 eax, 84			; 00000054H
  00022	0f 85 9c 00 00
	00		 jne	 $LN2@endof_rec

; 2165 :     {
; 2166 : #if defined( _MSVC_ )
; 2167 :         if (fwrite( "\r\n", 1, 2, ofile ) != 2)

  00028	4c 8b 4c 24 70	 mov	 r9, QWORD PTR ofile$[rsp]
  0002d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170651
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00045	48 83 f8 02	 cmp	 rax, 2
  00049	74 79		 je	 SHORT $LN3@endof_rec

; 2168 : #else
; 2169 :         if (fwrite( "\n",   1, 1, ofile ) != 1)
; 2170 : #endif
; 2171 :         {
; 2172 :             // "I/O error on file \"%s\": %s"
; 2173 :             FWRMSG( stderr, HHC02627, "E", name, strerror( errno ));

  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00051	8b 08		 mov	 ecx, DWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00059	48 89 44 24 58	 mov	 QWORD PTR tv72[rsp], rax
  0005e	b9 02 00 00 00	 mov	 ecx, 2
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00069	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv72[rsp]
  0006e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00073	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  0007b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170652
  00087	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170653
  00093	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00098	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009d	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170654
  000aa	ba 7d 08 00 00	 mov	 edx, 2173		; 0000087dH
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170655
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2174 :             rc = -1;

  000bc	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN3@endof_rec:
$LN2@endof_rec:

; 2175 :         }
; 2176 :     }
; 2177 :     return rc;

  000c4	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 2178 : }

  000c8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000cc	c3		 ret	 0
endof_rec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv88 = 88
ofile$ = 112
p$ = 120
len$ = 128
trim$ = 136
filefmt$ = 144
name$ = 152
write_rec PROC

; 2137 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2138 :     int rc = 0;

  00018	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2139 :     if (len)

  00020	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00028	0f 84 18 01 00
	00		 je	 $LN4@write_rec

; 2140 :     {
; 2141 :         if (filefmt == 'T')  // ('T'extual)

  0002e	0f be 84 24 90
	00 00 00	 movsx	 eax, BYTE PTR filefmt$[rsp]
  00036	83 f8 54	 cmp	 eax, 84			; 00000054H
  00039	75 57		 jne	 SHORT $LN5@write_rec

; 2142 :         {
; 2143 :             buf_guest_to_host( p, p, len );

  0003b	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00043	48 8b 54 24 78	 mov	 rdx, QWORD PTR p$[rsp]
  00048	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_buf_guest_to_host

; 2144 :             if (trim)

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR trim$[rsp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 33		 je	 SHORT $LN6@write_rec
$LN2@write_rec:

; 2145 :                 while (len && ' ' == (char)(*(p + len - 1)))

  0005f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00067	74 29		 je	 SHORT $LN3@write_rec
  00069	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00071	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00076	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  0007b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007e	75 12		 jne	 SHORT $LN3@write_rec

; 2146 :                     --len;

  00080	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00087	ff c8		 dec	 eax
  00089	89 84 24 80 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00090	eb cd		 jmp	 SHORT $LN2@write_rec
$LN3@write_rec:
$LN6@write_rec:
$LN5@write_rec:

; 2147 :         }
; 2148 :         if (len && fwrite( p, 1, (size_t) len, ofile ) != (size_t) len)

  00092	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0009a	0f 84 a6 00 00
	00		 je	 $LN7@write_rec
  000a0	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000a8	4c 8b 4c 24 70	 mov	 r9, QWORD PTR ofile$[rsp]
  000ad	4c 8b c0	 mov	 r8, rax
  000b0	ba 01 00 00 00	 mov	 edx, 1
  000b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000c0	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  000c8	48 3b c1	 cmp	 rax, rcx
  000cb	74 79		 je	 SHORT $LN7@write_rec

; 2149 :         {
; 2150 :             // "I/O error on file \"%s\": %s"
; 2151 :             FWRMSG( stderr, HHC02627, "E", name, strerror( errno ));

  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d3	8b 08		 mov	 ecx, DWORD PTR [rax]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000db	48 89 44 24 58	 mov	 QWORD PTR tv88[rsp], rax
  000e0	b9 02 00 00 00	 mov	 ecx, 2
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv88[rsp]
  000f0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  000fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170636
  00109	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170637
  00115	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170638
  0012c	ba 67 08 00 00	 mov	 edx, 2151		; 00000867H
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170639
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2152 :             rc = -1;

  0013e	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN7@write_rec:
$LN4@write_rec:

; 2153 :         }
; 2154 :     }
; 2155 :     return rc;

  00146	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 2156 : }

  0014a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0014e	c3		 ret	 0
write_rec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv72 = 88
ofile$ = 112
p$ = 120
filefmt$ = 128
name$ = 136
write_siz PROC

; 2118 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2119 :     int rc = 0;

  00018	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2120 :     if (filefmt == 'S')  // ('S'tructured)

  00020	0f be 84 24 80
	00 00 00	 movsx	 eax, BYTE PTR filefmt$[rsp]
  00028	83 f8 53	 cmp	 eax, 83			; 00000053H
  0002b	0f 85 9a 00 00
	00		 jne	 $LN2@write_siz

; 2121 :     {
; 2122 :         if (fwrite( p, 1, sizeof( HWORD ), ofile ) != sizeof( HWORD ))

  00031	4c 8b 4c 24 70	 mov	 r9, QWORD PTR ofile$[rsp]
  00036	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  0004c	48 83 f8 02	 cmp	 rax, 2
  00050	74 79		 je	 SHORT $LN3@write_siz

; 2123 :         {
; 2124 :             // "I/O error on file \"%s\": %s"
; 2125 :             FWRMSG( stderr, HHC02627, "E", name, strerror( errno ));

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00058	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00060	48 89 44 24 58	 mov	 QWORD PTR tv72[rsp], rax
  00065	b9 02 00 00 00	 mov	 ecx, 2
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv72[rsp]
  00075	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0007a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00082	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170608
  0008e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170609
  0009a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170610
  000b1	ba 4d 08 00 00	 mov	 edx, 2125		; 0000084dH
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170611
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2126 :             rc = -1;

  000c3	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN3@write_siz:
$LN2@write_siz:

; 2127 :         }
; 2128 :     }
; 2129 :     return rc;

  000cb	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 2130 : }

  000cf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d3	c3		 ret	 0
write_siz ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 64
tapemark_count$ = 68
blksize$ = 72
tv132 = 80
tv167 = 88
tv194 = 96
fst$ = 112
cms$ = 192
info$ = 288
__$ArrayPad$ = 368
opts$ = 416
doscan	PROC

; 2044 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2045 :     int   rc;
; 2046 :     int   blksize;
; 2047 :     int   tapemark_count = 0;

  00020	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2048 :     FST   fst;
; 2049 :     CMS   cms;
; 2050 :     char  info[80];
; 2051 : 
; 2052 :     // "%s"
; 2053 :     WRMSG( HHC02625, "I", "SCANNING..." );

  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170564
  0003a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170565
  00046	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170566
  00052	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170567
  00069	ba 05 08 00 00	 mov	 edx, 2053		; 00000805H
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170568
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2054 : 
; 2055 :     /* Open the output tape file */
; 2056 :     if ((rc = tape_open( opts )) != 0)

  0007b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00083	e8 00 00 00 00	 call	 tape_open
  00088	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  0008c	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00091	74 09		 je	 SHORT $LN4@doscan

; 2057 :         return rc;

  00093	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  00097	e9 d0 02 00 00	 jmp	 $LN1@doscan
$LN4@doscan:
$LN2@doscan:

; 2058 : 
; 2059 :     /* Scan tape until end-of-tape reached (two tapemarks in a row) */
; 2060 :     while (tapemark_count < 2 && (rc = tape_read( opts )) >= 0)

  0009c	83 7c 24 44 02	 cmp	 DWORD PTR tapemark_count$[rsp], 2
  000a1	0f 8d 4a 02 00
	00		 jge	 $LN3@doscan
  000a7	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000af	e8 00 00 00 00	 call	 tape_read
  000b4	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000b8	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bd	0f 8c 2e 02 00
	00		 jl	 $LN3@doscan

; 2061 :     {
; 2062 :         blksize = rc;

  000c3	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  000c7	89 44 24 48	 mov	 DWORD PTR blksize$[rsp], eax

; 2063 : 
; 2064 :         if (blksize)

  000cb	83 7c 24 48 00	 cmp	 DWORD PTR blksize$[rsp], 0
  000d0	0f 84 b9 01 00
	00		 je	 $LN5@doscan

; 2065 :         {
; 2066 :             tapemark_count = 0;

  000d6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tapemark_count$[rsp], 0

; 2067 : 
; 2068 :             /* Is this a PLCH header (FST) block? */
; 2069 :             if (1
; 2070 :                 && blksize >= BLK_HDRSIZE
; 2071 :                 && memcmp( bfr, PLCH_hdr, BLK_HDRSIZE ) == 0

  000de	33 c0		 xor	 eax, eax
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	0f 84 c2 00 00
	00		 je	 $LN7@doscan
  000e9	83 7c 24 48 05	 cmp	 DWORD PTR blksize$[rsp], 5
  000ee	0f 8c b7 00 00
	00		 jl	 $LN7@doscan
  000f4	41 b8 05 00 00
	00		 mov	 r8d, 5
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PLCH_hdr
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00108	e8 00 00 00 00	 call	 memcmp
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 96 00 00
	00		 jne	 $LN7@doscan

; 2072 :             )
; 2073 :             {
; 2074 :                 /* Yes, display file information */
; 2075 :                 memcpy( &fst, &bfr[ BLK_HDRSIZE ], sizeof( FST ));

  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	48 6b c0 05	 imul	 rax, rax, 5
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00125	48 8d 54 24 70	 lea	 rdx, QWORD PTR fst$[rsp]
  0012a	48 8b fa	 mov	 rdi, rdx
  0012d	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00131	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00136	f3 a4		 rep movsb

; 2076 : 
; 2077 :                 // ">>> %s"
; 2078 :                 WRMSG( HHC02626, "I",

  00138	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0013e	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  00146	48 8d 4c 24 70	 lea	 rcx, QWORD PTR fst$[rsp]
  0014b	e8 00 00 00 00	 call	 format_fst_info
  00150	48 89 44 24 50	 mov	 QWORD PTR tv132[rsp], rax
  00155	b9 01 00 00 00	 mov	 ecx, 1
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv132[rsp]
  00165	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170574
  00171	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170575
  0017d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00182	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00187	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170576
  00194	ba 1f 08 00 00	 mov	 edx, 2079		; 0000081fH
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170577
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2079 :                     format_fst_info( &fst, info, sizeof( info )));
; 2080 :             }

  001a6	e9 e2 00 00 00	 jmp	 $LN8@doscan
$LN7@doscan:

; 2081 :             /* Is this a CMSN header (FST) block? */
; 2082 :             else if (1
; 2083 :                 && opts->cms
; 2084 :                 && blksize >= BLK_HDRSIZE
; 2085 :                 && memcmp( bfr, CMSN_hdr, BLK_HDRSIZE ) == 0

  001ab	33 c0		 xor	 eax, eax
  001ad	83 f8 01	 cmp	 eax, 1
  001b0	0f 84 d7 00 00
	00		 je	 $LN9@doscan
  001b6	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001be	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 c3 00 00
	00		 je	 $LN9@doscan
  001ca	83 7c 24 48 05	 cmp	 DWORD PTR blksize$[rsp], 5
  001cf	0f 8c b8 00 00
	00		 jl	 $LN9@doscan
  001d5	41 b8 05 00 00
	00		 mov	 r8d, 5
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CMSN_hdr
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  001e9	e8 00 00 00 00	 call	 memcmp
  001ee	85 c0		 test	 eax, eax
  001f0	0f 85 97 00 00
	00		 jne	 $LN9@doscan

; 2086 :             )
; 2087 :             {
; 2088 :                 /* Yes, display file information */
; 2089 :                 memcpy( &cms, &bfr[ BLK_HDRSIZE ], sizeof( CMS ));

  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	48 6b c0 05	 imul	 rax, rax, 5
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00206	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR cms$[rsp]
  0020e	48 8b fa	 mov	 rdi, rdx
  00211	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00215	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0021a	f3 a4		 rep movsb

; 2090 : 
; 2091 :                 // ">>> %s"
; 2092 :                 WRMSG( HHC02626, "I",

  0021c	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00222	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  0022a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cms$[rsp]
  00232	e8 00 00 00 00	 call	 format_cms_info
  00237	48 89 44 24 58	 mov	 QWORD PTR tv167[rsp], rax
  0023c	b9 01 00 00 00	 mov	 ecx, 1
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv167[rsp]
  0024c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170579
  00258	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170580
  00264	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00269	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00274	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170581
  0027b	ba 2d 08 00 00	 mov	 edx, 2093		; 0000082dH
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170582
  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@doscan:
$LN8@doscan:

; 2093 :                     format_cms_info( &cms, info, sizeof( info )));
; 2094 :             }
; 2095 :         }

  0028d	eb 5d		 jmp	 SHORT $LN6@doscan
$LN5@doscan:

; 2096 :         else /* (zero length block == tapemark) */
; 2097 :         {
; 2098 :             // "    %s"
; 2099 :             WRMSG( HHC02633, "I", "@TM" );

  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170583
  002a1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170584
  002ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170585
  002b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170586
  002d0	ba 33 08 00 00	 mov	 edx, 2099		; 00000833H
  002d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170587
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2100 :             tapemark_count++;

  002e2	8b 44 24 44	 mov	 eax, DWORD PTR tapemark_count$[rsp]
  002e6	ff c0		 inc	 eax
  002e8	89 44 24 44	 mov	 DWORD PTR tapemark_count$[rsp], eax
$LN6@doscan:

; 2101 :         }
; 2102 :     }

  002ec	e9 ab fd ff ff	 jmp	 $LN2@doscan
$LN3@doscan:

; 2103 : 
; 2104 :     /* Close input tape and issue completion message */
; 2105 :     tape_close( opts );

  002f1	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  002f9	e8 00 00 00 00	 call	 tape_close

; 2106 : 
; 2107 :     if (!(rc < 0))

  002fe	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00303	7c 63		 jl	 SHORT $LN10@doscan

; 2108 :         // "%s complete"
; 2109 :         WRMSG( HHC02631, "I", verb( opts ));

  00305	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0030d	e8 00 00 00 00	 call	 verb
  00312	48 89 44 24 60	 mov	 QWORD PTR tv194[rsp], rax
  00317	b9 01 00 00 00	 mov	 ecx, 1
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00322	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv194[rsp]
  00327	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170589
  00333	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170590
  0033f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170591
  00356	ba 3d 08 00 00	 mov	 edx, 2109		; 0000083dH
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170592
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@doscan:

; 2110 : 
; 2111 :     return rc;

  00368	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@doscan:

; 2112 : }

  0036c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00374	48 33 cc	 xor	 rcx, rsp
  00377	e8 00 00 00 00	 call	 __security_check_cookie
  0037c	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  00383	5f		 pop	 rdi
  00384	5e		 pop	 rsi
  00385	c3		 ret	 0
doscan	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
i$ = 84
blks$ = 88
fstb$ = 96
cmsb$ = 104
reccount$ = 112
filesz$ = 120
tv157 = 128
tv189 = 136
tv224 = 144
tv259 = 152
tv356 = 160
info$ = 176
__$ArrayPad$ = 256
opts$ = 288
dodump	PROC

; 1914 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1915 :     TAPE_BLOCKS*  blks = NULL;

  0001e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR blks$[rsp], 0

; 1916 :     FST_BLOCK*    fstb = NULL;

  00027	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR fstb$[rsp], 0

; 1917 :     CMS_BLOCK*    cmsb = NULL;

  00030	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR cmsb$[rsp], 0

; 1918 :     size_t        filesz;
; 1919 :     int           i, rc, reccount;
; 1920 :     char          info[80];
; 1921 : 
; 1922 :     // "%s"
; 1923 :     WRMSG( HHC02625, "I", "DUMPING..." );

  00039	b9 01 00 00 00	 mov	 ecx, 1
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170486
  0004b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170487
  00057	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170488
  00063	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00073	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170489
  0007a	ba 83 07 00 00	 mov	 edx, 1923		; 00000783H
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170490
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1924 : 
; 1925 :     /* Parse the DUMP control file */
; 1926 :     if ((rc = parse_ctlfile( opts )) != 0)

  0008c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00094	e8 00 00 00 00	 call	 parse_ctlfile
  00099	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0009d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a2	74 09		 je	 SHORT $LN5@dodump

; 1927 :         return rc;

  000a4	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  000a8	e9 9c 07 00 00	 jmp	 $LN1@dodump
$LN5@dodump:

; 1928 : 
; 1929 :     /* Open the output tape file */
; 1930 :     if ((rc = tape_open( opts )) != 0)

  000ad	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000b5	e8 00 00 00 00	 call	 tape_open
  000ba	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  000be	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000c3	74 09		 je	 SHORT $LN6@dodump

; 1931 :         return rc;

  000c5	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  000c9	e9 7b 07 00 00	 jmp	 $LN1@dodump
$LN6@dodump:

; 1932 : 
; 1933 :     /* Process each entry in the parsed CTLTAB */
; 1934 :     for (i=0, rc=0; rc == 0 && i < numctl; i++)

  000ce	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000d6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
  000de	eb 0a		 jmp	 SHORT $LN4@dodump
$LN2@dodump:
  000e0	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@dodump:
  000ea	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ef	0f 85 83 05 00
	00		 jne	 $LN3@dodump
  000f5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numctl
  000fb	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  000ff	0f 8d 73 05 00
	00		 jge	 $LN3@dodump

; 1935 :     {
; 1936 :         /* Write tapemark if requested */
; 1937 :         if (strcasecmp( ctltab[i].fn, "@TM" ) == 0)

  00105	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0010a	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170494
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  0011c	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00127	85 c0		 test	 eax, eax
  00129	75 70		 jne	 SHORT $LN7@dodump

; 1938 :         {
; 1939 :             if ((rc = tape_write_mark( opts )) == 0)

  0012b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00133	e8 00 00 00 00	 call	 tape_write_mark
  00138	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0013c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00141	75 53		 jne	 SHORT $LN8@dodump

; 1940 :                 // ">>> %s"
; 1941 :                 WRMSG( HHC02626, "I", "@TM" );

  00143	b9 01 00 00 00	 mov	 ecx, 1
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170496
  00155	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170497
  00161	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170498
  0016d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170499
  00184	ba 95 07 00 00	 mov	 edx, 1941		; 00000795H
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170500
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@dodump:

; 1942 :             continue;

  00196	e9 45 ff ff ff	 jmp	 $LN2@dodump
$LN7@dodump:

; 1943 :         }
; 1944 : 
; 1945 :         /* Set translation codepage if file is TEXT format */
; 1946 :         if (ctltab[i].filefmt == 'T')

  0019b	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  001a0	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  001a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  001ab	0f be 44 01 3d	 movsx	 eax, BYTE PTR [rcx+rax+61]
  001b0	83 f8 54	 cmp	 eax, 84			; 00000054H
  001b3	75 43		 jne	 SHORT $LN9@dodump

; 1947 :             if (strcasecmp( ctltab[i].codepage, query_codepage()) != 0)

  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_query_codepage
  001bb	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  001c0	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  001c4	48 8b d0	 mov	 rdx, rax
  001c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  001ce	48 8b 4c 08 08	 mov	 rcx, QWORD PTR [rax+rcx+8]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001d9	85 c0		 test	 eax, eax
  001db	74 1b		 je	 SHORT $LN10@dodump

; 1948 :                 set_codepage( ctltab[i].codepage );

  001dd	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  001e2	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  001e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  001ed	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage
$LN10@dodump:
$LN9@dodump:

; 1949 : 
; 1950 :         // ">>> %s"
; 1951 :         WRMSG( HHC02626, "I", ctltab[i].orec );

  001f8	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  001fd	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00201	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  00209	b9 01 00 00 00	 mov	 ecx, 1
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00214	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  0021b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv157[rsp]
  00223	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00227	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170503
  00233	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170504
  0023f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00244	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00249	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170505
  00256	ba 9f 07 00 00	 mov	 edx, 1951		; 0000079fH
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170506
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1952 : 
; 1953 :         /* DUMP file, creating TAPE_BLOCKS */
; 1954 :         if (!(blks = dump_file( opts,

  00268	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0026d	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00271	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  00278	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  0027d	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  00282	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  00286	48 63 54 24 54	 movsxd	 rdx, DWORD PTR i$[rsp]
  0028b	48 6b d2 40	 imul	 rdx, rdx, 64		; 00000040H
  0028f	4c 63 44 24 54	 movsxd	 r8, DWORD PTR i$[rsp]
  00294	4d 6b c0 40	 imul	 r8, r8, 64		; 00000040H
  00298	4c 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv189[rsp], r8
  002a0	4c 8d 4c 24 78	 lea	 r9, QWORD PTR filesz$[rsp]
  002a5	4c 89 4c 24 30	 mov	 QWORD PTR [rsp+48], r9
  002aa	4c 8d 4c 24 70	 lea	 r9, QWORD PTR reccount$[rsp]
  002af	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  002b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  002c0	44 0f b6 4c 08
	3c		 movzx	 r9d, BYTE PTR [rax+rcx+60]
  002c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  002cd	44 0f b6 44 10
	3d		 movzx	 r8d, BYTE PTR [rax+rdx+61]
  002d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  002da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv189[rsp]
  002e2	48 8b 54 08 28	 mov	 rdx, QWORD PTR [rax+rcx+40]
  002e7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  002ef	e8 00 00 00 00	 call	 dump_file
  002f4	48 89 44 24 58	 mov	 QWORD PTR blks$[rsp], rax
  002f9	48 83 7c 24 58
	00		 cmp	 QWORD PTR blks$[rsp], 0
  002ff	75 0d		 jne	 SHORT $LN11@dodump

; 1955 :                                 ctltab[i].hostfile, ctltab[i].filefmt,
; 1956 :                                 ctltab[i].recfm, &ctltab[i].reclen,
; 1957 :                                 &reccount, &filesz )))
; 1958 :         {
; 1959 :             rc = -1;

  00301	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 1960 :             break;

  00309	e9 6a 03 00 00	 jmp	 $LN3@dodump
$LN11@dodump:

; 1961 :         }
; 1962 : 
; 1963 :         /* Build FST_BLOCK or CMS_BLOCK for this file */
; 1964 :         if (opts->cms)

  0030e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00316	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0031a	85 c0		 test	 eax, eax
  0031c	0f 84 c4 00 00
	00		 je	 $LN12@dodump

; 1965 :             cmsb = build_cms_block( ctltab[i].fn, ctltab[i].ft, ctltab[i].fm,

  00322	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00327	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0032b	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  00330	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  00334	48 63 54 24 54	 movsxd	 rdx, DWORD PTR i$[rsp]
  00339	48 6b d2 40	 imul	 rdx, rdx, 64		; 00000040H
  0033d	4c 63 44 24 54	 movsxd	 r8, DWORD PTR i$[rsp]
  00342	4d 6b c0 40	 imul	 r8, r8, 64		; 00000040H
  00346	4c 63 4c 24 54	 movsxd	 r9, DWORD PTR i$[rsp]
  0034b	4d 6b c9 40	 imul	 r9, r9, 64		; 00000040H
  0034f	4c 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv224[rsp], r9
  00357	4c 63 54 24 54	 movsxd	 r10, DWORD PTR i$[rsp]
  0035c	4d 6b d2 40	 imul	 r10, r10, 64		; 00000040H
  00360	4c 8b 5c 24 58	 mov	 r11, QWORD PTR blks$[rsp]
  00365	4d 8b 5b 20	 mov	 r11, QWORD PTR [r11+32]
  00369	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  0036e	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR ctltab
  00375	49 8b 44 03 30	 mov	 rax, QWORD PTR [r11+rax+48]
  0037a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0037f	8b 44 24 78	 mov	 eax, DWORD PTR filesz$[rsp]
  00383	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00387	8b 44 24 70	 mov	 eax, DWORD PTR reccount$[rsp]
  0038b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0038f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  00396	8b 44 08 38	 mov	 eax, DWORD PTR [rax+rcx+56]
  0039a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0039e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  003a5	44 0f b6 4c 10
	3c		 movzx	 r9d, BYTE PTR [rax+rdx+60]
  003ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  003b2	4e 8b 44 00 20	 mov	 r8, QWORD PTR [rax+r8+32]
  003b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  003be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv224[rsp]
  003c6	48 8b 54 08 18	 mov	 rdx, QWORD PTR [rax+rcx+24]
  003cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  003d2	4a 8b 4c 10 10	 mov	 rcx, QWORD PTR [rax+r10+16]
  003d7	e8 00 00 00 00	 call	 build_cms_block
  003dc	48 89 44 24 68	 mov	 QWORD PTR cmsb$[rsp], rax
  003e1	e9 bf 00 00 00	 jmp	 $LN13@dodump
$LN12@dodump:

; 1966 :                                     ctltab[i].recfm, ctltab[i].reclen, reccount,
; 1967 :                                     (int) filesz, ctltab[i].mtime, blks->blk_count );
; 1968 :         else // (vmfplc2 format)
; 1969 :             fstb = build_fst_block( ctltab[i].fn, ctltab[i].ft, ctltab[i].fm,

  003e6	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  003eb	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  003ef	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  003f4	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  003f8	48 63 54 24 54	 movsxd	 rdx, DWORD PTR i$[rsp]
  003fd	48 6b d2 40	 imul	 rdx, rdx, 64		; 00000040H
  00401	4c 63 44 24 54	 movsxd	 r8, DWORD PTR i$[rsp]
  00406	4d 6b c0 40	 imul	 r8, r8, 64		; 00000040H
  0040a	4c 63 4c 24 54	 movsxd	 r9, DWORD PTR i$[rsp]
  0040f	4d 6b c9 40	 imul	 r9, r9, 64		; 00000040H
  00413	4c 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv259[rsp], r9
  0041b	4c 63 54 24 54	 movsxd	 r10, DWORD PTR i$[rsp]
  00420	4d 6b d2 40	 imul	 r10, r10, 64		; 00000040H
  00424	4c 8b 5c 24 58	 mov	 r11, QWORD PTR blks$[rsp]
  00429	4d 8b 5b 20	 mov	 r11, QWORD PTR [r11+32]
  0042d	4c 89 5c 24 40	 mov	 QWORD PTR [rsp+64], r11
  00432	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR ctltab
  00439	49 8b 44 03 30	 mov	 rax, QWORD PTR [r11+rax+48]
  0043e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00443	8b 44 24 78	 mov	 eax, DWORD PTR filesz$[rsp]
  00447	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0044b	8b 44 24 70	 mov	 eax, DWORD PTR reccount$[rsp]
  0044f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00453	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  0045a	8b 44 08 38	 mov	 eax, DWORD PTR [rax+rcx+56]
  0045e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00462	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  00469	44 0f b6 4c 10
	3c		 movzx	 r9d, BYTE PTR [rax+rdx+60]
  0046f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  00476	4e 8b 44 00 20	 mov	 r8, QWORD PTR [rax+r8+32]
  0047b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  00482	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv259[rsp]
  0048a	48 8b 54 08 18	 mov	 rdx, QWORD PTR [rax+rcx+24]
  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ctltab
  00496	4a 8b 4c 10 10	 mov	 rcx, QWORD PTR [rax+r10+16]
  0049b	e8 00 00 00 00	 call	 build_fst_block
  004a0	48 89 44 24 60	 mov	 QWORD PTR fstb$[rsp], rax
$LN13@dodump:

; 1970 :                                     ctltab[i].recfm, ctltab[i].reclen, reccount,
; 1971 :                                     (int) filesz, ctltab[i].mtime, blks->blk_count );
; 1972 : 
; 1973 :         /* (check for success/failure) */
; 1974 :         if (0
; 1975 :             || ( opts->cms && !cmsb)
; 1976 :             || (!opts->cms && !fstb)

  004a5	33 c0		 xor	 eax, eax
  004a7	85 c0		 test	 eax, eax
  004a9	75 30		 jne	 SHORT $LN15@dodump
  004ab	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  004b3	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  004b7	85 c0		 test	 eax, eax
  004b9	74 08		 je	 SHORT $LN16@dodump
  004bb	48 83 7c 24 68
	00		 cmp	 QWORD PTR cmsb$[rsp], 0
  004c1	74 18		 je	 SHORT $LN15@dodump
$LN16@dodump:
  004c3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  004cb	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  004cf	85 c0		 test	 eax, eax
  004d1	75 1f		 jne	 SHORT $LN14@dodump
  004d3	48 83 7c 24 60
	00		 cmp	 QWORD PTR fstb$[rsp], 0
  004d9	75 17		 jne	 SHORT $LN14@dodump
$LN15@dodump:

; 1977 :         )
; 1978 :         {
; 1979 :             free_blocks( blks );

  004db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR blks$[rsp]
  004e0	e8 00 00 00 00	 call	 free_blocks

; 1980 :             rc = -1;

  004e5	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 1981 :             break;

  004ed	e9 86 01 00 00	 jmp	 $LN3@dodump
$LN14@dodump:

; 1982 :         }
; 1983 : 
; 1984 :         /* Create the DUMP tape */
; 1985 :         if (opts->cms)

  004f2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  004fa	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  004fe	85 c0		 test	 eax, eax
  00500	74 61		 je	 SHORT $LN17@dodump

; 1986 :         {
; 1987 :             /* Write all TAPE_BLOCKS and the CMS_BLOCK for this file */
; 1988 :             if ((rc = write_TAPE_BLOCKS( opts, blks )) == 0)

  00502	48 8b 54 24 58	 mov	 rdx, QWORD PTR blks$[rsp]
  00507	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0050f	e8 00 00 00 00	 call	 write_TAPE_BLOCKS
  00514	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00518	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0051d	75 42		 jne	 SHORT $LN19@dodump

; 1989 :                 if ((rc = tape_write_block( opts, (BYTE*) cmsb, sizeof( CMS_BLOCK ))) == 0)

  0051f	41 b8 25 03 00
	00		 mov	 r8d, 805		; 00000325H
  00525	48 8b 54 24 68	 mov	 rdx, QWORD PTR cmsb$[rsp]
  0052a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00532	e8 00 00 00 00	 call	 tape_write_block
  00537	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0053b	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00540	75 1f		 jne	 SHORT $LN20@dodump

; 1990 :                     format_cms_info( &cmsb->cms, info, sizeof( info ));

  00542	48 8b 44 24 68	 mov	 rax, QWORD PTR cmsb$[rsp]
  00547	48 83 c0 05	 add	 rax, 5
  0054b	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00551	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  00559	48 8b c8	 mov	 rcx, rax
  0055c	e8 00 00 00 00	 call	 format_cms_info
$LN20@dodump:
$LN19@dodump:

; 1991 :         }

  00561	eb 5f		 jmp	 SHORT $LN18@dodump
$LN17@dodump:

; 1992 :         else // (vmfplc2 format)
; 1993 :         {
; 1994 :             /* Write the FST_BLOCK and all TAPE_BLOCKS for this file */
; 1995 :             if ((rc = tape_write_block( opts, (BYTE*) fstb, sizeof( FST_BLOCK ))) == 0)

  00563	41 b8 4d 00 00
	00		 mov	 r8d, 77			; 0000004dH
  00569	48 8b 54 24 60	 mov	 rdx, QWORD PTR fstb$[rsp]
  0056e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00576	e8 00 00 00 00	 call	 tape_write_block
  0057b	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0057f	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00584	75 3c		 jne	 SHORT $LN21@dodump

; 1996 :                 if ((rc = write_TAPE_BLOCKS( opts, blks )) == 0)

  00586	48 8b 54 24 58	 mov	 rdx, QWORD PTR blks$[rsp]
  0058b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00593	e8 00 00 00 00	 call	 write_TAPE_BLOCKS
  00598	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0059c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  005a1	75 1f		 jne	 SHORT $LN22@dodump

; 1997 :                     format_fst_info( &fstb->fst, info, sizeof( info ));

  005a3	48 8b 44 24 60	 mov	 rax, QWORD PTR fstb$[rsp]
  005a8	48 83 c0 05	 add	 rax, 5
  005ac	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  005b2	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  005ba	48 8b c8	 mov	 rcx, rax
  005bd	e8 00 00 00 00	 call	 format_fst_info
$LN22@dodump:
$LN21@dodump:
$LN18@dodump:

; 1998 :         }
; 1999 : 
; 2000 :         if (!opts->quiet)

  005c2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  005ca	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  005ce	85 c0		 test	 eax, eax
  005d0	75 54		 jne	 SHORT $LN23@dodump

; 2001 :             // "    %s"
; 2002 :             WRMSG( HHC02633, "I", info );

  005d2	b9 01 00 00 00	 mov	 ecx, 1
  005d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005dd	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR info$[rsp]
  005e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170520
  005f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170521
  005fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00602	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00607	41 b9 03 00 00
	00		 mov	 r9d, 3
  0060d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170522
  00614	ba d2 07 00 00	 mov	 edx, 2002		; 000007d2H
  00619	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170523
  00620	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@dodump:

; 2003 : 
; 2004 :         if (opts->cms) free( cmsb );

  00626	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0062e	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00632	85 c0		 test	 eax, eax
  00634	74 0d		 je	 SHORT $LN24@dodump
  00636	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cmsb$[rsp]
  0063b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00641	eb 0b		 jmp	 SHORT $LN25@dodump
$LN24@dodump:

; 2005 :         else           free( fstb );

  00643	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fstb$[rsp]
  00648	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@dodump:

; 2006 : 
; 2007 :         free_blocks( blks );

  0064e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR blks$[rsp]
  00653	e8 00 00 00 00	 call	 free_blocks

; 2008 : 
; 2009 :         fstb = NULL;

  00658	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR fstb$[rsp], 0

; 2010 :         cmsb = NULL;

  00661	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR cmsb$[rsp], 0

; 2011 :         blks = NULL;

  0066a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR blks$[rsp], 0

; 2012 :     }

  00673	e9 68 fa ff ff	 jmp	 $LN2@dodump
$LN3@dodump:

; 2013 : 
; 2014 :     if (rc == 0)

  00678	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0067d	75 6b		 jne	 SHORT $LN26@dodump

; 2015 :         if ((rc = tape_write_mark( opts )) == 0)

  0067f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00687	e8 00 00 00 00	 call	 tape_write_mark
  0068c	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00690	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00695	75 53		 jne	 SHORT $LN27@dodump

; 2016 :             // ">>> %s"
; 2017 :             WRMSG( HHC02626, "I", "@TM" );

  00697	b9 01 00 00 00	 mov	 ecx, 1
  0069c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170528
  006a9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170529
  006b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170530
  006c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  006d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170531
  006d8	ba e1 07 00 00	 mov	 edx, 2017		; 000007e1H
  006dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170532
  006e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@dodump:
$LN26@dodump:

; 2018 : 
; 2019 :     if (rc == 0)

  006ea	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  006ef	75 6b		 jne	 SHORT $LN28@dodump

; 2020 :         if ((rc = tape_write_mark( opts )) == 0)

  006f1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  006f9	e8 00 00 00 00	 call	 tape_write_mark
  006fe	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00702	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00707	75 53		 jne	 SHORT $LN29@dodump

; 2021 :             // ">>> %s"
; 2022 :             WRMSG( HHC02626, "I", "@TM" );

  00709	b9 01 00 00 00	 mov	 ecx, 1
  0070e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00714	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170535
  0071b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00720	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170536
  00727	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0072c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170537
  00733	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00738	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0073d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00743	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170538
  0074a	ba e6 07 00 00	 mov	 edx, 2022		; 000007e6H
  0074f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170539
  00756	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@dodump:
$LN28@dodump:

; 2023 : 
; 2024 :     /* Close output tape and issue completion message */
; 2025 :     tape_close( opts );

  0075c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00764	e8 00 00 00 00	 call	 tape_close

; 2026 : 
; 2027 :     if (rc == 0)

  00769	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0076e	0f 85 d1 00 00
	00		 jne	 $LN30@dodump

; 2028 :     {
; 2029 :         // "%s complete"
; 2030 :         WRMSG( HHC02631, "I", verb( opts ));

  00774	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0077c	e8 00 00 00 00	 call	 verb
  00781	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  00789	b9 01 00 00 00	 mov	 ecx, 1
  0078e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00794	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  0079c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170541
  007a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170542
  007b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007be	41 b9 03 00 00
	00		 mov	 r9d, 3
  007c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170543
  007cb	ba ee 07 00 00	 mov	 edx, 2030		; 000007eeH
  007d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170544
  007d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2031 : 
; 2032 :         if (!opts->quiet)

  007dd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  007e5	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  007e9	85 c0		 test	 eax, eax
  007eb	75 58		 jne	 SHORT $LN31@dodump

; 2033 :             // "Tape \"%s\" created"
; 2034 :             WRMSG( HHC02635, "I", opts->tapefile );

  007ed	b9 01 00 00 00	 mov	 ecx, 1
  007f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00800	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00804	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00809	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170546
  00810	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00815	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170547
  0081c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00821	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00826	41 b9 03 00 00
	00		 mov	 r9d, 3
  0082c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170548
  00833	ba f2 07 00 00	 mov	 edx, 2034		; 000007f2H
  00838	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170549
  0083f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@dodump:
$LN30@dodump:

; 2035 :     }
; 2036 : 
; 2037 :     return rc;

  00845	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@dodump:

; 2038 : }

  00849	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00851	48 33 cc	 xor	 rcx, rsp
  00854	e8 00 00 00 00	 call	 __security_check_cookie
  00859	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00860	c3		 ret	 0
dodump	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
errs$ = 80
recno$ = 84
tv181 = 88
rec$ = 96
cfile$ = 104
tv69 = 112
tv136 = 120
opts$ = 144
parse_ctlfile PROC

; 1868 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1869 :     FILE*   cfile;
; 1870 :     char*   rec;
; 1871 :     int     recno = 0;

  0000c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR recno$[rsp], 0

; 1872 :     int     errs  = 0;

  00014	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR errs$[rsp], 0

; 1873 : 
; 1874 :     /* Open the control file */
; 1875 :     if (!(cfile = fopen( opts->ctlfile, "r" )))

  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170432
  00023	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0002b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00035	48 89 44 24 68	 mov	 QWORD PTR cfile$[rsp], rax
  0003a	48 83 7c 24 68
	00		 cmp	 QWORD PTR cfile$[rsp], 0
  00040	75 7f		 jne	 SHORT $LN10@parse_ctlf

; 1876 :     {
; 1877 :         // "File open error: \"%s\": %s"
; 1878 :         FWRMSG( stderr, HHC02623, "E", opts->ctlfile, strerror( errno ));

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00048	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00050	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
  00055	b9 02 00 00 00	 mov	 ecx, 2
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00060	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv69[rsp]
  00065	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0006a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170433
  00082	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170434
  0008e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00098	41 b9 03 00 00
	00		 mov	 r9d, 3
  0009e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170435
  000a5	ba 56 07 00 00	 mov	 edx, 1878		; 00000756H
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170436
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1879 :         return -1;

  000b7	b8 ff ff ff ff	 mov	 eax, -1
  000bc	e9 db 01 00 00	 jmp	 $LN1@parse_ctlf
$LN10@parse_ctlf:
$LN2@parse_ctlf:

; 1880 :     }
; 1881 : 
; 1882 :     /* Parse and save each control file statement */
; 1883 :     while ((rec = fgets( (char*) bfr, sizeof( bfr ), cfile )) != NULL)

  000c1	4c 8b 44 24 68	 mov	 r8, QWORD PTR cfile$[rsp]
  000c6	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  000d8	48 89 44 24 60	 mov	 QWORD PTR rec$[rsp], rax
  000dd	48 83 7c 24 60
	00		 cmp	 QWORD PTR rec$[rsp], 0
  000e3	74 45		 je	 SHORT $LN3@parse_ctlf

; 1884 :     {
; 1885 :         recno++;

  000e5	8b 44 24 54	 mov	 eax, DWORD PTR recno$[rsp]
  000e9	ff c0		 inc	 eax
  000eb	89 44 24 54	 mov	 DWORD PTR recno$[rsp], eax

; 1886 :         rec[ strlen( rec ) - 1 ] = 0;  // (remove newline)

  000ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  000f4	e8 00 00 00 00	 call	 strlen
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  000fe	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 1887 : 
; 1888 :         if (parse_ctlfile_stmt( opts, rec, recno ) != 0)

  00103	44 8b 44 24 54	 mov	 r8d, DWORD PTR recno$[rsp]
  00108	48 8b 54 24 60	 mov	 rdx, QWORD PTR rec$[rsp]
  0010d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00115	e8 00 00 00 00	 call	 parse_ctlfile_stmt
  0011a	85 c0		 test	 eax, eax
  0011c	74 0a		 je	 SHORT $LN11@parse_ctlf

; 1889 :             errs++;

  0011e	8b 44 24 50	 mov	 eax, DWORD PTR errs$[rsp]
  00122	ff c0		 inc	 eax
  00124	89 44 24 50	 mov	 DWORD PTR errs$[rsp], eax
$LN11@parse_ctlf:

; 1890 :     }

  00128	eb 97		 jmp	 SHORT $LN2@parse_ctlf
$LN3@parse_ctlf:

; 1891 : 
; 1892 :     /* Check for ctlfile I/O error */
; 1893 :     if (ferror( cfile ))

  0012a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cfile$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00135	85 c0		 test	 eax, eax
  00137	74 7f		 je	 SHORT $LN12@parse_ctlf

; 1894 :     {
; 1895 :         // "I/O error on file \"%s\": %s"
; 1896 :         FWRMSG( stderr, HHC02627, "E", opts->ctlfile, strerror( errno ));

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00147	48 89 44 24 78	 mov	 QWORD PTR tv136[rsp], rax
  0014c	b9 02 00 00 00	 mov	 ecx, 2
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00157	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv136[rsp]
  0015c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00161	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00169	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0016d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170439
  00179	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170440
  00185	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0018a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00195	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170441
  0019c	ba 68 07 00 00	 mov	 edx, 1896		; 00000768H
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170442
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1897 :         errs++;

  001ae	8b 44 24 50	 mov	 eax, DWORD PTR errs$[rsp]
  001b2	ff c0		 inc	 eax
  001b4	89 44 24 50	 mov	 DWORD PTR errs$[rsp], eax
$LN12@parse_ctlf:
$LN6@parse_ctlf:

; 1898 :     }
; 1899 : 
; 1900 :     /* Close the control file */
; 1901 :     VERIFY( fclose( cfile ) == 0 );

  001b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cfile$[rsp]
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  001c3	85 c0		 test	 eax, eax
  001c5	74 5c		 je	 SHORT $LN13@parse_ctlf
$LN9@parse_ctlf:
  001c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170444
  001ce	41 b8 6d 07 00
	00		 mov	 r8d, 1901		; 0000076dH
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170445
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170446
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001ee	85 c0		 test	 eax, eax
  001f0	74 20		 je	 SHORT $LN14@parse_ctlf
  001f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170448
  001f9	41 b8 6d 07 00
	00		 mov	 r8d, 1901		; 0000076dH
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170449
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170450
  0020d	e8 00 00 00 00	 call	 DebuggerTrace
$LN14@parse_ctlf:
  00212	33 c0		 xor	 eax, eax
  00214	85 c0		 test	 eax, eax
  00216	75 af		 jne	 SHORT $LN9@parse_ctlf
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0021e	85 c0		 test	 eax, eax
  00220	74 01		 je	 SHORT $LN15@parse_ctlf
  00222	cc		 int	 3
$LN15@parse_ctlf:
$LN13@parse_ctlf:
  00223	33 c0		 xor	 eax, eax
  00225	85 c0		 test	 eax, eax
  00227	75 8f		 jne	 SHORT $LN6@parse_ctlf

; 1902 : 
; 1903 :     if (errs)

  00229	83 7c 24 50 00	 cmp	 DWORD PTR errs$[rsp], 0
  0022e	74 4f		 je	 SHORT $LN16@parse_ctlf

; 1904 :         // "%d errors encountered"
; 1905 :         FWRMSG( stderr, HHC02630, "W", errs );

  00230	b9 02 00 00 00	 mov	 ecx, 2
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023b	8b 4c 24 50	 mov	 ecx, DWORD PTR errs$[rsp]
  0023f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170453
  0024a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170454
  00256	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00260	41 b9 03 00 00
	00		 mov	 r9d, 3
  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170455
  0026d	ba 71 07 00 00	 mov	 edx, 1905		; 00000771H
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170456
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@parse_ctlf:

; 1906 : 
; 1907 :     return errs ? -1 : 0;

  0027f	83 7c 24 50 00	 cmp	 DWORD PTR errs$[rsp], 0
  00284	74 0a		 je	 SHORT $LN18@parse_ctlf
  00286	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR tv181[rsp], -1
  0028e	eb 08		 jmp	 SHORT $LN19@parse_ctlf
$LN18@parse_ctlf:
  00290	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN19@parse_ctlf:
  00298	8b 44 24 58	 mov	 eax, DWORD PTR tv181[rsp]
$LN1@parse_ctlf:

; 1908 : }

  0029c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002a3	c3		 ret	 0
parse_ctlfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
argc$ = 80
msg$ = 88
filefmt$ = 96
reclen$ = 104
fn$ = 112
recfm$ = 120
ft$ = 128
fm$ = 136
codepage$ = 144
lrecl$ = 152
infile$ = 160
rec$ = 168
rc$ = 176
tv139 = 184
tv143 = 192
tv147 = 200
tv151 = 208
tv155 = 216
tv159 = 224
tv163 = 232
tv167 = 240
endptr$ = 248
ctl$ = 256
stt$ = 320
argv$ = 384
__$ArrayPad$ = 8576
opts$ = 8608
orec$ = 8616
recno$ = 8624
parse_ctlfile_stmt PROC

; 1642 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	b8 90 21 00 00	 mov	 eax, 8592		; 00002190H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 80
	21 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1643 :     int            rc;
; 1644 :     int            argc;
; 1645 :     int            reclen;
; 1646 : 
; 1647 :     struct  stat   stt                  = {0};

  0002f	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR stt$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00041	f3 aa		 rep stosb

; 1648 :     CTLTAB         ctl                  = {0};

  00043	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR ctl$[rsp]
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	33 c0		 xor	 eax, eax
  00050	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00055	f3 aa		 rep stosb

; 1649 :     char*          argv[ MAX_ARGS ]     = {0};

  00057	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR argv$[rsp]
  0005f	48 8b f8	 mov	 rdi, rax
  00062	33 c0		 xor	 eax, eax
  00064	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00069	f3 aa		 rep stosb

; 1650 :     char*          fn                   = NULL;

  0006b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR fn$[rsp], 0

; 1651 :     char*          ft                   = NULL;

  00074	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ft$[rsp], 0

; 1652 :     char*          fm                   = NULL;

  00080	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fm$[rsp], 0

; 1653 :     char*          recfm                = NULL;

  0008c	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR recfm$[rsp], 0

; 1654 :     char*          lrecl                = NULL;

  00095	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR lrecl$[rsp], 0

; 1655 :     char*          filefmt              = NULL;

  000a1	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR filefmt$[rsp], 0

; 1656 :     char*          infile               = NULL;

  000aa	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR infile$[rsp], 0

; 1657 :     char*          rec                  = NULL;

  000b6	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rec$[rsp], 0

; 1658 :     char*          endptr               = NULL;

  000c2	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR endptr$[rsp], 0

; 1659 :     const char*    msg                  = NULL;

  000ce	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR msg$[rsp], 0

; 1660 :     const char*    codepage             = NULL;

  000d7	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR codepage$[rsp], 0

; 1661 : 
; 1662 :     /* Parse the ctlfile statement */
; 1663 :     if (0
; 1664 :         || parse_args((rec = strdup( orec )), MAX_ARGS, argv, &argc ) == 0
; 1665 :         || argv[0][0] == '*'
; 1666 :         || argv[0][0] == '#'
; 1667 :         || argv[0][0] == ';'

  000e3	33 c0		 xor	 eax, eax
  000e5	85 c0		 test	 eax, eax
  000e7	0f 85 a3 00 00
	00		 jne	 $LN15@parse_ctlf
  000ed	48 8b 8c 24 a8
	21 00 00	 mov	 rcx, QWORD PTR orec$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000fb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rec$[rsp], rax
  00103	4c 8d 4c 24 50	 lea	 r9, QWORD PTR argc$[rsp]
  00108	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR argv$[rsp]
  00110	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00115	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parse_args
  00123	85 c0		 test	 eax, eax
  00125	74 69		 je	 SHORT $LN15@parse_ctlf
  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	b9 01 00 00 00	 mov	 ecx, 1
  00135	48 6b c9 00	 imul	 rcx, rcx, 0
  00139	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00141	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00145	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00148	74 46		 je	 SHORT $LN15@parse_ctlf
  0014a	b8 08 00 00 00	 mov	 eax, 8
  0014f	48 6b c0 00	 imul	 rax, rax, 0
  00153	b9 01 00 00 00	 mov	 ecx, 1
  00158	48 6b c9 00	 imul	 rcx, rcx, 0
  0015c	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00164	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00168	83 f8 23	 cmp	 eax, 35			; 00000023H
  0016b	74 23		 je	 SHORT $LN15@parse_ctlf
  0016d	b8 08 00 00 00	 mov	 eax, 8
  00172	48 6b c0 00	 imul	 rax, rax, 0
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	48 6b c9 00	 imul	 rcx, rcx, 0
  0017f	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00187	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0018b	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0018e	75 15		 jne	 SHORT $LN14@parse_ctlf
$LN15@parse_ctlf:

; 1668 :     )
; 1669 :     {
; 1670 :         /* Blank line or comment line; ignore */
; 1671 :         free( rec );

  00190	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1672 :         return 0;

  0019e	33 c0		 xor	 eax, eax
  001a0	e9 42 09 00 00	 jmp	 $LN1@parse_ctlf
$LN14@parse_ctlf:

; 1673 :     }
; 1674 : 
; 1675 :     /*     0        1     2     3       4        5       6         7      */
; 1676 :     /* [codepage]  <FN>  <FT>  <FM>  <recfm>  <lrecl>  <type>  <hostfile> */
; 1677 : 
; 1678 :     codepage = argc >= 1 ? argv[0] : NULL;

  001a5	83 7c 24 50 01	 cmp	 DWORD PTR argc$[rsp], 1
  001aa	7c 1b		 jl	 SHORT $LN45@parse_ctlf
  001ac	b8 08 00 00 00	 mov	 eax, 8
  001b1	48 6b c0 00	 imul	 rax, rax, 0
  001b5	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  001bd	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  001c5	eb 0c		 jmp	 SHORT $LN46@parse_ctlf
$LN45@parse_ctlf:
  001c7	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv139[rsp], 0
$LN46@parse_ctlf:
  001d3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv139[rsp]
  001db	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR codepage$[rsp], rax

; 1679 :     fn       = argc >= 2 ? argv[1] : NULL;

  001e3	83 7c 24 50 02	 cmp	 DWORD PTR argc$[rsp], 2
  001e8	7c 1b		 jl	 SHORT $LN47@parse_ctlf
  001ea	b8 08 00 00 00	 mov	 eax, 8
  001ef	48 6b c0 01	 imul	 rax, rax, 1
  001f3	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  001fb	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  00203	eb 0c		 jmp	 SHORT $LN48@parse_ctlf
$LN47@parse_ctlf:
  00205	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv143[rsp], 0
$LN48@parse_ctlf:
  00211	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv143[rsp]
  00219	48 89 44 24 70	 mov	 QWORD PTR fn$[rsp], rax

; 1680 :     ft       = argc >= 3 ? argv[2] : NULL;

  0021e	83 7c 24 50 03	 cmp	 DWORD PTR argc$[rsp], 3
  00223	7c 1b		 jl	 SHORT $LN49@parse_ctlf
  00225	b8 08 00 00 00	 mov	 eax, 8
  0022a	48 6b c0 02	 imul	 rax, rax, 2
  0022e	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00236	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  0023e	eb 0c		 jmp	 SHORT $LN50@parse_ctlf
$LN49@parse_ctlf:
  00240	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv147[rsp], 0
$LN50@parse_ctlf:
  0024c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv147[rsp]
  00254	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ft$[rsp], rax

; 1681 :     fm       = argc >= 4 ? argv[3] : NULL;

  0025c	83 7c 24 50 04	 cmp	 DWORD PTR argc$[rsp], 4
  00261	7c 1b		 jl	 SHORT $LN51@parse_ctlf
  00263	b8 08 00 00 00	 mov	 eax, 8
  00268	48 6b c0 03	 imul	 rax, rax, 3
  0026c	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00274	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  0027c	eb 0c		 jmp	 SHORT $LN52@parse_ctlf
$LN51@parse_ctlf:
  0027e	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv151[rsp], 0
$LN52@parse_ctlf:
  0028a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv151[rsp]
  00292	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR fm$[rsp], rax

; 1682 :     recfm    = argc >= 5 ? argv[4] : NULL;

  0029a	83 7c 24 50 05	 cmp	 DWORD PTR argc$[rsp], 5
  0029f	7c 1b		 jl	 SHORT $LN53@parse_ctlf
  002a1	b8 08 00 00 00	 mov	 eax, 8
  002a6	48 6b c0 04	 imul	 rax, rax, 4
  002aa	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  002b2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  002ba	eb 0c		 jmp	 SHORT $LN54@parse_ctlf
$LN53@parse_ctlf:
  002bc	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv155[rsp], 0
$LN54@parse_ctlf:
  002c8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  002d0	48 89 44 24 78	 mov	 QWORD PTR recfm$[rsp], rax

; 1683 :     lrecl    = argc >= 6 ? argv[5] : NULL;

  002d5	83 7c 24 50 06	 cmp	 DWORD PTR argc$[rsp], 6
  002da	7c 1b		 jl	 SHORT $LN55@parse_ctlf
  002dc	b8 08 00 00 00	 mov	 eax, 8
  002e1	48 6b c0 05	 imul	 rax, rax, 5
  002e5	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  002ed	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  002f5	eb 0c		 jmp	 SHORT $LN56@parse_ctlf
$LN55@parse_ctlf:
  002f7	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv159[rsp], 0
$LN56@parse_ctlf:
  00303	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv159[rsp]
  0030b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR lrecl$[rsp], rax

; 1684 :     filefmt  = argc >= 7 ? argv[6] : NULL;

  00313	83 7c 24 50 07	 cmp	 DWORD PTR argc$[rsp], 7
  00318	7c 1b		 jl	 SHORT $LN57@parse_ctlf
  0031a	b8 08 00 00 00	 mov	 eax, 8
  0031f	48 6b c0 06	 imul	 rax, rax, 6
  00323	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  0032b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  00333	eb 0c		 jmp	 SHORT $LN58@parse_ctlf
$LN57@parse_ctlf:
  00335	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv163[rsp], 0
$LN58@parse_ctlf:
  00341	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv163[rsp]
  00349	48 89 44 24 60	 mov	 QWORD PTR filefmt$[rsp], rax

; 1685 :     infile   = argc >= 8 ? argv[7] : NULL;

  0034e	83 7c 24 50 08	 cmp	 DWORD PTR argc$[rsp], 8
  00353	7c 1b		 jl	 SHORT $LN59@parse_ctlf
  00355	b8 08 00 00 00	 mov	 eax, 8
  0035a	48 6b c0 07	 imul	 rax, rax, 7
  0035e	48 8b 84 04 80
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax]
  00366	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
  0036e	eb 0c		 jmp	 SHORT $LN60@parse_ctlf
$LN59@parse_ctlf:
  00370	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv167[rsp], 0
$LN60@parse_ctlf:
  0037c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv167[rsp]
  00384	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR infile$[rsp], rax

; 1686 : 
; 1687 :     /* Was codepage specified? */
; 1688 :     if (codepage && strchr( codepage, '/' ))

  0038c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR codepage$[rsp], 0
  00395	74 3f		 je	 SHORT $LN16@parse_ctlf
  00397	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0039c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR codepage$[rsp]
  003a4	e8 00 00 00 00	 call	 strchr
  003a9	48 85 c0	 test	 rax, rax
  003ac	74 28		 je	 SHORT $LN16@parse_ctlf

; 1689 :     {
; 1690 :         if (!valid_codepage_name( codepage ))

  003ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR codepage$[rsp]
  003b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_valid_codepage_name
  003bc	0f b6 c0	 movzx	 eax, al
  003bf	85 c0		 test	 eax, eax
  003c1	75 11		 jne	 SHORT $LN18@parse_ctlf

; 1691 :         {
; 1692 :             msg = "Invalid codepage";

  003c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170343
  003ca	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1693 :             goto process_entry_error;

  003cf	e9 f8 05 00 00	 jmp	 $process_entry_error$61
$LN18@parse_ctlf:

; 1694 :         }
; 1695 :     }

  003d4	eb 6d		 jmp	 SHORT $LN17@parse_ctlf
$LN16@parse_ctlf:

; 1696 :     else /* codepage NOT specified; adjust parameters */
; 1697 :     {
; 1698 :         infile   = filefmt;

  003d6	48 8b 44 24 60	 mov	 rax, QWORD PTR filefmt$[rsp]
  003db	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR infile$[rsp], rax

; 1699 :         filefmt  = lrecl;

  003e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lrecl$[rsp]
  003eb	48 89 44 24 60	 mov	 QWORD PTR filefmt$[rsp], rax

; 1700 :         lrecl    = recfm;

  003f0	48 8b 44 24 78	 mov	 rax, QWORD PTR recfm$[rsp]
  003f5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR lrecl$[rsp], rax

; 1701 :         recfm    = fm;

  003fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fm$[rsp]
  00405	48 89 44 24 78	 mov	 QWORD PTR recfm$[rsp], rax

; 1702 :         fm       = ft;

  0040a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ft$[rsp]
  00412	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR fm$[rsp], rax

; 1703 :         ft       = fn;

  0041a	48 8b 44 24 70	 mov	 rax, QWORD PTR fn$[rsp]
  0041f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ft$[rsp], rax

; 1704 :         fn       = (char*) codepage;

  00427	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR codepage$[rsp]
  0042f	48 89 44 24 70	 mov	 QWORD PTR fn$[rsp], rax

; 1705 :         codepage = defaultcp;

  00434	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR defaultcp
  0043b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR codepage$[rsp], rax
$LN17@parse_ctlf:

; 1706 :     }
; 1707 : 
; 1708 :     /* Validate each argument... */
; 1709 : 
; 1710 :     if (!fn)

  00443	48 83 7c 24 70
	00		 cmp	 QWORD PTR fn$[rsp], 0
  00449	75 11		 jne	 SHORT $LN19@parse_ctlf

; 1711 :     {
; 1712 :         msg = "File name missing";

  0044b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170345
  00452	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1713 :         goto process_entry_error;

  00457	e9 70 05 00 00	 jmp	 $process_entry_error$61
$LN19@parse_ctlf:

; 1714 :     }
; 1715 : 
; 1716 :     if (strcasecmp( fn, "@TM" ) == 0)

  0045c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170347
  00463	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fn$[rsp]
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0046e	85 c0		 test	 eax, eax
  00470	0f 85 9a 00 00
	00		 jne	 $LN20@parse_ctlf

; 1717 :     {
; 1718 :         ctl.fn = strdup( "@TM" );

  00476	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170348
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00483	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ctl$[rsp+16], rax

; 1719 :         ctl.loaded = false;

  0048b	c6 84 24 3e 01
	00 00 00	 mov	 BYTE PTR ctl$[rsp+62], 0
$LN4@parse_ctlf:

; 1720 :         VERIFY( add_ctltab_entry( &ctl ));

  00493	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ctl$[rsp]
  0049b	e8 00 00 00 00	 call	 add_ctltab_entry
  004a0	0f b6 c0	 movzx	 eax, al
  004a3	85 c0		 test	 eax, eax
  004a5	75 5c		 jne	 SHORT $LN21@parse_ctlf
$LN7@parse_ctlf:
  004a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170350
  004ae	41 b8 b8 06 00
	00		 mov	 r8d, 1720		; 000006b8H
  004b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170351
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170352
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004ce	85 c0		 test	 eax, eax
  004d0	74 20		 je	 SHORT $LN22@parse_ctlf
  004d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170354
  004d9	41 b8 b8 06 00
	00		 mov	 r8d, 1720		; 000006b8H
  004df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170355
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170356
  004ed	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@parse_ctlf:
  004f2	33 c0		 xor	 eax, eax
  004f4	85 c0		 test	 eax, eax
  004f6	75 af		 jne	 SHORT $LN7@parse_ctlf
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004fe	85 c0		 test	 eax, eax
  00500	74 01		 je	 SHORT $LN23@parse_ctlf
  00502	cc		 int	 3
$LN23@parse_ctlf:
$LN21@parse_ctlf:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	75 8a		 jne	 SHORT $LN4@parse_ctlf

; 1721 :         return 0;

  00509	33 c0		 xor	 eax, eax
  0050b	e9 d7 05 00 00	 jmp	 $LN1@parse_ctlf
$LN20@parse_ctlf:

; 1722 :     }
; 1723 : 
; 1724 :     if (!ft)

  00510	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ft$[rsp], 0
  00519	75 11		 jne	 SHORT $LN24@parse_ctlf

; 1725 :     {
; 1726 :         msg = "File type missing";

  0051b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170359
  00522	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1727 :         goto process_entry_error;

  00527	e9 a0 04 00 00	 jmp	 $process_entry_error$61
$LN24@parse_ctlf:

; 1728 :     }
; 1729 : 
; 1730 :     if (!fm)

  0052c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR fm$[rsp], 0
  00535	75 11		 jne	 SHORT $LN25@parse_ctlf

; 1731 :     {
; 1732 :         msg = "File mode missing";

  00537	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170361
  0053e	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1733 :         goto process_entry_error;

  00543	e9 84 04 00 00	 jmp	 $process_entry_error$61
$LN25@parse_ctlf:

; 1734 :     }
; 1735 : 
; 1736 :     strupper( fn, fn );

  00548	48 8b 54 24 70	 mov	 rdx, QWORD PTR fn$[rsp]
  0054d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fn$[rsp]
  00552	e8 00 00 00 00	 call	 strupper

; 1737 :     strupper( ft, ft );

  00557	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ft$[rsp]
  0055f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ft$[rsp]
  00567	e8 00 00 00 00	 call	 strupper

; 1738 :     strupper( fm, fm );

  0056c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR fm$[rsp]
  00574	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR fm$[rsp]
  0057c	e8 00 00 00 00	 call	 strupper

; 1739 : 
; 1740 :     if ((msg = validate_cmsfile( fn, ft, fm )) != NULL)

  00581	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR fm$[rsp]
  00589	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ft$[rsp]
  00591	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fn$[rsp]
  00596	e8 00 00 00 00	 call	 validate_cmsfile
  0059b	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax
  005a0	48 83 7c 24 58
	00		 cmp	 QWORD PTR msg$[rsp], 0
  005a6	74 05		 je	 SHORT $LN26@parse_ctlf

; 1741 :         goto process_entry_error;

  005a8	e9 1f 04 00 00	 jmp	 $process_entry_error$61
$LN26@parse_ctlf:

; 1742 : 
; 1743 :     if (!recfm)

  005ad	48 83 7c 24 78
	00		 cmp	 QWORD PTR recfm$[rsp], 0
  005b3	75 11		 jne	 SHORT $LN27@parse_ctlf

; 1744 :     {
; 1745 :         msg = "Record format missing";

  005b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170364
  005bc	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1746 :         goto process_entry_error;

  005c1	e9 06 04 00 00	 jmp	 $process_entry_error$61
$LN27@parse_ctlf:

; 1747 :     }
; 1748 : 
; 1749 :     if (1
; 1750 :         && !CMD( recfm, FIXED,    1 )
; 1751 :         && !CMD( recfm, VARIABLE, 1 )

  005c6	33 c0		 xor	 eax, eax
  005c8	83 f8 01	 cmp	 eax, 1
  005cb	74 47		 je	 SHORT $LN28@parse_ctlf
  005cd	41 b8 01 00 00
	00		 mov	 r8d, 1
  005d3	48 8b 54 24 78	 mov	 rdx, QWORD PTR recfm$[rsp]
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170366
  005df	e8 00 00 00 00	 call	 strcaseabbrev
  005e4	85 c0		 test	 eax, eax
  005e6	75 2c		 jne	 SHORT $LN28@parse_ctlf
  005e8	41 b8 01 00 00
	00		 mov	 r8d, 1
  005ee	48 8b 54 24 78	 mov	 rdx, QWORD PTR recfm$[rsp]
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170367
  005fa	e8 00 00 00 00	 call	 strcaseabbrev
  005ff	85 c0		 test	 eax, eax
  00601	75 11		 jne	 SHORT $LN28@parse_ctlf

; 1752 :     )
; 1753 :     {
; 1754 :         msg = "Record format must be 'F'ixed or 'V'ariable";

  00603	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170368
  0060a	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1755 :         goto process_entry_error;

  0060f	e9 b8 03 00 00	 jmp	 $process_entry_error$61
$LN28@parse_ctlf:

; 1756 :     }
; 1757 : 
; 1758 :     /* For recfm 'V'ariable files the lrecl should not be specified. */
; 1759 :     if (recfm[0] == 'V')

  00614	b8 01 00 00 00	 mov	 eax, 1
  00619	48 6b c0 00	 imul	 rax, rax, 0
  0061d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR recfm$[rsp]
  00622	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00626	83 f8 56	 cmp	 eax, 86			; 00000056H
  00629	75 27		 jne	 SHORT $LN29@parse_ctlf

; 1760 :     {
; 1761 :         infile  = filefmt;

  0062b	48 8b 44 24 60	 mov	 rax, QWORD PTR filefmt$[rsp]
  00630	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR infile$[rsp], rax

; 1762 :         filefmt = lrecl;

  00638	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR lrecl$[rsp]
  00640	48 89 44 24 60	 mov	 QWORD PTR filefmt$[rsp], rax

; 1763 :         reclen  = 0;     // (recln meaningless for recfm V = variable)

  00645	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR reclen$[rsp], 0

; 1764 :     }

  0064d	e9 bb 00 00 00	 jmp	 $LN30@parse_ctlf
$LN29@parse_ctlf:

; 1765 :     else /* (recfm[0]) */
; 1766 :     {
; 1767 :         if (!lrecl)

  00652	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR lrecl$[rsp], 0
  0065b	75 11		 jne	 SHORT $LN31@parse_ctlf

; 1768 :         {
; 1769 :             msg = "Logical Record Length missing for 'F'ixed record format file";

  0065d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170372
  00664	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1770 :             goto process_entry_error;

  00669	e9 5e 03 00 00	 jmp	 $process_entry_error$61
$LN31@parse_ctlf:

; 1771 :         }
; 1772 : 
; 1773 :         errno  = 0;

  0066e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00674	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1774 :         reclen = strtoul( lrecl, &endptr, 0 );

  0067a	45 33 c0	 xor	 r8d, r8d
  0067d	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR endptr$[rsp]
  00685	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR lrecl$[rsp]
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  00693	89 44 24 68	 mov	 DWORD PTR reclen$[rsp], eax

; 1775 : 
; 1776 :         if (errno || endptr[0] != 0)

  00697	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0069d	83 38 00	 cmp	 DWORD PTR [rax], 0
  006a0	75 19		 jne	 SHORT $LN33@parse_ctlf
  006a2	b8 01 00 00 00	 mov	 eax, 1
  006a7	48 6b c0 00	 imul	 rax, rax, 0
  006ab	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR endptr$[rsp]
  006b3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  006b7	85 c0		 test	 eax, eax
  006b9	74 11		 je	 SHORT $LN32@parse_ctlf
$LN33@parse_ctlf:

; 1777 :         {
; 1778 :             msg = "Logical Record Length must be a numeric value";

  006bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170375
  006c2	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1779 :             goto process_entry_error;

  006c7	e9 00 03 00 00	 jmp	 $process_entry_error$61
$LN32@parse_ctlf:

; 1780 :         }
; 1781 : 
; 1782 :         if (reclen < 1 || reclen >= MAX_PLC2_BLKSIZE)

  006cc	83 7c 24 68 01	 cmp	 DWORD PTR reclen$[rsp], 1
  006d1	7c 0a		 jl	 SHORT $LN35@parse_ctlf
  006d3	81 7c 24 68 ff
	ff 00 00	 cmp	 DWORD PTR reclen$[rsp], 65535 ; 0000ffffH
  006db	7c 30		 jl	 SHORT $LN34@parse_ctlf
$LN35@parse_ctlf:

; 1783 :         {
; 1784 :             static char buf[64];
; 1785 :             MSGBUF( buf, "Logical Record Length must be between 1 and %u",

  006dd	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  006e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170378
  006ea	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?BE@??parse_ctlfile_stmt@@9@9
  006f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1786 :                 MAX_PLC2_BLKSIZE );
; 1787 :             msg = buf;

  006fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buf@?BE@??parse_ctlfile_stmt@@9@9
  00703	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1788 :             goto process_entry_error;

  00708	e9 bf 02 00 00	 jmp	 $process_entry_error$61
$LN34@parse_ctlf:
$LN30@parse_ctlf:

; 1789 :         }
; 1790 :     }
; 1791 : 
; 1792 :     if (!filefmt)

  0070d	48 83 7c 24 60
	00		 cmp	 QWORD PTR filefmt$[rsp], 0
  00713	75 11		 jne	 SHORT $LN36@parse_ctlf

; 1793 :     {
; 1794 :         msg = "File format is missing";

  00715	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170380
  0071c	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1795 :         goto process_entry_error;

  00721	e9 a6 02 00 00	 jmp	 $process_entry_error$61
$LN36@parse_ctlf:

; 1796 :     }
; 1797 : 
; 1798 :     if (1
; 1799 :         && !CMD( filefmt, BINARY,     1 )
; 1800 :         && !CMD( filefmt, TEXTUAL,    1 )
; 1801 :         && !CMD( filefmt, TXT,        1 )
; 1802 :         && !CMD( filefmt, STRUCTURED, 1 )

  00726	33 c0		 xor	 eax, eax
  00728	83 f8 01	 cmp	 eax, 1
  0072b	74 7d		 je	 SHORT $LN37@parse_ctlf
  0072d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00733	48 8b 54 24 60	 mov	 rdx, QWORD PTR filefmt$[rsp]
  00738	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170382
  0073f	e8 00 00 00 00	 call	 strcaseabbrev
  00744	85 c0		 test	 eax, eax
  00746	75 62		 jne	 SHORT $LN37@parse_ctlf
  00748	41 b8 01 00 00
	00		 mov	 r8d, 1
  0074e	48 8b 54 24 60	 mov	 rdx, QWORD PTR filefmt$[rsp]
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170383
  0075a	e8 00 00 00 00	 call	 strcaseabbrev
  0075f	85 c0		 test	 eax, eax
  00761	75 47		 jne	 SHORT $LN37@parse_ctlf
  00763	41 b8 01 00 00
	00		 mov	 r8d, 1
  00769	48 8b 54 24 60	 mov	 rdx, QWORD PTR filefmt$[rsp]
  0076e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170384
  00775	e8 00 00 00 00	 call	 strcaseabbrev
  0077a	85 c0		 test	 eax, eax
  0077c	75 2c		 jne	 SHORT $LN37@parse_ctlf
  0077e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00784	48 8b 54 24 60	 mov	 rdx, QWORD PTR filefmt$[rsp]
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170385
  00790	e8 00 00 00 00	 call	 strcaseabbrev
  00795	85 c0		 test	 eax, eax
  00797	75 11		 jne	 SHORT $LN37@parse_ctlf

; 1803 :     )
; 1804 :     {
; 1805 :         msg = "File format must be either 'B'inary, 'T'extual or 'S'tructured";

  00799	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170386
  007a0	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1806 :         goto process_entry_error;

  007a5	e9 22 02 00 00	 jmp	 $process_entry_error$61
$LN37@parse_ctlf:

; 1807 :     }
; 1808 : 
; 1809 :     if (!infile)

  007aa	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR infile$[rsp], 0
  007b3	75 11		 jne	 SHORT $LN38@parse_ctlf

; 1810 :     {
; 1811 :         msg = "Input file name missing";

  007b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170388
  007bc	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1812 :         goto process_entry_error;

  007c1	e9 06 02 00 00	 jmp	 $process_entry_error$61
$LN38@parse_ctlf:

; 1813 :     }
; 1814 : 
; 1815 :     /* Structured files are only for RECFM V for the time being */
; 1816 :     if (filefmt[0] == 'S' && recfm[0] != 'V')

  007c6	b8 01 00 00 00	 mov	 eax, 1
  007cb	48 6b c0 00	 imul	 rax, rax, 0
  007cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filefmt$[rsp]
  007d4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  007d8	83 f8 53	 cmp	 eax, 83			; 00000053H
  007db	75 28		 jne	 SHORT $LN39@parse_ctlf
  007dd	b8 01 00 00 00	 mov	 eax, 1
  007e2	48 6b c0 00	 imul	 rax, rax, 0
  007e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR recfm$[rsp]
  007eb	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  007ef	83 f8 56	 cmp	 eax, 86			; 00000056H
  007f2	74 11		 je	 SHORT $LN39@parse_ctlf

; 1817 :     {
; 1818 :         msg = "Dumping structured input to anything other than RECFM V is not supported";

  007f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170390
  007fb	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1819 :         goto process_entry_error;

  00800	e9 c7 01 00 00	 jmp	 $process_entry_error$61
$LN39@parse_ctlf:

; 1820 :     }
; 1821 : 
; 1822 :     /* If 'DUMP'ing, verify host file exists */
; 1823 :     if (1
; 1824 :         && DUMP_VERB == opts->verb
; 1825 :         && (rc = stat( infile, &stt )) != 0

  00805	33 c0		 xor	 eax, eax
  00807	83 f8 01	 cmp	 eax, 1
  0080a	74 4f		 je	 SHORT $LN40@parse_ctlf
  0080c	48 8b 84 24 a0
	21 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00814	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00818	85 c0		 test	 eax, eax
  0081a	75 3f		 jne	 SHORT $LN40@parse_ctlf
  0081c	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR stt$[rsp]
  00824	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  0082c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00832	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00839	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00841	74 18		 je	 SHORT $LN40@parse_ctlf

; 1826 :     )
; 1827 :     {
; 1828 :         msg = strerror( errno );

  00843	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00849	8b 08		 mov	 ecx, DWORD PTR [rax]
  0084b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00851	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1829 :         goto process_entry_error;

  00856	e9 71 01 00 00	 jmp	 $process_entry_error$61
$LN40@parse_ctlf:

; 1830 :     }
; 1831 : 
; 1832 :     /* Add this entry to the table */
; 1833 :     ctl.orec     = strdup( orec );

  0085b	48 8b 8c 24 a8
	21 00 00	 mov	 rcx, QWORD PTR orec$[rsp]
  00863	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00869	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR ctl$[rsp], rax

; 1834 :     ctl.codepage = strdup( codepage );

  00871	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR codepage$[rsp]
  00879	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0087f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ctl$[rsp+8], rax

; 1835 :     ctl.fn       = strdup( fn );

  00887	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fn$[rsp]
  0088c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00892	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ctl$[rsp+16], rax

; 1836 :     ctl.ft       = strdup( ft );

  0089a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ft$[rsp]
  008a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  008a8	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR ctl$[rsp+24], rax

; 1837 :     ctl.fm       = strdup( fm );

  008b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR fm$[rsp]
  008b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  008be	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR ctl$[rsp+32], rax

; 1838 :     ctl.hostfile = strdup( infile );

  008c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  008ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  008d4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR ctl$[rsp+40], rax

; 1839 :     ctl.mtime    = stt.st_mtime;

  008dc	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR stt$[rsp+40]
  008e4	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR ctl$[rsp+48], rax

; 1840 :     ctl.reclen   = reclen;

  008ec	8b 44 24 68	 mov	 eax, DWORD PTR reclen$[rsp]
  008f0	89 84 24 38 01
	00 00		 mov	 DWORD PTR ctl$[rsp+56], eax

; 1841 :     ctl.recfm    = toupper( recfm  [0] );

  008f7	b8 01 00 00 00	 mov	 eax, 1
  008fc	48 6b c0 00	 imul	 rax, rax, 0
  00900	48 8b 4c 24 78	 mov	 rcx, QWORD PTR recfm$[rsp]
  00905	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00909	8b c8		 mov	 ecx, eax
  0090b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00911	88 84 24 3c 01
	00 00		 mov	 BYTE PTR ctl$[rsp+60], al

; 1842 :     ctl.filefmt  = toupper( filefmt[0] );

  00918	b8 01 00 00 00	 mov	 eax, 1
  0091d	48 6b c0 00	 imul	 rax, rax, 0
  00921	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filefmt$[rsp]
  00926	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0092a	8b c8		 mov	 ecx, eax
  0092c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00932	88 84 24 3d 01
	00 00		 mov	 BYTE PTR ctl$[rsp+61], al

; 1843 :     ctl.loaded   = false;

  00939	c6 84 24 3e 01
	00 00 00	 mov	 BYTE PTR ctl$[rsp+62], 0
$LN10@parse_ctlf:

; 1844 : 
; 1845 :     VERIFY( add_ctltab_entry( &ctl ));

  00941	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR ctl$[rsp]
  00949	e8 00 00 00 00	 call	 add_ctltab_entry
  0094e	0f b6 c0	 movzx	 eax, al
  00951	85 c0		 test	 eax, eax
  00953	75 5c		 jne	 SHORT $LN41@parse_ctlf
$LN13@parse_ctlf:
  00955	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170393
  0095c	41 b8 35 07 00
	00		 mov	 r8d, 1845		; 00000735H
  00962	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170394
  00969	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170395
  00970	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00976	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0097c	85 c0		 test	 eax, eax
  0097e	74 20		 je	 SHORT $LN42@parse_ctlf
  00980	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170397
  00987	41 b8 35 07 00
	00		 mov	 r8d, 1845		; 00000735H
  0098d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170398
  00994	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170399
  0099b	e8 00 00 00 00	 call	 DebuggerTrace
$LN42@parse_ctlf:
  009a0	33 c0		 xor	 eax, eax
  009a2	85 c0		 test	 eax, eax
  009a4	75 af		 jne	 SHORT $LN13@parse_ctlf
  009a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  009ac	85 c0		 test	 eax, eax
  009ae	74 01		 je	 SHORT $LN43@parse_ctlf
  009b0	cc		 int	 3
$LN43@parse_ctlf:
$LN41@parse_ctlf:
  009b1	33 c0		 xor	 eax, eax
  009b3	85 c0		 test	 eax, eax
  009b5	75 8a		 jne	 SHORT $LN10@parse_ctlf

; 1846 : 
; 1847 :     free( rec );

  009b7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  009bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1848 :     return 0;

  009c5	33 c0		 xor	 eax, eax
  009c7	e9 1b 01 00 00	 jmp	 $LN1@parse_ctlf
$process_entry_error$61:

; 1849 : 
; 1850 : process_entry_error:
; 1851 : 
; 1852 :     // ">>> %s"
; 1853 :     // "    Bad entry at line %d in file \"%s\""
; 1854 :     // "    %s"
; 1855 : 
; 1856 :     FWRMSG( stderr, HHC02626, "E", orec );

  009cc	b9 02 00 00 00	 mov	 ecx, 2
  009d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009d7	48 8b 8c 24 a8
	21 00 00	 mov	 rcx, QWORD PTR orec$[rsp]
  009df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170401
  009eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170402
  009f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a01	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a07	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170403
  00a0e	ba 40 07 00 00	 mov	 edx, 1856		; 00000740H
  00a13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170404
  00a1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1857 :     FWRMSG( stderr, HHC02632, "E", recno, opts->ctlfile );

  00a20	b9 02 00 00 00	 mov	 ecx, 2
  00a25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a2b	48 8b 8c 24 a0
	21 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00a33	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a37	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a3c	8b 8c 24 b0 21
	00 00		 mov	 ecx, DWORD PTR recno$[rsp]
  00a43	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170405
  00a4e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170406
  00a5a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a5f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a64	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a6a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170407
  00a71	ba 41 07 00 00	 mov	 edx, 1857		; 00000741H
  00a76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170408
  00a7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1858 :     FWRMSG( stderr, HHC02633, "E", msg );

  00a83	b9 02 00 00 00	 mov	 ecx, 2
  00a88	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a8e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR msg$[rsp]
  00a93	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170409
  00a9f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aa4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170410
  00aab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ab0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00abb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170411
  00ac2	ba 42 07 00 00	 mov	 edx, 1858		; 00000742H
  00ac7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170412
  00ace	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1859 : 
; 1860 :     free( rec );

  00ad4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  00adc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1861 :     return -1;

  00ae2	b8 ff ff ff ff	 mov	 eax, -1
$LN1@parse_ctlf:

; 1862 : }

  00ae7	48 8b 8c 24 80
	21 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00aef	48 33 cc	 xor	 rcx, rsp
  00af2	e8 00 00 00 00	 call	 __security_check_cookie
  00af7	48 81 c4 90 21
	00 00		 add	 rsp, 8592		; 00002190H
  00afe	5f		 pop	 rdi
  00aff	c3		 ret	 0
parse_ctlfile_stmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
i$ = 32
fn$ = 64
ft$ = 72
recfm$ = 80
find_ctltab_entry PROC

; 1624 : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1625 :     int  i;
; 1626 :     for (i=0; i < numctl; i++)

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001b	eb 0a		 jmp	 SHORT $LN4@find_ctlta
$LN2@find_ctlta:
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00021	ff c0		 inc	 eax
  00023	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@find_ctlta:
  00027	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numctl
  0002d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00031	0f 8d d1 00 00
	00		 jge	 $LN3@find_ctlta

; 1627 :         if (1
; 1628 :             && strcasecmp( ctltab[i].fn,    "@TM"   ) != 0  // not tapemark entry
; 1629 :             && strcasecmp( ctltab[i].fn,      fn    ) == 0  // file name matches
; 1630 :             && strcasecmp( ctltab[i].ft,      ft    ) == 0  // file type matches
; 1631 :             &&             ctltab[i].recfm == recfm         // recfm matches
; 1632 :             &&            !ctltab[i].loaded                 // not already loaded

  00037	33 c0		 xor	 eax, eax
  00039	83 f8 01	 cmp	 eax, 1
  0003c	0f 84 c1 00 00
	00		 je	 $LN5@find_ctlta
  00042	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00047	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170273
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  00059	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00064	85 c0		 test	 eax, eax
  00066	0f 84 97 00 00
	00		 je	 $LN5@find_ctlta
  0006c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00071	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00075	48 8b 54 24 40	 mov	 rdx, QWORD PTR fn$[rsp]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  00081	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0008c	85 c0		 test	 eax, eax
  0008e	75 73		 jne	 SHORT $LN5@find_ctlta
  00090	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00095	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00099	48 8b 54 24 48	 mov	 rdx, QWORD PTR ft$[rsp]
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  000a5	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000b0	85 c0		 test	 eax, eax
  000b2	75 4f		 jne	 SHORT $LN5@find_ctlta
  000b4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b9	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  000c4	0f be 44 01 3c	 movsx	 eax, BYTE PTR [rcx+rax+60]
  000c9	0f be 4c 24 50	 movsx	 ecx, BYTE PTR recfm$[rsp]
  000ce	3b c1		 cmp	 eax, ecx
  000d0	75 31		 jne	 SHORT $LN5@find_ctlta
  000d2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d7	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  000e2	0f b6 44 01 3e	 movzx	 eax, BYTE PTR [rcx+rax+62]
  000e7	85 c0		 test	 eax, eax
  000e9	75 18		 jne	 SHORT $LN5@find_ctlta

; 1633 :         )
; 1634 :             return &ctltab[i];  // (found)

  000eb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000f0	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  000f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  000fb	48 03 c8	 add	 rcx, rax
  000fe	48 8b c1	 mov	 rax, rcx
  00101	eb 07		 jmp	 SHORT $LN1@find_ctlta
$LN5@find_ctlta:
  00103	e9 15 ff ff ff	 jmp	 $LN2@find_ctlta
$LN3@find_ctlta:

; 1635 :     return NULL;                // (not found)

  00108	33 c0		 xor	 eax, eax
$LN1@find_ctlta:

; 1636 : }

  0010a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010e	c3		 ret	 0
find_ctltab_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
num$ = 32
tab$ = 40
ctl$ = 80
add_ctltab_entry PROC

; 1604 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1605 :     CTLTAB* tab;
; 1606 :     int     num;
; 1607 : 
; 1608 :     /* Make room for new entry */
; 1609 :     if (!(tab = realloc( ctltab, sizeof( CTLTAB ) * (num = numctl + 1))))

  0000b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numctl
  00011	ff c0		 inc	 eax
  00013	89 44 24 20	 mov	 DWORD PTR num$[rsp], eax
  00017	48 63 44 24 20	 movsxd	 rax, DWORD PTR num$[rsp]
  0001c	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00030	48 89 44 24 28	 mov	 QWORD PTR tab$[rsp], rax
  00035	48 83 7c 24 28
	00		 cmp	 QWORD PTR tab$[rsp], 0
  0003b	75 04		 jne	 SHORT $LN2@add_ctltab

; 1610 :         return false; // (out of memory)

  0003d	32 c0		 xor	 al, al
  0003f	eb 3d		 jmp	 SHORT $LN1@add_ctltab
$LN2@add_ctltab:

; 1611 : 
; 1612 :     ctltab = tab;

  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR tab$[rsp]
  00046	48 89 05 00 00
	00 00		 mov	 QWORD PTR ctltab, rax

; 1613 :     numctl = num;

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR num$[rsp]
  00051	89 05 00 00 00
	00		 mov	 DWORD PTR numctl, eax

; 1614 : 
; 1615 :     /* Append new entry to end of table */
; 1616 :     memcpy( &ctltab[ numctl - 1 ], ctl, sizeof( CTLTAB ));

  00057	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numctl
  0005d	ff c8		 dec	 eax
  0005f	48 98		 cdqe
  00061	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ctltab
  0006c	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00070	48 8b 74 24 50	 mov	 rsi, QWORD PTR ctl$[rsp]
  00075	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0007a	f3 a4		 rep movsb

; 1617 :     return true;

  0007c	b0 01		 mov	 al, 1
$LN1@add_ctltab:

; 1618 : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	5f		 pop	 rdi
  00083	5e		 pop	 rsi
  00084	c3		 ret	 0
add_ctltab_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
i$ = 48
fn$ = 80
ft$ = 88
fm$ = 96
validate_cmsfile PROC

; 1538 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1539 :     int i;
; 1540 :     static char msg[512];
; 1541 : 
; 1542 :     if (strlen( fn ) > 8) return "CMS File name too long";

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fn$[rsp]
  00018	e8 00 00 00 00	 call	 strlen
  0001d	48 83 f8 08	 cmp	 rax, 8
  00021	76 0c		 jbe	 SHORT $LN5@validate_c
  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170218
  0002a	e9 70 01 00 00	 jmp	 $LN1@validate_c
$LN5@validate_c:

; 1543 :     if (strlen( ft ) > 8) return "CMS File type too long";

  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ft$[rsp]
  00034	e8 00 00 00 00	 call	 strlen
  00039	48 83 f8 08	 cmp	 rax, 8
  0003d	76 0c		 jbe	 SHORT $LN6@validate_c
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170220
  00046	e9 54 01 00 00	 jmp	 $LN1@validate_c
$LN6@validate_c:

; 1544 :     if (strlen( fm ) > 2) return "CMS File mode too long";

  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fm$[rsp]
  00050	e8 00 00 00 00	 call	 strlen
  00055	48 83 f8 02	 cmp	 rax, 2
  00059	76 0c		 jbe	 SHORT $LN7@validate_c
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170222
  00062	e9 38 01 00 00	 jmp	 $LN1@validate_c
$LN7@validate_c:

; 1545 : 
; 1546 :     if ((i = validate_fnft( fn )) != 0)

  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fn$[rsp]
  0006c	e8 00 00 00 00	 call	 validate_fnft
  00071	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00075	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  0007a	74 34		 je	 SHORT $LN8@validate_c

; 1547 :     {
; 1548 :         MSGBUF( msg,

  0007c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00080	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170224
  0008b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170225
  00092	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?msg@?1??validate_cmsfile@@9@9
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1549 :             "Invalid character in CMS file %s at position %d",
; 1550 :             "name", i );
; 1551 :         return msg;

  000a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?msg@?1??validate_cmsfile@@9@9
  000ab	e9 ef 00 00 00	 jmp	 $LN1@validate_c
$LN8@validate_c:

; 1552 :     }
; 1553 : 
; 1554 :     if ((i = validate_fnft( ft )) != 0)

  000b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ft$[rsp]
  000b5	e8 00 00 00 00	 call	 validate_fnft
  000ba	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  000be	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  000c3	74 34		 je	 SHORT $LN9@validate_c

; 1555 :     {
; 1556 :         // "Invalid character in CMS file %s at position %d"
; 1557 :         MSGBUF( msg,

  000c5	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000c9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170227
  000d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170228
  000db	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?msg@?1??validate_cmsfile@@9@9
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1558 :             "Invalid character in CMS file %s at position %d",
; 1559 :             "type", i );
; 1560 :         return msg;

  000ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?msg@?1??validate_cmsfile@@9@9
  000f4	e9 a6 00 00 00	 jmp	 $LN1@validate_c
$LN9@validate_c:

; 1561 :     }
; 1562 : 
; 1563 :     if (!isalpha( fm[0] ))

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fm$[rsp]
  00107	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0010b	8b c8		 mov	 ecx, eax
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  00113	85 c0		 test	 eax, eax
  00115	75 09		 jne	 SHORT $LN10@validate_c

; 1564 :         return "CMS File mode must start with a letter";

  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170230
  0011e	eb 7f		 jmp	 SHORT $LN1@validate_c
$LN10@validate_c:

; 1565 : 
; 1566 :     if (strlen( fm ) > 1)

  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fm$[rsp]
  00125	e8 00 00 00 00	 call	 strlen
  0012a	48 83 f8 01	 cmp	 rax, 1
  0012e	76 6d		 jbe	 SHORT $LN11@validate_c

; 1567 :     {
; 1568 :         for (i=0; validfmnum[i] && fm[1] != validfmnum[i]; i++)

  00130	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00138	eb 0a		 jmp	 SHORT $LN4@validate_c
$LN2@validate_c:
  0013a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0013e	ff c0		 inc	 eax
  00140	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@validate_c:
  00144	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00149	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR validfmnum
  00150	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00154	85 c0		 test	 eax, eax
  00156	74 28		 je	 SHORT $LN3@validate_c
  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	48 6b c0 01	 imul	 rax, rax, 1
  00161	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fm$[rsp]
  00166	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0016a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0016f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR validfmnum
  00176	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0017a	3b c1		 cmp	 eax, ecx
  0017c	74 02		 je	 SHORT $LN3@validate_c

; 1569 :             ; // (do nothing)

  0017e	eb ba		 jmp	 SHORT $LN2@validate_c
$LN3@validate_c:

; 1570 : 
; 1571 :         if (!validfmnum[i])

  00180	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR validfmnum
  0018c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00190	85 c0		 test	 eax, eax
  00192	75 09		 jne	 SHORT $LN12@validate_c

; 1572 :             return "CMS File mode number must be 0-6";

  00194	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170233
  0019b	eb 02		 jmp	 SHORT $LN1@validate_c
$LN12@validate_c:
$LN11@validate_c:

; 1573 :     }
; 1574 : 
; 1575 :     return NULL;

  0019d	33 c0		 xor	 eax, eax
$LN1@validate_c:

; 1576 : }

  0019f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a3	c3		 ret	 0
validate_cmsfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
fnft$ = 32
validate_fnft PROC

; 1519 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1520 :     int i, j;
; 1521 : 
; 1522 :     for (i=0; fnft[i]; i++)     /* For each char in FN/FT... */

  00009	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@validate_f
$LN2@validate_f:
  00013	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@validate_f:
  0001d	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fnft$[rsp]
  00027	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0002b	85 c0		 test	 eax, eax
  0002d	74 64		 je	 SHORT $LN3@validate_f

; 1523 :     {
; 1524 :         for (j=0; validchars[j] && fnft[i] != validchars[j]; j++)

  0002f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  00036	eb 08		 jmp	 SHORT $LN7@validate_f
$LN5@validate_f:
  00038	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  0003b	ff c0		 inc	 eax
  0003d	89 04 24	 mov	 DWORD PTR j$[rsp], eax
$LN7@validate_f:
  00040	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR validchars
  0004b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0004f	85 c0		 test	 eax, eax
  00051	74 23		 je	 SHORT $LN6@validate_f
  00053	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fnft$[rsp]
  0005d	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00061	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00065	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR validchars
  0006c	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00070	3b c1		 cmp	 eax, ecx
  00072	74 02		 je	 SHORT $LN6@validate_f

; 1525 :             ; // (do nothing)

  00074	eb c2		 jmp	 SHORT $LN5@validate_f
$LN6@validate_f:

; 1526 : 
; 1527 :         if (!validchars[j])     /* If end of valid string reached */

  00076	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR validchars
  00081	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00085	85 c0		 test	 eax, eax
  00087	75 08		 jne	 SHORT $LN8@validate_f

; 1528 :             return i+1;         /* Then an invalid char was found */

  00089	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0008d	ff c0		 inc	 eax
  0008f	eb 04		 jmp	 SHORT $LN1@validate_f
$LN8@validate_f:

; 1529 :     }

  00091	eb 80		 jmp	 SHORT $LN2@validate_f
$LN3@validate_f:

; 1530 :     return 0;

  00093	33 c0		 xor	 eax, eax
$LN1@validate_f:

; 1531 : }

  00095	48 83 c4 18	 add	 rsp, 24
  00099	c3		 ret	 0
validate_fnft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
recfm$ = 96
fm$ = 100
blks$ = 104
recs$ = 108
recl$ = 112
ft$ = 120
fn$ = 136
dt$ = 152
__$ArrayPad$ = 176
cms$ = 208
str$ = 216
strsz$ = 224
format_cms_info PROC

; 1487 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1488 :     int  recl, recs, blks;
; 1489 : 
; 1490 :     char fn [ sizeof( cms->fn ) + 1 ]  = {0};

  00029	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR fn$[rsp]
  00031	48 8b f8	 mov	 rdi, rax
  00034	33 c0		 xor	 eax, eax
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	f3 aa		 rep stosb

; 1491 :     char ft [ sizeof( cms->ft ) + 1 ]  = {0};

  0003d	48 8d 44 24 78	 lea	 rax, QWORD PTR ft$[rsp]
  00042	48 8b f8	 mov	 rdi, rax
  00045	33 c0		 xor	 eax, eax
  00047	b9 09 00 00 00	 mov	 ecx, 9
  0004c	f3 aa		 rep stosb

; 1492 :     char fm [ sizeof( cms->fm ) + 1 ]  = {0};

  0004e	48 8d 44 24 64	 lea	 rax, QWORD PTR fm$[rsp]
  00053	48 8b f8	 mov	 rdi, rax
  00056	33 c0		 xor	 eax, eax
  00058	b9 03 00 00 00	 mov	 ecx, 3
  0005d	f3 aa		 rep stosb

; 1493 :     char dt [ 19                + 1 ]  = {0};

  0005f	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dt$[rsp]
  00067	48 8b f8	 mov	 rdi, rax
  0006a	33 c0		 xor	 eax, eax
  0006c	b9 14 00 00 00	 mov	 ecx, 20
  00071	f3 aa		 rep stosb

; 1494 :     char recfm;
; 1495 : 
; 1496 :     str_guest_to_host( cms->fn, fn, sizeof( cms->fn ));

  00073	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  0007b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0007f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00085	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR fn$[rsp]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1497 :     str_guest_to_host( cms->ft, ft, sizeof( cms->ft ));

  00096	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  0009e	48 83 c0 48	 add	 rax, 72			; 00000048H
  000a2	41 b8 08 00 00
	00		 mov	 r8d, 8
  000a8	48 8d 54 24 78	 lea	 rdx, QWORD PTR ft$[rsp]
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1498 :     str_guest_to_host( cms->fm, fm, sizeof( cms->fm ));

  000b6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  000be	48 83 c0 50	 add	 rax, 80			; 00000050H
  000c2	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c8	48 8d 54 24 64	 lea	 rdx, QWORD PTR fm$[rsp]
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1499 : 
; 1500 :     recfm = (char) guest_to_host( cms->recfm );

  000d6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  000de	0f b6 48 0a	 movzx	 ecx, BYTE PTR [rax+10]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000e8	88 44 24 60	 mov	 BYTE PTR recfm$[rsp], al

; 1501 : 
; 1502 :     format_cms_datetime( cms, dt, sizeof( dt ));

  000ec	41 b8 14 00 00
	00		 mov	 r8d, 20
  000f2	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR dt$[rsp]
  000fa	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR cms$[rsp]
  00102	e8 00 00 00 00	 call	 format_cms_datetime

; 1503 : 
; 1504 :     recl = fetch_fw( cms->lrecl );

  00107	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  0010f	48 83 c0 0c	 add	 rax, 12
  00113	48 8b c8	 mov	 rcx, rax
  00116	e8 00 00 00 00	 call	 fetch_fw_noswap
  0011b	8b c8		 mov	 ecx, eax
  0011d	e8 00 00 00 00	 call	 _byteswap_ulong
  00122	89 44 24 70	 mov	 DWORD PTR recl$[rsp], eax

; 1505 :     recs = fetch_hw( cms->reccount );

  00126	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  0012e	48 83 c0 06	 add	 rax, 6
  00132	48 8b c8	 mov	 rcx, rax
  00135	e8 00 00 00 00	 call	 fetch_hw_noswap
  0013a	0f b7 c8	 movzx	 ecx, ax
  0013d	e8 00 00 00 00	 call	 _byteswap_ushort
  00142	0f b7 c0	 movzx	 eax, ax
  00145	89 44 24 6c	 mov	 DWORD PTR recs$[rsp], eax

; 1506 :     blks = fetch_hw( cms->dbc );

  00149	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cms$[rsp]
  00151	48 83 c0 10	 add	 rax, 16
  00155	48 8b c8	 mov	 rcx, rax
  00158	e8 00 00 00 00	 call	 fetch_hw_noswap
  0015d	0f b7 c8	 movzx	 ecx, ax
  00160	e8 00 00 00 00	 call	 _byteswap_ushort
  00165	0f b7 c0	 movzx	 eax, ax
  00168	89 44 24 68	 mov	 DWORD PTR blks$[rsp], eax

; 1507 : 
; 1508 :     snprintf( str, strsz, "%-8s %-8s %-2s %c %-5u %s recs %4u blks %u",

  0016c	0f be 44 24 60	 movsx	 eax, BYTE PTR recfm$[rsp]
  00171	8b 4c 24 68	 mov	 ecx, DWORD PTR blks$[rsp]
  00175	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00179	8b 4c 24 6c	 mov	 ecx, DWORD PTR recs$[rsp]
  0017d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00181	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dt$[rsp]
  00189	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0018e	8b 4c 24 70	 mov	 ecx, DWORD PTR recl$[rsp]
  00192	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00196	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0019a	48 8d 44 24 64	 lea	 rax, QWORD PTR fm$[rsp]
  0019f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a4	48 8d 44 24 78	 lea	 rax, QWORD PTR ft$[rsp]
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR fn$[rsp]
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170188
  001bd	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR strsz$[rsp]
  001c5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1509 :         fn , ft, fm, recfm, recl, dt, recs, blks );
; 1510 : 
; 1511 :     return str;

  001d3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]

; 1512 : }

  001db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e3	48 33 cc	 xor	 rcx, rsp
  001e6	e8 00 00 00 00	 call	 __security_check_cookie
  001eb	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  001f2	5f		 pop	 rdi
  001f3	c3		 ret	 0
format_cms_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
recfm$ = 96
blks$ = 100
fm$ = 104
recs$ = 108
recl$ = 112
ft$ = 120
fn$ = 136
dt$ = 152
__$ArrayPad$ = 176
fst$ = 208
str$ = 216
strsz$ = 224
format_fst_info PROC

; 1451 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1452 :     int  recl, recs, blks;
; 1453 : 
; 1454 :     char fn [ sizeof( fst->fn ) + 1 ]  = {0};

  00029	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR fn$[rsp]
  00031	48 8b f8	 mov	 rdi, rax
  00034	33 c0		 xor	 eax, eax
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	f3 aa		 rep stosb

; 1455 :     char ft [ sizeof( fst->ft ) + 1 ]  = {0};

  0003d	48 8d 44 24 78	 lea	 rax, QWORD PTR ft$[rsp]
  00042	48 8b f8	 mov	 rdi, rax
  00045	33 c0		 xor	 eax, eax
  00047	b9 09 00 00 00	 mov	 ecx, 9
  0004c	f3 aa		 rep stosb

; 1456 :     char fm [ sizeof( fst->fm ) + 1 ]  = {0};

  0004e	48 8d 44 24 68	 lea	 rax, QWORD PTR fm$[rsp]
  00053	48 8b f8	 mov	 rdi, rax
  00056	33 c0		 xor	 eax, eax
  00058	b9 03 00 00 00	 mov	 ecx, 3
  0005d	f3 aa		 rep stosb

; 1457 :     char dt [ 19                + 1 ]  = {0};

  0005f	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dt$[rsp]
  00067	48 8b f8	 mov	 rdi, rax
  0006a	33 c0		 xor	 eax, eax
  0006c	b9 14 00 00 00	 mov	 ecx, 20
  00071	f3 aa		 rep stosb

; 1458 :     char recfm;
; 1459 : 
; 1460 :     str_guest_to_host( fst->fn, fn, sizeof( fst->fn ));

  00073	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0007b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00081	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR fn$[rsp]
  00089	48 8b c8	 mov	 rcx, rax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1461 :     str_guest_to_host( fst->ft, ft, sizeof( fst->ft ));

  00092	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0009a	48 83 c0 08	 add	 rax, 8
  0009e	41 b8 08 00 00
	00		 mov	 r8d, 8
  000a4	48 8d 54 24 78	 lea	 rdx, QWORD PTR ft$[rsp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1462 :     str_guest_to_host( fst->fm, fm, sizeof( fst->fm ));

  000b2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  000ba	48 83 c0 18	 add	 rax, 24
  000be	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c4	48 8d 54 24 68	 lea	 rdx, QWORD PTR fm$[rsp]
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1463 : 
; 1464 :     recfm = (char) guest_to_host( fst->recfm );

  000d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  000da	0f b6 48 1e	 movzx	 ecx, BYTE PTR [rax+30]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  000e4	88 44 24 60	 mov	 BYTE PTR recfm$[rsp], al

; 1465 : 
; 1466 :     format_fst_datetime( fst, dt, sizeof( dt ));

  000e8	41 b8 14 00 00
	00		 mov	 r8d, 20
  000ee	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR dt$[rsp]
  000f6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fst$[rsp]
  000fe	e8 00 00 00 00	 call	 format_fst_datetime

; 1467 : 
; 1468 :     recl = fetch_fw( fst->lrecl );

  00103	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0010b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 fetch_fw_noswap
  00117	8b c8		 mov	 ecx, eax
  00119	e8 00 00 00 00	 call	 _byteswap_ulong
  0011e	89 44 24 70	 mov	 DWORD PTR recl$[rsp], eax

; 1469 : 
; 1470 :     if (!(recs = fetch_fw( fst->aic )))

  00122	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0012a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0012e	48 8b c8	 mov	 rcx, rax
  00131	e8 00 00 00 00	 call	 fetch_fw_noswap
  00136	8b c8		 mov	 ecx, eax
  00138	e8 00 00 00 00	 call	 _byteswap_ulong
  0013d	89 44 24 6c	 mov	 DWORD PTR recs$[rsp], eax
  00141	83 7c 24 6c 00	 cmp	 DWORD PTR recs$[rsp], 0
  00146	75 23		 jne	 SHORT $LN2@format_fst

; 1471 :         recs = fetch_hw( fst->reccount );

  00148	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00150	48 83 c0 1a	 add	 rax, 26
  00154	48 8b c8	 mov	 rcx, rax
  00157	e8 00 00 00 00	 call	 fetch_hw_noswap
  0015c	0f b7 c8	 movzx	 ecx, ax
  0015f	e8 00 00 00 00	 call	 _byteswap_ushort
  00164	0f b7 c0	 movzx	 eax, ax
  00167	89 44 24 6c	 mov	 DWORD PTR recs$[rsp], eax
$LN2@format_fst:

; 1472 : 
; 1473 :     blks  = fetch_fw( fst->numblk );

  0016b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00173	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00177	48 8b c8	 mov	 rcx, rax
  0017a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0017f	8b c8		 mov	 ecx, eax
  00181	e8 00 00 00 00	 call	 _byteswap_ulong
  00186	89 44 24 64	 mov	 DWORD PTR blks$[rsp], eax

; 1474 :     blks *= (PLC2_BLOCKSIZE / CMS_BLOCKSIZE);

  0018a	6b 44 24 64 05	 imul	 eax, DWORD PTR blks$[rsp], 5
  0018f	89 44 24 64	 mov	 DWORD PTR blks$[rsp], eax

; 1475 :     blks += fetch_fw( fst->lastsz );

  00193	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0019b	48 83 c0 28	 add	 rax, 40			; 00000028H
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	e8 00 00 00 00	 call	 fetch_fw_noswap
  001a7	8b c8		 mov	 ecx, eax
  001a9	e8 00 00 00 00	 call	 _byteswap_ulong
  001ae	8b 4c 24 64	 mov	 ecx, DWORD PTR blks$[rsp]
  001b2	03 c8		 add	 ecx, eax
  001b4	8b c1		 mov	 eax, ecx
  001b6	89 44 24 64	 mov	 DWORD PTR blks$[rsp], eax

; 1476 : 
; 1477 :     snprintf( str, strsz, "%-8s %-8s %-2s %c %-5u %s recs %4u blks %u",

  001ba	0f be 44 24 60	 movsx	 eax, BYTE PTR recfm$[rsp]
  001bf	8b 4c 24 64	 mov	 ecx, DWORD PTR blks$[rsp]
  001c3	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001c7	8b 4c 24 6c	 mov	 ecx, DWORD PTR recs$[rsp]
  001cb	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001cf	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dt$[rsp]
  001d7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001dc	8b 4c 24 70	 mov	 ecx, DWORD PTR recl$[rsp]
  001e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001e8	48 8d 44 24 68	 lea	 rax, QWORD PTR fm$[rsp]
  001ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f2	48 8d 44 24 78	 lea	 rax, QWORD PTR ft$[rsp]
  001f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fc	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR fn$[rsp]
  00204	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170170
  0020b	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR strsz$[rsp]
  00213	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1478 :         fn , ft, fm, recfm, recl, dt, recs, blks );
; 1479 : 
; 1480 :     return str;

  00221	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]

; 1481 : }

  00229	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00231	48 33 cc	 xor	 rcx, rsp
  00234	e8 00 00 00 00	 call	 __security_check_cookie
  00239	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00240	5f		 pop	 rdi
  00241	c3		 ret	 0
format_fst_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
mi$ = 64
hh$ = 68
yy$ = 72
dd$ = 76
mo$ = 80
cms$ = 112
str$ = 120
strsz$ = 128
format_cms_datetime PROC

; 1426 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1427 :     char  yy [4]  = {0};    // "YY" year

  00014	48 8d 44 24 48	 lea	 rax, QWORD PTR yy$[rsp]
  00019	48 8b f8	 mov	 rdi, rax
  0001c	33 c0		 xor	 eax, eax
  0001e	b9 04 00 00 00	 mov	 ecx, 4
  00023	f3 aa		 rep stosb

; 1428 :     char  mo [4]  = {0};    // "MM" month

  00025	48 8d 44 24 50	 lea	 rax, QWORD PTR mo$[rsp]
  0002a	48 8b f8	 mov	 rdi, rax
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 04 00 00 00	 mov	 ecx, 4
  00034	f3 aa		 rep stosb

; 1429 :     char  dd [4]  = {0};    // "DD" day

  00036	48 8d 44 24 4c	 lea	 rax, QWORD PTR dd$[rsp]
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	33 c0		 xor	 eax, eax
  00040	b9 04 00 00 00	 mov	 ecx, 4
  00045	f3 aa		 rep stosb

; 1430 :     char  hh [4]  = {0};    // "HH" hour

  00047	48 8d 44 24 44	 lea	 rax, QWORD PTR hh$[rsp]
  0004c	48 8b f8	 mov	 rdi, rax
  0004f	33 c0		 xor	 eax, eax
  00051	b9 04 00 00 00	 mov	 ecx, 4
  00056	f3 aa		 rep stosb

; 1431 :     char  mi [4]  = {0};    // "MM" minute

  00058	48 8d 44 24 40	 lea	 rax, QWORD PTR mi$[rsp]
  0005d	48 8b f8	 mov	 rdi, rax
  00060	33 c0		 xor	 eax, eax
  00062	b9 04 00 00 00	 mov	 ecx, 4
  00067	f3 aa		 rep stosb

; 1432 : 
; 1433 :     str_guest_to_host( cms->year, yy, sizeof( cms->year ));

  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR cms$[rsp]
  0006e	48 83 c0 12	 add	 rax, 18
  00072	41 b8 02 00 00
	00		 mov	 r8d, 2
  00078	48 8d 54 24 48	 lea	 rdx, QWORD PTR yy$[rsp]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1434 : 
; 1435 :     dcb_to_str( cms->dt + 0, 1, mo, sizeof( mo ));

  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR cms$[rsp]
  0008b	48 83 c0 14	 add	 rax, 20
  0008f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00095	4c 8d 44 24 50	 lea	 r8, QWORD PTR mo$[rsp]
  0009a	ba 01 00 00 00	 mov	 edx, 1
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 dcb_to_str

; 1436 :     dcb_to_str( cms->dt + 1, 1, dd, sizeof( dd ));

  000a7	48 8b 44 24 70	 mov	 rax, QWORD PTR cms$[rsp]
  000ac	48 83 c0 15	 add	 rax, 21
  000b0	41 b9 04 00 00
	00		 mov	 r9d, 4
  000b6	4c 8d 44 24 4c	 lea	 r8, QWORD PTR dd$[rsp]
  000bb	ba 01 00 00 00	 mov	 edx, 1
  000c0	48 8b c8	 mov	 rcx, rax
  000c3	e8 00 00 00 00	 call	 dcb_to_str

; 1437 :     dcb_to_str( cms->dt + 2, 1, hh, sizeof( hh ));

  000c8	48 8b 44 24 70	 mov	 rax, QWORD PTR cms$[rsp]
  000cd	48 83 c0 16	 add	 rax, 22
  000d1	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d7	4c 8d 44 24 44	 lea	 r8, QWORD PTR hh$[rsp]
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 dcb_to_str

; 1438 :     dcb_to_str( cms->dt + 3, 1, mi, sizeof( mi ));

  000e9	48 8b 44 24 70	 mov	 rax, QWORD PTR cms$[rsp]
  000ee	48 83 c0 17	 add	 rax, 23
  000f2	41 b9 04 00 00
	00		 mov	 r9d, 4
  000f8	4c 8d 44 24 40	 lea	 r8, QWORD PTR mi$[rsp]
  000fd	ba 01 00 00 00	 mov	 edx, 1
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 dcb_to_str

; 1439 : 
; 1440 :     // "MM/DD/YY HH:MM"     // 14 chars + null = 15 bytes
; 1441 : 
; 1442 :     snprintf( str, strsz, "%s/%s/%s %s:%s",

  0010a	48 8d 44 24 40	 lea	 rax, QWORD PTR mi$[rsp]
  0010f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00114	48 8d 44 24 44	 lea	 rax, QWORD PTR hh$[rsp]
  00119	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0011e	48 8d 44 24 48	 lea	 rax, QWORD PTR yy$[rsp]
  00123	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00128	48 8d 44 24 4c	 lea	 rax, QWORD PTR dd$[rsp]
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	4c 8d 4c 24 50	 lea	 r9, QWORD PTR mo$[rsp]
  00137	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170151
  0013e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strsz$[rsp]
  00146	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1443 :                            mo, dd, yy, hh, mi );
; 1444 :     return str;

  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR str$[rsp]

; 1445 : }

  00156	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
format_cms_datetime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
ss$ = 80
mi$ = 84
hh$ = 88
dd$ = 92
mo$ = 96
yy$ = 100
cc$ = 104
tv130 = 112
fst$ = 144
str$ = 152
strsz$ = 160
format_fst_datetime PROC

; 1382 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1383 :     char  cc [4]  = {0};    // "YY" century

  00017	48 8d 44 24 68	 lea	 rax, QWORD PTR cc$[rsp]
  0001c	48 8b f8	 mov	 rdi, rax
  0001f	33 c0		 xor	 eax, eax
  00021	b9 04 00 00 00	 mov	 ecx, 4
  00026	f3 aa		 rep stosb

; 1384 :     char  yy [4]  = {0};    // "YY" year

  00028	48 8d 44 24 64	 lea	 rax, QWORD PTR yy$[rsp]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	33 c0		 xor	 eax, eax
  00032	b9 04 00 00 00	 mov	 ecx, 4
  00037	f3 aa		 rep stosb

; 1385 :     char  mo [4]  = {0};    // "MM" month

  00039	48 8d 44 24 60	 lea	 rax, QWORD PTR mo$[rsp]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	33 c0		 xor	 eax, eax
  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	f3 aa		 rep stosb

; 1386 :     char  dd [4]  = {0};    // "DD" day

  0004a	48 8d 44 24 5c	 lea	 rax, QWORD PTR dd$[rsp]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 04 00 00 00	 mov	 ecx, 4
  00059	f3 aa		 rep stosb

; 1387 :     char  hh [4]  = {0};    // "HH" hour

  0005b	48 8d 44 24 58	 lea	 rax, QWORD PTR hh$[rsp]
  00060	48 8b f8	 mov	 rdi, rax
  00063	33 c0		 xor	 eax, eax
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	f3 aa		 rep stosb

; 1388 :     char  mi [4]  = {0};    // "MM" minute

  0006c	48 8d 44 24 54	 lea	 rax, QWORD PTR mi$[rsp]
  00071	48 8b f8	 mov	 rdi, rax
  00074	33 c0		 xor	 eax, eax
  00076	b9 04 00 00 00	 mov	 ecx, 4
  0007b	f3 aa		 rep stosb

; 1389 :     char  ss [4]  = {0};    // "SS" second

  0007d	48 8d 44 24 50	 lea	 rax, QWORD PTR ss$[rsp]
  00082	48 8b f8	 mov	 rdi, rax
  00085	33 c0		 xor	 eax, eax
  00087	b9 04 00 00 00	 mov	 ecx, 4
  0008c	f3 aa		 rep stosb

; 1390 : 
; 1391 :     STRLCPY( cc, (fst->flag1 & FSTCNTRY) ? "20" : "19" );

  0008e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00096	0f b6 40 1f	 movzx	 eax, BYTE PTR [rax+31]
  0009a	83 e0 08	 and	 eax, 8
  0009d	85 c0		 test	 eax, eax
  0009f	74 0e		 je	 SHORT $LN5@format_fst
  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170132
  000a8	48 89 44 24 70	 mov	 QWORD PTR tv130[rsp], rax
  000ad	eb 0c		 jmp	 SHORT $LN6@format_fst
$LN5@format_fst:
  000af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170133
  000b6	48 89 44 24 70	 mov	 QWORD PTR tv130[rsp], rax
$LN6@format_fst:
  000bb	41 b8 04 00 00
	00		 mov	 r8d, 4
  000c1	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv130[rsp]
  000c6	48 8d 4c 24 68	 lea	 rcx, QWORD PTR cc$[rsp]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1392 : 
; 1393 :     /* Use Alt Date (YYMMDDHHMMSS) if it's available (non-zero) */
; 1394 : 
; 1395 :     if (memcmp( fst->adt, empty_adt, sizeof( fst->adt )) != 0)

  000d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  000d9	48 83 c0 3e	 add	 rax, 62			; 0000003eH
  000dd	41 b8 06 00 00
	00		 mov	 r8d, 6
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:empty_adt
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 memcmp
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 dd 00 00
	00		 je	 $LN2@format_fst

; 1396 :     {
; 1397 :         dcb_to_str( fst->adt + 0, 1, yy, sizeof( yy ));

  000fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00102	48 83 c0 3e	 add	 rax, 62			; 0000003eH
  00106	41 b9 04 00 00
	00		 mov	 r9d, 4
  0010c	4c 8d 44 24 64	 lea	 r8, QWORD PTR yy$[rsp]
  00111	ba 01 00 00 00	 mov	 edx, 1
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 dcb_to_str

; 1398 :         dcb_to_str( fst->adt + 1, 1, mo, sizeof( mo ));

  0011e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00126	48 83 c0 3f	 add	 rax, 63			; 0000003fH
  0012a	41 b9 04 00 00
	00		 mov	 r9d, 4
  00130	4c 8d 44 24 60	 lea	 r8, QWORD PTR mo$[rsp]
  00135	ba 01 00 00 00	 mov	 edx, 1
  0013a	48 8b c8	 mov	 rcx, rax
  0013d	e8 00 00 00 00	 call	 dcb_to_str

; 1399 :         dcb_to_str( fst->adt + 2, 1, dd, sizeof( dd ));

  00142	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0014a	48 83 c0 40	 add	 rax, 64			; 00000040H
  0014e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00154	4c 8d 44 24 5c	 lea	 r8, QWORD PTR dd$[rsp]
  00159	ba 01 00 00 00	 mov	 edx, 1
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 dcb_to_str

; 1400 :         dcb_to_str( fst->adt + 3, 1, hh, sizeof( hh ));

  00166	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0016e	48 83 c0 41	 add	 rax, 65			; 00000041H
  00172	41 b9 04 00 00
	00		 mov	 r9d, 4
  00178	4c 8d 44 24 58	 lea	 r8, QWORD PTR hh$[rsp]
  0017d	ba 01 00 00 00	 mov	 edx, 1
  00182	48 8b c8	 mov	 rcx, rax
  00185	e8 00 00 00 00	 call	 dcb_to_str

; 1401 :         dcb_to_str( fst->adt + 4, 1, mi, sizeof( mi ));

  0018a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00192	48 83 c0 42	 add	 rax, 66			; 00000042H
  00196	41 b9 04 00 00
	00		 mov	 r9d, 4
  0019c	4c 8d 44 24 54	 lea	 r8, QWORD PTR mi$[rsp]
  001a1	ba 01 00 00 00	 mov	 edx, 1
  001a6	48 8b c8	 mov	 rcx, rax
  001a9	e8 00 00 00 00	 call	 dcb_to_str

; 1402 :         dcb_to_str( fst->adt + 5, 1, ss, sizeof( ss ));

  001ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  001b6	48 83 c0 43	 add	 rax, 67			; 00000043H
  001ba	41 b9 04 00 00
	00		 mov	 r9d, 4
  001c0	4c 8d 44 24 50	 lea	 r8, QWORD PTR ss$[rsp]
  001c5	ba 01 00 00 00	 mov	 edx, 1
  001ca	48 8b c8	 mov	 rcx, rax
  001cd	e8 00 00 00 00	 call	 dcb_to_str

; 1403 :     }

  001d2	e9 c8 00 00 00	 jmp	 $LN3@format_fst
$LN2@format_fst:

; 1404 :     else /* (use shorter default (MMDDhhmm) date) */
; 1405 :     {
; 1406 :         str_guest_to_host( fst->year, yy, sizeof( fst->year ));

  001d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  001df	48 83 c0 26	 add	 rax, 38			; 00000026H
  001e3	41 b8 02 00 00
	00		 mov	 r8d, 2
  001e9	48 8d 54 24 64	 lea	 rdx, QWORD PTR yy$[rsp]
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 1407 : 
; 1408 :         dcb_to_str( fst->dt + 0, 1, mo, sizeof( mo ));

  001f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  001ff	48 83 c0 10	 add	 rax, 16
  00203	41 b9 04 00 00
	00		 mov	 r9d, 4
  00209	4c 8d 44 24 60	 lea	 r8, QWORD PTR mo$[rsp]
  0020e	ba 01 00 00 00	 mov	 edx, 1
  00213	48 8b c8	 mov	 rcx, rax
  00216	e8 00 00 00 00	 call	 dcb_to_str

; 1409 :         dcb_to_str( fst->dt + 1, 1, dd, sizeof( dd ));

  0021b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00223	48 83 c0 11	 add	 rax, 17
  00227	41 b9 04 00 00
	00		 mov	 r9d, 4
  0022d	4c 8d 44 24 5c	 lea	 r8, QWORD PTR dd$[rsp]
  00232	ba 01 00 00 00	 mov	 edx, 1
  00237	48 8b c8	 mov	 rcx, rax
  0023a	e8 00 00 00 00	 call	 dcb_to_str

; 1410 :         dcb_to_str( fst->dt + 2, 1, hh, sizeof( hh ));

  0023f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  00247	48 83 c0 12	 add	 rax, 18
  0024b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00251	4c 8d 44 24 58	 lea	 r8, QWORD PTR hh$[rsp]
  00256	ba 01 00 00 00	 mov	 edx, 1
  0025b	48 8b c8	 mov	 rcx, rax
  0025e	e8 00 00 00 00	 call	 dcb_to_str

; 1411 :         dcb_to_str( fst->dt + 3, 1, mi, sizeof( mi ));

  00263	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fst$[rsp]
  0026b	48 83 c0 13	 add	 rax, 19
  0026f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00275	4c 8d 44 24 54	 lea	 r8, QWORD PTR mi$[rsp]
  0027a	ba 01 00 00 00	 mov	 edx, 1
  0027f	48 8b c8	 mov	 rcx, rax
  00282	e8 00 00 00 00	 call	 dcb_to_str

; 1412 :         STRLCPY( ss, "00" );

  00287	41 b8 04 00 00
	00		 mov	 r8d, 4
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170136
  00294	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ss$[rsp]
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN3@format_fst:

; 1413 :     }
; 1414 : 
; 1415 :     // "YYYY-MM-DD HH:MM:SS"    // 19 chars + null = 20 bytes
; 1416 : 
; 1417 :     snprintf( str, strsz, "%2.2s%2.2s-%2.2s-%2.2s %2.2s:%2.2s:%2.2s",

  0029f	48 8d 44 24 50	 lea	 rax, QWORD PTR ss$[rsp]
  002a4	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002a9	48 8d 44 24 54	 lea	 rax, QWORD PTR mi$[rsp]
  002ae	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002b3	48 8d 44 24 58	 lea	 rax, QWORD PTR hh$[rsp]
  002b8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002bd	48 8d 44 24 5c	 lea	 rax, QWORD PTR dd$[rsp]
  002c2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002c7	48 8d 44 24 60	 lea	 rax, QWORD PTR mo$[rsp]
  002cc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002d1	48 8d 44 24 64	 lea	 rax, QWORD PTR yy$[rsp]
  002d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002db	4c 8d 4c 24 68	 lea	 r9, QWORD PTR cc$[rsp]
  002e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170137
  002e7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR strsz$[rsp]
  002ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  002f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1418 :                            cc, yy, mo, dd, hh, mi, ss );
; 1419 :     return str;

  002fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]

; 1420 : }

  00305	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0030c	5f		 pop	 rdi
  0030d	c3		 ret	 0
format_fst_datetime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
bfr$ = 32
cmsb$ = 40
ttm$ = 48
fn$ = 96
ft$ = 104
fm$ = 112
recfm$ = 120
lrecl$ = 128
reccount$ = 136
filesz$ = 144
dt$ = 152
blk_count$ = 160
build_cms_block PROC

; 1334 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@build_cms_:

; 1335 :     CMS_BLOCK*   cmsb;
; 1336 :     struct  tm*  ttm;
; 1337 :     char         bfr[3];
; 1338 : 
; 1339 :     UNREFERENCED( filesz );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@build_cms_

; 1340 : 
; 1341 :     if (!(cmsb = malloc( sizeof( CMS_BLOCK ))))

  00020	b9 25 03 00 00	 mov	 ecx, 805		; 00000325H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0002b	48 89 44 24 28	 mov	 QWORD PTR cmsb$[rsp], rax
  00030	48 83 7c 24 28
	00		 cmp	 QWORD PTR cmsb$[rsp], 0
  00036	75 07		 jne	 SHORT $LN5@build_cms_

; 1342 :         return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 61 02 00 00	 jmp	 $LN1@build_cms_
$LN5@build_cms_:

; 1343 : 
; 1344 :     memset( cmsb, 0, sizeof( CMS_BLOCK ));

  0003f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cmsb$[rsp]
  00044	33 c0		 xor	 eax, eax
  00046	b9 25 03 00 00	 mov	 ecx, 805		; 00000325H
  0004b	f3 aa		 rep stosb

; 1345 :     memcpy( cmsb->hdr, CMSN_hdr, BLK_HDRSIZE );

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CMSN_hdr
  00054	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cmsb$[rsp]
  00059	48 8b f0	 mov	 rsi, rax
  0005c	b9 05 00 00 00	 mov	 ecx, 5
  00061	f3 a4		 rep movsb

; 1346 : 
; 1347 :     memset( cmsb->cms.fn, 0x40, sizeof( cmsb->cms.fn ));

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  00068	48 83 c0 45	 add	 rax, 69			; 00000045H
  0006c	48 8b f8	 mov	 rdi, rax
  0006f	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00074	b9 08 00 00 00	 mov	 ecx, 8
  00079	f3 aa		 rep stosb

; 1348 :     memset( cmsb->cms.ft, 0x40, sizeof( cmsb->cms.ft ) );

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  00080	48 83 c0 4d	 add	 rax, 77			; 0000004dH
  00084	48 8b f8	 mov	 rdi, rax
  00087	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0008c	b9 08 00 00 00	 mov	 ecx, 8
  00091	f3 aa		 rep stosb

; 1349 :     memset( cmsb->cms.fm, 0x40, sizeof( cmsb->cms.fm ) );

  00093	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  00098	48 83 c0 55	 add	 rax, 85			; 00000055H
  0009c	48 8b f8	 mov	 rdi, rax
  0009f	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000a4	b9 02 00 00 00	 mov	 ecx, 2
  000a9	f3 aa		 rep stosb

; 1350 : 
; 1351 :     str_host_to_guest( fn, cmsb->cms.fn, sizeof( cmsb->cms.fn ));

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  000b0	48 83 c0 45	 add	 rax, 69			; 00000045H
  000b4	41 b8 08 00 00
	00		 mov	 r8d, 8
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fn$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1352 :     str_host_to_guest( ft, cmsb->cms.ft, sizeof( cmsb->cms.ft ));

  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  000cd	48 83 c0 4d	 add	 rax, 77			; 0000004dH
  000d1	41 b8 08 00 00
	00		 mov	 r8d, 8
  000d7	48 8b d0	 mov	 rdx, rax
  000da	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ft$[rsp]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1353 :     str_host_to_guest( fm, cmsb->cms.fm, sizeof( cmsb->cms.fm ));

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  000ea	48 83 c0 55	 add	 rax, 85			; 00000055H
  000ee	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fm$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1354 : 
; 1355 :     memcpy( cmsb->cms.mode, cmsb->cms.fm, sizeof( HWORD ));

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  00107	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  0010c	0f b7 49 55	 movzx	 ecx, WORD PTR [rcx+85]
  00110	66 89 48 09	 mov	 WORD PTR [rax+9], cx

; 1356 : 
; 1357 :     ttm = localtime( &dt );

  00114	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dt$[rsp]
  0011c	e8 00 00 00 00	 call	 localtime
  00121	48 89 44 24 30	 mov	 QWORD PTR ttm$[rsp], rax

; 1358 : 
; 1359 :     cmsb->cms.dt[0] = to_dcb( ttm->tm_mon  + 1 ); // Months since January! (0..11)

  00126	48 8b 44 24 30	 mov	 rax, QWORD PTR ttm$[rsp]
  0012b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0012e	ff c0		 inc	 eax
  00130	0f b6 c8	 movzx	 ecx, al
  00133	e8 00 00 00 00	 call	 to_dcb
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	48 6b c9 00	 imul	 rcx, rcx, 0
  00141	48 8b 54 24 28	 mov	 rdx, QWORD PTR cmsb$[rsp]
  00146	88 44 0a 19	 mov	 BYTE PTR [rdx+rcx+25], al

; 1360 :     cmsb->cms.dt[1] = to_dcb( ttm->tm_mday + 0 );

  0014a	48 8b 44 24 30	 mov	 rax, QWORD PTR ttm$[rsp]
  0014f	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  00153	e8 00 00 00 00	 call	 to_dcb
  00158	b9 01 00 00 00	 mov	 ecx, 1
  0015d	48 6b c9 01	 imul	 rcx, rcx, 1
  00161	48 8b 54 24 28	 mov	 rdx, QWORD PTR cmsb$[rsp]
  00166	88 44 0a 19	 mov	 BYTE PTR [rdx+rcx+25], al

; 1361 :     cmsb->cms.dt[2] = to_dcb( ttm->tm_hour + 0 );

  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR ttm$[rsp]
  0016f	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  00173	e8 00 00 00 00	 call	 to_dcb
  00178	b9 01 00 00 00	 mov	 ecx, 1
  0017d	48 6b c9 02	 imul	 rcx, rcx, 2
  00181	48 8b 54 24 28	 mov	 rdx, QWORD PTR cmsb$[rsp]
  00186	88 44 0a 19	 mov	 BYTE PTR [rdx+rcx+25], al

; 1362 :     cmsb->cms.dt[3] = to_dcb( ttm->tm_min  + 0 );

  0018a	48 8b 44 24 30	 mov	 rax, QWORD PTR ttm$[rsp]
  0018f	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00193	e8 00 00 00 00	 call	 to_dcb
  00198	b9 01 00 00 00	 mov	 ecx, 1
  0019d	48 6b c9 03	 imul	 rcx, rcx, 3
  001a1	48 8b 54 24 28	 mov	 rdx, QWORD PTR cmsb$[rsp]
  001a6	88 44 0a 19	 mov	 BYTE PTR [rdx+rcx+25], al

; 1363 : 
; 1364 :     MSGBUF( bfr, "%2.2u", ttm->tm_year % 100 );

  001aa	48 8b 44 24 30	 mov	 rax, QWORD PTR ttm$[rsp]
  001af	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001b2	99		 cdq
  001b3	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b8	f7 f9		 idiv	 ecx
  001ba	8b c2		 mov	 eax, edx
  001bc	44 8b c8	 mov	 r9d, eax
  001bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170116
  001c6	ba 03 00 00 00	 mov	 edx, 3
  001cb	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bfr$[rsp]
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1365 :     str_host_to_guest( bfr, cmsb->cms.year, sizeof( cmsb->cms.year ));

  001d6	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
  001db	48 83 c0 17	 add	 rax, 23
  001df	41 b8 02 00 00
	00		 mov	 r8d, 2
  001e5	48 8b d0	 mov	 rdx, rax
  001e8	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bfr$[rsp]
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1366 : 
; 1367 :     cmsb->cms.recfm = host_to_guest( recfm );

  001f3	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR recfm$[rsp]
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  001fe	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  00203	88 41 0f	 mov	 BYTE PTR [rcx+15], al

; 1368 : 
; 1369 :     store_fw( cmsb->cms.lrecl,    (U32) lrecl        );

  00206	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR lrecl$[rsp]
  0020d	e8 00 00 00 00	 call	 _byteswap_ulong
  00212	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  00217	48 83 c1 11	 add	 rcx, 17
  0021b	8b d0		 mov	 edx, eax
  0021d	e8 00 00 00 00	 call	 store_fw_noswap

; 1370 :     store_hw( cmsb->cms.reccount, (U16) reccount     );

  00222	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR reccount$[rsp]
  0022a	e8 00 00 00 00	 call	 _byteswap_ushort
  0022f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  00234	48 83 c1 0b	 add	 rcx, 11
  00238	0f b7 d0	 movzx	 edx, ax
  0023b	e8 00 00 00 00	 call	 store_hw_noswap

; 1371 :     store_hw( cmsb->cms.wp,       (U16) reccount + 1 );

  00240	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR reccount$[rsp]
  00248	ff c0		 inc	 eax
  0024a	0f b7 c8	 movzx	 ecx, ax
  0024d	e8 00 00 00 00	 call	 _byteswap_ushort
  00252	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  00257	48 83 c1 05	 add	 rcx, 5
  0025b	0f b7 d0	 movzx	 edx, ax
  0025e	e8 00 00 00 00	 call	 store_hw_noswap

; 1372 :     store_hw( cmsb->cms.rp,       (U16)     1        );

  00263	66 b9 01 00	 mov	 cx, 1
  00267	e8 00 00 00 00	 call	 _byteswap_ushort
  0026c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  00271	48 83 c1 07	 add	 rcx, 7
  00275	0f b7 d0	 movzx	 edx, ax
  00278	e8 00 00 00 00	 call	 store_hw_noswap

; 1373 :     store_hw( cmsb->cms.dbc,      (U16) blk_count    );

  0027d	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR blk_count$[rsp]
  00285	e8 00 00 00 00	 call	 _byteswap_ushort
  0028a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cmsb$[rsp]
  0028f	48 83 c1 15	 add	 rcx, 21
  00293	0f b7 d0	 movzx	 edx, ax
  00296	e8 00 00 00 00	 call	 store_hw_noswap

; 1374 : 
; 1375 :     return  cmsb;

  0029b	48 8b 44 24 28	 mov	 rax, QWORD PTR cmsb$[rsp]
$LN1@build_cms_:

; 1376 : }

  002a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002a4	5f		 pop	 rdi
  002a5	5e		 pop	 rsi
  002a6	c3		 ret	 0
build_cms_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
bfr$ = 32
lastsz$ = 36
tv270 = 40
numfull$ = 44
fstb$ = 48
ttm$ = 56
fn$ = 96
ft$ = 104
fm$ = 112
recfm$ = 120
lrecl$ = 128
reccount$ = 136
filesz$ = 144
dt$ = 152
blk_count$ = 160
build_fst_block PROC

; 1248 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1249 :     FST_BLOCK*   fstb;
; 1250 :     struct  tm*  ttm;
; 1251 :     int          numfull;
; 1252 :     int          lastsz;
; 1253 :     char         bfr[3];
; 1254 : 
; 1255 :     if (!(fstb = malloc( sizeof( FST_BLOCK ))))

  0001a	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00025	48 89 44 24 30	 mov	 QWORD PTR fstb$[rsp], rax
  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR fstb$[rsp], 0
  00030	75 07		 jne	 SHORT $LN2@build_fst_

; 1256 :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 0d 04 00 00	 jmp	 $LN1@build_fst_
$LN2@build_fst_:

; 1257 : 
; 1258 :     memset( fstb, 0, sizeof( FST_BLOCK ));

  00039	48 8b 7c 24 30	 mov	 rdi, QWORD PTR fstb$[rsp]
  0003e	33 c0		 xor	 eax, eax
  00040	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00045	f3 aa		 rep stosb

; 1259 :     memcpy( fstb->hdr, PLCH_hdr, BLK_HDRSIZE );

  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PLCH_hdr
  0004e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR fstb$[rsp]
  00053	48 8b f0	 mov	 rsi, rax
  00056	b9 05 00 00 00	 mov	 ecx, 5
  0005b	f3 a4		 rep movsb

; 1260 : 
; 1261 :     memset( fstb->fst.fn, 0x40, sizeof( fstb->fst.fn ));

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  00062	48 83 c0 05	 add	 rax, 5
  00066	48 8b f8	 mov	 rdi, rax
  00069	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0006e	b9 08 00 00 00	 mov	 ecx, 8
  00073	f3 aa		 rep stosb

; 1262 :     memset( fstb->fst.ft, 0x40, sizeof( fstb->fst.ft ) );

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  0007a	48 83 c0 0d	 add	 rax, 13
  0007e	48 8b f8	 mov	 rdi, rax
  00081	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00086	b9 08 00 00 00	 mov	 ecx, 8
  0008b	f3 aa		 rep stosb

; 1263 :     memset( fstb->fst.fm, 0x40, sizeof( fstb->fst.fm ) );

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  00092	48 83 c0 1d	 add	 rax, 29
  00096	48 8b f8	 mov	 rdi, rax
  00099	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0009e	b9 02 00 00 00	 mov	 ecx, 2
  000a3	f3 aa		 rep stosb

; 1264 : 
; 1265 :     str_host_to_guest( fn, fstb->fst.fn, sizeof( fstb->fst.fn ));

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  000aa	48 83 c0 05	 add	 rax, 5
  000ae	41 b8 08 00 00
	00		 mov	 r8d, 8
  000b4	48 8b d0	 mov	 rdx, rax
  000b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fn$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1266 :     str_host_to_guest( ft, fstb->fst.ft, sizeof( fstb->fst.ft ));

  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  000c7	48 83 c0 0d	 add	 rax, 13
  000cb	41 b8 08 00 00
	00		 mov	 r8d, 8
  000d1	48 8b d0	 mov	 rdx, rax
  000d4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ft$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1267 :     str_host_to_guest( fm, fstb->fst.fm, sizeof( fstb->fst.fm ));

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  000e4	48 83 c0 1d	 add	 rax, 29
  000e8	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fm$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1268 : 
; 1269 :     ttm = localtime( &dt );

  000fc	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR dt$[rsp]
  00104	e8 00 00 00 00	 call	 localtime
  00109	48 89 44 24 38	 mov	 QWORD PTR ttm$[rsp], rax

; 1270 : 
; 1271 :     fstb->fst.dt[0] = to_dcb( ttm->tm_mon  + 1 ); // Months since January! (0..11)

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00113	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00116	ff c0		 inc	 eax
  00118	0f b6 c8	 movzx	 ecx, al
  0011b	e8 00 00 00 00	 call	 to_dcb
  00120	b9 01 00 00 00	 mov	 ecx, 1
  00125	48 6b c9 00	 imul	 rcx, rcx, 0
  00129	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  0012e	88 44 0a 15	 mov	 BYTE PTR [rdx+rcx+21], al

; 1272 :     fstb->fst.dt[1] = to_dcb( ttm->tm_mday + 0 );

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00137	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  0013b	e8 00 00 00 00	 call	 to_dcb
  00140	b9 01 00 00 00	 mov	 ecx, 1
  00145	48 6b c9 01	 imul	 rcx, rcx, 1
  00149	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  0014e	88 44 0a 15	 mov	 BYTE PTR [rdx+rcx+21], al

; 1273 :     fstb->fst.dt[2] = to_dcb( ttm->tm_hour + 0 );

  00152	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00157	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  0015b	e8 00 00 00 00	 call	 to_dcb
  00160	b9 01 00 00 00	 mov	 ecx, 1
  00165	48 6b c9 02	 imul	 rcx, rcx, 2
  00169	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  0016e	88 44 0a 15	 mov	 BYTE PTR [rdx+rcx+21], al

; 1274 :     fstb->fst.dt[3] = to_dcb( ttm->tm_min  + 0 );

  00172	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00177	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  0017b	e8 00 00 00 00	 call	 to_dcb
  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	48 6b c9 03	 imul	 rcx, rcx, 3
  00189	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  0018e	88 44 0a 15	 mov	 BYTE PTR [rdx+rcx+21], al

; 1275 : 
; 1276 :     MSGBUF( bfr, "%2.2u", ttm->tm_year % 100 );

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00197	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0019a	99		 cdq
  0019b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001a0	f7 f9		 idiv	 ecx
  001a2	8b c2		 mov	 eax, edx
  001a4	44 8b c8	 mov	 r9d, eax
  001a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170069
  001ae	ba 03 00 00 00	 mov	 edx, 3
  001b3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bfr$[rsp]
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1277 :     str_host_to_guest( bfr, fstb->fst.year, sizeof( fstb->fst.year ));

  001be	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  001c3	48 83 c0 2b	 add	 rax, 43			; 0000002bH
  001c7	41 b8 02 00 00
	00		 mov	 r8d, 2
  001cd	48 8b d0	 mov	 rdx, rax
  001d0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR bfr$[rsp]
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 1278 : 
; 1279 :     fstb->fst.adt[0] = to_dcb( ttm->tm_year % 100 );

  001db	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  001e0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001e3	99		 cdq
  001e4	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001e9	f7 f9		 idiv	 ecx
  001eb	8b c2		 mov	 eax, edx
  001ed	0f b6 c8	 movzx	 ecx, al
  001f0	e8 00 00 00 00	 call	 to_dcb
  001f5	b9 01 00 00 00	 mov	 ecx, 1
  001fa	48 6b c9 00	 imul	 rcx, rcx, 0
  001fe	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  00203	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1280 :     fstb->fst.adt[1] = to_dcb( ttm->tm_mon  + 1 ); // Months since January! (0..11)

  00207	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  0020c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0020f	ff c0		 inc	 eax
  00211	0f b6 c8	 movzx	 ecx, al
  00214	e8 00 00 00 00	 call	 to_dcb
  00219	b9 01 00 00 00	 mov	 ecx, 1
  0021e	48 6b c9 01	 imul	 rcx, rcx, 1
  00222	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  00227	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1281 :     fstb->fst.adt[2] = to_dcb( ttm->tm_mday + 0 );

  0022b	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00230	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  00234	e8 00 00 00 00	 call	 to_dcb
  00239	b9 01 00 00 00	 mov	 ecx, 1
  0023e	48 6b c9 02	 imul	 rcx, rcx, 2
  00242	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  00247	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1282 :     fstb->fst.adt[3] = to_dcb( ttm->tm_hour + 0 );

  0024b	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00250	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  00254	e8 00 00 00 00	 call	 to_dcb
  00259	b9 01 00 00 00	 mov	 ecx, 1
  0025e	48 6b c9 03	 imul	 rcx, rcx, 3
  00262	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  00267	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1283 :     fstb->fst.adt[4] = to_dcb( ttm->tm_min  + 0 );

  0026b	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00270	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00274	e8 00 00 00 00	 call	 to_dcb
  00279	b9 01 00 00 00	 mov	 ecx, 1
  0027e	48 6b c9 04	 imul	 rcx, rcx, 4
  00282	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  00287	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1284 :     fstb->fst.adt[5] = to_dcb( ttm->tm_sec  + 0 );

  0028b	48 8b 44 24 38	 mov	 rax, QWORD PTR ttm$[rsp]
  00290	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00293	e8 00 00 00 00	 call	 to_dcb
  00298	b9 01 00 00 00	 mov	 ecx, 1
  0029d	48 6b c9 05	 imul	 rcx, rcx, 5
  002a1	48 8b 54 24 30	 mov	 rdx, QWORD PTR fstb$[rsp]
  002a6	88 44 0a 43	 mov	 BYTE PTR [rdx+rcx+67], al

; 1285 : 
; 1286 :     fstb->fst.recfm = host_to_guest( recfm );

  002aa	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR recfm$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  002b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  002ba	88 41 23	 mov	 BYTE PTR [rcx+35], al

; 1287 : 
; 1288 :     fstb->fst.flag1 = FSTCNTRY;   // current year is >= 2000!

  002bd	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
  002c2	c6 40 24 08	 mov	 BYTE PTR [rax+36], 8

; 1289 : 
; 1290 :     store_fw( fstb->fst.lrecl,    (U32) lrecl        );

  002c6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR lrecl$[rsp]
  002cd	e8 00 00 00 00	 call	 _byteswap_ulong
  002d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  002d7	48 83 c1 25	 add	 rcx, 37			; 00000025H
  002db	8b d0		 mov	 edx, eax
  002dd	e8 00 00 00 00	 call	 store_fw_noswap

; 1291 :     store_fw( fstb->fst.aic,      (U32) reccount     );

  002e2	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR reccount$[rsp]
  002e9	e8 00 00 00 00	 call	 _byteswap_ulong
  002ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  002f3	48 83 c1 3d	 add	 rcx, 61			; 0000003dH
  002f7	8b d0		 mov	 edx, eax
  002f9	e8 00 00 00 00	 call	 store_fw_noswap

; 1292 : 
; 1293 :     store_hw( fstb->fst.reccount, (U16) reccount     );

  002fe	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR reccount$[rsp]
  00306	e8 00 00 00 00	 call	 _byteswap_ushort
  0030b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  00310	48 83 c1 1f	 add	 rcx, 31
  00314	0f b7 d0	 movzx	 edx, ax
  00317	e8 00 00 00 00	 call	 store_hw_noswap

; 1294 :     store_hw( fstb->fst.wp,       (U16) reccount + 1 );

  0031c	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR reccount$[rsp]
  00324	ff c0		 inc	 eax
  00326	0f b7 c8	 movzx	 ecx, ax
  00329	e8 00 00 00 00	 call	 _byteswap_ushort
  0032e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  00333	48 83 c1 19	 add	 rcx, 25
  00337	0f b7 d0	 movzx	 edx, ax
  0033a	e8 00 00 00 00	 call	 store_hw_noswap

; 1295 :     store_hw( fstb->fst.rp,       (U16)     1        );

  0033f	66 b9 01 00	 mov	 cx, 1
  00343	e8 00 00 00 00	 call	 _byteswap_ushort
  00348	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  0034d	48 83 c1 1b	 add	 rcx, 27
  00351	0f b7 d0	 movzx	 edx, ax
  00354	e8 00 00 00 00	 call	 store_hw_noswap

; 1296 :     store_hw( fstb->fst.dbc,      (U16) blk_count    );

  00359	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR blk_count$[rsp]
  00361	e8 00 00 00 00	 call	 _byteswap_ushort
  00366	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  0036b	48 83 c1 29	 add	 rcx, 41			; 00000029H
  0036f	0f b7 d0	 movzx	 edx, ax
  00372	e8 00 00 00 00	 call	 store_hw_noswap

; 1297 : 
; 1298 :     if (recfm == 'V')

  00377	0f be 44 24 78	 movsx	 eax, BYTE PTR recfm$[rsp]
  0037c	83 f8 56	 cmp	 eax, 86			; 00000056H
  0037f	75 1b		 jne	 SHORT $LN3@build_fst_

; 1299 :         filesz += (reccount * sizeof( HWORD ));

  00381	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR reccount$[rsp]
  00389	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR filesz$[rsp]
  00391	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00395	89 84 24 90 00
	00 00		 mov	 DWORD PTR filesz$[rsp], eax
$LN3@build_fst_:

; 1300 : 
; 1301 :     numfull = filesz / PLC2_BLOCKSIZE;

  0039c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR filesz$[rsp]
  003a3	99		 cdq
  003a4	b9 a0 0f 00 00	 mov	 ecx, 4000		; 00000fa0H
  003a9	f7 f9		 idiv	 ecx
  003ab	89 44 24 2c	 mov	 DWORD PTR numfull$[rsp], eax

; 1302 :     lastsz  = filesz % PLC2_BLOCKSIZE;

  003af	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR filesz$[rsp]
  003b6	99		 cdq
  003b7	b9 a0 0f 00 00	 mov	 ecx, 4000		; 00000fa0H
  003bc	f7 f9		 idiv	 ecx
  003be	8b c2		 mov	 eax, edx
  003c0	89 44 24 24	 mov	 DWORD PTR lastsz$[rsp], eax

; 1303 :     if (lastsz)

  003c4	83 7c 24 24 00	 cmp	 DWORD PTR lastsz$[rsp], 0
  003c9	74 34		 je	 SHORT $LN4@build_fst_

; 1304 :         lastsz = ROUND_UP( lastsz, CMS_BLOCKSIZE );

  003cb	83 7c 24 24 00	 cmp	 DWORD PTR lastsz$[rsp], 0
  003d0	74 1d		 je	 SHORT $LN6@build_fst_
  003d2	8b 44 24 24	 mov	 eax, DWORD PTR lastsz$[rsp]
  003d6	05 1f 03 00 00	 add	 eax, 799		; 0000031fH
  003db	99		 cdq
  003dc	b9 20 03 00 00	 mov	 ecx, 800		; 00000320H
  003e1	f7 f9		 idiv	 ecx
  003e3	69 c0 20 03 00
	00		 imul	 eax, eax, 800		; 00000320H
  003e9	89 44 24 28	 mov	 DWORD PTR tv270[rsp], eax
  003ed	eb 08		 jmp	 SHORT $LN7@build_fst_
$LN6@build_fst_:
  003ef	c7 44 24 28 20
	03 00 00	 mov	 DWORD PTR tv270[rsp], 800 ; 00000320H
$LN7@build_fst_:
  003f7	8b 44 24 28	 mov	 eax, DWORD PTR tv270[rsp]
  003fb	89 44 24 24	 mov	 DWORD PTR lastsz$[rsp], eax
$LN4@build_fst_:

; 1305 :     lastsz /= CMS_BLOCKSIZE;

  003ff	8b 44 24 24	 mov	 eax, DWORD PTR lastsz$[rsp]
  00403	99		 cdq
  00404	b9 20 03 00 00	 mov	 ecx, 800		; 00000320H
  00409	f7 f9		 idiv	 ecx
  0040b	89 44 24 24	 mov	 DWORD PTR lastsz$[rsp], eax

; 1306 : 
; 1307 :     store_fw( fstb->fst.numblk, (U32) numfull );

  0040f	8b 4c 24 2c	 mov	 ecx, DWORD PTR numfull$[rsp]
  00413	e8 00 00 00 00	 call	 _byteswap_ulong
  00418	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  0041d	48 83 c1 31	 add	 rcx, 49			; 00000031H
  00421	8b d0		 mov	 edx, eax
  00423	e8 00 00 00 00	 call	 store_fw_noswap

; 1308 :     store_fw( fstb->fst.lastsz, (U32) lastsz  );

  00428	8b 4c 24 24	 mov	 ecx, DWORD PTR lastsz$[rsp]
  0042c	e8 00 00 00 00	 call	 _byteswap_ulong
  00431	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fstb$[rsp]
  00436	48 83 c1 2d	 add	 rcx, 45			; 0000002dH
  0043a	8b d0		 mov	 edx, eax
  0043c	e8 00 00 00 00	 call	 store_fw_noswap

; 1309 : 
; 1310 :     return  fstb;

  00441	48 8b 44 24 30	 mov	 rax, QWORD PTR fstb$[rsp]
$LN1@build_fst_:

; 1311 : }

  00446	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0044a	5f		 pop	 rdi
  0044b	5e		 pop	 rsi
  0044c	c3		 ret	 0
build_fst_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
buf$ = 32
i$ = 40
dcb$ = 64
dcbsz$ = 72
str$ = 80
strsz$ = 88
dcb_to_str PROC

; 1209 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1210 :     size_t i;
; 1211 :     char buf[4] = {0};

  00019	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  0001e	48 8b f8	 mov	 rdi, rax
  00021	33 c0		 xor	 eax, eax
  00023	b9 04 00 00 00	 mov	 ecx, 4
  00028	f3 aa		 rep stosb
$LN4@dcb_to_str:

; 1212 : 
; 1213 :     /* (valid arguments check) */
; 1214 :     ASSERT( dcb && dcbsz && str && strsz > (2 * dcbsz));

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR dcb$[rsp], 0
  00030	74 1f		 je	 SHORT $LN12@dcb_to_str
  00032	48 83 7c 24 48
	00		 cmp	 QWORD PTR dcbsz$[rsp], 0
  00038	74 17		 je	 SHORT $LN12@dcb_to_str
  0003a	48 83 7c 24 50
	00		 cmp	 QWORD PTR str$[rsp], 0
  00040	74 0f		 je	 SHORT $LN12@dcb_to_str
  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR dcbsz$[rsp]
  00047	48 d1 e0	 shl	 rax, 1
  0004a	48 39 44 24 58	 cmp	 QWORD PTR strsz$[rsp], rax
  0004f	77 5c		 ja	 SHORT $LN11@dcb_to_str
$LN12@dcb_to_str:
$LN7@dcb_to_str:
  00051	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170016
  00058	41 b8 be 04 00
	00		 mov	 r8d, 1214		; 000004beH
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170017
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170018
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00078	85 c0		 test	 eax, eax
  0007a	74 20		 je	 SHORT $LN13@dcb_to_str
  0007c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170020
  00083	41 b8 be 04 00
	00		 mov	 r8d, 1214		; 000004beH
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170021
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170022
  00097	e8 00 00 00 00	 call	 DebuggerTrace
$LN13@dcb_to_str:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 af		 jne	 SHORT $LN7@dcb_to_str
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a8	85 c0		 test	 eax, eax
  000aa	74 01		 je	 SHORT $LN14@dcb_to_str
  000ac	cc		 int	 3
$LN14@dcb_to_str:
$LN11@dcb_to_str:
  000ad	33 c0		 xor	 eax, eax
  000af	85 c0		 test	 eax, eax
  000b1	0f 85 73 ff ff
	ff		 jne	 $LN4@dcb_to_str

; 1215 : 
; 1216 :     if (!str || !dcbsz || !str || !strsz)

  000b7	48 83 7c 24 50
	00		 cmp	 QWORD PTR str$[rsp], 0
  000bd	74 18		 je	 SHORT $LN16@dcb_to_str
  000bf	48 83 7c 24 48
	00		 cmp	 QWORD PTR dcbsz$[rsp], 0
  000c5	74 10		 je	 SHORT $LN16@dcb_to_str
  000c7	48 83 7c 24 50
	00		 cmp	 QWORD PTR str$[rsp], 0
  000cd	74 08		 je	 SHORT $LN16@dcb_to_str
  000cf	48 83 7c 24 58
	00		 cmp	 QWORD PTR strsz$[rsp], 0
  000d5	75 04		 jne	 SHORT $LN15@dcb_to_str
$LN16@dcb_to_str:

; 1217 :         return NULL;

  000d7	33 c0		 xor	 eax, eax
  000d9	eb 7d		 jmp	 SHORT $LN1@dcb_to_str
$LN15@dcb_to_str:

; 1218 : 
; 1219 :     *str = 0;

  000db	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  000e0	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1220 : 
; 1221 :     for (i=0; i < dcbsz; i++)

  000e3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000ec	eb 0d		 jmp	 SHORT $LN10@dcb_to_str
$LN8@dcb_to_str:
  000ee	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f3	48 ff c0	 inc	 rax
  000f6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN10@dcb_to_str:
  000fb	48 8b 44 24 48	 mov	 rax, QWORD PTR dcbsz$[rsp]
  00100	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00105	73 4c		 jae	 SHORT $LN9@dcb_to_str

; 1222 :     {
; 1223 :         MSGBUF( buf, "%02u", from_dcb( dcb[i] ));

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0010c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dcb$[rsp]
  00111	48 03 c8	 add	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0011a	e8 00 00 00 00	 call	 from_dcb
  0011f	0f b6 c0	 movzx	 eax, al
  00122	44 8b c8	 mov	 r9d, eax
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170026
  0012c	ba 04 00 00 00	 mov	 edx, 4
  00131	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1224 :         strlcat( str, buf, strsz );

  0013c	4c 8b 44 24 58	 mov	 r8, QWORD PTR strsz$[rsp]
  00141	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00146	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 1225 :     }

  00151	eb 9b		 jmp	 SHORT $LN8@dcb_to_str
$LN9@dcb_to_str:

; 1226 : 
; 1227 :     return str;

  00153	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
$LN1@dcb_to_str:

; 1228 : }

  00158	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
dcb_to_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
v$ = 8
from_dcb PROC

; 1201 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 1202 :     return ((v >> 4) * 10) + (v & 0x0F);    // 0x28 (28) ==> 0x1C

  00004	0f b6 44 24 08	 movzx	 eax, BYTE PTR v$[rsp]
  00009	c1 f8 04	 sar	 eax, 4
  0000c	6b c0 0a	 imul	 eax, eax, 10
  0000f	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR v$[rsp]
  00014	83 e1 0f	 and	 ecx, 15
  00017	03 c1		 add	 eax, ecx

; 1203 : }

  00019	c3		 ret	 0
from_dcb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
tv66 = 0
v$ = 32
to_dcb	PROC

; 1193 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 1194 :     return ((v/10) * 16) + (v % 10);        // 0x1C (28) ==> 0x28

  00008	0f b6 44 24 20	 movzx	 eax, BYTE PTR v$[rsp]
  0000d	99		 cdq
  0000e	b9 0a 00 00 00	 mov	 ecx, 10
  00013	f7 f9		 idiv	 ecx
  00015	6b c0 10	 imul	 eax, eax, 16
  00018	89 04 24	 mov	 DWORD PTR tv66[rsp], eax
  0001b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR v$[rsp]
  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	b9 0a 00 00 00	 mov	 ecx, 10
  00028	f7 f9		 idiv	 ecx
  0002a	8b c2		 mov	 eax, edx
  0002c	8b 0c 24	 mov	 ecx, DWORD PTR tv66[rsp]
  0002f	03 c8		 add	 ecx, eax
  00031	8b c1		 mov	 eax, ecx

; 1195 : }

  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
to_dcb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
tv65 = 64
blks$ = 72
opts$ = 96
infile$ = 104
filefmt$ = 112
recfm$ = 120
recl$ = 128
recc$ = 136
filesz$ = 144
dump_file PROC

; 1088 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1089 :     TAPE_BLOCKS* blks;
; 1090 : 
; 1091 :     switch (filefmt)

  00018	0f b6 44 24 70	 movzx	 eax, BYTE PTR filefmt$[rsp]
  0001d	88 44 24 40	 mov	 BYTE PTR tv65[rsp], al
  00021	80 7c 24 40 42	 cmp	 BYTE PTR tv65[rsp], 66	; 00000042H
  00026	74 17		 je	 SHORT $LN4@dump_file
  00028	80 7c 24 40 53	 cmp	 BYTE PTR tv65[rsp], 83	; 00000053H
  0002d	0f 84 8e 00 00
	00		 je	 $LN6@dump_file
  00033	80 7c 24 40 54	 cmp	 BYTE PTR tv65[rsp], 84	; 00000054H
  00038	74 46		 je	 SHORT $LN5@dump_file
  0003a	e9 c0 00 00 00	 jmp	 $LN7@dump_file
$LN4@dump_file:

; 1092 :     {
; 1093 :         case 'B': blks = dump_binary_file     ( opts, infile, recfm, recl, recc, filesz ); break;

  0003f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR filesz$[rsp]
  00047	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR recc$[rsp]
  00054	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00059	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR recl$[rsp]
  00061	44 0f b6 44 24
	78		 movzx	 r8d, BYTE PTR recfm$[rsp]
  00067	48 8b 54 24 68	 mov	 rdx, QWORD PTR infile$[rsp]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opts$[rsp]
  00071	e8 00 00 00 00	 call	 dump_binary_file
  00076	48 89 44 24 48	 mov	 QWORD PTR blks$[rsp], rax
  0007b	e9 d6 00 00 00	 jmp	 $LN2@dump_file
$LN5@dump_file:

; 1094 :         case 'T': blks = dump_text_file       ( opts, infile, recfm, recl, recc, filesz ); break;

  00080	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR filesz$[rsp]
  00088	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR recc$[rsp]
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR recl$[rsp]
  000a2	44 0f b6 44 24
	78		 movzx	 r8d, BYTE PTR recfm$[rsp]
  000a8	48 8b 54 24 68	 mov	 rdx, QWORD PTR infile$[rsp]
  000ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opts$[rsp]
  000b2	e8 00 00 00 00	 call	 dump_text_file
  000b7	48 89 44 24 48	 mov	 QWORD PTR blks$[rsp], rax
  000bc	e9 95 00 00 00	 jmp	 $LN2@dump_file
$LN6@dump_file:

; 1095 :         case 'S': blks = dump_structured_file ( opts, infile, recfm, recl, recc, filesz ); break;

  000c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR filesz$[rsp]
  000c9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ce	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR recc$[rsp]
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR recl$[rsp]
  000e3	44 0f b6 44 24
	78		 movzx	 r8d, BYTE PTR recfm$[rsp]
  000e9	48 8b 54 24 68	 mov	 rdx, QWORD PTR infile$[rsp]
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opts$[rsp]
  000f3	e8 00 00 00 00	 call	 dump_structured_file
  000f8	48 89 44 24 48	 mov	 QWORD PTR blks$[rsp], rax
  000fd	eb 57		 jmp	 SHORT $LN2@dump_file
$LN7@dump_file:

; 1096 :         default:
; 1097 :             // "INTERNAL ERROR %s"
; 1098 :             FWRMSG( stderr, HHC02634, "E", "0001" );

  000ff	b9 02 00 00 00	 mov	 ecx, 2
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169925
  00111	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169926
  0011d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169927
  00129	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	41 b9 03 00 00
	00		 mov	 r9d, 3
  00139	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169928
  00140	ba 4a 04 00 00	 mov	 edx, 1098		; 0000044aH
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169929
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1099 :             return NULL;

  00152	33 c0		 xor	 eax, eax
  00154	eb 05		 jmp	 SHORT $LN1@dump_file
$LN2@dump_file:

; 1100 :     }
; 1101 : 
; 1102 :     return blks;

  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR blks$[rsp]
$LN1@dump_file:

; 1103 : }

  0015b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015f	c3		 ret	 0
dump_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rsz$ = 80
ifile$ = 88
rlbfr$ = 96
num$ = 104
recs$ = 112
tv67 = 120
hdr$ = 128
tv79 = 136
tv146 = 144
tv211 = 152
blks$ = 160
opts$ = 192
infile$ = 200
recfm$ = 208
recl$ = 216
recc$ = 224
filesz$ = 232
dump_structured_file PROC

; 1012 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1013 :     TAPE_BLOCKS*  blks;
; 1014 :     FILE*         ifile;
; 1015 :     RECS*         recs;
; 1016 :     const BYTE*   hdr;
; 1017 :     size_t        num;
; 1018 :     int           rsz;
; 1019 :     uint16_t      rlbfr;
; 1020 : 
; 1021 :     /* Allocate and initialize a new RECS collection for this file */
; 1022 :     hdr = opts->cms ? CMS__hdr : PLCD_hdr;

  0001b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00023	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00027	85 c0		 test	 eax, eax
  00029	74 0e		 je	 SHORT $LN42@dump_struc
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CMS__hdr
  00032	48 89 44 24 78	 mov	 QWORD PTR tv67[rsp], rax
  00037	eb 0c		 jmp	 SHORT $LN43@dump_struc
$LN42@dump_struc:
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PLCD_hdr
  00040	48 89 44 24 78	 mov	 QWORD PTR tv67[rsp], rax
$LN43@dump_struc:
  00045	48 8b 44 24 78	 mov	 rax, QWORD PTR tv67[rsp]
  0004a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hdr$[rsp], rax

; 1023 :     if (!(recs = initrecs( opts, recfm, *recl, hdr, BLK_HDRSIZE )))

  00052	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR [rsp+32], 5
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00062	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  0006a	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0006d	0f b6 94 24 d0
	00 00 00	 movzx	 edx, BYTE PTR recfm$[rsp]
  00075	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0007d	e8 00 00 00 00	 call	 initrecs
  00082	48 89 44 24 70	 mov	 QWORD PTR recs$[rsp], rax
  00087	48 83 7c 24 70
	00		 cmp	 QWORD PTR recs$[rsp], 0
  0008d	75 07		 jne	 SHORT $LN22@dump_struc

; 1024 :         return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 c1 04 00 00	 jmp	 $LN1@dump_struc
$LN22@dump_struc:

; 1025 : 
; 1026 :     /* Open this file for reading */
; 1027 :     if (!(ifile = fopen( infile, "rb" )))

  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169845
  0009d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  000ab	48 89 44 24 58	 mov	 QWORD PTR ifile$[rsp], rax
  000b0	48 83 7c 24 58
	00		 cmp	 QWORD PTR ifile$[rsp], 0
  000b6	75 7e		 jne	 SHORT $LN23@dump_struc

; 1028 :     {
; 1029 :         // "File open error: \"%s\": %s"
; 1030 :         FWRMSG( stderr, HHC02623, "E", infile, strerror( errno ));

  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000be	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000ce	b9 02 00 00 00	 mov	 ecx, 2
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  000e1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169846
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169847
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169848
  0011d	ba 06 04 00 00	 mov	 edx, 1030		; 00000406H
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169849
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1031 :         return NULL;

  0012f	33 c0		 xor	 eax, eax
  00131	e9 21 04 00 00	 jmp	 $LN1@dump_struc
$LN23@dump_struc:
$LN2@dump_struc:

; 1032 :     }
; 1033 : 
; 1034 :     /* Read the structured record's length */
; 1035 :     while ((num = fread( &rlbfr, 1, sizeof( rlbfr ), ifile )) == sizeof( rlbfr ))

  00136	4c 8b 4c 24 58	 mov	 r9, QWORD PTR ifile$[rsp]
  0013b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00141	ba 01 00 00 00	 mov	 edx, 1
  00146	48 8d 4c 24 60	 lea	 rcx, QWORD PTR rlbfr$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00151	48 89 44 24 68	 mov	 QWORD PTR num$[rsp], rax
  00156	48 83 7c 24 68
	02		 cmp	 QWORD PTR num$[rsp], 2
  0015c	0f 85 d5 01 00
	00		 jne	 $LN3@dump_struc

; 1036 :     {
; 1037 :         rsz = fetch_hw( &rlbfr );

  00162	48 8d 4c 24 60	 lea	 rcx, QWORD PTR rlbfr$[rsp]
  00167	e8 00 00 00 00	 call	 fetch_hw_noswap
  0016c	0f b7 c8	 movzx	 ecx, ax
  0016f	e8 00 00 00 00	 call	 _byteswap_ushort
  00174	0f b7 c0	 movzx	 eax, ax
  00177	89 44 24 50	 mov	 DWORD PTR rsz$[rsp], eax

; 1038 : 
; 1039 :         /* Now that we know how big the record is,
; 1040 :            read the actual structure record itself. */
; 1041 :         if ((int)(num = fread( bfr, 1, rsz, ifile )) != rsz)

  0017b	48 63 44 24 50	 movsxd	 rax, DWORD PTR rsz$[rsp]
  00180	4c 8b 4c 24 58	 mov	 r9, QWORD PTR ifile$[rsp]
  00185	4c 8b c0	 mov	 r8, rax
  00188	ba 01 00 00 00	 mov	 edx, 1
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0019a	48 89 44 24 68	 mov	 QWORD PTR num$[rsp], rax
  0019f	8b 44 24 50	 mov	 eax, DWORD PTR rsz$[rsp]
  001a3	39 44 24 68	 cmp	 DWORD PTR num$[rsp], eax
  001a7	0f 84 64 01 00
	00		 je	 $LN24@dump_struc

; 1042 :         {
; 1043 :             if (ferror( ifile ))

  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  001b8	85 c0		 test	 eax, eax
  001ba	74 79		 je	 SHORT $LN25@dump_struc

; 1044 :                 // "I/O error on file \"%s\": %s"
; 1045 :                 FWRMSG( stderr, HHC02627, "E", infile, strerror( errno ));

  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001c2	8b 08		 mov	 ecx, DWORD PTR [rax]
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001ca	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv146[rsp], rax
  001d2	b9 02 00 00 00	 mov	 ecx, 2
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv146[rsp]
  001e5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  001f2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169853
  001fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169854
  0020a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00214	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169855
  00221	ba 15 04 00 00	 mov	 edx, 1045		; 00000415H
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169856
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00233	eb 64		 jmp	 SHORT $LN26@dump_struc
$LN25@dump_struc:

; 1046 :             else
; 1047 :                 // "Expected %d bytes from file \"%s\", but only %d bytes read"
; 1048 :                 FWRMSG( stderr, HHC02629, "E", rsz, infile, (int) num );

  00235	b9 02 00 00 00	 mov	 ecx, 2
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00240	8b 4c 24 68	 mov	 ecx, DWORD PTR num$[rsp]
  00244	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00248	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  00250	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00255	8b 4c 24 50	 mov	 ecx, DWORD PTR rsz$[rsp]
  00259	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169857
  00264	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169858
  00270	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00280	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169859
  00287	ba 18 04 00 00	 mov	 edx, 1048		; 00000418H
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169860
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN26@dump_struc:
$LN6@dump_struc:

; 1049 : 
; 1050 :             VERIFY( fclose( ifile ) == 0 );

  00299	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  002a4	85 c0		 test	 eax, eax
  002a6	74 5c		 je	 SHORT $LN27@dump_struc
$LN9@dump_struc:
  002a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169862
  002af	41 b8 1a 04 00
	00		 mov	 r8d, 1050		; 0000041aH
  002b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169863
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169864
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002cf	85 c0		 test	 eax, eax
  002d1	74 20		 je	 SHORT $LN28@dump_struc
  002d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169866
  002da	41 b8 1a 04 00
	00		 mov	 r8d, 1050		; 0000041aH
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169867
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169868
  002ee	e8 00 00 00 00	 call	 DebuggerTrace
$LN28@dump_struc:
  002f3	33 c0		 xor	 eax, eax
  002f5	85 c0		 test	 eax, eax
  002f7	75 af		 jne	 SHORT $LN9@dump_struc
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002ff	85 c0		 test	 eax, eax
  00301	74 01		 je	 SHORT $LN29@dump_struc
  00303	cc		 int	 3
$LN29@dump_struc:
$LN27@dump_struc:
  00304	33 c0		 xor	 eax, eax
  00306	85 c0		 test	 eax, eax
  00308	75 8f		 jne	 SHORT $LN6@dump_struc

; 1051 :             return NULL;

  0030a	33 c0		 xor	 eax, eax
  0030c	e9 46 02 00 00	 jmp	 $LN1@dump_struc
$LN24@dump_struc:

; 1052 :         }
; 1053 : 
; 1054 :         /* Add this record to this file's RECS collection */
; 1055 :         if (addrecs( recs, bfr, rsz ) != 0)

  00311	44 8b 44 24 50	 mov	 r8d, DWORD PTR rsz$[rsp]
  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:bfr
  0031d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recs$[rsp]
  00322	e8 00 00 00 00	 call	 addrecs
  00327	85 c0		 test	 eax, eax
  00329	74 07		 je	 SHORT $LN30@dump_struc

; 1056 :             return NULL;

  0032b	33 c0		 xor	 eax, eax
  0032d	e9 25 02 00 00	 jmp	 $LN1@dump_struc
$LN30@dump_struc:

; 1057 :     }

  00332	e9 ff fd ff ff	 jmp	 $LN2@dump_struc
$LN3@dump_struc:

; 1058 : 
; 1059 :     /* Short read or I/O error? */
; 1060 :     if (num || ferror( ifile ))

  00337	48 83 7c 24 68
	00		 cmp	 QWORD PTR num$[rsp], 0
  0033d	75 13		 jne	 SHORT $LN32@dump_struc
  0033f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  00344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 5d 01 00
	00		 je	 $LN31@dump_struc
$LN32@dump_struc:

; 1061 :     {
; 1062 :         if (num)

  00352	48 83 7c 24 68
	00		 cmp	 QWORD PTR num$[rsp], 0
  00358	74 66		 je	 SHORT $LN33@dump_struc

; 1063 :             // "Expected %d bytes from file \"%s\", but only %d bytes read"
; 1064 :             FWRMSG( stderr, HHC02629, "E", (int) sizeof( rlbfr ), infile, (int) num );

  0035a	b9 02 00 00 00	 mov	 ecx, 2
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00365	8b 4c 24 68	 mov	 ecx, DWORD PTR num$[rsp]
  00369	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0036d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  00375	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0037a	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR [rsp+56], 2
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169875
  00389	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169876
  00395	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0039a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039f	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169877
  003ac	ba 28 04 00 00	 mov	 edx, 1064		; 00000428H
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169878
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  003be	eb 77		 jmp	 SHORT $LN34@dump_struc
$LN33@dump_struc:

; 1065 :         else
; 1066 :             // "I/O error on file \"%s\": %s"
; 1067 :             FWRMSG( stderr, HHC02627, "E", infile, strerror( errno ));

  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003c6	8b 08		 mov	 ecx, DWORD PTR [rax]
  003c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003ce	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  003d6	b9 02 00 00 00	 mov	 ecx, 2
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  003e9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003ee	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  003f6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169879
  00402	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169880
  0040e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00413	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00418	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169881
  00425	ba 2b 04 00 00	 mov	 edx, 1067		; 0000042bH
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169882
  00431	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@dump_struc:
$LN12@dump_struc:

; 1068 : 
; 1069 :         VERIFY( fclose( ifile ) == 0 );

  00437	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  00442	85 c0		 test	 eax, eax
  00444	74 5c		 je	 SHORT $LN35@dump_struc
$LN15@dump_struc:
  00446	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169884
  0044d	41 b8 2d 04 00
	00		 mov	 r8d, 1069		; 0000042dH
  00453	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169885
  0045a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169886
  00461	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0046d	85 c0		 test	 eax, eax
  0046f	74 20		 je	 SHORT $LN36@dump_struc
  00471	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169888
  00478	41 b8 2d 04 00
	00		 mov	 r8d, 1069		; 0000042dH
  0047e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169889
  00485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169890
  0048c	e8 00 00 00 00	 call	 DebuggerTrace
$LN36@dump_struc:
  00491	33 c0		 xor	 eax, eax
  00493	85 c0		 test	 eax, eax
  00495	75 af		 jne	 SHORT $LN15@dump_struc
  00497	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0049d	85 c0		 test	 eax, eax
  0049f	74 01		 je	 SHORT $LN37@dump_struc
  004a1	cc		 int	 3
$LN37@dump_struc:
$LN35@dump_struc:
  004a2	33 c0		 xor	 eax, eax
  004a4	85 c0		 test	 eax, eax
  004a6	75 8f		 jne	 SHORT $LN12@dump_struc

; 1070 :         return NULL;

  004a8	33 c0		 xor	 eax, eax
  004aa	e9 a8 00 00 00	 jmp	 $LN1@dump_struc
$LN31@dump_struc:
$LN18@dump_struc:

; 1071 :     }
; 1072 : 
; 1073 :     /* Close the file */
; 1074 :     VERIFY( fclose( ifile ) == 0 );

  004af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  004b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  004ba	85 c0		 test	 eax, eax
  004bc	74 5c		 je	 SHORT $LN38@dump_struc
$LN21@dump_struc:
  004be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169893
  004c5	41 b8 32 04 00
	00		 mov	 r8d, 1074		; 00000432H
  004cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169894
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004e5	85 c0		 test	 eax, eax
  004e7	74 20		 je	 SHORT $LN39@dump_struc
  004e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169897
  004f0	41 b8 32 04 00
	00		 mov	 r8d, 1074		; 00000432H
  004f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169898
  004fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169899
  00504	e8 00 00 00 00	 call	 DebuggerTrace
$LN39@dump_struc:
  00509	33 c0		 xor	 eax, eax
  0050b	85 c0		 test	 eax, eax
  0050d	75 af		 jne	 SHORT $LN21@dump_struc
  0050f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00515	85 c0		 test	 eax, eax
  00517	74 01		 je	 SHORT $LN40@dump_struc
  00519	cc		 int	 3
$LN40@dump_struc:
$LN38@dump_struc:
  0051a	33 c0		 xor	 eax, eax
  0051c	85 c0		 test	 eax, eax
  0051e	75 8f		 jne	 SHORT $LN18@dump_struc

; 1075 : 
; 1076 :     /* Create a TAPE_BLOCKS collection and discard RECS collection */
; 1077 :     blks = flushrecs( recs, recl, recc, filesz, 0x40 );

  00520	c6 44 24 20 40	 mov	 BYTE PTR [rsp+32], 64	; 00000040H
  00525	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR filesz$[rsp]
  0052d	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR recc$[rsp]
  00535	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR recl$[rsp]
  0053d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recs$[rsp]
  00542	e8 00 00 00 00	 call	 flushrecs
  00547	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR blks$[rsp], rax

; 1078 : 
; 1079 :     return blks;

  0054f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR blks$[rsp]
$LN1@dump_struc:

; 1080 : }

  00557	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0055e	c3		 ret	 0
dump_structured_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rsz$ = 80
truncated$ = 84
maxrsz$ = 88
rec$ = 96
tv158 = 104
ifile$ = 112
recs$ = 120
tv67 = 128
hdr$ = 136
tv79 = 144
tv150 = 152
tv179 = 160
blks$ = 168
opts$ = 192
infile$ = 200
recfm$ = 208
recl$ = 216
recc$ = 224
filesz$ = 232
dump_text_file PROC

; 920  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 921  :     TAPE_BLOCKS*  blks;
; 922  :     FILE*         ifile;
; 923  :     RECS*         recs;
; 924  :     const BYTE*   hdr;
; 925  :     char*         rec;
; 926  :     int           rsz, maxrsz = 0;

  0001c	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR maxrsz$[rsp], 0

; 927  :     bool          truncated = false;

  00024	c6 44 24 54 00	 mov	 BYTE PTR truncated$[rsp], 0

; 928  : 
; 929  :     /* Allocate and initialize a new RECS collection for this file */
; 930  :     hdr = opts->cms ? CMS__hdr : PLCD_hdr;

  00029	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00031	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00035	85 c0		 test	 eax, eax
  00037	74 11		 je	 SHORT $LN35@dump_text_
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CMS__hdr
  00040	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv67[rsp], rax
  00048	eb 0f		 jmp	 SHORT $LN36@dump_text_
$LN35@dump_text_:
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PLCD_hdr
  00051	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv67[rsp], rax
$LN36@dump_text_:
  00059	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv67[rsp]
  00061	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR hdr$[rsp], rax

; 931  :     if (!(recs = initrecs( opts, recfm, *recl, hdr, BLK_HDRSIZE )))

  00069	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR [rsp+32], 5
  00071	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00079	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00081	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00084	0f b6 94 24 d0
	00 00 00	 movzx	 edx, BYTE PTR recfm$[rsp]
  0008c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00094	e8 00 00 00 00	 call	 initrecs
  00099	48 89 44 24 78	 mov	 QWORD PTR recs$[rsp], rax
  0009e	48 83 7c 24 78
	00		 cmp	 QWORD PTR recs$[rsp], 0
  000a4	75 07		 jne	 SHORT $LN16@dump_text_

; 932  :         return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 43 04 00 00	 jmp	 $LN1@dump_text_
$LN16@dump_text_:

; 933  : 
; 934  :     /* Open this file for reading */
; 935  :     if (!(ifile = fopen( infile, "r" )))

  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169752
  000b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  000c2	48 89 44 24 70	 mov	 QWORD PTR ifile$[rsp], rax
  000c7	48 83 7c 24 70
	00		 cmp	 QWORD PTR ifile$[rsp], 0
  000cd	75 7e		 jne	 SHORT $LN17@dump_text_

; 936  :     {
; 937  :         // "File open error: \"%s\": %s"
; 938  :         FWRMSG( stderr, HHC02623, "E", infile, strerror( errno ));

  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000dd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000e5	b9 02 00 00 00	 mov	 ecx, 2
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  000f8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000fd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  00105	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169753
  00111	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  0011d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169755
  00134	ba aa 03 00 00	 mov	 edx, 938		; 000003aaH
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169756
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 939  :         return NULL;

  00146	33 c0		 xor	 eax, eax
  00148	e9 a3 03 00 00	 jmp	 $LN1@dump_text_
$LN17@dump_text_:
$LN2@dump_text_:

; 940  :     }
; 941  : 
; 942  :     /* Add all of this file's data to our RECS collection */
; 943  :     while ((rec = fgets( (char*)bfr, sizeof( bfr ), ifile )) != NULL)

  0014d	4c 8b 44 24 70	 mov	 r8, QWORD PTR ifile$[rsp]
  00152	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00164	48 89 44 24 60	 mov	 QWORD PTR rec$[rsp], rax
  00169	48 83 7c 24 60
	00		 cmp	 QWORD PTR rec$[rsp], 0
  0016f	0f 84 6b 01 00
	00		 je	 $LN3@dump_text_

; 944  :     {
; 945  :         /* Get length */
; 946  :         rsz = (int) strlen( rec );

  00175	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  0017a	e8 00 00 00 00	 call	 strlen
  0017f	89 44 24 50	 mov	 DWORD PTR rsz$[rsp], eax

; 947  : 
; 948  :         /* Remove newline (if present) and adjust length */
; 949  :         if (rsz && rec[ rsz - 1 ] == '\n')

  00183	83 7c 24 50 00	 cmp	 DWORD PTR rsz$[rsp], 0
  00188	74 2e		 je	 SHORT $LN18@dump_text_
  0018a	8b 44 24 50	 mov	 eax, DWORD PTR rsz$[rsp]
  0018e	ff c8		 dec	 eax
  00190	48 98		 cdqe
  00192	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  00197	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0019b	83 f8 0a	 cmp	 eax, 10
  0019e	75 18		 jne	 SHORT $LN18@dump_text_

; 950  :             rec[ --rsz ] = 0;

  001a0	8b 44 24 50	 mov	 eax, DWORD PTR rsz$[rsp]
  001a4	ff c8		 dec	 eax
  001a6	89 44 24 50	 mov	 DWORD PTR rsz$[rsp], eax
  001aa	48 63 44 24 50	 movsxd	 rax, DWORD PTR rsz$[rsp]
  001af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  001b4	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN18@dump_text_:

; 951  : 
; 952  :         /* If fixed, pad or truncate record to specified length */
; 953  :         if (recfm == 'F')

  001b8	0f be 84 24 d0
	00 00 00	 movsx	 eax, BYTE PTR recfm$[rsp]
  001c0	83 f8 46	 cmp	 eax, 70			; 00000046H
  001c3	0f 85 ab 00 00
	00		 jne	 $LN19@dump_text_

; 954  :         {
; 955  :             /* Pad or truncate the record as needed */
; 956  :             if (rsz < *recl )

  001c9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  001d1	8b 00		 mov	 eax, DWORD PTR [rax]
  001d3	39 44 24 50	 cmp	 DWORD PTR rsz$[rsp], eax
  001d7	7d 3e		 jge	 SHORT $LN21@dump_text_

; 957  :                 memset( &rec[rsz], ' ', *recl - rsz );  // (pad)

  001d9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  001e1	8b 4c 24 50	 mov	 ecx, DWORD PTR rsz$[rsp]
  001e5	8b 00		 mov	 eax, DWORD PTR [rax]
  001e7	2b c1		 sub	 eax, ecx
  001e9	48 98		 cdqe
  001eb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001f3	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR rsz$[rsp]
  001f8	48 8b 54 24 60	 mov	 rdx, QWORD PTR rec$[rsp]
  001fd	48 03 d1	 add	 rdx, rcx
  00200	48 8b ca	 mov	 rcx, rdx
  00203	48 8b f9	 mov	 rdi, rcx
  00206	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0020b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  00213	f3 aa		 rep stosb
  00215	eb 4d		 jmp	 SHORT $LN22@dump_text_
$LN21@dump_text_:

; 958  :             else if (rsz > *recl)

  00217	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  0021f	8b 00		 mov	 eax, DWORD PTR [rax]
  00221	39 44 24 50	 cmp	 DWORD PTR rsz$[rsp], eax
  00225	7e 3d		 jle	 SHORT $LN23@dump_text_

; 959  :             {
; 960  :                 maxrsz = MAX( rsz, maxrsz );

  00227	8b 44 24 58	 mov	 eax, DWORD PTR maxrsz$[rsp]
  0022b	39 44 24 50	 cmp	 DWORD PTR rsz$[rsp], eax
  0022f	7e 0a		 jle	 SHORT $LN37@dump_text_
  00231	8b 44 24 50	 mov	 eax, DWORD PTR rsz$[rsp]
  00235	89 44 24 68	 mov	 DWORD PTR tv158[rsp], eax
  00239	eb 08		 jmp	 SHORT $LN38@dump_text_
$LN37@dump_text_:
  0023b	8b 44 24 58	 mov	 eax, DWORD PTR maxrsz$[rsp]
  0023f	89 44 24 68	 mov	 DWORD PTR tv158[rsp], eax
$LN38@dump_text_:
  00243	8b 44 24 68	 mov	 eax, DWORD PTR tv158[rsp]
  00247	89 44 24 58	 mov	 DWORD PTR maxrsz$[rsp], eax

; 961  :                 rec[ *recl ] = 0;  // (truncate)

  0024b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00253	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00256	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  0025b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 962  :                 truncated = true;

  0025f	c6 44 24 54 01	 mov	 BYTE PTR truncated$[rsp], 1
$LN23@dump_text_:
$LN22@dump_text_:

; 963  :             }
; 964  :             rsz = *recl;

  00264	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  0026c	8b 00		 mov	 eax, DWORD PTR [rax]
  0026e	89 44 24 50	 mov	 DWORD PTR rsz$[rsp], eax

; 965  :         }

  00272	eb 2f		 jmp	 SHORT $LN20@dump_text_
$LN19@dump_text_:

; 966  :         else // (recfm == 'V')
; 967  :         {
; 968  :             /* If empty line, change it to a single blank */
; 969  :             if (!rsz)

  00274	83 7c 24 50 00	 cmp	 DWORD PTR rsz$[rsp], 0
  00279	75 28		 jne	 SHORT $LN24@dump_text_

; 970  :             {
; 971  :                 rec[0] = ' ';

  0027b	b8 01 00 00 00	 mov	 eax, 1
  00280	48 6b c0 00	 imul	 rax, rax, 0
  00284	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  00289	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H

; 972  :                 rec[ rsz = 1 ] =  0;

  0028d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR rsz$[rsp], 1
  00295	48 63 44 24 50	 movsxd	 rax, DWORD PTR rsz$[rsp]
  0029a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  0029f	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN24@dump_text_:
$LN20@dump_text_:

; 973  :             }
; 974  :         }
; 975  : 
; 976  :         /* Translate textual data from ASCII to EBCDIC */
; 977  :         str_host_to_guest( rec, wrk, rsz );

  002a3	44 8b 44 24 50	 mov	 r8d, DWORD PTR rsz$[rsp]
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:wrk
  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rec$[rsp]
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest

; 978  : 
; 979  :         /* Add this record to our RECS collection */
; 980  :         if (addrecs( recs, wrk, rsz ) != 0)

  002ba	44 8b 44 24 50	 mov	 r8d, DWORD PTR rsz$[rsp]
  002bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:wrk
  002c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR recs$[rsp]
  002cb	e8 00 00 00 00	 call	 addrecs
  002d0	85 c0		 test	 eax, eax
  002d2	74 07		 je	 SHORT $LN25@dump_text_

; 981  :             return NULL;

  002d4	33 c0		 xor	 eax, eax
  002d6	e9 15 02 00 00	 jmp	 $LN1@dump_text_
$LN25@dump_text_:

; 982  :     }

  002db	e9 6d fe ff ff	 jmp	 $LN2@dump_text_
$LN3@dump_text_:

; 983  : 
; 984  :     /* Check for I/O error */
; 985  :     if (ferror( ifile ))

  002e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ifile$[rsp]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  002eb	85 c0		 test	 eax, eax
  002ed	0f 84 ef 00 00
	00		 je	 $LN26@dump_text_

; 986  :     {
; 987  :         // "I/O error on file \"%s\": %s"
; 988  :         FWRMSG( stderr, HHC02627, "E", infile, strerror( errno ));

  002f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002f9	8b 08		 mov	 ecx, DWORD PTR [rax]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00301	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv179[rsp], rax
  00309	b9 02 00 00 00	 mov	 ecx, 2
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00314	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv179[rsp]
  0031c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00321	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  00329	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169766
  00335	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0033a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169767
  00341	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00346	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00351	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169768
  00358	ba dc 03 00 00	 mov	 edx, 988		; 000003dcH
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169769
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@dump_text_:

; 989  :         VERIFY( fclose( ifile ) == 0 );

  0036a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ifile$[rsp]
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  00375	85 c0		 test	 eax, eax
  00377	74 5c		 je	 SHORT $LN27@dump_text_
$LN9@dump_text_:
  00379	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169771
  00380	41 b8 dd 03 00
	00		 mov	 r8d, 989		; 000003ddH
  00386	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169772
  0038d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169773
  00394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003a0	85 c0		 test	 eax, eax
  003a2	74 20		 je	 SHORT $LN28@dump_text_
  003a4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169775
  003ab	41 b8 dd 03 00
	00		 mov	 r8d, 989		; 000003ddH
  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169776
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169777
  003bf	e8 00 00 00 00	 call	 DebuggerTrace
$LN28@dump_text_:
  003c4	33 c0		 xor	 eax, eax
  003c6	85 c0		 test	 eax, eax
  003c8	75 af		 jne	 SHORT $LN9@dump_text_
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003d0	85 c0		 test	 eax, eax
  003d2	74 01		 je	 SHORT $LN29@dump_text_
  003d4	cc		 int	 3
$LN29@dump_text_:
$LN27@dump_text_:
  003d5	33 c0		 xor	 eax, eax
  003d7	85 c0		 test	 eax, eax
  003d9	75 8f		 jne	 SHORT $LN6@dump_text_

; 990  :         return NULL;

  003db	33 c0		 xor	 eax, eax
  003dd	e9 0e 01 00 00	 jmp	 $LN1@dump_text_
$LN26@dump_text_:
$LN12@dump_text_:

; 991  :     }
; 992  : 
; 993  :     /* Close the file */
; 994  :     VERIFY( fclose( ifile ) == 0 );

  003e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ifile$[rsp]
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  003ed	85 c0		 test	 eax, eax
  003ef	74 5c		 je	 SHORT $LN30@dump_text_
$LN15@dump_text_:
  003f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169780
  003f8	41 b8 e2 03 00
	00		 mov	 r8d, 994		; 000003e2H
  003fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169781
  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169782
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00418	85 c0		 test	 eax, eax
  0041a	74 20		 je	 SHORT $LN31@dump_text_
  0041c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169784
  00423	41 b8 e2 03 00
	00		 mov	 r8d, 994		; 000003e2H
  00429	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169785
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169786
  00437	e8 00 00 00 00	 call	 DebuggerTrace
$LN31@dump_text_:
  0043c	33 c0		 xor	 eax, eax
  0043e	85 c0		 test	 eax, eax
  00440	75 af		 jne	 SHORT $LN15@dump_text_
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00448	85 c0		 test	 eax, eax
  0044a	74 01		 je	 SHORT $LN32@dump_text_
  0044c	cc		 int	 3
$LN32@dump_text_:
$LN30@dump_text_:
  0044d	33 c0		 xor	 eax, eax
  0044f	85 c0		 test	 eax, eax
  00451	75 8f		 jne	 SHORT $LN12@dump_text_

; 995  : 
; 996  :     /* Create a TAPE_BLOCKS collection and discard RECS collection */
; 997  :     blks = flushrecs( recs, recl, recc, filesz, 0x40 );

  00453	c6 44 24 20 40	 mov	 BYTE PTR [rsp+32], 64	; 00000040H
  00458	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR filesz$[rsp]
  00460	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR recc$[rsp]
  00468	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR recl$[rsp]
  00470	48 8b 4c 24 78	 mov	 rcx, QWORD PTR recs$[rsp]
  00475	e8 00 00 00 00	 call	 flushrecs
  0047a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR blks$[rsp], rax

; 998  : 
; 999  :     if (truncated)

  00482	0f b6 44 24 54	 movzx	 eax, BYTE PTR truncated$[rsp]
  00487	85 c0		 test	 eax, eax
  00489	74 5d		 je	 SHORT $LN33@dump_text_

; 1000 :         // "lrecl %u less than %u; one or more records truncated"
; 1001 :         FWRMSG( stderr, HHC02628, "W", *recl, maxrsz );

  0048b	b9 02 00 00 00	 mov	 ecx, 2
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00496	8b 4c 24 58	 mov	 ecx, DWORD PTR maxrsz$[rsp]
  0049a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0049e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR recl$[rsp]
  004a6	8b 09		 mov	 ecx, DWORD PTR [rcx]
  004a8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169789
  004b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169790
  004bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  004cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169791
  004d6	ba e9 03 00 00	 mov	 edx, 1001		; 000003e9H
  004db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169792
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@dump_text_:

; 1002 : 
; 1003 :     return blks;

  004e8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR blks$[rsp]
$LN1@dump_text_:

; 1004 : }

  004f0	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  004f7	5f		 pop	 rdi
  004f8	c3		 ret	 0
dump_text_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rsz$ = 80
ifile$ = 88
recs$ = 96
tv67 = 104
hdr$ = 112
tv79 = 120
tv140 = 128
blks$ = 136
opts$ = 160
infile$ = 168
recfm$ = 176
recl$ = 184
recc$ = 192
filesz$ = 200
dump_binary_file PROC

; 871  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 872  :     TAPE_BLOCKS*  blks;
; 873  :     FILE*         ifile;
; 874  :     RECS*         recs;
; 875  :     const BYTE*   hdr;
; 876  :     int           rsz;
; 877  : 
; 878  :     /* Allocate and initialize a new RECS collection for this file */
; 879  :     hdr = opts->cms ? CMS__hdr : PLCD_hdr;

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00023	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00027	85 c0		 test	 eax, eax
  00029	74 0e		 je	 SHORT $LN27@dump_binar
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CMS__hdr
  00032	48 89 44 24 68	 mov	 QWORD PTR tv67[rsp], rax
  00037	eb 0c		 jmp	 SHORT $LN28@dump_binar
$LN27@dump_binar:
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PLCD_hdr
  00040	48 89 44 24 68	 mov	 QWORD PTR tv67[rsp], rax
$LN28@dump_binar:
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR tv67[rsp]
  0004a	48 89 44 24 70	 mov	 QWORD PTR hdr$[rsp], rax

; 880  :     if (!(recs = initrecs( opts, recfm, *recl, hdr, BLK_HDRSIZE )))

  0004f	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR [rsp+32], 5
  00057	4c 8b 4c 24 70	 mov	 r9, QWORD PTR hdr$[rsp]
  0005c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR recl$[rsp]
  00064	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00067	0f b6 94 24 b0
	00 00 00	 movzx	 edx, BYTE PTR recfm$[rsp]
  0006f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00077	e8 00 00 00 00	 call	 initrecs
  0007c	48 89 44 24 60	 mov	 QWORD PTR recs$[rsp], rax
  00081	48 83 7c 24 60
	00		 cmp	 QWORD PTR recs$[rsp], 0
  00087	75 07		 jne	 SHORT $LN16@dump_binar

; 881  :         return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 8f 02 00 00	 jmp	 $LN1@dump_binar
$LN16@dump_binar:

; 882  : 
; 883  :     /* Open this file for reading */
; 884  :     if (!(ifile = fopen( infile, "rb" )))

  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169678
  00097	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  000a5	48 89 44 24 58	 mov	 QWORD PTR ifile$[rsp], rax
  000aa	48 83 7c 24 58
	00		 cmp	 QWORD PTR ifile$[rsp], 0
  000b0	75 78		 jne	 SHORT $LN17@dump_binar

; 885  :     {
; 886  :         // "File open error: \"%s\": %s"
; 887  :         FWRMSG( stderr, HHC02623, "E", infile, strerror( errno ));

  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c0	48 89 44 24 78	 mov	 QWORD PTR tv79[rsp], rax
  000c5	b9 02 00 00 00	 mov	 ecx, 2
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv79[rsp]
  000d5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000da	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  000e2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  000ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  000fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00104	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169681
  00111	ba 77 03 00 00	 mov	 edx, 887		; 00000377H
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 888  :         return NULL;

  00123	33 c0		 xor	 eax, eax
  00125	e9 f5 01 00 00	 jmp	 $LN1@dump_binar
$LN17@dump_binar:
$LN2@dump_binar:

; 889  :     }
; 890  : 
; 891  :     /* Add all of this file's data to our RECS collection */
; 892  :     while ((rsz = (int) fread( bfr, 1, MAX_PLC2_BLKSIZE, ifile )) != 0)

  0012a	4c 8b 4c 24 58	 mov	 r9, QWORD PTR ifile$[rsp]
  0012f	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  00135	ba 01 00 00 00	 mov	 edx, 1
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bfr
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00147	89 44 24 50	 mov	 DWORD PTR rsz$[rsp], eax
  0014b	83 7c 24 50 00	 cmp	 DWORD PTR rsz$[rsp], 0
  00150	74 23		 je	 SHORT $LN3@dump_binar

; 893  :         if (addrecs( recs, bfr, rsz) != 0)

  00152	44 8b 44 24 50	 mov	 r8d, DWORD PTR rsz$[rsp]
  00157	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:bfr
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  00163	e8 00 00 00 00	 call	 addrecs
  00168	85 c0		 test	 eax, eax
  0016a	74 07		 je	 SHORT $LN18@dump_binar

; 894  :             return NULL;

  0016c	33 c0		 xor	 eax, eax
  0016e	e9 ac 01 00 00	 jmp	 $LN1@dump_binar
$LN18@dump_binar:
  00173	eb b5		 jmp	 SHORT $LN2@dump_binar
$LN3@dump_binar:

; 895  : 
; 896  :     /* Check for I/O error */
; 897  :     if (ferror( ifile ))

  00175	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00180	85 c0		 test	 eax, eax
  00182	0f 84 ef 00 00
	00		 je	 $LN19@dump_binar

; 898  :     {
; 899  :         // "I/O error on file \"%s\": %s"
; 900  :         FWRMSG( stderr, HHC02627, "E", infile, strerror( errno ));

  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00196	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
  0019e	b9 02 00 00 00	 mov	 ecx, 2
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv140[rsp]
  001b1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001b6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR infile$[rsp]
  001be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  001ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169686
  001d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169687
  001ed	ba 84 03 00 00	 mov	 edx, 900		; 00000384H
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@dump_binar:

; 901  :         VERIFY( fclose( ifile ) == 0 );

  001ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  0020a	85 c0		 test	 eax, eax
  0020c	74 5c		 je	 SHORT $LN20@dump_binar
$LN9@dump_binar:
  0020e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169690
  00215	41 b8 85 03 00
	00		 mov	 r8d, 901		; 00000385H
  0021b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169691
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169692
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00235	85 c0		 test	 eax, eax
  00237	74 20		 je	 SHORT $LN21@dump_binar
  00239	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169694
  00240	41 b8 85 03 00
	00		 mov	 r8d, 901		; 00000385H
  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169695
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  00254	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@dump_binar:
  00259	33 c0		 xor	 eax, eax
  0025b	85 c0		 test	 eax, eax
  0025d	75 af		 jne	 SHORT $LN9@dump_binar
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00265	85 c0		 test	 eax, eax
  00267	74 01		 je	 SHORT $LN22@dump_binar
  00269	cc		 int	 3
$LN22@dump_binar:
$LN20@dump_binar:
  0026a	33 c0		 xor	 eax, eax
  0026c	85 c0		 test	 eax, eax
  0026e	75 8f		 jne	 SHORT $LN6@dump_binar

; 902  :         return NULL;

  00270	33 c0		 xor	 eax, eax
  00272	e9 a8 00 00 00	 jmp	 $LN1@dump_binar
$LN19@dump_binar:
$LN12@dump_binar:

; 903  :     }
; 904  : 
; 905  :     /* Close the file */
; 906  :     VERIFY( fclose( ifile ) == 0 );

  00277	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ifile$[rsp]
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  00282	85 c0		 test	 eax, eax
  00284	74 5c		 je	 SHORT $LN23@dump_binar
$LN15@dump_binar:
  00286	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169699
  0028d	41 b8 8a 03 00
	00		 mov	 r8d, 906		; 0000038aH
  00293	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169700
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169701
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002ad	85 c0		 test	 eax, eax
  002af	74 20		 je	 SHORT $LN24@dump_binar
  002b1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169703
  002b8	41 b8 8a 03 00
	00		 mov	 r8d, 906		; 0000038aH
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169704
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169705
  002cc	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@dump_binar:
  002d1	33 c0		 xor	 eax, eax
  002d3	85 c0		 test	 eax, eax
  002d5	75 af		 jne	 SHORT $LN15@dump_binar
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002dd	85 c0		 test	 eax, eax
  002df	74 01		 je	 SHORT $LN25@dump_binar
  002e1	cc		 int	 3
$LN25@dump_binar:
$LN23@dump_binar:
  002e2	33 c0		 xor	 eax, eax
  002e4	85 c0		 test	 eax, eax
  002e6	75 8f		 jne	 SHORT $LN12@dump_binar

; 907  : 
; 908  :     /* Create a TAPE_BLOCKS collection and discard RECS collection */
; 909  :     blks = flushrecs( recs, recl, recc, filesz, 0x40 );

  002e8	c6 44 24 20 40	 mov	 BYTE PTR [rsp+32], 64	; 00000040H
  002ed	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR filesz$[rsp]
  002f5	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR recc$[rsp]
  002fd	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR recl$[rsp]
  00305	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  0030a	e8 00 00 00 00	 call	 flushrecs
  0030f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR blks$[rsp], rax

; 910  : 
; 911  :     return blks;

  00317	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR blks$[rsp]
$LN1@dump_binar:

; 912  : }

  0031f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00326	c3		 ret	 0
dump_binary_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
residual$ = 32
rc$ = 36
padbfr$1 = 40
tv82 = 48
tv133 = 56
blks$ = 64
recs$ = 96
recl$ = 104
recc$ = 112
filesz$ = 120
pad$ = 128
flushrecs PROC

; 805  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 806  :     TAPE_BLOCKS* blks;
; 807  :     int residual;
; 808  :     int rc;
; 809  : 
; 810  :     if (!recs->filesz)

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  0001e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00023	75 60		 jne	 SHORT $LN2@flushrecs

; 811  :     {
; 812  :         if ((rc = append_data( recs->blocks, &pad, 1 )) != 0)

  00025	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR pad$[rsp]
  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	e8 00 00 00 00	 call	 append_data
  00040	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  00044	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00049	74 07		 je	 SHORT $LN3@flushrecs

; 813  :             return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 93 01 00 00	 jmp	 $LN1@flushrecs
$LN3@flushrecs:

; 814  : 
; 815  :         recs->filesz = 1;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00057	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 816  : 
; 817  :         if (recs->recfm == 'V')     // (variable)

  0005f	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00064	0f be 40 18	 movsx	 eax, BYTE PTR [rax+24]
  00068	83 f8 56	 cmp	 eax, 86			; 00000056H
  0006b	75 18		 jne	 SHORT $LN4@flushrecs

; 818  :         {
; 819  :             recs->reccount = 1;

  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00072	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [rax+16], 1

; 820  :             recs->reclen   = 1;

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  0007e	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
$LN4@flushrecs:
$LN2@flushrecs:

; 821  :         }
; 822  :     }
; 823  : 
; 824  :     if (recs->recfm == 'F')         // (fixed)

  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  0008a	0f be 40 18	 movsx	 eax, BYTE PTR [rax+24]
  0008e	83 f8 46	 cmp	 eax, 70			; 00000046H
  00091	0f 85 02 01 00
	00		 jne	 $LN5@flushrecs

; 825  :     {
; 826  :         /* Check if we need to do any padding */
; 827  :         residual  = recs->reclen - (recs->filesz % recs->reclen);

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  0009c	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  000a0	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  000aa	48 63 49 14	 movsxd	 rcx, DWORD PTR [rcx+20]
  000ae	33 d2		 xor	 edx, edx
  000b0	4c 8b 44 24 60	 mov	 r8, QWORD PTR recs$[rsp]
  000b5	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  000b9	48 f7 f1	 div	 rcx
  000bc	48 8b c2	 mov	 rax, rdx
  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  000c4	48 2b c8	 sub	 rcx, rax
  000c7	48 8b c1	 mov	 rax, rcx
  000ca	89 44 24 20	 mov	 DWORD PTR residual$[rsp], eax

; 828  :         residual %= recs->reclen;

  000ce	8b 44 24 20	 mov	 eax, DWORD PTR residual$[rsp]
  000d2	99		 cdq
  000d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  000d8	f7 79 14	 idiv	 DWORD PTR [rcx+20]
  000db	8b c2		 mov	 eax, edx
  000dd	89 44 24 20	 mov	 DWORD PTR residual$[rsp], eax

; 829  : 
; 830  :         if (residual)  /* (do we need to pad?) */

  000e1	83 7c 24 20 00	 cmp	 DWORD PTR residual$[rsp], 0
  000e6	0f 84 94 00 00
	00		 je	 $LN6@flushrecs

; 831  :         {
; 832  :             BYTE* padbfr;
; 833  : 
; 834  :             if (!(padbfr = malloc( residual )))

  000ec	48 63 44 24 20	 movsxd	 rax, DWORD PTR residual$[rsp]
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000fa	48 89 44 24 28	 mov	 QWORD PTR padbfr$1[rsp], rax
  000ff	48 83 7c 24 28
	00		 cmp	 QWORD PTR padbfr$1[rsp], 0
  00105	75 07		 jne	 SHORT $LN7@flushrecs

; 835  :                 return NULL;

  00107	33 c0		 xor	 eax, eax
  00109	e9 d7 00 00 00	 jmp	 $LN1@flushrecs
$LN7@flushrecs:

; 836  : 
; 837  :             /* Fill work buffer with requested padding character */
; 838  :             memset( padbfr, pad, residual );

  0010e	48 63 44 24 20	 movsxd	 rax, DWORD PTR residual$[rsp]
  00113	48 89 44 24 38	 mov	 QWORD PTR tv133[rsp], rax
  00118	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR pad$[rsp]
  00120	48 63 c9	 movsxd	 rcx, ecx
  00123	48 8b 7c 24 28	 mov	 rdi, QWORD PTR padbfr$1[rsp]
  00128	48 8b c1	 mov	 rax, rcx
  0012b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv133[rsp]
  00130	f3 aa		 rep stosb

; 839  : 
; 840  :             /* Add padding to reach proper fixed record size */
; 841  :             if ((rc = append_data( recs->blocks, padbfr, residual )) != 0)

  00132	48 63 44 24 20	 movsxd	 rax, DWORD PTR residual$[rsp]
  00137	4c 8b c0	 mov	 r8, rax
  0013a	48 8b 54 24 28	 mov	 rdx, QWORD PTR padbfr$1[rsp]
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00144	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00147	e8 00 00 00 00	 call	 append_data
  0014c	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  00150	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00155	74 07		 je	 SHORT $LN8@flushrecs

; 842  :                 return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	e9 87 00 00 00	 jmp	 $LN1@flushrecs
$LN8@flushrecs:

; 843  : 
; 844  :             free( padbfr );

  0015e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR padbfr$1[rsp]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 845  : 
; 846  :             recs->filesz += residual;   /* (fix the file size) */

  00169	48 63 44 24 20	 movsxd	 rax, DWORD PTR residual$[rsp]
  0016e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  00173	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  0017c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN6@flushrecs:

; 847  :         }
; 848  : 
; 849  :         recs->reccount = (int) recs->filesz / recs->reclen;

  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  00185	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00188	99		 cdq
  00189	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  0018e	f7 79 14	 idiv	 DWORD PTR [rcx+20]
  00191	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  00196	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN5@flushrecs:

; 850  :     }
; 851  : 
; 852  :     /* Pass updated values back to caller */
; 853  : 
; 854  :     *recl   = recs->reclen;

  00199	48 8b 44 24 68	 mov	 rax, QWORD PTR recl$[rsp]
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  001a3	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  001a6	89 08		 mov	 DWORD PTR [rax], ecx

; 855  :     *recc   = recs->reccount;

  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR recc$[rsp]
  001ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  001b2	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  001b5	89 08		 mov	 DWORD PTR [rax], ecx

; 856  :     *filesz = recs->filesz;

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR filesz$[rsp]
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  001c1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 857  : 
; 858  :     blks = recs->blocks;

  001c8	48 8b 44 24 60	 mov	 rax, QWORD PTR recs$[rsp]
  001cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d0	48 89 44 24 40	 mov	 QWORD PTR blks$[rsp], rax

; 859  : 
; 860  :     free( recs );

  001d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recs$[rsp]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 861  : 
; 862  :     return blks;

  001e0	48 8b 44 24 40	 mov	 rax, QWORD PTR blks$[rsp]
$LN1@flushrecs:

; 863  : }

  001e5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
flushrecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
recd$ = 32
rc$ = 36
tv70 = 40
tv129 = 44
recs$ = 64
bfr$ = 72
sz$ = 80
addrecs	PROC

; 760  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 761  :     BYTE recd[2];   // (guest BIG-ENDIAN format)
; 762  :     int rc;
; 763  : 
; 764  :     recs->filesz += sz;

  00013	48 63 44 24 50	 movsxd	 rax, DWORD PTR sz$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recs$[rsp]
  0001d	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recs$[rsp]
  00026	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 765  : 
; 766  :     switch (recs->recfm)

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  0002f	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00033	88 44 24 28	 mov	 BYTE PTR tv70[rsp], al
  00037	80 7c 24 28 46	 cmp	 BYTE PTR tv70[rsp], 70	; 00000046H
  0003c	0f 84 bb 00 00
	00		 je	 $LN7@addrecs
  00042	80 7c 24 28 56	 cmp	 BYTE PTR tv70[rsp], 86	; 00000056H
  00047	74 05		 je	 SHORT $LN4@addrecs
  00049	e9 da 00 00 00	 jmp	 $LN2@addrecs
$LN4@addrecs:

; 767  :     {
; 768  :         case 'V': // (variable)
; 769  : 
; 770  :             store_hw( recd, (U16) sz );

  0004e	0f b7 4c 24 50	 movzx	 ecx, WORD PTR sz$[rsp]
  00053	e8 00 00 00 00	 call	 _byteswap_ushort
  00058	0f b7 d0	 movzx	 edx, ax
  0005b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR recd$[rsp]
  00060	e8 00 00 00 00	 call	 store_hw_noswap

; 771  : 
; 772  :             if (0
; 773  :                 || (rc = append_data( recs->blocks, recd,  2 )) != 0
; 774  :                 || (rc = append_data( recs->blocks, bfr,  sz )) != 0

  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 48		 jne	 SHORT $LN6@addrecs
  0006b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00071	48 8d 54 24 20	 lea	 rdx, QWORD PTR recd$[rsp]
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  0007b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007e	e8 00 00 00 00	 call	 append_data
  00083	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  00087	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0008c	75 25		 jne	 SHORT $LN6@addrecs
  0008e	48 63 44 24 50	 movsxd	 rax, DWORD PTR sz$[rsp]
  00093	4c 8b c0	 mov	 r8, rax
  00096	48 8b 54 24 48	 mov	 rdx, QWORD PTR bfr$[rsp]
  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  000a0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a3	e8 00 00 00 00	 call	 append_data
  000a8	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  000ac	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  000b1	74 06		 je	 SHORT $LN5@addrecs
$LN6@addrecs:

; 775  :             )
; 776  :                 return rc;

  000b3	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  000b7	eb 71		 jmp	 SHORT $LN1@addrecs
$LN5@addrecs:

; 777  : 
; 778  :             recs->reccount++;

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  000be	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c1	ff c0		 inc	 eax
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recs$[rsp]
  000c8	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 779  :             recs->reclen = MAX( recs->reclen, sz );

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  000d0	8b 4c 24 50	 mov	 ecx, DWORD PTR sz$[rsp]
  000d4	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  000d7	7e 0e		 jle	 SHORT $LN10@addrecs
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  000de	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000e1	89 44 24 2c	 mov	 DWORD PTR tv129[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN11@addrecs
$LN10@addrecs:
  000e7	8b 44 24 50	 mov	 eax, DWORD PTR sz$[rsp]
  000eb	89 44 24 2c	 mov	 DWORD PTR tv129[rsp], eax
$LN11@addrecs:
  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  000f4	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv129[rsp]
  000f8	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 780  :             break;

  000fb	eb 2b		 jmp	 SHORT $LN2@addrecs
$LN7@addrecs:

; 781  : 
; 782  :         case 'F': // (fixed)
; 783  : 
; 784  :             if ((rc = append_data( recs->blocks, bfr, sz )) != 0)

  000fd	48 63 44 24 50	 movsxd	 rax, DWORD PTR sz$[rsp]
  00102	4c 8b c0	 mov	 r8, rax
  00105	48 8b 54 24 48	 mov	 rdx, QWORD PTR bfr$[rsp]
  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR recs$[rsp]
  0010f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00112	e8 00 00 00 00	 call	 append_data
  00117	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  0011b	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00120	74 06		 je	 SHORT $LN8@addrecs

; 785  :                 return rc;

  00122	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00126	eb 02		 jmp	 SHORT $LN1@addrecs
$LN8@addrecs:
$LN2@addrecs:

; 786  :             break;
; 787  :     }
; 788  : 
; 789  :     return 0;

  00128	33 c0		 xor	 eax, eax
$LN1@addrecs:

; 790  : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
addrecs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
tv67 = 32
recs$ = 40
blksz$ = 48
opts$ = 80
recfm$ = 88
recl$ = 96
hdr$ = 104
hdrsz$ = 112
initrecs PROC

; 739  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 740  :     RECS*  recs;
; 741  :     size_t blksz = opts->cms ? CMS_BLOCKSIZE : PLC2_BLOCKSIZE;

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR opts$[rsp]
  0001c	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN4@initrecs
  00024	c7 44 24 20 20
	03 00 00	 mov	 DWORD PTR tv67[rsp], 800 ; 00000320H
  0002c	eb 08		 jmp	 SHORT $LN5@initrecs
$LN4@initrecs:
  0002e	c7 44 24 20 a0
	0f 00 00	 mov	 DWORD PTR tv67[rsp], 4000 ; 00000fa0H
$LN5@initrecs:
  00036	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv67[rsp]
  0003b	48 89 44 24 30	 mov	 QWORD PTR blksz$[rsp], rax

; 742  : 
; 743  :     if (!(recs = malloc( sizeof( RECS ))))

  00040	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004b	48 89 44 24 28	 mov	 QWORD PTR recs$[rsp], rax
  00050	48 83 7c 24 28
	00		 cmp	 QWORD PTR recs$[rsp], 0
  00056	75 04		 jne	 SHORT $LN2@initrecs

; 744  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 58		 jmp	 SHORT $LN1@initrecs
$LN2@initrecs:

; 745  : 
; 746  :     recs->blocks   = init_blocks( blksz, CMS_BLOCKSIZE, hdr, hdrsz );

  0005c	44 8b 4c 24 70	 mov	 r9d, DWORD PTR hdrsz$[rsp]
  00061	4c 8b 44 24 68	 mov	 r8, QWORD PTR hdr$[rsp]
  00066	ba 20 03 00 00	 mov	 edx, 800		; 00000320H
  0006b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR blksz$[rsp]
  00070	e8 00 00 00 00	 call	 init_blocks
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR recs$[rsp]
  0007a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 747  :     recs->filesz   = 0;

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR recs$[rsp]
  00082	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 748  :     recs->reccount = 0;

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR recs$[rsp]
  0008f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 749  :     recs->reclen   = recl;

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR recs$[rsp]
  0009b	8b 4c 24 60	 mov	 ecx, DWORD PTR recl$[rsp]
  0009f	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 750  :     recs->recfm    = recfm;

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR recs$[rsp]
  000a7	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR recfm$[rsp]
  000ac	88 48 18	 mov	 BYTE PTR [rax+24], cl

; 751  : 
; 752  :     return recs;

  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR recs$[rsp]
$LN1@initrecs:

; 753  : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
initrecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
tb$ = 32
ntb$ = 40
tbs$ = 64
free_blocks PROC

; 695  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 696  :     TAPE_BLOCK *tb, *ntb;
; 697  : 
; 698  :     if (!tbs)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR tbs$[rsp], 0
  0000f	75 02		 jne	 SHORT $LN4@free_block

; 699  :         return;

  00011	eb 54		 jmp	 SHORT $LN1@free_block
$LN4@free_block:

; 700  : 
; 701  :     tb = tbs->first;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR tbs$[rsp]
  00018	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0001c	48 89 44 24 20	 mov	 QWORD PTR tb$[rsp], rax
$LN2@free_block:

; 702  : 
; 703  :     while (tb)

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR tb$[rsp], 0
  00027	74 33		 je	 SHORT $LN3@free_block

; 704  :     {
; 705  :         free( tb->data );

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR tb$[rsp]
  0002e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 706  :         ntb = tb->next;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR tb$[rsp]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	48 89 44 24 28	 mov	 QWORD PTR ntb$[rsp], rax

; 707  :         free( tb );

  00045	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tb$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 708  :         tb = ntb;

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR ntb$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR tb$[rsp], rax

; 709  :     }

  0005a	eb c5		 jmp	 SHORT $LN2@free_block
$LN3@free_block:

; 710  : 
; 711  :     free( tbs );

  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tbs$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@free_block:

; 712  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
free_blocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
cpy_amount$ = 32
bfr_offset$ = 36
tb$ = 40
tv94 = 48
tv165 = 56
tbs$ = 96
bfr$ = 104
bfr_bytes$ = 112
append_data PROC

; 618  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 619  :     TAPE_BLOCK* tb;
; 620  :     int bfr_offset;
; 621  :     int cpy_amount;
; 622  : 
; 623  :     bfr_offset = 0;

  00015	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR bfr_offset$[rsp], 0
$LN2@append_dat:

; 624  : 
; 625  :     while (bfr_bytes)   /* while bytes remain to be appended */

  0001d	48 83 7c 24 70
	00		 cmp	 QWORD PTR bfr_bytes$[rsp], 0
  00023	0f 84 37 02 00
	00		 je	 $LN3@append_dat

; 626  :     {
; 627  :         /* Allocate a new tape block if we don't have one yet,
; 628  :            or if the current block is full (no room remains).
; 629  :         */
; 630  :         if (0
; 631  :             || !tbs->current
; 632  :             ||  tbs->current->sz >= (tbs->hdrsz + tbs->blksz)

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 31		 jne	 SHORT $LN6@append_dat
  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  00034	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00039	74 25		 je	 SHORT $LN6@append_dat
  0003b	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  00040	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  00049	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004d	48 8b 54 24 60	 mov	 rdx, QWORD PTR tbs$[rsp]
  00052	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00056	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0005a	0f 82 2a 01 00
	00		 jb	 $LN4@append_dat
$LN6@append_dat:

; 633  :         )
; 634  :         {
; 635  :             /* Allocate a new TAPE_BLOCK structure */
; 636  :             if (!(tb = malloc( sizeof( TAPE_BLOCK ))))

  00060	b9 18 00 00 00	 mov	 ecx, 24
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0006b	48 89 44 24 28	 mov	 QWORD PTR tb$[rsp], rax
  00070	48 83 7c 24 28
	00		 cmp	 QWORD PTR tb$[rsp], 0
  00076	75 0a		 jne	 SHORT $LN7@append_dat

; 637  :                 return -1;

  00078	b8 ff ff ff ff	 mov	 eax, -1
  0007d	e9 e0 01 00 00	 jmp	 $LN1@append_dat
$LN7@append_dat:

; 638  : 
; 639  :             tb->next = NULL;

  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  00087	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 640  :             tb->sz   = 0;

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  00094	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 641  : 
; 642  :             /* First one? */
; 643  :             if (!tbs->first)

  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000a1	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  000a6	75 1e		 jne	 SHORT $LN8@append_dat

; 644  :             {
; 645  :                 tbs->first   = tb;

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  000b2	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 646  :                 tbs->current = tb;

  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000bb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  000c0	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 647  :             }

  000c4	eb 20		 jmp	 SHORT $LN9@append_dat
$LN8@append_dat:

; 648  :             else /* No, chain to previous */
; 649  :             {
; 650  :                 tbs->current->next = tb;

  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000cb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  000d4	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 651  :                 tbs->current       = tb;

  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  000e2	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN9@append_dat:

; 652  :             }
; 653  : 
; 654  :             /* Track number of blocks in chain */
; 655  :             tbs->blk_count++;

  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  000eb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000ef	48 ff c0	 inc	 rax
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  000f7	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 656  : 
; 657  :             /* Allocate room for the actual tape block */
; 658  :             if (!(tb->data = malloc( tbs->hdrsz + tbs->blksz )))

  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  00100	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00104	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  00109	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0010d	48 8b c8	 mov	 rcx, rax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00116	48 89 44 24 30	 mov	 QWORD PTR tv94[rsp], rax
  0011b	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv94[rsp]
  00125	48 89 08	 mov	 QWORD PTR [rax], rcx
  00128	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv94[rsp], 0
  0012e	75 0a		 jne	 SHORT $LN10@append_dat

; 659  :                 return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 28 01 00 00	 jmp	 $LN1@append_dat
$LN10@append_dat:

; 660  : 
; 661  :             /* Initialize block header and clear remainder */
; 662  :             memcpy( tb->data, tbs->hdr, tbs->hdrsz );

  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  0013f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  00144	48 8b 54 24 60	 mov	 rdx, QWORD PTR tbs$[rsp]
  00149	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  0014c	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0014f	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00153	f3 a4		 rep movsb

; 663  :             memset( tb->data + tbs->hdrsz, 0, tbs->blksz );

  00155	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  0015a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  00162	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00166	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  0016b	48 8b f8	 mov	 rdi, rax
  0016e	33 c0		 xor	 eax, eax
  00170	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00174	f3 aa		 rep stosb

; 664  : 
; 665  :             /* Initialize the current tape blocks size (i.e. how much
; 666  :                actual data it currently holds: just hdr at the moment)
; 667  :             */
; 668  :             tb->sz = tbs->hdrsz; /* (just the header at the moment) */

  00176	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  0017b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  00180	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00184	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 669  :         }

  00188	eb 0e		 jmp	 SHORT $LN5@append_dat
$LN4@append_dat:

; 670  :         else
; 671  :         {
; 672  :             /* Otherwise append data to end of current block */
; 673  :             tb = tbs->current;

  0018a	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  0018f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00193	48 89 44 24 28	 mov	 QWORD PTR tb$[rsp], rax
$LN5@append_dat:

; 674  :         }
; 675  : 
; 676  :         /* Calculate how much room remains in the current tape block */
; 677  :         cpy_amount = (int) MIN( bfr_bytes, (tbs->hdrsz + tbs->blksz) - tb->sz );

  00198	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  0019d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  001a6	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  001af	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  001b3	48 39 44 24 70	 cmp	 QWORD PTR bfr_bytes$[rsp], rax
  001b8	73 0c		 jae	 SHORT $LN12@append_dat
  001ba	48 8b 44 24 70	 mov	 rax, QWORD PTR bfr_bytes$[rsp]
  001bf	48 89 44 24 38	 mov	 QWORD PTR tv165[rsp], rax
  001c4	eb 20		 jmp	 SHORT $LN13@append_dat
$LN12@append_dat:
  001c6	48 8b 44 24 60	 mov	 rax, QWORD PTR tbs$[rsp]
  001cb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tbs$[rsp]
  001d4	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  001dd	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  001e1	48 89 44 24 38	 mov	 QWORD PTR tv165[rsp], rax
$LN13@append_dat:
  001e6	8b 44 24 38	 mov	 eax, DWORD PTR tv165[rsp]
  001ea	89 44 24 20	 mov	 DWORD PTR cpy_amount$[rsp], eax

; 678  : 
; 679  :         /* Append as much data as possible to end of current block */
; 680  :         memcpy( &tb->data[ tb->sz ], &bfr[ bfr_offset ], cpy_amount );

  001ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpy_amount$[rsp]
  001f3	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR bfr_offset$[rsp]
  001f8	48 8b 54 24 68	 mov	 rdx, QWORD PTR bfr$[rsp]
  001fd	48 03 d1	 add	 rdx, rcx
  00200	48 8b ca	 mov	 rcx, rdx
  00203	48 8b 54 24 28	 mov	 rdx, QWORD PTR tb$[rsp]
  00208	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0020b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR tb$[rsp]
  00210	48 03 57 08	 add	 rdx, QWORD PTR [rdi+8]
  00214	48 8b fa	 mov	 rdi, rdx
  00217	48 8b f1	 mov	 rsi, rcx
  0021a	48 8b c8	 mov	 rcx, rax
  0021d	f3 a4		 rep movsb

; 681  : 
; 682  :         /* Update current block size, bfr offset and bytes remaining */
; 683  :         tb->sz     += cpy_amount;

  0021f	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpy_amount$[rsp]
  00224	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  00229	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0022d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tb$[rsp]
  00232	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 684  :         bfr_offset += cpy_amount;

  00236	8b 44 24 20	 mov	 eax, DWORD PTR cpy_amount$[rsp]
  0023a	8b 4c 24 24	 mov	 ecx, DWORD PTR bfr_offset$[rsp]
  0023e	03 c8		 add	 ecx, eax
  00240	8b c1		 mov	 eax, ecx
  00242	89 44 24 24	 mov	 DWORD PTR bfr_offset$[rsp], eax

; 685  :         bfr_bytes  -= cpy_amount;

  00246	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpy_amount$[rsp]
  0024b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bfr_bytes$[rsp]
  00250	48 2b c8	 sub	 rcx, rax
  00253	48 8b c1	 mov	 rax, rcx
  00256	48 89 44 24 70	 mov	 QWORD PTR bfr_bytes$[rsp], rax

; 686  :     }

  0025b	e9 bd fd ff ff	 jmp	 $LN2@append_dat
$LN3@append_dat:

; 687  : 
; 688  :     return 0;

  00260	33 c0		 xor	 eax, eax
$LN1@append_dat:

; 689  : }

  00262	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00266	5f		 pop	 rdi
  00267	5e		 pop	 rsi
  00268	c3		 ret	 0
append_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
tbs$ = 32
blksz$ = 64
modulo$ = 72
hdr$ = 80
hdrsz$ = 88
init_blocks PROC

; 597  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 598  :     TAPE_BLOCKS*  tbs;
; 599  : 
; 600  :     if (!(tbs = malloc( sizeof( TAPE_BLOCKS ))))

  00018	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00023	48 89 44 24 20	 mov	 QWORD PTR tbs$[rsp], rax
  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR tbs$[rsp], 0
  0002e	75 04		 jne	 SHORT $LN2@init_block

; 601  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 63		 jmp	 SHORT $LN1@init_block
$LN2@init_block:

; 602  : 
; 603  :     tbs->hdr        = hdr;

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  00039	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdr$[rsp]
  0003e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 604  :     tbs->hdrsz      = hdrsz;

  00041	48 63 44 24 58	 movsxd	 rax, DWORD PTR hdrsz$[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tbs$[rsp]
  0004b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 605  :     tbs->blksz      = blksz;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR blksz$[rsp]
  00059	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 606  :     tbs->blk_count  = 0;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  00062	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 607  :     tbs->blk_modulo = modulo;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR modulo$[rsp]
  00074	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 608  :     tbs->first      = NULL;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  0007d	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 609  :     tbs->current    = NULL;

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
  0008a	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 610  : 
; 611  :     return tbs;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR tbs$[rsp]
$LN1@init_block:

; 612  : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
init_blocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 32
tb$ = 40
opts$ = 64
tbs$ = 72
write_TAPE_BLOCKS PROC

; 577  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 578  :     TAPE_BLOCK* tb;
; 579  :     int rc;
; 580  : 
; 581  :     tb = tbs->first;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR tbs$[rsp]
  00013	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00017	48 89 44 24 28	 mov	 QWORD PTR tb$[rsp], rax
$LN2@write_TAPE:

; 582  : 
; 583  :     while (tb)

  0001c	48 83 7c 24 28
	00		 cmp	 QWORD PTR tb$[rsp], 0
  00022	74 42		 je	 SHORT $LN3@write_TAPE

; 584  :     {
; 585  :         if ((rc = write_TAPE_BLOCK( opts, tb, tbs->blk_modulo, tbs->hdrsz )) < 0)

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR tbs$[rsp]
  00029	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0002d	48 8b 44 24 48	 mov	 rax, QWORD PTR tbs$[rsp]
  00032	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  00036	48 8b 54 24 28	 mov	 rdx, QWORD PTR tb$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opts$[rsp]
  00040	e8 00 00 00 00	 call	 write_TAPE_BLOCK
  00045	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00049	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004e	7d 06		 jge	 SHORT $LN4@write_TAPE

; 586  :             return rc;

  00050	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00054	eb 12		 jmp	 SHORT $LN1@write_TAPE
$LN4@write_TAPE:

; 587  :         tb = tb->next;

  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR tb$[rsp]
  0005b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005f	48 89 44 24 28	 mov	 QWORD PTR tb$[rsp], rax

; 588  :     }

  00064	eb b6		 jmp	 SHORT $LN2@write_TAPE
$LN3@write_TAPE:

; 589  : 
; 590  :     return 0;

  00066	33 c0		 xor	 eax, eax
$LN1@write_TAPE:

; 591  : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
write_TAPE_BLOCKS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
sz$ = 32
opts$ = 64
tb$ = 72
mod$ = 80
hdrsz$ = 88
write_TAPE_BLOCK PROC

; 560  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 561  :     size_t  sz;
; 562  : 
; 563  :     sz = (tb->sz - hdrsz) / mod;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR tb$[rsp]
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hdrsz$[rsp]
  00022	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00026	48 2b c1	 sub	 rax, rcx
  00029	33 d2		 xor	 edx, edx
  0002b	48 f7 74 24 50	 div	 QWORD PTR mod$[rsp]
  00030	48 89 44 24 20	 mov	 QWORD PTR sz$[rsp], rax

; 564  :     if ( (tb->sz - hdrsz) % mod)

  00035	48 8b 44 24 48	 mov	 rax, QWORD PTR tb$[rsp]
  0003a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hdrsz$[rsp]
  0003f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00043	48 2b c1	 sub	 rax, rcx
  00046	33 d2		 xor	 edx, edx
  00048	48 f7 74 24 50	 div	 QWORD PTR mod$[rsp]
  0004d	48 8b c2	 mov	 rax, rdx
  00050	48 85 c0	 test	 rax, rax
  00053	74 0d		 je	 SHORT $LN2@write_TAPE

; 565  :         sz++;

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR sz$[rsp]
  0005a	48 ff c0	 inc	 rax
  0005d	48 89 44 24 20	 mov	 QWORD PTR sz$[rsp], rax
$LN2@write_TAPE:

; 566  : 
; 567  :     sz *= mod;

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR sz$[rsp]
  00067	48 0f af 44 24
	50		 imul	 rax, QWORD PTR mod$[rsp]
  0006d	48 89 44 24 20	 mov	 QWORD PTR sz$[rsp], rax

; 568  :     sz += hdrsz;

  00072	48 8b 44 24 58	 mov	 rax, QWORD PTR hdrsz$[rsp]
  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sz$[rsp]
  0007c	48 03 c8	 add	 rcx, rax
  0007f	48 8b c1	 mov	 rax, rcx
  00082	48 89 44 24 20	 mov	 QWORD PTR sz$[rsp], rax

; 569  : 
; 570  :     return tape_write_block( opts, tb->data, (int) sz );

  00087	44 8b 44 24 20	 mov	 r8d, DWORD PTR sz$[rsp]
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR tb$[rsp]
  00091	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opts$[rsp]
  00099	e8 00 00 00 00	 call	 tape_write_block

; 571  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
write_TAPE_BLOCK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv76 = 88
tv130 = 96
opts$ = 128
bfr$ = 136
sz$ = 144
tape_write_block PROC

; 536  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 537  :     int rc;
; 538  : 
; 539  :     if (opts->comp)

  00013	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0001b	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 b4 00 00
	00		 je	 $LN2@tape_write

; 540  :     {
; 541  :         if ((rc =  write_het( &opts->devblk, bfr, sz, &opts->unitstat, 0 )) < 0)

  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0002f	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  00035	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0003d	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00041	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00046	4c 8b c8	 mov	 r9, rax
  00049	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR sz$[rsp]
  00051	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR bfr$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_het
  0005f	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00063	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00068	7d 6c		 jge	 SHORT $LN4@tape_write

; 542  :             // "Error in function %s: %s"
; 543  :             FWRMSG( stderr, HHC02624, "E", "write_het()", het_error( rc ));

  0006a	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00074	48 89 44 24 58	 mov	 QWORD PTR tv76[rsp], rax
  00079	b9 02 00 00 00	 mov	 ecx, 2
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00084	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv76[rsp]
  00089	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169481
  00095	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169482
  000a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169483
  000ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169484
  000c4	ba 1f 02 00 00	 mov	 edx, 543		; 0000021fH
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169485
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_write:

; 544  :     }

  000d6	e9 b3 00 00 00	 jmp	 $LN3@tape_write
$LN2@tape_write:

; 545  :     else
; 546  :     {
; 547  :         if ((rc = write_awstape( &opts->devblk, bfr, sz, &opts->unitstat, 0 )) < 0)

  000db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000e3	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  000e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000f1	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000f5	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000fa	4c 8b c8	 mov	 r9, rax
  000fd	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR sz$[rsp]
  00105	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR bfr$[rsp]
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_awstape
  00113	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00117	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011c	7d 70		 jge	 SHORT $LN5@tape_write

; 548  :             // "Error in function %s: %s"
; 549  :             FWRMSG( stderr, HHC02624, "E", "write_awstape()", strerror( errno ));

  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00124	8b 08		 mov	 ecx, DWORD PTR [rax]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012c	48 89 44 24 60	 mov	 QWORD PTR tv130[rsp], rax
  00131	b9 02 00 00 00	 mov	 ecx, 2
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv130[rsp]
  00141	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169487
  0014d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169488
  00159	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169489
  00165	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169490
  0017c	ba 25 02 00 00	 mov	 edx, 549		; 00000225H
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169491
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_write:
$LN3@tape_write:

; 550  :     }
; 551  : 
; 552  :     return rc;

  0018e	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 553  : }

  00192	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00196	c3		 ret	 0
tape_write_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv74 = 88
tv94 = 96
opts$ = 128
tape_write_mark PROC

; 513  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 514  :     int rc;
; 515  : 
; 516  :     if (opts->comp)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00011	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00015	85 c0		 test	 eax, eax
  00017	0f 84 a2 00 00
	00		 je	 $LN2@tape_write

; 517  :     {
; 518  :         if ((rc = write_hetmark( &opts->devblk, &opts->unitstat, 0 )) < 0)

  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00025	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  0002b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00033	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_hetmark
  00043	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00047	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004c	7d 6c		 jge	 SHORT $LN4@tape_write

; 519  :             // "Error in function %s: %s"
; 520  :             FWRMSG( stderr, HHC02624, "E", "write_hetmark()", het_error( rc ));

  0004e	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00058	48 89 44 24 58	 mov	 QWORD PTR tv74[rsp], rax
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv74[rsp]
  0006d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169458
  00079	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169459
  00085	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169460
  00091	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00096	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009b	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169461
  000a8	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169462
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_write:

; 521  :     }

  000ba	e9 a1 00 00 00	 jmp	 $LN3@tape_write
$LN2@tape_write:

; 522  :     else
; 523  :     {
; 524  :         if ((rc = write_awsmark( &opts->devblk, &opts->unitstat, 0 )) < 0)

  000bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000c7	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  000cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000d5	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b d0	 mov	 rdx, rax
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_awsmark
  000e5	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  000e9	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ee	7d 70		 jge	 SHORT $LN5@tape_write

; 525  :             // "Error in function %s: %s"
; 526  :             FWRMSG( stderr, HHC02624, "E", "write_awsmark()", strerror( errno ));

  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fe	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
  00103	b9 02 00 00 00	 mov	 ecx, 2
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv94[rsp]
  00113	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169464
  0011f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169465
  0012b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169466
  00137	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	41 b9 03 00 00
	00		 mov	 r9d, 3
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169467
  0014e	ba 0e 02 00 00	 mov	 edx, 526		; 0000020eH
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169468
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_write:
$LN3@tape_write:

; 527  :     }
; 528  : 
; 529  :     return rc;

  00160	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 530  : }

  00164	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00168	c3		 ret	 0
tape_write_mark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv75 = 88
tv128 = 96
opts$ = 128
tape_read PROC

; 490  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 491  :     int rc;
; 492  : 
; 493  :     if (opts->comp)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00011	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00015	85 c0		 test	 eax, eax
  00017	0f 84 a9 00 00
	00		 je	 $LN2@tape_read

; 494  :     {
; 495  :         if ((rc = read_het( &opts->devblk, bfr, &opts->unitstat, 0 )) < 0)

  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00025	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  0002b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00033	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	4c 8b c0	 mov	 r8, rax
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:bfr
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_het
  0004a	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0004e	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00053	7d 6c		 jge	 SHORT $LN4@tape_read

; 496  :             // "Error in function %s: %s"
; 497  :             FWRMSG( stderr, HHC02624, "E", "read_het()", het_error( rc ));

  00055	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  0005f	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  00064	b9 02 00 00 00	 mov	 ecx, 2
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv75[rsp]
  00074	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169439
  00080	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169440
  0008c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169441
  00098	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169442
  000af	ba f1 01 00 00	 mov	 edx, 497		; 000001f1H
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169443
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_read:

; 498  :     }

  000c1	e9 a8 00 00 00	 jmp	 $LN3@tape_read
$LN2@tape_read:

; 499  :     else
; 500  :     {
; 501  :         if ((rc = read_awstape( &opts->devblk, bfr, &opts->unitstat, 0 )) < 0)

  000c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000ce	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  000d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000dc	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000e0	45 33 c9	 xor	 r9d, r9d
  000e3	4c 8b c0	 mov	 r8, rax
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:bfr
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_awstape
  000f3	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  000f7	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000fc	7d 70		 jge	 SHORT $LN5@tape_read

; 502  :             // "Error in function %s: %s"
; 503  :             FWRMSG( stderr, HHC02624, "E", "read_awstape()", strerror( errno ));

  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00104	8b 08		 mov	 ecx, DWORD PTR [rax]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0010c	48 89 44 24 60	 mov	 QWORD PTR tv128[rsp], rax
  00111	b9 02 00 00 00	 mov	 ecx, 2
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv128[rsp]
  00121	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169445
  0012d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169446
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169447
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169448
  0015c	ba f7 01 00 00	 mov	 edx, 503		; 000001f7H
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169449
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_read:
$LN3@tape_read:

; 504  :     }
; 505  : 
; 506  :     return rc;

  0016e	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 507  : }

  00172	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00176	c3		 ret	 0
tape_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 32
opts$ = 64
blockid$ = 72
tape_set_position PROC

; 469  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 470  :     int rc;
; 471  : 
; 472  :     if ((rc = tape_rewind( opts )) >= 0)

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opts$[rsp]
  00012	e8 00 00 00 00	 call	 tape_rewind
  00017	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  0001b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00020	7c 68		 jl	 SHORT $LN4@tape_set_p

; 473  :     {
; 474  :         opts->devblk.curfilen   =  1;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opts$[rsp]
  0002c	66 89 81 22 10
	00 00		 mov	 WORD PTR [rcx+4130], ax

; 475  :         opts->devblk.nxtblkpos  =  0;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR opts$[rsp]
  00038	48 c7 80 28 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4136], 0

; 476  :         opts->devblk.prvblkpos  = -1;

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR opts$[rsp]
  00048	48 c7 80 30 10
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+4144], -1

; 477  :         opts->devblk.blockid    =  0;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR opts$[rsp]
  00058	c7 80 24 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4132], 0
$LN2@tape_set_p:

; 478  : 
; 479  :         while (opts->devblk.blockid < blockid && rc >= 0)

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR opts$[rsp]
  00067	8b 4c 24 48	 mov	 ecx, DWORD PTR blockid$[rsp]
  0006b	39 88 24 10 00
	00		 cmp	 DWORD PTR [rax+4132], ecx
  00071	73 17		 jae	 SHORT $LN3@tape_set_p
  00073	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00078	7c 10		 jl	 SHORT $LN3@tape_set_p

; 480  :             rc = tape_fsb( opts );

  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opts$[rsp]
  0007f	e8 00 00 00 00	 call	 tape_fsb
  00084	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00088	eb d8		 jmp	 SHORT $LN2@tape_set_p
$LN3@tape_set_p:
$LN4@tape_set_p:

; 481  :     }
; 482  : 
; 483  :     return rc;

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 484  : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
tape_set_position ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
opts$ = 8
tape_get_position PROC

; 461  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 462  :     return opts->devblk.blockid;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR opts$[rsp]
  0000a	8b 80 24 10 00
	00		 mov	 eax, DWORD PTR [rax+4132]

; 463  : }

  00010	c3		 ret	 0
tape_get_position ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv74 = 88
tv94 = 96
opts$ = 128
tape_fsb PROC

; 438  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 439  :     int rc;
; 440  : 
; 441  :     if (opts->comp)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00011	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00015	85 c0		 test	 eax, eax
  00017	0f 84 a2 00 00
	00		 je	 $LN2@tape_fsb

; 442  :     {
; 443  :         if ((rc = fsb_het( &opts->devblk, &opts->unitstat, 0 )) < 0)

  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00025	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  0002b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00033	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsb_het
  00043	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00047	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004c	7d 6c		 jge	 SHORT $LN4@tape_fsb

; 444  :             // "Error in function %s: %s"
; 445  :             FWRMSG( stderr, HHC02624, "E", "fsb_het()", het_error( rc ));

  0004e	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00058	48 89 44 24 58	 mov	 QWORD PTR tv74[rsp], rax
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv74[rsp]
  0006d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169406
  00079	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169407
  00085	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169408
  00091	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00096	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009b	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169409
  000a8	ba bd 01 00 00	 mov	 edx, 445		; 000001bdH
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169410
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_fsb:

; 446  :     }

  000ba	e9 a1 00 00 00	 jmp	 $LN3@tape_fsb
$LN2@tape_fsb:

; 447  :     else
; 448  :     {
; 449  :         if ((rc = fsb_awstape( &opts->devblk, &opts->unitstat, 0 )) < 0)

  000bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000c7	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  000cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000d5	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b d0	 mov	 rdx, rax
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsb_awstape
  000e5	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  000e9	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ee	7d 70		 jge	 SHORT $LN5@tape_fsb

; 450  :             // "Error in function %s: %s"
; 451  :             FWRMSG( stderr, HHC02624, "E", "fsb_awstape()", strerror( errno ));

  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fe	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
  00103	b9 02 00 00 00	 mov	 ecx, 2
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv94[rsp]
  00113	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169412
  0011f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169413
  0012b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169414
  00137	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	41 b9 03 00 00
	00		 mov	 r9d, 3
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169415
  0014e	ba c3 01 00 00	 mov	 edx, 451		; 000001c3H
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169416
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_fsb:
$LN3@tape_fsb:

; 452  :     }
; 453  : 
; 454  :     return rc;

  00160	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 455  : }

  00164	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00168	c3		 ret	 0
tape_fsb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv74 = 88
tv94 = 96
opts$ = 128
tape_rewind PROC

; 415  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 416  :     int rc;
; 417  : 
; 418  :     if (opts->comp)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00011	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00015	85 c0		 test	 eax, eax
  00017	0f 84 a2 00 00
	00		 je	 $LN2@tape_rewin

; 419  :     {
; 420  :         if ((rc = rewind_het( &opts->devblk, &opts->unitstat, 0 )) < 0)

  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00025	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  0002b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00033	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rewind_het
  00043	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00047	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004c	7d 6c		 jge	 SHORT $LN4@tape_rewin

; 421  :             // "Error in function %s: %s"
; 422  :             FWRMSG( stderr, HHC02624, "E", "rewind_het()", het_error( rc ));

  0004e	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00058	48 89 44 24 58	 mov	 QWORD PTR tv74[rsp], rax
  0005d	b9 02 00 00 00	 mov	 ecx, 2
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv74[rsp]
  0006d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169387
  00079	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169388
  00085	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169389
  00091	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00096	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009b	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169390
  000a8	ba a6 01 00 00	 mov	 edx, 422		; 000001a6H
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169391
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_rewin:

; 423  :     }

  000ba	e9 a1 00 00 00	 jmp	 $LN3@tape_rewin
$LN2@tape_rewin:

; 424  :     else
; 425  :     {
; 426  :         if ((rc = rewind_awstape( &opts->devblk, &opts->unitstat, 0 )) < 0)

  000bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000c7	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  000cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000d5	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b d0	 mov	 rdx, rax
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rewind_awstape
  000e5	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  000e9	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ee	7d 70		 jge	 SHORT $LN5@tape_rewin

; 427  :             // "Error in function %s: %s"
; 428  :             FWRMSG( stderr, HHC02624, "E", "rewind_awstape()", strerror( errno ));

  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fe	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
  00103	b9 02 00 00 00	 mov	 ecx, 2
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv94[rsp]
  00113	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169393
  0011f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169394
  0012b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169395
  00137	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	41 b9 03 00 00
	00		 mov	 r9d, 3
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169396
  0014e	ba ac 01 00 00	 mov	 edx, 428		; 000001acH
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169397
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_rewin:
$LN3@tape_rewin:

; 429  :     }
; 430  : 
; 431  :     return rc;

  00160	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 432  : }

  00164	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00168	c3		 ret	 0
tape_rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
rc$ = 80
tv68 = 84
tv88 = 88
tv137 = 92
tv179 = 96
tv199 = 104
opts$ = 128
tape_open PROC

; 376  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 377  :     int rc;
; 378  : 
; 379  :     /* Initialize SYSBLK and DEVBLK fields for open of tape device */
; 380  : 
; 381  :     sysblk.auto_tape_create = (DUMP_VERB == opts->verb) ? 1 : 0;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00011	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00015	85 c0		 test	 eax, eax
  00017	75 0a		 jne	 SHORT $LN7@tape_open
  00019	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN8@tape_open
$LN7@tape_open:
  00023	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN8@tape_open:
  0002b	8b 44 24 54	 mov	 eax, DWORD PTR tv68[rsp]
  0002f	83 e0 01	 and	 eax, 1
  00032	c1 e0 13	 shl	 eax, 19
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003c	8b 89 94 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4756]
  00042	0f ba f1 13	 btr	 ecx, 19
  00046	0b c8		 or	 ecx, eax
  00048	8b c1		 mov	 eax, ecx
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00051	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 382  : 
; 383  :     opts->devblk.tdparms.auto_create      =  sysblk.auto_tape_create;

  00057	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00064	c1 e8 13	 shr	 eax, 19
  00067	83 e0 01	 and	 eax, 1
  0006a	83 e0 01	 and	 eax, 1
  0006d	c1 e0 0c	 shl	 eax, 12
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00078	8b 89 50 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4176]
  0007e	0f ba f1 0c	 btr	 ecx, 12
  00082	0b c8		 or	 ecx, eax
  00084	8b c1		 mov	 eax, ecx
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0008e	89 81 50 10 00
	00		 mov	 DWORD PTR [rcx+4176], eax

; 384  :     opts->devblk.tdparms.logical_readonly = !sysblk.auto_tape_create;

  00094	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000a1	c1 e8 13	 shr	 eax, 19
  000a4	83 e0 01	 and	 eax, 1
  000a7	85 c0		 test	 eax, eax
  000a9	75 0a		 jne	 SHORT $LN9@tape_open
  000ab	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000b3	eb 08		 jmp	 SHORT $LN10@tape_open
$LN9@tape_open:
  000b5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN10@tape_open:
  000bd	8b 44 24 58	 mov	 eax, DWORD PTR tv88[rsp]
  000c1	83 e0 01	 and	 eax, 1
  000c4	c1 e0 0b	 shl	 eax, 11
  000c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000cf	8b 89 50 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4176]
  000d5	0f ba f1 0b	 btr	 ecx, 11
  000d9	0b c8		 or	 ecx, eax
  000db	8b c1		 mov	 eax, ecx
  000dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  000e5	89 81 50 10 00
	00		 mov	 DWORD PTR [rcx+4176], eax

; 385  :     opts->devblk.tdparms.compress         = opts->comp;

  000eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  000f3	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  000f7	83 e0 01	 and	 eax, 1
  000fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00102	8b 89 50 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4176]
  00108	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0010b	0b c8		 or	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00117	89 81 50 10 00
	00		 mov	 DWORD PTR [rcx+4176], eax

; 386  :     opts->devblk.tdparms.method           = opts->zlib ? HETMETH_ZLIB : HETMETH_BZLIB;

  0011d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00125	0f b6 40 1b	 movzx	 eax, BYTE PTR [rax+27]
  00129	85 c0		 test	 eax, eax
  0012b	74 0a		 je	 SHORT $LN11@tape_open
  0012d	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  00135	eb 08		 jmp	 SHORT $LN12@tape_open
$LN11@tape_open:
  00137	c7 44 24 5c 02
	00 00 00	 mov	 DWORD PTR tv137[rsp], 2
$LN12@tape_open:
  0013f	8b 44 24 5c	 mov	 eax, DWORD PTR tv137[rsp]
  00143	83 e0 07	 and	 eax, 7
  00146	d1 e0		 shl	 eax, 1
  00148	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00150	8b 89 50 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4176]
  00156	83 e1 f1	 and	 ecx, -15		; fffffff1H
  00159	0b c8		 or	 ecx, eax
  0015b	8b c1		 mov	 eax, ecx
  0015d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00165	89 81 50 10 00
	00		 mov	 DWORD PTR [rcx+4176], eax

; 387  :     opts->devblk.tdparms.level            = opts->level;

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00173	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  00177	83 e0 0f	 and	 eax, 15
  0017a	c1 e0 04	 shl	 eax, 4
  0017d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00185	8b 89 50 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4176]
  0018b	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00191	0b c8		 or	 ecx, eax
  00193	8b c1		 mov	 eax, ecx
  00195	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0019d	89 81 50 10 00
	00		 mov	 DWORD PTR [rcx+4176], eax

; 388  :     opts->devblk.tdparms.chksize          = HETDFLT_CHKSIZE;

  001a3	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  001b0	66 89 81 54 10
	00 00		 mov	 WORD PTR [rcx+4180], ax

; 389  :     opts->devblk.devtype                  = 0x3590;

  001b7	b8 90 35 00 00	 mov	 eax, 13712		; 00003590H
  001bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  001c4	66 89 41 6a	 mov	 WORD PTR [rcx+106], ax

; 390  :     opts->devblk.batch                    = 1; // enable quiet flag

  001c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001d0	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  001d6	0f ba e8 0a	 bts	 eax, 10
  001da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  001e2	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 391  :     opts->devblk.quiet                    = opts->quiet;

  001e8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001f0	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  001f4	83 e0 01	 and	 eax, 1
  001f7	c1 e0 0c	 shl	 eax, 12
  001fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00202	8b 89 18 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1560]
  00208	0f ba f1 0c	 btr	 ecx, 12
  0020c	0b c8		 or	 ecx, eax
  0020e	8b c1		 mov	 eax, ecx
  00210	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00218	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 392  : 
; 393  :     STRLCPY( opts->devblk.filename, opts->tapefile );

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00226	48 05 c4 00 00
	00		 add	 rax, 196		; 000000c4H
  0022c	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00232	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0023a	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0023e	48 8b c8	 mov	 rcx, rax
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 394  : 
; 395  :     if (opts->comp)

  00247	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0024f	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00253	85 c0		 test	 eax, eax
  00255	0f 84 a2 00 00
	00		 je	 $LN2@tape_open

; 396  :     {
; 397  :         if ((rc = open_het( &opts->devblk, &opts->unitstat, 0 )) < 0)

  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00263	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  00269	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00271	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00275	45 33 c0	 xor	 r8d, r8d
  00278	48 8b d0	 mov	 rdx, rax
  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_het
  00281	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00285	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0028a	7d 6c		 jge	 SHORT $LN4@tape_open

; 398  :             // "Error in function %s: %s"
; 399  :             FWRMSG( stderr, HHC02624, "E", "open_het()", het_error( rc ));

  0028c	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_het_error
  00296	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  0029b	b9 02 00 00 00	 mov	 ecx, 2
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv179[rsp]
  002ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169368
  002b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169369
  002c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169370
  002cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  002df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169371
  002e6	ba 8f 01 00 00	 mov	 edx, 399		; 0000018fH
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169372
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@tape_open:

; 400  :     }

  002f8	e9 a1 00 00 00	 jmp	 $LN3@tape_open
$LN2@tape_open:

; 401  :     else
; 402  :     {
; 403  :         if ((rc = open_awstape( &opts->devblk, &opts->unitstat, 0 )) < 0)

  002fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00305	48 05 c0 1b 00
	00		 add	 rax, 7104		; 00001bc0H
  0030b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00313	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00317	45 33 c0	 xor	 r8d, r8d
  0031a	48 8b d0	 mov	 rdx, rax
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_awstape
  00323	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00327	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0032c	7d 70		 jge	 SHORT $LN5@tape_open

; 404  :             // "Error in function %s: %s"
; 405  :             FWRMSG( stderr, HHC02624, "E", "open_awstape()", strerror( errno ));

  0032e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00334	8b 08		 mov	 ecx, DWORD PTR [rax]
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0033c	48 89 44 24 68	 mov	 QWORD PTR tv199[rsp], rax
  00341	b9 02 00 00 00	 mov	 ecx, 2
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv199[rsp]
  00351	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169374
  0035d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00362	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169375
  00369	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  00375	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00385	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169377
  0038c	ba 95 01 00 00	 mov	 edx, 405		; 00000195H
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169378
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@tape_open:
$LN3@tape_open:

; 406  :     }
; 407  : 
; 408  :     return rc;

  0039e	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 409  : }

  003a2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003a6	c3		 ret	 0
tape_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
opts$ = 48
tape_close PROC

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 366  :     if (opts->comp)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR opts$[rsp]
  0000e	0f b6 40 1a	 movzx	 eax, BYTE PTR [rax+26]
  00012	85 c0		 test	 eax, eax
  00014	74 14		 je	 SHORT $LN2@tape_close

; 367  :         close_het( &opts->devblk );

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR opts$[rsp]
  0001b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0001f	48 8b c8	 mov	 rcx, rax
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_het
  00028	eb 12		 jmp	 SHORT $LN3@tape_close
$LN2@tape_close:

; 368  :     else
; 369  :         close_awstape( &opts->devblk );

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR opts$[rsp]
  0002f	48 83 c0 20	 add	 rax, 32			; 00000020H
  00033	48 8b c8	 mov	 rcx, rax
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_awstape
$LN3@tape_close:

; 370  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
tape_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
i$ = 80
argc$ = 84
tv130 = 88
tv297 = 92
tv364 = 96
tv413 = 104
tv418 = 112
tv166 = 120
tv224 = 128
tv279 = 136
tv395 = 144
ac$ = 176
av$ = 184
opts$ = 192
parse_parms PROC

; 159  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 160  :     int i, argc;
; 161  : 
; 162  :     /* Set default options */
; 163  :     opts->cmd   = basename( av[0] );

  00015	b8 08 00 00 00	 mov	 eax, 8
  0001a	48 6b c0 00	 imul	 rax, rax, 0
  0001e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00026	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  00030	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00038	48 89 01	 mov	 QWORD PTR [rcx], rax

; 164  :     opts->quiet = true;

  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00043	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 165  :     opts->comp  = true;

  00047	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0004f	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 166  :     opts->zlib  = true;

  00053	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0005b	c6 40 1b 01	 mov	 BYTE PTR [rax+27], 1

; 167  :     opts->level = HETDFLT_LEVEL;

  0005f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00067	c6 40 1c 04	 mov	 BYTE PTR [rax+28], 4

; 168  :     defaultcp   = query_codepage();

  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_query_codepage
  00071	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultcp, rax

; 169  : 
; 170  :     if (opts->quiet) sysblk.msglvl &= ~MLVL_VERBOSE;

  00078	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00080	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00084	85 c0		 test	 eax, eax
  00086	74 20		 je	 SHORT $LN9@parse_parm
  00088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008f	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00095	0f ba f0 1f	 btr	 eax, 31
  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a0	89 81 80 75 01
	00		 mov	 DWORD PTR [rcx+95616], eax
  000a6	eb 1e		 jmp	 SHORT $LN10@parse_parm
$LN9@parse_parm:

; 171  :     else             sysblk.msglvl |=  MLVL_VERBOSE;

  000a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000af	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000b5	0f ba e8 1f	 bts	 eax, 31
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c0	89 81 80 75 01
	00		 mov	 DWORD PTR [rcx+95616], eax
$LN10@parse_parm:

; 172  : 
; 173  :     /* Parse the options */
; 174  :     for (argc=ac, i=1; i < argc && '-' == av[i][0]; i++)

  000c6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR ac$[rsp]
  000cd	89 44 24 54	 mov	 DWORD PTR argc$[rsp], eax
  000d1	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000d9	eb 0a		 jmp	 SHORT $LN4@parse_parm
$LN2@parse_parm:
  000db	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  000df	ff c0		 inc	 eax
  000e1	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@parse_parm:
  000e5	8b 44 24 54	 mov	 eax, DWORD PTR argc$[rsp]
  000e9	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  000ed	0f 8d ac 03 00
	00		 jge	 $LN3@parse_parm
  000f3	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	48 6b c9 00	 imul	 rcx, rcx, 0
  00101	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  00109	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0010d	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00111	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00114	0f 85 85 03 00
	00		 jne	 $LN3@parse_parm

; 175  :     {
; 176  :         switch (av[i][1])

  0011a	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	48 6b c9 01	 imul	 rcx, rcx, 1
  00128	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  00130	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00134	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00138	89 44 24 58	 mov	 DWORD PTR tv130[rsp], eax
  0013c	8b 44 24 58	 mov	 eax, DWORD PTR tv130[rsp]
  00140	83 e8 62	 sub	 eax, 98			; 00000062H
  00143	89 44 24 58	 mov	 DWORD PTR tv130[rsp], eax
  00147	83 7c 24 58 18	 cmp	 DWORD PTR tv130[rsp], 24
  0014c	0f 87 eb 01 00
	00		 ja	 $LN19@parse_parm
  00152	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv130[rsp]
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0015e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN42@parse_parm[rcx+rax]
  00166	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@parse_parm[rcx+rax*4]
  0016d	48 03 c1	 add	 rax, rcx
  00170	ff e0		 jmp	 rax
$LN11@parse_parm:

; 177  :         {
; 178  :             case 't':
; 179  : 
; 180  :                 opts->cms = true;

  00172	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0017a	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1

; 181  :                 break;

  0017e	e9 17 03 00 00	 jmp	 $LN5@parse_parm
$LN12@parse_parm:

; 182  : 
; 183  :             case 'v':
; 184  : 
; 185  :                 opts->quiet = false;

  00183	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0018b	c6 40 19 00	 mov	 BYTE PTR [rax+25], 0

; 186  :                 sysblk.msglvl |= MLVL_VERBOSE;

  0018f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00196	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0019c	0f ba e8 1f	 bts	 eax, 31
  001a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a7	89 81 80 75 01
	00		 mov	 DWORD PTR [rcx+95616], eax

; 187  :                 break;

  001ad	e9 e8 02 00 00	 jmp	 $LN5@parse_parm
$LN13@parse_parm:

; 188  : 
; 189  :             case 'u':
; 190  : 
; 191  :                 opts->comp  = false;

  001b2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001ba	c6 40 1a 00	 mov	 BYTE PTR [rax+26], 0

; 192  :                 break;

  001be	e9 d7 02 00 00	 jmp	 $LN5@parse_parm
$LN14@parse_parm:

; 193  : 
; 194  :             case 'z':
; 195  : 
; 196  :                 opts->comp  = true;

  001c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001cb	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 197  :                 opts->zlib  = true;

  001cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001d7	c6 40 1b 01	 mov	 BYTE PTR [rax+27], 1

; 198  :                 break;

  001db	e9 ba 02 00 00	 jmp	 $LN5@parse_parm
$LN15@parse_parm:

; 199  : 
; 200  :             case 'b':
; 201  : 
; 202  :                 opts->comp  = true;

  001e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001e8	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 203  :                 opts->zlib  = false;

  001ec	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  001f4	c6 40 1b 00	 mov	 BYTE PTR [rax+27], 0

; 204  :                 break;

  001f8	e9 9d 02 00 00	 jmp	 $LN5@parse_parm
$LN16@parse_parm:

; 205  : 
; 206  :             case 'c':
; 207  : 
; 208  :                 if (!av[i+1])

  001fd	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00201	ff c0		 inc	 eax
  00203	48 98		 cdqe
  00205	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  0020d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00212	75 5d		 jne	 SHORT $LN17@parse_parm

; 209  :                 {
; 210  :                     // "%s not specified"
; 211  :                     FWRMSG( stderr, HHC02622, "E", "code page" );

  00214	b9 02 00 00 00	 mov	 ecx, 2
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169266
  00226	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169267
  00232	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169268
  0023e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169269
  00255	ba d3 00 00 00	 mov	 edx, 211		; 000000d3H
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169270
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 212  :                     return syntax();

  00267	e8 00 00 00 00	 call	 syntax
  0026c	e9 26 07 00 00	 jmp	 $LN1@parse_parm
$LN17@parse_parm:

; 213  :                 }
; 214  : 
; 215  :                 if (!valid_codepage_name( av[i+1] ))

  00271	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00275	ff c0		 inc	 eax
  00277	48 98		 cdqe
  00279	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00281	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_valid_codepage_name
  0028b	0f b6 c0	 movzx	 eax, al
  0028e	85 c0		 test	 eax, eax
  00290	0f 85 80 00 00
	00		 jne	 $LN18@parse_parm

; 216  :                 {
; 217  :                     // "Invalid %s \"%s\""
; 218  :                     FWRMSG( stderr, HHC02621, "E", "code page", av[i+1] );

  00296	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0029a	ff c0		 inc	 eax
  0029c	48 98		 cdqe
  0029e	48 89 44 24 78	 mov	 QWORD PTR tv166[rsp], rax
  002a3	b9 02 00 00 00	 mov	 ecx, 2
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ae	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  002b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv166[rsp]
  002bb	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  002bf	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169272
  002cb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169273
  002d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169274
  002e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169275
  002fa	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169276
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 219  :                     return syntax();

  0030c	e8 00 00 00 00	 call	 syntax
  00311	e9 81 06 00 00	 jmp	 $LN1@parse_parm
$LN18@parse_parm:

; 220  :                 }
; 221  : 
; 222  :                 defaultcp = av[ ++i ];

  00316	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0031a	ff c0		 inc	 eax
  0031c	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
  00320	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00325	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  0032d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00331	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultcp, rax

; 223  :                 break;

  00338	e9 5d 01 00 00	 jmp	 $LN5@parse_parm
$LN19@parse_parm:

; 224  : 
; 225  :             default:
; 226  : 
; 227  :                 if (1
; 228  :                     &&  av[i][1]
; 229  :                     &&  av[i][1] >= '1'
; 230  :                     &&  av[i][1] <= '9'
; 231  :                     && !av[i][2]

  0033d	33 c0		 xor	 eax, eax
  0033f	83 f8 01	 cmp	 eax, 1
  00342	0f 84 cf 00 00
	00		 je	 $LN20@parse_parm
  00348	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0034d	b9 01 00 00 00	 mov	 ecx, 1
  00352	48 6b c9 01	 imul	 rcx, rcx, 1
  00356	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  0035e	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00362	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00366	85 c0		 test	 eax, eax
  00368	0f 84 a9 00 00
	00		 je	 $LN20@parse_parm
  0036e	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00373	b9 01 00 00 00	 mov	 ecx, 1
  00378	48 6b c9 01	 imul	 rcx, rcx, 1
  0037c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  00384	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00388	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0038c	83 f8 31	 cmp	 eax, 49			; 00000031H
  0038f	0f 8c 82 00 00
	00		 jl	 $LN20@parse_parm
  00395	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0039a	b9 01 00 00 00	 mov	 ecx, 1
  0039f	48 6b c9 01	 imul	 rcx, rcx, 1
  003a3	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  003ab	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  003af	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  003b3	83 f8 39	 cmp	 eax, 57			; 00000039H
  003b6	7f 5f		 jg	 SHORT $LN20@parse_parm
  003b8	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  003bd	b9 01 00 00 00	 mov	 ecx, 1
  003c2	48 6b c9 02	 imul	 rcx, rcx, 2
  003c6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  003ce	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  003d2	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  003d6	85 c0		 test	 eax, eax
  003d8	75 3d		 jne	 SHORT $LN20@parse_parm

; 232  :                 )
; 233  :                 {
; 234  :                     opts->comp  = true;

  003da	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  003e2	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 235  :                     opts->level = (av[i][1] & 0x0F);

  003e6	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  003eb	b9 01 00 00 00	 mov	 ecx, 1
  003f0	48 6b c9 01	 imul	 rcx, rcx, 1
  003f4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  003fc	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00400	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00404	83 e0 0f	 and	 eax, 15
  00407	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0040f	88 41 1c	 mov	 BYTE PTR [rcx+28], al

; 236  :                     break;

  00412	e9 83 00 00 00	 jmp	 $LN5@parse_parm
$LN20@parse_parm:

; 237  :                 }
; 238  : 
; 239  :                 // "Invalid %s \"%s\""
; 240  :                 FWRMSG( stderr, HHC02621, "E", "option", av[i] );

  00417	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0041c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv224[rsp], rax
  00424	b9 02 00 00 00	 mov	 ecx, 2
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00437	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv224[rsp]
  0043f	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00443	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00448	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169279
  0044f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00454	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169280
  0045b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00460	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  00467	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00471	41 b9 03 00 00
	00		 mov	 r9d, 3
  00477	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169282
  0047e	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169283
  0048a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 241  :                 return syntax();

  00490	e8 00 00 00 00	 call	 syntax
  00495	e9 fd 04 00 00	 jmp	 $LN1@parse_parm
$LN5@parse_parm:

; 242  :         }
; 243  :     }

  0049a	e9 3c fc ff ff	 jmp	 $LN2@parse_parm
$LN3@parse_parm:

; 244  : 
; 245  :     /* Account for options just parsed */
; 246  :     argc -= (i-1);

  0049f	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  004a3	ff c8		 dec	 eax
  004a5	8b 4c 24 54	 mov	 ecx, DWORD PTR argc$[rsp]
  004a9	2b c8		 sub	 ecx, eax
  004ab	8b c1		 mov	 eax, ecx
  004ad	89 44 24 54	 mov	 DWORD PTR argc$[rsp], eax

; 247  : 
; 248  :     /* Parse the action verb */
; 249  : 
; 250  :     if (argc < 2)

  004b1	83 7c 24 54 02	 cmp	 DWORD PTR argc$[rsp], 2
  004b6	7d 5d		 jge	 SHORT $LN21@parse_parm

; 251  :     {
; 252  :         // "%s not specified"
; 253  :         FWRMSG( stderr, HHC02622, "E", "VERB" );

  004b8	b9 02 00 00 00	 mov	 ecx, 2
  004bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169285
  004ca	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169286
  004d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169287
  004e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169288
  004f9	ba fd 00 00 00	 mov	 edx, 253		; 000000fdH
  004fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169289
  00505	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 254  :         return syntax();

  0050b	e8 00 00 00 00	 call	 syntax
  00510	e9 82 04 00 00	 jmp	 $LN1@parse_parm
$LN21@parse_parm:

; 255  :     }
; 256  : 
; 257  :          if (strcasecmp( av[i], "DUMP" ) == 0) opts->verb = DUMP_VERB;

  00515	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0051a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169292
  00521	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00529	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0052d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00533	85 c0		 test	 eax, eax
  00535	75 11		 jne	 SHORT $LN22@parse_parm
  00537	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  0053f	c6 40 1d 00	 mov	 BYTE PTR [rax+29], 0
  00543	e9 e9 00 00 00	 jmp	 $LN23@parse_parm
$LN22@parse_parm:

; 258  :     else if (strcasecmp( av[i], "SCAN" ) == 0) opts->verb = SCAN_VERB;

  00548	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0054d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169295
  00554	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  0055c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00560	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00566	85 c0		 test	 eax, eax
  00568	75 11		 jne	 SHORT $LN24@parse_parm
  0056a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00572	c6 40 1d 02	 mov	 BYTE PTR [rax+29], 2
  00576	e9 b6 00 00 00	 jmp	 $LN25@parse_parm
$LN24@parse_parm:

; 259  :     else if (strcasecmp( av[i], "LOAD" ) == 0) opts->verb = LOAD_VERB;

  0057b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00580	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169298
  00587	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  0058f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00593	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00599	85 c0		 test	 eax, eax
  0059b	75 11		 jne	 SHORT $LN26@parse_parm
  0059d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  005a5	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1
  005a9	e9 83 00 00 00	 jmp	 $LN27@parse_parm
$LN26@parse_parm:

; 260  :     else
; 261  :     {
; 262  :         // "Invalid %s \"%s\""
; 263  :         FWRMSG( stderr, HHC02621, "E", "function", av[i] );

  005ae	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  005b3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  005bb	b9 02 00 00 00	 mov	 ecx, 2
  005c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  005ce	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv279[rsp]
  005d6	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  005da	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169299
  005e6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169300
  005f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169301
  005fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00603	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00608	41 b9 03 00 00
	00		 mov	 r9d, 3
  0060e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169302
  00615	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  0061a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169303
  00621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 264  :         return syntax();

  00627	e8 00 00 00 00	 call	 syntax
  0062c	e9 66 03 00 00	 jmp	 $LN1@parse_parm
$LN27@parse_parm:
$LN25@parse_parm:
$LN23@parse_parm:

; 265  :     }
; 266  : 
; 267  :     i++; /* (get past verb argument) */

  00631	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00635	ff c0		 inc	 eax
  00637	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 268  : 
; 269  :     /* Each verb has its own set of required arguments */
; 270  :     switch (opts->verb)

  0063b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00643	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00647	88 44 24 5c	 mov	 BYTE PTR tv297[rsp], al
  0064b	80 7c 24 5c 00	 cmp	 BYTE PTR tv297[rsp], 0
  00650	0f 84 b3 00 00
	00		 je	 $LN30@parse_parm
  00656	80 7c 24 5c 01	 cmp	 BYTE PTR tv297[rsp], 1
  0065b	0f 84 a8 00 00
	00		 je	 $LN31@parse_parm
  00661	80 7c 24 5c 02	 cmp	 BYTE PTR tv297[rsp], 2
  00666	74 05		 je	 SHORT $LN28@parse_parm
  00668	e9 de 01 00 00	 jmp	 $LN7@parse_parm
$LN28@parse_parm:

; 271  :     {
; 272  :         case SCAN_VERB:
; 273  : 
; 274  :             if (argc < 3)

  0066d	83 7c 24 54 03	 cmp	 DWORD PTR argc$[rsp], 3
  00672	7d 5d		 jge	 SHORT $LN29@parse_parm

; 275  :             {
; 276  :                 // "%s not specified"
; 277  :                 FWRMSG( stderr, HHC02622, "E", "tape file" );

  00674	b9 02 00 00 00	 mov	 ecx, 2
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0067f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169306
  00686	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0068b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169307
  00692	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00697	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169308
  0069e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169309
  006b5	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  006ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169310
  006c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 278  :                 return syntax();

  006c7	e8 00 00 00 00	 call	 syntax
  006cc	e9 c6 02 00 00	 jmp	 $LN1@parse_parm
$LN29@parse_parm:

; 279  :             }
; 280  : 
; 281  :             opts->tapefile = av[i++];

  006d1	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  006d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  006de	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  006e6	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  006ea	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  006ee	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  006f2	ff c0		 inc	 eax
  006f4	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 282  : 
; 283  :             /* Force use of het handler which can read het or aws */
; 284  :             opts->comp = true;

  006f8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00700	c6 40 1a 01	 mov	 BYTE PTR [rax+26], 1

; 285  :             break;

  00704	e9 42 01 00 00	 jmp	 $LN7@parse_parm
$LN30@parse_parm:
$LN31@parse_parm:

; 286  : 
; 287  :         case DUMP_VERB:
; 288  :         case LOAD_VERB:
; 289  : 
; 290  :             if (argc < 3)

  00709	83 7c 24 54 03	 cmp	 DWORD PTR argc$[rsp], 3
  0070e	7d 5d		 jge	 SHORT $LN32@parse_parm

; 291  :             {
; 292  :                 // "%s not specified"
; 293  :                 FWRMSG( stderr, HHC02622, "E", "ctlfile" );

  00710	b9 02 00 00 00	 mov	 ecx, 2
  00715	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0071b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169314
  00722	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00727	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169315
  0072e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00733	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169316
  0073a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0073f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00744	41 b9 03 00 00
	00		 mov	 r9d, 3
  0074a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169317
  00751	ba 25 01 00 00	 mov	 edx, 293		; 00000125H
  00756	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169318
  0075d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 294  :                 return syntax();

  00763	e8 00 00 00 00	 call	 syntax
  00768	e9 2a 02 00 00	 jmp	 $LN1@parse_parm
$LN32@parse_parm:

; 295  :             }
; 296  : 
; 297  :             if (argc < 4)

  0076d	83 7c 24 54 04	 cmp	 DWORD PTR argc$[rsp], 4
  00772	0f 8d 85 00 00
	00		 jge	 $LN33@parse_parm

; 298  :             {
; 299  :                 // "%s not specified"
; 300  :                 FWRMSG( stderr, HHC02622, "E",

  00778	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00780	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00784	85 c0		 test	 eax, eax
  00786	75 0e		 jne	 SHORT $LN36@parse_parm
  00788	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169320
  0078f	48 89 44 24 60	 mov	 QWORD PTR tv364[rsp], rax
  00794	eb 0c		 jmp	 SHORT $LN37@parse_parm
$LN36@parse_parm:
  00796	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169321
  0079d	48 89 44 24 60	 mov	 QWORD PTR tv364[rsp], rax
$LN37@parse_parm:
  007a2	b9 02 00 00 00	 mov	 ecx, 2
  007a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv364[rsp]
  007b2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169322
  007be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169323
  007ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  007da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169324
  007e1	ba 2d 01 00 00	 mov	 edx, 301		; 0000012dH
  007e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169325
  007ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 301  :                     DUMP_VERB == opts->verb ? "outfile" : "infile" );
; 302  :                 return syntax();

  007f3	e8 00 00 00 00	 call	 syntax
  007f8	e9 9a 01 00 00	 jmp	 $LN1@parse_parm
$LN33@parse_parm:

; 303  :             }
; 304  : 
; 305  :             opts->ctlfile  = av[i++];

  007fd	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00802	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  0080a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  00812	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00816	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0081a	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0081e	ff c0		 inc	 eax
  00820	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax

; 306  :             opts->tapefile = av[i++];

  00824	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00829	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opts$[rsp]
  00831	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR av$[rsp]
  00839	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0083d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00841	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00845	ff c0		 inc	 eax
  00847	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN7@parse_parm:

; 307  :             break;
; 308  :     }
; 309  : 
; 310  :     /* Check for any extraneous (leftover) arguments */
; 311  :     if (av[i])

  0084b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00850	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00858	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0085d	0f 84 83 00 00
	00		 je	 $LN34@parse_parm

; 312  :     {
; 313  :         // "Invalid %s \"%s\""
; 314  :         FWRMSG( stderr, HHC02621, "E", "argument", av[i] );

  00863	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00868	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv395[rsp], rax
  00870	b9 02 00 00 00	 mov	 ecx, 2
  00875	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0087b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR av$[rsp]
  00883	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv395[rsp]
  0088b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0088f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00894	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169327
  0089b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169328
  008a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169329
  008b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  008c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169330
  008ca	ba 3a 01 00 00	 mov	 edx, 314		; 0000013aH
  008cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  008d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 315  :         return syntax();

  008dc	e8 00 00 00 00	 call	 syntax
  008e1	e9 b1 00 00 00	 jmp	 $LN1@parse_parm
$LN34@parse_parm:

; 316  :     }
; 317  : 
; 318  :     // "%s tape format set to %s"
; 319  :     WRMSG( HHC02637, "I",

  008e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  008ee	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  008f2	85 c0		 test	 eax, eax
  008f4	74 0e		 je	 SHORT $LN38@parse_parm
  008f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169332
  008fd	48 89 44 24 68	 mov	 QWORD PTR tv413[rsp], rax
  00902	eb 0c		 jmp	 SHORT $LN39@parse_parm
$LN38@parse_parm:
  00904	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169333
  0090b	48 89 44 24 68	 mov	 QWORD PTR tv413[rsp], rax
$LN39@parse_parm:
  00910	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opts$[rsp]
  00918	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  0091c	85 c0		 test	 eax, eax
  0091e	75 0e		 jne	 SHORT $LN40@parse_parm
  00920	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169334
  00927	48 89 44 24 70	 mov	 QWORD PTR tv418[rsp], rax
  0092c	eb 0c		 jmp	 SHORT $LN41@parse_parm
$LN40@parse_parm:
  0092e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169335
  00935	48 89 44 24 70	 mov	 QWORD PTR tv418[rsp], rax
$LN41@parse_parm:
  0093a	b9 01 00 00 00	 mov	 ecx, 1
  0093f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00945	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv413[rsp]
  0094a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0094f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv418[rsp]
  00954	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00959	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169336
  00960	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00965	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169337
  0096c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00971	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00976	41 b9 03 00 00
	00		 mov	 r9d, 3
  0097c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169338
  00983	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00988	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169339
  0098f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 320  :         DUMP_VERB == opts->verb ? "Output" : "Input",
; 321  :         opts->cms ? "CMS TAPE" : "VMFPLC2" );
; 322  : 
; 323  :     return 0;

  00995	33 c0		 xor	 eax, eax
$LN1@parse_parm:

; 324  : }

  00997	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0099e	c3		 ret	 0
  0099f	90		 npad	 1
$LN43@parse_parm:
  009a0	00 00 00 00	 DD	 $LN15@parse_parm
  009a4	00 00 00 00	 DD	 $LN16@parse_parm
  009a8	00 00 00 00	 DD	 $LN11@parse_parm
  009ac	00 00 00 00	 DD	 $LN13@parse_parm
  009b0	00 00 00 00	 DD	 $LN12@parse_parm
  009b4	00 00 00 00	 DD	 $LN14@parse_parm
  009b8	00 00 00 00	 DD	 $LN19@parse_parm
$LN42@parse_parm:
  009bc	00		 DB	 0
  009bd	01		 DB	 1
  009be	06		 DB	 6
  009bf	06		 DB	 6
  009c0	06		 DB	 6
  009c1	06		 DB	 6
  009c2	06		 DB	 6
  009c3	06		 DB	 6
  009c4	06		 DB	 6
  009c5	06		 DB	 6
  009c6	06		 DB	 6
  009c7	06		 DB	 6
  009c8	06		 DB	 6
  009c9	06		 DB	 6
  009ca	06		 DB	 6
  009cb	06		 DB	 6
  009cc	06		 DB	 6
  009cd	06		 DB	 6
  009ce	02		 DB	 2
  009cf	03		 DB	 3
  009d0	04		 DB	 4
  009d1	06		 DB	 6
  009d2	06		 DB	 6
  009d3	06		 DB	 6
  009d4	05		 DB	 5
parse_parms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
syntax	PROC

; 130  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 131  :     WRMSG( HHC02620, "I", pgm );    // "Usage: %s ...

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pgm
  00016	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169236
  00022	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169237
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169238
  00045	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169239
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 132  :     return -1;

  00057	b8 ff ff ff ff	 mov	 eax, -1

; 133  : }

  0005c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00060	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vmfplc2.c
_TEXT	SEGMENT
opts$ = 8
verb	PROC

; 119  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 120  :     if (DUMP_VERB == opts->verb) return "DUMP";

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR opts$[rsp]
  0000a	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  0000e	85 c0		 test	 eax, eax
  00010	75 09		 jne	 SHORT $LN2@verb
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169228
  00019	eb 35		 jmp	 SHORT $LN1@verb
$LN2@verb:

; 121  :     if (LOAD_VERB == opts->verb) return "LOAD";

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR opts$[rsp]
  00020	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00024	83 f8 01	 cmp	 eax, 1
  00027	75 09		 jne	 SHORT $LN3@verb
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169230
  00030	eb 1e		 jmp	 SHORT $LN1@verb
$LN3@verb:

; 122  :     if (SCAN_VERB == opts->verb) return "SCAN";

  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR opts$[rsp]
  00037	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  0003b	83 f8 02	 cmp	 eax, 2
  0003e	75 09		 jne	 SHORT $LN4@verb
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169232
  00047	eb 07		 jmp	 SHORT $LN1@verb
$LN4@verb:

; 123  :     return "???";

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169233
$LN1@verb:

; 124  : }

  00050	c3		 ret	 0
verb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
s$ = 32
r$ = 40
result$ = 64
string$ = 72
strupper PROC

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     register char *r = result;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 159  :     register char *s = string;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 160  :     for (; *s; r++, s++)

  00022	eb 1a		 jmp	 SHORT $LN4@strupper
$LN2@strupper:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 ff c0	 inc	 rax
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@strupper:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	85 c0		 test	 eax, eax
  00048	74 16		 je	 SHORT $LN3@strupper

; 161  :     {
; 162  :         *r = asciitoupper(*s);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00052	e8 00 00 00 00	 call	 asciitoupper
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$[rsp]
  0005c	88 01		 mov	 BYTE PTR [rcx], al

; 163  :     }

  0005e	eb c4		 jmp	 SHORT $LN2@strupper
$LN3@strupper:

; 164  :     *r = 0;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 165  :     return result;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 166  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
tv84 = 32
tv73 = 36
tv93 = 40
a$ = 48
s$ = 56
string$ = 80
abbrev$ = 88
n$ = 96
strcaseabbrev PROC

; 91   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     register const char *s = string;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 93   :     register const char *a = abbrev;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 94   :     if (*a &&
; 95   :         *s &&

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 02 01 00
	00		 je	 $LN5@strcaseabb
  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 f2 00 00
	00		 je	 $LN5@strcaseabb
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00054	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00057	3b c1		 cmp	 eax, ecx
  00059	74 30		 je	 SHORT $LN6@strcaseabb
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00060	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00063	e8 00 00 00 00	 call	 asciitoupper
  00068	0f be c0	 movsx	 eax, al
  0006b	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00077	e8 00 00 00 00	 call	 asciitoupper
  0007c	0f be c0	 movsx	 eax, al
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 ae 00 00
	00		 jne	 $LN5@strcaseabb
$LN6@strcaseabb:
$LN2@strcaseabb:

; 96   :         (*a == *s ||
; 97   :         asciitoupper(*a) == asciitoupper(*s)))
; 98   :     {
; 99   :         for (;;)
; 100  :         {
; 101  :             a++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 102  :             if (!*a)

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 31		 jne	 SHORT $LN7@strcaseabb

; 103  :                 return (((uintptr_t)a - (uintptr_t)abbrev) >= n);

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	48 3b c1	 cmp	 rax, rcx
  000bb	72 0a		 jb	 SHORT $LN12@strcaseabb
  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000c5	eb 08		 jmp	 SHORT $LN13@strcaseabb
$LN12@strcaseabb:
  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN13@strcaseabb:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR tv84[rsp]
  000d3	eb 66		 jmp	 SHORT $LN1@strcaseabb
$LN7@strcaseabb:

; 104  :             s++;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 105  :             if (!*s)

  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN8@strcaseabb

; 106  :                 break;

  000ee	eb 49		 jmp	 SHORT $LN3@strcaseabb
$LN8@strcaseabb:

; 107  :             if (*a == *s)

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000fd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 02		 jne	 SHORT $LN9@strcaseabb

; 108  :                 continue;

  00104	eb 85		 jmp	 SHORT $LN2@strcaseabb
$LN9@strcaseabb:

; 109  :             if (asciitoupper(*a) != asciitoupper(*s))

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010e	e8 00 00 00 00	 call	 asciitoupper
  00113	0f be c0	 movsx	 eax, al
  00116	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00122	e8 00 00 00 00	 call	 asciitoupper
  00127	0f be c0	 movsx	 eax, al
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv93[rsp]
  0012e	3b c8		 cmp	 ecx, eax
  00130	74 02		 je	 SHORT $LN10@strcaseabb

; 110  :                 break;

  00132	eb 05		 jmp	 SHORT $LN3@strcaseabb
$LN10@strcaseabb:

; 111  :         }

  00134	e9 52 ff ff ff	 jmp	 $LN2@strcaseabb
$LN3@strcaseabb:
$LN5@strcaseabb:

; 112  :     }
; 113  :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN1@strcaseabb:

; 114  : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
strcaseabbrev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
