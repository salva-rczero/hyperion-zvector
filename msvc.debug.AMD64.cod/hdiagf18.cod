; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	cap
_DATA	SEGMENT
cap	DB	00H
	DB	00H
	DB	040H
	DB	082H
	DB	00H
	DB	061H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_diagf18_call
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	df18_ck_opts
PUBLIC	s390_diagf18_call
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	z900_diagf18_call
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
EXTRN	s370_fetch_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s370_hdiagf18_FC:PROC
EXTRN	s390_hdiagf18_FC:PROC
EXTRN	z900_hdiagf18_FC:PROC
pdata	SEGMENT
$pdata$s370_diagf18_call DD imagerel $LN11
	DD	imagerel $LN11+314
	DD	imagerel $unwind$s370_diagf18_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
pdata	SEGMENT
$pdata$df18_ck_opts DD imagerel $LN5
	DD	imagerel $LN5+133
	DD	imagerel $unwind$df18_ck_opts
$pdata$s390_diagf18_call DD imagerel $LN11
	DD	imagerel $LN11+322
	DD	imagerel $unwind$s390_diagf18_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
pdata	SEGMENT
$pdata$z900_diagf18_call DD imagerel $LN16
	DD	imagerel $LN16+478
	DD	imagerel $unwind$z900_diagf18_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_diagf18_call DD 011101H
	DD	08211H
$unwind$df18_ck_opts DD 011301H
	DD	06213H
$unwind$s390_diagf18_call DD 011101H
	DD	08211H
$unwind$z900_diagf18_call DD 011101H
	DD	0a211H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdiagf18.c
_TEXT	SEGMENT
options$ = 48
tv79 = 52
tv136 = 56
tv175 = 64
r1$ = 96
r2$ = 104
regs$ = 112
z900_diagf18_call PROC

; 175  : {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 176  : /* Guest related paramters and values                                */
; 177  : U16     options;                     /* supplied options             */
; 178  : 
; 179  : #if 0
; 180  :     if (sizeof(CPB) != 16)
; 181  :         LOGMSG( "CPB size not 8: %d\n", sizeof( CPB ));
; 182  : #endif
; 183  : 
; 184  :     /* Specification exception if Rx is not even/odd or facility not enabled */
; 185  :     if ( (!FACILITY_ENABLED( HERC_HOST_RESOURCE_ACCESS, regs )) ||

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0001a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00027	83 e0 20	 and	 eax, 32			; 00000020H
  0002a	85 c0		 test	 eax, eax
  0002c	74 0b		 je	 SHORT $LN5@z900_diagf
  0002e	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	74 0f		 je	 SHORT $LN4@z900_diagf
$LN5@z900_diagf:

; 186  :          ((r1 & 0x1) != 0)
; 187  :        )
; 188  :     {
; 189  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00039	ba 06 00 00 00	 mov	 edx, 6
  0003e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	e8 00 00 00 00	 call	 z900_program_interrupt
$LN4@z900_diagf:

; 190  :     }
; 191  : 
; 192  :     switch(regs->GR_L(r1))

  00048	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	89 44 24 34	 mov	 DWORD PTR tv79[rsp], eax
  0005d	83 7c 24 34 00	 cmp	 DWORD PTR tv79[rsp], 0
  00062	74 10		 je	 SHORT $LN6@z900_diagf
  00064	83 7c 24 34 02	 cmp	 DWORD PTR tv79[rsp], 2
  00069	0f 84 b1 00 00
	00		 je	 $LN8@z900_diagf
  0006f	e9 56 01 00 00	 jmp	 $LN10@z900_diagf
$LN6@z900_diagf:

; 193  :     {
; 194  : 
; 195  : /*--------------------------------------------------------*/
; 196  : /* Perform the Query Operation                            */
; 197  : /*--------------------------------------------------------*/
; 198  :     case QUERY:
; 199  : 
; 200  :         /* Specification exception if CPB is not on a doubleword boundary */
; 201  :         if ( (regs->GR(2) & 0x7 ) !=0 )

  00074	b8 08 00 00 00	 mov	 eax, 8
  00079	48 6b c0 02	 imul	 rax, rax, 2
  0007d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0008a	48 83 e0 07	 and	 rax, 7
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0f		 je	 SHORT $LN7@z900_diagf

; 202  :         {
; 203  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00093	ba 06 00 00 00	 mov	 edx, 6
  00098	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_diagf:

; 204  :         }
; 205  : 
; 206  :         /* Store the CPB at the designated location */
; 207  :         ARCH_DEP(wstorec)

  000a2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	74 19		 je	 SHORT $LN12@z900_diagf
  000b4	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  000b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000c6	48 89 44 24 38	 mov	 QWORD PTR tv136[rsp], rax
  000cb	eb 16		 jmp	 SHORT $LN13@z900_diagf
$LN12@z900_diagf:
  000cd	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  000d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv136[rsp], rax
$LN13@z900_diagf:
  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv136[rsp]
  000f4	48 23 c8	 and	 rcx, rax
  000f7	48 8b c1	 mov	 rax, rcx
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00104	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  0010a	4c 8b c0	 mov	 r8, rax
  0010d	b2 0f		 mov	 dl, 15
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cap
  00116	e8 00 00 00 00	 call	 z900_vstorec

; 208  :             (&cap,(BYTE)sizeof(CPB)-1,(VADR)GR_A(r2,regs),USE_REAL_ADDR,regs);
; 209  : 
; 210  :         break;

  0011b	e9 b9 00 00 00	 jmp	 $LN2@z900_diagf
$LN8@z900_diagf:

; 211  : 
; 212  : #if defined(CSOCKET)
; 213  : /*--------------------------------------------------------*/
; 214  : /* Perform Socket Function in Compatibility Mode          */
; 215  : /*--------------------------------------------------------*/
; 216  :     case CSOCKET:
; 217  : 
; 218  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 219  :         if (regs->psw.amode64)
; 220  :         {
; 221  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 222  :         }
; 223  : #endif /* defined(ESAME) */
; 224  :          break;
; 225  : 
; 226  : #endif /* defined(CSOCKET) */
; 227  : 
; 228  : #if defined(CFILE)
; 229  : /*--------------------------------------------------------*/
; 230  : /* Perform File Operation in Compatibility Mode           */
; 231  : /*--------------------------------------------------------*/
; 232  :     case CFILE:
; 233  : 
; 234  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 235  :         if (regs->psw.amode64)

  00120	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00125	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 0f		 je	 SHORT $LN9@z900_diagf

; 236  :         {
; 237  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	e8 00 00 00 00	 call	 z900_program_interrupt
$LN9@z900_diagf:

; 238  :         }
; 239  : #endif /* defined(ESAME) */
; 240  : 
; 241  :         options = df18_ck_opts

  00141	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  00145	ff c0		 inc	 eax
  00147	48 98		 cdqe
  00149	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  00156	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0015b	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00160	66 ba 9f ff	 mov	 dx, 65439		; 0000ff9fH
  00164	0f b7 c8	 movzx	 ecx, ax
  00167	e8 00 00 00 00	 call	 df18_ck_opts
  0016c	66 89 44 24 30	 mov	 WORD PTR options$[rsp], ax

; 242  :             ( (U16)regs->GR_L(r1+1) & 0x0000FFFF, (U16) COMPAT_INVALID, regs );
; 243  : 
; 244  :         /* Retrieve the Parameter Block address from Ry */
; 245  :         ARCH_DEP(hdiagf18_FC) (options, (VADR)GR_A(r2,regs), regs);

  00171	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00176	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 19		 je	 SHORT $LN14@z900_diagf
  00183	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00188	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00195	48 89 44 24 40	 mov	 QWORD PTR tv175[rsp], rax
  0019a	eb 16		 jmp	 SHORT $LN15@z900_diagf
$LN14@z900_diagf:
  0019c	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  001a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001ad	48 89 44 24 40	 mov	 QWORD PTR tv175[rsp], rax
$LN15@z900_diagf:
  001b2	0f b7 44 24 30	 movzx	 eax, WORD PTR options$[rsp]
  001b7	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  001bc	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv175[rsp]
  001c1	8b c8		 mov	 ecx, eax
  001c3	e8 00 00 00 00	 call	 z900_hdiagf18_FC

; 246  : 
; 247  :         break;

  001c8	eb 0f		 jmp	 SHORT $LN2@z900_diagf
$LN10@z900_diagf:

; 248  : 
; 249  : #endif /* defined(CFILE) */
; 250  : 
; 251  : #if defined(NSOCKET)
; 252  : /*--------------------------------------------------------*/
; 253  : /* Perform Socket Function in Native Mode                 */
; 254  : /*--------------------------------------------------------*/
; 255  :     case NSOCKET:
; 256  :         break;
; 257  : 
; 258  : #endif /* defined(NSOCKET) */
; 259  : 
; 260  : #if defined(NFILE)
; 261  : /*--------------------------------------------------------*/
; 262  : /* Perform File Operation in Native Mode                  */
; 263  : /*--------------------------------------------------------*/
; 264  :     case NFILE:
; 265  :         break;
; 266  : 
; 267  : #endif /* defined(NFILE) */
; 268  : 
; 269  :     default:
; 270  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001ca	ba 06 00 00 00	 mov	 edx, 6
  001cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	e8 00 00 00 00	 call	 z900_program_interrupt
$LN2@z900_diagf:

; 271  : 
; 272  :     } /* end switch(regs->GR_L(r1)) */
; 273  : 
; 274  : } /* end function ARCH_DEP( diagf18_call ) */

  001d9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001dd	c3		 ret	 0
z900_diagf18_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdiagf18.c
_TEXT	SEGMENT
options$ = 48
tv79 = 52
r1$ = 80
r2$ = 88
regs$ = 96
s390_diagf18_call PROC

; 175  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 176  : /* Guest related paramters and values                                */
; 177  : U16     options;                     /* supplied options             */
; 178  : 
; 179  : #if 0
; 180  :     if (sizeof(CPB) != 16)
; 181  :         LOGMSG( "CPB size not 8: %d\n", sizeof( CPB ));
; 182  : #endif
; 183  : 
; 184  :     /* Specification exception if Rx is not even/odd or facility not enabled */
; 185  :     if ( (!FACILITY_ENABLED( HERC_HOST_RESOURCE_ACCESS, regs )) ||

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0001f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00027	83 e0 20	 and	 eax, 32			; 00000020H
  0002a	85 c0		 test	 eax, eax
  0002c	74 0b		 je	 SHORT $LN5@s390_diagf
  0002e	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	74 0f		 je	 SHORT $LN4@s390_diagf
$LN5@s390_diagf:

; 186  :          ((r1 & 0x1) != 0)
; 187  :        )
; 188  :     {
; 189  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00039	ba 06 00 00 00	 mov	 edx, 6
  0003e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	e8 00 00 00 00	 call	 s390_program_interrupt
$LN4@s390_diagf:

; 190  :     }
; 191  : 
; 192  :     switch(regs->GR_L(r1))

  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	89 44 24 34	 mov	 DWORD PTR tv79[rsp], eax
  0005d	83 7c 24 34 00	 cmp	 DWORD PTR tv79[rsp], 0
  00062	74 0c		 je	 SHORT $LN6@s390_diagf
  00064	83 7c 24 34 02	 cmp	 DWORD PTR tv79[rsp], 2
  00069	74 71		 je	 SHORT $LN8@s390_diagf
  0006b	e9 be 00 00 00	 jmp	 $LN9@s390_diagf
$LN6@s390_diagf:

; 193  :     {
; 194  : 
; 195  : /*--------------------------------------------------------*/
; 196  : /* Perform the Query Operation                            */
; 197  : /*--------------------------------------------------------*/
; 198  :     case QUERY:
; 199  : 
; 200  :         /* Specification exception if CPB is not on a doubleword boundary */
; 201  :         if ( (regs->GR(2) & 0x7 ) !=0 )

  00070	b8 08 00 00 00	 mov	 eax, 8
  00075	48 6b c0 02	 imul	 rax, rax, 2
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00085	83 e0 07	 and	 eax, 7
  00088	85 c0		 test	 eax, eax
  0008a	74 0f		 je	 SHORT $LN7@s390_diagf

; 202  :         {
; 203  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0008c	ba 06 00 00 00	 mov	 edx, 6
  00091	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_diagf:

; 204  :         }
; 205  : 
; 206  :         /* Store the CPB at the designated location */
; 207  :         ARCH_DEP(wstorec)

  0009b	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  000aa	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  000b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b7	23 c2		 and	 eax, edx
  000b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000c3	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000c9	44 8b c0	 mov	 r8d, eax
  000cc	b2 0f		 mov	 dl, 15
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cap
  000d5	e8 00 00 00 00	 call	 s390_vstorec

; 208  :             (&cap,(BYTE)sizeof(CPB)-1,(VADR)GR_A(r2,regs),USE_REAL_ADDR,regs);
; 209  : 
; 210  :         break;

  000da	eb 61		 jmp	 SHORT $LN2@s390_diagf
$LN8@s390_diagf:

; 211  : 
; 212  : #if defined(CSOCKET)
; 213  : /*--------------------------------------------------------*/
; 214  : /* Perform Socket Function in Compatibility Mode          */
; 215  : /*--------------------------------------------------------*/
; 216  :     case CSOCKET:
; 217  : 
; 218  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 219  :         if (regs->psw.amode64)
; 220  :         {
; 221  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 222  :         }
; 223  : #endif /* defined(ESAME) */
; 224  :          break;
; 225  : 
; 226  : #endif /* defined(CSOCKET) */
; 227  : 
; 228  : #if defined(CFILE)
; 229  : /*--------------------------------------------------------*/
; 230  : /* Perform File Operation in Compatibility Mode           */
; 231  : /*--------------------------------------------------------*/
; 232  :     case CFILE:
; 233  : 
; 234  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 235  :         if (regs->psw.amode64)
; 236  :         {
; 237  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 238  :         }
; 239  : #endif /* defined(ESAME) */
; 240  : 
; 241  :         options = df18_ck_opts

  000dc	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  000e0	ff c0		 inc	 eax
  000e2	48 98		 cdqe
  000e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000f1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000f6	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000fb	66 ba 9f ff	 mov	 dx, 65439		; 0000ff9fH
  000ff	0f b7 c8	 movzx	 ecx, ax
  00102	e8 00 00 00 00	 call	 df18_ck_opts
  00107	66 89 44 24 30	 mov	 WORD PTR options$[rsp], ax

; 242  :             ( (U16)regs->GR_L(r1+1) & 0x0000FFFF, (U16) COMPAT_INVALID, regs );
; 243  : 
; 244  :         /* Retrieve the Parameter Block address from Ry */
; 245  :         ARCH_DEP(hdiagf18_FC) (options, (VADR)GR_A(r2,regs), regs);

  0010c	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  00111	0f b7 4c 24 30	 movzx	 ecx, WORD PTR options$[rsp]
  00116	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0011b	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00120	8b 94 c2 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+640]
  00127	e8 00 00 00 00	 call	 s390_hdiagf18_FC

; 246  : 
; 247  :         break;

  0012c	eb 0f		 jmp	 SHORT $LN2@s390_diagf
$LN9@s390_diagf:

; 248  : 
; 249  : #endif /* defined(CFILE) */
; 250  : 
; 251  : #if defined(NSOCKET)
; 252  : /*--------------------------------------------------------*/
; 253  : /* Perform Socket Function in Native Mode                 */
; 254  : /*--------------------------------------------------------*/
; 255  :     case NSOCKET:
; 256  :         break;
; 257  : 
; 258  : #endif /* defined(NSOCKET) */
; 259  : 
; 260  : #if defined(NFILE)
; 261  : /*--------------------------------------------------------*/
; 262  : /* Perform File Operation in Native Mode                  */
; 263  : /*--------------------------------------------------------*/
; 264  :     case NFILE:
; 265  :         break;
; 266  : 
; 267  : #endif /* defined(NFILE) */
; 268  : 
; 269  :     default:
; 270  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0012e	ba 06 00 00 00	 mov	 edx, 6
  00133	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	e8 00 00 00 00	 call	 s390_program_interrupt
$LN2@s390_diagf:

; 271  : 
; 272  :     } /* end switch(regs->GR_L(r1)) */
; 273  : 
; 274  : } /* end function ARCH_DEP( diagf18_call ) */

  0013d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00141	c3		 ret	 0
s390_diagf18_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdiagf18.c
_TEXT	SEGMENT
amode$ = 32
regopts$ = 64
invalid$ = 72
regs$ = 80
df18_ck_opts PROC

; 134  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 135  : U16 amode;     /* address mode requested for parameter block */
; 136  : 
; 137  :     amode = regopts & AMODE_MASK;

  00013	0f b7 44 24 40	 movzx	 eax, WORD PTR regopts$[rsp]
  00018	83 e0 70	 and	 eax, 112		; 00000070H
  0001b	66 89 44 24 20	 mov	 WORD PTR amode$[rsp], ax

; 138  :     if (
; 139  :            /* version must be specified */
; 140  :            ( (regopts & VER_MASK)==0 ) ||
; 141  :            /* version must not be higher than we support */
; 142  :            ( (regopts & VER_MASK)>DF18_VER )  ||
; 143  :            /* options are valid */
; 144  :            ( ((regopts & OPTIONS_MASK) & invalid ) != 0 ) ||

  00020	0f b7 44 24 40	 movzx	 eax, WORD PTR regopts$[rsp]
  00025	83 e0 0f	 and	 eax, 15
  00028	85 c0		 test	 eax, eax
  0002a	74 40		 je	 SHORT $LN3@df18_ck_op
  0002c	0f b7 44 24 40	 movzx	 eax, WORD PTR regopts$[rsp]
  00031	83 e0 0f	 and	 eax, 15
  00034	83 f8 01	 cmp	 eax, 1
  00037	7f 33		 jg	 SHORT $LN3@df18_ck_op
  00039	0f b7 44 24 40	 movzx	 eax, WORD PTR regopts$[rsp]
  0003e	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00043	0f b7 4c 24 48	 movzx	 ecx, WORD PTR invalid$[rsp]
  00048	23 c1		 and	 eax, ecx
  0004a	85 c0		 test	 eax, eax
  0004c	75 1e		 jne	 SHORT $LN3@df18_ck_op
  0004e	0f b7 44 24 20	 movzx	 eax, WORD PTR amode$[rsp]
  00053	83 f8 40	 cmp	 eax, 64			; 00000040H
  00056	74 23		 je	 SHORT $LN2@df18_ck_op
  00058	0f b7 44 24 20	 movzx	 eax, WORD PTR amode$[rsp]
  0005d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00060	74 19		 je	 SHORT $LN2@df18_ck_op
  00062	0f b7 44 24 20	 movzx	 eax, WORD PTR amode$[rsp]
  00067	83 f8 10	 cmp	 eax, 16
  0006a	74 0f		 je	 SHORT $LN2@df18_ck_op
$LN3@df18_ck_op:

; 145  :            /* one and only one amode requested */
; 146  :            ( !(amode==0x0040 || amode==0x0020 || amode==0x0010) )
; 147  :        )
; 148  :     {
; 149  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0006c	ba 06 00 00 00	 mov	 edx, 6
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@df18_ck_op:

; 150  :     }
; 151  :     return regopts;

  0007b	0f b7 44 24 40	 movzx	 eax, WORD PTR regopts$[rsp]

; 152  : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
df18_ck_opts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdiagf18.c
_TEXT	SEGMENT
options$ = 48
tv79 = 52
r1$ = 80
r2$ = 88
regs$ = 96
s370_diagf18_call PROC

; 175  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 176  : /* Guest related paramters and values                                */
; 177  : U16     options;                     /* supplied options             */
; 178  : 
; 179  : #if 0
; 180  :     if (sizeof(CPB) != 16)
; 181  :         LOGMSG( "CPB size not 8: %d\n", sizeof( CPB ));
; 182  : #endif
; 183  : 
; 184  :     /* Specification exception if Rx is not even/odd or facility not enabled */
; 185  :     if ( (!FACILITY_ENABLED( HERC_HOST_RESOURCE_ACCESS, regs )) ||

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0001f	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00027	83 e0 20	 and	 eax, 32			; 00000020H
  0002a	85 c0		 test	 eax, eax
  0002c	74 0b		 je	 SHORT $LN5@s370_diagf
  0002e	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	74 0f		 je	 SHORT $LN4@s370_diagf
$LN5@s370_diagf:

; 186  :          ((r1 & 0x1) != 0)
; 187  :        )
; 188  :     {
; 189  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00039	ba 06 00 00 00	 mov	 edx, 6
  0003e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	e8 00 00 00 00	 call	 s370_program_interrupt
$LN4@s370_diagf:

; 190  :     }
; 191  : 
; 192  :     switch(regs->GR_L(r1))

  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	89 44 24 34	 mov	 DWORD PTR tv79[rsp], eax
  0005d	83 7c 24 34 00	 cmp	 DWORD PTR tv79[rsp], 0
  00062	74 0c		 je	 SHORT $LN6@s370_diagf
  00064	83 7c 24 34 02	 cmp	 DWORD PTR tv79[rsp], 2
  00069	74 69		 je	 SHORT $LN8@s370_diagf
  0006b	e9 b6 00 00 00	 jmp	 $LN9@s370_diagf
$LN6@s370_diagf:

; 193  :     {
; 194  : 
; 195  : /*--------------------------------------------------------*/
; 196  : /* Perform the Query Operation                            */
; 197  : /*--------------------------------------------------------*/
; 198  :     case QUERY:
; 199  : 
; 200  :         /* Specification exception if CPB is not on a doubleword boundary */
; 201  :         if ( (regs->GR(2) & 0x7 ) !=0 )

  00070	b8 08 00 00 00	 mov	 eax, 8
  00075	48 6b c0 02	 imul	 rax, rax, 2
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00085	83 e0 07	 and	 eax, 7
  00088	85 c0		 test	 eax, eax
  0008a	74 0f		 je	 SHORT $LN7@s370_diagf

; 202  :         {
; 203  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0008c	ba 06 00 00 00	 mov	 edx, 6
  00091	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	e8 00 00 00 00	 call	 s370_program_interrupt
$LN7@s370_diagf:

; 204  :         }
; 205  : 
; 206  :         /* Store the CPB at the designated location */
; 207  :         ARCH_DEP(wstorec)

  0009b	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000bb	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  000c1	44 8b c0	 mov	 r8d, eax
  000c4	b2 0f		 mov	 dl, 15
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cap
  000cd	e8 00 00 00 00	 call	 s370_vstorec

; 208  :             (&cap,(BYTE)sizeof(CPB)-1,(VADR)GR_A(r2,regs),USE_REAL_ADDR,regs);
; 209  : 
; 210  :         break;

  000d2	eb 61		 jmp	 SHORT $LN2@s370_diagf
$LN8@s370_diagf:

; 211  : 
; 212  : #if defined(CSOCKET)
; 213  : /*--------------------------------------------------------*/
; 214  : /* Perform Socket Function in Compatibility Mode          */
; 215  : /*--------------------------------------------------------*/
; 216  :     case CSOCKET:
; 217  : 
; 218  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 219  :         if (regs->psw.amode64)
; 220  :         {
; 221  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 222  :         }
; 223  : #endif /* defined(ESAME) */
; 224  :          break;
; 225  : 
; 226  : #endif /* defined(CSOCKET) */
; 227  : 
; 228  : #if defined(CFILE)
; 229  : /*--------------------------------------------------------*/
; 230  : /* Perform File Operation in Compatibility Mode           */
; 231  : /*--------------------------------------------------------*/
; 232  :     case CFILE:
; 233  : 
; 234  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 235  :         if (regs->psw.amode64)
; 236  :         {
; 237  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 238  :         }
; 239  : #endif /* defined(ESAME) */
; 240  : 
; 241  :         options = df18_ck_opts

  000d4	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  000d8	ff c0		 inc	 eax
  000da	48 98		 cdqe
  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  000e9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000ee	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000f3	66 ba 9f ff	 mov	 dx, 65439		; 0000ff9fH
  000f7	0f b7 c8	 movzx	 ecx, ax
  000fa	e8 00 00 00 00	 call	 df18_ck_opts
  000ff	66 89 44 24 30	 mov	 WORD PTR options$[rsp], ax

; 242  :             ( (U16)regs->GR_L(r1+1) & 0x0000FFFF, (U16) COMPAT_INVALID, regs );
; 243  : 
; 244  :         /* Retrieve the Parameter Block address from Ry */
; 245  :         ARCH_DEP(hdiagf18_FC) (options, (VADR)GR_A(r2,regs), regs);

  00104	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  00109	0f b7 4c 24 30	 movzx	 ecx, WORD PTR options$[rsp]
  0010e	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  00113	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00118	8b 94 c2 80 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+640]
  0011f	e8 00 00 00 00	 call	 s370_hdiagf18_FC

; 246  : 
; 247  :         break;

  00124	eb 0f		 jmp	 SHORT $LN2@s370_diagf
$LN9@s370_diagf:

; 248  : 
; 249  : #endif /* defined(CFILE) */
; 250  : 
; 251  : #if defined(NSOCKET)
; 252  : /*--------------------------------------------------------*/
; 253  : /* Perform Socket Function in Native Mode                 */
; 254  : /*--------------------------------------------------------*/
; 255  :     case NSOCKET:
; 256  :         break;
; 257  : 
; 258  : #endif /* defined(NSOCKET) */
; 259  : 
; 260  : #if defined(NFILE)
; 261  : /*--------------------------------------------------------*/
; 262  : /* Perform File Operation in Native Mode                  */
; 263  : /*--------------------------------------------------------*/
; 264  :     case NFILE:
; 265  :         break;
; 266  : 
; 267  : #endif /* defined(NFILE) */
; 268  : 
; 269  :     default:
; 270  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00126	ba 06 00 00 00	 mov	 edx, 6
  0012b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	e8 00 00 00 00	 call	 s370_program_interrupt
$LN2@s370_diagf:

; 271  : 
; 272  :     } /* end switch(regs->GR_L(r1)) */
; 273  : 
; 274  : } /* end function ARCH_DEP( diagf18_call ) */

  00135	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00139	c3		 ret	 0
s370_diagf18_call ENDP
_TEXT	ENDS
END
