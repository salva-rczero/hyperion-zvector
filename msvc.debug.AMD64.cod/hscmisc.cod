; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG195236 DB	'Device Status    ', 00H
	ORG $+6
$SG195237 DB	'Unit Status      ', 00H
	ORG $+2
$SG195433 DB	'0', 00H
	ORG $+2
$SG195238 DB	'Subchannel Status', 00H
	ORG $+2
$SG195434 DB	'1', 00H
	ORG $+2
$SG195435 DB	'MONIT', 00H
	ORG $+2
$SG195436 DB	'SUBCH', 00H
	ORG $+2
$SG195437 DB	'CHPID', 00H
	ORG $+2
$SG195438 DB	'5', 00H
	ORG $+2
$SG195439 DB	'6', 00H
	ORG $+2
$SG195440 DB	'7', 00H
	ORG $+2
$SG195441 DB	'8', 00H
	ORG $+2
$SG195442 DB	'CAF', 00H
$SG195443 DB	'10', 00H
	ORG $+1
$SG195444 DB	'CSS', 00H
$SG195445 DB	'NULL', 00H
	ORG $+3
$SG195446 DB	'AVAIL', 00H
	ORG $+2
$SG195447 DB	'INIT', 00H
	ORG $+3
$SG195448 DB	'TEMP', 00H
	ORG $+3
$SG195449 DB	'ALERT', 00H
	ORG $+2
$SG195450 DB	'ABORT', 00H
	ORG $+2
$SG195451 DB	'ERROR', 00H
	ORG $+2
$SG195452 DB	'RESET', 00H
	ORG $+2
$SG195453 DB	'MODFY', 00H
	ORG $+2
$SG195454 DB	'9', 00H
	ORG $+2
$SG195455 DB	'RSTRD', 00H
	ORG $+2
$SG195492 DB	'00', 00H
	ORG $+1
$SG195493 DB	'RD', 00H
	ORG $+1
$SG195494 DB	'WR', 00H
	ORG $+1
$SG195495 DB	'BW', 00H
	ORG $+1
$SG195496 DB	'HA', 00H
	ORG $+1
$SG195497 DB	'ST', 00H
	ORG $+1
$SG195498 DB	'CL', 00H
	ORG $+1
$SG195499 DB	'11', 00H
	ORG $+1
$SG195554 DB	'UNUSED', 00H
	ORG $+1
$SG195555 DB	'NEQ', 00H
$SG195556 DB	'GENEQ', 00H
	ORG $+2
$SG195557 DB	'NED', 00H
$SG195580 DB	'NEXT', 00H
	ORG $+3
$SG195581 DB	'UNIQUE', 00H
	ORG $+1
$SG195582 DB	'NODE', 00H
	ORG $+3
$SG195583 DB	'CODE3', 00H
	ORG $+2
$SG195584 DB	'UNSPEC', 00H
	ORG $+1
$SG195585 DB	'DEVICE', 00H
	ORG $+1
$SG195586 DB	'CTLUNIT', 00H
$SG195587 DB	'UNKNOWN', 00H
$SG195588 DB	'DASD', 00H
	ORG $+3
$SG195589 DB	'TAPE', 00H
	ORG $+3
$SG195590 DB	'READER', 00H
	ORG $+1
$SG195591 DB	'PUNCH', 00H
	ORG $+2
$SG195592 DB	'PRINTER', 00H
$SG195593 DB	'COMM', 00H
	ORG $+3
$SG195594 DB	'DISPLAY', 00H
$SG195595 DB	'CONSOLE', 00H
$SG195596 DB	'CTCA', 00H
	ORG $+3
$SG195597 DB	'SWITCH', 00H
	ORG $+1
$SG195598 DB	'PROTO', 00H
	ORG $+2
$SG195721 DB	'UNKNOWN', 00H
$SG195722 DB	'CHPATH', 00H
	ORG $+1
$SG195723 DB	'CTCA', 00H
	ORG $+3
$SG195724 DB	'VALID', 00H
	ORG $+2
$SG195725 DB	'UNSURE', 00H
	ORG $+1
$SG195726 DB	'INVALID', 00H
$SG195727 DB	'3', 00H
	ORG $+2
$SG195728 DB	'4', 00H
	ORG $+2
$SG195729 DB	'5', 00H
	ORG $+2
$SG195730 DB	'6', 00H
	ORG $+2
$SG195731 DB	'7', 00H
	ORG $+2
$SG195735 DB	'READER', 00H
	ORG $+1
$SG195779 DB	'IIL', 00H
$SG195732 DB	'UNKNOWN', 00H
$SG195733 DB	'DASD', 00H
	ORG $+3
$SG195734 DB	'TAPE', 00H
	ORG $+3
$SG195736 DB	'PUNCH', 00H
	ORG $+2
$SG195737 DB	'PRINTER', 00H
$SG195738 DB	'COMM', 00H
	ORG $+3
$SG195739 DB	'DISPLAY', 00H
$SG195740 DB	'CONSOLE', 00H
$SG195741 DB	'CTCA', 00H
	ORG $+3
$SG195742 DB	'SWITCH', 00H
	ORG $+1
$SG195743 DB	'PROTO', 00H
	ORG $+2
$SG195780 DB	'MODEP', 00H
	ORG $+2
$SG195781 DB	'2', 00H
	ORG $+2
$SG195782 DB	'3', 00H
	ORG $+2
$SG195783 DB	'4', 00H
	ORG $+2
$SG195784 DB	'5', 00H
	ORG $+2
$SG195785 DB	'6', 00H
	ORG $+2
$SG195786 DB	'7', 00H
	ORG $+2
$SG195836 DB	'RCD', 00H
$SG195837 DB	'SII', 00H
$SG195838 DB	'RNI', 00H
$SG195839 DB	'3  ', 00H
$SG195840 DB	'4  ', 00H
$SG195841 DB	'5  ', 00H
$SG195842 DB	'6  ', 00H
$SG195843 DB	'7  ', 00H
$SG195844 DB	'8  ', 00H
$SG195845 DB	'9  ', 00H
$SG195846 DB	'10 ', 00H
$SG195847 DB	'11 ', 00H
$SG195848 DB	'12 ', 00H
$SG195849 DB	'13 ', 00H
$SG195850 DB	'14 ', 00H
$SG195851 DB	'15 ', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?numrsc@?1??FormatCRW@@9@9 DB 0cH			; `FormatCRW'::`2'::numrsc
?numerc@?1??FormatCRW@@9@9 DB 0bH			; `FormatCRW'::`2'::numerc
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	s370_display_inst
PUBLIC	s370_display_pgmint_inst
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	herc_system
PUBLIC	do_shutdown
PUBLIC	insttrace_all
PUBLIC	display_gregs
PUBLIC	display_fregs
PUBLIC	display_vregs
PUBLIC	display_cregs
PUBLIC	display_aregs
PUBLIC	display_subchannel
PUBLIC	display_inst_regs
PUBLIC	FormatCRW
PUBLIC	FormatSCL
PUBLIC	FormatERW
PUBLIC	FormatESW
PUBLIC	parse_range
PUBLIC	copy_regs
PUBLIC	FormatSID
PUBLIC	FormatRCD
PUBLIC	FormatRNI
PUBLIC	s370_virt_to_real
PUBLIC	s390_virt_to_real
PUBLIC	z900_virt_to_real
PUBLIC	get_connected_client
PUBLIC	alter_display_real_or_abs
PUBLIC	alter_display_virt
PUBLIC	disasm_stor
PUBLIC	s390_display_inst
PUBLIC	z900_display_inst
PUBLIC	s370_display_guest_inst
PUBLIC	s390_display_guest_inst
PUBLIC	z900_display_guest_inst
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__get_storage_key
PUBLIC	s390_display_pgmint_inst
PUBLIC	s390__get_storage_key
PUBLIC	z900_display_pgmint_inst
PUBLIC	z900__get_storage_key
PUBLIC	FormatSDC
PUBLIC	FormatNED
PUBLIC	FormatNEQ
PUBLIC	FormatND
PUBLIC	FormatNQ
PUBLIC	FormatCIW
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp_isgraph:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_test_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_idx_snprintf:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_PIC2Name:PROC
EXTRN	__imp_tf_2269:PROC
EXTRN	__imp_tf_2270:PROC
EXTRN	__imp_tf_2271:PROC
EXTRN	__imp_tf_2272:PROC
EXTRN	__imp_tf_2276:PROC
EXTRN	__imp_tf_2277:PROC
EXTRN	__imp_tf_2324:PROC
EXTRN	__imp_tf_2326:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_socket_deinit:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_poor_mans_fork:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_hdl_atexit:PROC
EXTRN	iprint_router_func:PROC
EXTRN	copy_psw:PROC
EXTRN	can_signal_quiesce:PROC
EXTRN	signal_quiesce:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__imp_hexdumpew:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_setjmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_daemon_task:QWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169775 DB	01H DUP (?)
$SG170337 DB	01H DUP (?)
$SG170379 DB	01H DUP (?)
$SG170380 DB	01H DUP (?)
$SG170395 DB	01H DUP (?)
$SG180555 DB	01H DUP (?)
$SG181108 DB	01H DUP (?)
$SG181149 DB	01H DUP (?)
$SG181150 DB	01H DUP (?)
$SG181165 DB	01H DUP (?)
$SG194202 DB	01H DUP (?)
$SG194756 DB	01H DUP (?)
$SG194797 DB	01H DUP (?)
$SG194798 DB	01H DUP (?)
$SG194813 DB	01H DUP (?)
wait_for_quiesce_cancelled DB 01H DUP (?)
$SG195175 DB	01H DUP (?)
$SG195200 DB	01H DUP (?)
$SG195202 DB	01H DUP (?)
$SG195245 DB	01H DUP (?)
$SG195247 DB	01H DUP (?)
$SG195249 DB	01H DUP (?)
$SG195251 DB	01H DUP (?)
$SG195253 DB	01H DUP (?)
$SG195255 DB	01H DUP (?)
$SG195257 DB	01H DUP (?)
$SG195259 DB	01H DUP (?)
$SG195261 DB	01H DUP (?)
$SG195264 DB	01H DUP (?)
$SG195266 DB	01H DUP (?)
$SG195268 DB	01H DUP (?)
$SG195270 DB	01H DUP (?)
$SG195272 DB	01H DUP (?)
$SG195274 DB	01H DUP (?)
$SG195276 DB	01H DUP (?)
$SG195278 DB	01H DUP (?)
$SG195280 DB	01H DUP (?)
$SG195364 DB	01H DUP (?)
$SG195462 DB	01H DUP (?)
$SG195464 DB	01H DUP (?)
$SG195466 DB	01H DUP (?)
$SG195468 DB	01H DUP (?)
$SG195470 DB	01H DUP (?)
$SG195472 DB	01H DUP (?)
$SG195473 DB	01H DUP (?)
$SG195505 DB	01H DUP (?)
$SG195614 DB	01H DUP (?)
$SG195621 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$s370_display_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$s370_display_inst
$pdata$s370_display_pgmint_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$s370_display_pgmint_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$herc_system DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$herc_system
$pdata$do_shutdown DD imagerel $LN9
	DD	imagerel $LN9+145
	DD	imagerel $unwind$do_shutdown
$pdata$insttrace_all DD imagerel $LN9
	DD	imagerel $LN9+136
	DD	imagerel $unwind$insttrace_all
$pdata$display_gregs DD imagerel $LN11
	DD	imagerel $LN11+387
	DD	imagerel $unwind$display_gregs
$pdata$display_fregs DD imagerel $LN7
	DD	imagerel $LN7+2078
	DD	imagerel $unwind$display_fregs
$pdata$display_vregs DD imagerel $LN8
	DD	imagerel $LN8+2350
	DD	imagerel $unwind$display_vregs
$pdata$display_cregs DD imagerel $LN11
	DD	imagerel $LN11+393
	DD	imagerel $unwind$display_cregs
$pdata$display_aregs DD imagerel $LN6
	DD	imagerel $LN6+210
	DD	imagerel $unwind$display_aregs
$pdata$display_subchannel DD imagerel $LN48
	DD	imagerel $LN48+6038
	DD	imagerel $unwind$display_subchannel
$pdata$display_inst_regs DD imagerel $LN63
	DD	imagerel $LN63+2207
	DD	imagerel $unwind$display_inst_regs
$pdata$FormatCRW DD imagerel $LN26
	DD	imagerel $LN26+906
	DD	imagerel $unwind$FormatCRW
$pdata$FormatSCL DD imagerel $LN41
	DD	imagerel $LN41+1200
	DD	imagerel $unwind$FormatSCL
$pdata$FormatERW DD imagerel $LN27
	DD	imagerel $LN27+666
	DD	imagerel $unwind$FormatERW
$pdata$FormatESW DD imagerel $LN7
	DD	imagerel $LN7+242
	DD	imagerel $unwind$FormatESW
$pdata$parse_range DD imagerel $LN42
	DD	imagerel $LN42+1986
	DD	imagerel $unwind$parse_range
$pdata$copy_regs DD imagerel $LN7
	DD	imagerel $LN7+671
	DD	imagerel $unwind$copy_regs
$pdata$FormatSID DD imagerel $LN13
	DD	imagerel $LN13+674
	DD	imagerel $unwind$FormatSID
$pdata$FormatRCD DD imagerel $LN17
	DD	imagerel $LN17+463
	DD	imagerel $unwind$FormatRCD
$pdata$FormatRNI DD imagerel $LN12
	DD	imagerel $LN12+542
	DD	imagerel $unwind$FormatRNI
$pdata$s370_virt_to_real DD imagerel $LN6
	DD	imagerel $LN6+268
	DD	imagerel $unwind$s370_virt_to_real
$pdata$s390_virt_to_real DD imagerel $LN6
	DD	imagerel $LN6+268
	DD	imagerel $unwind$s390_virt_to_real
$pdata$z900_virt_to_real DD imagerel $LN6
	DD	imagerel $LN6+269
	DD	imagerel $unwind$z900_virt_to_real
$pdata$get_connected_client DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$get_connected_client
$pdata$alter_display_real_or_abs DD imagerel $LN12
	DD	imagerel $LN12+169
	DD	imagerel $unwind$alter_display_real_or_abs
$pdata$alter_display_virt DD imagerel $LN16
	DD	imagerel $LN16+262
	DD	imagerel $unwind$alter_display_virt
$pdata$disasm_stor DD imagerel $LN16
	DD	imagerel $LN16+257
	DD	imagerel $unwind$disasm_stor
$pdata$s390_display_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$s390_display_inst
$pdata$z900_display_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$z900_display_inst
$pdata$s370_display_guest_inst DD imagerel $LN12
	DD	imagerel $LN12+156
	DD	imagerel $unwind$s370_display_guest_inst
$pdata$s390_display_guest_inst DD imagerel $LN12
	DD	imagerel $LN12+156
	DD	imagerel $unwind$s390_display_guest_inst
$pdata$z900_display_guest_inst DD imagerel $LN12
	DD	imagerel $LN12+156
	DD	imagerel $unwind$z900_display_guest_inst
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$are_all_cpus_stopped_intlock_held DD imagerel are_all_cpus_stopped_intlock_held
	DD	imagerel are_all_cpus_stopped_intlock_held+118
	DD	imagerel $unwind$are_all_cpus_stopped_intlock_held
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+118
	DD	imagerel $unwind$s370__get_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s370_display_real DD imagerel s370_display_real
	DD	imagerel s370_display_real+1151
	DD	imagerel $unwind$s370_display_real
$pdata$s370_display_virt DD imagerel s370_display_virt
	DD	imagerel s370_display_virt+468
	DD	imagerel $unwind$s370_display_virt
$pdata$s370_dump_abs_page DD imagerel s370_dump_abs_page
	DD	imagerel s370_dump_abs_page+1425
	DD	imagerel $unwind$s370_dump_abs_page
$pdata$s370_disasm_stor DD imagerel s370_disasm_stor
	DD	imagerel s370_disasm_stor+1977
	DD	imagerel $unwind$s370_disasm_stor
$pdata$s370_alter_display_real_or_abs DD imagerel s370_alter_display_real_or_abs
	DD	imagerel s370_alter_display_real_or_abs+1823
	DD	imagerel $unwind$s370_alter_display_real_or_abs
$pdata$s370_bldtrans DD imagerel s370_bldtrans
	DD	imagerel s370_bldtrans+289
	DD	imagerel $unwind$s370_bldtrans
$pdata$s370_alter_display_virt DD imagerel s370_alter_display_virt
	DD	imagerel s370_alter_display_virt+2478
	DD	imagerel $unwind$s370_alter_display_virt
$pdata$s370_display_inst_adj DD imagerel s370_display_inst_adj
	DD	imagerel s370_display_inst_adj+6650
	DD	imagerel $unwind$s370_display_inst_adj
$pdata$s390_display_pgmint_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$s390_display_pgmint_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$s390__get_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_display_real DD imagerel s390_display_real
	DD	imagerel s390_display_real+1059
	DD	imagerel $unwind$s390_display_real
$pdata$s390_display_virt DD imagerel s390_display_virt
	DD	imagerel s390_display_virt+468
	DD	imagerel $unwind$s390_display_virt
$pdata$s390_dump_abs_page DD imagerel s390_dump_abs_page
	DD	imagerel s390_dump_abs_page+1282
	DD	imagerel $unwind$s390_dump_abs_page
$pdata$s390_disasm_stor DD imagerel s390_disasm_stor
	DD	imagerel s390_disasm_stor+1958
	DD	imagerel $unwind$s390_disasm_stor
$pdata$s390_alter_display_real_or_abs DD imagerel s390_alter_display_real_or_abs
	DD	imagerel s390_alter_display_real_or_abs+1823
	DD	imagerel $unwind$s390_alter_display_real_or_abs
$pdata$s390_bldtrans DD imagerel s390_bldtrans
	DD	imagerel s390_bldtrans+273
	DD	imagerel $unwind$s390_bldtrans
$pdata$s390_alter_display_virt DD imagerel s390_alter_display_virt
	DD	imagerel s390_alter_display_virt+2478
	DD	imagerel $unwind$s390_alter_display_virt
$pdata$s390_display_inst_adj DD imagerel s390_display_inst_adj
	DD	imagerel s390_display_inst_adj+6642
	DD	imagerel $unwind$s390_display_inst_adj
$pdata$z900_display_pgmint_inst DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$z900_display_pgmint_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$z900__get_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_display_real DD imagerel z900_display_real
	DD	imagerel z900_display_real+1061
	DD	imagerel $unwind$z900_display_real
$pdata$z900_display_virt DD imagerel z900_display_virt
	DD	imagerel z900_display_virt+473
	DD	imagerel $unwind$z900_display_virt
$pdata$z900_dump_abs_page DD imagerel z900_dump_abs_page
	DD	imagerel z900_dump_abs_page+1282
	DD	imagerel $unwind$z900_dump_abs_page
$pdata$z900_disasm_stor DD imagerel z900_disasm_stor
	DD	imagerel z900_disasm_stor+1960
	DD	imagerel $unwind$z900_disasm_stor
$pdata$z900_alter_display_real_or_abs DD imagerel z900_alter_display_real_or_abs
	DD	imagerel z900_alter_display_real_or_abs+1827
	DD	imagerel $unwind$z900_alter_display_real_or_abs
$pdata$z900_bldtrans DD imagerel z900_bldtrans
	DD	imagerel z900_bldtrans+273
	DD	imagerel $unwind$z900_bldtrans
$pdata$z900_alter_display_virt DD imagerel z900_alter_display_virt
	DD	imagerel z900_alter_display_virt+2486
	DD	imagerel $unwind$z900_alter_display_virt
$pdata$z900_display_inst_adj DD imagerel z900_display_inst_adj
	DD	imagerel z900_display_inst_adj+7075
	DD	imagerel $unwind$z900_display_inst_adj
$pdata$is_guest_quiesced DD imagerel is_guest_quiesced
	DD	imagerel is_guest_quiesced+53
	DD	imagerel $unwind$is_guest_quiesced
$pdata$wait_for_guest_to_quiesce DD imagerel wait_for_guest_to_quiesce
	DD	imagerel wait_for_guest_to_quiesce+252
	DD	imagerel $unwind$wait_for_guest_to_quiesce
$pdata$cancel_wait_for_guest_quiesce DD imagerel cancel_wait_for_guest_quiesce
	DD	imagerel cancel_wait_for_guest_quiesce+51
	DD	imagerel $unwind$cancel_wait_for_guest_quiesce
$pdata$do_shutdown_now DD imagerel do_shutdown_now
	DD	imagerel do_shutdown_now+727
	DD	imagerel $unwind$do_shutdown_now
$pdata$do_shutdown_wait DD imagerel do_shutdown_wait
	DD	imagerel do_shutdown_wait+103
	DD	imagerel $unwind$do_shutdown_wait
$pdata$display_regs32 DD imagerel display_regs32
	DD	imagerel display_regs32+553
	DD	imagerel $unwind$display_regs32
$pdata$display_regs64 DD imagerel display_regs64
	DD	imagerel display_regs64+618
	DD	imagerel $unwind$display_regs64
$pdata$sdcchar DD imagerel sdcchar
	DD	imagerel sdcchar+69
	DD	imagerel $unwind$sdcchar
$pdata$FormatSDC DD imagerel $LN7
	DD	imagerel $LN7+1418
	DD	imagerel $unwind$FormatSDC
$pdata$FormatNED DD imagerel $LN29
	DD	imagerel $LN29+1182
	DD	imagerel $unwind$FormatNED
$pdata$FormatNEQ DD imagerel $LN7
	DD	imagerel $LN7+1588
	DD	imagerel $unwind$FormatNEQ
$pdata$FormatBytes DD imagerel FormatBytes
	DD	imagerel FormatBytes+151
	DD	imagerel $unwind$FormatBytes
$pdata$FormatND DD imagerel $LN22
	DD	imagerel $LN22+819
	DD	imagerel $unwind$FormatND
$pdata$FormatNQ DD imagerel $LN7
	DD	imagerel $LN7+1454
	DD	imagerel $unwind$FormatNQ
$pdata$FormatCIW DD imagerel $LN9
	DD	imagerel $LN9+471
	DD	imagerel $unwind$FormatCIW
pdata	ENDS
_DATA	SEGMENT
$SG169728 DB	'%s', 00H
guest_is_quiesced DB 01H
$SG169741 DB	'%s', 00H
	ORG $+1
$SG169730 DB	'R:%16.16llX:', 00H
	ORG $+3
$SG169736 DB	'A:%16.16llX Guest real address is not valid', 00H
$SG169810 DB	'E', 00H
	ORG $+2
$SG169737 DB	'A:%16.16llX:', 00H
	ORG $+3
$SG169740 DB	' Real address is not valid', 00H
	ORG $+1
$SG169819 DB	'E', 00H
	ORG $+2
$SG169742 DB	'K:%2.2X=', 00H
	ORG $+3
$SG169743 DB	'%2.2X', 00H
	ORG $+2
$SG169823 DB	'E', 00H
	ORG $+2
$SG169747 DB	'%-36.36s %-16.16s', 00H
	ORG $+2
$SG169831 DB	'E', 00H
	ORG $+2
$SG169773 DB	'%sR:%8.8X:', 00H
	ORG $+1
$SG169837 DB	'I', 00H
	ORG $+2
$SG169774 DB	'%sV:%8.8X:R:%16.16llX:', 00H
	ORG $+1
$SG169776 DB	'%s%c:%8.8X:', 00H
$SG169841 DB	'I', 00H
	ORG $+2
$SG169777 DB	' Translation exception %4.4hX (%s)', 00H
	ORG $+1
$SG169886 DB	'E', 00H
	ORG $+2
$SG169804 DB	'HHC02290', 00H
	ORG $+3
$SG169896 DB	'I', 00H
	ORG $+2
$SG169805 DB	'HHC02291', 00H
	ORG $+3
$SG169905 DB	'I', 00H
	ORG $+2
$SG169808 DB	'invalid parameters', 00H
	ORG $+1
$SG169911 DB	'I', 00H
	ORG $+2
$SG169809 DB	'dump_abs_page()', 00H
$SG169811 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169812 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG169917 DB	'I', 00H
	ORG $+2
$SG169813 DB	'hscmisc.c', 00H
	ORG $+2
$SG169930 DB	'I', 00H
	ORG $+2
$SG169816 DB	'%c:%16.16llX  Addressing exception', 00H
	ORG $+1
$SG169995 DB	'E', 00H
	ORG $+2
$SG169820 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG169821 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG170001 DB	'E', 00H
	ORG $+2
$SG169822 DB	'hscmisc.c', 00H
	ORG $+2
$SG170009 DB	'E', 00H
	ORG $+2
$SG169824 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG169825 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG170019 DB	'E', 00H
	ORG $+2
$SG169826 DB	'hscmisc.c', 00H
	ORG $+2
$SG170024 DB	'I', 00H
	ORG $+2
$SG169827 DB	'%sI %c:', 00H
$SG169829 DB	'hexdumpew failed', 00H
	ORG $+3
$SG169928 DB	'     ', 00H
	ORG $+2
$SG170056 DB	'%s', 00H
	ORG $+1
$SG169830 DB	'dump_abs_page()', 00H
$SG169832 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169833 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG170060 DB	'%s', 00H
	ORG $+1
$SG169834 DB	'hscmisc.c', 00H
	ORG $+2
$SG170064 DB	'%s', 00H
	ORG $+1
$SG169838 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG169839 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG170068 DB	'%s', 00H
	ORG $+1
$SG169840 DB	'hscmisc.c', 00H
	ORG $+2
$SG170067 DB	'(home)', 00H
	ORG $+1
$SG170131 DB	'E', 00H
	ORG $+2
$SG169842 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG169843 DB	's370_dump_abs_page', 00H
	ORG $+1
$SG170142 DB	'E', 00H
	ORG $+2
$SG169844 DB	'hscmisc.c', 00H
	ORG $+2
$SG170148 DB	'E', 00H
	ORG $+2
$SG169887 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG170153 DB	'E', 00H
	ORG $+2
$SG169888 DB	's370_disasm_stor', 00H
	ORG $+3
$SG170162 DB	'E', 00H
	ORG $+2
$SG169889 DB	'hscmisc.c', 00H
	ORG $+2
$SG170167 DB	'E', 00H
	ORG $+2
$SG169895 DB	'Real address is not valid', 00H
	ORG $+2
$SG170172 DB	'I', 00H
	ORG $+2
$SG169897 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG169898 DB	's370_disasm_stor', 00H
	ORG $+3
$SG170289 DB	'dinst', 00H
	ORG $+2
$SG170296 DB	'I', 00H
	ORG $+2
$SG169899 DB	'hscmisc.c', 00H
	ORG $+2
$SG170311 DB	'E', 00H
	ORG $+2
$SG169904 DB	'R:%16.16llX  Storage not accessible code = %4.4X (%s)', 00H
	ORG $+2
$SG169906 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG169907 DB	's370_disasm_stor', 00H
	ORG $+3
$SG170304 DB	'SIE: ', 00H
	ORG $+2
$SG170338 DB	' %s', 00H
$SG169908 DB	'hscmisc.c', 00H
	ORG $+2
$SG170339 DB	'I', 00H
	ORG $+2
$SG169910 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+2
$SG170381 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG170382 DB	'I', 00H
	ORG $+2
$SG169912 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG169913 DB	's370_disasm_stor', 00H
	ORG $+3
$SG170373 DB	'SIE: ', 00H
	ORG $+2
$SG170396 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG170397 DB	'I', 00H
	ORG $+2
$SG169914 DB	'hscmisc.c', 00H
	ORG $+2
$SG180508 DB	'%s', 00H
	ORG $+1
$SG169916 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+2
$SG180521 DB	'%s', 00H
	ORG $+1
$SG169918 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG169919 DB	's370_disasm_stor', 00H
	ORG $+3
$SG170386 DB	'SIE: ', 00H
	ORG $+2
$SG180587 DB	'E', 00H
	ORG $+2
$SG169920 DB	'hscmisc.c', 00H
	ORG $+2
$SG180595 DB	'E', 00H
	ORG $+2
$SG169921 DB	'%c:%16.16llX  %2.2X%2.2X', 00H
	ORG $+3
$SG180523 DB	'%2.2X', 00H
	ORG $+2
$SG180599 DB	'E', 00H
	ORG $+2
$SG169924 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG180607 DB	'E', 00H
	ORG $+2
$SG169927 DB	'%2.2X%2.2X ', 00H
$SG180613 DB	'I', 00H
	ORG $+2
$SG169929 DB	'         ', 00H
	ORG $+2
$SG180617 DB	'I', 00H
	ORG $+2
$SG169931 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG169932 DB	's370_disasm_stor', 00H
	ORG $+3
$SG180661 DB	'E', 00H
	ORG $+2
$SG169933 DB	'hscmisc.c', 00H
	ORG $+2
$SG180671 DB	'I', 00H
	ORG $+2
$SG169996 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG180680 DB	'I', 00H
	ORG $+2
$SG169997 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG169998 DB	'hscmisc.c', 00H
	ORG $+2
$SG180686 DB	'I', 00H
	ORG $+2
$SG170002 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG170003 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170004 DB	'hscmisc.c', 00H
	ORG $+2
$SG180692 DB	'I', 00H
	ORG $+2
$SG170010 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG170011 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170012 DB	'hscmisc.c', 00H
	ORG $+2
$SG180705 DB	'I', 00H
	ORG $+2
$SG170020 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG170021 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170022 DB	'hscmisc.c', 00H
	ORG $+2
$SG180770 DB	'E', 00H
	ORG $+2
$SG170023 DB	'A:%16.16llX  K:%2.2X', 00H
	ORG $+3
$SG170025 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG170026 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170027 DB	'hscmisc.c', 00H
	ORG $+2
$SG180776 DB	'E', 00H
	ORG $+2
$SG170029 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170030 DB	'hscmisc.c', 00H
	ORG $+6
$SG170031 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170033 DB	's370_alter_display_real_or_abs', 00H
	ORG $+1
$SG170034 DB	'hscmisc.c', 00H
	ORG $+6
$SG170063 DB	'(secondary)', 00H
$SG170336 DB	'    ', 00H
	ORG $+7
$SG170035 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170055 DB	'(dat off)', 00H
	ORG $+2
$SG180784 DB	'E', 00H
	ORG $+2
$SG170059 DB	'(primary)', 00H
	ORG $+2
$SG180794 DB	'E', 00H
	ORG $+2
$SG170069 DB	'(AR%2.2d)', 00H
	ORG $+2
$SG180799 DB	'I', 00H
	ORG $+2
$SG170132 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG180829 DB	'%s', 00H
	ORG $+1
$SG170133 DB	's370_alter_display_virt', 00H
$SG170134 DB	'hscmisc.c', 00H
	ORG $+2
$SG180833 DB	'%s', 00H
	ORG $+1
$SG170143 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG170144 DB	's370_alter_display_virt', 00H
$SG170145 DB	'hscmisc.c', 00H
	ORG $+2
$SG180837 DB	'%s', 00H
	ORG $+1
$SG170149 DB	'HHC02329%s %c:%8.8X  Translation exception %4.4hX (%s)  '
	DB	'%s', 0aH, 00H
$SG180841 DB	'%s', 00H
	ORG $+1
$SG170150 DB	's370_alter_display_virt', 00H
$SG170151 DB	'hscmisc.c', 00H
	ORG $+2
$SG180840 DB	'(home)', 00H
	ORG $+1
$SG180904 DB	'E', 00H
	ORG $+2
$SG170154 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG170155 DB	's370_alter_display_virt', 00H
$SG170156 DB	'hscmisc.c', 00H
	ORG $+2
$SG180915 DB	'E', 00H
	ORG $+2
$SG170163 DB	'HHC02329%s %c:%8.8X  Translation exception %4.4hX (%s)  '
	DB	'%s', 0aH, 00H
$SG180921 DB	'E', 00H
	ORG $+2
$SG170164 DB	's370_alter_display_virt', 00H
$SG170165 DB	'hscmisc.c', 00H
	ORG $+2
$SG180926 DB	'E', 00H
	ORG $+2
$SG170168 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG170169 DB	's370_alter_display_virt', 00H
$SG170170 DB	'hscmisc.c', 00H
	ORG $+2
$SG180935 DB	'E', 00H
	ORG $+2
$SG170171 DB	'R:%16.16llX  K:%2.2X  %s', 00H
	ORG $+3
$SG180703 DB	'     ', 00H
	ORG $+2
$SG180940 DB	'E', 00H
	ORG $+2
$SG170173 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG170174 DB	's370_alter_display_virt', 00H
$SG170175 DB	'hscmisc.c', 00H
	ORG $+2
$SG180945 DB	'I', 00H
	ORG $+2
$SG170177 DB	's370_alter_display_virt', 00H
$SG170178 DB	'hscmisc.c', 00H
	ORG $+6
$SG170179 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170181 DB	's370_alter_display_virt', 00H
$SG170182 DB	'hscmisc.c', 00H
	ORG $+6
$SG170183 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170288 DB	'hscmisc.c:832', 00H
	ORG $+2
$SG170290 DB	'hscmisc.c:834', 00H
	ORG $+2
$SG170291 DB	'hscmisc.c:838', 00H
	ORG $+2
$SG170295 DB	'Real address is not valid', 00H
	ORG $+2
$SG181067 DB	'I', 00H
	ORG $+2
$SG170297 DB	'HHC02267%s %s', 0aH, 00H
	ORG $+1
$SG170298 DB	's370_display_inst_adj', 00H
	ORG $+2
$SG170299 DB	'hscmisc.c', 00H
	ORG $+2
$SG181082 DB	'E', 00H
	ORG $+2
$SG170308 DB	'%s Instruction fetch error', 0aH, 00H
$SG181109 DB	' %s', 00H
$SG170309 DB	'HHC02269I ', 00H
	ORG $+1
$SG181110 DB	'I', 00H
	ORG $+2
$SG170312 DB	'HHC02325%s %s%s', 0aH, 00H
	ORG $+3
$SG181060 DB	'dinst', 00H
	ORG $+2
$SG181151 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG181152 DB	'I', 00H
	ORG $+2
$SG170313 DB	's370_display_inst_adj', 00H
	ORG $+2
$SG170314 DB	'hscmisc.c', 00H
	ORG $+2
$SG181166 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG181167 DB	'I', 00H
	ORG $+2
$SG170317 DB	'hscmisc.c:892', 00H
	ORG $+2
$SG170318 DB	'dinst op,ilc', 00H
	ORG $+3
$SG170320 DB	'hscmisc.c:901', 00H
	ORG $+2
$SG170321 DB	'dinst ip,IA', 00H
$SG194155 DB	'%s', 00H
	ORG $+1
$SG170324 DB	'hscmisc.c:907', 00H
	ORG $+2
$SG170325 DB	'dinst ip,IA', 00H
$SG194168 DB	'%s', 00H
	ORG $+1
$SG170328 DB	'%s%02X: ', 00H
	ORG $+3
$SG181075 DB	'SIE: ', 00H
	ORG $+2
$SG194234 DB	'E', 00H
	ORG $+2
$SG170329 DB	'PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ', 00H
	ORG $+2
$SG170330 DB	'INST=%2.2X%2.2X', 00H
$SG170332 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG194242 DB	'E', 00H
	ORG $+2
$SG170334 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG194246 DB	'E', 00H
	ORG $+2
$SG170335 DB	'        ', 00H
	ORG $+3
$SG181144 DB	'SIE: ', 00H
	ORG $+2
$SG194254 DB	'E', 00H
	ORG $+2
$SG170340 DB	'HHC02324%s %s', 0aH, 00H
	ORG $+1
$SG170364 DB	'hscmisc.c:1062', 00H
	ORG $+1
$SG170365 DB	'dinst rel1:', 00H
$SG194260 DB	'I', 00H
	ORG $+2
$SG170367 DB	'hscmisc.c:1068', 00H
	ORG $+1
$SG170368 DB	'dinst rel1=', 00H
$SG194264 DB	'I', 00H
	ORG $+2
$SG170375 DB	'%s%02X: ', 00H
	ORG $+3
$SG181156 DB	'SIE: ', 00H
	ORG $+2
$SG194308 DB	'E', 00H
	ORG $+2
$SG170383 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG170388 DB	'%s%02X: ', 00H
	ORG $+3
$SG194170 DB	'%2.2X', 00H
	ORG $+2
$SG194318 DB	'I', 00H
	ORG $+2
$SG170398 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG170406 DB	'%s%s%s%s', 00H
	ORG $+3
$SG194327 DB	'I', 00H
	ORG $+2
$SG170407 DB	's370_display_inst_adj', 00H
	ORG $+2
$SG170408 DB	'hscmisc.c', 00H
	ORG $+2
$SG194333 DB	'I', 00H
	ORG $+2
$SG170409 DB	'%s%s%s%s', 00H
	ORG $+3
$SG194339 DB	'I', 00H
	ORG $+2
$SG170410 DB	's370_display_inst_adj', 00H
	ORG $+2
$SG170411 DB	'hscmisc.c', 00H
	ORG $+2
$SG194352 DB	'I', 00H
	ORG $+2
$SG180510 DB	'R:%16.16llX:', 00H
	ORG $+3
$SG180516 DB	'A:%16.16llX Guest real address is not valid', 00H
$SG194417 DB	'E', 00H
	ORG $+2
$SG180517 DB	'A:%16.16llX:', 00H
	ORG $+3
$SG180520 DB	' Real address is not valid', 00H
	ORG $+1
$SG194423 DB	'E', 00H
	ORG $+2
$SG180522 DB	'K:%2.2X=', 00H
	ORG $+3
$SG194350 DB	'     ', 00H
	ORG $+2
$SG194431 DB	'E', 00H
	ORG $+2
$SG180527 DB	'%-36.36s %-16.16s', 00H
	ORG $+2
$SG194441 DB	'E', 00H
	ORG $+2
$SG180553 DB	'%sR:%8.8X:', 00H
	ORG $+1
$SG194446 DB	'I', 00H
	ORG $+2
$SG180554 DB	'%sV:%8.8X:R:%16.16llX:', 00H
	ORG $+1
$SG180556 DB	'%s%c:%8.8X:', 00H
$SG194476 DB	'%s', 00H
	ORG $+1
$SG180557 DB	' Translation exception %4.4hX (%s)', 00H
	ORG $+1
$SG194480 DB	'%s', 00H
	ORG $+1
$SG180581 DB	'HHC02290', 00H
	ORG $+3
$SG194484 DB	'%s', 00H
	ORG $+1
$SG180582 DB	'HHC02291', 00H
	ORG $+3
$SG194487 DB	'(home)', 00H
	ORG $+1
$SG194488 DB	'%s', 00H
	ORG $+1
$SG180585 DB	'invalid parameters', 00H
	ORG $+1
$SG194551 DB	'E', 00H
	ORG $+2
$SG180586 DB	'dump_abs_page()', 00H
$SG180588 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG180589 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194562 DB	'E', 00H
	ORG $+2
$SG180590 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194568 DB	'E', 00H
	ORG $+2
$SG180592 DB	'%c:%16.16llX  Addressing exception', 00H
	ORG $+1
$SG194573 DB	'E', 00H
	ORG $+2
$SG180596 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG180597 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194582 DB	'E', 00H
	ORG $+2
$SG180598 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194587 DB	'E', 00H
	ORG $+2
$SG180600 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG180601 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194592 DB	'I', 00H
	ORG $+2
$SG180602 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194707 DB	'dinst', 00H
	ORG $+2
$SG194714 DB	'I', 00H
	ORG $+2
$SG180603 DB	'%sI %c:', 00H
$SG180605 DB	'hexdumpew failed', 00H
	ORG $+3
$SG194722 DB	'SIE: ', 00H
	ORG $+2
$SG194729 DB	'E', 00H
	ORG $+2
$SG180606 DB	'dump_abs_page()', 00H
$SG180608 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG180609 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194757 DB	' %s', 00H
$SG180610 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194758 DB	'I', 00H
	ORG $+2
$SG180614 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG180615 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194800 DB	'I', 00H
	ORG $+2
$SG180616 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194792 DB	'SIE: ', 00H
	ORG $+2
$SG194799 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG194815 DB	'I', 00H
	ORG $+2
$SG180618 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG180619 DB	's390_dump_abs_page', 00H
	ORG $+1
$SG194905 DB	'I', 00H
	ORG $+2
$SG180620 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194804 DB	'SIE: ', 00H
	ORG $+2
$SG194814 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG194919 DB	'I', 00H
	ORG $+2
$SG180662 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG194923 DB	'I', 00H
	ORG $+2
$SG180663 DB	's390_disasm_stor', 00H
	ORG $+3
$SG194925 DB	'I', 00H
	ORG $+2
$SG180664 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194927 DB	'I', 00H
	ORG $+2
$SG180670 DB	'Real address is not valid', 00H
	ORG $+2
$SG194938 DB	'I', 00H
	ORG $+2
$SG180672 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG180673 DB	's390_disasm_stor', 00H
	ORG $+3
$SG194976 DB	0aH, 00H
	ORG $+2
$SG180674 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194977 DB	'%s', 00H
	ORG $+1
$SG180679 DB	'R:%16.16llX  Storage not accessible code = %4.4X (%s)', 00H
	ORG $+2
$SG180681 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG180682 DB	's390_disasm_stor', 00H
	ORG $+3
$SG194978 DB	'%s', 00H
	ORG $+1
$SG180683 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194982 DB	' ', 00H
	ORG $+2
$SG180685 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+2
$SG194983 DB	'%s', 00H
	ORG $+1
$SG180687 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG180688 DB	's390_disasm_stor', 00H
	ORG $+3
$SG194985 DB	0aH, 00H
	ORG $+2
$SG180689 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG194986 DB	'%s', 00H
	ORG $+1
$SG180691 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+2
$SG195013 DB	0aH, 00H
	ORG $+2
$SG180693 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG180694 DB	's390_disasm_stor', 00H
	ORG $+3
$SG195014 DB	'%s', 00H
	ORG $+1
$SG180695 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195015 DB	'%s', 00H
	ORG $+1
$SG180696 DB	'%c:%16.16llX  %2.2X%2.2X', 00H
	ORG $+3
$SG195019 DB	' ', 00H
	ORG $+2
$SG180699 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG195020 DB	'%s', 00H
	ORG $+1
$SG180702 DB	'%2.2X%2.2X ', 00H
$SG195022 DB	0aH, 00H
	ORG $+2
$SG180704 DB	'         ', 00H
	ORG $+2
$SG195023 DB	'%s', 00H
	ORG $+1
$SG180706 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG180707 DB	's390_disasm_stor', 00H
	ORG $+3
$SG195081 DB	'I', 00H
	ORG $+2
$SG180708 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195105 DB	0aH, 00H
	ORG $+2
$SG180771 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG195126 DB	'GR', 00H
	ORG $+1
$SG180772 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180773 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195127 DB	'R', 00H
	ORG $+2
$SG180777 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG180778 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180779 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195148 DB	'CR', 00H
	ORG $+1
$SG180785 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG180786 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180787 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195149 DB	'C', 00H
	ORG $+2
$SG180795 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG180796 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180797 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195164 DB	'AR', 00H
	ORG $+1
$SG180798 DB	'A:%16.16llX  K:%2.2X', 00H
	ORG $+3
$SG180800 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG180801 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180802 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195179 DB	'%s', 00H
	ORG $+1
$SG180804 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180805 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG180808 DB	's390_alter_display_real_or_abs', 00H
	ORG $+1
$SG180906 DB	's390_alter_display_virt', 00H
$SG180806 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG180809 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG180828 DB	'(dat off)', 00H
	ORG $+6
$SG180836 DB	'(secondary)', 00H
$SG181107 DB	'    ', 00H
	ORG $+7
$SG180810 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG180832 DB	'(primary)', 00H
	ORG $+2
$SG195206 DB	'%s', 00H
	ORG $+1
$SG180842 DB	'(AR%2.2d)', 00H
	ORG $+2
$SG195244 DB	'UE ', 00H
$SG180905 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+1
$SG195246 DB	'UC ', 00H
$SG180907 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195248 DB	'DE ', 00H
$SG180916 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG180917 DB	's390_alter_display_virt', 00H
$SG180918 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195250 DB	'CE ', 00H
$SG180922 DB	'HHC02329%s %c:%8.8X  Translation exception %4.4hX (%s)  '
	DB	'%s', 0aH, 00H
$SG195256 DB	'SM ', 00H
$SG180923 DB	's390_alter_display_virt', 00H
$SG180924 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195252 DB	'Busy ', 00H
	ORG $+2
$SG195263 DB	'CC ', 00H
$SG180927 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG180928 DB	's390_alter_display_virt', 00H
$SG180929 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195271 DB	'ProtC ', 00H
	ORG $+1
$SG195273 DB	'PC ', 00H
$SG180936 DB	'HHC02329%s %c:%8.8X  Translation exception %4.4hX (%s)  '
	DB	'%s', 0aH, 00H
$SG195275 DB	'IL ', 00H
$SG180937 DB	's390_alter_display_virt', 00H
$SG180938 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195312 DB	'E', 00H
	ORG $+2
$SG180941 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG180942 DB	's390_alter_display_virt', 00H
$SG180943 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195323 DB	'"', 00H
	ORG $+2
$SG180944 DB	'R:%16.16llX  K:%2.2X  %s', 00H
	ORG $+3
$SG195324 DB	'E', 00H
	ORG $+2
$SG180946 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG180947 DB	's390_alter_display_virt', 00H
$SG180948 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195330 DB	'"', 00H
	ORG $+2
$SG180950 DB	's390_alter_display_virt', 00H
$SG180951 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG180954 DB	's390_alter_display_virt', 00H
$SG180952 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG180955 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG181059 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:832', 00H
	ORG $+3
$SG181068 DB	'HHC02267%s %s', 0aH, 00H
	ORG $+1
$SG181069 DB	's390_display_inst_adj', 00H
	ORG $+2
$SG180956 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG181061 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:834', 00H
	ORG $+3
$SG181062 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:838', 00H
	ORG $+3
$SG181066 DB	'Real address is not valid', 00H
	ORG $+2
$SG195331 DB	'E', 00H
	ORG $+2
$SG181070 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195343 DB	'E', 00H
	ORG $+2
$SG181079 DB	'%s Instruction fetch error', 0aH, 00H
$SG195349 DB	'E', 00H
	ORG $+2
$SG181080 DB	'HHC02269I ', 00H
	ORG $+1
$SG195355 DB	'E', 00H
	ORG $+2
$SG181083 DB	'HHC02325%s %s%s', 0aH, 00H
	ORG $+3
$SG195365 DB	'E', 00H
	ORG $+2
$SG181084 DB	's390_display_inst_adj', 00H
	ORG $+2
$SG181085 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195372 DB	'E', 00H
	ORG $+2
$SG181088 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:892', 00H
	ORG $+3
$SG181089 DB	'dinst op,ilc', 00H
	ORG $+3
$SG181091 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:901', 00H
	ORG $+3
$SG181092 DB	'dinst ip,IA', 00H
$SG195404 DB	'E', 00H
	ORG $+2
$SG181095 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:907', 00H
	ORG $+3
$SG181096 DB	'dinst ip,IA', 00H
$SG195463 DB	'AR,', 00H
$SG181099 DB	'%s%02X: ', 00H
	ORG $+3
$SG195465 DB	'CHAIN,', 00H
	ORG $+1
$SG195474 DB	'0', 00H
	ORG $+2
$SG181100 DB	'PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ', 00H
	ORG $+2
$SG181101 DB	'INST=%2.2X%2.2X', 00H
$SG181103 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG195475 DB	'???', 00H
$SG181105 DB	'%2.2X%2.2X', 00H
	ORG $+1
$SG195476 DB	'???', 00H
$SG181106 DB	'        ', 00H
	ORG $+3
$SG195467 DB	'OFLOW,', 00H
	ORG $+1
$SG195478 DB	',', 00H
	ORG $+2
$SG181111 DB	'HHC02324%s %s', 0aH, 00H
	ORG $+1
$SG181135 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1062', 00H
	ORG $+2
$SG181136 DB	'dinst rel1:', 00H
$SG195605 DB	'%u', 00H
	ORG $+1
$SG181138 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1068', 00H
	ORG $+2
$SG181139 DB	'dinst rel1=', 00H
$SG195610 DB	'%u', 00H
	ORG $+1
$SG181146 DB	'%s%02X: ', 00H
	ORG $+3
$SG195479 DB	'(end)', 00H
	ORG $+2
$SG195615 DB	'*', 00H
	ORG $+2
$SG181153 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG181158 DB	'%s%02X: ', 00H
	ORG $+3
$SG195616 DB	' ', 00H
	ORG $+2
$SG181168 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG181176 DB	'%s%s%s%s', 00H
	ORG $+3
$SG195622 DB	'*', 00H
	ORG $+2
$SG181177 DB	's390_display_inst_adj', 00H
	ORG $+2
$SG181178 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195623 DB	' ', 00H
	ORG $+2
$SG181179 DB	'%s%s%s%s', 00H
	ORG $+3
$SG195660 DB	' ', 00H
	ORG $+2
$SG181180 DB	's390_display_inst_adj', 00H
	ORG $+2
$SG181181 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+3
$SG195694 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG195752 DB	'CSS', 00H
$SG194157 DB	'R:%16.16llX:', 00H
	ORG $+3
$SG194163 DB	'A:%16.16llX Guest real address is not valid', 00H
$SG195755 DB	'DEV', 00H
$SG194164 DB	'A:%16.16llX:', 00H
	ORG $+3
$SG194167 DB	' Real address is not valid', 00H
	ORG $+1
$SG195760 DB	'%u', 00H
	ORG $+1
$SG194169 DB	'K:%2.2X=', 00H
	ORG $+3
$SG195753 DB	'CHPID', 00H
	ORG $+2
$SG195824 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+5
$SG194174 DB	'%-36.36s %-16.16s', 00H
	ORG $+6
$SG194200 DB	'%sR:%16.16llX:', 00H
	ORG $+1
$SG194201 DB	'%sV:%16.16llX:R:%16.16llX:', 00H
	ORG $+5
$SG194203 DB	'%s%c:%16.16llX:', 00H
$SG194204 DB	' Translation exception %4.4hX (%s)', 00H
	ORG $+5
$SG194228 DB	'HHC02290', 00H
	ORG $+7
$SG194229 DB	'HHC02291', 00H
	ORG $+7
$SG194232 DB	'invalid parameters', 00H
	ORG $+5
$SG194233 DB	'dump_abs_page()', 00H
$SG194235 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG194236 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194237 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194239 DB	'%c:%16.16llX  Addressing exception', 00H
	ORG $+5
$SG194243 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG194244 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194245 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194247 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG194248 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194249 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194250 DB	'%sI %c:', 00H
$SG194252 DB	'hexdumpew failed', 00H
	ORG $+7
$SG194253 DB	'dump_abs_page()', 00H
$SG194255 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG194256 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194257 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194261 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG194262 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194263 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194265 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG194266 DB	'z900_dump_abs_page', 00H
	ORG $+5
$SG194267 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194309 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+5
$SG194310 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194311 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194317 DB	'Real address is not valid', 00H
	ORG $+6
$SG194319 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG194320 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194321 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194326 DB	'R:%16.16llX  Storage not accessible code = %4.4X (%s)', 00H
	ORG $+2
$SG194328 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG194329 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194330 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194332 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+6
$SG194334 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG194335 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194336 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194338 DB	'R:%16.16llX  Addressing exception', 00H
	ORG $+6
$SG194340 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG194341 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194342 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194343 DB	'%c:%16.16llX  %2.2X%2.2X', 00H
	ORG $+7
$SG194346 DB	'%2.2X%2.2X', 00H
	ORG $+5
$SG194349 DB	'%2.2X%2.2X ', 00H
	ORG $+4
$SG194351 DB	'         ', 00H
	ORG $+6
$SG194353 DB	'HHC02289%s %s', 0aH, 00H
	ORG $+1
$SG194354 DB	'z900_disasm_stor', 00H
	ORG $+7
$SG194355 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194418 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+5
$SG194419 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194420 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194424 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG194425 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194426 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194432 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG194433 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194434 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194442 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG194443 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194444 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194445 DB	'A:%16.16llX  K:%2.2X', 00H
	ORG $+3
$SG194447 DB	'HHC02290%s %s', 0aH, 00H
	ORG $+1
$SG194448 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194449 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194451 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194452 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194453 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194455 DB	'z900_alter_display_real_or_abs', 00H
	ORG $+1
$SG194456 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194475 DB	'(dat off)', 00H
	ORG $+6
$SG194483 DB	'(secondary)', 00H
$SG194755 DB	'    ', 00H
	ORG $+7
$SG194457 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194479 DB	'(primary)', 00H
	ORG $+6
$SG194489 DB	'(AR%2.2d)', 00H
	ORG $+6
$SG194552 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+5
$SG194553 DB	'z900_alter_display_virt', 00H
$SG194554 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194563 DB	'HHC02327%s %c:%16.16llX  Storage address is not valid', 0aH
	DB	00H
	ORG $+1
$SG194564 DB	'z900_alter_display_virt', 00H
$SG194565 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194569 DB	'HHC02329%s %c:%16.16llX  Translation exception %4.4hX (%'
	DB	's)  %s', 0aH, 00H
$SG194570 DB	'z900_alter_display_virt', 00H
$SG194571 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194574 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG194575 DB	'z900_alter_display_virt', 00H
$SG194576 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194583 DB	'HHC02329%s %c:%16.16llX  Translation exception %4.4hX (%'
	DB	's)  %s', 0aH, 00H
$SG194584 DB	'z900_alter_display_virt', 00H
$SG194585 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194588 DB	'HHC02328%s %c:%16.16llX  Addressing exception', 0aH, 00H
	ORG $+1
$SG194589 DB	'z900_alter_display_virt', 00H
$SG194590 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194591 DB	'R:%16.16llX  K:%2.2X  %s', 00H
	ORG $+7
$SG194593 DB	'HHC02291%s %s', 0aH, 00H
	ORG $+1
$SG194594 DB	'z900_alter_display_virt', 00H
$SG194595 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194597 DB	'z900_alter_display_virt', 00H
$SG194598 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194599 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194601 DB	'z900_alter_display_virt', 00H
$SG194602 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194603 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194706 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:832', 00H
	ORG $+3
$SG194708 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:834', 00H
	ORG $+3
$SG194709 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:838', 00H
	ORG $+3
$SG194713 DB	'Real address is not valid', 00H
	ORG $+6
$SG194715 DB	'HHC02267%s %s', 0aH, 00H
	ORG $+1
$SG194716 DB	'z900_display_inst_adj', 00H
	ORG $+2
$SG194717 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194726 DB	'%s Instruction fetch error', 0aH, 00H
	ORG $+4
$SG194727 DB	'HHC02269I ', 00H
	ORG $+5
$SG194730 DB	'HHC02325%s %s%s', 0aH, 00H
	ORG $+7
$SG194731 DB	'z900_display_inst_adj', 00H
	ORG $+2
$SG194732 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194735 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:892', 00H
	ORG $+3
$SG194736 DB	'dinst op,ilc', 00H
	ORG $+3
$SG194738 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:901', 00H
	ORG $+3
$SG194739 DB	'dinst ip,IA', 00H
	ORG $+4
$SG194742 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:907', 00H
	ORG $+3
$SG194743 DB	'dinst ip,IA', 00H
	ORG $+4
$SG194746 DB	'%s%02X: ', 00H
	ORG $+7
$SG194747 DB	'PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ', 00H
	ORG $+2
$SG194748 DB	'%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ', 00H
	ORG $+6
$SG194749 DB	'INST=%2.2X%2.2X', 00H
$SG194751 DB	'%2.2X%2.2X', 00H
	ORG $+5
$SG194753 DB	'%2.2X%2.2X', 00H
	ORG $+5
$SG194754 DB	'        ', 00H
	ORG $+7
$SG194759 DB	'HHC02324%s %s', 0aH, 00H
	ORG $+1
$SG194783 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1062', 00H
	ORG $+2
$SG194784 DB	'dinst rel1:', 00H
	ORG $+4
$SG194786 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1068', 00H
	ORG $+2
$SG194787 DB	'dinst rel1=', 00H
	ORG $+4
$SG194794 DB	'%s%02X: ', 00H
	ORG $+7
$SG194801 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG194806 DB	'%s%02X: ', 00H
	ORG $+7
$SG194816 DB	'HHC02326%s %s', 0aH, 00H
	ORG $+1
$SG194824 DB	'%s%s%s%s', 00H
	ORG $+7
$SG194825 DB	'z900_display_inst_adj', 00H
	ORG $+2
$SG194826 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194827 DB	'%s%s%s%s', 00H
	ORG $+7
$SG194828 DB	'z900_display_inst_adj', 00H
	ORG $+2
$SG194829 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194864 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1252', 00H
	ORG $+2
$SG194865 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1256', 00H
	ORG $+2
$SG194884 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1276', 00H
	ORG $+2
$SG194886 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1283', 00H
	ORG $+2
$SG194891 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1291', 00H
	ORG $+2
$SG194892 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1301', 00H
	ORG $+2
$SG194906 DB	'HHC01420%s Begin Hercules shutdown', 0aH, 00H
	ORG $+4
$SG194907 DB	'do_shutdown_now', 00H
$SG194908 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194910 DB	'do_shutdown_now', 00H
$SG194911 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194914 DB	'do_shutdown_now', 00H
$SG194926 DB	'HHC01425%s Hercules shutdown complete', 0aH, 00H
	ORG $+1
$SG194912 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194915 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194918 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1370', 00H
	ORG $+2
$SG194921 DB	'do_shutdown_now', 00H
$SG194940 DB	'do_shutdown_wait', 00H
	ORG $+7
$SG194916 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194920 DB	'HHC01423%s Calling termination routines', 0aH, 00H
	ORG $+7
$SG194922 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194924 DB	'HHC01424%s All termination routines complete', 0aH, 00H
	ORG $+2
$SG194928 DB	'HHC01412%s Hercules terminated', 0aH, 00H
$SG194939 DB	'HHC01426%s Shutdown initiated', 0aH, 00H
	ORG $+1
$SG194941 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG194951 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:1502', 00H
	ORG $+2
$SG194952 DB	'do_shutdown_wait', 00H
	ORG $+7
$SG194980 DB	'%s%02X: ', 00H
	ORG $+7
$SG194984 DB	'%s%2.2d=%8.8X', 00H
	ORG $+2
$SG195017 DB	'%s%02X: ', 00H
	ORG $+7
$SG195021 DB	'%s%1.1X=%16.16llX', 00H
	ORG $+6
$SG195045 DB	'HHC02269I ', 00H
	ORG $+5
$SG195050 DB	'HHC02271I ', 00H
	ORG $+5
$SG195054 DB	'HHC02272I ', 00H
	ORG $+5
$SG195082 DB	'HHC02276%s Floating point control register: %08X', 0aH, 00H
	ORG $+6
$SG195099 DB	'HHC02270I ', 00H
	ORG $+5
$SG195103 DB	'HHC02277I ', 00H
	ORG $+5
$SG195178 DB	'%s%s%02X: ', 00H
	ORG $+5
$SG195182 DB	'%sFPR0=%8.8X%8.8X FPR2=%8.8X%8.8X', 0aH, '%sFPR1=%8.8X%8'
	DB	'.8X FPR3=%8.8X%8.8X', 0aH, '%sFPR4=%8.8X%8.8X FPR6=%8.8X%8.8X'
	DB	0aH, '%sFPR5=%8.8X%8.8X FPR7=%8.8X%8.8X', 0aH, '%sFPR8=%8.8X%8'
	DB	'.8X FP10=%8.8X%8.8X', 0aH, '%sFPR9=%8.8X%8.8X FP11=%8.8X%8.8X'
	DB	0aH, '%sFP12=%8.8X%8.8X FP14=%8.8X%8.8X', 0aH, '%sFP13=%8.8X%8'
	DB	'.8X FP15=%8.8X%8.8X', 0aH, 00H
	ORG $+7
$SG195205 DB	'%s%s%02X: ', 00H
	ORG $+5
?status_type@?1??display_subchannel@@9@9 DQ FLAT:$SG195236 ; `display_subchannel'::`2'::status_type
	DQ	FLAT:$SG195237
	DQ	FLAT:$SG195238
$SG195183 DB	'%sFPR0=%8.8X%8.8X FPR2=%8.8X%8.8X', 0aH, '%sFPR4=%8.8X%8'
	DB	'.8X FPR6=%8.8X%8.8X', 0aH, 00H
	ORG $+3
$SG195239 DB	'%s%1d:%04X D/T%04X', 0aH, 00H
	ORG $+4
$SG195207 DB	'VR%02d=%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%'
	DB	'02X%02X%02X%02X', 00H
$SG195254 DB	'CUE ', 00H
	ORG $+3
$SG195208 DB	'%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH
	DB	'%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH
	DB	'%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH
	DB	'%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH, '%s%s %s', 0aH
	DB	00H
	ORG $+7
$SG195258 DB	'Attention ', 00H
	ORG $+5
$SG195262 DB	'%s    %s %s%s%s%s%s%s%s%s%s', 0aH, 00H
	ORG $+3
$SG195265 DB	'ICC ', 00H
	ORG $+3
$SG195241 DB	'%s  CSW Flags:%2.2X CCW:%2.2X%2.2X%2.2X            Flags'
	DB	0aH, '%s         US:%2.2X  CS:%2.2X Count:%2.2X%2.2X       (Ke'
	DB	'y) Subchannel key          %1.1X', 0aH, '%s                  '
	DB	'                     (S)   Suspend control         %1.1X', 0aH
	DB	'%s                                       (L)   Extended forma'
	DB	't         %1.1X', 0aH, '%s  Subchannel Internal Management   '
	DB	'    (CC)  Deferred condition code %1.1X', 0aH, 00H
	ORG $+6
$SG195242 DB	'%s  Subchannel Number[%04X]', 0aH, '%s    Path Managemen'
	DB	't Control Word (PMCW)', 0aH, '%s  IntParm:%2.2X%2.2X%2.2X%2.2'
	DB	'X', 0aH, '%s    Flags:%2.2X%2.2X        Dev:%2.2X%2.2X', 0aH, '%'
	DB	's      LPM:%2.2X PNOM:%2.2X LPUM:%2.2X PIM:%2.2X', 0aH, '%s  '
	DB	'    MBI:%2.2X%2.2X        POM:%2.2X PAM:%2.2X', 0aH, '%s  CHP'
	DB	'ID 0:%2.2X    1:%2.2X    2:%2.2X   3:%2.2X', 0aH, '%s        '
	DB	'4:%2.2X    5:%2.2X    6:%2.2X   7:%2.2X', 0aH, '%s     Misc:%'
	DB	'2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+2
$SG195243 DB	'%s  Subchannel Status Word (SCSW)', 0aH, '%s    Flags: %'
	DB	'2.2X%2.2X  Subchan Ctl: %2.2X%2.2X     (FC)  Function Control'
	DB	0aH, '%s      CCW: %2.2X%2.2X%2.2X%2.2X                       '
	DB	'   Start                   %1.1X', 0aH, '%s       DS: %2.2X  '
	DB	'SS: %2.2X  Count: %2.2X%2.2X           Halt                  '
	DB	'  %1.1X', 0aH, '%s                                           '
	DB	'  Clear                   %1.1X', 0aH, '%s    Flags          '
	DB	'                    (AC)  Activity Control', 0aH, '%s      (K'
	DB	'ey) Subchannel key          %1.1X        Resume pending      '
	DB	'    %1.1X', 0aH, '%s      (S)   Suspend control         %1.1X'
	DB	'        Start pending           %1.1X', 0aH, '%s      (L)   E'
	DB	'xtended format         %1.1X        Halt pending            %'
	DB	'1.1X', 0aH, '%s      (CC)  Deferred condition code %1.1X     '
	DB	'   Clear pending           %1.1X', 0aH, '%s      (F)   CCW-fo'
	DB	'rmat control      %1.1X        Subchannel active       %1.1X', 0aH
	DB	'%s      (P)   Prefetch control        %1.1X        Device act'
	DB	'ive           %1.1X', 0aH, '%s      (I)   Initial-status cont'
	DB	'rol  %1.1X        Suspended               %1.1X', 0aH, '%s   '
	DB	'   (A)   Address-limit control   %1.1X  (SC)  Status Control', 0aH
	DB	'%s      (U)   Suppress-suspend int.   %1.1X        Alert     '
	DB	'              %1.1X', 0aH, '%s    Subchannel Control         '
	DB	'              Intermediate            %1.1X', 0aH, '%s      ('
	DB	'Z)   Zero condition code     %1.1X        Primary            '
	DB	'     %1.1X', 0aH, '%s      (E)   Extended control (ECW)  %1.1'
	DB	'X        Secondary               %1.1X', 0aH, '%s      (N)   '
	DB	'Path not operational    %1.1X        Status pending          '
	DB	'%1.1X', 0aH, '%s      (Q)   QDIO active             %1.1X', 0aH
	DB	00H
	ORG $+4
$SG195260 DB	'is Normal', 00H
	ORG $+2
$SG195267 DB	'CCC ', 00H
	ORG $+3
$SG195269 DB	'CDC ', 00H
	ORG $+3
$SG195277 DB	'PCI ', 00H
	ORG $+7
$SG195279 DB	'is Normal', 00H
	ORG $+6
$SG195281 DB	'%s    %s %s%s%s%s%s%s%s%s%s', 0aH, 00H
	ORG $+3
$SG195282 DB	'%s  DEVBLK Status', 0aH, '%s    busy             %1.1X  '
	DB	'  shareable     %1.1X', 0aH, '%s    suspended        %1.1X   '
	DB	' console       %1.1X    rlen3270 %5d', 0aH, '%s    pending   '
	DB	'       %1.1X    connected     %1.1X', 0aH, '%s    pcipending '
	DB	'      %1.1X    readpending   %1.1X', 0aH, '%s    attnpending '
	DB	'     %1.1X    connecting    %1.1X', 0aH, '%s    startpending '
	DB	'    %1.1X    localhost     %1.1X', 0aH, '%s    resumesuspende'
	DB	'd  %1.1X    reserved      %1.1X', 0aH, '%s    tschpending    '
	DB	'  %1.1X    locked        %1.1X', 0aH, 00H
	ORG $+5
$SG195313 DB	'HHC17000%s Missing or invalid argument(s)', 0aH, 00H
	ORG $+5
$SG195314 DB	'parse_range', 00H
	ORG $+4
$SG195315 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195316 DB	'%llx%c%llx%c', 00H
	ORG $+3
$SG195322 DB	': string expected', 00H
	ORG $+6
$SG195325 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195326 DB	'parse_range', 00H
	ORG $+4
$SG195327 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195329 DB	': maximum string length is 32 characters', 00H
	ORG $+7
$SG195332 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195333 DB	'parse_range', 00H
	ORG $+4
$SG195334 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195342 DB	': invalid hex digit', 00H
	ORG $+4
$SG195344 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195345 DB	'parse_range', 00H
	ORG $+4
$SG195346 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195348 DB	': invalid hex pair', 00H
	ORG $+5
$SG195350 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195351 DB	'parse_range', 00H
	ORG $+4
$SG195352 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195354 DB	': only a maximum of 32 bytes may be altered', 00H
	ORG $+4
$SG195356 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195357 DB	'parse_range', 00H
	ORG $+4
$SG195358 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195366 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195367 DB	'parse_range', 00H
	ORG $+4
$SG195368 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195371 DB	': invalid range', 00H
$SG195373 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+6
$SG195374 DB	'parse_range', 00H
	ORG $+4
$SG195375 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
$SG195385 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:2213', 00H
	ORG $+2
$SG195387 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c:2222', 00H
	ORG $+2
$SG195403 DB	'malloc(%d)', 00H
	ORG $+5
$SG195405 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG195406 DB	'copy_regs', 00H
	ORG $+6
$SG195407 DB	'C:\papa\MyGit\hyperion-zvector\hscmisc.c', 00H
	ORG $+7
?rsctab@?1??FormatCRW@@9@9 DQ FLAT:$SG195433		; `FormatCRW'::`2'::rsctab
	DQ	FLAT:$SG195434
	DQ	FLAT:$SG195435
	DQ	FLAT:$SG195436
	DQ	FLAT:$SG195437
	DQ	FLAT:$SG195438
	DQ	FLAT:$SG195439
	DQ	FLAT:$SG195440
	DQ	FLAT:$SG195441
	DQ	FLAT:$SG195442
	DQ	FLAT:$SG195443
	DQ	FLAT:$SG195444
?erctab@?1??FormatCRW@@9@9 DQ FLAT:$SG195445		; `FormatCRW'::`2'::erctab
	DQ	FLAT:$SG195446
	DQ	FLAT:$SG195447
	DQ	FLAT:$SG195448
	DQ	FLAT:$SG195449
	DQ	FLAT:$SG195450
	DQ	FLAT:$SG195451
	DQ	FLAT:$SG195452
	DQ	FLAT:$SG195453
	DQ	FLAT:$SG195454
	DQ	FLAT:$SG195455
$SG195461 DB	'0x00400000,', 00H
$SG195469 DB	'SOL,', 00H
	ORG $+7
$SG195471 DB	'0x80000000,', 00H
	ORG $+4
$SG195477 DB	'RSC:%d=%s, ERC:%d=%s, RSID:%d=0x%4.4X Flags:%s%s%s%s%s%s'
	DB	'%s', 00H
	ORG $+5
?sa@?1??FormatSCL@@9@9 DQ FLAT:$SG195492		; `FormatSCL'::`2'::sa
	DQ	FLAT:$SG195493
	DQ	FLAT:$SG195494
	DQ	FLAT:$SG195495
?tc@?1??FormatSCL@@9@9 DQ FLAT:$SG195496		; `FormatSCL'::`2'::tc
	DQ	FLAT:$SG195497
	DQ	FLAT:$SG195498
	DQ	FLAT:$SG195499
$SG195504 DB	' (R)', 00H
	ORG $+3
$SG195519 DB	'Flags:%c%c%c%c%c%c%c%c %c%c SCNT:%d', 00H
	ORG $+4
$SG195506 DB	'ESF:%c%c%c%c%c%c%c%c%s FVF:%c%c%c%c%c LPUM:%2.2X SA:%s T'
	DB	'C:%s Flgs:%c%c%c SC=%d', 00H
	ORG $+1
$SG195534 DB	'SCL = %s, ERW = %s', 00H
	ORG $+5
NED_NEQ_type DQ	FLAT:$SG195554
	DQ	FLAT:$SG195555
	DQ	FLAT:$SG195556
	DQ	FLAT:$SG195557
?ned_type@?1??FormatNED@@9@9 DQ FLAT:$SG195584		; `FormatNED'::`2'::ned_type
	DQ	FLAT:$SG195585
	DQ	FLAT:$SG195586
$SG195552 DB	'SDC: type/model:%c%c%c%c%c%c-%c%c%c mfg:%c%c%c plant:%c%'
	DB	'c seq/serial:%c%c%c%c%c%c%c%c%c%c%c%c', 0aH, 00H
	ORG $+1
?sn_ind@?1??FormatNED@@9@9 DQ FLAT:$SG195580		; `FormatNED'::`2'::sn_ind
	DQ	FLAT:$SG195581
	DQ	FLAT:$SG195582
	DQ	FLAT:$SG195583
?dev_class@?1??FormatNED@@9@9 DQ FLAT:$SG195587		; `FormatNED'::`2'::dev_class
	DQ	FLAT:$SG195588
	DQ	FLAT:$SG195589
	DQ	FLAT:$SG195590
	DQ	FLAT:$SG195591
	DQ	FLAT:$SG195592
	DQ	FLAT:$SG195593
	DQ	FLAT:$SG195594
	DQ	FLAT:$SG195595
	DQ	FLAT:$SG195596
	DQ	FLAT:$SG195597
	DQ	FLAT:$SG195598
$SG195611 DB	'UNRELATED', 00H
	ORG $+6
$SG195612 DB	'RELATED', 00H
$SG195613 DB	'(EMULATED) ', 00H
	ORG $+4
$SG195617 DB	'NED:%s%styp:%s cls:%s lvl:%s sn:%s tag:%02X%02X', 0aH, ' '
	DB	'    %s', 00H
$SG195618 DB	'UNRELATED', 00H
	ORG $+6
$SG195619 DB	'RELATED', 00H
$SG195620 DB	'(EMULATED) ', 00H
	ORG $+4
$SG195624 DB	'NED:%s%styp:%s lvl:%s sn:%s tag:%02X%02X', 0aH, '     %s'
	DB	00H
	ORG $+7
$SG195643 DB	'NEQ: typ:%s IID:%02X%02X DDTO:%u', 0aH, '     %02X%02X%0'
	DB	'2X%02X %02X%02X%02X%02X', 0aH, '     %02X%02X%02X%02X %02X%02'
	DB	'X%02X%02X', 0aH, '     %02X%02X%02X%02X %02X%02X%02X%02X', 0aH
	DB	'     %02X%02X%02X%02X %02X%02X%02X%02X', 0aH, 00H
	ORG $+2
$SG195661 DB	'%02X', 00H
	ORG $+3
$SG195693 DB	'n/a', 0aH, 00H
	ORG $+3
?css_class@?1??FormatND@@9@9 DQ FLAT:$SG195721		; `FormatND'::`2'::css_class
	DQ	FLAT:$SG195722
	DQ	FLAT:$SG195723
$SG195756 DB	'LINK', 00H
	ORG $+3
?val_type@?1??FormatND@@9@9 DQ FLAT:$SG195724		; `FormatND'::`2'::val_type
	DQ	FLAT:$SG195725
	DQ	FLAT:$SG195726
	DQ	FLAT:$SG195727
	DQ	FLAT:$SG195728
	DQ	FLAT:$SG195729
	DQ	FLAT:$SG195730
	DQ	FLAT:$SG195731
?dev_class@?1??FormatND@@9@9 DQ FLAT:$SG195732		; `FormatND'::`2'::dev_class
	DQ	FLAT:$SG195733
	DQ	FLAT:$SG195734
	DQ	FLAT:$SG195735
	DQ	FLAT:$SG195736
	DQ	FLAT:$SG195737
	DQ	FLAT:$SG195738
	DQ	FLAT:$SG195739
	DQ	FLAT:$SG195740
	DQ	FLAT:$SG195741
	DQ	FLAT:$SG195742
	DQ	FLAT:$SG195743
$SG195757 DB	'BYTE3', 00H
	ORG $+2
$SG195761 DB	'ND:  val:%s typ:%s cls:%s %s:%02X tag:%02X%02X', 0aH, ' '
	DB	'    %s', 00H
	ORG $+1
$SG195763 DB	'ND:  val:INVALID', 0aH, 00H
	ORG $+6
$SG195765 DB	'ND:  val:%u (invalid)', 0aH, 00H
	ORG $+1
?type@?1??FormatNQ@@9@9 DQ FLAT:$SG195779		; `FormatNQ'::`2'::type
	DQ	FLAT:$SG195780
	DQ	FLAT:$SG195781
	DQ	FLAT:$SG195782
	DQ	FLAT:$SG195783
	DQ	FLAT:$SG195784
	DQ	FLAT:$SG195785
	DQ	FLAT:$SG195786
$SG195791 DB	'NQ:  %02X%02X%02X%02X %02X%02X%02X%02X  (typ:%s)', 0aH, ' '
	DB	'    %02X%02X%02X%02X %02X%02X%02X%02X', 0aH, '     %02X%02X%0'
	DB	'2X%02X %02X%02X%02X%02X', 0aH, '     %02X%02X%02X%02X %02X%02'
	DB	'X%02X%02X', 0aH, 00H
	ORG $+1
$SG195859 DB	'CIW: %02X%02X%02X%02X  not a CIW', 0aH, 00H
	ORG $+6
?type@?1??FormatCIW@@9@9 DQ FLAT:$SG195836		; `FormatCIW'::`2'::type
	DQ	FLAT:$SG195837
	DQ	FLAT:$SG195838
	DQ	FLAT:$SG195839
	DQ	FLAT:$SG195840
	DQ	FLAT:$SG195841
	DQ	FLAT:$SG195842
	DQ	FLAT:$SG195843
	DQ	FLAT:$SG195844
	DQ	FLAT:$SG195845
	DQ	FLAT:$SG195846
	DQ	FLAT:$SG195847
	DQ	FLAT:$SG195848
	DQ	FLAT:$SG195849
	DQ	FLAT:$SG195850
	DQ	FLAT:$SG195851
$SG195858 DB	'CIW: %02X%02X%02X%02X  typ:%s op:%02X len:%u', 0aH, 00H
	ORG $+2
$SG195880 DB	'%02X CU=%02X%02X-%02X DEV=%02X%02X-%02X %02X', 0aH, 00H
	ORG $+2
$SG195882 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG195963 DB	'conspawn ', 00H
	ORG $+6
$SG195964 DB	'conspawn ', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatND
	DD	020H
	DD	031bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatNED
	DD	020H
	DD	0486H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_display_inst_adj
	DD	027H
	DD	01b8aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_alter_display_virt
	DD	024H
	DD	099eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_bldtrans
	DD	021H
	DD	0ffH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_alter_display_real_or_abs
	DD	024H
	DD	070bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_disasm_stor
	DD	026H
	DD	078eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dump_abs_page
	DD	025H
	DD	04eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_display_real
	DD	026H
	DD	040cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_display_inst_adj
	DD	027H
	DD	019d9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_alter_display_virt
	DD	024H
	DD	0996H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_bldtrans
	DD	021H
	DD	0ffH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_alter_display_real_or_abs
	DD	024H
	DD	0707H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_disasm_stor
	DD	026H
	DD	078cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dump_abs_page
	DD	025H
	DD	04eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_display_real
	DD	026H
	DD	040aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_display_inst_adj
	DD	027H
	DD	019e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_alter_display_virt
	DD	024H
	DD	0996H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_bldtrans
	DD	021H
	DD	010fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_alter_display_real_or_abs
	DD	024H
	DD	0707H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_disasm_stor
	DD	026H
	DD	079fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dump_abs_page
	DD	025H
	DD	0579H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_display_real
	DD	026H
	DD	0466H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatRNI
	DD	024H
	DD	0206H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatRCD
	DD	024H
	DD	01b7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatSID
	DD	026H
	DD	0288H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:copy_regs
	DD	018H
	DD	0285H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:FormatESW
	DD	020H
	DD	0daH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:display_aregs
	DD	025H
	DD	0baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:display_cregs
	DD	025H
	DD	0171H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:display_vregs
	DD	031H
	DD	090aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:display_fregs
	DD	031H
	DD	07faH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:display_gregs
	DD	025H
	DD	016bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$s370_display_inst DD 010e01H
	DD	0420eH
$unwind$s370_display_pgmint_inst DD 010e01H
	DD	0420eH
$unwind$herc_system DD 010901H
	DD	08209H
$unwind$do_shutdown DD 010401H
	DD	08204H
$unwind$insttrace_all DD 010401H
	DD	02204H
$unwind$display_gregs DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$display_fregs DD 0a3919H
	DD	0470127H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
	DD	imagerel __GSHandlerCheck
	DD	0228H
$unwind$display_vregs DD 0a3919H
	DD	0d50127H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
	DD	imagerel __GSHandlerCheck
	DD	0690H
$unwind$display_cregs DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$display_aregs DD 022d19H
	DD	015011bH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$display_subchannel DD 0a2701H
	DD	06d0127H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
$unwind$display_inst_regs DD 011701H
	DD	08217H
$unwind$FormatCRW DD 021501H
	DD	01d0115H
$unwind$FormatSCL DD 021601H
	DD	0230116H
$unwind$FormatERW DD 021601H
	DD	0150116H
$unwind$FormatESW DD 022819H
	DD	01b0116H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$parse_range DD 021b01H
	DD	019011bH
$unwind$copy_regs DD 042019H
	DD	01b010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$FormatSID DD 042e19H
	DD	01f011cH
	DD	030147015H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$FormatRCD DD 022c19H
	DD	029011aH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$FormatRNI DD 022c19H
	DD	029011aH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$s370_virt_to_real DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$s390_virt_to_real DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$z900_virt_to_real DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$get_connected_client DD 011301H
	DD	04213H
$unwind$alter_display_real_or_abs DD 011701H
	DD	06217H
$unwind$alter_display_virt DD 011701H
	DD	08217H
$unwind$disasm_stor DD 011701H
	DD	08217H
$unwind$s390_display_inst DD 010e01H
	DD	0420eH
$unwind$z900_display_inst DD 010e01H
	DD	0420eH
$unwind$s370_display_guest_inst DD 010e01H
	DD	0620eH
$unwind$s390_display_guest_inst DD 010e01H
	DD	0620eH
$unwind$z900_display_guest_inst DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$are_all_cpus_stopped_intlock_held DD 010401H
	DD	02204H
$unwind$s370_display_real DD 032e19H
	DD	01a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_display_virt DD 011701H
	DD	0a217H
$unwind$s370_dump_abs_page DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_disasm_stor DD 042e19H
	DD	059011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$s370_alter_display_real_or_abs DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$s370_bldtrans DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$s370_alter_display_virt DD 022c19H
	DD	037011aH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$s370_display_inst_adj DD 032f19H
	DD	02aa011dH
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	01540H
$unwind$s390_display_pgmint_inst DD 010e01H
	DD	0420eH
$unwind$s390_display_real DD 032e19H
	DD	01a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_display_virt DD 011701H
	DD	0a217H
$unwind$s390_dump_abs_page DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s390_disasm_stor DD 042e19H
	DD	059011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$s390_alter_display_real_or_abs DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$s390_bldtrans DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$s390_alter_display_virt DD 022c19H
	DD	037011aH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$s390_display_inst_adj DD 032f19H
	DD	02aa011dH
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	01540H
$unwind$z900_display_pgmint_inst DD 010e01H
	DD	0420eH
$unwind$z900_display_real DD 032e19H
	DD	01a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_display_virt DD 011801H
	DD	0a218H
$unwind$z900_dump_abs_page DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$z900_disasm_stor DD 042e19H
	DD	059011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$z900_alter_display_real_or_abs DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$z900_bldtrans DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$z900_alter_display_virt DD 022c19H
	DD	037011aH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$z900_display_inst_adj DD 032f19H
	DD	02ac011dH
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	01550H
$unwind$is_guest_quiesced DD 010401H
	DD	06204H
$unwind$wait_for_guest_to_quiesce DD 010401H
	DD	06204H
$unwind$cancel_wait_for_guest_quiesce DD 010401H
	DD	04204H
$unwind$do_shutdown_now DD 010401H
	DD	0a204H
$unwind$do_shutdown_wait DD 010901H
	DD	08209H
$unwind$display_regs32 DD 011801H
	DD	0a218H
$unwind$display_regs64 DD 011801H
	DD	0a218H
$unwind$sdcchar DD 010801H
	DD	06208H
$unwind$FormatSDC DD 021601H
	DD	02d0116H
$unwind$FormatNED DD 022819H
	DD	03b0116H
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$FormatNEQ DD 0a2201H
	DD	0370122H
	DD	0e019f01bH
	DD	0c015d017H
	DD	060127013H
	DD	030105011H
$unwind$FormatBytes DD 011701H
	DD	06217H
$unwind$FormatND DD 022819H
	DD	0370116H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$FormatNQ DD 0a2201H
	DD	0310122H
	DD	0e019f01bH
	DD	0c015d017H
	DD	060127013H
	DD	030105011H
$unwind$FormatCIW DD 031501H
	DD	07011a215H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
ciw$ = 112
buf$ = 120
bufsz$ = 128
FormatCIW PROC

; 2916 : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2917 :     static const char* type[] =
; 2918 :     {
; 2919 :         "RCD", "SII", "RNI", "3  ", "4  ", "5  ", "6  ", "7  ",
; 2920 :         "8  ", "9  ", "10 ", "11 ", "12 ", "13 ", "14 ", "15 ",
; 2921 :     };
; 2922 : 
; 2923 :     if (!buf)

  00015	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0001b	75 07		 jne	 SHORT $LN2@FormatCIW

; 2924 :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 ac 01 00 00	 jmp	 $LN1@FormatCIW
$LN2@FormatCIW:

; 2925 :     if (bufsz)

  00024	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  0002d	74 12		 je	 SHORT $LN3@FormatCIW

; 2926 :         buf[0] = 0;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buf$[rsp]
  0003d	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatCIW:

; 2927 :     if (bufsz <= 1 || !ciw)

  00041	48 83 bc 24 80
	00 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  0004a	76 08		 jbe	 SHORT $LN5@FormatCIW
  0004c	48 83 7c 24 70
	00		 cmp	 QWORD PTR ciw$[rsp], 0
  00052	75 0a		 jne	 SHORT $LN4@FormatCIW
$LN5@FormatCIW:

; 2928 :         return buf;

  00054	48 8b 44 24 78	 mov	 rax, QWORD PTR buf$[rsp]
  00059	e9 72 01 00 00	 jmp	 $LN1@FormatCIW
$LN4@FormatCIW:

; 2929 : 
; 2930 :     if ((ciw[0] & 0xC0) == 0x40)

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	48 6b c0 00	 imul	 rax, rax, 0
  00067	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ciw$[rsp]
  0006c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00070	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00075	83 f8 40	 cmp	 eax, 64			; 00000040H
  00078	0f 85 dc 00 00
	00		 jne	 $LN6@FormatCIW

; 2931 :     {
; 2932 :         snprintf( buf, bufsz,

  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR ciw$[rsp]
  00083	48 83 c0 02	 add	 rax, 2
  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0008f	0f b7 c8	 movzx	 ecx, ax
  00092	e8 00 00 00 00	 call	 _byteswap_ushort
  00097	0f b7 c0	 movzx	 eax, ax
  0009a	b9 01 00 00 00	 mov	 ecx, 1
  0009f	48 6b c9 01	 imul	 rcx, rcx, 1
  000a3	48 8b 54 24 70	 mov	 rdx, QWORD PTR ciw$[rsp]
  000a8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ac	ba 01 00 00 00	 mov	 edx, 1
  000b1	48 6b d2 00	 imul	 rdx, rdx, 0
  000b5	4c 8b 44 24 70	 mov	 r8, QWORD PTR ciw$[rsp]
  000ba	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000bf	83 e2 0f	 and	 edx, 15
  000c2	48 63 d2	 movsxd	 rdx, edx
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?type@?1??FormatCIW@@9@9
  000cc	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d2	4d 6b c9 03	 imul	 r9, r9, 3
  000d6	4c 8b 54 24 70	 mov	 r10, QWORD PTR ciw$[rsp]
  000db	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  000e0	41 ba 01 00 00
	00		 mov	 r10d, 1
  000e6	4d 6b d2 02	 imul	 r10, r10, 2
  000ea	4c 8b 5c 24 70	 mov	 r11, QWORD PTR ciw$[rsp]
  000ef	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  000f4	41 bb 01 00 00
	00		 mov	 r11d, 1
  000fa	4d 6b db 01	 imul	 r11, r11, 1
  000fe	48 8b 5c 24 70	 mov	 rbx, QWORD PTR ciw$[rsp]
  00103	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00108	41 bb 01 00 00
	00		 mov	 r11d, 1
  0010e	4d 6b db 00	 imul	 r11, r11, 0
  00112	48 8b 7c 24 70	 mov	 rdi, QWORD PTR ciw$[rsp]
  00117	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  0011c	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00120	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00124	49 8b 04 d0	 mov	 rax, QWORD PTR [r8+rdx*8]
  00128	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0012d	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00132	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00137	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0013b	44 8b cf	 mov	 r9d, edi
  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195858
  00145	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  0014d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buf$[rsp]
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2933 : 
; 2934 :             "CIW: %02X%02X%02X%02X  typ:%s op:%02X len:%u\n"
; 2935 : 
; 2936 :             , ciw[0], ciw[1], ciw[2], ciw[3]
; 2937 :             , type[ ciw[0] & 0x0F ]
; 2938 :             , ciw[1]
; 2939 :             , fetch_hw( ciw+2 )
; 2940 :         );
; 2941 :     }

  00158	eb 71		 jmp	 SHORT $LN7@FormatCIW
$LN6@FormatCIW:

; 2942 :     else
; 2943 :     {
; 2944 :         snprintf( buf, bufsz,

  0015a	b8 01 00 00 00	 mov	 eax, 1
  0015f	48 6b c0 03	 imul	 rax, rax, 3
  00163	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ciw$[rsp]
  00168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016c	b9 01 00 00 00	 mov	 ecx, 1
  00171	48 6b c9 02	 imul	 rcx, rcx, 2
  00175	48 8b 54 24 70	 mov	 rdx, QWORD PTR ciw$[rsp]
  0017a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0017e	ba 01 00 00 00	 mov	 edx, 1
  00183	48 6b d2 01	 imul	 rdx, rdx, 1
  00187	48 8b 5c 24 70	 mov	 rbx, QWORD PTR ciw$[rsp]
  0018c	0f b6 14 13	 movzx	 edx, BYTE PTR [rbx+rdx]
  00190	bb 01 00 00 00	 mov	 ebx, 1
  00195	48 6b db 00	 imul	 rbx, rbx, 0
  00199	48 8b 7c 24 70	 mov	 rdi, QWORD PTR ciw$[rsp]
  0019e	0f b6 1c 1f	 movzx	 ebx, BYTE PTR [rdi+rbx]
  001a2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001a6	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  001aa	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  001ae	44 8b cb	 mov	 r9d, ebx
  001b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195859
  001b8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  001c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buf$[rsp]
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN7@FormatCIW:

; 2945 : 
; 2946 :             "CIW: %02X%02X%02X%02X  not a CIW\n"
; 2947 : 
; 2948 :             , ciw[0]
; 2949 :             , ciw[1]
; 2950 :             , ciw[2]
; 2951 :             , ciw[3]
; 2952 :         );
; 2953 :     }
; 2954 : 
; 2955 :     return buf;

  001cb	48 8b 44 24 78	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatCIW:

; 2956 : }

  001d0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d4	5f		 pop	 rdi
  001d5	5b		 pop	 rbx
  001d6	c3		 ret	 0
FormatCIW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
byte$ = 288
tv157 = 296
tv161 = 300
tv165 = 304
tv169 = 308
tv173 = 312
tv177 = 316
tv181 = 320
tv185 = 324
tv189 = 328
tv193 = 332
tv197 = 336
tv208 = 340
tv212 = 344
tv216 = 348
tv220 = 352
tv224 = 356
tv228 = 360
tv232 = 364
tv70 = 368
tv202 = 376
nq$ = 464
buf$ = 472
bufsz$ = 480
FormatNQ PROC

; 2831 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	55		 push	 rbp
  00011	56		 push	 rsi
  00012	57		 push	 rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	41 57		 push	 r15
  0001b	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H

; 2832 :     BYTE* byte = (BYTE*) nq;

  00022	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR nq$[rsp]
  0002a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR byte$[rsp], rax

; 2833 :     static const char* type[] =
; 2834 :     {
; 2835 :         "IIL", "MODEP", "2", "3", "4", "5", "6", "7",
; 2836 :     };
; 2837 : 
; 2838 :     if (!buf)

  00032	48 83 bc 24 d8
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0003b	75 07		 jne	 SHORT $LN2@FormatNQ

; 2839 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 56 05 00 00	 jmp	 $LN1@FormatNQ
$LN2@FormatNQ:

; 2840 :     if (bufsz)

  00044	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  0004d	74 15		 je	 SHORT $LN3@FormatNQ

; 2841 :         buf[0] = 0;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	48 6b c0 00	 imul	 rax, rax, 0
  00058	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00060	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatNQ:

; 2842 :     if (bufsz <= 1 || !nq)

  00064	48 83 bc 24 e0
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  0006d	76 0b		 jbe	 SHORT $LN5@FormatNQ
  0006f	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR nq$[rsp], 0
  00078	75 0d		 jne	 SHORT $LN4@FormatNQ
$LN5@FormatNQ:

; 2843 :         return buf;

  0007a	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00082	e9 13 05 00 00	 jmp	 $LN1@FormatNQ
$LN4@FormatNQ:

; 2844 : 
; 2845 :     snprintf( buf, bufsz,

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 6b c0 1f	 imul	 rax, rax, 31
  00090	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR byte$[rsp]
  00098	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	48 6b c9 1e	 imul	 rcx, rcx, 30
  000a5	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR byte$[rsp]
  000ad	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 6b d2 1d	 imul	 rdx, rdx, 29
  000ba	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR byte$[rsp]
  000c2	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000c7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000cd	4d 6b c0 1c	 imul	 r8, r8, 28
  000d1	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR byte$[rsp]
  000d9	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000de	41 b9 01 00 00
	00		 mov	 r9d, 1
  000e4	4d 6b c9 1b	 imul	 r9, r9, 27
  000e8	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR byte$[rsp]
  000f0	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  000f5	41 ba 01 00 00
	00		 mov	 r10d, 1
  000fb	4d 6b d2 1a	 imul	 r10, r10, 26
  000ff	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR byte$[rsp]
  00107	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  0010c	41 bb 01 00 00
	00		 mov	 r11d, 1
  00112	4d 6b db 19	 imul	 r11, r11, 25
  00116	48 8b 9c 24 20
	01 00 00	 mov	 rbx, QWORD PTR byte$[rsp]
  0011e	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00123	41 bb 01 00 00
	00		 mov	 r11d, 1
  00129	4d 6b db 18	 imul	 r11, r11, 24
  0012d	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR byte$[rsp]
  00135	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  0013a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00140	4d 6b db 17	 imul	 r11, r11, 23
  00144	48 8b b4 24 20
	01 00 00	 mov	 rsi, QWORD PTR byte$[rsp]
  0014c	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00151	41 bb 01 00 00
	00		 mov	 r11d, 1
  00157	4d 6b db 16	 imul	 r11, r11, 22
  0015b	48 8b ac 24 20
	01 00 00	 mov	 rbp, QWORD PTR byte$[rsp]
  00163	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  00168	41 bb 01 00 00
	00		 mov	 r11d, 1
  0016e	4d 6b db 15	 imul	 r11, r11, 21
  00172	4c 8b b4 24 20
	01 00 00	 mov	 r14, QWORD PTR byte$[rsp]
  0017a	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  0017f	41 be 01 00 00
	00		 mov	 r14d, 1
  00185	4d 6b f6 14	 imul	 r14, r14, 20
  00189	4c 8b bc 24 20
	01 00 00	 mov	 r15, QWORD PTR byte$[rsp]
  00191	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  00196	41 bf 01 00 00
	00		 mov	 r15d, 1
  0019c	4d 6b ff 13	 imul	 r15, r15, 19
  001a0	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  001a8	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  001ad	41 bc 01 00 00
	00		 mov	 r12d, 1
  001b3	4d 6b e4 12	 imul	 r12, r12, 18
  001b7	4c 8b ac 24 20
	01 00 00	 mov	 r13, QWORD PTR byte$[rsp]
  001bf	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001c4	44 89 a4 24 28
	01 00 00	 mov	 DWORD PTR tv157[rsp], r12d
  001cc	41 bd 01 00 00
	00		 mov	 r13d, 1
  001d2	4d 6b ed 11	 imul	 r13, r13, 17
  001d6	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  001de	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001e3	44 89 a4 24 2c
	01 00 00	 mov	 DWORD PTR tv161[rsp], r12d
  001eb	41 bd 01 00 00
	00		 mov	 r13d, 1
  001f1	4d 6b ed 10	 imul	 r13, r13, 16
  001f5	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  001fd	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00202	44 89 a4 24 30
	01 00 00	 mov	 DWORD PTR tv165[rsp], r12d
  0020a	41 bd 01 00 00
	00		 mov	 r13d, 1
  00210	4d 6b ed 0f	 imul	 r13, r13, 15
  00214	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0021c	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00221	44 89 a4 24 34
	01 00 00	 mov	 DWORD PTR tv169[rsp], r12d
  00229	41 bd 01 00 00
	00		 mov	 r13d, 1
  0022f	4d 6b ed 0e	 imul	 r13, r13, 14
  00233	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0023b	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00240	44 89 a4 24 38
	01 00 00	 mov	 DWORD PTR tv173[rsp], r12d
  00248	41 bd 01 00 00
	00		 mov	 r13d, 1
  0024e	4d 6b ed 0d	 imul	 r13, r13, 13
  00252	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0025a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0025f	44 89 a4 24 3c
	01 00 00	 mov	 DWORD PTR tv177[rsp], r12d
  00267	41 bd 01 00 00
	00		 mov	 r13d, 1
  0026d	4d 6b ed 0c	 imul	 r13, r13, 12
  00271	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00279	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0027e	44 89 a4 24 40
	01 00 00	 mov	 DWORD PTR tv181[rsp], r12d
  00286	41 bd 01 00 00
	00		 mov	 r13d, 1
  0028c	4d 6b ed 0b	 imul	 r13, r13, 11
  00290	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00298	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0029d	44 89 a4 24 44
	01 00 00	 mov	 DWORD PTR tv185[rsp], r12d
  002a5	41 bd 01 00 00
	00		 mov	 r13d, 1
  002ab	4d 6b ed 0a	 imul	 r13, r13, 10
  002af	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002b7	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002bc	44 89 a4 24 48
	01 00 00	 mov	 DWORD PTR tv189[rsp], r12d
  002c4	41 bd 01 00 00
	00		 mov	 r13d, 1
  002ca	4d 6b ed 09	 imul	 r13, r13, 9
  002ce	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002d6	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002db	44 89 a4 24 4c
	01 00 00	 mov	 DWORD PTR tv193[rsp], r12d
  002e3	41 bd 01 00 00
	00		 mov	 r13d, 1
  002e9	4d 6b ed 08	 imul	 r13, r13, 8
  002ed	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002f5	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002fa	44 89 a4 24 50
	01 00 00	 mov	 DWORD PTR tv197[rsp], r12d
  00302	4c 8b ac 24 d0
	01 00 00	 mov	 r13, QWORD PTR nq$[rsp]
  0030a	45 0f b6 6d 00	 movzx	 r13d, BYTE PTR [r13]
  0030f	41 c1 fd 05	 sar	 r13d, 5
  00313	4d 63 ed	 movsxd	 r13, r13d
  00316	4c 89 ac 24 78
	01 00 00	 mov	 QWORD PTR tv202[rsp], r13
  0031e	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?type@?1??FormatNQ@@9@9
  00325	4c 89 ac 24 70
	01 00 00	 mov	 QWORD PTR tv70[rsp], r13
  0032d	41 bd 01 00 00
	00		 mov	 r13d, 1
  00333	4d 6b ed 07	 imul	 r13, r13, 7
  00337	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0033f	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00344	44 89 a4 24 54
	01 00 00	 mov	 DWORD PTR tv208[rsp], r12d
  0034c	41 bd 01 00 00
	00		 mov	 r13d, 1
  00352	4d 6b ed 06	 imul	 r13, r13, 6
  00356	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0035e	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00363	44 89 a4 24 58
	01 00 00	 mov	 DWORD PTR tv212[rsp], r12d
  0036b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00371	4d 6b ed 05	 imul	 r13, r13, 5
  00375	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0037d	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00382	44 89 a4 24 5c
	01 00 00	 mov	 DWORD PTR tv216[rsp], r12d
  0038a	41 bd 01 00 00
	00		 mov	 r13d, 1
  00390	4d 6b ed 04	 imul	 r13, r13, 4
  00394	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0039c	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003a1	44 89 a4 24 60
	01 00 00	 mov	 DWORD PTR tv220[rsp], r12d
  003a9	41 bd 01 00 00
	00		 mov	 r13d, 1
  003af	4d 6b ed 03	 imul	 r13, r13, 3
  003b3	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003bb	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003c0	44 89 a4 24 64
	01 00 00	 mov	 DWORD PTR tv224[rsp], r12d
  003c8	41 bd 01 00 00
	00		 mov	 r13d, 1
  003ce	4d 6b ed 02	 imul	 r13, r13, 2
  003d2	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003da	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003df	44 89 a4 24 68
	01 00 00	 mov	 DWORD PTR tv228[rsp], r12d
  003e7	41 bd 01 00 00
	00		 mov	 r13d, 1
  003ed	4d 6b ed 01	 imul	 r13, r13, 1
  003f1	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003f9	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003fe	44 89 a4 24 6c
	01 00 00	 mov	 DWORD PTR tv232[rsp], r12d
  00406	41 bd 01 00 00
	00		 mov	 r13d, 1
  0040c	4d 6b ed 00	 imul	 r13, r13, 0
  00410	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00418	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0041d	89 84 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], eax
  00424	89 8c 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], ecx
  0042b	89 94 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], edx
  00432	44 89 84 24 00
	01 00 00	 mov	 DWORD PTR [rsp+256], r8d
  0043a	44 89 8c 24 f8
	00 00 00	 mov	 DWORD PTR [rsp+248], r9d
  00442	44 89 94 24 f0
	00 00 00	 mov	 DWORD PTR [rsp+240], r10d
  0044a	89 9c 24 e8 00
	00 00		 mov	 DWORD PTR [rsp+232], ebx
  00451	89 bc 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], edi
  00458	89 b4 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], esi
  0045f	89 ac 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ebp
  00466	44 89 9c 24 c8
	00 00 00	 mov	 DWORD PTR [rsp+200], r11d
  0046e	44 89 b4 24 c0
	00 00 00	 mov	 DWORD PTR [rsp+192], r14d
  00476	44 89 bc 24 b8
	00 00 00	 mov	 DWORD PTR [rsp+184], r15d
  0047e	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv157[rsp]
  00485	89 84 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], eax
  0048c	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv161[rsp]
  00493	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  0049a	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR tv165[rsp]
  004a1	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  004a8	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv169[rsp]
  004af	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  004b6	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR tv173[rsp]
  004bd	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  004c4	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR tv177[rsp]
  004cb	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  004d2	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv181[rsp]
  004d9	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  004e0	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv185[rsp]
  004e7	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  004eb	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR tv189[rsp]
  004f2	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  004f6	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR tv193[rsp]
  004fd	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00501	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  00508	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0050c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR tv70[rsp]
  00514	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv202[rsp]
  0051c	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00520	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00525	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  0052c	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00530	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR tv212[rsp]
  00537	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0053b	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR tv216[rsp]
  00542	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00546	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR tv220[rsp]
  0054d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00551	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR tv224[rsp]
  00558	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0055c	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tv228[rsp]
  00563	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00567	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR tv232[rsp]
  0056e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00572	45 8b cc	 mov	 r9d, r12d
  00575	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195791
  0057c	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00584	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0058c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2846 : 
; 2847 :         "NQ:  %02X%02X%02X%02X %02X%02X%02X%02X  (typ:%s)\n"
; 2848 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2849 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2850 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2851 : 
; 2852 :         , byte[ 0],byte[ 1],byte[ 2],byte[ 3],  byte[ 4],byte[ 5],byte[ 6],byte[ 7]
; 2853 :         , type[ nq->flags >> 5 ]
; 2854 :         , byte[ 8],byte[ 9],byte[10],byte[11],  byte[12],byte[13],byte[14],byte[15]
; 2855 :         , byte[16],byte[17],byte[18],byte[19],  byte[20],byte[21],byte[22],byte[23]
; 2856 :         , byte[24],byte[25],byte[26],byte[27],  byte[28],byte[29],byte[30],byte[31]
; 2857 :     );
; 2858 : 
; 2859 :     return buf;

  00592	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatNQ:

; 2860 : }

  0059a	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  005a1	41 5f		 pop	 r15
  005a3	41 5e		 pop	 r14
  005a5	41 5d		 pop	 r13
  005a7	41 5c		 pop	 r12
  005a9	5f		 pop	 rdi
  005aa	5e		 pop	 rsi
  005ab	5d		 pop	 rbp
  005ac	5b		 pop	 rbx
  005ad	c3		 ret	 0
FormatNQ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv79 = 96
bad_cls$ = 100
cls$ = 104
tv94 = 112
$T1 = 120
by3$ = 128
typ$ = 136
val$ = 144
sdc_info$ = 160
__$ArrayPad$ = 416
nd$ = 448
buf$ = 456
bufsz$ = 464
FormatND PROC

; 2735 : {

$LN22:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2736 :     const char* val;
; 2737 :     const char* cls;
; 2738 :     const char* by3;
; 2739 :     const char* typ;
; 2740 :     char bad_cls[4];
; 2741 :     char sdc_info[256];
; 2742 :     static const char* css_class[] = { "UNKNOWN", "CHPATH", "CTCA" };
; 2743 :     static const char* val_type[] =
; 2744 :     {
; 2745 :         "VALID", "UNSURE", "INVALID", "3", "4", "5", "6", "7",
; 2746 :     };
; 2747 :     static const char* dev_class[] =
; 2748 :     {
; 2749 :         "UNKNOWN",
; 2750 :         "DASD",
; 2751 :         "TAPE",
; 2752 :         "READER",
; 2753 :         "PUNCH",
; 2754 :         "PRINTER",
; 2755 :         "COMM",
; 2756 :         "DISPLAY",
; 2757 :         "CONSOLE",
; 2758 :         "CTCA",
; 2759 :         "SWITCH",
; 2760 :         "PROTO",
; 2761 :     };
; 2762 : 
; 2763 :     if (!buf)

  00028	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00031	75 07		 jne	 SHORT $LN4@FormatND

; 2764 :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 e1 02 00 00	 jmp	 $LN1@FormatND
$LN4@FormatND:

; 2765 :     if (bufsz)

  0003a	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00043	74 15		 je	 SHORT $LN5@FormatND

; 2766 :         buf[0] = 0;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	48 6b c0 00	 imul	 rax, rax, 0
  0004e	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00056	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN5@FormatND:

; 2767 :     if (bufsz <= 1 || !nd)

  0005a	48 83 bc 24 d0
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00063	76 0b		 jbe	 SHORT $LN7@FormatND
  00065	48 83 bc 24 c0
	01 00 00 00	 cmp	 QWORD PTR nd$[rsp], 0
  0006e	75 0d		 jne	 SHORT $LN6@FormatND
$LN7@FormatND:

; 2768 :         return buf;

  00070	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00078	e9 9e 02 00 00	 jmp	 $LN1@FormatND
$LN6@FormatND:

; 2769 : 
; 2770 :     val = val_type[ nd->flags >> 5 ];

  0007d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00085	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00088	c1 f8 05	 sar	 eax, 5
  0008b	48 98		 cdqe
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?val_type@?1??FormatND@@9@9
  00094	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00098	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR val$[rsp], rax

; 2771 : 
; 2772 :     switch (nd->flags >> 5)

  000a0	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  000a8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ab	c1 f8 05	 sar	 eax, 5
  000ae	89 44 24 60	 mov	 DWORD PTR tv79[rsp], eax
  000b2	83 7c 24 60 00	 cmp	 DWORD PTR tv79[rsp], 0
  000b7	74 17		 je	 SHORT $LN8@FormatND
  000b9	83 7c 24 60 01	 cmp	 DWORD PTR tv79[rsp], 1
  000be	74 10		 je	 SHORT $LN9@FormatND
  000c0	83 7c 24 60 02	 cmp	 DWORD PTR tv79[rsp], 2
  000c5	0f 84 fb 01 00
	00		 je	 $LN15@FormatND
  000cb	e9 15 02 00 00	 jmp	 $LN16@FormatND
$LN8@FormatND:
$LN9@FormatND:

; 2773 :     {
; 2774 :     case ND_VAL_VALID:
; 2775 :     case ND_VAL_UNSURE:
; 2776 : 
; 2777 :         cls = NULL;

  000d0	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR cls$[rsp], 0

; 2778 :         if (nd->flags & 0x01)

  000d9	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  000e1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e4	83 e0 01	 and	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	74 4e		 je	 SHORT $LN10@FormatND

; 2779 :         {
; 2780 :             typ = "CSS";

  000eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195752
  000f2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR typ$[rsp], rax

; 2781 :             by3 = "CHPID";

  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195753
  00101	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR by3$[rsp], rax

; 2782 :             if (nd->cls < _countof( css_class ))

  00109	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00111	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00115	48 83 f8 03	 cmp	 rax, 3
  00119	73 1c		 jae	 SHORT $LN12@FormatND

; 2783 :                 cls = css_class[ nd->cls ];

  0011b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00123	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?css_class@?1??FormatND@@9@9
  0012e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00132	48 89 44 24 68	 mov	 QWORD PTR cls$[rsp], rax
$LN12@FormatND:

; 2784 :         }

  00137	eb 75		 jmp	 SHORT $LN11@FormatND
$LN10@FormatND:

; 2785 :         else
; 2786 :         {
; 2787 :             typ = "DEV";

  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195755
  00140	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR typ$[rsp], rax

; 2788 :             by3 = (nd->cls == ND_DEV_PROTO) ? "LINK" : "BYTE3";

  00148	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00150	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00154	83 f8 0b	 cmp	 eax, 11
  00157	75 0e		 jne	 SHORT $LN18@FormatND
  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195756
  00160	48 89 44 24 70	 mov	 QWORD PTR tv94[rsp], rax
  00165	eb 0c		 jmp	 SHORT $LN19@FormatND
$LN18@FormatND:
  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195757
  0016e	48 89 44 24 70	 mov	 QWORD PTR tv94[rsp], rax
$LN19@FormatND:
  00173	48 8b 44 24 70	 mov	 rax, QWORD PTR tv94[rsp]
  00178	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR by3$[rsp], rax

; 2789 :             if (nd->cls < _countof( dev_class ))

  00180	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00188	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0018c	48 83 f8 0c	 cmp	 rax, 12
  00190	73 1c		 jae	 SHORT $LN13@FormatND

; 2790 :                 cls = dev_class[ nd->cls ];

  00192	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  0019a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?dev_class@?1??FormatND@@9@9
  001a5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001a9	48 89 44 24 68	 mov	 QWORD PTR cls$[rsp], rax
$LN13@FormatND:
$LN11@FormatND:

; 2791 :         }
; 2792 :         if (!cls)

  001ae	48 83 7c 24 68
	00		 cmp	 QWORD PTR cls$[rsp], 0
  001b4	75 57		 jne	 SHORT $LN14@FormatND

; 2793 :         {
; 2794 :             snprintf( bad_cls, sizeof(bad_cls), "%u", nd->cls );

  001b6	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  001be	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001c2	44 8b c8	 mov	 r9d, eax
  001c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195760
  001cc	ba 04 00 00 00	 mov	 edx, 4
  001d1	48 8d 4c 24 64	 lea	 rcx, QWORD PTR bad_cls$[rsp]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2795 :             bad_cls[3] = 0;

  001dc	b8 01 00 00 00	 mov	 eax, 1
  001e1	48 6b c0 03	 imul	 rax, rax, 3
  001e5	48 89 44 24 78	 mov	 QWORD PTR $T1[rsp], rax
  001ea	48 83 7c 24 78
	04		 cmp	 QWORD PTR $T1[rsp], 4
  001f0	73 02		 jae	 SHORT $LN20@FormatND
  001f2	eb 05		 jmp	 SHORT $LN21@FormatND
$LN20@FormatND:
  001f4	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@FormatND:
  001f9	48 8b 44 24 78	 mov	 rax, QWORD PTR $T1[rsp]
  001fe	c6 44 04 64 00	 mov	 BYTE PTR bad_cls$[rsp+rax], 0

; 2796 :             cls = bad_cls;

  00203	48 8d 44 24 64	 lea	 rax, QWORD PTR bad_cls$[rsp]
  00208	48 89 44 24 68	 mov	 QWORD PTR cls$[rsp], rax
$LN14@FormatND:

; 2797 :         }
; 2798 :         snprintf( buf, bufsz,

  0020d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  00215	48 83 c0 04	 add	 rax, 4
  00219	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0021f	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR sdc_info$[rsp]
  00227	48 8b c8	 mov	 rcx, rax
  0022a	e8 00 00 00 00	 call	 FormatSDC
  0022f	b9 01 00 00 00	 mov	 ecx, 1
  00234	48 6b c9 01	 imul	 rcx, rcx, 1
  00238	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR nd$[rsp]
  00240	0f b6 4c 0a 1e	 movzx	 ecx, BYTE PTR [rdx+rcx+30]
  00245	ba 01 00 00 00	 mov	 edx, 1
  0024a	48 6b d2 00	 imul	 rdx, rdx, 0
  0024e	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR nd$[rsp]
  00256	41 0f b6 54 10
	1e		 movzx	 edx, BYTE PTR [r8+rdx+30]
  0025c	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR nd$[rsp]
  00264	45 0f b6 40 03	 movzx	 r8d, BYTE PTR [r8+3]
  00269	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0026e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00272	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00276	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0027b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR by3$[rsp]
  00283	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00288	48 8b 44 24 68	 mov	 rax, QWORD PTR cls$[rsp]
  0028d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00292	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR typ$[rsp]
  0029a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029f	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR val$[rsp]
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195761
  002ae	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  002b6	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2799 : 
; 2800 :             "ND:  val:%s typ:%s cls:%s %s:%02X tag:%02X%02X\n     %s"
; 2801 : 
; 2802 :             , val
; 2803 :             , typ
; 2804 :             , cls
; 2805 :             , by3, nd->ua
; 2806 :             , nd->tag[0], nd->tag[1]
; 2807 :             , FormatSDC( &nd->info, sdc_info, sizeof(sdc_info))
; 2808 :         );
; 2809 :         break;

  002c4	eb 4d		 jmp	 SHORT $LN2@FormatND
$LN15@FormatND:

; 2810 : 
; 2811 :     case ND_VAL_INVALID:
; 2812 : 
; 2813 :         snprintf( buf, bufsz, "ND:  val:INVALID\n" );

  002c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195763
  002cd	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  002d5	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2814 :         break;

  002e3	eb 2e		 jmp	 SHORT $LN2@FormatND
$LN16@FormatND:

; 2815 : 
; 2816 :     default:
; 2817 : 
; 2818 :         snprintf( buf, bufsz, "ND:  val:%u (invalid)\n",

  002e5	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR nd$[rsp]
  002ed	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f0	c1 f8 05	 sar	 eax, 5
  002f3	44 8b c8	 mov	 r9d, eax
  002f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195765
  002fd	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00305	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN2@FormatND:

; 2819 :             (int)(nd->flags >> 5) );
; 2820 :         break;
; 2821 :     }
; 2822 : 
; 2823 :     return buf;

  00313	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatND:
$LN17@FormatND:

; 2824 : }

  0031b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00323	48 33 cc	 xor	 rcx, rsp
  00326	e8 00 00 00 00	 call	 __security_check_cookie
  0032b	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00332	c3		 ret	 0
FormatND ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 32
temp$ = 36
data$ = 64
len$ = 72
buf$ = 80
bufsz$ = 88
FormatBytes PROC

; 2667 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2668 :     char temp[4];
; 2669 :     int  i;
; 2670 : 
; 2671 :     for (i=0; i < len; ++i)

  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN4@FormatByte
$LN2@FormatByte:
  00021	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@FormatByte:
  0002b	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0002f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00033	7d 5d		 jge	 SHORT $LN3@FormatByte

; 2672 :     {
; 2673 :         if (i == 4)

  00035	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  0003a	75 17		 jne	 SHORT $LN5@FormatByte

; 2674 :             strlcat( buf, " ", bufsz );

  0003c	4c 8b 44 24 58	 mov	 r8, QWORD PTR bufsz$[rsp]
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195660
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN5@FormatByte:

; 2675 :         MSGBUF( temp, "%02X", data[i] );

  00053	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0005d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00061	44 8b c8	 mov	 r9d, eax
  00064	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195661
  0006b	ba 04 00 00 00	 mov	 edx, 4
  00070	48 8d 4c 24 24	 lea	 rcx, QWORD PTR temp$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2676 :         strlcat( buf, temp, bufsz );

  0007b	4c 8b 44 24 58	 mov	 r8, QWORD PTR bufsz$[rsp]
  00080	48 8d 54 24 24	 lea	 rdx, QWORD PTR temp$[rsp]
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2677 :     }

  00090	eb 8f		 jmp	 SHORT $LN2@FormatByte
$LN3@FormatByte:

; 2678 : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
FormatBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
byte$ = 320
iid$ = 328
tv162 = 332
tv166 = 336
tv170 = 340
tv174 = 344
tv178 = 348
tv182 = 352
tv186 = 356
tv190 = 360
tv194 = 364
tv198 = 368
tv202 = 372
tv206 = 376
tv210 = 380
tv214 = 384
tv218 = 388
tv222 = 392
tv226 = 396
tv230 = 400
tv237 = 404
tv242 = 408
tv247 = 412
tv252 = 416
neq$ = 512
buf$ = 520
bufsz$ = 528
FormatNEQ PROC

; 2629 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	55		 push	 rbp
  00011	56		 push	 rsi
  00012	57		 push	 rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	41 57		 push	 r15
  0001b	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H

; 2630 :     BYTE* byte = (BYTE*) neq;

  00022	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR neq$[rsp]
  0002a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR byte$[rsp], rax

; 2631 :     U16 iid;
; 2632 : 
; 2633 :     if (!buf)

  00032	48 83 bc 24 08
	02 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0003b	75 07		 jne	 SHORT $LN2@FormatNEQ

; 2634 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 dc 05 00 00	 jmp	 $LN1@FormatNEQ
$LN2@FormatNEQ:

; 2635 :     if (bufsz)

  00044	48 83 bc 24 10
	02 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  0004d	74 15		 je	 SHORT $LN3@FormatNEQ

; 2636 :         buf[0] = 0;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	48 6b c0 00	 imul	 rax, rax, 0
  00058	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00060	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatNEQ:

; 2637 :     if (bufsz <= 1 || !neq)

  00064	48 83 bc 24 10
	02 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  0006d	76 0b		 jbe	 SHORT $LN5@FormatNEQ
  0006f	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR neq$[rsp], 0
  00078	75 0d		 jne	 SHORT $LN4@FormatNEQ
$LN5@FormatNEQ:

; 2638 :         return buf;

  0007a	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00082	e9 99 05 00 00	 jmp	 $LN1@FormatNEQ
$LN4@FormatNEQ:

; 2639 : 
; 2640 :     iid = fetch_hw( &neq->iid );

  00087	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR neq$[rsp]
  0008f	48 83 c0 02	 add	 rax, 2
  00093	48 8b c8	 mov	 rcx, rax
  00096	e8 00 00 00 00	 call	 fetch_hw_noswap
  0009b	0f b7 c8	 movzx	 ecx, ax
  0009e	e8 00 00 00 00	 call	 _byteswap_ushort
  000a3	66 89 84 24 48
	01 00 00	 mov	 WORD PTR iid$[rsp], ax

; 2641 : 
; 2642 :     snprintf( buf, bufsz,

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 1f	 imul	 rax, rax, 31
  000b4	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR byte$[rsp]
  000bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c0	b9 01 00 00 00	 mov	 ecx, 1
  000c5	48 6b c9 1e	 imul	 rcx, rcx, 30
  000c9	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR byte$[rsp]
  000d1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d5	ba 01 00 00 00	 mov	 edx, 1
  000da	48 6b d2 1d	 imul	 rdx, rdx, 29
  000de	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR byte$[rsp]
  000e6	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000eb	41 b8 01 00 00
	00		 mov	 r8d, 1
  000f1	4d 6b c0 1c	 imul	 r8, r8, 28
  000f5	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR byte$[rsp]
  000fd	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00102	41 b9 01 00 00
	00		 mov	 r9d, 1
  00108	4d 6b c9 1b	 imul	 r9, r9, 27
  0010c	4c 8b 94 24 40
	01 00 00	 mov	 r10, QWORD PTR byte$[rsp]
  00114	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00119	41 ba 01 00 00
	00		 mov	 r10d, 1
  0011f	4d 6b d2 1a	 imul	 r10, r10, 26
  00123	4c 8b 9c 24 40
	01 00 00	 mov	 r11, QWORD PTR byte$[rsp]
  0012b	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00130	41 bb 01 00 00
	00		 mov	 r11d, 1
  00136	4d 6b db 19	 imul	 r11, r11, 25
  0013a	48 8b 9c 24 40
	01 00 00	 mov	 rbx, QWORD PTR byte$[rsp]
  00142	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00147	41 bb 01 00 00
	00		 mov	 r11d, 1
  0014d	4d 6b db 18	 imul	 r11, r11, 24
  00151	48 8b bc 24 40
	01 00 00	 mov	 rdi, QWORD PTR byte$[rsp]
  00159	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  0015e	41 bb 01 00 00
	00		 mov	 r11d, 1
  00164	4d 6b db 17	 imul	 r11, r11, 23
  00168	48 8b b4 24 40
	01 00 00	 mov	 rsi, QWORD PTR byte$[rsp]
  00170	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00175	41 bb 01 00 00
	00		 mov	 r11d, 1
  0017b	4d 6b db 16	 imul	 r11, r11, 22
  0017f	48 8b ac 24 40
	01 00 00	 mov	 rbp, QWORD PTR byte$[rsp]
  00187	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  0018c	41 bb 01 00 00
	00		 mov	 r11d, 1
  00192	4d 6b db 15	 imul	 r11, r11, 21
  00196	4c 8b b4 24 40
	01 00 00	 mov	 r14, QWORD PTR byte$[rsp]
  0019e	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  001a3	41 be 01 00 00
	00		 mov	 r14d, 1
  001a9	4d 6b f6 14	 imul	 r14, r14, 20
  001ad	4c 8b bc 24 40
	01 00 00	 mov	 r15, QWORD PTR byte$[rsp]
  001b5	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  001ba	41 bf 01 00 00
	00		 mov	 r15d, 1
  001c0	4d 6b ff 13	 imul	 r15, r15, 19
  001c4	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  001cc	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  001d1	41 bc 01 00 00
	00		 mov	 r12d, 1
  001d7	4d 6b e4 12	 imul	 r12, r12, 18
  001db	4c 8b ac 24 40
	01 00 00	 mov	 r13, QWORD PTR byte$[rsp]
  001e3	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001e8	44 89 a4 24 4c
	01 00 00	 mov	 DWORD PTR tv162[rsp], r12d
  001f0	41 bd 01 00 00
	00		 mov	 r13d, 1
  001f6	4d 6b ed 11	 imul	 r13, r13, 17
  001fa	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00202	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00207	44 89 a4 24 50
	01 00 00	 mov	 DWORD PTR tv166[rsp], r12d
  0020f	41 bd 01 00 00
	00		 mov	 r13d, 1
  00215	4d 6b ed 10	 imul	 r13, r13, 16
  00219	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00221	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00226	44 89 a4 24 54
	01 00 00	 mov	 DWORD PTR tv170[rsp], r12d
  0022e	41 bd 01 00 00
	00		 mov	 r13d, 1
  00234	4d 6b ed 0f	 imul	 r13, r13, 15
  00238	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00240	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00245	44 89 a4 24 58
	01 00 00	 mov	 DWORD PTR tv174[rsp], r12d
  0024d	41 bd 01 00 00
	00		 mov	 r13d, 1
  00253	4d 6b ed 0e	 imul	 r13, r13, 14
  00257	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0025f	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00264	44 89 a4 24 5c
	01 00 00	 mov	 DWORD PTR tv178[rsp], r12d
  0026c	41 bd 01 00 00
	00		 mov	 r13d, 1
  00272	4d 6b ed 0d	 imul	 r13, r13, 13
  00276	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0027e	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00283	44 89 a4 24 60
	01 00 00	 mov	 DWORD PTR tv182[rsp], r12d
  0028b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00291	4d 6b ed 0c	 imul	 r13, r13, 12
  00295	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  0029d	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002a2	44 89 a4 24 64
	01 00 00	 mov	 DWORD PTR tv186[rsp], r12d
  002aa	41 bd 01 00 00
	00		 mov	 r13d, 1
  002b0	4d 6b ed 0b	 imul	 r13, r13, 11
  002b4	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002bc	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002c1	44 89 a4 24 68
	01 00 00	 mov	 DWORD PTR tv190[rsp], r12d
  002c9	41 bd 01 00 00
	00		 mov	 r13d, 1
  002cf	4d 6b ed 0a	 imul	 r13, r13, 10
  002d3	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002db	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002e0	44 89 a4 24 6c
	01 00 00	 mov	 DWORD PTR tv194[rsp], r12d
  002e8	41 bd 01 00 00
	00		 mov	 r13d, 1
  002ee	4d 6b ed 09	 imul	 r13, r13, 9
  002f2	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  002fa	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002ff	44 89 a4 24 70
	01 00 00	 mov	 DWORD PTR tv198[rsp], r12d
  00307	41 bd 01 00 00
	00		 mov	 r13d, 1
  0030d	4d 6b ed 08	 imul	 r13, r13, 8
  00311	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00319	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0031e	44 89 a4 24 74
	01 00 00	 mov	 DWORD PTR tv202[rsp], r12d
  00326	41 bd 01 00 00
	00		 mov	 r13d, 1
  0032c	4d 6b ed 07	 imul	 r13, r13, 7
  00330	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00338	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0033d	44 89 a4 24 78
	01 00 00	 mov	 DWORD PTR tv206[rsp], r12d
  00345	41 bd 01 00 00
	00		 mov	 r13d, 1
  0034b	4d 6b ed 06	 imul	 r13, r13, 6
  0034f	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00357	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0035c	44 89 a4 24 7c
	01 00 00	 mov	 DWORD PTR tv210[rsp], r12d
  00364	41 bd 01 00 00
	00		 mov	 r13d, 1
  0036a	4d 6b ed 05	 imul	 r13, r13, 5
  0036e	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00376	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0037b	44 89 a4 24 80
	01 00 00	 mov	 DWORD PTR tv214[rsp], r12d
  00383	41 bd 01 00 00
	00		 mov	 r13d, 1
  00389	4d 6b ed 04	 imul	 r13, r13, 4
  0038d	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00395	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0039a	44 89 a4 24 84
	01 00 00	 mov	 DWORD PTR tv218[rsp], r12d
  003a2	41 bd 01 00 00
	00		 mov	 r13d, 1
  003a8	4d 6b ed 03	 imul	 r13, r13, 3
  003ac	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003b4	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003b9	44 89 a4 24 88
	01 00 00	 mov	 DWORD PTR tv222[rsp], r12d
  003c1	41 bd 01 00 00
	00		 mov	 r13d, 1
  003c7	4d 6b ed 02	 imul	 r13, r13, 2
  003cb	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003d3	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003d8	44 89 a4 24 8c
	01 00 00	 mov	 DWORD PTR tv226[rsp], r12d
  003e0	41 bd 01 00 00
	00		 mov	 r13d, 1
  003e6	4d 6b ed 01	 imul	 r13, r13, 1
  003ea	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  003f2	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  003f7	44 89 a4 24 90
	01 00 00	 mov	 DWORD PTR tv230[rsp], r12d
  003ff	41 bd 01 00 00
	00		 mov	 r13d, 1
  00405	4d 6b ed 00	 imul	 r13, r13, 0
  00409	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR byte$[rsp]
  00411	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00416	4c 8b ac 24 00
	02 00 00	 mov	 r13, QWORD PTR neq$[rsp]
  0041e	45 0f b6 6d 04	 movzx	 r13d, BYTE PTR [r13+4]
  00423	44 89 ac 24 94
	01 00 00	 mov	 DWORD PTR tv237[rsp], r13d
  0042b	44 0f b7 ac 24
	48 01 00 00	 movzx	 r13d, WORD PTR iid$[rsp]
  00434	41 81 e5 ff 00
	00 00		 and	 r13d, 255		; 000000ffH
  0043b	45 0f b6 ed	 movzx	 r13d, r13b
  0043f	44 89 ac 24 98
	01 00 00	 mov	 DWORD PTR tv242[rsp], r13d
  00447	44 0f b7 ac 24
	48 01 00 00	 movzx	 r13d, WORD PTR iid$[rsp]
  00450	41 c1 fd 08	 sar	 r13d, 8
  00454	45 0f b6 ed	 movzx	 r13d, r13b
  00458	44 89 ac 24 9c
	01 00 00	 mov	 DWORD PTR tv247[rsp], r13d
  00460	4c 8b ac 24 00
	02 00 00	 mov	 r13, QWORD PTR neq$[rsp]
  00468	45 0f b6 6d 00	 movzx	 r13d, BYTE PTR [r13]
  0046d	41 c1 fd 06	 sar	 r13d, 6
  00471	4d 63 ed	 movsxd	 r13, r13d
  00474	4c 89 ac 24 a0
	01 00 00	 mov	 QWORD PTR tv252[rsp], r13
  0047c	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:NED_NEQ_type
  00483	89 84 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], eax
  0048a	89 8c 24 28 01
	00 00		 mov	 DWORD PTR [rsp+296], ecx
  00491	89 94 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], edx
  00498	44 89 84 24 18
	01 00 00	 mov	 DWORD PTR [rsp+280], r8d
  004a0	44 89 8c 24 10
	01 00 00	 mov	 DWORD PTR [rsp+272], r9d
  004a8	44 89 94 24 08
	01 00 00	 mov	 DWORD PTR [rsp+264], r10d
  004b0	89 9c 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], ebx
  004b7	89 bc 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], edi
  004be	89 b4 24 f0 00
	00 00		 mov	 DWORD PTR [rsp+240], esi
  004c5	89 ac 24 e8 00
	00 00		 mov	 DWORD PTR [rsp+232], ebp
  004cc	44 89 9c 24 e0
	00 00 00	 mov	 DWORD PTR [rsp+224], r11d
  004d4	44 89 b4 24 d8
	00 00 00	 mov	 DWORD PTR [rsp+216], r14d
  004dc	44 89 bc 24 d0
	00 00 00	 mov	 DWORD PTR [rsp+208], r15d
  004e4	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR tv162[rsp]
  004eb	89 84 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], eax
  004f2	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv166[rsp]
  004f9	89 84 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], eax
  00500	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv170[rsp]
  00507	89 84 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], eax
  0050e	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR tv174[rsp]
  00515	89 84 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], eax
  0051c	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR tv178[rsp]
  00523	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  0052a	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR tv182[rsp]
  00531	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  00538	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR tv186[rsp]
  0053f	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  00546	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tv190[rsp]
  0054d	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  00554	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR tv194[rsp]
  0055b	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  00562	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR tv198[rsp]
  00569	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  00570	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR tv202[rsp]
  00577	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  0057b	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR tv206[rsp]
  00582	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00586	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR tv210[rsp]
  0058d	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00591	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR tv214[rsp]
  00598	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0059c	8b 84 24 84 01
	00 00		 mov	 eax, DWORD PTR tv218[rsp]
  005a3	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  005a7	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR tv222[rsp]
  005ae	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  005b2	8b 84 24 8c 01
	00 00		 mov	 eax, DWORD PTR tv226[rsp]
  005b9	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  005bd	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR tv230[rsp]
  005c4	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  005c8	44 89 64 24 38	 mov	 DWORD PTR [rsp+56], r12d
  005cd	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR tv237[rsp]
  005d4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005d8	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR tv242[rsp]
  005df	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005e3	8b 84 24 9c 01
	00 00		 mov	 eax, DWORD PTR tv247[rsp]
  005ea	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005ee	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR tv252[rsp]
  005f6	4d 8b 4c c5 00	 mov	 r9, QWORD PTR [r13+rax*8]
  005fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195643
  00602	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  0060a	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2643 : 
; 2644 :         "NEQ: typ:%s IID:%02X%02X DDTO:%u\n"
; 2645 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2646 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2647 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2648 :         "     %02X%02X%02X%02X %02X%02X%02X%02X\n"
; 2649 : 
; 2650 :         , NED_NEQ_type[ neq->flags >> 6 ]
; 2651 :         , (BYTE)(iid >> 8), (BYTE)(iid & 0xFF)
; 2652 :         , neq->ddto
; 2653 :         , byte[ 0],byte[ 1],byte[ 2],byte[ 3],  byte[ 4],byte[ 5],byte[ 6],byte[ 7]
; 2654 :         , byte[ 8],byte[ 9],byte[10],byte[11],  byte[12],byte[13],byte[14],byte[15]
; 2655 :         , byte[16],byte[17],byte[18],byte[19],  byte[20],byte[21],byte[22],byte[23]
; 2656 :         , byte[24],byte[25],byte[26],byte[27],  byte[28],byte[29],byte[30],byte[31]
; 2657 :     );
; 2658 : 
; 2659 :     return buf;

  00618	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatNEQ:

; 2660 : }

  00620	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00627	41 5f		 pop	 r15
  00629	41 5e		 pop	 r14
  0062b	41 5d		 pop	 r13
  0062d	41 5c		 pop	 r12
  0062f	5f		 pop	 rdi
  00630	5e		 pop	 rsi
  00631	5d		 pop	 rbp
  00632	5b		 pop	 rbx
  00633	c3		 ret	 0
FormatNEQ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
bad_typ$ = 96
bad_class$1 = 100
typ$ = 104
$T2 = 112
$T3 = 120
tv166 = 128
cls$4 = 136
tv174 = 144
tv180 = 152
tv213 = 160
tv220 = 168
tv226 = 176
sdc_info$ = 192
__$ArrayPad$ = 448
ned$ = 480
buf$ = 488
bufsz$ = 496
FormatNED PROC

; 2538 : {

$LN29:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2539 :     const char* typ;
; 2540 :     char bad_typ[4];
; 2541 :     char sdc_info[256];
; 2542 :     static const char* sn_ind[] = { "NEXT", "UNIQUE", "NODE", "CODE3" };
; 2543 :     static const char* ned_type[] = { "UNSPEC", "DEVICE", "CTLUNIT" };
; 2544 :     static const char* dev_class[] =
; 2545 :     {
; 2546 :         "UNKNOWN",
; 2547 :         "DASD",
; 2548 :         "TAPE",
; 2549 :         "READER",
; 2550 :         "PUNCH",
; 2551 :         "PRINTER",
; 2552 :         "COMM",
; 2553 :         "DISPLAY",
; 2554 :         "CONSOLE",
; 2555 :         "CTCA",
; 2556 :         "SWITCH",
; 2557 :         "PROTO",
; 2558 :     };
; 2559 : 
; 2560 :     if (!buf)

  00028	48 83 bc 24 e8
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00031	75 07		 jne	 SHORT $LN2@FormatNED

; 2561 :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 4c 04 00 00	 jmp	 $LN1@FormatNED
$LN2@FormatNED:

; 2562 :     if (bufsz)

  0003a	48 83 bc 24 f0
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00043	74 15		 je	 SHORT $LN3@FormatNED

; 2563 :         buf[0] = 0;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	48 6b c0 00	 imul	 rax, rax, 0
  0004e	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00056	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatNED:

; 2564 :     if (bufsz <= 1 || !ned)

  0005a	48 83 bc 24 f0
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00063	76 0b		 jbe	 SHORT $LN5@FormatNED
  00065	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR ned$[rsp], 0
  0006e	75 0d		 jne	 SHORT $LN4@FormatNED
$LN5@FormatNED:

; 2565 :         return buf;

  00070	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00078	e9 09 04 00 00	 jmp	 $LN1@FormatNED
$LN4@FormatNED:

; 2566 : 
; 2567 :     if (ned->type < _countof( ned_type ))

  0007d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00085	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00089	48 83 f8 03	 cmp	 rax, 3
  0008d	73 1e		 jae	 SHORT $LN6@FormatNED

; 2568 :         typ = ned_type[ ned->type ];

  0008f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00097	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ned_type@?1??FormatNED@@9@9
  000a2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000a6	48 89 44 24 68	 mov	 QWORD PTR typ$[rsp], rax
  000ab	eb 57		 jmp	 SHORT $LN7@FormatNED
$LN6@FormatNED:

; 2569 :     else
; 2570 :     {
; 2571 :         snprintf( bad_typ, sizeof(bad_typ), "%u", ned->type );

  000ad	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  000b5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000b9	44 8b c8	 mov	 r9d, eax
  000bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195605
  000c3	ba 04 00 00 00	 mov	 edx, 4
  000c8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR bad_typ$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2572 :         bad_typ[3] = 0;

  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	48 6b c0 03	 imul	 rax, rax, 3
  000dc	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  000e1	48 83 7c 24 70
	04		 cmp	 QWORD PTR $T2[rsp], 4
  000e7	73 02		 jae	 SHORT $LN13@FormatNED
  000e9	eb 05		 jmp	 SHORT $LN14@FormatNED
$LN13@FormatNED:
  000eb	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN14@FormatNED:
  000f0	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp]
  000f5	c6 44 04 60 00	 mov	 BYTE PTR bad_typ$[rsp+rax], 0

; 2573 :         typ = bad_typ;

  000fa	48 8d 44 24 60	 lea	 rax, QWORD PTR bad_typ$[rsp]
  000ff	48 89 44 24 68	 mov	 QWORD PTR typ$[rsp], rax
$LN7@FormatNED:

; 2574 :     }
; 2575 : 
; 2576 : 
; 2577 :     if (ned->type == NED_TYP_DEVICE)

  00104	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  0010c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00110	83 f8 01	 cmp	 eax, 1
  00113	0f 85 02 02 00
	00		 jne	 $LN8@FormatNED

; 2578 :     {
; 2579 :         const char* cls;
; 2580 :         char bad_class[4];
; 2581 : 
; 2582 :         if (ned->cls < _countof( dev_class ))

  00119	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00121	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00125	48 83 f8 0c	 cmp	 rax, 12
  00129	73 21		 jae	 SHORT $LN10@FormatNED

; 2583 :             cls = dev_class[ ned->cls ];

  0012b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00133	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?dev_class@?1??FormatNED@@9@9
  0013e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00142	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cls$4[rsp], rax
  0014a	eb 5a		 jmp	 SHORT $LN11@FormatNED
$LN10@FormatNED:

; 2584 :         else
; 2585 :         {
; 2586 :             snprintf( bad_class, sizeof(bad_class), "%u", ned->cls );

  0014c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00154	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00158	44 8b c8	 mov	 r9d, eax
  0015b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195610
  00162	ba 04 00 00 00	 mov	 edx, 4
  00167	48 8d 4c 24 64	 lea	 rcx, QWORD PTR bad_class$1[rsp]
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2587 :             bad_class[3] = 0;

  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	48 6b c0 03	 imul	 rax, rax, 3
  0017b	48 89 44 24 78	 mov	 QWORD PTR $T3[rsp], rax
  00180	48 83 7c 24 78
	04		 cmp	 QWORD PTR $T3[rsp], 4
  00186	73 02		 jae	 SHORT $LN15@FormatNED
  00188	eb 05		 jmp	 SHORT $LN16@FormatNED
$LN15@FormatNED:
  0018a	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@FormatNED:
  0018f	48 8b 44 24 78	 mov	 rax, QWORD PTR $T3[rsp]
  00194	c6 44 04 64 00	 mov	 BYTE PTR bad_class$1[rsp+rax], 0

; 2588 :             cls = bad_class;

  00199	48 8d 44 24 64	 lea	 rax, QWORD PTR bad_class$1[rsp]
  0019e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cls$4[rsp], rax
$LN11@FormatNED:

; 2589 :         }
; 2590 : 
; 2591 :         snprintf( buf, bufsz,

  001a6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  001ae	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001b2	83 e0 01	 and	 eax, 1
  001b5	85 c0		 test	 eax, eax
  001b7	74 11		 je	 SHORT $LN17@FormatNED
  001b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195611
  001c0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  001c8	eb 0f		 jmp	 SHORT $LN18@FormatNED
$LN17@FormatNED:
  001ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195612
  001d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN18@FormatNED:
  001d9	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  001e1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e4	83 e0 01	 and	 eax, 1
  001e7	85 c0		 test	 eax, eax
  001e9	74 11		 je	 SHORT $LN19@FormatNED
  001eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195613
  001f2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  001fa	eb 0f		 jmp	 SHORT $LN20@FormatNED
$LN19@FormatNED:
  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195614
  00203	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
$LN20@FormatNED:
  0020b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00213	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00216	83 e0 20	 and	 eax, 32			; 00000020H
  00219	85 c0		 test	 eax, eax
  0021b	74 11		 je	 SHORT $LN21@FormatNED
  0021d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195615
  00224	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  0022c	eb 0f		 jmp	 SHORT $LN22@FormatNED
$LN21@FormatNED:
  0022e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195616
  00235	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
$LN22@FormatNED:
  0023d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00245	48 83 c0 04	 add	 rax, 4
  00249	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0024f	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR sdc_info$[rsp]
  00257	48 8b c8	 mov	 rcx, rax
  0025a	e8 00 00 00 00	 call	 FormatSDC
  0025f	b9 01 00 00 00	 mov	 ecx, 1
  00264	48 6b c9 01	 imul	 rcx, rcx, 1
  00268	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR ned$[rsp]
  00270	0f b6 4c 0a 1e	 movzx	 ecx, BYTE PTR [rdx+rcx+30]
  00275	ba 01 00 00 00	 mov	 edx, 1
  0027a	48 6b d2 00	 imul	 rdx, rdx, 0
  0027e	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR ned$[rsp]
  00286	41 0f b6 54 10
	1e		 movzx	 edx, BYTE PTR [r8+rdx+30]
  0028c	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR ned$[rsp]
  00294	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]
  00298	41 c1 f8 03	 sar	 r8d, 3
  0029c	41 83 e0 03	 and	 r8d, 3
  002a0	4d 63 c0	 movsxd	 r8, r8d
  002a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?sn_ind@?1??FormatNED@@9@9
  002aa	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  002af	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b3	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  002b7	4b 8b 04 c1	 mov	 rax, QWORD PTR [r9+r8*8]
  002bb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv166[rsp]
  002c8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cls$4[rsp]
  002d5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002da	48 8b 44 24 68	 mov	 rax, QWORD PTR typ$[rsp]
  002df	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv174[rsp]
  002ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR tv180[rsp]
  002f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195617
  00300	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00308	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2592 : 
; 2593 :             "NED:%s%styp:%s cls:%s lvl:%s sn:%s tag:%02X%02X\n     %s"
; 2594 : 
; 2595 :             , (ned->flags & 0x20) ? "*" : " "
; 2596 :             , (ned->flags & 0x01) ? "(EMULATED) " : ""
; 2597 :             , typ
; 2598 :             , cls
; 2599 :             , (ned->lvl & 0x01) ? "UNRELATED" : "RELATED"
; 2600 :             , sn_ind[ (ned->flags >> 3) & 0x03 ]
; 2601 :             , ned->tag[0], ned->tag[1]
; 2602 :             , FormatSDC( &ned->info, sdc_info, sizeof(sdc_info))
; 2603 :         );
; 2604 :     }

  00316	e9 63 01 00 00	 jmp	 $LN9@FormatNED
$LN8@FormatNED:

; 2605 :     else
; 2606 :     {
; 2607 :         snprintf( buf, bufsz,

  0031b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00323	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00327	83 e0 01	 and	 eax, 1
  0032a	85 c0		 test	 eax, eax
  0032c	74 11		 je	 SHORT $LN23@FormatNED
  0032e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195618
  00335	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
  0033d	eb 0f		 jmp	 SHORT $LN24@FormatNED
$LN23@FormatNED:
  0033f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195619
  00346	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
$LN24@FormatNED:
  0034e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00356	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00359	83 e0 01	 and	 eax, 1
  0035c	85 c0		 test	 eax, eax
  0035e	74 11		 je	 SHORT $LN25@FormatNED
  00360	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195620
  00367	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv220[rsp], rax
  0036f	eb 0f		 jmp	 SHORT $LN26@FormatNED
$LN25@FormatNED:
  00371	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195621
  00378	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv220[rsp], rax
$LN26@FormatNED:
  00380	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  00388	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0038b	83 e0 20	 and	 eax, 32			; 00000020H
  0038e	85 c0		 test	 eax, eax
  00390	74 11		 je	 SHORT $LN27@FormatNED
  00392	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195622
  00399	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  003a1	eb 0f		 jmp	 SHORT $LN28@FormatNED
$LN27@FormatNED:
  003a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195623
  003aa	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
$LN28@FormatNED:
  003b2	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR ned$[rsp]
  003ba	48 83 c0 04	 add	 rax, 4
  003be	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  003c4	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR sdc_info$[rsp]
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 FormatSDC
  003d4	b9 01 00 00 00	 mov	 ecx, 1
  003d9	48 6b c9 01	 imul	 rcx, rcx, 1
  003dd	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR ned$[rsp]
  003e5	0f b6 4c 0a 1e	 movzx	 ecx, BYTE PTR [rdx+rcx+30]
  003ea	ba 01 00 00 00	 mov	 edx, 1
  003ef	48 6b d2 00	 imul	 rdx, rdx, 0
  003f3	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR ned$[rsp]
  003fb	41 0f b6 54 10
	1e		 movzx	 edx, BYTE PTR [r8+rdx+30]
  00401	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR ned$[rsp]
  00409	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]
  0040d	41 c1 f8 03	 sar	 r8d, 3
  00411	41 83 e0 03	 and	 r8d, 3
  00415	4d 63 c0	 movsxd	 r8, r8d
  00418	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?sn_ind@?1??FormatNED@@9@9
  0041f	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00424	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00428	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0042c	4b 8b 04 c1	 mov	 rax, QWORD PTR [r9+r8*8]
  00430	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00435	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv213[rsp]
  0043d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00442	48 8b 44 24 68	 mov	 rax, QWORD PTR typ$[rsp]
  00447	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0044c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv220[rsp]
  00454	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00459	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR tv226[rsp]
  00461	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195624
  00468	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00470	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00478	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@FormatNED:

; 2608 : 
; 2609 :             "NED:%s%styp:%s lvl:%s sn:%s tag:%02X%02X\n     %s"
; 2610 : 
; 2611 :             , (ned->flags & 0x20) ? "*" : " "
; 2612 :             , (ned->flags & 0x01) ? "(EMULATED) " : ""
; 2613 :             , typ
; 2614 :             , (ned->lvl & 0x01) ? "UNRELATED" : "RELATED"
; 2615 :             , sn_ind[ (ned->flags >> 3) & 0x03 ]
; 2616 :             , ned->tag[0], ned->tag[1]
; 2617 :             , FormatSDC( &ned->info, sdc_info, sizeof(sdc_info))
; 2618 :         );
; 2619 :     }
; 2620 : 
; 2621 :     return buf;

  0047e	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatNED:
$LN12@FormatNED:

; 2622 : }

  00486	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048e	48 33 cc	 xor	 rcx, rsp
  00491	e8 00 00 00 00	 call	 __security_check_cookie
  00496	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  0049d	c3		 ret	 0
FormatNED ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv76 = 240
tv83 = 244
tv90 = 248
tv129 = 252
tv136 = 256
tv143 = 260
tv150 = 264
tv157 = 268
tv164 = 272
tv171 = 276
tv178 = 280
tv185 = 284
tv192 = 288
tv199 = 292
tv206 = 296
tv213 = 300
tv220 = 304
tv227 = 308
tv234 = 312
tv241 = 316
tv248 = 320
tv255 = 324
tv262 = 328
tv269 = 332
tv276 = 336
sdc$ = 368
buf$ = 376
bufsz$ = 384
FormatSDC PROC

; 2499 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H

; 2500 :     if (!buf)

  00016	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@FormatSDC

; 2501 :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 5a 05 00 00	 jmp	 $LN1@FormatSDC
$LN2@FormatSDC:

; 2502 :     if (bufsz)

  00028	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00031	74 15		 je	 SHORT $LN3@FormatSDC

; 2503 :         buf[0] = 0;

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	48 6b c0 00	 imul	 rax, rax, 0
  0003c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00044	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatSDC:

; 2504 :     if (bufsz <= 1 || !sdc)

  00048	48 83 bc 24 80
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00051	76 0b		 jbe	 SHORT $LN5@FormatSDC
  00053	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR sdc$[rsp], 0
  0005c	75 0d		 jne	 SHORT $LN4@FormatSDC
$LN5@FormatSDC:

; 2505 :         return buf;

  0005e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00066	e9 17 05 00 00	 jmp	 $LN1@FormatSDC
$LN4@FormatSDC:

; 2506 : 
; 2507 :     #define SDCCHAR(fld, n) sdcchar(sdc->fld[n])
; 2508 : 
; 2509 :     snprintf( buf, bufsz,

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	48 6b c0 0b	 imul	 rax, rax, 11
  00074	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sdc$[rsp]
  0007c	0f b6 4c 01 0e	 movzx	 ecx, BYTE PTR [rcx+rax+14]
  00081	e8 00 00 00 00	 call	 sdcchar
  00086	0f b6 c0	 movzx	 eax, al
  00089	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	48 6b c9 0a	 imul	 rcx, rcx, 10
  00099	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  000a1	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  000a6	e8 00 00 00 00	 call	 sdcchar
  000ab	0f b6 c0	 movzx	 eax, al
  000ae	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv83[rsp], eax
  000b5	b9 01 00 00 00	 mov	 ecx, 1
  000ba	48 6b c9 09	 imul	 rcx, rcx, 9
  000be	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  000c6	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  000cb	e8 00 00 00 00	 call	 sdcchar
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv90[rsp], eax
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	48 6b c9 08	 imul	 rcx, rcx, 8
  000e3	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  000eb	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  000f0	e8 00 00 00 00	 call	 sdcchar
  000f5	0f b6 c0	 movzx	 eax, al
  000f8	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	48 6b c9 07	 imul	 rcx, rcx, 7
  00108	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00110	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  00115	e8 00 00 00 00	 call	 sdcchar
  0011a	0f b6 c0	 movzx	 eax, al
  0011d	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv136[rsp], eax
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	48 6b c9 06	 imul	 rcx, rcx, 6
  0012d	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00135	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  0013a	e8 00 00 00 00	 call	 sdcchar
  0013f	0f b6 c0	 movzx	 eax, al
  00142	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv143[rsp], eax
  00149	b9 01 00 00 00	 mov	 ecx, 1
  0014e	48 6b c9 05	 imul	 rcx, rcx, 5
  00152	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  0015a	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  0015f	e8 00 00 00 00	 call	 sdcchar
  00164	0f b6 c0	 movzx	 eax, al
  00167	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv150[rsp], eax
  0016e	b9 01 00 00 00	 mov	 ecx, 1
  00173	48 6b c9 04	 imul	 rcx, rcx, 4
  00177	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  0017f	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  00184	e8 00 00 00 00	 call	 sdcchar
  00189	0f b6 c0	 movzx	 eax, al
  0018c	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv157[rsp], eax
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	48 6b c9 03	 imul	 rcx, rcx, 3
  0019c	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  001a4	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  001a9	e8 00 00 00 00	 call	 sdcchar
  001ae	0f b6 c0	 movzx	 eax, al
  001b1	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  001b8	b9 01 00 00 00	 mov	 ecx, 1
  001bd	48 6b c9 02	 imul	 rcx, rcx, 2
  001c1	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  001c9	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  001ce	e8 00 00 00 00	 call	 sdcchar
  001d3	0f b6 c0	 movzx	 eax, al
  001d6	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  001dd	b9 01 00 00 00	 mov	 ecx, 1
  001e2	48 6b c9 01	 imul	 rcx, rcx, 1
  001e6	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  001ee	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  001f3	e8 00 00 00 00	 call	 sdcchar
  001f8	0f b6 c0	 movzx	 eax, al
  001fb	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv178[rsp], eax
  00202	b9 01 00 00 00	 mov	 ecx, 1
  00207	48 6b c9 00	 imul	 rcx, rcx, 0
  0020b	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00213	0f b6 4c 0a 0e	 movzx	 ecx, BYTE PTR [rdx+rcx+14]
  00218	e8 00 00 00 00	 call	 sdcchar
  0021d	0f b6 c0	 movzx	 eax, al
  00220	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	48 6b c9 01	 imul	 rcx, rcx, 1
  00230	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00238	0f b6 4c 0a 0c	 movzx	 ecx, BYTE PTR [rdx+rcx+12]
  0023d	e8 00 00 00 00	 call	 sdcchar
  00242	0f b6 c0	 movzx	 eax, al
  00245	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	48 6b c9 00	 imul	 rcx, rcx, 0
  00255	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  0025d	0f b6 4c 0a 0c	 movzx	 ecx, BYTE PTR [rdx+rcx+12]
  00262	e8 00 00 00 00	 call	 sdcchar
  00267	0f b6 c0	 movzx	 eax, al
  0026a	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv199[rsp], eax
  00271	b9 01 00 00 00	 mov	 ecx, 1
  00276	48 6b c9 02	 imul	 rcx, rcx, 2
  0027a	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00282	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  00287	e8 00 00 00 00	 call	 sdcchar
  0028c	0f b6 c0	 movzx	 eax, al
  0028f	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  00296	b9 01 00 00 00	 mov	 ecx, 1
  0029b	48 6b c9 01	 imul	 rcx, rcx, 1
  0029f	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  002a7	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  002ac	e8 00 00 00 00	 call	 sdcchar
  002b1	0f b6 c0	 movzx	 eax, al
  002b4	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  002bb	b9 01 00 00 00	 mov	 ecx, 1
  002c0	48 6b c9 00	 imul	 rcx, rcx, 0
  002c4	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  002cc	0f b6 4c 0a 09	 movzx	 ecx, BYTE PTR [rdx+rcx+9]
  002d1	e8 00 00 00 00	 call	 sdcchar
  002d6	0f b6 c0	 movzx	 eax, al
  002d9	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  002e0	b9 01 00 00 00	 mov	 ecx, 1
  002e5	48 6b c9 02	 imul	 rcx, rcx, 2
  002e9	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  002f1	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  002f6	e8 00 00 00 00	 call	 sdcchar
  002fb	0f b6 c0	 movzx	 eax, al
  002fe	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv227[rsp], eax
  00305	b9 01 00 00 00	 mov	 ecx, 1
  0030a	48 6b c9 01	 imul	 rcx, rcx, 1
  0030e	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00316	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  0031b	e8 00 00 00 00	 call	 sdcchar
  00320	0f b6 c0	 movzx	 eax, al
  00323	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  0032a	b9 01 00 00 00	 mov	 ecx, 1
  0032f	48 6b c9 00	 imul	 rcx, rcx, 0
  00333	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  0033b	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00340	e8 00 00 00 00	 call	 sdcchar
  00345	0f b6 c0	 movzx	 eax, al
  00348	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  0034f	b9 01 00 00 00	 mov	 ecx, 1
  00354	48 6b c9 05	 imul	 rcx, rcx, 5
  00358	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00360	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00364	e8 00 00 00 00	 call	 sdcchar
  00369	0f b6 c0	 movzx	 eax, al
  0036c	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv248[rsp], eax
  00373	b9 01 00 00 00	 mov	 ecx, 1
  00378	48 6b c9 04	 imul	 rcx, rcx, 4
  0037c	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00384	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00388	e8 00 00 00 00	 call	 sdcchar
  0038d	0f b6 c0	 movzx	 eax, al
  00390	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv255[rsp], eax
  00397	b9 01 00 00 00	 mov	 ecx, 1
  0039c	48 6b c9 03	 imul	 rcx, rcx, 3
  003a0	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  003a8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003ac	e8 00 00 00 00	 call	 sdcchar
  003b1	0f b6 c0	 movzx	 eax, al
  003b4	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv262[rsp], eax
  003bb	b9 01 00 00 00	 mov	 ecx, 1
  003c0	48 6b c9 02	 imul	 rcx, rcx, 2
  003c4	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  003cc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003d0	e8 00 00 00 00	 call	 sdcchar
  003d5	0f b6 c0	 movzx	 eax, al
  003d8	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv269[rsp], eax
  003df	b9 01 00 00 00	 mov	 ecx, 1
  003e4	48 6b c9 01	 imul	 rcx, rcx, 1
  003e8	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  003f0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003f4	e8 00 00 00 00	 call	 sdcchar
  003f9	0f b6 c0	 movzx	 eax, al
  003fc	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv276[rsp], eax
  00403	b9 01 00 00 00	 mov	 ecx, 1
  00408	48 6b c9 00	 imul	 rcx, rcx, 0
  0040c	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR sdc$[rsp]
  00414	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00418	e8 00 00 00 00	 call	 sdcchar
  0041d	0f b6 c0	 movzx	 eax, al
  00420	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv76[rsp]
  00427	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], ecx
  0042e	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv83[rsp]
  00435	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  0043c	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv90[rsp]
  00443	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  0044a	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00451	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], ecx
  00458	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv136[rsp]
  0045f	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  00466	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv143[rsp]
  0046d	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ecx
  00474	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv150[rsp]
  0047b	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], ecx
  00482	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  00489	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], ecx
  00490	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  00497	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  0049e	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  004a5	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  004ac	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  004b3	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  004ba	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  004c1	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  004c8	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  004cf	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  004d6	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv199[rsp]
  004dd	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  004e1	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  004e8	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  004ec	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv213[rsp]
  004f3	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  004f7	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv220[rsp]
  004fe	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00502	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv227[rsp]
  00509	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0050d	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  00514	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00518	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  0051f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00523	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv248[rsp]
  0052a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0052e	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv255[rsp]
  00535	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00539	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  00540	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00544	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv269[rsp]
  0054b	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0054f	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  00556	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0055a	44 8b c8	 mov	 r9d, eax
  0055d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195552
  00564	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  0056c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2510 : 
; 2511 :         "SDC: type/model:%c%c%c%c%c%c-%c%c%c mfg:%c%c%c plant:%c%c seq/serial:%c%c%c%c%c%c%c%c%c%c%c%c\n"
; 2512 : 
; 2513 :         , SDCCHAR(type,0),SDCCHAR(type,1),SDCCHAR(type,2),SDCCHAR(type,3),SDCCHAR(type,4),SDCCHAR(type,5)
; 2514 :         , SDCCHAR(model,0),SDCCHAR(model,1),SDCCHAR(model,2)
; 2515 :         , SDCCHAR(mfr,0),SDCCHAR(mfr,1),SDCCHAR(mfr,2)
; 2516 :         , SDCCHAR(plant,0),SDCCHAR(plant,1)
; 2517 :         , SDCCHAR(serial,0),SDCCHAR(serial,1),SDCCHAR(serial,2),SDCCHAR(serial,3),SDCCHAR(serial,4),SDCCHAR(serial,5)
; 2518 :         , SDCCHAR(serial,6),SDCCHAR(serial,7),SDCCHAR(serial,8),SDCCHAR(serial,9),SDCCHAR(serial,10),SDCCHAR(serial,11)
; 2519 :     );
; 2520 : 
; 2521 :     return buf;

  0057a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatSDC:

; 2522 : }

  00582	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00589	c3		 ret	 0
FormatSDC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv71 = 32
c$ = 64
sdcchar	PROC

; 2491 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2492 :     /* This  suberfuge  resolved a compiler bug that leads to a slew */
; 2493 :     /* of warnings about c possibly being undefined.                 */
; 2494 :     c = guest_to_host( c );

  00008	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$[rsp]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00013	88 44 24 40	 mov	 BYTE PTR c$[rsp], al

; 2495 :     return isgraph(c) ? c : '?';

  00017	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$[rsp]
  0001c	8b c8		 mov	 ecx, eax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isgraph
  00024	85 c0		 test	 eax, eax
  00026	74 0b		 je	 SHORT $LN3@sdcchar
  00028	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR tv71[rsp], eax
  00031	eb 08		 jmp	 SHORT $LN4@sdcchar
$LN3@sdcchar:
  00033	c7 44 24 20 3f
	00 00 00	 mov	 DWORD PTR tv71[rsp], 63	; 0000003fH
$LN4@sdcchar:
  0003b	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv71[rsp]

; 2496 : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
sdcchar	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
len$ = 64
i$ = 68
rpl$ = 72
tv128 = 76
hdr$ = 96
cpuad$ = 104
r$ = 112
numcpus$ = 120
buf$ = 128
buflen$ = 136
msghdr$ = 144
display_regs64 PROC

; 1562 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1563 :     int i;
; 1564 :     int rpl;
; 1565 :     int len=0;

  00018	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 1566 :     if(numcpus>1 && !(sysblk.insttrace || sysblk.instbreak) )

  00020	83 7c 24 78 01	 cmp	 DWORD PTR numcpus$[rsp], 1
  00025	7e 38		 jle	 SHORT $LN5@display_re
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00034	c1 e8 08	 shr	 eax, 8
  00037	83 e0 01	 and	 eax, 1
  0003a	85 c0		 test	 eax, eax
  0003c	75 21		 jne	 SHORT $LN5@display_re
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00045	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0004b	c1 e8 0a	 shr	 eax, 10
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	75 0a		 jne	 SHORT $LN5@display_re

; 1567 :     {
; 1568 :         rpl=2;

  00055	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR rpl$[rsp], 2

; 1569 :     }

  0005d	eb 08		 jmp	 SHORT $LN6@display_re
$LN5@display_re:

; 1570 :     else // (numcpus <= 1 || sysblk.insttrace || sysblk.instbreak)
; 1571 :     {
; 1572 :         rpl=4;

  0005f	c7 44 24 48 04
	00 00 00	 mov	 DWORD PTR rpl$[rsp], 4
$LN6@display_re:

; 1573 :     }
; 1574 :     for(i=0;i<16;i++)

  00067	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@display_re
$LN2@display_re:
  00071	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN4@display_re:
  0007b	83 7c 24 44 10	 cmp	 DWORD PTR i$[rsp], 16
  00080	0f 8d 9f 01 00
	00		 jge	 $LN3@display_re

; 1575 :     {
; 1576 :         if(!(i%rpl))

  00086	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0008a	99		 cdq
  0008b	f7 7c 24 48	 idiv	 DWORD PTR rpl$[rsp]
  0008f	8b c2		 mov	 eax, edx
  00091	85 c0		 test	 eax, eax
  00093	0f 85 e7 00 00
	00		 jne	 $LN7@display_re

; 1577 :         {
; 1578 :             if(i)

  00099	83 7c 24 44 00	 cmp	 DWORD PTR i$[rsp], 0
  0009e	74 3c		 je	 SHORT $LN8@display_re

; 1579 :             {
; 1580 :                 len += idx_snprintf( len, buf, buflen, "%s", "\n" );

  000a0	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195013
  000af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195014
  000bb	4c 8b c0	 mov	 r8, rax
  000be	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000c6	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  000d0	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN8@display_re:

; 1581 :             }
; 1582 :             len += idx_snprintf( len, buf, buflen, "%s", msghdr );

  000dc	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  000e4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR msghdr$[rsp]
  000ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195015
  000f8	4c 8b c0	 mov	 r8, rax
  000fb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00103	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0010d	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00111	03 c8		 add	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1583 :             if(numcpus>1)

  00119	83 7c 24 78 01	 cmp	 DWORD PTR numcpus$[rsp], 1
  0011e	7e 60		 jle	 SHORT $LN9@display_re

; 1584 :             {
; 1585 :                 len += idx_snprintf( len, buf, buflen, "%s%02X: ", PTYPSTR(cpuad), cpuad );

  00120	0f b7 44 24 68	 movzx	 eax, WORD PTR cpuad$[rsp]
  00125	89 44 24 4c	 mov	 DWORD PTR tv128[rsp], eax
  00129	0f b7 4c 24 68	 movzx	 ecx, WORD PTR cpuad$[rsp]
  0012e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00135	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00143	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  0014b	8b 54 24 4c	 mov	 edx, DWORD PTR tv128[rsp]
  0014f	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00153	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00158	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195017
  0015f	4c 8b c1	 mov	 r8, rcx
  00162	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0016a	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00174	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00178	03 c8		 add	 ecx, eax
  0017a	8b c1		 mov	 eax, ecx
  0017c	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN9@display_re:
$LN7@display_re:

; 1586 :             }
; 1587 :         }
; 1588 :         if(i%rpl)

  00180	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00184	99		 cdq
  00185	f7 7c 24 48	 idiv	 DWORD PTR rpl$[rsp]
  00189	8b c2		 mov	 eax, edx
  0018b	85 c0		 test	 eax, eax
  0018d	74 3c		 je	 SHORT $LN10@display_re

; 1589 :         {
; 1590 :             len += idx_snprintf( len, buf, buflen, "%s", " " );

  0018f	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195019
  0019e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195020
  001aa	4c 8b c0	 mov	 r8, rax
  001ad	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001b5	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001bf	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  001c3	03 c8		 add	 ecx, eax
  001c5	8b c1		 mov	 eax, ecx
  001c7	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN10@display_re:

; 1591 :         }
; 1592 :         len += idx_snprintf( len, buf, buflen, "%s%1.1X=%16.16"PRIX64, hdr, i, r[i] );

  001cb	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  001d0	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  001d8	48 8b 54 24 70	 mov	 rdx, QWORD PTR r$[rsp]
  001dd	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  001e1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001e6	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  001ea	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001ee	48 8b 44 24 60	 mov	 rax, QWORD PTR hdr$[rsp]
  001f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195021
  001ff	4c 8b c1	 mov	 r8, rcx
  00202	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0020a	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00214	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00218	03 c8		 add	 ecx, eax
  0021a	8b c1		 mov	 eax, ecx
  0021c	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1593 :     }

  00220	e9 4c fe ff ff	 jmp	 $LN2@display_re
$LN3@display_re:

; 1594 :     len += idx_snprintf( len, buf, buflen, "%s", "\n" );

  00225	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195022
  00234	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00239	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195023
  00240	4c 8b c0	 mov	 r8, rax
  00243	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0024b	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00255	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00259	03 c8		 add	 ecx, eax
  0025b	8b c1		 mov	 eax, ecx
  0025d	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1595 :     return(len);

  00261	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]

; 1596 : }

  00265	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00269	c3		 ret	 0
display_regs64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
len$ = 64
i$ = 68
tv87 = 72
hdr$ = 96
cpuad$ = 104
r$ = 112
numcpus$ = 120
buf$ = 128
buflen$ = 136
msghdr$ = 144
display_regs32 PROC

; 1532 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1533 :     int i;
; 1534 :     int len=0;

  00018	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 1535 :     for(i=0;i<16;i++)

  00020	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00028	eb 0a		 jmp	 SHORT $LN4@display_re
$LN2@display_re:
  0002a	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN4@display_re:
  00034	83 7c 24 44 10	 cmp	 DWORD PTR i$[rsp], 16
  00039	0f 8d a5 01 00
	00		 jge	 $LN3@display_re

; 1536 :     {
; 1537 :         if(!(i%4))

  0003f	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00043	99		 cdq
  00044	83 e2 03	 and	 edx, 3
  00047	03 c2		 add	 eax, edx
  00049	83 e0 03	 and	 eax, 3
  0004c	2b c2		 sub	 eax, edx
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 e7 00 00
	00		 jne	 $LN5@display_re

; 1538 :         {
; 1539 :             if(i)

  00056	83 7c 24 44 00	 cmp	 DWORD PTR i$[rsp], 0
  0005b	74 3c		 je	 SHORT $LN6@display_re

; 1540 :             {
; 1541 :                 len += idx_snprintf( len, buf, buflen, "%s", "\n" );

  0005d	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194976
  0006c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00071	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194977
  00078	4c 8b c0	 mov	 r8, rax
  0007b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00083	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0008d	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00091	03 c8		 add	 ecx, eax
  00093	8b c1		 mov	 eax, ecx
  00095	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN6@display_re:

; 1542 :             }
; 1543 :             len += idx_snprintf( len, buf, buflen, "%s", msghdr );

  00099	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  000a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR msghdr$[rsp]
  000a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194978
  000b5	4c 8b c0	 mov	 r8, rax
  000b8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000c0	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  000ca	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  000ce	03 c8		 add	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1544 :             if(numcpus>1)

  000d6	83 7c 24 78 01	 cmp	 DWORD PTR numcpus$[rsp], 1
  000db	7e 60		 jle	 SHORT $LN7@display_re

; 1545 :             {
; 1546 :                 len += idx_snprintf( len, buf, buflen, "%s%02X: ", PTYPSTR(cpuad), cpuad );

  000dd	0f b7 44 24 68	 movzx	 eax, WORD PTR cpuad$[rsp]
  000e2	89 44 24 48	 mov	 DWORD PTR tv87[rsp], eax
  000e6	0f b7 4c 24 68	 movzx	 ecx, WORD PTR cpuad$[rsp]
  000eb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000f2	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00100	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  00108	8b 54 24 48	 mov	 edx, DWORD PTR tv87[rsp]
  0010c	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194980
  0011c	4c 8b c1	 mov	 r8, rcx
  0011f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00127	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00131	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00135	03 c8		 add	 ecx, eax
  00137	8b c1		 mov	 eax, ecx
  00139	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN7@display_re:
$LN5@display_re:

; 1547 :             }
; 1548 :         }
; 1549 :         if(i%4)

  0013d	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00141	99		 cdq
  00142	83 e2 03	 and	 edx, 3
  00145	03 c2		 add	 eax, edx
  00147	83 e0 03	 and	 eax, 3
  0014a	2b c2		 sub	 eax, edx
  0014c	85 c0		 test	 eax, eax
  0014e	74 3c		 je	 SHORT $LN8@display_re

; 1550 :         {
; 1551 :             len += idx_snprintf( len, buf, buflen, "%s", " ");

  00150	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194982
  0015f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00164	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194983
  0016b	4c 8b c0	 mov	 r8, rax
  0016e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00176	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00180	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00184	03 c8		 add	 ecx, eax
  00186	8b c1		 mov	 eax, ecx
  00188	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax
$LN8@display_re:

; 1552 :         }
; 1553 :         len += idx_snprintf( len, buf, buflen, "%s%2.2d=%8.8"PRIX32, hdr, i, r[i] );

  0018c	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00191	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  00199	48 8b 54 24 70	 mov	 rdx, QWORD PTR r$[rsp]
  0019e	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  001a1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001a5	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  001a9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001ad	48 8b 44 24 60	 mov	 rax, QWORD PTR hdr$[rsp]
  001b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194984
  001be	4c 8b c1	 mov	 r8, rcx
  001c1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001c9	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001d3	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  001d7	03 c8		 add	 ecx, eax
  001d9	8b c1		 mov	 eax, ecx
  001db	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1554 :     }

  001df	e9 46 fe ff ff	 jmp	 $LN2@display_re
$LN3@display_re:

; 1555 :     len += idx_snprintf( len, buf, buflen, "%s", "\n" );

  001e4	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194985
  001f3	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194986
  001ff	4c 8b c0	 mov	 r8, rax
  00202	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0020a	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00214	8b 4c 24 40	 mov	 ecx, DWORD PTR len$[rsp]
  00218	03 c8		 add	 ecx, eax
  0021a	8b c1		 mov	 eax, ecx
  0021c	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 1556 :     return(len);

  00220	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]

; 1557 : }

  00224	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00228	c3		 ret	 0
display_regs32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
arg$ = 80
do_shutdown_wait PROC

; 1444 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@do_shutdow:

; 1445 :     UNREFERENCED( arg );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@do_shutdow

; 1446 :     // "Shutdown initiated"
; 1447 :     WRMSG( HHC01426, "I" );

  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194938
  00021	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194939
  0002d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194940
  00044	ba a7 05 00 00	 mov	 edx, 1447		; 000005a7H
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194941
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1448 :     wait_for_guest_to_quiesce();

  00056	e8 00 00 00 00	 call	 wait_for_guest_to_quiesce

; 1449 :     do_shutdown_now();

  0005b	e8 00 00 00 00	 call	 do_shutdown_now

; 1450 :     return NULL;

  00060	33 c0		 xor	 eax, eax

; 1451 : }

  00062	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00066	c3		 ret	 0
do_shutdown_wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
n$1 = 64
do_shutdown_now PROC

; 1352 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1353 :     // "Begin Hercules shutdown"
; 1354 :     WRMSG( HHC01420, "I" );

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194905
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194906
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194907
  00039	ba 4a 05 00 00	 mov	 edx, 1354		; 0000054aH
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194908
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1355 : 
; 1356 :     // (hack to prevent minor message glitch during shutdown)
; 1357 :     fflush( stdout );

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00056	48 8b c8	 mov	 rcx, rax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1358 :     fflush( stderr );

  0005f	b9 02 00 00 00	 mov	 ecx, 2
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1359 :     usleep( 10000 );

  00073	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN4@do_shutdow:

; 1360 : 
; 1361 :     ASSERT( !sysblk.shutfini );   // (sanity check)

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00085	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0008b	c1 e8 0c	 shr	 eax, 12
  0008e	83 e0 01	 and	 eax, 1
  00091	85 c0		 test	 eax, eax
  00093	74 5c		 je	 SHORT $LN11@do_shutdow
$LN7@do_shutdow:
  00095	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194910
  0009c	41 b8 51 05 00
	00		 mov	 r8d, 1361		; 00000551H
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194911
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194912
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000bc	85 c0		 test	 eax, eax
  000be	74 20		 je	 SHORT $LN12@do_shutdow
  000c0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194914
  000c7	41 b8 51 05 00
	00		 mov	 r8d, 1361		; 00000551H
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194915
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194916
  000db	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@do_shutdow:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 af		 jne	 SHORT $LN7@do_shutdow
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ec	85 c0		 test	 eax, eax
  000ee	74 01		 je	 SHORT $LN13@do_shutdow
  000f0	cc		 int	 3
$LN13@do_shutdow:
$LN11@do_shutdow:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 87		 jne	 SHORT $LN4@do_shutdow

; 1362 :     sysblk.shutfini = FALSE;      // (shutdown NOT finished yet)

  000f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fe	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00104	0f ba f0 0c	 btr	 eax, 12
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010f	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 1363 :     sysblk.shutdown = TRUE;       // (system shutdown initiated)

  00115	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00122	0f ba e8 0b	 bts	 eax, 11
  00126	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012d	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 1364 : 
; 1365 :     /* Wakeup I/O subsystem to start I/O subsystem shutdown */
; 1366 :     {
; 1367 :         int  n;
; 1368 :         for (n=0; sysblk.devtnbr && n < 100; ++n)

  00133	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  0013b	eb 0a		 jmp	 SHORT $LN10@do_shutdow
$LN8@do_shutdow:
  0013d	8b 44 24 40	 mov	 eax, DWORD PTR n$1[rsp]
  00141	ff c0		 inc	 eax
  00143	89 44 24 40	 mov	 DWORD PTR n$1[rsp], eax
$LN10@do_shutdow:
  00147	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014e	83 b8 4c 12 00
	00 00		 cmp	 DWORD PTR [rax+4684], 0
  00155	74 31		 je	 SHORT $LN9@do_shutdow
  00157	83 7c 24 40 64	 cmp	 DWORD PTR n$1[rsp], 100	; 00000064H
  0015c	7d 2a		 jge	 SHORT $LN9@do_shutdow

; 1369 :         {
; 1370 :             signal_condition( &sysblk.ioqcond );

  0015e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00165	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194918
  00172	48 8b c8	 mov	 rcx, rax
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 1371 :             usleep( 10000 );

  0017b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1372 :         }

  00186	eb b5		 jmp	 SHORT $LN8@do_shutdow
$LN9@do_shutdow:

; 1373 :     }
; 1374 : 
; 1375 :     // "Calling termination routines"
; 1376 :     WRMSG( HHC01423, "I" );

  00188	b9 01 00 00 00	 mov	 ecx, 1
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194919
  0019a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194920
  001a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194921
  001bd	ba 60 05 00 00	 mov	 edx, 1376		; 00000560H
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194922
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1377 : 
; 1378 :     // (hack to prevent minor message glitch during shutdown)
; 1379 :     fflush( stdout );

  001cf	b9 01 00 00 00	 mov	 ecx, 1
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001da	48 8b c8	 mov	 rcx, rax
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1380 :     fflush( stderr );

  001e3	b9 02 00 00 00	 mov	 ecx, 2
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1381 :     usleep( 10000 );

  001f7	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1382 : 
; 1383 : #if !defined( _MSVC_ )
; 1384 :     logger_unredirect();
; 1385 : #endif
; 1386 : 
; 1387 :     hdl_atexit();

  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_atexit

; 1388 : 
; 1389 :     // "All termination routines complete"
; 1390 :     fprintf( stdout, MSG( HHC01424, "I" ));

  00208	b9 01 00 00 00	 mov	 ecx, 1
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00213	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194923
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194924
  00221	48 8b c8	 mov	 rcx, rax
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 1391 : 
; 1392 :     /*
; 1393 :     logmsg("Terminating threads\n");
; 1394 :     {
; 1395 :         // (none we really care about at the moment...)
; 1396 :     }
; 1397 :     logmsg("Threads terminations complete\n");
; 1398 :     */
; 1399 : 
; 1400 :     // "Hercules shutdown complete"
; 1401 :     fprintf( stdout, MSG( HHC01425, "I" ));

  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194925
  0023c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194926
  00243	48 8b c8	 mov	 rcx, rax
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 1402 : 
; 1403 :     sysblk.shutfini = TRUE;    // (shutdown is now complete)

  0024c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00253	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00259	0f ba e8 0c	 bts	 eax, 12
  0025d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00264	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 1404 : 
; 1405 :     // "Hercules terminated"
; 1406 :     fprintf( stdout, MSG( HHC01412, "I" ));

  0026a	b9 01 00 00 00	 mov	 ecx, 1
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00275	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194927
  0027c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194928
  00283	48 8b c8	 mov	 rcx, rax
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 1407 : 
; 1408 :     //                     PROGRAMMING NOTE
; 1409 : 
; 1410 :     // If we're NOT in "daemon_mode" (i.e. panel_display in control),
; 1411 :     // -OR- if a daemon_task DOES exist, then THEY are in control of
; 1412 :     // shutdown; THEY are responsible for exiting the system whenever
; 1413 :     // THEY feel it's proper to do so (by simply returning back to the
; 1414 :     // caller thereby allowing 'main' to return back to the operating
; 1415 :     // system).
; 1416 : 
; 1417 :     // OTHEWRWISE we ARE in "daemon_mode", but a daemon_task does NOT
; 1418 :     // exist, which means the main thread (tail end of 'impl.c') is
; 1419 :     // stuck in a loop reading log messages and writing them to the
; 1420 :     // logfile, so we need to do the exiting here since it obviously
; 1421 :     // cannot.
; 1422 : 
; 1423 :     if (sysblk.daemon_mode && !daemon_task)

  0028c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00293	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00299	c1 e8 02	 shr	 eax, 2
  0029c	83 e0 01	 and	 eax, 1
  0029f	85 c0		 test	 eax, eax
  002a1	74 2f		 je	 SHORT $LN14@do_shutdow
  002a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_daemon_task
  002aa	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002ae	75 22		 jne	 SHORT $LN14@do_shutdow

; 1424 :     {
; 1425 : #ifdef _MSVC_
; 1426 :         socket_deinit();

  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_deinit

; 1427 : #endif
; 1428 :         fflush( stdout );

  002b6	b9 01 00 00 00	 mov	 ecx, 1
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c1	48 8b c8	 mov	 rcx, rax
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1429 :         exit(0);

  002ca	33 c9		 xor	 ecx, ecx
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN14@do_shutdow:
$LN15@do_shutdow:

; 1430 :     }
; 1431 : }

  002d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d6	c3		 ret	 0
do_shutdown_now ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
cancel_wait_for_guest_quiesce PROC

; 1290 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1291 :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194891
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1292 :     {
; 1293 :         /* Purposely LIE by setting the flag indicating the guest has
; 1294 :            finished quiescing (regardless of whether it actually has
; 1295 :            or not!) so as to cause the above "wait_for_guest_to_quiesce"
; 1296 :            function to break out of its wait loop and return.
; 1297 :         */
; 1298 :         wait_for_quiesce_cancelled = true;  // (if anyone's interested)

  00012	c6 05 00 00 00
	00 01		 mov	 BYTE PTR wait_for_quiesce_cancelled, 1

; 1299 :         guest_is_quiesced = true;           // PURPOSELY LIE! (maybe)

  00019	c6 05 00 00 00
	00 01		 mov	 BYTE PTR guest_is_quiesced, 1

; 1300 :     }
; 1301 :     RELEASE_INTLOCK( NULL );

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194892
  00027	33 c9		 xor	 ecx, ecx
  00029	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1302 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
cancel_wait_for_guest_quiesce ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
keep_waiting$ = 32
i$ = 36
rc$1 = 40
tv86 = 44
wait_for_guest_to_quiesce PROC

; 1262 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1263 :     int  i;
; 1264 :     bool keep_waiting = true;

  00004	c6 44 24 20 01	 mov	 BYTE PTR keep_waiting$[rsp], 1

; 1265 : 
; 1266 :     guest_is_quiesced = false;

  00009	c6 05 00 00 00
	00 00		 mov	 BYTE PTR guest_is_quiesced, 0

; 1267 : 
; 1268 :     /* Wait for all CPU's to stop or time has expired */
; 1269 :     for (i=0; keep_waiting && (!sysblk.quitmout || i < sysblk.quitmout); ++i)

  00010	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00018	eb 0a		 jmp	 SHORT $LN4@wait_for_g
$LN2@wait_for_g:
  0001a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	ff c0		 inc	 eax
  00020	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@wait_for_g:
  00024	0f b6 44 24 20	 movzx	 eax, BYTE PTR keep_waiting$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 c6 00 00
	00		 je	 $LN3@wait_for_g
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00038	83 b8 9c 12 00
	00 00		 cmp	 DWORD PTR [rax+4764], 0
  0003f	74 17		 je	 SHORT $LN10@wait_for_g
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00048	8b 80 9c 12 00
	00		 mov	 eax, DWORD PTR [rax+4764]
  0004e	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00052	0f 8d 9f 00 00
	00		 jge	 $LN3@wait_for_g
$LN10@wait_for_g:

; 1270 :     {
; 1271 :         /* If not the first time, wait a bit before checking again */
; 1272 :         if (i != 0 && !is_guest_quiesced())

  00058	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0005d	74 3b		 je	 SHORT $LN11@wait_for_g
  0005f	e8 00 00 00 00	 call	 is_guest_quiesced
  00064	85 c0		 test	 eax, eax
  00066	75 32		 jne	 SHORT $LN11@wait_for_g
$LN7@wait_for_g:

; 1273 :             SLEEP( 1 );

  00068	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1
$LN8@wait_for_g:
  00070	83 7c 24 28 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00075	74 1d		 je	 SHORT $LN9@wait_for_g
  00077	8b 4c 24 28	 mov	 ecx, DWORD PTR rc$1[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00081	89 44 24 28	 mov	 DWORD PTR rc$1[rsp], eax
  00085	83 7c 24 28 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0008a	74 06		 je	 SHORT $LN12@wait_for_g
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN12@wait_for_g:
  00092	eb dc		 jmp	 SHORT $LN8@wait_for_g
$LN9@wait_for_g:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 ce		 jne	 SHORT $LN7@wait_for_g
$LN11@wait_for_g:

; 1274 : 
; 1275 :         /* Check if guest has finally quiesced itself */
; 1276 :         OBTAIN_INTLOCK( NULL );

  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194884
  000a1	33 c9		 xor	 ecx, ecx
  000a3	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1277 :         {
; 1278 :             if (!guest_is_quiesced)

  000a8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR guest_is_quiesced
  000af	85 c0		 test	 eax, eax
  000b1	75 0b		 jne	 SHORT $LN13@wait_for_g

; 1279 :                  guest_is_quiesced = are_all_cpus_stopped_intlock_held();

  000b3	e8 00 00 00 00	 call	 are_all_cpus_stopped_intlock_held
  000b8	88 05 00 00 00
	00		 mov	 BYTE PTR guest_is_quiesced, al
$LN13@wait_for_g:

; 1280 : 
; 1281 :             keep_waiting = !guest_is_quiesced;

  000be	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR guest_is_quiesced
  000c5	85 c0		 test	 eax, eax
  000c7	75 0a		 jne	 SHORT $LN15@wait_for_g
  000c9	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000d1	eb 08		 jmp	 SHORT $LN16@wait_for_g
$LN15@wait_for_g:
  000d3	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN16@wait_for_g:
  000db	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv86[rsp]
  000e0	88 44 24 20	 mov	 BYTE PTR keep_waiting$[rsp], al

; 1282 :         }
; 1283 :         RELEASE_INTLOCK( NULL );

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194886
  000eb	33 c9		 xor	 ecx, ecx
  000ed	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1284 :     }

  000f2	e9 23 ff ff ff	 jmp	 $LN2@wait_for_g
$LN3@wait_for_g:

; 1285 : 
; 1286 :     /* Guest has finished quiescing itself or else we lost patience */
; 1287 : }

  000f7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fb	c3		 ret	 0
wait_for_guest_to_quiesce ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
quiesced$ = 32
is_guest_quiesced PROC

; 1249 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1250 :     bool quiesced;
; 1251 : 
; 1252 :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194864
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1253 :     {
; 1254 :         quiesced = guest_is_quiesced;

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR guest_is_quiesced
  00019	88 44 24 20	 mov	 BYTE PTR quiesced$[rsp], al

; 1255 :     }
; 1256 :     RELEASE_INTLOCK( NULL );

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194865
  00024	33 c9		 xor	 ecx, ecx
  00026	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1257 : 
; 1258 :     return quiesced;

  0002b	0f b6 44 24 20	 movzx	 eax, BYTE PTR quiesced$[rsp]

; 1259 : }

  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
is_guest_quiesced ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
opcode$ = 96
n$ = 100
regs$ = 104
trace2file$ = 112
b1$ = 116
b2$ = 120
addr1$ = 128
ilc$ = 136
xcode$ = 140
addr2$ = 144
relative_long_operand$1 = 152
tv136 = 156
tv138 = 160
tv145 = 164
tv181 = 168
tv232 = 172
tv233 = 176
x1$ = 180
tv887 = 184
ar$2 = 188
tv888 = 192
tv299 = 196
tv925 = 200
tv835 = 204
offset$3 = 208
$T4 = 216
len$5 = 224
$T6 = 232
tv437 = 240
tv438 = 248
$T7 = 256
$T8 = 264
$T9 = 272
len$10 = 280
$T11 = 288
tf2326$ = 304
qword$ = 416
psw_inst_msg$ = 432
op2_stor_msg$ = 592
op1_stor_msg$ = 720
buf2$ = 848
buf$ = 1360
regs_msg_buf$ = 3408
__$ArrayPad$ = 5456
iregs$ = 5488
inst$ = 5496
pgmint$ = 5504
z900_display_inst_adj PROC

; 812  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	b8 60 15 00 00	 mov	 eax, 5472		; 00001560H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 50
	15 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 813  : QWORD   qword;                          /* Doubleword work area      */
; 814  : BYTE    opcode;                         /* Instruction operation code*/
; 815  : int     ilc;                            /* Instruction length        */
; 816  : int     b1=-1, b2=-1, x1;               /* Register numbers          */

  0002f	c7 44 24 74 ff
	ff ff ff	 mov	 DWORD PTR b1$[rsp], -1
  00037	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR b2$[rsp], -1

; 817  : U16     xcode = 0;                      /* Exception code            */

  0003f	33 c0		 xor	 eax, eax
  00041	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR xcode$[rsp], ax

; 818  : VADR    addr1 = 0, addr2 = 0;           /* Operand addresses         */

  00049	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR addr1$[rsp], 0
  00055	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR addr2$[rsp], 0

; 819  : char    buf[2048];                      /* Message buffer            */
; 820  : char    buf2[512];
; 821  : int     n;                              /* Number of bytes in buffer */
; 822  : REGS*   regs;                           /* Copied regs               */
; 823  : 
; 824  : TF02326 tf2326 = {0};

  00061	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR tf2326$[rsp]
  00069	48 8b f8	 mov	 rdi, rax
  0006c	33 c0		 xor	 eax, eax
  0006e	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00073	f3 aa		 rep stosb

; 825  : bool    trace2file;
; 826  : 
; 827  : char    psw_inst_msg[160]   = {0};

  00075	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR psw_inst_msg$[rsp]
  0007d	48 8b f8	 mov	 rdi, rax
  00080	33 c0		 xor	 eax, eax
  00082	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00087	f3 aa		 rep stosb

; 828  : char    op1_stor_msg[128]   = {0};

  00089	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR op1_stor_msg$[rsp]
  00091	48 8b f8	 mov	 rdi, rax
  00094	33 c0		 xor	 eax, eax
  00096	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0009b	f3 aa		 rep stosb

; 829  : char    op2_stor_msg[128]   = {0};

  0009d	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR op2_stor_msg$[rsp]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	33 c0		 xor	 eax, eax
  000aa	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000af	f3 aa		 rep stosb

; 830  : char    regs_msg_buf[4*512] = {0};

  000b1	48 8d 84 24 50
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  000b9	48 8b f8	 mov	 rdi, rax
  000bc	33 c0		 xor	 eax, eax
  000be	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000c3	f3 aa		 rep stosb
$LN4@z900_displ:

; 831  : 
; 832  :     PTT_PGM( "dinst", inst, 0, pgmint );

  000c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 83 e0 20	 and	 rax, 32			; 00000020H
  000d3	48 85 c0	 test	 rax, rax
  000d6	74 3f		 je	 SHORT $LN20@z900_displ
  000d8	0f b6 84 24 80
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  000e0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194706
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	45 33 c9	 xor	 r9d, r9d
  000fd	4c 8b 84 24 78
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194707
  0010c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@z900_displ:
  00117	33 c0		 xor	 eax, eax
  00119	85 c0		 test	 eax, eax
  0011b	75 a8		 jne	 SHORT $LN4@z900_displ

; 833  : 
; 834  :     OBTAIN_TRACEFILE_LOCK();

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194708
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 835  :     {
; 836  :         trace2file = (iregs->insttrace && sysblk.traceFILE) ? true : false;

  0013a	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  00142	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00148	c1 e8 0f	 shr	 eax, 15
  0014b	83 e0 01	 and	 eax, 1
  0014e	85 c0		 test	 eax, eax
  00150	74 1e		 je	 SHORT $LN90@z900_displ
  00152	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00159	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00161	74 0d		 je	 SHORT $LN90@z900_displ
  00163	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv136[rsp], 1
  0016e	eb 0b		 jmp	 SHORT $LN91@z900_displ
$LN90@z900_displ:
  00170	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
$LN91@z900_displ:
  0017b	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv136[rsp], 0
  00183	75 0d		 jne	 SHORT $LN92@z900_displ
  00185	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv138[rsp], 0
  00190	eb 0b		 jmp	 SHORT $LN93@z900_displ
$LN92@z900_displ:
  00192	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv138[rsp], 1
$LN93@z900_displ:
  0019d	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv138[rsp]
  001a5	88 44 24 70	 mov	 BYTE PTR trace2file$[rsp], al

; 837  :     }
; 838  :     RELEASE_TRACEFILE_LOCK();

  001a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b0	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194709
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 839  : 
; 840  :     /* Ensure storage exists to attempt the display */
; 841  :     tf2326.valid = (iregs->mainlim != 0);

  001c6	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  001ce	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001d6	74 0d		 je	 SHORT $LN94@z900_displ
  001d8	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  001e3	eb 0b		 jmp	 SHORT $LN95@z900_displ
$LN94@z900_displ:
  001e5	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN95@z900_displ:
  001f0	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  001f8	88 84 24 48 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+24], al

; 842  :     if (!tf2326.valid)

  001ff	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+24]
  00207	85 c0		 test	 eax, eax
  00209	0f 85 8f 00 00
	00		 jne	 $LN21@z900_displ

; 843  :     {
; 844  :         if (trace2file)

  0020f	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00214	85 c0		 test	 eax, eax
  00216	74 2e		 je	 SHORT $LN22@z900_displ

; 845  :             tf_2326( iregs, &tf2326, 0,0,0,0 );

  00218	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00220	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00228	45 33 c9	 xor	 r9d, r9d
  0022b	45 33 c0	 xor	 r8d, r8d
  0022e	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  00236	48 8b 8c 24 70
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326
  00244	eb 53		 jmp	 SHORT $LN23@z900_displ
$LN22@z900_displ:

; 846  :         else
; 847  :             WRMSG( HHC02267, "I", "Real address is not valid" );

  00246	b9 01 00 00 00	 mov	 ecx, 1
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194713
  00258	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194714
  00264	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194715
  00270	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00280	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194716
  00287	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194717
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@z900_displ:

; 848  :         return;

  00299	e9 ec 18 00 00	 jmp	 $LN1@z900_displ
$LN21@z900_displ:

; 849  :     }
; 850  : 
; 851  :     n = 0;

  0029e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 852  :     buf[0] = '\0';

  002a6	b8 01 00 00 00	 mov	 eax, 1
  002ab	48 6b c0 00	 imul	 rax, rax, 0
  002af	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  002b7	48 81 bc 24 d8
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T4[rsp], 2048 ; 00000800H
  002c3	73 02		 jae	 SHORT $LN96@z900_displ
  002c5	eb 05		 jmp	 SHORT $LN97@z900_displ
$LN96@z900_displ:
  002c7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN97@z900_displ:
  002cc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  002d4	c6 84 04 50 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 853  : 
; 854  :     /* Get a working (modifiable) copy of the REGS */
; 855  :     if (iregs->ghostregs)

  002dc	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002e4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002ea	c1 e8 0d	 shr	 eax, 13
  002ed	83 e0 01	 and	 eax, 1
  002f0	85 c0		 test	 eax, eax
  002f2	74 0f		 je	 SHORT $LN24@z900_displ

; 856  :         regs = iregs;

  002f4	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002fc	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  00301	eb 1f		 jmp	 SHORT $LN25@z900_displ
$LN24@z900_displ:

; 857  :     else if (!(regs = copy_regs( iregs )))

  00303	48 8b 8c 24 70
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  0030b	e8 00 00 00 00	 call	 copy_regs
  00310	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  00315	48 83 7c 24 68
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0031b	75 05		 jne	 SHORT $LN26@z900_displ

; 858  :         return;

  0031d	e9 68 18 00 00	 jmp	 $LN1@z900_displ
$LN26@z900_displ:
$LN25@z900_displ:

; 859  : 
; 860  : #if defined( _FEATURE_SIE )
; 861  :     tf2326.sie = SIE_MODE( regs ) ? true : false;

  00322	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00327	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0032d	d1 e8		 shr	 eax, 1
  0032f	83 e0 01	 and	 eax, 1
  00332	85 c0		 test	 eax, eax
  00334	74 0d		 je	 SHORT $LN98@z900_displ
  00336	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv181[rsp], 1
  00341	eb 0b		 jmp	 SHORT $LN99@z900_displ
$LN98@z900_displ:
  00343	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN99@z900_displ:
  0034e	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv181[rsp]
  00356	88 84 24 49 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+25], al

; 862  :     if (tf2326.sie)

  0035d	0f b6 84 24 49
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+25]
  00365	85 c0		 test	 eax, eax
  00367	74 2b		 je	 SHORT $LN27@z900_displ

; 863  :         n += idx_snprintf( n, buf, sizeof( buf ), "SIE: " );

  00369	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194722
  00370	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00376	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0037e	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00388	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0038c	03 c8		 add	 ecx, eax
  0038e	8b c1		 mov	 eax, ecx
  00390	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN27@z900_displ:

; 864  : #endif
; 865  : 
; 866  :     /* Exit if instruction is not valid */
; 867  :     if (!inst)

  00394	48 83 bc 24 78
	15 00 00 00	 cmp	 QWORD PTR inst$[rsp], 0
  0039d	0f 85 43 01 00
	00		 jne	 $LN28@z900_displ

; 868  :     {
; 869  :         if (trace2file)

  003a3	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  003a8	85 c0		 test	 eax, eax
  003aa	74 18		 je	 SHORT $LN29@z900_displ

; 870  :             tf_2269( regs, inst );

  003ac	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  003b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2269
  003bf	e9 1d 01 00 00	 jmp	 $LN30@z900_displ
$LN29@z900_displ:

; 871  :         else
; 872  :         {
; 873  :             size_t len;
; 874  :             MSGBUF( psw_inst_msg, "%s Instruction fetch error\n", buf );

  003c4	4c 8d 8c 24 50
	05 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  003cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194726
  003d3	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  003d8	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 875  :             display_gregs( regs, regs_msg_buf, sizeof(regs_msg_buf)-1, "HHC02269I " );

  003e6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194727
  003ed	41 b8 ff 07 00
	00		 mov	 r8d, 2047		; 000007ffH
  003f3	48 8d 94 24 50
	0d 00 00	 lea	 rdx, QWORD PTR regs_msg_buf$[rsp]
  003fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00400	e8 00 00 00 00	 call	 display_gregs

; 876  :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 877  :             len = strlen( regs_msg_buf );

  00405	48 8d 8c 24 50
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  0040d	e8 00 00 00 00	 call	 strlen
  00412	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR len$5[rsp], rax

; 878  :             if (len)

  0041a	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR len$5[rsp], 0
  00423	74 38		 je	 SHORT $LN31@z900_displ

; 879  :                 regs_msg_buf[ len-1 ] = 0;

  00425	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR len$5[rsp]
  0042d	48 ff c8	 dec	 rax
  00430	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  00438	48 81 bc 24 e8
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T6[rsp], 2048 ; 00000800H
  00444	73 02		 jae	 SHORT $LN100@z900_displ
  00446	eb 05		 jmp	 SHORT $LN101@z900_displ
$LN100@z900_displ:
  00448	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN101@z900_displ:
  0044d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00455	c6 84 04 50 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN31@z900_displ:

; 880  :             // "%s%s" // (instruction fetch error + regs)
; 881  :             WRMSG( HHC02325, "E", psw_inst_msg, regs_msg_buf );

  0045d	b9 01 00 00 00	 mov	 ecx, 1
  00462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00468	48 8d 8c 24 50
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  00470	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00475	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  0047d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194729
  00489	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194730
  00495	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049f	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194731
  004ac	ba 71 03 00 00	 mov	 edx, 881		; 00000371H
  004b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194732
  004b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 882  :             if (!iregs->ghostregs)

  004be	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  004c6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  004cc	c1 e8 0d	 shr	 eax, 13
  004cf	83 e0 01	 and	 eax, 1
  004d2	85 c0		 test	 eax, eax
  004d4	75 0b		 jne	 SHORT $LN32@z900_displ

; 883  :                 free_aligned( regs );

  004d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  004db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN32@z900_displ:
$LN30@z900_displ:

; 884  :         }
; 885  :         return;

  004e1	e9 a4 16 00 00	 jmp	 $LN1@z900_displ
$LN28@z900_displ:

; 886  :     }
; 887  : 
; 888  :     /* Save the opcode and determine the instruction length */
; 889  :     opcode = inst[0];

  004e6	b8 01 00 00 00	 mov	 eax, 1
  004eb	48 6b c0 00	 imul	 rax, rax, 0
  004ef	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  004f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004fb	88 44 24 60	 mov	 BYTE PTR opcode$[rsp], al

; 890  :     ilc = ILC( opcode );

  004ff	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00504	83 f8 40	 cmp	 eax, 64			; 00000040H
  00507	7d 0d		 jge	 SHORT $LN104@z900_displ
  00509	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv233[rsp], 2
  00514	eb 32		 jmp	 SHORT $LN105@z900_displ
$LN104@z900_displ:
  00516	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0051b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00520	7d 0d		 jge	 SHORT $LN102@z900_displ
  00522	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv232[rsp], 4
  0052d	eb 0b		 jmp	 SHORT $LN103@z900_displ
$LN102@z900_displ:
  0052f	c7 84 24 ac 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv232[rsp], 6
$LN103@z900_displ:
  0053a	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv232[rsp]
  00541	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv233[rsp], eax
$LN105@z900_displ:
  00548	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv233[rsp]
  0054f	89 84 24 88 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN7@z900_displ:

; 891  : 
; 892  :     PTT_PGM( "dinst op,ilc", opcode, ilc, pgmint );

  00556	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0055d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00560	48 83 e0 20	 and	 rax, 32			; 00000020H
  00564	48 85 c0	 test	 rax, rax
  00567	74 47		 je	 SHORT $LN33@z900_displ
  00569	0f b6 84 24 80
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  00571	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR ilc$[rsp]
  00579	0f b6 54 24 60	 movzx	 edx, BYTE PTR opcode$[rsp]
  0057e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00587	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0058c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194735
  00593	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00598	4c 8b c9	 mov	 r9, rcx
  0059b	44 8b c2	 mov	 r8d, edx
  0059e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194736
  005a5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  005aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@z900_displ:
  005b0	33 c0		 xor	 eax, eax
  005b2	85 c0		 test	 eax, eax
  005b4	75 a0		 jne	 SHORT $LN7@z900_displ
$LN10@z900_displ:

; 893  : 
; 894  :     /* If we were called to display the instruction that program
; 895  :        checked, then since the "iregs" REGS value that was passed
; 896  :        to us (that we made a working copy of) was pointing PAST
; 897  :        the instruction that actually program checked (not at it),
; 898  :        we need to backup by the ilc amount so that it points at
; 899  :        the instruction that program checked, not past it.
; 900  :     */
; 901  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  005b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005c0	48 83 e0 20	 and	 rax, 32			; 00000020H
  005c4	48 85 c0	 test	 rax, rax
  005c7	74 49		 je	 SHORT $LN34@z900_displ
  005c9	0f b6 84 24 80
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  005d1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005da	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194738
  005e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005eb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  005f0	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  005f7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  005fc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00600	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194739
  00607	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0060c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@z900_displ:
  00612	33 c0		 xor	 eax, eax
  00614	85 c0		 test	 eax, eax
  00616	75 9e		 jne	 SHORT $LN10@z900_displ

; 902  :     if (pgmint)

  00618	0f b6 84 24 80
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  00620	85 c0		 test	 eax, eax
  00622	74 62		 je	 SHORT $LN35@z900_displ

; 903  :     {
; 904  :         regs->ip -= ilc;

  00624	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0062c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00631	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00635	48 2b c8	 sub	 rcx, rax
  00638	48 8b c1	 mov	 rax, rcx
  0063b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00640	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 905  :         regs->psw.IA = PSW_IA_FROM_IP( regs, 0 );

  00644	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00649	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0064e	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00655	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00659	48 2b c1	 sub	 rax, rcx
  0065c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00661	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00668	48 03 c8	 add	 rcx, rax
  0066b	48 8b c1	 mov	 rax, rcx
  0066e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00673	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0067a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0067f	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN35@z900_displ:
$LN13@z900_displ:

; 906  :     }
; 907  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  00686	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0068d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00690	48 83 e0 20	 and	 rax, 32			; 00000020H
  00694	48 85 c0	 test	 rax, rax
  00697	74 49		 je	 SHORT $LN36@z900_displ
  00699	0f b6 84 24 80
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  006a1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006aa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194742
  006b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  006c0	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  006c7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  006cc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  006d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194743
  006d7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_displ:
  006e2	33 c0		 xor	 eax, eax
  006e4	85 c0		 test	 eax, eax
  006e6	75 9e		 jne	 SHORT $LN13@z900_displ

; 908  : 
; 909  :     /* Display the PSW */
; 910  :     memset( qword, 0, sizeof( qword ));

  006e8	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR qword$[rsp]
  006f0	48 8b f8	 mov	 rdi, rax
  006f3	33 c0		 xor	 eax, eax
  006f5	b9 10 00 00 00	 mov	 ecx, 16
  006fa	f3 aa		 rep stosb

; 911  :     copy_psw( regs, qword );

  006fc	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR qword$[rsp]
  00704	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00709	e8 00 00 00 00	 call	 copy_psw

; 912  : 
; 913  :     if (!trace2file)

  0070e	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00713	85 c0		 test	 eax, eax
  00715	0f 85 57 04 00
	00		 jne	 $LN37@z900_displ

; 914  :     {
; 915  :         if (sysblk.cpus > 1)

  0071b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00722	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  00729	7e 6f		 jle	 SHORT $LN38@z900_displ

; 916  :             n += idx_snprintf( n, buf, sizeof( buf ), "%s%02X: ", PTYPSTR( regs->cpuad ), regs->cpuad );

  0072b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00730	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00737	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv299[rsp], eax
  0073e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00743	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0074a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00751	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00759	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0075f	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv299[rsp]
  00766	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0076a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194746
  00776	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0077c	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00784	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00788	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0078e	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00792	03 c8		 add	 ecx, eax
  00794	8b c1		 mov	 eax, ecx
  00796	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN38@z900_displ:

; 917  : 
; 918  :         n += idx_snprintf( n, buf, sizeof( buf ),

  0079a	b8 01 00 00 00	 mov	 eax, 1
  0079f	48 6b c0 07	 imul	 rax, rax, 7
  007a3	0f b6 84 04 a0
	01 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  007ab	b9 01 00 00 00	 mov	 ecx, 1
  007b0	48 6b c9 06	 imul	 rcx, rcx, 6
  007b4	0f b6 8c 0c a0
	01 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  007bc	ba 01 00 00 00	 mov	 edx, 1
  007c1	48 6b d2 05	 imul	 rdx, rdx, 5
  007c5	0f b6 94 14 a0
	01 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  007cd	bf 01 00 00 00	 mov	 edi, 1
  007d2	48 6b ff 04	 imul	 rdi, rdi, 4
  007d6	0f b6 bc 3c a0
	01 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  007de	41 b8 01 00 00
	00		 mov	 r8d, 1
  007e4	4d 6b c0 03	 imul	 r8, r8, 3
  007e8	46 0f b6 84 04
	a0 01 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  007f1	41 b9 01 00 00
	00		 mov	 r9d, 1
  007f7	4d 6b c9 02	 imul	 r9, r9, 2
  007fb	46 0f b6 8c 0c
	a0 01 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  00804	41 ba 01 00 00
	00		 mov	 r10d, 1
  0080a	4d 6b d2 01	 imul	 r10, r10, 1
  0080e	46 0f b6 94 14
	a0 01 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  00817	41 bb 01 00 00
	00		 mov	 r11d, 1
  0081d	4d 6b db 00	 imul	 r11, r11, 0
  00821	46 0f b6 9c 1c
	a0 01 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  0082a	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0082e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00832	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00836	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0083a	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0083f	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00844	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00849	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  0084e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194747
  00855	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0085b	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00863	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00867	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0086d	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00871	03 c8		 add	 ecx, eax
  00873	8b c1		 mov	 eax, ecx
  00875	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 919  :                     "PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 920  :                     qword[0], qword[1], qword[2], qword[3],
; 921  :                     qword[4], qword[5], qword[6], qword[7] );
; 922  : 
; 923  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 924  :         n += idx_snprintf( n, buf, sizeof(buf),

  00879	b8 01 00 00 00	 mov	 eax, 1
  0087e	48 6b c0 0f	 imul	 rax, rax, 15
  00882	0f b6 84 04 a0
	01 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  0088a	b9 01 00 00 00	 mov	 ecx, 1
  0088f	48 6b c9 0e	 imul	 rcx, rcx, 14
  00893	0f b6 8c 0c a0
	01 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  0089b	ba 01 00 00 00	 mov	 edx, 1
  008a0	48 6b d2 0d	 imul	 rdx, rdx, 13
  008a4	0f b6 94 14 a0
	01 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  008ac	bf 01 00 00 00	 mov	 edi, 1
  008b1	48 6b ff 0c	 imul	 rdi, rdi, 12
  008b5	0f b6 bc 3c a0
	01 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  008bd	41 b8 01 00 00
	00		 mov	 r8d, 1
  008c3	4d 6b c0 0b	 imul	 r8, r8, 11
  008c7	46 0f b6 84 04
	a0 01 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  008d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  008d6	4d 6b c9 0a	 imul	 r9, r9, 10
  008da	46 0f b6 8c 0c
	a0 01 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  008e3	41 ba 01 00 00
	00		 mov	 r10d, 1
  008e9	4d 6b d2 09	 imul	 r10, r10, 9
  008ed	46 0f b6 94 14
	a0 01 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  008f6	41 bb 01 00 00
	00		 mov	 r11d, 1
  008fc	4d 6b db 08	 imul	 r11, r11, 8
  00900	46 0f b6 9c 1c
	a0 01 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  00909	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0090d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00911	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00915	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00919	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0091e	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00923	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00928	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  0092d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194748
  00934	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0093a	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00942	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00946	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0094c	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00950	03 c8		 add	 ecx, eax
  00952	8b c1		 mov	 eax, ecx
  00954	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 925  :                     "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 926  :                     qword[8], qword[9], qword[10], qword[11],
; 927  :                     qword[12], qword[13], qword[14], qword[15]);
; 928  : #endif
; 929  : 
; 930  :         /* Format instruction line */
; 931  :                      n += idx_snprintf( n, buf, sizeof( buf ), "INST=%2.2X%2.2X", inst[0], inst[1] );

  00958	b8 01 00 00 00	 mov	 eax, 1
  0095d	48 6b c0 01	 imul	 rax, rax, 1
  00961	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00969	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0096d	b9 01 00 00 00	 mov	 ecx, 1
  00972	48 6b c9 00	 imul	 rcx, rcx, 0
  00976	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  0097e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00982	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00986	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0098a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194749
  00991	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00997	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0099f	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  009a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  009a9	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  009ad	03 c8		 add	 ecx, eax
  009af	8b c1		 mov	 eax, ecx
  009b1	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 932  :         if (ilc > 2){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[2], inst[3] );}

  009b5	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  009bd	7e 5d		 jle	 SHORT $LN39@z900_displ
  009bf	b8 01 00 00 00	 mov	 eax, 1
  009c4	48 6b c0 03	 imul	 rax, rax, 3
  009c8	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  009d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009d4	b9 01 00 00 00	 mov	 ecx, 1
  009d9	48 6b c9 02	 imul	 rcx, rcx, 2
  009dd	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  009e5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  009e9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  009ed	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  009f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194751
  009f8	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  009fe	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00a06	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00a10	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a14	03 c8		 add	 ecx, eax
  00a16	8b c1		 mov	 eax, ecx
  00a18	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN39@z900_displ:

; 933  :         if (ilc > 4){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[4], inst[5] );}

  00a1c	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00a24	7e 5d		 jle	 SHORT $LN40@z900_displ
  00a26	b8 01 00 00 00	 mov	 eax, 1
  00a2b	48 6b c0 05	 imul	 rax, rax, 5
  00a2f	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00a37	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a3b	b9 01 00 00 00	 mov	 ecx, 1
  00a40	48 6b c9 04	 imul	 rcx, rcx, 4
  00a44	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00a4c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00a50	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a54	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00a58	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194753
  00a5f	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00a65	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00a6d	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00a77	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a7b	03 c8		 add	 ecx, eax
  00a7d	8b c1		 mov	 eax, ecx
  00a7f	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN40@z900_displ:

; 934  :                      n += idx_snprintf( n, buf, sizeof( buf ), " %s", (ilc < 4) ? "        " :

  00a83	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00a8b	7d 11		 jge	 SHORT $LN108@z900_displ
  00a8d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194754
  00a94	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
  00a9c	eb 3a		 jmp	 SHORT $LN109@z900_displ
$LN108@z900_displ:
  00a9e	83 bc 24 88 00
	00 00 06	 cmp	 DWORD PTR ilc$[rsp], 6
  00aa6	7d 11		 jge	 SHORT $LN106@z900_displ
  00aa8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194755
  00aaf	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv437[rsp], rax
  00ab7	eb 0f		 jmp	 SHORT $LN107@z900_displ
$LN106@z900_displ:
  00ab9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194756
  00ac0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv437[rsp], rax
$LN107@z900_displ:
  00ac8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv437[rsp]
  00ad0	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
$LN109@z900_displ:
  00ad8	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv438[rsp]
  00ae0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ae5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194757
  00aec	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00af2	48 8d 94 24 50
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00afa	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00afe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00b04	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00b08	03 c8		 add	 ecx, eax
  00b0a	8b c1		 mov	 eax, ecx
  00b0c	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 935  :                                                                       (ilc < 6) ? "    " : "" );
; 936  :         n += PRINT_INST( regs->arch_mode, inst, buf + n );

  00b10	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  00b15	48 8d 84 04 50
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00b1d	4c 8b c8	 mov	 r9, rax
  00b20	45 33 c0	 xor	 r8d, r8d
  00b23	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00b2b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00b30	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  00b33	e8 00 00 00 00	 call	 iprint_router_func
  00b38	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00b3c	03 c8		 add	 ecx, eax
  00b3e	8b c1		 mov	 eax, ecx
  00b40	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 937  :         MSGBUF( psw_inst_msg, MSG( HHC02324, "I", buf ));

  00b44	48 8d 84 24 50
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00b4c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b51	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194758
  00b58	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194759
  00b5f	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00b64	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  00b6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN37@z900_displ:

; 938  :     }
; 939  : 
; 940  :     n = 0;

  00b72	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 941  :     buf[0] = '\0';

  00b7a	b8 01 00 00 00	 mov	 eax, 1
  00b7f	48 6b c0 00	 imul	 rax, rax, 0
  00b83	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR $T7[rsp], rax
  00b8b	48 81 bc 24 00
	01 00 00 00 08
	00 00		 cmp	 QWORD PTR $T7[rsp], 2048 ; 00000800H
  00b97	73 02		 jae	 SHORT $LN110@z900_displ
  00b99	eb 05		 jmp	 SHORT $LN111@z900_displ
$LN110@z900_displ:
  00b9b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN111@z900_displ:
  00ba0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  00ba8	c6 84 04 50 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 942  : 
; 943  :     /* Process the first storage operand */
; 944  :     if (1
; 945  :         && ilc > 2
; 946  :         && opcode != 0x84   // BRXH
; 947  :         && opcode != 0x85   // BRXLE
; 948  :         && opcode != 0xA5   // RI-x     (relative)
; 949  :         && opcode != 0xA7   // RI-x     (relative)
; 950  :         && opcode != 0xB3   // RRE/RRF
; 951  :         && opcode != 0xC0   // RIL-x    (relative)
; 952  :         && opcode != 0xC4   // RIL-x    (relative)
; 953  :         && opcode != 0xC6   // RIL-x    (relative)
; 954  :         && opcode != 0xEC   // RIE-x

  00bb0	33 c0		 xor	 eax, eax
  00bb2	83 f8 01	 cmp	 eax, 1
  00bb5	0f 84 fb 01 00
	00		 je	 $LN41@z900_displ
  00bbb	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  00bc3	0f 8e ed 01 00
	00		 jle	 $LN41@z900_displ
  00bc9	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00bce	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  00bd3	0f 84 dd 01 00
	00		 je	 $LN41@z900_displ
  00bd9	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00bde	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00be3	0f 84 cd 01 00
	00		 je	 $LN41@z900_displ
  00be9	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00bee	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  00bf3	0f 84 bd 01 00
	00		 je	 $LN41@z900_displ
  00bf9	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00bfe	3d a7 00 00 00	 cmp	 eax, 167		; 000000a7H
  00c03	0f 84 ad 01 00
	00		 je	 $LN41@z900_displ
  00c09	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c0e	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00c13	0f 84 9d 01 00
	00		 je	 $LN41@z900_displ
  00c19	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c1e	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00c23	0f 84 8d 01 00
	00		 je	 $LN41@z900_displ
  00c29	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c2e	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00c33	0f 84 7d 01 00
	00		 je	 $LN41@z900_displ
  00c39	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c3e	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00c43	0f 84 6d 01 00
	00		 je	 $LN41@z900_displ
  00c49	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c4e	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00c53	0f 84 5d 01 00
	00		 je	 $LN41@z900_displ

; 955  :     )
; 956  :     {
; 957  :         /* Calculate the effective address of the first operand */
; 958  :         b1 = inst[2] >> 4;

  00c59	b8 01 00 00 00	 mov	 eax, 1
  00c5e	48 6b c0 02	 imul	 rax, rax, 2
  00c62	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00c6a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c6e	c1 f8 04	 sar	 eax, 4
  00c71	89 44 24 74	 mov	 DWORD PTR b1$[rsp], eax

; 959  :         addr1 = ((inst[2] & 0x0F) << 8) | inst[3];

  00c75	b8 01 00 00 00	 mov	 eax, 1
  00c7a	48 6b c0 02	 imul	 rax, rax, 2
  00c7e	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00c86	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c8a	83 e0 0f	 and	 eax, 15
  00c8d	c1 e0 08	 shl	 eax, 8
  00c90	b9 01 00 00 00	 mov	 ecx, 1
  00c95	48 6b c9 03	 imul	 rcx, rcx, 3
  00c99	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00ca1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00ca5	0b c1		 or	 eax, ecx
  00ca7	48 98		 cdqe
  00ca9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 960  :         if (b1 != 0)

  00cb1	83 7c 24 74 00	 cmp	 DWORD PTR b1$[rsp], 0
  00cb6	74 4a		 je	 SHORT $LN42@z900_displ

; 961  :         {
; 962  :             addr1 += regs->GR( b1 );

  00cb8	48 63 44 24 74	 movsxd	 rax, DWORD PTR b1$[rsp]
  00cbd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00cc2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00cca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00cd2	48 03 c8	 add	 rcx, rax
  00cd5	48 8b c1	 mov	 rax, rcx
  00cd8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 963  :             addr1 &= ADDRESS_MAXWRAP( regs );

  00ce0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00ce5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00cec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00cf4	48 23 c8	 and	 rcx, rax
  00cf7	48 8b c1	 mov	 rax, rcx
  00cfa	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax
$LN42@z900_displ:

; 964  :         }
; 965  : 
; 966  :         /* Apply indexing for RX/RXE/RXF instructions */
; 967  :         if (0
; 968  :             || (opcode >= 0x40 && opcode <= 0x7F)
; 969  :             ||  opcode == 0xB1   // LRA
; 970  :             ||  opcode == 0xE3   // RXY-x
; 971  :             ||  opcode == 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00d02	33 c0		 xor	 eax, eax
  00d04	85 c0		 test	 eax, eax
  00d06	75 38		 jne	 SHORT $LN44@z900_displ
  00d08	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d0d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00d10	7c 0a		 jl	 SHORT $LN45@z900_displ
  00d12	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d17	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00d1a	7e 24		 jle	 SHORT $LN44@z900_displ
$LN45@z900_displ:
  00d1c	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d21	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00d26	74 18		 je	 SHORT $LN44@z900_displ
  00d28	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d2d	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00d32	74 0c		 je	 SHORT $LN44@z900_displ
  00d34	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d39	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00d3e	75 76		 jne	 SHORT $LN43@z900_displ
$LN44@z900_displ:

; 972  :         )
; 973  :         {
; 974  :             x1 = inst[1] & 0x0F;

  00d40	b8 01 00 00 00	 mov	 eax, 1
  00d45	48 6b c0 01	 imul	 rax, rax, 1
  00d49	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00d51	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d55	83 e0 0f	 and	 eax, 15
  00d58	89 84 24 b4 00
	00 00		 mov	 DWORD PTR x1$[rsp], eax

; 975  :             if (x1 != 0)

  00d5f	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR x1$[rsp], 0
  00d67	74 4d		 je	 SHORT $LN46@z900_displ

; 976  :             {
; 977  :                 addr1 += regs->GR( x1 );

  00d69	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR x1$[rsp]
  00d71	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00d76	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00d7e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00d86	48 03 c8	 add	 rcx, rax
  00d89	48 8b c1	 mov	 rax, rcx
  00d8c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 978  :                 addr1 &= ADDRESS_MAXWRAP( regs );

  00d94	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00d99	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00da0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  00da8	48 23 c8	 and	 rcx, rax
  00dab	48 8b c1	 mov	 rax, rcx
  00dae	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax
$LN46@z900_displ:
$LN43@z900_displ:
$LN41@z900_displ:

; 979  :             }
; 980  :         }
; 981  :     }
; 982  : 
; 983  :     /* Process the second storage operand */
; 984  :     if (1
; 985  :         && ilc > 4
; 986  :         && opcode != 0xC0   // RIL-x    (relative)
; 987  :         && opcode != 0xC4   // RIL-x    (relative)
; 988  :         && opcode != 0xC6   // RIL-x    (relative)
; 989  :         && opcode != 0xE3   // RXY-x
; 990  :         && opcode != 0xEB   // RSY-x, SIY-x
; 991  :         && opcode != 0xEC   // RIE-x
; 992  :         && opcode != 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00db6	33 c0		 xor	 eax, eax
  00db8	83 f8 01	 cmp	 eax, 1
  00dbb	0f 84 27 01 00
	00		 je	 $LN47@z900_displ
  00dc1	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00dc9	0f 8e 19 01 00
	00		 jle	 $LN47@z900_displ
  00dcf	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00dd4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00dd9	0f 84 09 01 00
	00		 je	 $LN47@z900_displ
  00ddf	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00de4	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00de9	0f 84 f9 00 00
	00		 je	 $LN47@z900_displ
  00def	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00df4	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00df9	0f 84 e9 00 00
	00		 je	 $LN47@z900_displ
  00dff	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e04	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00e09	0f 84 d9 00 00
	00		 je	 $LN47@z900_displ
  00e0f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e14	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00e19	0f 84 c9 00 00
	00		 je	 $LN47@z900_displ
  00e1f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e24	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00e29	0f 84 b9 00 00
	00		 je	 $LN47@z900_displ
  00e2f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e34	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00e39	0f 84 a9 00 00
	00		 je	 $LN47@z900_displ

; 993  :     )
; 994  :     {
; 995  :         /* Calculate the effective address of the second operand */
; 996  :         b2 = inst[4] >> 4;

  00e3f	b8 01 00 00 00	 mov	 eax, 1
  00e44	48 6b c0 04	 imul	 rax, rax, 4
  00e48	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e50	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e54	c1 f8 04	 sar	 eax, 4
  00e57	89 44 24 78	 mov	 DWORD PTR b2$[rsp], eax

; 997  :         addr2 = ((inst[4] & 0x0F) << 8) | inst[5];

  00e5b	b8 01 00 00 00	 mov	 eax, 1
  00e60	48 6b c0 04	 imul	 rax, rax, 4
  00e64	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e6c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e70	83 e0 0f	 and	 eax, 15
  00e73	c1 e0 08	 shl	 eax, 8
  00e76	b9 01 00 00 00	 mov	 ecx, 1
  00e7b	48 6b c9 05	 imul	 rcx, rcx, 5
  00e7f	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00e87	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e8b	0b c1		 or	 eax, ecx
  00e8d	48 98		 cdqe
  00e8f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 998  :         if (b2 != 0)

  00e97	83 7c 24 78 00	 cmp	 DWORD PTR b2$[rsp], 0
  00e9c	74 4a		 je	 SHORT $LN48@z900_displ

; 999  :         {
; 1000 :             addr2 += regs->GR( b2 );

  00e9e	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  00ea3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00ea8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00eb0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  00eb8	48 03 c8	 add	 rcx, rax
  00ebb	48 8b c1	 mov	 rax, rcx
  00ebe	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax

; 1001 :             addr2 &= ADDRESS_MAXWRAP( regs );

  00ec6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00ecb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00ed2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr2$[rsp]
  00eda	48 23 c8	 and	 rcx, rax
  00edd	48 8b c1	 mov	 rax, rcx
  00ee0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax
$LN48@z900_displ:
$LN47@z900_displ:

; 1002 :         }
; 1003 :     }
; 1004 : 
; 1005 :     /* Calculate the operand addresses for MVCL(E) and CLCL(E) */
; 1006 :     if (0
; 1007 :         || opcode == 0x0E   // MVCL
; 1008 :         || opcode == 0x0F   // CLCL
; 1009 :         || opcode == 0xA8   // MVCLE
; 1010 :         || opcode == 0xA9   // CLCLE

  00ee8	33 c0		 xor	 eax, eax
  00eea	85 c0		 test	 eax, eax
  00eec	75 30		 jne	 SHORT $LN50@z900_displ
  00eee	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ef3	83 f8 0e	 cmp	 eax, 14
  00ef6	74 26		 je	 SHORT $LN50@z900_displ
  00ef8	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00efd	83 f8 0f	 cmp	 eax, 15
  00f00	74 1c		 je	 SHORT $LN50@z900_displ
  00f02	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00f07	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  00f0c	74 10		 je	 SHORT $LN50@z900_displ
  00f0e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00f13	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  00f18	0f 85 8a 00 00
	00		 jne	 $LN49@z900_displ
$LN50@z900_displ:

; 1011 :     )
; 1012 :     {
; 1013 :         b1 = inst[1] >> 4;   addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  00f1e	b8 01 00 00 00	 mov	 eax, 1
  00f23	48 6b c0 01	 imul	 rax, rax, 1
  00f27	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f2f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f33	c1 f8 04	 sar	 eax, 4
  00f36	89 44 24 74	 mov	 DWORD PTR b1$[rsp], eax
  00f3a	48 63 44 24 74	 movsxd	 rax, DWORD PTR b1$[rsp]
  00f3f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00f44	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00f49	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00f50	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00f58	48 23 c2	 and	 rax, rdx
  00f5b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 1014 :         b2 = inst[1] & 0x0F; addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  00f63	b8 01 00 00 00	 mov	 eax, 1
  00f68	48 6b c0 01	 imul	 rax, rax, 1
  00f6c	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f74	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f78	83 e0 0f	 and	 eax, 15
  00f7b	89 44 24 78	 mov	 DWORD PTR b2$[rsp], eax
  00f7f	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  00f84	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00f89	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00f8e	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00f95	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00f9d	48 23 c2	 and	 rax, rdx
  00fa0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax
$LN49@z900_displ:

; 1015 :     }
; 1016 : 
; 1017 :     /* Calculate the operand addresses for RRE instructions */
; 1018 :     if (0
; 1019 :         || (opcode == 0xB2 &&
; 1020 :             (0
; 1021 :              || (inst[1] >= 0x20 && inst[1] <= 0x2F)
; 1022 :              || (inst[1] >= 0x40 && inst[1] <= 0x6F)
; 1023 :              || (inst[1] >= 0xA0 && inst[1] <= 0xAF)
; 1024 :             )
; 1025 :            )
; 1026 :         || (opcode == 0xB9 &&

  00fa8	33 c0		 xor	 eax, eax
  00faa	85 c0		 test	 eax, eax
  00fac	0f 85 2a 01 00
	00		 jne	 $LN52@z900_displ
  00fb2	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00fb7	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00fbc	0f 85 b2 00 00
	00		 jne	 $LN53@z900_displ
  00fc2	33 c0		 xor	 eax, eax
  00fc4	85 c0		 test	 eax, eax
  00fc6	0f 85 10 01 00
	00		 jne	 $LN52@z900_displ
  00fcc	b8 01 00 00 00	 mov	 eax, 1
  00fd1	48 6b c0 01	 imul	 rax, rax, 1
  00fd5	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00fdd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fe1	83 f8 20	 cmp	 eax, 32			; 00000020H
  00fe4	7c 1e		 jl	 SHORT $LN54@z900_displ
  00fe6	b8 01 00 00 00	 mov	 eax, 1
  00feb	48 6b c0 01	 imul	 rax, rax, 1
  00fef	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ff7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ffb	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00ffe	0f 8e d8 00 00
	00		 jle	 $LN52@z900_displ
$LN54@z900_displ:
  01004	b8 01 00 00 00	 mov	 eax, 1
  01009	48 6b c0 01	 imul	 rax, rax, 1
  0100d	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01015	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01019	83 f8 40	 cmp	 eax, 64			; 00000040H
  0101c	7c 1e		 jl	 SHORT $LN55@z900_displ
  0101e	b8 01 00 00 00	 mov	 eax, 1
  01023	48 6b c0 01	 imul	 rax, rax, 1
  01027	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0102f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01033	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  01036	0f 8e a0 00 00
	00		 jle	 $LN52@z900_displ
$LN55@z900_displ:
  0103c	b8 01 00 00 00	 mov	 eax, 1
  01041	48 6b c0 01	 imul	 rax, rax, 1
  01045	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0104d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01051	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  01056	7c 1c		 jl	 SHORT $LN56@z900_displ
  01058	b8 01 00 00 00	 mov	 eax, 1
  0105d	48 6b c0 01	 imul	 rax, rax, 1
  01061	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01069	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0106d	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  01072	7e 68		 jle	 SHORT $LN52@z900_displ
$LN56@z900_displ:
$LN53@z900_displ:
  01074	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01079	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  0107e	0f 85 41 01 00
	00		 jne	 $LN51@z900_displ
  01084	33 c0		 xor	 eax, eax
  01086	85 c0		 test	 eax, eax
  01088	75 52		 jne	 SHORT $LN57@z900_displ
  0108a	b8 01 00 00 00	 mov	 eax, 1
  0108f	48 6b c0 01	 imul	 rax, rax, 1
  01093	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0109b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0109f	83 f8 05	 cmp	 eax, 5
  010a2	74 38		 je	 SHORT $LN57@z900_displ
  010a4	b8 01 00 00 00	 mov	 eax, 1
  010a9	48 6b c0 01	 imul	 rax, rax, 1
  010ad	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010b9	83 f8 25	 cmp	 eax, 37			; 00000025H
  010bc	74 1e		 je	 SHORT $LN57@z900_displ
  010be	b8 01 00 00 00	 mov	 eax, 1
  010c3	48 6b c0 01	 imul	 rax, rax, 1
  010c7	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010d3	83 f8 31	 cmp	 eax, 49			; 00000031H
  010d6	0f 8c e9 00 00
	00		 jl	 $LN51@z900_displ
$LN57@z900_displ:
$LN52@z900_displ:

; 1027 :             (0
; 1028 :              || (inst[1] == 0x05)   // LURAG
; 1029 :              || (inst[1] == 0x25)   // STURG
; 1030 :              || (inst[1] >= 0x31)   // CLGFR
; 1031 :             )
; 1032 :            )
; 1033 :     )
; 1034 :     {
; 1035 :         b1 = inst[3] >> 4;

  010dc	b8 01 00 00 00	 mov	 eax, 1
  010e1	48 6b c0 03	 imul	 rax, rax, 3
  010e5	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010f1	c1 f8 04	 sar	 eax, 4
  010f4	89 44 24 74	 mov	 DWORD PTR b1$[rsp], eax

; 1036 :         addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  010f8	48 63 44 24 74	 movsxd	 rax, DWORD PTR b1$[rsp]
  010fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  01107	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  0110e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  01116	48 23 c2	 and	 rax, rdx
  01119	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 1037 :         b2 = inst[3] & 0x0F;

  01121	b8 01 00 00 00	 mov	 eax, 1
  01126	48 6b c0 03	 imul	 rax, rax, 3
  0112a	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01132	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01136	83 e0 0f	 and	 eax, 15
  01139	89 44 24 78	 mov	 DWORD PTR b2$[rsp], eax

; 1038 :         if (inst[1] >= 0x29 && inst[1] <= 0x2C)

  0113d	b8 01 00 00 00	 mov	 eax, 1
  01142	48 6b c0 01	 imul	 rax, rax, 1
  01146	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0114e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01152	83 f8 29	 cmp	 eax, 41			; 00000029H
  01155	7c 45		 jl	 SHORT $LN58@z900_displ
  01157	b8 01 00 00 00	 mov	 eax, 1
  0115c	48 6b c0 01	 imul	 rax, rax, 1
  01160	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0116c	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0116f	7f 2b		 jg	 SHORT $LN58@z900_displ

; 1039 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP_E( regs );

  01171	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  01176	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0117b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  01180	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  01187	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0118f	48 23 c2	 and	 rax, rdx
  01192	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax
  0119a	eb 29		 jmp	 SHORT $LN59@z900_displ
$LN58@z900_displ:

; 1040 :         else
; 1041 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  0119c	48 63 44 24 78	 movsxd	 rax, DWORD PTR b2$[rsp]
  011a1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  011a6	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  011ab	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  011b2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  011ba	48 23 c2	 and	 rax, rdx
  011bd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR addr2$[rsp], rax
$LN59@z900_displ:
$LN51@z900_displ:

; 1042 :     }
; 1043 : 
; 1044 :     /* Calculate the operand address for RIL-x (relative) instructions */
; 1045 :     if (0
; 1046 :         || (opcode == 0xC0 &&
; 1047 :             (0
; 1048 :              || (inst[1] & 0x0F) == 0x00    // LARL   (relative)
; 1049 :              || (inst[1] & 0x0F) == 0x04    // BRCL   (relative)
; 1050 :              || (inst[1] & 0x0F) == 0x05    // BRASL  (relative)
; 1051 :             )
; 1052 :            )
; 1053 :         || opcode == 0xC4   // RIL-x  (relative)
; 1054 :         || opcode == 0xC6   // RIL-x  (relative)

  011c5	33 c0		 xor	 eax, eax
  011c7	85 c0		 test	 eax, eax
  011c9	0f 85 84 00 00
	00		 jne	 $LN61@z900_displ
  011cf	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  011d4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  011d9	75 5c		 jne	 SHORT $LN62@z900_displ
  011db	33 c0		 xor	 eax, eax
  011dd	85 c0		 test	 eax, eax
  011df	75 72		 jne	 SHORT $LN61@z900_displ
  011e1	b8 01 00 00 00	 mov	 eax, 1
  011e6	48 6b c0 01	 imul	 rax, rax, 1
  011ea	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  011f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  011f6	83 e0 0f	 and	 eax, 15
  011f9	85 c0		 test	 eax, eax
  011fb	74 56		 je	 SHORT $LN61@z900_displ
  011fd	b8 01 00 00 00	 mov	 eax, 1
  01202	48 6b c0 01	 imul	 rax, rax, 1
  01206	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0120e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01212	83 e0 0f	 and	 eax, 15
  01215	83 f8 04	 cmp	 eax, 4
  01218	74 39		 je	 SHORT $LN61@z900_displ
  0121a	b8 01 00 00 00	 mov	 eax, 1
  0121f	48 6b c0 01	 imul	 rax, rax, 1
  01223	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0122b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0122f	83 e0 0f	 and	 eax, 15
  01232	83 f8 05	 cmp	 eax, 5
  01235	74 1c		 je	 SHORT $LN61@z900_displ
$LN62@z900_displ:
  01237	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0123c	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  01241	74 10		 je	 SHORT $LN61@z900_displ
  01243	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01248	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  0124d	0f 85 75 01 00
	00		 jne	 $LN60@z900_displ
$LN61@z900_displ:

; 1055 :     )
; 1056 :     {
; 1057 :         S64 offset;
; 1058 :         S32 relative_long_operand = fetch_fw( inst+2 );

  01253	48 8b 84 24 78
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0125b	48 83 c0 02	 add	 rax, 2
  0125f	48 8b c8	 mov	 rcx, rax
  01262	e8 00 00 00 00	 call	 fetch_fw_noswap
  01267	8b c8		 mov	 ecx, eax
  01269	e8 00 00 00 00	 call	 _byteswap_ulong
  0126e	89 84 24 98 00
	00 00		 mov	 DWORD PTR relative_long_operand$1[rsp], eax

; 1059 :         offset = 2LL * relative_long_operand;

  01275	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  0127d	48 d1 e0	 shl	 rax, 1
  01280	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR offset$3[rsp], rax

; 1060 :         addr1 = PSW_IA_FROM_IP( regs, 0 );  // (current instruction address)

  01288	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0128d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01292	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01299	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0129d	48 2b c1	 sub	 rax, rcx
  012a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  012a5	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  012ac	48 03 c8	 add	 rcx, rax
  012af	48 8b c1	 mov	 rax, rcx
  012b2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  012b7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  012be	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax
$LN16@z900_displ:

; 1061 : 
; 1062 :         PTT_PGM( "dinst rel1:", addr1, offset, relative_long_operand );

  012c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  012cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012d0	48 83 e0 20	 and	 rax, 32			; 00000020H
  012d4	48 85 c0	 test	 rax, rax
  012d7	74 44		 je	 SHORT $LN63@z900_displ
  012d9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  012e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  012ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  012ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194783
  012f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012fb	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  01303	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR addr1$[rsp]
  0130b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194784
  01312	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@z900_displ:
  0131d	33 c0		 xor	 eax, eax
  0131f	85 c0		 test	 eax, eax
  01321	75 a3		 jne	 SHORT $LN16@z900_displ

; 1063 : 
; 1064 :         addr1 += (VADR)offset;      // (plus relative offset)

  01323	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR offset$3[rsp]
  0132b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  01333	48 03 c8	 add	 rcx, rax
  01336	48 8b c1	 mov	 rax, rcx
  01339	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 1065 :         addr1 &= ADDRESS_MAXWRAP( regs );

  01341	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01346	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0134d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr1$[rsp]
  01355	48 23 c8	 and	 rcx, rax
  01358	48 8b c1	 mov	 rax, rcx
  0135b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR addr1$[rsp], rax

; 1066 :         b1 = 0;

  01363	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR b1$[rsp], 0
$LN19@z900_displ:

; 1067 : 
; 1068 :         PTT_PGM( "dinst rel1=", addr1, offset, relative_long_operand );

  0136b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01372	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01375	48 83 e0 20	 and	 rax, 32			; 00000020H
  01379	48 85 c0	 test	 rax, rax
  0137c	74 44		 je	 SHORT $LN64@z900_displ
  0137e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  01386	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0138f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01394	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194786
  0139b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013a0	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  013a8	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR addr1$[rsp]
  013b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194787
  013b7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  013bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN64@z900_displ:
  013c2	33 c0		 xor	 eax, eax
  013c4	85 c0		 test	 eax, eax
  013c6	75 a3		 jne	 SHORT $LN19@z900_displ
$LN60@z900_displ:

; 1069 :     }
; 1070 : 
; 1071 :     if (trace2file)

  013c8	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  013cd	85 c0		 test	 eax, eax
  013cf	74 74		 je	 SHORT $LN65@z900_displ

; 1072 :     {
; 1073 :         tf2326.op1.vaddr = addr1;

  013d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr1$[rsp]
  013d9	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+32], rax

; 1074 :         tf2326.op2.vaddr = addr2;

  013e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr2$[rsp]
  013e9	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+72], rax

; 1075 :         tf_2326( regs, &tf2326, inst[0], inst[1], b1, b2 );

  013f1	b8 01 00 00 00	 mov	 eax, 1
  013f6	48 6b c0 01	 imul	 rax, rax, 1
  013fa	b9 01 00 00 00	 mov	 ecx, 1
  013ff	48 6b c9 00	 imul	 rcx, rcx, 0
  01403	8b 54 24 78	 mov	 edx, DWORD PTR b2$[rsp]
  01407	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  0140b	8b 54 24 74	 mov	 edx, DWORD PTR b1$[rsp]
  0140f	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01413	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  0141b	44 0f b6 0c 02	 movzx	 r9d, BYTE PTR [rdx+rax]
  01420	48 8b 84 24 78
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  01428	44 0f b6 04 08	 movzx	 r8d, BYTE PTR [rax+rcx]
  0142d	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  01435	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0143a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326

; 1076 :     }

  01440	e9 26 05 00 00	 jmp	 $LN66@z900_displ
$LN65@z900_displ:

; 1077 :     else
; 1078 :     {
; 1079 :         /* Format storage at first storage operand location */
; 1080 :         if (b1 >= 0)

  01445	83 7c 24 74 00	 cmp	 DWORD PTR b1$[rsp], 0
  0144a	0f 8c 9f 02 00
	00		 jl	 $LN67@z900_displ

; 1081 :         {
; 1082 :             n = 0;

  01450	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1083 :             buf2[0] = '\0';

  01458	b8 01 00 00 00	 mov	 eax, 1
  0145d	48 6b c0 00	 imul	 rax, rax, 0
  01461	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR $T8[rsp], rax
  01469	48 81 bc 24 08
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T8[rsp], 512	; 00000200H
  01475	73 02		 jae	 SHORT $LN112@z900_displ
  01477	eb 05		 jmp	 SHORT $LN113@z900_displ
$LN112@z900_displ:
  01479	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN113@z900_displ:
  0147e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  01486	c6 84 04 50 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1084 : 
; 1085 : #if defined( _FEATURE_SIE )
; 1086 :             if (SIE_MODE( regs ))

  0148e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01493	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01499	d1 e8		 shr	 eax, 1
  0149b	83 e0 01	 and	 eax, 1
  0149e	85 c0		 test	 eax, eax
  014a0	74 2b		 je	 SHORT $LN68@z900_displ

; 1087 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  014a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194792
  014a9	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  014af	48 8d 94 24 50
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  014b7	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  014bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  014c1	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  014c5	03 c8		 add	 ecx, eax
  014c7	8b c1		 mov	 eax, ecx
  014c9	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN68@z900_displ:

; 1088 : #endif
; 1089 :             if (sysblk.cpus > 1)

  014cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014d4	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  014db	7e 6f		 jle	 SHORT $LN69@z900_displ

; 1090 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  014dd	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  014e2	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  014e9	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv835[rsp], eax
  014f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  014f5	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  014fc	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01503	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0150b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01511	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv835[rsp]
  01518	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0151c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01521	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194794
  01528	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0152e	48 8d 94 24 50
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  01536	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0153a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01540	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01544	03 c8		 add	 ecx, eax
  01546	8b c1		 mov	 eax, ecx
  01548	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN69@z900_displ:

; 1091 :                               PTYPSTR( regs->cpuad ), regs->cpuad );
; 1092 : 
; 1093 :             if (REAL_MODE( &regs->psw ))

  0154c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01551	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01555	83 e0 04	 and	 eax, 4
  01558	85 c0		 test	 eax, eax
  0155a	75 66		 jne	 SHORT $LN70@z900_displ

; 1094 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  0155c	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  01561	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  01566	48 2b c8	 sub	 rcx, rax
  01569	48 8b c1	 mov	 rax, rcx
  0156c	48 ff c8	 dec	 rax
  0156f	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  01574	48 8d 8c 0c 50
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  0157c	48 8d 94 24 8c
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  01584	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  01589	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194797
  01590	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01595	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0159d	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR [rsp+32], -2
  015a5	4c 8b c8	 mov	 r9, rax
  015a8	4c 8b c1	 mov	 r8, rcx
  015ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr1$[rsp]
  015b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  015b8	e8 00 00 00 00	 call	 z900_display_virt
  015bd	e9 f2 00 00 00	 jmp	 $LN71@z900_displ
$LN70@z900_displ:

; 1095 :                                           USE_REAL_ADDR, ACCTYPE_HW, "", &xcode );
; 1096 :             else
; 1097 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  015c2	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  015c7	83 f8 44	 cmp	 eax, 68			; 00000044H
  015ca	74 79		 je	 SHORT $LN115@z900_displ
  015cc	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  015d1	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  015d6	75 39		 jne	 SHORT $LN114@z900_displ
  015d8	b8 01 00 00 00	 mov	 eax, 1
  015dd	48 6b c0 01	 imul	 rax, rax, 1
  015e1	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  015e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  015ed	83 e0 0f	 and	 eax, 15
  015f0	85 c0		 test	 eax, eax
  015f2	75 1d		 jne	 SHORT $LN114@z900_displ
  015f4	b8 01 00 00 00	 mov	 eax, 1
  015f9	48 6b c0 04	 imul	 rax, rax, 4
  015fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01602	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0160a	83 e0 10	 and	 eax, 16
  0160d	85 c0		 test	 eax, eax
  0160f	75 34		 jne	 SHORT $LN115@z900_displ
$LN114@z900_displ:
  01611	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01616	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  0161b	75 0d		 jne	 SHORT $LN116@z900_displ
  0161d	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv887[rsp], 0
  01628	eb 0b		 jmp	 SHORT $LN117@z900_displ
$LN116@z900_displ:
  0162a	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv887[rsp], 0
$LN117@z900_displ:
  01635	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv887[rsp]
  0163c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv888[rsp], eax
  01643	eb 0b		 jmp	 SHORT $LN118@z900_displ
$LN115@z900_displ:
  01645	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv888[rsp], 0
$LN118@z900_displ:
  01650	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  01655	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0165a	48 2b c8	 sub	 rcx, rax
  0165d	48 8b c1	 mov	 rax, rcx
  01660	48 ff c8	 dec	 rax
  01663	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  01668	48 8d 8c 0c 50
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  01670	48 8d 94 24 8c
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  01678	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  0167d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194798
  01684	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01689	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR tv888[rsp]
  01690	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  01694	8b 54 24 74	 mov	 edx, DWORD PTR b1$[rsp]
  01698	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0169c	4c 8b c8	 mov	 r9, rax
  0169f	4c 8b c1	 mov	 r8, rcx
  016a2	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr1$[rsp]
  016aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  016af	e8 00 00 00 00	 call	 z900_display_virt
$LN71@z900_displ:

; 1098 :                                           b1, (opcode == 0x44                 // EX?
; 1099 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1100 :                                  || (opcode == 0xc6 && !(inst[1] & 0x0f) &&
; 1101 :                                      FACILITY_ENABLED( 035_EXECUTE_EXTN, regs )) // EXRL?
; 1102 : #endif
; 1103 :                                                     ? ACCTYPE_HW :     // EX/EXRL
; 1104 :                                      opcode == 0xB1 ? ACCTYPE_HW :
; 1105 :                                                       ACCTYPE_HW ), "", &xcode );
; 1106 : 
; 1107 :             MSGBUF( op1_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  016b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194799
  016bb	48 8d 8c 24 50
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  016c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  016c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194800
  016d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194801
  016dc	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  016e1	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  016e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN67@z900_displ:

; 1108 :         }
; 1109 : 
; 1110 :         /* Format storage at second storage operand location */
; 1111 :         if (b2 >= 0)

  016ef	83 7c 24 78 00	 cmp	 DWORD PTR b2$[rsp], 0
  016f4	0f 8c 71 02 00
	00		 jl	 $LN72@z900_displ

; 1112 :         {
; 1113 :             int ar = b2;

  016fa	8b 44 24 78	 mov	 eax, DWORD PTR b2$[rsp]
  016fe	89 84 24 bc 00
	00 00		 mov	 DWORD PTR ar$2[rsp], eax

; 1114 :             n = 0;

  01705	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1115 :             buf2[0] = '\0';

  0170d	b8 01 00 00 00	 mov	 eax, 1
  01712	48 6b c0 00	 imul	 rax, rax, 0
  01716	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR $T9[rsp], rax
  0171e	48 81 bc 24 10
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T9[rsp], 512	; 00000200H
  0172a	73 02		 jae	 SHORT $LN119@z900_displ
  0172c	eb 05		 jmp	 SHORT $LN120@z900_displ
$LN119@z900_displ:
  0172e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN120@z900_displ:
  01733	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  0173b	c6 84 04 50 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1116 : 
; 1117 : #if defined(_FEATURE_SIE)
; 1118 :             if (SIE_MODE( regs ))

  01743	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01748	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0174e	d1 e8		 shr	 eax, 1
  01750	83 e0 01	 and	 eax, 1
  01753	85 c0		 test	 eax, eax
  01755	74 2b		 je	 SHORT $LN73@z900_displ

; 1119 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  01757	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194804
  0175e	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01764	48 8d 94 24 50
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  0176c	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01770	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01776	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0177a	03 c8		 add	 ecx, eax
  0177c	8b c1		 mov	 eax, ecx
  0177e	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN73@z900_displ:

; 1120 : #endif
; 1121 :             if (sysblk.cpus > 1)

  01782	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01789	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  01790	7e 6f		 jle	 SHORT $LN74@z900_displ

; 1122 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  01792	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01797	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0179e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv925[rsp], eax
  017a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  017aa	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  017b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  017b8	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  017c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  017c6	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv925[rsp]
  017cd	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  017d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194806
  017dd	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  017e3	48 8d 94 24 50
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  017eb	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  017ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  017f5	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  017f9	03 c8		 add	 ecx, eax
  017fb	8b c1		 mov	 eax, ecx
  017fd	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN74@z900_displ:

; 1123 :                                PTYPSTR( regs->cpuad ), regs->cpuad );
; 1124 :             if (0
; 1125 :                 || REAL_MODE( &regs->psw )
; 1126 :                 || IS_REAL_ADDR_OP( opcode, inst[1] )

  01801	33 c0		 xor	 eax, eax
  01803	85 c0		 test	 eax, eax
  01805	0f 85 b6 00 00
	00		 jne	 $LN76@z900_displ
  0180b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01810	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01814	83 e0 04	 and	 eax, 4
  01817	85 c0		 test	 eax, eax
  01819	0f 84 a2 00 00
	00		 je	 $LN76@z900_displ
  0181f	33 c0		 xor	 eax, eax
  01821	85 c0		 test	 eax, eax
  01823	0f 85 98 00 00
	00		 jne	 $LN77@z900_displ
  01829	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0182e	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  01833	75 1a		 jne	 SHORT $LN78@z900_displ
  01835	b8 01 00 00 00	 mov	 eax, 1
  0183a	48 6b c0 01	 imul	 rax, rax, 1
  0183e	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01846	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0184a	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0184d	74 72		 je	 SHORT $LN77@z900_displ
$LN78@z900_displ:
  0184f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01854	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  01859	75 1a		 jne	 SHORT $LN79@z900_displ
  0185b	b8 01 00 00 00	 mov	 eax, 1
  01860	48 6b c0 01	 imul	 rax, rax, 1
  01864	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0186c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01870	83 f8 46	 cmp	 eax, 70			; 00000046H
  01873	74 4c		 je	 SHORT $LN77@z900_displ
$LN79@z900_displ:
  01875	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0187a	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  0187f	75 1a		 jne	 SHORT $LN80@z900_displ
  01881	b8 01 00 00 00	 mov	 eax, 1
  01886	48 6b c0 01	 imul	 rax, rax, 1
  0188a	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01892	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01896	83 f8 05	 cmp	 eax, 5
  01899	74 26		 je	 SHORT $LN77@z900_displ
$LN80@z900_displ:
  0189b	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  018a0	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  018a5	75 25		 jne	 SHORT $LN75@z900_displ
  018a7	b8 01 00 00 00	 mov	 eax, 1
  018ac	48 6b c0 01	 imul	 rax, rax, 1
  018b0	48 8b 8c 24 78
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  018b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  018bc	83 f8 25	 cmp	 eax, 37			; 00000025H
  018bf	75 0b		 jne	 SHORT $LN75@z900_displ
$LN77@z900_displ:
$LN76@z900_displ:

; 1127 :             )
; 1128 :                 ar = USE_REAL_ADDR;

  018c1	c7 84 24 bc 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR ar$2[rsp], -2
$LN75@z900_displ:

; 1129 : 
; 1130 :             ARCH_DEP( display_virt )( regs, addr2, buf2+n, sizeof( buf2 )-n-1,

  018cc	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  018d1	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  018d6	48 2b c8	 sub	 rcx, rax
  018d9	48 8b c1	 mov	 rax, rcx
  018dc	48 ff c8	 dec	 rax
  018df	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  018e4	48 8d 8c 0c 50
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  018ec	48 8d 94 24 8c
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  018f4	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  018f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194813
  01900	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01905	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0190d	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR ar$2[rsp]
  01914	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01918	4c 8b c8	 mov	 r9, rax
  0191b	4c 8b c1	 mov	 r8, rcx
  0191e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr2$[rsp]
  01926	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0192b	e8 00 00 00 00	 call	 z900_display_virt

; 1131 :                                       ar, ACCTYPE_HW, "", &xcode );
; 1132 : 
; 1133 :             MSGBUF( op2_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  01930	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194814
  01937	48 8d 8c 24 50
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  0193f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  01945	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0194a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194815
  01951	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194816
  01958	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0195d	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  01965	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN72@z900_displ:
$LN66@z900_displ:

; 1134 :         }
; 1135 :     }
; 1136 : 
; 1137 :     if (trace2file)

  0196b	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  01970	85 c0		 test	 eax, eax
  01972	74 47		 je	 SHORT $LN81@z900_displ

; 1138 :     {
; 1139 :         display_inst_regs( true, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  01974	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  0197c	48 8d 84 24 50
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  01984	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01989	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  0198f	4c 8b 84 24 78
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  01997	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0199c	b1 01		 mov	 cl, 1
  0199e	e8 00 00 00 00	 call	 display_inst_regs

; 1140 :         tf_2324( regs, inst );

  019a3	48 8b 94 24 78
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  019ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  019b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2324

; 1141 :     }

  019b6	e9 ac 01 00 00	 jmp	 $LN82@z900_displ
$LN81@z900_displ:

; 1142 :     else
; 1143 :     {
; 1144 :         /* Format registers associated with the instruction */
; 1145 :         if (!sysblk.showregsnone)

  019bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019c2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  019c8	c1 e8 11	 shr	 eax, 17
  019cb	83 e0 01	 and	 eax, 1
  019ce	85 c0		 test	 eax, eax
  019d0	75 2f		 jne	 SHORT $LN83@z900_displ

; 1146 :             display_inst_regs( false, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  019d2	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  019da	48 8d 84 24 50
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  019e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019e7	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  019ed	4c 8b 84 24 78
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  019f5	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  019fa	33 c9		 xor	 ecx, ecx
  019fc	e8 00 00 00 00	 call	 display_inst_regs
$LN83@z900_displ:

; 1147 : 
; 1148 :         if (sysblk.showregsfirst)

  01a01	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a08	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01a0e	c1 e8 10	 shr	 eax, 16
  01a11	83 e0 01	 and	 eax, 1
  01a14	85 c0		 test	 eax, eax
  01a16	74 58		 je	 SHORT $LN84@z900_displ

; 1149 :         {
; 1150 :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 1151 :             size_t len = strlen( regs_msg_buf );

  01a18	48 8d 8c 24 50
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01a20	e8 00 00 00 00	 call	 strlen
  01a25	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR len$10[rsp], rax

; 1152 :             if (len)

  01a2d	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR len$10[rsp], 0
  01a36	74 38		 je	 SHORT $LN85@z900_displ

; 1153 :                 regs_msg_buf[ len-1 ] = 0;

  01a38	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR len$10[rsp]
  01a40	48 ff c8	 dec	 rax
  01a43	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR $T11[rsp], rax
  01a4b	48 81 bc 24 20
	01 00 00 00 08
	00 00		 cmp	 QWORD PTR $T11[rsp], 2048 ; 00000800H
  01a57	73 02		 jae	 SHORT $LN121@z900_displ
  01a59	eb 05		 jmp	 SHORT $LN122@z900_displ
$LN121@z900_displ:
  01a5b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN122@z900_displ:
  01a60	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR $T11[rsp]
  01a68	c6 84 04 50 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN85@z900_displ:
$LN84@z900_displ:

; 1154 :         }
; 1155 : 
; 1156 :         /* Now display all instruction tracing messages all at once */
; 1157 :         if (sysblk.showregsfirst)

  01a70	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a77	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01a7d	c1 e8 10	 shr	 eax, 16
  01a80	83 e0 01	 and	 eax, 1
  01a83	85 c0		 test	 eax, eax
  01a85	74 71		 je	 SHORT $LN86@z900_displ

; 1158 :              LOGMSG( "%s%s%s%s", regs_msg_buf,

  01a87	b9 01 00 00 00	 mov	 ecx, 1
  01a8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a92	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  01a9a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01a9f	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  01aa7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01aac	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  01ab4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01ab9	48 8d 8c 24 50
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01ac1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ac6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194824
  01acd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ad2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ad7	41 b9 03 00 00
	00		 mov	 r9d, 3
  01add	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194825
  01ae4	ba 87 04 00 00	 mov	 edx, 1159		; 00000487H
  01ae9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194826
  01af0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01af6	eb 6f		 jmp	 SHORT $LN87@z900_displ
$LN86@z900_displ:

; 1159 :                                  psw_inst_msg, op1_stor_msg, op2_stor_msg );
; 1160 :         else LOGMSG( "%s%s%s%s", psw_inst_msg, op1_stor_msg, op2_stor_msg,

  01af8	b9 01 00 00 00	 mov	 ecx, 1
  01afd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b03	48 8d 8c 24 50
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01b0b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b10	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  01b18	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01b1d	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  01b25	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b2a	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  01b32	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194827
  01b3e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b43	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b48	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b4e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194828
  01b55	ba 89 04 00 00	 mov	 edx, 1161		; 00000489H
  01b5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194829
  01b61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN87@z900_displ:
$LN82@z900_displ:

; 1161 :                                  regs_msg_buf );
; 1162 :     }
; 1163 : 
; 1164 :     if (!iregs->ghostregs)

  01b67	48 8b 84 24 70
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  01b6f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01b75	c1 e8 0d	 shr	 eax, 13
  01b78	83 e0 01	 and	 eax, 1
  01b7b	85 c0		 test	 eax, eax
  01b7d	75 0b		 jne	 SHORT $LN88@z900_displ

; 1165 :         free_aligned( regs );

  01b7f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01b84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN88@z900_displ:
$LN1@z900_displ:
$LN89@z900_displ:

; 1166 : 
; 1167 : } /* end function display_inst_adj */

  01b8a	48 8b 8c 24 50
	15 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01b92	48 33 cc	 xor	 rcx, rsp
  01b95	e8 00 00 00 00	 call	 __security_check_cookie
  01b9a	48 81 c4 60 15
	00 00		 add	 rsp, 5472		; 00001560H
  01ba1	5f		 pop	 rdi
  01ba2	c3		 ret	 0
z900_display_inst_adj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 96
xcode$ = 100
arn$ = 104
addrwid$1 = 108
raddr$ = 112
i$ = 120
stid$ = 124
saddr$ = 128
tv89 = 136
len$ = 140
vaddr$ = 144
aaddr$ = 152
totamt$ = 160
tv244 = 168
eaddr$ = 176
pageamt$2 = 184
opnd$ = 192
pageadr$3 = 200
tv189 = 208
tv267 = 212
pageoff$4 = 216
tv209 = 224
tv287 = 232
maxadr$ = 240
tv185 = 248
tv263 = 256
trans$ = 264
newval$ = 280
buf$ = 320
__$ArrayPad$ = 416
regs$ = 448
argc$ = 456
argv$ = 464
cmdline$ = 472
z900_alter_display_virt PROC

; 626  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 627  : char*   opnd;                           /* range/alteration operand  */
; 628  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 629  : U64     maxadr;                         /* Highest virt storage addr */
; 630  : VADR    vaddr;                          /* Virtual storage address   */
; 631  : RADR    raddr;                          /* Real storage address      */
; 632  : RADR    aaddr;                          /* Absolute storage address  */
; 633  : int     stid;                           /* Segment table indication  */
; 634  : int     len;                            /* Number of bytes to alter  */
; 635  : int     i;                              /* Loop counter              */
; 636  : int     arn = 0;                        /* Access register number    */

  0002c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
$LN4@z900_alter:

; 637  : U16     xcode;                          /* Exception code            */
; 638  : char    trans[16];                      /* Address translation mode  */
; 639  : BYTE    newval[32];                     /* Storage alteration value  */
; 640  : char    buf[96];                        /* Message buffer            */
; 641  : char    type;                           /* optional addr-space type  */
; 642  : size_t  totamt;                         /* Total amount to be dumped */
; 643  : 
; 644  :     UNREFERENCED(cmdline);

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN4@z900_alter

; 645  : 
; 646  :     /* We require only one operand */
; 647  :     if (argc != 1)

  0003a	83 bc 24 c8 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00042	74 4c		 je	 SHORT $LN22@z900_alter

; 648  :     {
; 649  :         // "Missing or invalid argument(s)"
; 650  :         WRMSG( HHC17000, "E" );

  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194551
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194552
  00062	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00067	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194553
  00079	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194554
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :         return;

  0008b	e9 0e 09 00 00	 jmp	 $LN1@z900_alter
$LN22@z900_alter:

; 652  :     }
; 653  : 
; 654  :     /* Parse optional address-space prefix */
; 655  :     opnd = argv[0];

  00090	b8 08 00 00 00	 mov	 eax, 8
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 656  :     type = toupper( *opnd );

  000ad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c0	88 44 24 60	 mov	 BYTE PTR type$[rsp], al

; 657  : 
; 658  :     if (1
; 659  :         && type != 'P'
; 660  :         && type != 'S'
; 661  :         && type != 'H'

  000c4	33 c0		 xor	 eax, eax
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	74 28		 je	 SHORT $LN23@z900_alter
  000cb	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000d0	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d3	74 1e		 je	 SHORT $LN23@z900_alter
  000d5	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000da	83 f8 53	 cmp	 eax, 83			; 00000053H
  000dd	74 14		 je	 SHORT $LN23@z900_alter
  000df	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000e4	83 f8 48	 cmp	 eax, 72			; 00000048H
  000e7	74 0a		 je	 SHORT $LN23@z900_alter

; 662  :     )
; 663  :         arn = 0;

  000e9	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
  000f1	eb 5b		 jmp	 SHORT $LN24@z900_alter
$LN23@z900_alter:

; 664  :     else
; 665  :     {
; 666  :         switch (type)

  000f3	0f b6 44 24 60	 movzx	 eax, BYTE PTR type$[rsp]
  000f8	88 84 24 88 00
	00 00		 mov	 BYTE PTR tv89[rsp], al
  000ff	80 bc 24 88 00
	00 00 48	 cmp	 BYTE PTR tv89[rsp], 72	; 00000048H
  00107	74 2a		 je	 SHORT $LN27@z900_alter
  00109	80 bc 24 88 00
	00 00 50	 cmp	 BYTE PTR tv89[rsp], 80	; 00000050H
  00111	74 0c		 je	 SHORT $LN25@z900_alter
  00113	80 bc 24 88 00
	00 00 53	 cmp	 BYTE PTR tv89[rsp], 83	; 00000053H
  0011b	74 0c		 je	 SHORT $LN26@z900_alter
  0011d	eb 1c		 jmp	 SHORT $LN5@z900_alter
$LN25@z900_alter:

; 667  :         {
; 668  :             case 'P': arn = USE_PRIMARY_SPACE;   break;

  0011f	c7 44 24 68 fd
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -3
  00127	eb 12		 jmp	 SHORT $LN5@z900_alter
$LN26@z900_alter:

; 669  :             case 'S': arn = USE_SECONDARY_SPACE; break;

  00129	c7 44 24 68 fc
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -4
  00131	eb 08		 jmp	 SHORT $LN5@z900_alter
$LN27@z900_alter:

; 670  :             case 'H': arn = USE_HOME_SPACE;      break;

  00133	c7 44 24 68 fb
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -5
$LN5@z900_alter:

; 671  :         }
; 672  :         opnd++;

  0013b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  00143	48 ff c0	 inc	 rax
  00146	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
$LN24@z900_alter:

; 673  :     }
; 674  : 
; 675  :     /* Set limit for address range */
; 676  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 677  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;

  0014e	48 c7 84 24 f0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxadr$[rsp], -1

; 678  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 679  :     maxadr = 0x7FFFFFFF;
; 680  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 681  : 
; 682  :     /* Parse the range or alteration operand */
; 683  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  0015a	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  0016f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR saddr$[rsp]
  00177	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  0017f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  00187	e8 00 00 00 00	 call	 parse_range
  0018c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 684  :     if (len < 0) return;

  00193	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0019b	7d 05		 jge	 SHORT $LN28@z900_alter
  0019d	e9 fc 07 00 00	 jmp	 $LN1@z900_alter
$LN28@z900_alter:

; 685  : 
; 686  :     if (regs->mainlim == 0)

  001a2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001b2	75 61		 jne	 SHORT $LN29@z900_alter

; 687  :     {
; 688  :         // "%c:"F_RADR"  Storage address is not valid"
; 689  :         WRMSG( HHC02327, "E", 'V', saddr );

  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001cc	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194562
  001db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194563
  001e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194564
  001fe	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194565
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 690  :         return;

  00210	e9 89 07 00 00	 jmp	 $LN1@z900_alter
$LN29@z900_alter:

; 691  :     }
; 692  : 
; 693  :     /* Alter virtual storage */
; 694  :     if (len > 0
; 695  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, arn, regs, ACCTYPE_HW) == 0
; 696  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, eaddr, arn, regs, ACCTYPE_HW) == 0

  00215	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0021d	0f 8e cd 02 00
	00		 jle	 $LN30@z900_alter
  00223	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0022b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00238	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0023d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR saddr$[rsp]
  00245	48 8d 54 24 7c	 lea	 rdx, QWORD PTR stid$[rsp]
  0024a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0024f	e8 00 00 00 00	 call	 z900_virt_to_real
  00254	85 c0		 test	 eax, eax
  00256	0f 85 94 02 00
	00		 jne	 $LN30@z900_alter
  0025c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00264	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00271	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  00276	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR eaddr$[rsp]
  0027e	48 8d 54 24 7c	 lea	 rdx, QWORD PTR stid$[rsp]
  00283	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00288	e8 00 00 00 00	 call	 z900_virt_to_real
  0028d	85 c0		 test	 eax, eax
  0028f	0f 85 5b 02 00
	00		 jne	 $LN30@z900_alter

; 697  :     )
; 698  :     {
; 699  :         for (i=0; i < len; i++)

  00295	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0029d	eb 0a		 jmp	 SHORT $LN9@z900_alter
$LN7@z900_alter:
  0029f	8b 44 24 78	 mov	 eax, DWORD PTR i$[rsp]
  002a3	ff c0		 inc	 eax
  002a5	89 44 24 78	 mov	 DWORD PTR i$[rsp], eax
$LN9@z900_alter:
  002a9	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002b0	39 44 24 78	 cmp	 DWORD PTR i$[rsp], eax
  002b4	0f 8d 36 02 00
	00		 jge	 $LN8@z900_alter

; 700  :         {
; 701  :             /* Address of next byte */
; 702  :             vaddr = saddr + i;

  002ba	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$[rsp]
  002bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  002c7	48 03 c8	 add	 rcx, rax
  002ca	48 8b c1	 mov	 rax, rcx
  002cd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR vaddr$[rsp], rax

; 703  : 
; 704  :             /* Convert virtual address to real address */
; 705  :             xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, vaddr,

  002d5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002dd	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ea	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  002ef	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR vaddr$[rsp]
  002f7	48 8d 54 24 7c	 lea	 rdx, QWORD PTR stid$[rsp]
  002fc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00301	e8 00 00 00 00	 call	 z900_virt_to_real
  00306	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 706  :                 arn, regs, ACCTYPE_HW);
; 707  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  0030b	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  00314	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  0031c	44 8b 44 24 7c	 mov	 r8d, DWORD PTR stid$[rsp]
  00321	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00325	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	e8 00 00 00 00	 call	 z900_bldtrans

; 708  : 
; 709  :             /* Check for Translation Exception */
; 710  :             if (0 != xcode)

  00332	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00337	85 c0		 test	 eax, eax
  00339	0f 84 a7 00 00
	00		 je	 $LN31@z900_alter

; 711  :             {
; 712  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 713  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  0033f	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00344	8b c8		 mov	 ecx, eax
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  0034c	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  00354	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00359	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv189[rsp], ecx
  00360	b9 01 00 00 00	 mov	 ecx, 1
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036b	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  00373	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00378	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  00380	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00385	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  0038c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00390	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00398	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0039d	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  003a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194568
  003ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194569
  003b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194570
  003cf	ba ca 02 00 00	 mov	 edx, 714		; 000002caH
  003d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194571
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 714  :                     trans );
; 715  :                 return;

  003e1	e9 b8 05 00 00	 jmp	 $LN1@z900_alter
$LN31@z900_alter:

; 716  :             }
; 717  : 
; 718  :             /* Convert real address to absolute address */
; 719  :             aaddr = APPLY_PREFIXING (raddr, regs->PX);

  003e6	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  003eb	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  003f1	48 85 c0	 test	 rax, rax
  003f4	74 28		 je	 SHORT $LN44@z900_alter
  003f6	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  003fb	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00401	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00409	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0040d	74 0f		 je	 SHORT $LN44@z900_alter
  0040f	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00414	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
  0041c	eb 1f		 jmp	 SHORT $LN45@z900_alter
$LN44@z900_alter:
  0041e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00426	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  0042f	48 33 c8	 xor	 rcx, rax
  00432	48 8b c1	 mov	 rax, rcx
  00435	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
$LN45@z900_alter:
  0043d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv209[rsp]
  00445	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 720  : 
; 721  :             /* Check for addressing exception */
; 722  :             if (aaddr > regs->mainlim)

  0044d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00455	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0045c	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00464	76 5e		 jbe	 SHORT $LN32@z900_alter

; 723  :             {
; 724  :                 // "%c:"F_RADR"  Addressing exception"
; 725  :                 WRMSG( HHC02328, "E", 'R', raddr );

  00466	b9 01 00 00 00	 mov	 ecx, 1
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00471	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  00476	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0047b	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194573
  0048a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194574
  00496	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194575
  004ad	ba d5 02 00 00	 mov	 edx, 725		; 000002d5H
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194576
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 726  :                 return;

  004bf	e9 da 04 00 00	 jmp	 $LN1@z900_alter
$LN32@z900_alter:

; 727  :             }
; 728  : 
; 729  :             /* Update absolute storage */
; 730  :             regs->mainstor[aaddr] = newval[i];

  004c4	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$[rsp]
  004c9	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d1	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  004d8	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  004e0	0f b6 84 04 18
	01 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  004e8	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 731  :         }

  004eb	e9 af fd ff ff	 jmp	 $LN7@z900_alter
$LN8@z900_alter:
$LN30@z900_alter:
$LN12@z900_alter:

; 732  :     }
; 733  : 
; 734  :     /* Limit the amount to be displayed to a reasonable value */
; 735  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  004f0	48 81 bc 24 b0
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  004fc	76 2e		 jbe	 SHORT $LN33@z900_alter
  004fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00506	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  0050c	48 3b 84 24 80
	00 00 00	 cmp	 rax, QWORD PTR saddr$[rsp]
  00514	76 16		 jbe	 SHORT $LN33@z900_alter
  00516	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0051e	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00524	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@z900_alter:
  0052c	33 c0		 xor	 eax, eax
  0052e	85 c0		 test	 eax, eax
  00530	75 be		 jne	 SHORT $LN12@z900_alter

; 736  : 
; 737  :     /* Display virtual storage */
; 738  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  00532	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0053a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  00542	48 2b c8	 sub	 rcx, rax
  00545	48 8b c1	 mov	 rax, rcx
  00548	48 ff c0	 inc	 rax
  0054b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  00553	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  0055c	0f 86 3c 04 00
	00		 jbe	 $LN34@z900_alter

; 739  :     {
; 740  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  00562	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0056a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00570	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 741  :         size_t  pageoff  = saddr - pageadr;

  00578	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00580	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  00588	48 2b c8	 sub	 rcx, rax
  0058b	48 8b c1	 mov	 rax, rcx
  0058e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 742  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  00596	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0059b	48 2b 84 24 d8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  005a3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 743  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  005ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b2	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  005b9	75 0d		 jne	 SHORT $LN46@z900_alter
  005bb	c7 84 24 a8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv244[rsp], 64 ; 00000040H
  005c6	eb 0b		 jmp	 SHORT $LN47@z900_alter
$LN46@z900_alter:
  005c8	c7 84 24 a8 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv244[rsp], 32 ; 00000020H
$LN47@z900_alter:
  005d3	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv244[rsp]
  005db	88 44 24 6c	 mov	 BYTE PTR addrwid$1[rsp], al
$LN13@z900_alter:

; 744  : 
; 745  :         /* Dump absolute storage one whole page at a time */
; 746  : 
; 747  :         for (;;)
; 748  :         {
; 749  :             /* Next page to be dumped */
; 750  :             vaddr = pageadr;

  005df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  005e7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR vaddr$[rsp], rax

; 751  : 
; 752  :             /* Make sure we don't dump too much */
; 753  :             if (pageamt > totamt)

  005ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  005f7	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  005ff	76 10		 jbe	 SHORT $LN35@z900_alter

; 754  :                 pageamt = totamt;

  00601	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  00609	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@z900_alter:

; 755  : 
; 756  :             /* Convert virtual address to real address */
; 757  :             xcode = ARCH_DEP( virt_to_real )( &raddr, &stid, vaddr,

  00611	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00619	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00621	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00626	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0062b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR vaddr$[rsp]
  00633	48 8d 54 24 7c	 lea	 rdx, QWORD PTR stid$[rsp]
  00638	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0063d	e8 00 00 00 00	 call	 z900_virt_to_real
  00642	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 758  :                 arn, regs, ACCTYPE_HW );
; 759  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  00647	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  00650	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  00658	44 8b 44 24 7c	 mov	 r8d, DWORD PTR stid$[rsp]
  0065d	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00661	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	e8 00 00 00 00	 call	 z900_bldtrans

; 760  : 
; 761  :             /* Check for Translation Exception */
; 762  :             if (0 != xcode)

  0066e	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00673	85 c0		 test	 eax, eax
  00675	0f 84 a7 00 00
	00		 je	 $LN36@z900_alter

; 763  :             {
; 764  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 765  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  0067b	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00680	8b c8		 mov	 ecx, eax
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00688	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv263[rsp], rax
  00690	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00695	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv267[rsp], ecx
  0069c	b9 01 00 00 00	 mov	 ecx, 1
  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a7	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  006af	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv263[rsp]
  006bc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006c1	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv267[rsp]
  006c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006cc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  006d4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006d9	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194582
  006e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194583
  006f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00704	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194584
  0070b	ba fe 02 00 00	 mov	 edx, 766		; 000002feH
  00710	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194585
  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 766  :                     trans );
; 767  :             }

  0071d	e9 1e 02 00 00	 jmp	 $LN37@z900_alter
$LN36@z900_alter:

; 768  :             else
; 769  :             {
; 770  :                 /* Convert real address to absolute address */
; 771  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00722	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00727	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0072d	48 85 c0	 test	 rax, rax
  00730	74 28		 je	 SHORT $LN48@z900_alter
  00732	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00737	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0073d	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00745	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00749	74 0f		 je	 SHORT $LN48@z900_alter
  0074b	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00750	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
  00758	eb 1f		 jmp	 SHORT $LN49@z900_alter
$LN48@z900_alter:
  0075a	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00762	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00766	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  0076b	48 33 c8	 xor	 rcx, rax
  0076e	48 8b c1	 mov	 rax, rcx
  00771	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
$LN49@z900_alter:
  00779	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv287[rsp]
  00781	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 772  : 
; 773  :                 /* Check for addressing exception */
; 774  :                 if (aaddr > regs->mainlim)

  00789	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00791	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00798	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  007a0	76 5e		 jbe	 SHORT $LN38@z900_alter

; 775  :                 {
; 776  :                     // "%c:"F_RADR"  Addressing exception"
; 777  :                     WRMSG( HHC02328, "E", 'R', raddr );

  007a2	b9 01 00 00 00	 mov	 ecx, 1
  007a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  007b2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007b7	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  007bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194587
  007c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194588
  007d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  007e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194589
  007e9	ba 09 03 00 00	 mov	 edx, 777		; 00000309H
  007ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194590
  007f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 778  :                     break;  /* (no sense in continuing) */

  007fb	e9 9e 01 00 00	 jmp	 $LN14@z900_alter
$LN38@z900_alter:

; 779  :                 }
; 780  : 
; 781  :                 /* Display storage key for page and how translated. Note: we
; 782  :                    use the internal "_get_storage_key" function here so that
; 783  :                    we can display our STORKEY_BADFRM bit too, if it's set.
; 784  :                 */
; 785  :                 MSGBUF( buf, "R:"F_RADR"  K:%2.2X  %s",

  00800	b2 04		 mov	 dl, 4
  00802	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0080a	e8 00 00 00 00	 call	 z900__get_storage_key
  0080f	0f b6 c0	 movzx	 eax, al
  00812	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  0081a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0081f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00823	4c 8b 4c 24 70	 mov	 r9, QWORD PTR raddr$[rsp]
  00828	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194591
  0082f	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00834	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0083c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 786  :                     raddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ), trans );
; 787  : 
; 788  :                 WRMSG( HHC02291, "I", buf );

  00842	b9 01 00 00 00	 mov	 ecx, 1
  00847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0084d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00855	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0085a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194592
  00861	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194593
  0086d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00872	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00877	41 b9 03 00 00
	00		 mov	 r9d, 3
  0087d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194594
  00884	ba 14 03 00 00	 mov	 edx, 788		; 00000314H
  00889	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194595
  00890	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@z900_alter:

; 789  : 
; 790  :                 /* Now hexdump that absolute page */
; 791  :                 VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, vaddr,

  00896	0f b6 44 24 6c	 movzx	 eax, BYTE PTR addrwid$1[rsp]
  0089b	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  0089f	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  008a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  008ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b1	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  008b9	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR vaddr$[rsp]
  008c1	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  008c9	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d1	e8 00 00 00 00	 call	 z900_dump_abs_page
  008d6	85 c0		 test	 eax, eax
  008d8	74 5c		 je	 SHORT $LN39@z900_alter
$LN21@z900_alter:
  008da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194597
  008e1	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  008e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194598
  008ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194599
  008f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  008fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00901	85 c0		 test	 eax, eax
  00903	74 20		 je	 SHORT $LN40@z900_alter
  00905	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194601
  0090c	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  00912	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194602
  00919	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194603
  00920	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@z900_alter:
  00925	33 c0		 xor	 eax, eax
  00927	85 c0		 test	 eax, eax
  00929	75 af		 jne	 SHORT $LN21@z900_alter
  0092b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00931	85 c0		 test	 eax, eax
  00933	74 01		 je	 SHORT $LN41@z900_alter
  00935	cc		 int	 3
$LN41@z900_alter:
$LN39@z900_alter:
  00936	33 c0		 xor	 eax, eax
  00938	85 c0		 test	 eax, eax
  0093a	0f 85 56 ff ff
	ff		 jne	 $LN18@z900_alter
$LN37@z900_alter:

; 792  :                     pageoff, pageamt, 0, addrwid ) == 0);
; 793  :             }
; 794  : 
; 795  :             /* Check if we're done */
; 796  :             if (!(totamt -= pageamt))

  00940	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00948	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR totamt$[rsp]
  00950	48 2b c8	 sub	 rcx, rax
  00953	48 8b c1	 mov	 rax, rcx
  00956	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  0095e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  00967	75 02		 jne	 SHORT $LN42@z900_alter

; 797  :                 break;

  00969	eb 33		 jmp	 SHORT $LN14@z900_alter
$LN42@z900_alter:

; 798  : 
; 799  :             /* Go on to the next page */
; 800  :             pageoff =  0; // (from now on)

  0096b	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 801  :             pageamt =  PAGEFRAME_PAGESIZE;

  00977	48 c7 84 24 b8
	00 00 00 00 10
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 4096 ; 00001000H

; 802  :             pageadr += PAGEFRAME_PAGESIZE;

  00983	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  0098b	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00991	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 803  :         }

  00999	e9 41 fc ff ff	 jmp	 $LN13@z900_alter
$LN14@z900_alter:
$LN34@z900_alter:
$LN1@z900_alter:

; 804  :     }
; 805  : 
; 806  : } /* end function alter_display_virt */

  0099e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009a6	48 33 cc	 xor	 rcx, rsp
  009a9	e8 00 00 00 00	 call	 __security_check_cookie
  009ae	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  009b5	c3		 ret	 0
z900_alter_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 48
regs$ = 80
arn$ = 88
stid$ = 96
trans$ = 104
size$ = 112
z900_bldtrans PROC

; 607  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 608  :     /* Build string indicating how virtual address was translated    */
; 609  : 
; 610  :     char    buf[16];  /* Caller's buffer should be at least this big */
; 611  : 
; 612  :          if (REAL_MODE( &regs->psw )) MSGBUF( buf, "%s", "(dat off)"   );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0002f	83 e0 04	 and	 eax, 4
  00032	85 c0		 test	 eax, eax
  00034	75 23		 jne	 SHORT $LN2@z900_bldtr
  00036	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194475
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194476
  00044	ba 10 00 00 00	 mov	 edx, 16
  00049	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00054	e9 91 00 00 00	 jmp	 $LN3@z900_bldtr
$LN2@z900_bldtr:

; 613  :     else if (stid == TEA_ST_PRIMARY)  MSGBUF( buf, "%s", "(primary)"   );

  00059	83 7c 24 60 00	 cmp	 DWORD PTR stid$[rsp], 0
  0005e	75 20		 jne	 SHORT $LN4@z900_bldtr
  00060	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194479
  00067	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194480
  0006e	ba 10 00 00 00	 mov	 edx, 16
  00073	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0007e	eb 6a		 jmp	 SHORT $LN5@z900_bldtr
$LN4@z900_bldtr:

; 614  :     else if (stid == TEA_ST_SECNDRY)  MSGBUF( buf, "%s", "(secondary)" );

  00080	83 7c 24 60 02	 cmp	 DWORD PTR stid$[rsp], 2
  00085	75 20		 jne	 SHORT $LN6@z900_bldtr
  00087	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194483
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194484
  00095	ba 10 00 00 00	 mov	 edx, 16
  0009a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000a5	eb 43		 jmp	 SHORT $LN7@z900_bldtr
$LN6@z900_bldtr:

; 615  :     else if (stid == TEA_ST_HOME)     MSGBUF( buf, "%s", "(home)"      );

  000a7	83 7c 24 60 03	 cmp	 DWORD PTR stid$[rsp], 3
  000ac	75 20		 jne	 SHORT $LN8@z900_bldtr
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194487
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194488
  000bc	ba 10 00 00 00	 mov	 edx, 16
  000c1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000cc	eb 1c		 jmp	 SHORT $LN9@z900_bldtr
$LN8@z900_bldtr:

; 616  :     else                              MSGBUF( buf, "(AR%2.2d)", arn    );

  000ce	44 8b 4c 24 58	 mov	 r9d, DWORD PTR arn$[rsp]
  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194489
  000da	ba 10 00 00 00	 mov	 edx, 16
  000df	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@z900_bldtr:
$LN7@z900_bldtr:
$LN5@z900_bldtr:
$LN3@z900_bldtr:

; 617  : 
; 618  :     strlcpy( trans, buf, size);

  000ea	4c 8b 44 24 70	 mov	 r8, QWORD PTR size$[rsp]
  000ef	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  000f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR trans$[rsp]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 619  : }

  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00104	48 33 cc	 xor	 rcx, rsp
  00107	e8 00 00 00 00	 call	 __security_check_cookie
  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
z900_bldtrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 80
addrwid$1 = 84
raddr$ = 88
aaddr$ = 96
len$ = 104
saddr$ = 112
totamt$ = 120
tv207 = 128
pageamt$2 = 136
eaddr$ = 144
pageadr$3 = 152
tv145 = 160
pageoff$4 = 168
$T5 = 176
tv172 = 184
tv221 = 192
maxadr$ = 200
opnd$ = 208
absorr$ = 216
newval$ = 224
buf$ = 256
__$ArrayPad$ = 320
regs$ = 352
argc$ = 360
argv$ = 368
cmdline$ = 376
z900_alter_display_real_or_abs PROC

; 464  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_alter:

; 465  : char*   opnd;                           /* range/alteration operand  */
; 466  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 467  : U64     maxadr;                         /* Highest real storage addr */
; 468  : RADR    raddr;                          /* Real storage address      */
; 469  : RADR    aaddr;                          /* Absolute storage address  */
; 470  : size_t  totamt;                         /* Total amount to be dumped */
; 471  : int     len;                            /* Number of bytes to alter  */
; 472  : int     i;                              /* Loop counter              */
; 473  : BYTE    newval[32];                     /* Storage alteration value  */
; 474  : char    buf[64];                        /* MSGBUF work buffer        */
; 475  : char    absorr[8];                      /* Uppercase command         */
; 476  : 
; 477  :     UNREFERENCED(argc);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN4@z900_alter
$LN7@z900_alter:

; 478  :     UNREFERENCED(cmdline);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN7@z900_alter

; 479  : 
; 480  :     /* We require only one operand */
; 481  :     if (argc != 2)

  00038	83 bc 24 68 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00040	74 4c		 je	 SHORT $LN26@z900_alter

; 482  :     {
; 483  :         // "Missing or invalid argument(s)"
; 484  :         WRMSG( HHC17000, "E" );

  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194417
  00054	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194418
  00060	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194419
  00077	ba e4 01 00 00	 mov	 edx, 484		; 000001e4H
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194420
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 485  :         return;

  00089	e9 7d 06 00 00	 jmp	 $LN1@z900_alter
$LN26@z900_alter:

; 486  :     }
; 487  : 
; 488  :     /* Convert command to uppercase */
; 489  :     for (i = 0; argv[0][i]; i++)

  0008e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00096	eb 0a		 jmp	 SHORT $LN10@z900_alter
$LN8@z900_alter:
  00098	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_alter:
  000a2	b8 08 00 00 00	 mov	 eax, 8
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b0	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000b8	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000bc	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000c0	85 c0		 test	 eax, eax
  000c2	74 34		 je	 SHORT $LN9@z900_alter

; 490  :         absorr[i] = toupper(argv[0][i]);

  000c4	b8 08 00 00 00	 mov	 eax, 8
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d2	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000da	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000de	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000ea	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ef	88 84 0c d8 00
	00 00		 mov	 BYTE PTR absorr$[rsp+rcx], al
  000f6	eb a0		 jmp	 SHORT $LN8@z900_alter
$LN9@z900_alter:

; 491  :     absorr[i] = 0;

  000f8	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000fd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  00105	48 83 bc 24 b0
	00 00 00 08	 cmp	 QWORD PTR $T5[rsp], 8
  0010e	73 02		 jae	 SHORT $LN44@z900_alter
  00110	eb 05		 jmp	 SHORT $LN45@z900_alter
$LN44@z900_alter:
  00112	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN45@z900_alter:
  00117	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  0011f	c6 84 04 d8 00
	00 00 00	 mov	 BYTE PTR absorr$[rsp+rax], 0

; 492  :     opnd = argv[1];

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00138	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0013c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 493  : 
; 494  :     /* Set limit for address range */
; 495  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 496  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;

  00144	48 c7 84 24 c8
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxadr$[rsp], -1

; 497  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 498  :     maxadr = 0x7FFFFFFF;
; 499  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 500  : 
; 501  :     /* Parse the range or alteration operand */
; 502  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  00150	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015d	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00165	4c 8d 44 24 70	 lea	 r8, QWORD PTR saddr$[rsp]
  0016a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00172	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  0017a	e8 00 00 00 00	 call	 parse_range
  0017f	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 503  :     if (len < 0) return;

  00183	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  00188	7d 05		 jge	 SHORT $LN27@z900_alter
  0018a	e9 7c 05 00 00	 jmp	 $LN1@z900_alter
$LN27@z900_alter:

; 504  : 
; 505  :     if (regs->mainlim == 0)

  0018f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0019f	75 79		 jne	 SHORT $LN28@z900_alter

; 506  :     {
; 507  :         // "%c:"F_RADR"  Storage address is not valid"
; 508  :         WRMSG( HHC02327, "E", absorr[0], saddr );

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 00	 imul	 rax, rax, 0
  001aa	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  001b2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  001b9	b9 01 00 00 00	 mov	 ecx, 1
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ce	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194423
  001e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194424
  001ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194425
  00203	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194426
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 509  :         return;

  00215	e9 f1 04 00 00	 jmp	 $LN1@z900_alter
$LN28@z900_alter:

; 510  :     }
; 511  : 
; 512  :     /* Alter real or absolute storage */
; 513  :     if (len > 0)

  0021a	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  0021f	0f 8e 5a 01 00
	00		 jle	 $LN29@z900_alter

; 514  :     {
; 515  :         for (i=0; i < len; i++)

  00225	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0022d	eb 0a		 jmp	 SHORT $LN13@z900_alter
$LN11@z900_alter:
  0022f	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_alter:
  00239	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0023d	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00241	0f 8d 38 01 00
	00		 jge	 $LN12@z900_alter

; 516  :         {
; 517  :             /* Address of next byte */
; 518  :             raddr = saddr + i;

  00247	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0024c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00251	48 03 c8	 add	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 519  : 
; 520  :             /* Convert real address to absolute address */
; 521  :             if ('R' == absorr[0])

  0025c	b8 01 00 00 00	 mov	 eax, 1
  00261	48 6b c0 00	 imul	 rax, rax, 0
  00265	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  0026d	83 f8 52	 cmp	 eax, 82			; 00000052H
  00270	75 66		 jne	 SHORT $LN30@z900_alter

; 522  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00272	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  00277	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0027d	48 85 c0	 test	 rax, rax
  00280	74 28		 je	 SHORT $LN46@z900_alter
  00282	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  00287	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0028d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00299	74 0f		 je	 SHORT $LN46@z900_alter
  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002a0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  002a8	eb 1f		 jmp	 SHORT $LN47@z900_alter
$LN46@z900_alter:
  002aa	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR raddr$[rsp]
  002bb	48 33 c8	 xor	 rcx, rax
  002be	48 8b c1	 mov	 rax, rcx
  002c1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
$LN47@z900_alter:
  002c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv172[rsp]
  002d1	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  002d6	eb 0a		 jmp	 SHORT $LN31@z900_alter
$LN30@z900_alter:

; 523  :             else
; 524  :                 aaddr = raddr; /* (is already absolute) */

  002d8	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002dd	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN31@z900_alter:

; 525  : 
; 526  :             /* Check for addressing exception */
; 527  :             if (aaddr > regs->mainlim)

  002e2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ea	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002f1	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  002f6	76 5e		 jbe	 SHORT $LN32@z900_alter

; 528  :             {
; 529  :                 // "%c:"F_RADR"  Addressing exception"
; 530  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  002f8	b9 01 00 00 00	 mov	 ecx, 1
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00303	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00308	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0030d	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  00315	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194431
  0031c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194432
  00328	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00332	41 b9 03 00 00
	00		 mov	 r9d, 3
  00338	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194433
  0033f	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194434
  0034b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 531  :                 return;

  00351	e9 b5 03 00 00	 jmp	 $LN1@z900_alter
$LN32@z900_alter:

; 532  :             }
; 533  : 
; 534  :             /* Update absolute storage */
; 535  :             regs->mainstor[aaddr] = newval[i];

  00356	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0035b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0036a	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0036f	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  00377	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 536  : 
; 537  :         } /* end for(i) */

  0037a	e9 b0 fe ff ff	 jmp	 $LN11@z900_alter
$LN12@z900_alter:
$LN29@z900_alter:
$LN16@z900_alter:

; 538  :     }
; 539  : 
; 540  :     /* Limit the amount to be displayed to a reasonable value */
; 541  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  0037f	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  0038b	76 28		 jbe	 SHORT $LN33@z900_alter
  0038d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00395	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  0039b	48 3b 44 24 70	 cmp	 rax, QWORD PTR saddr$[rsp]
  003a0	76 13		 jbe	 SHORT $LN33@z900_alter
  003a2	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003a7	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  003ad	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@z900_alter:
  003b5	33 c0		 xor	 eax, eax
  003b7	85 c0		 test	 eax, eax
  003b9	75 c4		 jne	 SHORT $LN16@z900_alter

; 542  : 
; 543  :     /* Display real or absolute storage */
; 544  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  003bb	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  003c8	48 2b c8	 sub	 rcx, rax
  003cb	48 8b c1	 mov	 rax, rcx
  003ce	48 ff c0	 inc	 rax
  003d1	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  003d6	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  003dc	0f 86 29 03 00
	00		 jbe	 $LN34@z900_alter

; 545  :     {
; 546  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  003e2	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003e7	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003ed	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 547  :         size_t  pageoff  = saddr - pageadr;

  003f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  003fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00402	48 2b c8	 sub	 rcx, rax
  00405	48 8b c1	 mov	 rax, rcx
  00408	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 548  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  00410	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00415	48 2b 84 24 a8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  0041d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 549  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  00425	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0042c	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00433	75 0d		 jne	 SHORT $LN48@z900_alter
  00435	c7 84 24 80 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv207[rsp], 64 ; 00000040H
  00440	eb 0b		 jmp	 SHORT $LN49@z900_alter
$LN48@z900_alter:
  00442	c7 84 24 80 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv207[rsp], 32 ; 00000020H
$LN49@z900_alter:
  0044d	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR tv207[rsp]
  00455	88 44 24 54	 mov	 BYTE PTR addrwid$1[rsp], al
$LN17@z900_alter:

; 550  : 
; 551  :         /* Dump absolute storage one whole page at a time */
; 552  : 
; 553  :         for (;;)
; 554  :         {
; 555  :             /* Next page to be dumped */
; 556  :             raddr = pageadr;

  00459	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00461	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 557  : 
; 558  :             /* Make sure we don't dump too much */
; 559  :             if (pageamt > totamt)

  00466	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  0046b	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  00473	76 0d		 jbe	 SHORT $LN35@z900_alter

; 560  :                 pageamt = totamt;

  00475	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  0047a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@z900_alter:

; 561  : 
; 562  :             /* Convert real address to absolute address */
; 563  :             if ('R' == absorr[0])

  00482	b8 01 00 00 00	 mov	 eax, 1
  00487	48 6b c0 00	 imul	 rax, rax, 0
  0048b	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  00493	83 f8 52	 cmp	 eax, 82			; 00000052H
  00496	75 66		 jne	 SHORT $LN36@z900_alter

; 564  :                 aaddr = APPLY_PREFIXING( raddr, regs->PX );

  00498	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  0049d	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  004a3	48 85 c0	 test	 rax, rax
  004a6	74 28		 je	 SHORT $LN50@z900_alter
  004a8	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004ad	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  004b3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bb	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  004bf	74 0f		 je	 SHORT $LN50@z900_alter
  004c1	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004c6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  004ce	eb 1f		 jmp	 SHORT $LN51@z900_alter
$LN50@z900_alter:
  004d0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d8	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  004dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR raddr$[rsp]
  004e1	48 33 c8	 xor	 rcx, rax
  004e4	48 8b c1	 mov	 rax, rcx
  004e7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
$LN51@z900_alter:
  004ef	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv221[rsp]
  004f7	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  004fc	eb 0a		 jmp	 SHORT $LN37@z900_alter
$LN36@z900_alter:

; 565  :             else
; 566  :                 aaddr = raddr; /* (is already absolute) */

  004fe	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  00503	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN37@z900_alter:

; 567  : 
; 568  :             /* Check for addressing exception */
; 569  :             if (aaddr > regs->mainlim)

  00508	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00510	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00517	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  0051c	76 5e		 jbe	 SHORT $LN38@z900_alter

; 570  :             {
; 571  :                 // "%c:"F_RADR"  Addressing exception"
; 572  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  0051e	b9 01 00 00 00	 mov	 ecx, 1
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00529	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0052e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00533	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  0053b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194441
  00542	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194442
  0054e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00553	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00558	41 b9 03 00 00
	00		 mov	 r9d, 3
  0055e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194443
  00565	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  0056a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194444
  00571	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 573  :                 break;

  00577	e9 8f 01 00 00	 jmp	 $LN18@z900_alter
$LN38@z900_alter:

; 574  :             }
; 575  : 
; 576  :             /* Display storage key for this page. Note: we use the
; 577  :                internal "_get_storage_key" function here so that we
; 578  :                can display our STORKEY_BADFRM bit too, if it's set.
; 579  :             */
; 580  :             MSGBUF( buf, "A:"F_RADR"  K:%2.2X",

  0057c	b2 04		 mov	 dl, 4
  0057e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00583	e8 00 00 00 00	 call	 z900__get_storage_key
  00588	0f b6 c0	 movzx	 eax, al
  0058b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0058f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR aaddr$[rsp]
  00594	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194445
  0059b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  005a0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 581  :                 aaddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));
; 582  :             WRMSG( HHC02290, "I", buf );

  005ae	b9 01 00 00 00	 mov	 ecx, 1
  005b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b9	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005c1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194446
  005cd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194447
  005d9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e3	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194448
  005f0	ba 46 02 00 00	 mov	 edx, 582		; 00000246H
  005f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194449
  005fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@z900_alter:

; 583  : 
; 584  :             /* Now hexdump that absolute page */
; 585  :             VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, raddr,

  00602	b8 01 00 00 00	 mov	 eax, 1
  00607	48 6b c0 00	 imul	 rax, rax, 0
  0060b	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR addrwid$1[rsp]
  00610	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  00614	0f b6 84 04 d8
	00 00 00	 movzx	 eax, BYTE PTR absorr$[rsp+rax]
  0061c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00620	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00628	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0062d	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  00635	4c 8b 44 24 58	 mov	 r8, QWORD PTR raddr$[rsp]
  0063a	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0063f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00647	e8 00 00 00 00	 call	 z900_dump_abs_page
  0064c	85 c0		 test	 eax, eax
  0064e	74 5c		 je	 SHORT $LN39@z900_alter
$LN25@z900_alter:
  00650	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194451
  00657	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  0065d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194452
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194453
  0066b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00677	85 c0		 test	 eax, eax
  00679	74 20		 je	 SHORT $LN40@z900_alter
  0067b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194455
  00682	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00688	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194456
  0068f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194457
  00696	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@z900_alter:
  0069b	33 c0		 xor	 eax, eax
  0069d	85 c0		 test	 eax, eax
  0069f	75 af		 jne	 SHORT $LN25@z900_alter
  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006a7	85 c0		 test	 eax, eax
  006a9	74 01		 je	 SHORT $LN41@z900_alter
  006ab	cc		 int	 3
$LN41@z900_alter:
$LN39@z900_alter:
  006ac	33 c0		 xor	 eax, eax
  006ae	85 c0		 test	 eax, eax
  006b0	0f 85 4c ff ff
	ff		 jne	 $LN22@z900_alter

; 586  :                 pageoff, pageamt, absorr[0], addrwid ) == 0);
; 587  : 
; 588  :             /* Check if we're done */
; 589  :             if (!(totamt -= pageamt))

  006b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  006be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totamt$[rsp]
  006c3	48 2b c8	 sub	 rcx, rax
  006c6	48 8b c1	 mov	 rax, rcx
  006c9	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  006ce	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  006d4	75 02		 jne	 SHORT $LN42@z900_alter

; 590  :                 break;

  006d6	eb 33		 jmp	 SHORT $LN18@z900_alter
$LN42@z900_alter:

; 591  : 
; 592  :             /* Go on to the next page */
; 593  :             pageoff =  0; // (from now on)

  006d8	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 594  :             pageamt =  PAGEFRAME_PAGESIZE;

  006e4	48 c7 84 24 88
	00 00 00 00 10
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 4096 ; 00001000H

; 595  :             pageadr += PAGEFRAME_PAGESIZE;

  006f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  006f8	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006fe	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 596  :         }

  00706	e9 4e fd ff ff	 jmp	 $LN17@z900_alter
$LN18@z900_alter:
$LN34@z900_alter:
$LN1@z900_alter:
$LN43@z900_alter:

; 597  :     }
; 598  : 
; 599  : } /* end function alter_display_real_or_abs */

  0070b	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00713	48 33 cc	 xor	 rcx, rsp
  00716	e8 00 00 00 00	 call	 __security_check_cookie
  0071b	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00722	c3		 ret	 0
z900_alter_display_real_or_abs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 64
len$ = 68
opcode$ = 72
xcode$ = 76
ilc$ = 80
stid$ = 84
saddr$ = 88
raddr$ = 96
tv95 = 104
tv219 = 108
tv220 = 112
tv260 = 116
tv261 = 120
tv262 = 124
aaddr$ = 128
opnd$ = 136
eaddr$ = 144
tv195 = 152
maxadr$ = 160
inst$ = 168
buf$ = 176
__$ArrayPad$ = 688
regs$ = 736
argc$ = 744
argv$ = 752
cmdline$ = 760
z900_disasm_stor PROC

; 333  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 334  : char*   opnd;                           /* Range/alteration operand  */
; 335  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 336  : U64     maxadr;                         /* Highest real storage addr */
; 337  : RADR    raddr;                          /* Real storage address      */
; 338  : RADR    aaddr;                          /* Absolute storage address  */
; 339  : int     stid = -1;                      /* How translation was done  */

  0002e	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR stid$[rsp], -1
$LN4@z900_disas:

; 340  : int     len;                            /* Number of bytes to alter  */
; 341  : int     ilc;                            /* Instruction length counter*/
; 342  : BYTE    inst[6];                        /* Storage alteration value  */
; 343  : BYTE    opcode;                         /* Instruction opcode        */
; 344  : U16     xcode;                          /* Exception code            */
; 345  : char    type;                           /* Address space type        */
; 346  : char    buf[512];                       /* MSGBUF work buffer        */
; 347  : 
; 348  :     UNREFERENCED(cmdline);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN4@z900_disas

; 349  : 
; 350  :     /* We require only one operand */
; 351  :     if (argc != 1)

  0003c	83 bc 24 e8 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00044	74 4c		 je	 SHORT $LN10@z900_disas

; 352  :     {
; 353  :         // "Missing or invalid argument(s)"
; 354  :         WRMSG( HHC17000, "E" );

  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194308
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194309
  00064	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194310
  0007b	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194311
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 355  :         return;

  0008d	e9 fc 06 00 00	 jmp	 $LN1@z900_disas
$LN10@z900_disas:

; 356  :     }
; 357  : 
; 358  :     /* Parse optional address-space prefix */
; 359  :     opnd = argv[0];

  00092	b8 08 00 00 00	 mov	 eax, 8
  00097	48 6b c0 00	 imul	 rax, rax, 0
  0009b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 360  :     type = toupper( *opnd );

  000af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c2	88 44 24 40	 mov	 BYTE PTR type$[rsp], al

; 361  : 
; 362  :     if (0
; 363  :         || type == 'R'
; 364  :         || type == 'V'
; 365  :         || type == 'P'
; 366  :         || type == 'H'

  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 28		 jne	 SHORT $LN13@z900_disas
  000cc	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000d1	83 f8 52	 cmp	 eax, 82			; 00000052H
  000d4	74 1e		 je	 SHORT $LN13@z900_disas
  000d6	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000db	83 f8 56	 cmp	 eax, 86			; 00000056H
  000de	74 14		 je	 SHORT $LN13@z900_disas
  000e0	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000e5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000e8	74 0a		 je	 SHORT $LN13@z900_disas
  000ea	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000ef	83 f8 48	 cmp	 eax, 72			; 00000048H
  000f2	75 15		 jne	 SHORT $LN11@z900_disas
$LN13@z900_disas:

; 367  :     )
; 368  :         opnd++;

  000f4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
  00107	eb 2e		 jmp	 SHORT $LN12@z900_disas
$LN11@z900_disas:

; 369  :     else
; 370  :         type = REAL_MODE( &regs->psw ) ? 'R' : 'V';

  00109	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00111	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00115	83 e0 04	 and	 eax, 4
  00118	85 c0		 test	 eax, eax
  0011a	75 0a		 jne	 SHORT $LN27@z900_disas
  0011c	c7 44 24 68 52
	00 00 00	 mov	 DWORD PTR tv95[rsp], 82	; 00000052H
  00124	eb 08		 jmp	 SHORT $LN28@z900_disas
$LN27@z900_disas:
  00126	c7 44 24 68 56
	00 00 00	 mov	 DWORD PTR tv95[rsp], 86	; 00000056H
$LN28@z900_disas:
  0012e	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv95[rsp]
  00133	88 44 24 40	 mov	 BYTE PTR type$[rsp], al
$LN12@z900_disas:

; 371  : 
; 372  :     /* Set limit for address range */
; 373  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 374  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;

  00137	48 c7 84 24 a0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxadr$[rsp], -1

; 375  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 376  :     maxadr = 0x7FFFFFFF;
; 377  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 378  : 
; 379  :     /* Parse the range or alteration operand */
; 380  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, NULL);

  00143	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0014c	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00154	4c 8d 44 24 58	 lea	 r8, QWORD PTR saddr$[rsp]
  00159	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00161	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  00169	e8 00 00 00 00	 call	 parse_range
  0016e	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 381  :     if (len < 0) return;

  00172	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00177	7d 05		 jge	 SHORT $LN14@z900_disas
  00179	e9 10 06 00 00	 jmp	 $LN1@z900_disas
$LN14@z900_disas:

; 382  : 
; 383  :     if (regs->mainlim == 0)

  0017e	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00186	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0018e	75 58		 jne	 SHORT $LN15@z900_disas

; 384  :     {
; 385  :         WRMSG(HHC02289, "I", "Real address is not valid");

  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194317
  001a2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194318
  001ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194319
  001ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194320
  001d1	ba 81 01 00 00	 mov	 edx, 385		; 00000181H
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194321
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 386  :         return;

  001e3	e9 a6 05 00 00	 jmp	 $LN1@z900_disas
$LN15@z900_disas:
$LN7@z900_disas:

; 387  :     }
; 388  : 
; 389  :     /* Limit the amount to be displayed to a reasonable value */
; 390  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  001e8	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  001f4	76 28		 jbe	 SHORT $LN16@z900_disas
  001f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  001fe	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  00204	48 3b 44 24 58	 cmp	 rax, QWORD PTR saddr$[rsp]
  00209	76 13		 jbe	 SHORT $LN16@z900_disas
  0020b	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00210	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00216	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN16@z900_disas:
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 c4		 jne	 SHORT $LN7@z900_disas
$LN8@z900_disas:

; 391  : 
; 392  :     /* Display real storage */
; 393  :     while (saddr <= eaddr)

  00224	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  0022c	48 39 44 24 58	 cmp	 QWORD PTR saddr$[rsp], rax
  00231	0f 87 57 05 00
	00		 ja	 $LN9@z900_disas

; 394  :     {
; 395  :         if(type == 'R')

  00237	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  0023c	83 f8 52	 cmp	 eax, 82			; 00000052H
  0023f	75 0f		 jne	 SHORT $LN17@z900_disas

; 396  :             raddr = saddr;

  00241	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00246	48 89 44 24 60	 mov	 QWORD PTR raddr$[rsp], rax
  0024b	e9 d1 00 00 00	 jmp	 $LN18@z900_disas
$LN17@z900_disas:

; 397  :         else
; 398  :         {
; 399  :             /* Convert virtual address to real address */
; 400  :             if((xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, 0, regs, ACCTYPE_HW) ))

  00250	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00258	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00260	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00265	45 33 c9	 xor	 r9d, r9d
  00268	4c 8b 44 24 58	 mov	 r8, QWORD PTR saddr$[rsp]
  0026d	48 8d 54 24 54	 lea	 rdx, QWORD PTR stid$[rsp]
  00272	48 8d 4c 24 60	 lea	 rcx, QWORD PTR raddr$[rsp]
  00277	e8 00 00 00 00	 call	 z900_virt_to_real
  0027c	66 89 44 24 4c	 mov	 WORD PTR xcode$[rsp], ax
  00281	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  00286	85 c0		 test	 eax, eax
  00288	0f 84 93 00 00
	00		 je	 $LN19@z900_disas

; 401  :             {
; 402  :                 MSGBUF( buf, "R:"F_RADR"  Storage not accessible code = %4.4X (%s)",

  0028e	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  00293	8b c8		 mov	 ecx, eax
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  0029b	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR xcode$[rsp]
  002a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a5	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  002a9	4c 8b 4c 24 58	 mov	 r9, QWORD PTR saddr$[rsp]
  002ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194326
  002b5	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  002ba	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 403  :                     saddr, xcode, PIC2Name( xcode ));
; 404  :                 WRMSG( HHC02289, "I", buf );

  002c8	b9 01 00 00 00	 mov	 ecx, 1
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d3	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194327
  002e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194328
  002f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00303	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194329
  0030a	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194330
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  :                 return;

  0031c	e9 6d 04 00 00	 jmp	 $LN1@z900_disas
$LN19@z900_disas:
$LN18@z900_disas:

; 406  :             }
; 407  :         }
; 408  : 
; 409  :         /* Convert real address to absolute address */
; 410  :         aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00321	48 8b 44 24 60	 mov	 rax, QWORD PTR raddr$[rsp]
  00326	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0032c	48 85 c0	 test	 rax, rax
  0032f	74 28		 je	 SHORT $LN29@z900_disas
  00331	48 8b 44 24 60	 mov	 rax, QWORD PTR raddr$[rsp]
  00336	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0033c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00348	74 0f		 je	 SHORT $LN29@z900_disas
  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR raddr$[rsp]
  0034f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv195[rsp], rax
  00357	eb 1f		 jmp	 SHORT $LN30@z900_disas
$LN29@z900_disas:
  00359	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00361	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00365	48 8b 4c 24 60	 mov	 rcx, QWORD PTR raddr$[rsp]
  0036a	48 33 c8	 xor	 rcx, rax
  0036d	48 8b c1	 mov	 rax, rcx
  00370	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv195[rsp], rax
$LN30@z900_disas:
  00378	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  00380	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 411  :         if (aaddr > regs->mainlim)

  00388	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00390	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00397	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  0039f	76 78		 jbe	 SHORT $LN20@z900_disas

; 412  :         {
; 413  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", raddr );

  003a1	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  003a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194332
  003ad	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  003b2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 414  :             WRMSG( HHC02289, "I", buf );

  003c0	b9 01 00 00 00	 mov	 ecx, 1
  003c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003cb	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003d3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194333
  003df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194334
  003eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194335
  00402	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194336
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 415  :             return;

  00414	e9 75 03 00 00	 jmp	 $LN1@z900_disas
$LN20@z900_disas:

; 416  :         }
; 417  : 
; 418  :         /* Determine opcode and check for addressing exception */
; 419  :         opcode = regs->mainstor[aaddr];

  00419	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00421	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00428	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00430	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00434	88 44 24 48	 mov	 BYTE PTR opcode$[rsp], al

; 420  :         ilc = ILC(opcode);

  00438	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  0043d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00440	7d 0a		 jge	 SHORT $LN33@z900_disas
  00442	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv220[rsp], 2
  0044a	eb 26		 jmp	 SHORT $LN34@z900_disas
$LN33@z900_disas:
  0044c	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  00451	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00456	7d 0a		 jge	 SHORT $LN31@z900_disas
  00458	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv219[rsp], 4
  00460	eb 08		 jmp	 SHORT $LN32@z900_disas
$LN31@z900_disas:
  00462	c7 44 24 6c 06
	00 00 00	 mov	 DWORD PTR tv219[rsp], 6
$LN32@z900_disas:
  0046a	8b 44 24 6c	 mov	 eax, DWORD PTR tv219[rsp]
  0046e	89 44 24 70	 mov	 DWORD PTR tv220[rsp], eax
$LN34@z900_disas:
  00472	8b 44 24 70	 mov	 eax, DWORD PTR tv220[rsp]
  00476	89 44 24 50	 mov	 DWORD PTR ilc$[rsp], eax

; 421  : 
; 422  :         if (aaddr + ilc > regs->mainlim)

  0047a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0047f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00487	48 03 c8	 add	 rcx, rax
  0048a	48 8b c1	 mov	 rax, rcx
  0048d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00495	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0049c	76 7b		 jbe	 SHORT $LN21@z900_disas

; 423  :         {
; 424  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", aaddr );

  0049e	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR aaddr$[rsp]
  004a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194338
  004ad	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  004b2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 425  :             WRMSG( HHC02289, "I", buf );

  004c0	b9 01 00 00 00	 mov	 ecx, 1
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004cb	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004d3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194339
  004df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194340
  004eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  004fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194341
  00502	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00507	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194342
  0050e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  :             return;

  00514	e9 75 02 00 00	 jmp	 $LN1@z900_disas
$LN21@z900_disas:

; 427  :         }
; 428  : 
; 429  :         /* Copy instruction to work area and hex print it */
; 430  :         memcpy(inst, regs->mainstor + aaddr, ilc);

  00519	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0051e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00526	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0052d	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR aaddr$[rsp]
  00535	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  0053d	48 8b fa	 mov	 rdi, rdx
  00540	48 8b f1	 mov	 rsi, rcx
  00543	48 8b c8	 mov	 rcx, rax
  00546	f3 a4		 rep movsb

; 431  :         len = sprintf(buf, "%c:"F_RADR"  %2.2X%2.2X",

  00548	83 7c 24 54 00	 cmp	 DWORD PTR stid$[rsp], 0
  0054d	75 0a		 jne	 SHORT $LN39@z900_disas
  0054f	c7 44 24 7c 50
	00 00 00	 mov	 DWORD PTR tv262[rsp], 80 ; 00000050H
  00557	eb 3a		 jmp	 SHORT $LN40@z900_disas
$LN39@z900_disas:
  00559	83 7c 24 54 03	 cmp	 DWORD PTR stid$[rsp], 3
  0055e	75 0a		 jne	 SHORT $LN37@z900_disas
  00560	c7 44 24 78 48
	00 00 00	 mov	 DWORD PTR tv261[rsp], 72 ; 00000048H
  00568	eb 21		 jmp	 SHORT $LN38@z900_disas
$LN37@z900_disas:
  0056a	83 7c 24 54 02	 cmp	 DWORD PTR stid$[rsp], 2
  0056f	75 0a		 jne	 SHORT $LN35@z900_disas
  00571	c7 44 24 74 53
	00 00 00	 mov	 DWORD PTR tv260[rsp], 83 ; 00000053H
  00579	eb 08		 jmp	 SHORT $LN36@z900_disas
$LN35@z900_disas:
  0057b	c7 44 24 74 52
	00 00 00	 mov	 DWORD PTR tv260[rsp], 82 ; 00000052H
$LN36@z900_disas:
  00583	8b 44 24 74	 mov	 eax, DWORD PTR tv260[rsp]
  00587	89 44 24 78	 mov	 DWORD PTR tv261[rsp], eax
$LN38@z900_disas:
  0058b	8b 44 24 78	 mov	 eax, DWORD PTR tv261[rsp]
  0058f	89 44 24 7c	 mov	 DWORD PTR tv262[rsp], eax
$LN40@z900_disas:
  00593	b8 01 00 00 00	 mov	 eax, 1
  00598	48 6b c0 01	 imul	 rax, rax, 1
  0059c	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  005a4	b9 01 00 00 00	 mov	 ecx, 1
  005a9	48 6b c9 00	 imul	 rcx, rcx, 0
  005ad	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  005b5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005b9	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005bd	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  005c2	44 8b 44 24 7c	 mov	 r8d, DWORD PTR tv262[rsp]
  005c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194343
  005ce	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005d6	e8 00 00 00 00	 call	 sprintf
  005db	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 432  :           stid == TEA_ST_PRIMARY ? 'P' :
; 433  :           stid == TEA_ST_HOME ? 'H' :
; 434  :           stid == TEA_ST_SECNDRY ? 'S' : 'R',
; 435  :           raddr, inst[0], inst[1]);
; 436  : 
; 437  :         if(ilc > 2)

  005df	83 7c 24 50 02	 cmp	 DWORD PTR ilc$[rsp], 2
  005e4	0f 8e e0 00 00
	00		 jle	 $LN22@z900_disas

; 438  :         {
; 439  :             len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X", inst[2], inst[3]);

  005ea	b8 01 00 00 00	 mov	 eax, 1
  005ef	48 6b c0 03	 imul	 rax, rax, 3
  005f3	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  005fb	b9 01 00 00 00	 mov	 ecx, 1
  00600	48 6b c9 02	 imul	 rcx, rcx, 2
  00604	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  0060c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00610	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00614	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194346
  0061b	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00621	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00629	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  0062d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00633	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00637	03 c8		 add	 ecx, eax
  00639	8b c1		 mov	 eax, ecx
  0063b	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 440  :             if(ilc > 4)

  0063f	83 7c 24 50 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00644	7e 57		 jle	 SHORT $LN24@z900_disas

; 441  :                 len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X ", inst[4], inst[5]);

  00646	b8 01 00 00 00	 mov	 eax, 1
  0064b	48 6b c0 05	 imul	 rax, rax, 5
  0064f	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  00657	b9 01 00 00 00	 mov	 ecx, 1
  0065c	48 6b c9 04	 imul	 rcx, rcx, 4
  00660	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  00668	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0066c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00670	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194349
  00677	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0067d	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00685	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00689	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0068f	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00693	03 c8		 add	 ecx, eax
  00695	8b c1		 mov	 eax, ecx
  00697	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
  0069b	eb 2b		 jmp	 SHORT $LN25@z900_disas
$LN24@z900_disas:

; 442  :             else
; 443  :                 len += idx_snprintf( len, buf, sizeof(buf), "     ");

  0069d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194350
  006a4	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006aa	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006b2	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006bc	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006c0	03 c8		 add	 ecx, eax
  006c2	8b c1		 mov	 eax, ecx
  006c4	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN25@z900_disas:

; 444  :         }

  006c8	eb 2b		 jmp	 SHORT $LN23@z900_disas
$LN22@z900_disas:

; 445  :         else
; 446  :             len += idx_snprintf( len, buf, sizeof(buf), "         ");

  006ca	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194351
  006d1	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006d7	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006df	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006e9	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006ed	03 c8		 add	 ecx, eax
  006ef	8b c1		 mov	 eax, ecx
  006f1	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN23@z900_disas:

; 447  : 
; 448  :         /* Disassemble the instruction and display the results */
; 449  :         PRINT_INST( regs->arch_mode, inst, buf + len );

  006f5	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  006fa	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00702	4c 8b c8	 mov	 r9, rax
  00705	45 33 c0	 xor	 r8d, r8d
  00708	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  00710	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00718	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  0071b	e8 00 00 00 00	 call	 iprint_router_func

; 450  :         WRMSG( HHC02289, "I", buf );

  00720	b9 01 00 00 00	 mov	 ecx, 1
  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0072b	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00733	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00738	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194352
  0073f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194353
  0074b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00750	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00755	41 b9 03 00 00
	00		 mov	 r9d, 3
  0075b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194354
  00762	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00767	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194355
  0076e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 451  : 
; 452  :         /* Go on to the next instruction */
; 453  :         saddr += ilc;

  00774	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00779	48 8b 4c 24 58	 mov	 rcx, QWORD PTR saddr$[rsp]
  0077e	48 03 c8	 add	 rcx, rax
  00781	48 8b c1	 mov	 rax, rcx
  00784	48 89 44 24 58	 mov	 QWORD PTR saddr$[rsp], rax

; 454  : 
; 455  :     } /* end while (saddr <= eaddr) */

  00789	e9 96 fa ff ff	 jmp	 $LN8@z900_disas
$LN9@z900_disas:
$LN1@z900_disas:

; 456  : 
; 457  : } /* end function disasm_stor */

  0078e	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00796	48 33 cc	 xor	 rcx, rsp
  00799	e8 00 00 00 00	 call	 __security_check_cookie
  0079e	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  007a5	5f		 pop	 rdi
  007a6	5e		 pop	 rsi
  007a7	c3		 ret	 0
z900_disasm_stor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
dumpbuf$ = 80
tv129 = 88
tv159 = 92
msgnum$ = 96
tv66 = 104
dumpdata$ = 112
tv202 = 120
tv217 = 128
pfx$ = 144
__$ArrayPad$ = 208
regs$ = 240
aaddr$ = 248
adr$ = 256
offset$ = 264
amt$ = 272
vra$ = 280
wid$ = 288
z900_dump_abs_page PROC

; 238  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 239  :     char*   msgnum;                 /* "HHC02290" or "HHC02291"      */
; 240  :     char*   dumpdata;               /* pointer to data to be dumped  */
; 241  :     char*   dumpbuf = NULL;         /* pointer to hexdump buffer     */

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR dumpbuf$[rsp], 0

; 242  :     char    pfx[64];                /* string prefixed to each line  */
; 243  : 
; 244  :     msgnum = vra ? "HHC02290" : "HHC02291";

  00036	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0003e	85 c0		 test	 eax, eax
  00040	74 0e		 je	 SHORT $LN11@z900_dump_
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194228
  00049	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
  0004e	eb 0c		 jmp	 SHORT $LN12@z900_dump_
$LN11@z900_dump_:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194229
  00057	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
$LN12@z900_dump_:
  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR tv66[rsp]
  00061	48 89 44 24 60	 mov	 QWORD PTR msgnum$[rsp], rax

; 245  : 
; 246  :     if (0
; 247  :         || aaddr  &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 248  :         || adr    &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 249  :         || offset >= PAGEFRAME_PAGESIZE     /* offset >= pagesize    */
; 250  :         || amt    > (PAGEFRAME_PAGESIZE - offset)/* more than 1 page */
; 251  :         || (wid != 32 && wid != 64)         /* invalid address width */

  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 65		 jne	 SHORT $LN3@z900_dump_
  0006c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR aaddr$[rsp]
  00074	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0007a	48 85 c0	 test	 rax, rax
  0007d	75 52		 jne	 SHORT $LN3@z900_dump_
  0007f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00087	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0008d	48 85 c0	 test	 rax, rax
  00090	75 3f		 jne	 SHORT $LN3@z900_dump_
  00092	48 81 bc 24 08
	01 00 00 00 10
	00 00		 cmp	 QWORD PTR offset$[rsp], 4096 ; 00001000H
  0009e	73 31		 jae	 SHORT $LN3@z900_dump_
  000a0	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000a5	48 2b 84 24 08
	01 00 00	 sub	 rax, QWORD PTR offset$[rsp]
  000ad	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR amt$[rsp], rax
  000b5	77 1a		 ja	 SHORT $LN3@z900_dump_
  000b7	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c2	74 76		 je	 SHORT $LN2@z900_dump_
  000c4	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000cc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cf	74 69		 je	 SHORT $LN2@z900_dump_
$LN3@z900_dump_:

; 252  :     )
; 253  :     {
; 254  :         // "Error in function %s: %s"
; 255  :         WRMSG( HHC02219, "E", "dump_abs_page()", "invalid parameters" );

  000d1	b9 01 00 00 00	 mov	 ecx, 1
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194232
  000e3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194233
  000ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194234
  000fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194235
  00107	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	41 b9 03 00 00
	00		 mov	 r9d, 3
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194236
  0011e	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194237
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 256  :         return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 b0 03 00 00	 jmp	 $LN1@z900_dump_
$LN2@z900_dump_:

; 257  :     }
; 258  : 
; 259  :     /* Flush interval timer value to storage */
; 260  :     ITIMER_SYNC( adr + offset, amt, regs );
; 261  : 
; 262  :     /* Check for addressing exception */
; 263  :     if (aaddr > regs->mainlim)

  0013a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00149	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00151	0f 86 0e 01 00
	00		 jbe	 $LN4@z900_dump_

; 264  :     {
; 265  :         MSGBUF( pfx, "%c:"F_RADR"  Addressing exception",

  00157	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0015f	85 c0		 test	 eax, eax
  00161	74 0e		 je	 SHORT $LN13@z900_dump_
  00163	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0016b	89 44 24 58	 mov	 DWORD PTR tv129[rsp], eax
  0016f	eb 08		 jmp	 SHORT $LN14@z900_dump_
$LN13@z900_dump_:
  00171	c7 44 24 58 56
	00 00 00	 mov	 DWORD PTR tv129[rsp], 86 ; 00000056H
$LN14@z900_dump_:
  00179	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	44 8b 4c 24 58	 mov	 r9d, DWORD PTR tv129[rsp]
  0018b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194239
  00192	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00197	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 266  :             vra ? vra : 'V', adr );
; 267  :         if (vra)

  001a5	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  001ad	85 c0		 test	 eax, eax
  001af	74 56		 je	 SHORT $LN5@z900_dump_

; 268  :             WRMSG( HHC02290, "E", pfx );

  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bc	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  001c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194242
  001d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194243
  001dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194244
  001f3	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194245
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00205	eb 54		 jmp	 SHORT $LN6@z900_dump_
$LN5@z900_dump_:

; 269  :         else
; 270  :             WRMSG( HHC02291, "E", pfx );

  00207	b9 01 00 00 00	 mov	 ecx, 1
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0021a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194246
  00226	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194247
  00232	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00237	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00242	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194248
  00249	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194249
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@z900_dump_:

; 271  :         return -1;

  0025b	b8 ff ff ff ff	 mov	 eax, -1
  00260	e9 85 02 00 00	 jmp	 $LN1@z900_dump_
$LN4@z900_dump_:

; 272  :     }
; 273  : 
; 274  :     /* Format string each dump line should be prefixed with */
; 275  :     MSGBUF( pfx, "%sI %c:", msgnum, vra ? vra : 'V' );

  00265	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0026d	85 c0		 test	 eax, eax
  0026f	74 0e		 je	 SHORT $LN15@z900_dump_
  00271	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  00279	89 44 24 5c	 mov	 DWORD PTR tv159[rsp], eax
  0027d	eb 08		 jmp	 SHORT $LN16@z900_dump_
$LN15@z900_dump_:
  0027f	c7 44 24 5c 56
	00 00 00	 mov	 DWORD PTR tv159[rsp], 86 ; 00000056H
$LN16@z900_dump_:
  00287	8b 44 24 5c	 mov	 eax, DWORD PTR tv159[rsp]
  0028b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0028f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR msgnum$[rsp]
  00294	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194250
  0029b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  002a0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 276  : 
; 277  :     /* Point to first byte of actual storage to be dumped */
; 278  :     dumpdata = (char*) regs->mainstor + aaddr + offset;

  002ae	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002bd	48 03 84 24 f8
	00 00 00	 add	 rax, QWORD PTR aaddr$[rsp]
  002c5	48 03 84 24 08
	01 00 00	 add	 rax, QWORD PTR offset$[rsp]
  002cd	48 89 44 24 70	 mov	 QWORD PTR dumpdata$[rsp], rax

; 279  : 
; 280  :     /* Adjust cosmetic starting address of first line of dump */
; 281  :     adr += offset;                  /* exact cosmetic start address  */

  002d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  002da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adr$[rsp]
  002e2	48 03 c8	 add	 rcx, rax
  002e5	48 8b c1	 mov	 rax, rcx
  002e8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 282  :     adr &= ~0xF;                    /* align to 16-byte boundary     */

  002f0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  002f8	48 83 e0 f0	 and	 rax, -16
  002fc	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 283  :     offset &= 0xF;                  /* offset must be < (bpg * gpl)  */

  00304	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0030c	48 83 e0 0f	 and	 rax, 15
  00310	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 284  : 
; 285  :     /* Use hexdump to format 16-byte aligned absolute storage dump   */
; 286  : 
; 287  :     hexdumpew                       /* afterwards dumpbuf --> dump   */

  00318	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  00320	48 c7 44 24 40
	04 00 00 00	 mov	 QWORD PTR [rsp+64], 4
  00329	48 c7 44 24 38
	04 00 00 00	 mov	 QWORD PTR [rsp+56], 4
  00332	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00336	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  0033e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00343	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR amt$[rsp]
  0034b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00350	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR offset$[rsp]
  00358	4c 8b 44 24 70	 mov	 r8, QWORD PTR dumpdata$[rsp]
  0035d	48 8d 54 24 50	 lea	 rdx, QWORD PTR dumpbuf$[rsp]
  00362	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hexdumpew

; 288  :     (
; 289  :         pfx,                        /* string prefixed to each line  */
; 290  :         &dumpbuf,                   /* ptr to hexdump buffer pointer */
; 291  :                                     /* (if NULL hexdump will malloc) */
; 292  :         dumpdata,                   /* pointer to data to be dumped  */
; 293  :         offset,                     /* bytes to skip on first line   */
; 294  :         amt,                        /* amount of data to be dumped   */
; 295  :         adr,                        /* cosmetic dump address of data */
; 296  :         wid,                        /* width of dump address in bits */
; 297  :         4,                          /* bpg value (bytes per group)   */
; 298  :         4                           /* gpl value (groups per line)   */
; 299  :     );
; 300  : 
; 301  :     /* Check for internal hexdumpew error */
; 302  :     if (!dumpbuf)

  00370	48 83 7c 24 50
	00		 cmp	 QWORD PTR dumpbuf$[rsp], 0
  00376	75 69		 jne	 SHORT $LN7@z900_dump_

; 303  :     {
; 304  :         // "Error in function %s: %s"
; 305  :         WRMSG( HHC02219, "E", "dump_abs_page()", "hexdumpew failed" );

  00378	b9 01 00 00 00	 mov	 ecx, 1
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194252
  0038a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0038f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194253
  00396	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194254
  003a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194255
  003ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  003be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194256
  003c5	ba 31 01 00 00	 mov	 edx, 305		; 00000131H
  003ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194257
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 306  :         return -1;

  003d7	b8 ff ff ff ff	 mov	 eax, -1
  003dc	e9 09 01 00 00	 jmp	 $LN1@z900_dump_
$LN7@z900_dump_:

; 307  :     }
; 308  : 
; 309  :     /* Display the dump and free the buffer hexdump malloc'ed for us */
; 310  : 
; 311  :     /* Note: due to WRMSG requirements for multi-line messages, the
; 312  :        first line should not have a message number. Thus we skip past
; 313  :        it via +1 for "I" in message number +1 for blank following it.
; 314  :        We also remove the last newline since WRMSG does that for us. */
; 315  : 
; 316  :     *(dumpbuf + strlen( dumpbuf ) - 1) = 0; /* (remove last newline) */

  003e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  003e6	e8 00 00 00 00	 call	 strlen
  003eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  003f0	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 317  : 
; 318  :     if (vra)

  003f5	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  003fd	85 c0		 test	 eax, eax
  003ff	74 6c		 je	 SHORT $LN8@z900_dump_

; 319  :         WRMSG( HHC02290, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  00401	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msgnum$[rsp]
  00406	e8 00 00 00 00	 call	 strlen
  0040b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  00410	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00415	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
  0041a	b9 01 00 00 00	 mov	 ecx, 1
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00425	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv202[rsp]
  0042a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0042f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194260
  00436	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194261
  00442	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00447	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00452	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194262
  00459	ba 3f 01 00 00	 mov	 edx, 319		; 0000013fH
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194263
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0046b	eb 70		 jmp	 SHORT $LN9@z900_dump_
$LN8@z900_dump_:

; 320  :     else
; 321  :         WRMSG( HHC02291, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  0046d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msgnum$[rsp]
  00472	e8 00 00 00 00	 call	 strlen
  00477	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  0047c	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00481	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  00489	b9 01 00 00 00	 mov	 ecx, 1
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00494	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv217[rsp]
  0049c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194264
  004a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194265
  004b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004be	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194266
  004cb	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  004d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194267
  004d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@z900_dump_:

; 322  : 
; 323  :     free( dumpbuf );

  004dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 324  :     return 0;

  004e8	33 c0		 xor	 eax, eax
$LN1@z900_dump_:

; 325  : 
; 326  : } /* end function dump_abs_page */

  004ea	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f2	48 33 cc	 xor	 rcx, rsp
  004f5	e8 00 00 00 00	 call	 __security_check_cookie
  004fa	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00501	c3		 ret	 0
z900_dump_abs_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
n$ = 48
tv135 = 52
stid$ = 56
raddr$ = 64
regs$ = 96
vaddr$ = 104
buf$ = 112
bufl$ = 120
ar$ = 128
acctype$ = 136
hdr$ = 144
xcode$ = 152
z900_display_virt PROC

; 188  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 189  : RADR    raddr;                          /* Real address              */
; 190  : int     n;                              /* Number of bytes in buffer */
; 191  : int     stid;                           /* Segment table indication  */
; 192  : 
; 193  :     /* Convert virtual address to real address */
; 194  :     *xcode = ARCH_DEP(virt_to_real) (&raddr, &stid,

  00018	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0001f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002d	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR ar$[rsp]
  00035	4c 8b 44 24 68	 mov	 r8, QWORD PTR vaddr$[rsp]
  0003a	48 8d 54 24 38	 lea	 rdx, QWORD PTR stid$[rsp]
  0003f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR raddr$[rsp]
  00044	e8 00 00 00 00	 call	 z900_virt_to_real
  00049	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  00051	66 89 01	 mov	 WORD PTR [rcx], ax

; 195  :                                      vaddr, ar, regs, acctype);
; 196  : 
; 197  :     if (*xcode == 0)

  00054	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  0005c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0005f	85 c0		 test	 eax, eax
  00061	0f 85 ca 00 00
	00		 jne	 $LN2@z900_displ

; 198  :     {
; 199  :         if (ar == USE_REAL_ADDR)

  00067	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  0006f	75 2f		 jne	 SHORT $LN4@z900_displ

; 200  :             n = snprintf( buf, bufl, "%sR:"F_VADR":", hdr, vaddr );

  00071	48 8b 44 24 68	 mov	 rax, QWORD PTR vaddr$[rsp]
  00076	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194200
  0008a	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  0008f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0009a	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
  0009e	eb 37		 jmp	 SHORT $LN5@z900_displ
$LN4@z900_displ:

; 201  :         else
; 202  :             n = snprintf( buf, bufl, "%sV:"F_VADR":R:"F_RADR":", hdr, vaddr, raddr );

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR raddr$[rsp]
  000a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR vaddr$[rsp]
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194201
  000c3	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  000c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000d3	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN5@z900_displ:

; 203  : 
; 204  :         n += ARCH_DEP( display_real )( regs, raddr, buf+n, bufl-n, 0, "" );

  000d7	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  000dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bufl$[rsp]
  000e1	48 2b c8	 sub	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR n$[rsp]
  000ec	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  000f1	48 03 d1	 add	 rdx, rcx
  000f4	48 8b ca	 mov	 rcx, rdx
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194202
  000fe	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00103	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0010b	4c 8b c8	 mov	 r9, rax
  0010e	4c 8b c1	 mov	 r8, rcx
  00111	48 8b 54 24 40	 mov	 rdx, QWORD PTR raddr$[rsp]
  00116	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	e8 00 00 00 00	 call	 z900_display_real
  00120	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00124	03 c8		 add	 ecx, eax
  00126	8b c1		 mov	 eax, ecx
  00128	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 205  :     }

  0012c	e9 9f 00 00 00	 jmp	 $LN3@z900_displ
$LN2@z900_displ:

; 206  :     else
; 207  :     {
; 208  :         n = snprintf (buf, bufl, "%s%c:"F_VADR":", hdr,

  00131	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  00139	75 0a		 jne	 SHORT $LN7@z900_displ
  0013b	c7 44 24 34 52
	00 00 00	 mov	 DWORD PTR tv135[rsp], 82 ; 00000052H
  00143	eb 08		 jmp	 SHORT $LN8@z900_displ
$LN7@z900_displ:
  00145	c7 44 24 34 56
	00 00 00	 mov	 DWORD PTR tv135[rsp], 86 ; 00000056H
$LN8@z900_displ:
  0014d	48 8b 44 24 68	 mov	 rax, QWORD PTR vaddr$[rsp]
  00152	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00157	8b 44 24 34	 mov	 eax, DWORD PTR tv135[rsp]
  0015b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0015f	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194203
  0016e	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  00173	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0017e	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 209  :                      ar == USE_REAL_ADDR ? 'R' : 'V', vaddr);
; 210  :         n += idx_snprintf( n, buf, bufl, " Translation exception %4.4hX (%s)",

  00182	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  0018a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0018d	8b c8		 mov	 ecx, eax
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00195	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  0019d	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194204
  001b0	4c 8b 44 24 78	 mov	 r8, QWORD PTR bufl$[rsp]
  001b5	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  001ba	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001c4	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001c8	03 c8		 add	 ecx, eax
  001ca	8b c1		 mov	 eax, ecx
  001cc	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN3@z900_displ:

; 211  :             *xcode, PIC2Name( *xcode ));
; 212  :     }
; 213  :     return n;

  001d0	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]

; 214  : 
; 215  : } /* end function display_virt */

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
z900_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
c$ = 48
n$ = 52
j$ = 56
aaddr$ = 64
i$ = 72
tv84 = 80
$T1 = 88
cbuf$ = 96
hbuf$ = 128
__$ArrayPad$ = 192
regs$ = 224
raddr$ = 232
buf$ = 240
bufl$ = 248
draflag$ = 256
hdr$ = 264
z900_display_real PROC

; 113  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 114  : RADR    aaddr;                          /* Absolute storage address  */
; 115  : int     i, j;                           /* Loop counters             */
; 116  : int     n = 0;                          /* Number of bytes in buffer */

  0002e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 117  : char    hbuf[64];                       /* Hexadecimal buffer        */
; 118  : BYTE    cbuf[17];                       /* Character buffer          */
; 119  : BYTE    c;                              /* Character work area       */
; 120  : 
; 121  : #if defined(FEATURE_INTERVAL_TIMER)
; 122  :     if(ITIMER_ACCESS(raddr,16))
; 123  :         ARCH_DEP(store_int_timer)(regs);
; 124  : #endif
; 125  : 
; 126  :     n = snprintf(buf, bufl, "%s", hdr);

  00036	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194155
  00045	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR bufl$[rsp]
  0004d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0005b	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 127  :     if (draflag)

  0005f	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR draflag$[rsp], 0
  00067	74 3a		 je	 SHORT $LN5@z900_displ

; 128  :     {
; 129  :         n += idx_snprintf( n, buf, bufl, "R:"F_RADR":", raddr);

  00069	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194157
  0007d	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00085	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0008d	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00097	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0009b	03 c8		 add	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN5@z900_displ:

; 130  :     }
; 131  : 
; 132  :     aaddr = APPLY_PREFIXING (raddr, regs->PX);

  000a3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  000ab	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000b1	48 85 c0	 test	 rax, rax
  000b4	74 2b		 je	 SHORT $LN17@z900_displ
  000b6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  000be	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  000d0	74 0f		 je	 SHORT $LN17@z900_displ
  000d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  000da	48 89 44 24 50	 mov	 QWORD PTR tv84[rsp], rax
  000df	eb 1f		 jmp	 SHORT $LN18@z900_displ
$LN17@z900_displ:
  000e1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000ed	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raddr$[rsp]
  000f5	48 33 c8	 xor	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	48 89 44 24 50	 mov	 QWORD PTR tv84[rsp], rax
$LN18@z900_displ:
  00100	48 8b 44 24 50	 mov	 rax, QWORD PTR tv84[rsp]
  00105	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 133  :     if (SIE_MODE(regs))

  0010a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00112	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00118	d1 e8		 shr	 eax, 1
  0011a	83 e0 01	 and	 eax, 1
  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 b1 00 00
	00		 je	 $LN6@z900_displ

; 134  :     {
; 135  :         if (HOSTREGS->mainlim == 0 || aaddr > HOSTREGS->mainlim)

  00125	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00134	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0013c	74 1d		 je	 SHORT $LN10@z900_displ
  0013e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00146	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014d	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00154	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  00159	76 42		 jbe	 SHORT $LN8@z900_displ
$LN10@z900_displ:

; 136  :         {
; 137  :             n += idx_snprintf( n, buf, bufl,

  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  00160	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00165	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194163
  0016c	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00174	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0017c	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00186	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0018a	03 c8		 add	 ecx, eax
  0018c	8b c1		 mov	 eax, ecx
  0018e	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 138  :                 "A:"F_RADR" Guest real address is not valid", aaddr);
; 139  :             return n;

  00192	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00196	e9 71 02 00 00	 jmp	 $LN1@z900_displ

; 140  :         }

  0019b	eb 37		 jmp	 SHORT $LN9@z900_displ
$LN8@z900_displ:

; 141  :         else
; 142  :         {
; 143  :             n += idx_snprintf( n, buf, bufl, "A:"F_RADR":", aaddr);

  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  001a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194164
  001ae	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  001b6	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001be	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001c8	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001cc	03 c8		 add	 ecx, eax
  001ce	8b c1		 mov	 eax, ecx
  001d0	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN9@z900_displ:

; 144  :         }
; 145  :     }

  001d4	eb 6a		 jmp	 SHORT $LN7@z900_displ
$LN6@z900_displ:

; 146  :     else
; 147  :     if (regs->mainlim == 0 || aaddr > regs->mainlim)

  001d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001e6	74 16		 je	 SHORT $LN12@z900_displ
  001e8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f0	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  001f7	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  001fc	76 42		 jbe	 SHORT $LN11@z900_displ
$LN12@z900_displ:

; 148  :     {
; 149  :         n += idx_snprintf( n, buf, bufl, "%s", " Real address is not valid");

  001fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194167
  00205	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194168
  00211	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00219	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00221	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0022b	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0022f	03 c8		 add	 ecx, eax
  00231	8b c1		 mov	 eax, ecx
  00233	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 150  :         return n;

  00237	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  0023b	e9 cc 01 00 00	 jmp	 $LN1@z900_displ
$LN11@z900_displ:
$LN7@z900_displ:

; 151  :     }
; 152  : 
; 153  :     /* Note: we use the internal "_get_storage_key" function here
; 154  :        so that we display the STORKEY_BADFRM bit too, if it's set.
; 155  :     */
; 156  :     n += idx_snprintf( n, buf, bufl, "K:%2.2X=", ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));

  00240	b2 04		 mov	 dl, 4
  00242	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00247	e8 00 00 00 00	 call	 z900__get_storage_key
  0024c	0f b6 c0	 movzx	 eax, al
  0024f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00253	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194169
  0025a	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00262	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0026a	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00274	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00278	03 c8		 add	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 157  : 
; 158  :     memset (hbuf, SPACE, sizeof(hbuf));

  00280	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  00288	48 8b f8	 mov	 rdi, rax
  0028b	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00290	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00295	f3 aa		 rep stosb

; 159  :     memset (cbuf, SPACE, sizeof(cbuf));

  00297	48 8d 44 24 60	 lea	 rax, QWORD PTR cbuf$[rsp]
  0029c	48 8b f8	 mov	 rdi, rax
  0029f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002a4	b9 11 00 00 00	 mov	 ecx, 17
  002a9	f3 aa		 rep stosb

; 160  : 
; 161  :     for (i = 0, j = 0; i < 16; i++)

  002ab	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002b3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  002bb	eb 0a		 jmp	 SHORT $LN4@z900_displ
$LN2@z900_displ:
  002bd	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  002c1	ff c0		 inc	 eax
  002c3	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_displ:
  002c7	83 7c 24 48 10	 cmp	 DWORD PTR i$[rsp], 16
  002cc	0f 8d f2 00 00
	00		 jge	 $LN3@z900_displ

; 162  :     {
; 163  :         c = regs->mainstor[aaddr++];

  002d2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002da	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002e6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002ea	88 44 24 30	 mov	 BYTE PTR c$[rsp], al
  002ee	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  002f3	48 ff c0	 inc	 rax
  002f6	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 164  :         j += idx_snprintf( j, hbuf, sizeof(hbuf), "%2.2X", c);

  002fb	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  00300	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00304	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194170
  0030b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00311	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00319	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00323	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  00327	03 c8		 add	 ecx, eax
  00329	8b c1		 mov	 eax, ecx
  0032b	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax

; 165  :         if ((aaddr & 0x3) == 0x0)

  0032f	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  00334	48 83 e0 03	 and	 rax, 3
  00338	48 85 c0	 test	 rax, rax
  0033b	75 3d		 jne	 SHORT $LN13@z900_displ

; 166  :         {
; 167  :             hbuf[j] = SPACE;

  0033d	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  00342	c6 84 04 80 00
	00 00 20	 mov	 BYTE PTR hbuf$[rsp+rax], 32 ; 00000020H

; 168  :             hbuf[++j] = 0;

  0034a	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  0034e	ff c0		 inc	 eax
  00350	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  00354	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  00359	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  0035e	48 83 7c 24 58
	40		 cmp	 QWORD PTR $T1[rsp], 64	; 00000040H
  00364	73 02		 jae	 SHORT $LN19@z900_displ
  00366	eb 05		 jmp	 SHORT $LN20@z900_displ
$LN19@z900_displ:
  00368	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN20@z900_displ:
  0036d	48 8b 44 24 58	 mov	 rax, QWORD PTR $T1[rsp]
  00372	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR hbuf$[rsp+rax], 0
$LN13@z900_displ:

; 169  :         }
; 170  :         c = guest_to_host(c);

  0037a	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00385	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 171  :         if (!isprint(c)) c = '.';

  00389	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0038e	8b c8		 mov	 ecx, eax
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00396	85 c0		 test	 eax, eax
  00398	75 05		 jne	 SHORT $LN14@z900_displ
  0039a	c6 44 24 30 2e	 mov	 BYTE PTR c$[rsp], 46	; 0000002eH
$LN14@z900_displ:

; 172  :         cbuf[i] = c;

  0039f	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  003a4	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  003a9	88 4c 04 60	 mov	 BYTE PTR cbuf$[rsp+rax], cl

; 173  :         if ((aaddr & PAGEFRAME_BYTEMASK) == 0x000) break;

  003ad	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  003b2	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  003b8	48 85 c0	 test	 rax, rax
  003bb	75 02		 jne	 SHORT $LN15@z900_displ
  003bd	eb 05		 jmp	 SHORT $LN3@z900_displ
$LN15@z900_displ:

; 174  :     } /* end for(i) */

  003bf	e9 f9 fe ff ff	 jmp	 $LN2@z900_displ
$LN3@z900_displ:

; 175  : 
; 176  :     n += idx_snprintf( n, buf, bufl, "%-36.36s %-16.16s", hbuf, cbuf);

  003c4	48 8d 44 24 60	 lea	 rax, QWORD PTR cbuf$[rsp]
  003c9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ce	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  003d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194174
  003e2	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  003ea	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  003f2	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  003fc	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00400	03 c8		 add	 ecx, eax
  00402	8b c1		 mov	 eax, ecx
  00404	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 177  :     return n;

  00408	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
$LN1@z900_displ:
$LN16@z900_displ:

; 178  : 
; 179  : } /* end function display_real */

  0040c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00414	48 33 cc	 xor	 rcx, rsp
  00417	e8 00 00 00 00	 call	 __security_check_cookie
  0041c	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00423	5f		 pop	 rdi
  00424	c3		 ret	 0
z900_display_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
z900__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@z900__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@z900__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@z900__get_
$LN5@z900__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@z900__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
z900__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
z900_display_pgmint_inst PROC

; 1181 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1182 :     ARCH_DEP( display_inst_adj )( iregs, inst, true );

  0000e	41 b0 01	 mov	 r8b, 1
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 z900_display_inst_adj

; 1183 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
z900_display_pgmint_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
opcode$ = 96
n$ = 100
regs$ = 104
trace2file$ = 112
addr1$ = 116
b1$ = 120
b2$ = 124
addr2$ = 128
ilc$ = 132
xcode$ = 136
relative_long_operand$1 = 140
tv136 = 144
tv138 = 148
tv145 = 152
tv181 = 156
tv232 = 160
tv233 = 164
x1$ = 168
tv846 = 172
tv847 = 176
ar$2 = 180
tv807 = 184
tv884 = 188
tv304 = 192
offset$3 = 200
$T4 = 208
len$5 = 216
$T6 = 224
tv404 = 232
tv405 = 240
$T7 = 248
$T8 = 256
$T9 = 264
len$10 = 272
$T11 = 280
tf2326$ = 288
qword$ = 400
psw_inst_msg$ = 416
op2_stor_msg$ = 576
op1_stor_msg$ = 704
buf2$ = 832
buf$ = 1344
regs_msg_buf$ = 3392
__$ArrayPad$ = 5440
iregs$ = 5472
inst$ = 5480
pgmint$ = 5488
s390_display_inst_adj PROC

; 812  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	b8 50 15 00 00	 mov	 eax, 5456		; 00001550H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 40
	15 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 813  : QWORD   qword;                          /* Doubleword work area      */
; 814  : BYTE    opcode;                         /* Instruction operation code*/
; 815  : int     ilc;                            /* Instruction length        */
; 816  : int     b1=-1, b2=-1, x1;               /* Register numbers          */

  0002f	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR b1$[rsp], -1
  00037	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR b2$[rsp], -1

; 817  : U16     xcode = 0;                      /* Exception code            */

  0003f	33 c0		 xor	 eax, eax
  00041	66 89 84 24 88
	00 00 00	 mov	 WORD PTR xcode$[rsp], ax

; 818  : VADR    addr1 = 0, addr2 = 0;           /* Operand addresses         */

  00049	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR addr1$[rsp], 0
  00051	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR addr2$[rsp], 0

; 819  : char    buf[2048];                      /* Message buffer            */
; 820  : char    buf2[512];
; 821  : int     n;                              /* Number of bytes in buffer */
; 822  : REGS*   regs;                           /* Copied regs               */
; 823  : 
; 824  : TF02326 tf2326 = {0};

  0005c	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR tf2326$[rsp]
  00064	48 8b f8	 mov	 rdi, rax
  00067	33 c0		 xor	 eax, eax
  00069	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0006e	f3 aa		 rep stosb

; 825  : bool    trace2file;
; 826  : 
; 827  : char    psw_inst_msg[160]   = {0};

  00070	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR psw_inst_msg$[rsp]
  00078	48 8b f8	 mov	 rdi, rax
  0007b	33 c0		 xor	 eax, eax
  0007d	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00082	f3 aa		 rep stosb

; 828  : char    op1_stor_msg[128]   = {0};

  00084	48 8d 84 24 c0
	02 00 00	 lea	 rax, QWORD PTR op1_stor_msg$[rsp]
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	33 c0		 xor	 eax, eax
  00091	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00096	f3 aa		 rep stosb

; 829  : char    op2_stor_msg[128]   = {0};

  00098	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR op2_stor_msg$[rsp]
  000a0	48 8b f8	 mov	 rdi, rax
  000a3	33 c0		 xor	 eax, eax
  000a5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000aa	f3 aa		 rep stosb

; 830  : char    regs_msg_buf[4*512] = {0};

  000ac	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	33 c0		 xor	 eax, eax
  000b9	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000be	f3 aa		 rep stosb
$LN4@s390_displ:

; 831  : 
; 832  :     PTT_PGM( "dinst", inst, 0, pgmint );

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ca	48 83 e0 20	 and	 rax, 32			; 00000020H
  000ce	48 85 c0	 test	 rax, rax
  000d1	74 3f		 je	 SHORT $LN20@s390_displ
  000d3	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  000db	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181059
  000f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f5	45 33 c9	 xor	 r9d, r9d
  000f8	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181060
  00107	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@s390_displ:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 a8		 jne	 SHORT $LN4@s390_displ

; 833  : 
; 834  :     OBTAIN_TRACEFILE_LOCK();

  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011f	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181061
  0012c	48 8b c8	 mov	 rcx, rax
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 835  :     {
; 836  :         trace2file = (iregs->insttrace && sysblk.traceFILE) ? true : false;

  00135	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  0013d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00143	c1 e8 0f	 shr	 eax, 15
  00146	83 e0 01	 and	 eax, 1
  00149	85 c0		 test	 eax, eax
  0014b	74 1e		 je	 SHORT $LN90@s390_displ
  0014d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00154	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0015c	74 0d		 je	 SHORT $LN90@s390_displ
  0015e	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv136[rsp], 1
  00169	eb 0b		 jmp	 SHORT $LN91@s390_displ
$LN90@s390_displ:
  0016b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
$LN91@s390_displ:
  00176	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv136[rsp], 0
  0017e	75 0d		 jne	 SHORT $LN92@s390_displ
  00180	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv138[rsp], 0
  0018b	eb 0b		 jmp	 SHORT $LN93@s390_displ
$LN92@s390_displ:
  0018d	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv138[rsp], 1
$LN93@s390_displ:
  00198	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR tv138[rsp]
  001a0	88 44 24 70	 mov	 BYTE PTR trace2file$[rsp], al

; 837  :     }
; 838  :     RELEASE_TRACEFILE_LOCK();

  001a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ab	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181062
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 839  : 
; 840  :     /* Ensure storage exists to attempt the display */
; 841  :     tf2326.valid = (iregs->mainlim != 0);

  001c1	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  001c9	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001d1	74 0d		 je	 SHORT $LN94@s390_displ
  001d3	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  001de	eb 0b		 jmp	 SHORT $LN95@s390_displ
$LN94@s390_displ:
  001e0	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN95@s390_displ:
  001eb	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  001f3	88 84 24 38 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+24], al

; 842  :     if (!tf2326.valid)

  001fa	0f b6 84 24 38
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+24]
  00202	85 c0		 test	 eax, eax
  00204	0f 85 8f 00 00
	00		 jne	 $LN21@s390_displ

; 843  :     {
; 844  :         if (trace2file)

  0020a	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  0020f	85 c0		 test	 eax, eax
  00211	74 2e		 je	 SHORT $LN22@s390_displ

; 845  :             tf_2326( iregs, &tf2326, 0,0,0,0 );

  00213	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0021b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00223	45 33 c9	 xor	 r9d, r9d
  00226	45 33 c0	 xor	 r8d, r8d
  00229	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  00231	48 8b 8c 24 60
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326
  0023f	eb 53		 jmp	 SHORT $LN23@s390_displ
$LN22@s390_displ:

; 846  :         else
; 847  :             WRMSG( HHC02267, "I", "Real address is not valid" );

  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181066
  00253	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181067
  0025f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181068
  0026b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00270	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00275	41 b9 03 00 00
	00		 mov	 r9d, 3
  0027b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181069
  00282	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181070
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@s390_displ:

; 848  :         return;

  00294	e9 40 17 00 00	 jmp	 $LN1@s390_displ
$LN21@s390_displ:

; 849  :     }
; 850  : 
; 851  :     n = 0;

  00299	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 852  :     buf[0] = '\0';

  002a1	b8 01 00 00 00	 mov	 eax, 1
  002a6	48 6b c0 00	 imul	 rax, rax, 0
  002aa	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  002b2	48 81 bc 24 d0
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T4[rsp], 2048 ; 00000800H
  002be	73 02		 jae	 SHORT $LN96@s390_displ
  002c0	eb 05		 jmp	 SHORT $LN97@s390_displ
$LN96@s390_displ:
  002c2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN97@s390_displ:
  002c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  002cf	c6 84 04 40 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 853  : 
; 854  :     /* Get a working (modifiable) copy of the REGS */
; 855  :     if (iregs->ghostregs)

  002d7	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002df	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002e5	c1 e8 0d	 shr	 eax, 13
  002e8	83 e0 01	 and	 eax, 1
  002eb	85 c0		 test	 eax, eax
  002ed	74 0f		 je	 SHORT $LN24@s390_displ

; 856  :         regs = iregs;

  002ef	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002f7	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  002fc	eb 1f		 jmp	 SHORT $LN25@s390_displ
$LN24@s390_displ:

; 857  :     else if (!(regs = copy_regs( iregs )))

  002fe	48 8b 8c 24 60
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00306	e8 00 00 00 00	 call	 copy_regs
  0030b	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  00310	48 83 7c 24 68
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00316	75 05		 jne	 SHORT $LN26@s390_displ

; 858  :         return;

  00318	e9 bc 16 00 00	 jmp	 $LN1@s390_displ
$LN26@s390_displ:
$LN25@s390_displ:

; 859  : 
; 860  : #if defined( _FEATURE_SIE )
; 861  :     tf2326.sie = SIE_MODE( regs ) ? true : false;

  0031d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00328	d1 e8		 shr	 eax, 1
  0032a	83 e0 01	 and	 eax, 1
  0032d	85 c0		 test	 eax, eax
  0032f	74 0d		 je	 SHORT $LN98@s390_displ
  00331	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv181[rsp], 1
  0033c	eb 0b		 jmp	 SHORT $LN99@s390_displ
$LN98@s390_displ:
  0033e	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN99@s390_displ:
  00349	0f b6 84 24 9c
	00 00 00	 movzx	 eax, BYTE PTR tv181[rsp]
  00351	88 84 24 39 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+25], al

; 862  :     if (tf2326.sie)

  00358	0f b6 84 24 39
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+25]
  00360	85 c0		 test	 eax, eax
  00362	74 2b		 je	 SHORT $LN27@s390_displ

; 863  :         n += idx_snprintf( n, buf, sizeof( buf ), "SIE: " );

  00364	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181075
  0036b	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00371	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00379	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00383	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00387	03 c8		 add	 ecx, eax
  00389	8b c1		 mov	 eax, ecx
  0038b	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN27@s390_displ:

; 864  : #endif
; 865  : 
; 866  :     /* Exit if instruction is not valid */
; 867  :     if (!inst)

  0038f	48 83 bc 24 68
	15 00 00 00	 cmp	 QWORD PTR inst$[rsp], 0
  00398	0f 85 43 01 00
	00		 jne	 $LN28@s390_displ

; 868  :     {
; 869  :         if (trace2file)

  0039e	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  003a3	85 c0		 test	 eax, eax
  003a5	74 18		 je	 SHORT $LN29@s390_displ

; 870  :             tf_2269( regs, inst );

  003a7	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  003af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2269
  003ba	e9 1d 01 00 00	 jmp	 $LN30@s390_displ
$LN29@s390_displ:

; 871  :         else
; 872  :         {
; 873  :             size_t len;
; 874  :             MSGBUF( psw_inst_msg, "%s Instruction fetch error\n", buf );

  003bf	4c 8d 8c 24 40
	05 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  003c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181079
  003ce	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  003d3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 875  :             display_gregs( regs, regs_msg_buf, sizeof(regs_msg_buf)-1, "HHC02269I " );

  003e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181080
  003e8	41 b8 ff 07 00
	00		 mov	 r8d, 2047		; 000007ffH
  003ee	48 8d 94 24 40
	0d 00 00	 lea	 rdx, QWORD PTR regs_msg_buf$[rsp]
  003f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003fb	e8 00 00 00 00	 call	 display_gregs

; 876  :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 877  :             len = strlen( regs_msg_buf );

  00400	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  00408	e8 00 00 00 00	 call	 strlen
  0040d	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR len$5[rsp], rax

; 878  :             if (len)

  00415	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR len$5[rsp], 0
  0041e	74 38		 je	 SHORT $LN31@s390_displ

; 879  :                 regs_msg_buf[ len-1 ] = 0;

  00420	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR len$5[rsp]
  00428	48 ff c8	 dec	 rax
  0042b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  00433	48 81 bc 24 e0
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T6[rsp], 2048 ; 00000800H
  0043f	73 02		 jae	 SHORT $LN100@s390_displ
  00441	eb 05		 jmp	 SHORT $LN101@s390_displ
$LN100@s390_displ:
  00443	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN101@s390_displ:
  00448	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00450	c6 84 04 40 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN31@s390_displ:

; 880  :             // "%s%s" // (instruction fetch error + regs)
; 881  :             WRMSG( HHC02325, "E", psw_inst_msg, regs_msg_buf );

  00458	b9 01 00 00 00	 mov	 ecx, 1
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00463	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  0046b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00470	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  00478	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0047d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181082
  00484	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00489	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181083
  00490	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00495	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049a	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181084
  004a7	ba 71 03 00 00	 mov	 edx, 881		; 00000371H
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181085
  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 882  :             if (!iregs->ghostregs)

  004b9	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  004c1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  004c7	c1 e8 0d	 shr	 eax, 13
  004ca	83 e0 01	 and	 eax, 1
  004cd	85 c0		 test	 eax, eax
  004cf	75 0b		 jne	 SHORT $LN32@s390_displ

; 883  :                 free_aligned( regs );

  004d1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN32@s390_displ:
$LN30@s390_displ:

; 884  :         }
; 885  :         return;

  004dc	e9 f8 14 00 00	 jmp	 $LN1@s390_displ
$LN28@s390_displ:

; 886  :     }
; 887  : 
; 888  :     /* Save the opcode and determine the instruction length */
; 889  :     opcode = inst[0];

  004e1	b8 01 00 00 00	 mov	 eax, 1
  004e6	48 6b c0 00	 imul	 rax, rax, 0
  004ea	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  004f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004f6	88 44 24 60	 mov	 BYTE PTR opcode$[rsp], al

; 890  :     ilc = ILC( opcode );

  004fa	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  004ff	83 f8 40	 cmp	 eax, 64			; 00000040H
  00502	7d 0d		 jge	 SHORT $LN104@s390_displ
  00504	c7 84 24 a4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv233[rsp], 2
  0050f	eb 32		 jmp	 SHORT $LN105@s390_displ
$LN104@s390_displ:
  00511	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00516	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0051b	7d 0d		 jge	 SHORT $LN102@s390_displ
  0051d	c7 84 24 a0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv232[rsp], 4
  00528	eb 0b		 jmp	 SHORT $LN103@s390_displ
$LN102@s390_displ:
  0052a	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv232[rsp], 6
$LN103@s390_displ:
  00535	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv232[rsp]
  0053c	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv233[rsp], eax
$LN105@s390_displ:
  00543	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv233[rsp]
  0054a	89 84 24 84 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN7@s390_displ:

; 891  : 
; 892  :     PTT_PGM( "dinst op,ilc", opcode, ilc, pgmint );

  00551	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00558	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0055b	48 83 e0 20	 and	 rax, 32			; 00000020H
  0055f	48 85 c0	 test	 rax, rax
  00562	74 47		 je	 SHORT $LN33@s390_displ
  00564	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  0056c	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR ilc$[rsp]
  00574	0f b6 54 24 60	 movzx	 edx, BYTE PTR opcode$[rsp]
  00579	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00582	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00587	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181088
  0058e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00593	4c 8b c9	 mov	 r9, rcx
  00596	44 8b c2	 mov	 r8d, edx
  00599	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181089
  005a0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@s390_displ:
  005ab	33 c0		 xor	 eax, eax
  005ad	85 c0		 test	 eax, eax
  005af	75 a0		 jne	 SHORT $LN7@s390_displ
$LN10@s390_displ:

; 893  : 
; 894  :     /* If we were called to display the instruction that program
; 895  :        checked, then since the "iregs" REGS value that was passed
; 896  :        to us (that we made a working copy of) was pointing PAST
; 897  :        the instruction that actually program checked (not at it),
; 898  :        we need to backup by the ilc amount so that it points at
; 899  :        the instruction that program checked, not past it.
; 900  :     */
; 901  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  005b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005bb	48 83 e0 20	 and	 rax, 32			; 00000020H
  005bf	48 85 c0	 test	 rax, rax
  005c2	74 4b		 je	 SHORT $LN34@s390_displ
  005c4	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  005cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  005d1	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  005d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005e0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181091
  005ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f1	44 8b c9	 mov	 r9d, ecx
  005f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  005f9	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  005fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181092
  00604	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00609	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_displ:
  0060f	33 c0		 xor	 eax, eax
  00611	85 c0		 test	 eax, eax
  00613	75 9c		 jne	 SHORT $LN10@s390_displ

; 902  :     if (pgmint)

  00615	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  0061d	85 c0		 test	 eax, eax
  0061f	74 5f		 je	 SHORT $LN35@s390_displ

; 903  :     {
; 904  :         regs->ip -= ilc;

  00621	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00629	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00632	48 2b c8	 sub	 rcx, rax
  00635	48 8b c1	 mov	 rax, rcx
  00638	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0063d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 905  :         regs->psw.IA = PSW_IA_FROM_IP( regs, 0 );

  00641	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00646	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0064c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00651	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00656	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0065d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00661	48 2b ca	 sub	 rcx, rdx
  00664	48 03 c1	 add	 rax, rcx
  00667	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0066c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00672	48 23 c1	 and	 rax, rcx
  00675	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0067a	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN35@s390_displ:
$LN13@s390_displ:

; 906  :     }
; 907  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  00680	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00687	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0068a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0068e	48 85 c0	 test	 rax, rax
  00691	74 4b		 je	 SHORT $LN36@s390_displ
  00693	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  0069b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  006a0	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  006a6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181095
  006bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c0	44 8b c9	 mov	 r9d, ecx
  006c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  006c8	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  006cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181096
  006d3	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@s390_displ:
  006de	33 c0		 xor	 eax, eax
  006e0	85 c0		 test	 eax, eax
  006e2	75 9c		 jne	 SHORT $LN13@s390_displ

; 908  : 
; 909  :     /* Display the PSW */
; 910  :     memset( qword, 0, sizeof( qword ));

  006e4	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR qword$[rsp]
  006ec	48 8b f8	 mov	 rdi, rax
  006ef	33 c0		 xor	 eax, eax
  006f1	b9 10 00 00 00	 mov	 ecx, 16
  006f6	f3 aa		 rep stosb

; 911  :     copy_psw( regs, qword );

  006f8	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR qword$[rsp]
  00700	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00705	e8 00 00 00 00	 call	 copy_psw

; 912  : 
; 913  :     if (!trace2file)

  0070a	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  0070f	85 c0		 test	 eax, eax
  00711	0f 85 78 03 00
	00		 jne	 $LN37@s390_displ

; 914  :     {
; 915  :         if (sysblk.cpus > 1)

  00717	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0071e	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  00725	7e 6f		 jle	 SHORT $LN38@s390_displ

; 916  :             n += idx_snprintf( n, buf, sizeof( buf ), "%s%02X: ", PTYPSTR( regs->cpuad ), regs->cpuad );

  00727	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0072c	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00733	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv304[rsp], eax
  0073a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0073f	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00746	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0074d	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00755	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0075b	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv304[rsp]
  00762	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00766	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181099
  00772	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00778	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00780	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0078a	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0078e	03 c8		 add	 ecx, eax
  00790	8b c1		 mov	 eax, ecx
  00792	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN38@s390_displ:

; 917  : 
; 918  :         n += idx_snprintf( n, buf, sizeof( buf ),

  00796	b8 01 00 00 00	 mov	 eax, 1
  0079b	48 6b c0 07	 imul	 rax, rax, 7
  0079f	0f b6 84 04 90
	01 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  007a7	b9 01 00 00 00	 mov	 ecx, 1
  007ac	48 6b c9 06	 imul	 rcx, rcx, 6
  007b0	0f b6 8c 0c 90
	01 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  007b8	ba 01 00 00 00	 mov	 edx, 1
  007bd	48 6b d2 05	 imul	 rdx, rdx, 5
  007c1	0f b6 94 14 90
	01 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  007c9	bf 01 00 00 00	 mov	 edi, 1
  007ce	48 6b ff 04	 imul	 rdi, rdi, 4
  007d2	0f b6 bc 3c 90
	01 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  007da	41 b8 01 00 00
	00		 mov	 r8d, 1
  007e0	4d 6b c0 03	 imul	 r8, r8, 3
  007e4	46 0f b6 84 04
	90 01 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  007ed	41 b9 01 00 00
	00		 mov	 r9d, 1
  007f3	4d 6b c9 02	 imul	 r9, r9, 2
  007f7	46 0f b6 8c 0c
	90 01 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  00800	41 ba 01 00 00
	00		 mov	 r10d, 1
  00806	4d 6b d2 01	 imul	 r10, r10, 1
  0080a	46 0f b6 94 14
	90 01 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  00813	41 bb 01 00 00
	00		 mov	 r11d, 1
  00819	4d 6b db 00	 imul	 r11, r11, 0
  0081d	46 0f b6 9c 1c
	90 01 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  00826	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0082a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0082e	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00832	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00836	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  0083b	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00840	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00845	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  0084a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181100
  00851	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00857	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0085f	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00863	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00869	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0086d	03 c8		 add	 ecx, eax
  0086f	8b c1		 mov	 eax, ecx
  00871	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 919  :                     "PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 920  :                     qword[0], qword[1], qword[2], qword[3],
; 921  :                     qword[4], qword[5], qword[6], qword[7] );
; 922  : 
; 923  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 924  :         n += idx_snprintf( n, buf, sizeof(buf),
; 925  :                     "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 926  :                     qword[8], qword[9], qword[10], qword[11],
; 927  :                     qword[12], qword[13], qword[14], qword[15]);
; 928  : #endif
; 929  : 
; 930  :         /* Format instruction line */
; 931  :                      n += idx_snprintf( n, buf, sizeof( buf ), "INST=%2.2X%2.2X", inst[0], inst[1] );

  00875	b8 01 00 00 00	 mov	 eax, 1
  0087a	48 6b c0 01	 imul	 rax, rax, 1
  0087e	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00886	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0088a	b9 01 00 00 00	 mov	 ecx, 1
  0088f	48 6b c9 00	 imul	 rcx, rcx, 0
  00893	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  0089b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0089f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  008a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  008a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181101
  008ae	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  008b4	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  008bc	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  008c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  008c6	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  008ca	03 c8		 add	 ecx, eax
  008cc	8b c1		 mov	 eax, ecx
  008ce	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 932  :         if (ilc > 2){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[2], inst[3] );}

  008d2	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  008da	7e 5d		 jle	 SHORT $LN39@s390_displ
  008dc	b8 01 00 00 00	 mov	 eax, 1
  008e1	48 6b c0 03	 imul	 rax, rax, 3
  008e5	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  008ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008f1	b9 01 00 00 00	 mov	 ecx, 1
  008f6	48 6b c9 02	 imul	 rcx, rcx, 2
  008fa	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00902	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00906	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0090a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0090e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181103
  00915	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0091b	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00923	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00927	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0092d	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00931	03 c8		 add	 ecx, eax
  00933	8b c1		 mov	 eax, ecx
  00935	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN39@s390_displ:

; 933  :         if (ilc > 4){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[4], inst[5] );}

  00939	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00941	7e 5d		 jle	 SHORT $LN40@s390_displ
  00943	b8 01 00 00 00	 mov	 eax, 1
  00948	48 6b c0 05	 imul	 rax, rax, 5
  0094c	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00954	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00958	b9 01 00 00 00	 mov	 ecx, 1
  0095d	48 6b c9 04	 imul	 rcx, rcx, 4
  00961	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00969	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0096d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00971	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00975	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181105
  0097c	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00982	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0098a	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0098e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00994	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00998	03 c8		 add	 ecx, eax
  0099a	8b c1		 mov	 eax, ecx
  0099c	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN40@s390_displ:

; 934  :                      n += idx_snprintf( n, buf, sizeof( buf ), " %s", (ilc < 4) ? "        " :

  009a0	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  009a8	7d 11		 jge	 SHORT $LN108@s390_displ
  009aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181106
  009b1	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv405[rsp], rax
  009b9	eb 3a		 jmp	 SHORT $LN109@s390_displ
$LN108@s390_displ:
  009bb	83 bc 24 84 00
	00 00 06	 cmp	 DWORD PTR ilc$[rsp], 6
  009c3	7d 11		 jge	 SHORT $LN106@s390_displ
  009c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181107
  009cc	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
  009d4	eb 0f		 jmp	 SHORT $LN107@s390_displ
$LN106@s390_displ:
  009d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181108
  009dd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN107@s390_displ:
  009e5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  009ed	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv405[rsp], rax
$LN109@s390_displ:
  009f5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv405[rsp]
  009fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a02	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181109
  00a09	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00a0f	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00a17	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00a21	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a25	03 c8		 add	 ecx, eax
  00a27	8b c1		 mov	 eax, ecx
  00a29	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 935  :                                                                       (ilc < 6) ? "    " : "" );
; 936  :         n += PRINT_INST( regs->arch_mode, inst, buf + n );

  00a2d	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  00a32	48 8d 84 04 40
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00a3a	4c 8b c8	 mov	 r9, rax
  00a3d	45 33 c0	 xor	 r8d, r8d
  00a40	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00a48	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00a4d	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  00a50	e8 00 00 00 00	 call	 iprint_router_func
  00a55	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a59	03 c8		 add	 ecx, eax
  00a5b	8b c1		 mov	 eax, ecx
  00a5d	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 937  :         MSGBUF( psw_inst_msg, MSG( HHC02324, "I", buf ));

  00a61	48 8d 84 24 40
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00a69	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a6e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181110
  00a75	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181111
  00a7c	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00a81	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  00a89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN37@s390_displ:

; 938  :     }
; 939  : 
; 940  :     n = 0;

  00a8f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 941  :     buf[0] = '\0';

  00a97	b8 01 00 00 00	 mov	 eax, 1
  00a9c	48 6b c0 00	 imul	 rax, rax, 0
  00aa0	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR $T7[rsp], rax
  00aa8	48 81 bc 24 f8
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T7[rsp], 2048 ; 00000800H
  00ab4	73 02		 jae	 SHORT $LN110@s390_displ
  00ab6	eb 05		 jmp	 SHORT $LN111@s390_displ
$LN110@s390_displ:
  00ab8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN111@s390_displ:
  00abd	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  00ac5	c6 84 04 40 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 942  : 
; 943  :     /* Process the first storage operand */
; 944  :     if (1
; 945  :         && ilc > 2
; 946  :         && opcode != 0x84   // BRXH
; 947  :         && opcode != 0x85   // BRXLE
; 948  :         && opcode != 0xA5   // RI-x     (relative)
; 949  :         && opcode != 0xA7   // RI-x     (relative)
; 950  :         && opcode != 0xB3   // RRE/RRF
; 951  :         && opcode != 0xC0   // RIL-x    (relative)
; 952  :         && opcode != 0xC4   // RIL-x    (relative)
; 953  :         && opcode != 0xC6   // RIL-x    (relative)
; 954  :         && opcode != 0xEC   // RIE-x

  00acd	33 c0		 xor	 eax, eax
  00acf	83 f8 01	 cmp	 eax, 1
  00ad2	0f 84 c9 01 00
	00		 je	 $LN41@s390_displ
  00ad8	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  00ae0	0f 8e bb 01 00
	00		 jle	 $LN41@s390_displ
  00ae6	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00aeb	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  00af0	0f 84 ab 01 00
	00		 je	 $LN41@s390_displ
  00af6	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00afb	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00b00	0f 84 9b 01 00
	00		 je	 $LN41@s390_displ
  00b06	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b0b	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  00b10	0f 84 8b 01 00
	00		 je	 $LN41@s390_displ
  00b16	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b1b	3d a7 00 00 00	 cmp	 eax, 167		; 000000a7H
  00b20	0f 84 7b 01 00
	00		 je	 $LN41@s390_displ
  00b26	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b2b	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00b30	0f 84 6b 01 00
	00		 je	 $LN41@s390_displ
  00b36	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b3b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00b40	0f 84 5b 01 00
	00		 je	 $LN41@s390_displ
  00b46	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b4b	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00b50	0f 84 4b 01 00
	00		 je	 $LN41@s390_displ
  00b56	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b5b	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00b60	0f 84 3b 01 00
	00		 je	 $LN41@s390_displ
  00b66	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b6b	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00b70	0f 84 2b 01 00
	00		 je	 $LN41@s390_displ

; 955  :     )
; 956  :     {
; 957  :         /* Calculate the effective address of the first operand */
; 958  :         b1 = inst[2] >> 4;

  00b76	b8 01 00 00 00	 mov	 eax, 1
  00b7b	48 6b c0 02	 imul	 rax, rax, 2
  00b7f	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00b87	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b8b	c1 f8 04	 sar	 eax, 4
  00b8e	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax

; 959  :         addr1 = ((inst[2] & 0x0F) << 8) | inst[3];

  00b92	b8 01 00 00 00	 mov	 eax, 1
  00b97	48 6b c0 02	 imul	 rax, rax, 2
  00b9b	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ba3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ba7	83 e0 0f	 and	 eax, 15
  00baa	c1 e0 08	 shl	 eax, 8
  00bad	b9 01 00 00 00	 mov	 ecx, 1
  00bb2	48 6b c9 03	 imul	 rcx, rcx, 3
  00bb6	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00bbe	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00bc2	0b c1		 or	 eax, ecx
  00bc4	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 960  :         if (b1 != 0)

  00bc8	83 7c 24 78 00	 cmp	 DWORD PTR b1$[rsp], 0
  00bcd	74 34		 je	 SHORT $LN42@s390_displ

; 961  :         {
; 962  :             addr1 += regs->GR( b1 );

  00bcf	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00bd4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00be0	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00be4	03 c8		 add	 ecx, eax
  00be6	8b c1		 mov	 eax, ecx
  00be8	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 963  :             addr1 &= ADDRESS_MAXWRAP( regs );

  00bec	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00bf1	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00bf7	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00bfb	23 c8		 and	 ecx, eax
  00bfd	8b c1		 mov	 eax, ecx
  00bff	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN42@s390_displ:

; 964  :         }
; 965  : 
; 966  :         /* Apply indexing for RX/RXE/RXF instructions */
; 967  :         if (0
; 968  :             || (opcode >= 0x40 && opcode <= 0x7F)
; 969  :             ||  opcode == 0xB1   // LRA
; 970  :             ||  opcode == 0xE3   // RXY-x
; 971  :             ||  opcode == 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00c03	33 c0		 xor	 eax, eax
  00c05	85 c0		 test	 eax, eax
  00c07	75 38		 jne	 SHORT $LN44@s390_displ
  00c09	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c0e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00c11	7c 0a		 jl	 SHORT $LN45@s390_displ
  00c13	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c18	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00c1b	7e 24		 jle	 SHORT $LN44@s390_displ
$LN45@s390_displ:
  00c1d	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c22	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00c27	74 18		 je	 SHORT $LN44@s390_displ
  00c29	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c2e	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00c33	74 0c		 je	 SHORT $LN44@s390_displ
  00c35	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c3a	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00c3f	75 60		 jne	 SHORT $LN43@s390_displ
$LN44@s390_displ:

; 972  :         )
; 973  :         {
; 974  :             x1 = inst[1] & 0x0F;

  00c41	b8 01 00 00 00	 mov	 eax, 1
  00c46	48 6b c0 01	 imul	 rax, rax, 1
  00c4a	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00c52	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c56	83 e0 0f	 and	 eax, 15
  00c59	89 84 24 a8 00
	00 00		 mov	 DWORD PTR x1$[rsp], eax

; 975  :             if (x1 != 0)

  00c60	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR x1$[rsp], 0
  00c68	74 37		 je	 SHORT $LN46@s390_displ

; 976  :             {
; 977  :                 addr1 += regs->GR( x1 );

  00c6a	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR x1$[rsp]
  00c72	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00c77	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00c7e	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00c82	03 c8		 add	 ecx, eax
  00c84	8b c1		 mov	 eax, ecx
  00c86	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 978  :                 addr1 &= ADDRESS_MAXWRAP( regs );

  00c8a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00c8f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00c95	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00c99	23 c8		 and	 ecx, eax
  00c9b	8b c1		 mov	 eax, ecx
  00c9d	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN46@s390_displ:
$LN43@s390_displ:
$LN41@s390_displ:

; 979  :             }
; 980  :         }
; 981  :     }
; 982  : 
; 983  :     /* Process the second storage operand */
; 984  :     if (1
; 985  :         && ilc > 4
; 986  :         && opcode != 0xC0   // RIL-x    (relative)
; 987  :         && opcode != 0xC4   // RIL-x    (relative)
; 988  :         && opcode != 0xC6   // RIL-x    (relative)
; 989  :         && opcode != 0xE3   // RXY-x
; 990  :         && opcode != 0xEB   // RSY-x, SIY-x
; 991  :         && opcode != 0xEC   // RIE-x
; 992  :         && opcode != 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00ca1	33 c0		 xor	 eax, eax
  00ca3	83 f8 01	 cmp	 eax, 1
  00ca6	0f 84 1a 01 00
	00		 je	 $LN47@s390_displ
  00cac	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00cb4	0f 8e 0c 01 00
	00		 jle	 $LN47@s390_displ
  00cba	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cbf	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00cc4	0f 84 fc 00 00
	00		 je	 $LN47@s390_displ
  00cca	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ccf	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00cd4	0f 84 ec 00 00
	00		 je	 $LN47@s390_displ
  00cda	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cdf	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00ce4	0f 84 dc 00 00
	00		 je	 $LN47@s390_displ
  00cea	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cef	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00cf4	0f 84 cc 00 00
	00		 je	 $LN47@s390_displ
  00cfa	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cff	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00d04	0f 84 bc 00 00
	00		 je	 $LN47@s390_displ
  00d0a	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d0f	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00d14	0f 84 ac 00 00
	00		 je	 $LN47@s390_displ
  00d1a	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d1f	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00d24	0f 84 9c 00 00
	00		 je	 $LN47@s390_displ

; 993  :     )
; 994  :     {
; 995  :         /* Calculate the effective address of the second operand */
; 996  :         b2 = inst[4] >> 4;

  00d2a	b8 01 00 00 00	 mov	 eax, 1
  00d2f	48 6b c0 04	 imul	 rax, rax, 4
  00d33	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00d3b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d3f	c1 f8 04	 sar	 eax, 4
  00d42	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax

; 997  :         addr2 = ((inst[4] & 0x0F) << 8) | inst[5];

  00d46	b8 01 00 00 00	 mov	 eax, 1
  00d4b	48 6b c0 04	 imul	 rax, rax, 4
  00d4f	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00d57	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d5b	83 e0 0f	 and	 eax, 15
  00d5e	c1 e0 08	 shl	 eax, 8
  00d61	b9 01 00 00 00	 mov	 ecx, 1
  00d66	48 6b c9 05	 imul	 rcx, rcx, 5
  00d6a	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00d72	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d76	0b c1		 or	 eax, ecx
  00d78	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax

; 998  :         if (b2 != 0)

  00d7f	83 7c 24 7c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00d84	74 40		 je	 SHORT $LN48@s390_displ

; 999  :         {
; 1000 :             addr2 += regs->GR( b2 );

  00d86	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00d8b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00d90	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00d97	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  00d9e	03 c8		 add	 ecx, eax
  00da0	8b c1		 mov	 eax, ecx
  00da2	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax

; 1001 :             addr2 &= ADDRESS_MAXWRAP( regs );

  00da9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00dae	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00db4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  00dbb	23 c8		 and	 ecx, eax
  00dbd	8b c1		 mov	 eax, ecx
  00dbf	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN48@s390_displ:
$LN47@s390_displ:

; 1002 :         }
; 1003 :     }
; 1004 : 
; 1005 :     /* Calculate the operand addresses for MVCL(E) and CLCL(E) */
; 1006 :     if (0
; 1007 :         || opcode == 0x0E   // MVCL
; 1008 :         || opcode == 0x0F   // CLCL
; 1009 :         || opcode == 0xA8   // MVCLE
; 1010 :         || opcode == 0xA9   // CLCLE

  00dc6	33 c0		 xor	 eax, eax
  00dc8	85 c0		 test	 eax, eax
  00dca	75 2c		 jne	 SHORT $LN50@s390_displ
  00dcc	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00dd1	83 f8 0e	 cmp	 eax, 14
  00dd4	74 22		 je	 SHORT $LN50@s390_displ
  00dd6	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ddb	83 f8 0f	 cmp	 eax, 15
  00dde	74 18		 je	 SHORT $LN50@s390_displ
  00de0	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00de5	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  00dea	74 0c		 je	 SHORT $LN50@s390_displ
  00dec	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00df1	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  00df6	75 7f		 jne	 SHORT $LN49@s390_displ
$LN50@s390_displ:

; 1011 :     )
; 1012 :     {
; 1013 :         b1 = inst[1] >> 4;   addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  00df8	b8 01 00 00 00	 mov	 eax, 1
  00dfd	48 6b c0 01	 imul	 rax, rax, 1
  00e01	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e09	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e0d	c1 f8 04	 sar	 eax, 4
  00e10	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax
  00e14	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00e19	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00e1e	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00e23	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00e29	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00e30	23 c2		 and	 eax, edx
  00e32	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1014 :         b2 = inst[1] & 0x0F; addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  00e36	b8 01 00 00 00	 mov	 eax, 1
  00e3b	48 6b c0 01	 imul	 rax, rax, 1
  00e3f	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e47	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e4b	83 e0 0f	 and	 eax, 15
  00e4e	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax
  00e52	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00e57	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00e5c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00e61	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00e67	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00e6e	23 c2		 and	 eax, edx
  00e70	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN49@s390_displ:

; 1015 :     }
; 1016 : 
; 1017 :     /* Calculate the operand addresses for RRE instructions */
; 1018 :     if (0
; 1019 :         || (opcode == 0xB2 &&
; 1020 :             (0
; 1021 :              || (inst[1] >= 0x20 && inst[1] <= 0x2F)
; 1022 :              || (inst[1] >= 0x40 && inst[1] <= 0x6F)
; 1023 :              || (inst[1] >= 0xA0 && inst[1] <= 0xAF)
; 1024 :             )
; 1025 :            )
; 1026 :         || (opcode == 0xB9 &&

  00e77	33 c0		 xor	 eax, eax
  00e79	85 c0		 test	 eax, eax
  00e7b	0f 85 2a 01 00
	00		 jne	 $LN52@s390_displ
  00e81	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e86	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00e8b	0f 85 b2 00 00
	00		 jne	 $LN53@s390_displ
  00e91	33 c0		 xor	 eax, eax
  00e93	85 c0		 test	 eax, eax
  00e95	0f 85 10 01 00
	00		 jne	 $LN52@s390_displ
  00e9b	b8 01 00 00 00	 mov	 eax, 1
  00ea0	48 6b c0 01	 imul	 rax, rax, 1
  00ea4	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00eac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00eb0	83 f8 20	 cmp	 eax, 32			; 00000020H
  00eb3	7c 1e		 jl	 SHORT $LN54@s390_displ
  00eb5	b8 01 00 00 00	 mov	 eax, 1
  00eba	48 6b c0 01	 imul	 rax, rax, 1
  00ebe	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ec6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00eca	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00ecd	0f 8e d8 00 00
	00		 jle	 $LN52@s390_displ
$LN54@s390_displ:
  00ed3	b8 01 00 00 00	 mov	 eax, 1
  00ed8	48 6b c0 01	 imul	 rax, rax, 1
  00edc	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ee4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ee8	83 f8 40	 cmp	 eax, 64			; 00000040H
  00eeb	7c 1e		 jl	 SHORT $LN55@s390_displ
  00eed	b8 01 00 00 00	 mov	 eax, 1
  00ef2	48 6b c0 01	 imul	 rax, rax, 1
  00ef6	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00efe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f02	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00f05	0f 8e a0 00 00
	00		 jle	 $LN52@s390_displ
$LN55@s390_displ:
  00f0b	b8 01 00 00 00	 mov	 eax, 1
  00f10	48 6b c0 01	 imul	 rax, rax, 1
  00f14	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f1c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f20	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00f25	7c 1c		 jl	 SHORT $LN56@s390_displ
  00f27	b8 01 00 00 00	 mov	 eax, 1
  00f2c	48 6b c0 01	 imul	 rax, rax, 1
  00f30	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f38	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f3c	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  00f41	7e 68		 jle	 SHORT $LN52@s390_displ
$LN56@s390_displ:
$LN53@s390_displ:
  00f43	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00f48	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00f4d	0f 85 32 01 00
	00		 jne	 $LN51@s390_displ
  00f53	33 c0		 xor	 eax, eax
  00f55	85 c0		 test	 eax, eax
  00f57	75 52		 jne	 SHORT $LN57@s390_displ
  00f59	b8 01 00 00 00	 mov	 eax, 1
  00f5e	48 6b c0 01	 imul	 rax, rax, 1
  00f62	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f6a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f6e	83 f8 05	 cmp	 eax, 5
  00f71	74 38		 je	 SHORT $LN57@s390_displ
  00f73	b8 01 00 00 00	 mov	 eax, 1
  00f78	48 6b c0 01	 imul	 rax, rax, 1
  00f7c	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f84	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f88	83 f8 25	 cmp	 eax, 37			; 00000025H
  00f8b	74 1e		 je	 SHORT $LN57@s390_displ
  00f8d	b8 01 00 00 00	 mov	 eax, 1
  00f92	48 6b c0 01	 imul	 rax, rax, 1
  00f96	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f9e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fa2	83 f8 31	 cmp	 eax, 49			; 00000031H
  00fa5	0f 8c da 00 00
	00		 jl	 $LN51@s390_displ
$LN57@s390_displ:
$LN52@s390_displ:

; 1027 :             (0
; 1028 :              || (inst[1] == 0x05)   // LURAG
; 1029 :              || (inst[1] == 0x25)   // STURG
; 1030 :              || (inst[1] >= 0x31)   // CLGFR
; 1031 :             )
; 1032 :            )
; 1033 :     )
; 1034 :     {
; 1035 :         b1 = inst[3] >> 4;

  00fab	b8 01 00 00 00	 mov	 eax, 1
  00fb0	48 6b c0 03	 imul	 rax, rax, 3
  00fb4	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00fbc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fc0	c1 f8 04	 sar	 eax, 4
  00fc3	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax

; 1036 :         addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  00fc7	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00fcc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00fd6	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00fdc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00fe3	23 c2		 and	 eax, edx
  00fe5	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1037 :         b2 = inst[3] & 0x0F;

  00fe9	b8 01 00 00 00	 mov	 eax, 1
  00fee	48 6b c0 03	 imul	 rax, rax, 3
  00ff2	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ffa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ffe	83 e0 0f	 and	 eax, 15
  01001	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax

; 1038 :         if (inst[1] >= 0x29 && inst[1] <= 0x2C)

  01005	b8 01 00 00 00	 mov	 eax, 1
  0100a	48 6b c0 01	 imul	 rax, rax, 1
  0100e	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01016	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0101a	83 f8 29	 cmp	 eax, 41			; 00000029H
  0101d	7c 41		 jl	 SHORT $LN58@s390_displ
  0101f	b8 01 00 00 00	 mov	 eax, 1
  01024	48 6b c0 01	 imul	 rax, rax, 1
  01028	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01034	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  01037	7f 27		 jg	 SHORT $LN58@s390_displ

; 1039 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP_E( regs );

  01039	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0103e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01043	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  01048	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0104e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  01055	23 c2		 and	 eax, edx
  01057	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
  0105e	eb 25		 jmp	 SHORT $LN59@s390_displ
$LN58@s390_displ:

; 1040 :         else
; 1041 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  01060	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  01065	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0106a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0106f	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  01075	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0107c	23 c2		 and	 eax, edx
  0107e	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN59@s390_displ:
$LN51@s390_displ:

; 1042 :     }
; 1043 : 
; 1044 :     /* Calculate the operand address for RIL-x (relative) instructions */
; 1045 :     if (0
; 1046 :         || (opcode == 0xC0 &&
; 1047 :             (0
; 1048 :              || (inst[1] & 0x0F) == 0x00    // LARL   (relative)
; 1049 :              || (inst[1] & 0x0F) == 0x04    // BRCL   (relative)
; 1050 :              || (inst[1] & 0x0F) == 0x05    // BRASL  (relative)
; 1051 :             )
; 1052 :            )
; 1053 :         || opcode == 0xC4   // RIL-x  (relative)
; 1054 :         || opcode == 0xC6   // RIL-x  (relative)

  01085	33 c0		 xor	 eax, eax
  01087	85 c0		 test	 eax, eax
  01089	0f 85 84 00 00
	00		 jne	 $LN61@s390_displ
  0108f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01094	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01099	75 5c		 jne	 SHORT $LN62@s390_displ
  0109b	33 c0		 xor	 eax, eax
  0109d	85 c0		 test	 eax, eax
  0109f	75 72		 jne	 SHORT $LN61@s390_displ
  010a1	b8 01 00 00 00	 mov	 eax, 1
  010a6	48 6b c0 01	 imul	 rax, rax, 1
  010aa	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010b6	83 e0 0f	 and	 eax, 15
  010b9	85 c0		 test	 eax, eax
  010bb	74 56		 je	 SHORT $LN61@s390_displ
  010bd	b8 01 00 00 00	 mov	 eax, 1
  010c2	48 6b c0 01	 imul	 rax, rax, 1
  010c6	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010d2	83 e0 0f	 and	 eax, 15
  010d5	83 f8 04	 cmp	 eax, 4
  010d8	74 39		 je	 SHORT $LN61@s390_displ
  010da	b8 01 00 00 00	 mov	 eax, 1
  010df	48 6b c0 01	 imul	 rax, rax, 1
  010e3	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  010eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010ef	83 e0 0f	 and	 eax, 15
  010f2	83 f8 05	 cmp	 eax, 5
  010f5	74 1c		 je	 SHORT $LN61@s390_displ
$LN62@s390_displ:
  010f7	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  010fc	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  01101	74 10		 je	 SHORT $LN61@s390_displ
  01103	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01108	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  0110d	0f 85 57 01 00
	00		 jne	 $LN60@s390_displ
$LN61@s390_displ:

; 1055 :     )
; 1056 :     {
; 1057 :         S64 offset;
; 1058 :         S32 relative_long_operand = fetch_fw( inst+2 );

  01113	48 8b 84 24 68
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0111b	48 83 c0 02	 add	 rax, 2
  0111f	48 8b c8	 mov	 rcx, rax
  01122	e8 00 00 00 00	 call	 fetch_fw_noswap
  01127	8b c8		 mov	 ecx, eax
  01129	e8 00 00 00 00	 call	 _byteswap_ulong
  0112e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR relative_long_operand$1[rsp], eax

; 1059 :         offset = 2LL * relative_long_operand;

  01135	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  0113d	48 d1 e0	 shl	 rax, 1
  01140	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR offset$3[rsp], rax

; 1060 :         addr1 = PSW_IA_FROM_IP( regs, 0 );  // (current instruction address)

  01148	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0114d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01153	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01158	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0115d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01164	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01168	48 2b ca	 sub	 rcx, rdx
  0116b	48 03 c1	 add	 rax, rcx
  0116e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01173	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01179	48 23 c1	 and	 rax, rcx
  0117c	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN16@s390_displ:

; 1061 : 
; 1062 :         PTT_PGM( "dinst rel1:", addr1, offset, relative_long_operand );

  01180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01187	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0118a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0118e	48 85 c0	 test	 rax, rax
  01191	74 43		 je	 SHORT $LN63@s390_displ
  01193	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  0119b	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  0119f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  011a8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181135
  011b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011b9	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  011c1	44 8b c1	 mov	 r8d, ecx
  011c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181136
  011cb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  011d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@s390_displ:
  011d6	33 c0		 xor	 eax, eax
  011d8	85 c0		 test	 eax, eax
  011da	75 a4		 jne	 SHORT $LN16@s390_displ

; 1063 : 
; 1064 :         addr1 += (VADR)offset;      // (plus relative offset)

  011dc	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR offset$3[rsp]
  011e3	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  011e7	03 c8		 add	 ecx, eax
  011e9	8b c1		 mov	 eax, ecx
  011eb	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1065 :         addr1 &= ADDRESS_MAXWRAP( regs );

  011ef	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  011f4	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  011fa	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  011fe	23 c8		 and	 ecx, eax
  01200	8b c1		 mov	 eax, ecx
  01202	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1066 :         b1 = 0;

  01206	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR b1$[rsp], 0
$LN19@s390_displ:

; 1067 : 
; 1068 :         PTT_PGM( "dinst rel1=", addr1, offset, relative_long_operand );

  0120e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01215	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01218	48 83 e0 20	 and	 rax, 32			; 00000020H
  0121c	48 85 c0	 test	 rax, rax
  0121f	74 43		 je	 SHORT $LN64@s390_displ
  01221	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  01229	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  0122d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01236	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0123b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181138
  01242	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01247	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  0124f	44 8b c1	 mov	 r8d, ecx
  01252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181139
  01259	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0125e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN64@s390_displ:
  01264	33 c0		 xor	 eax, eax
  01266	85 c0		 test	 eax, eax
  01268	75 a4		 jne	 SHORT $LN19@s390_displ
$LN60@s390_displ:

; 1069 :     }
; 1070 : 
; 1071 :     if (trace2file)

  0126a	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  0126f	85 c0		 test	 eax, eax
  01271	74 6f		 je	 SHORT $LN65@s390_displ

; 1072 :     {
; 1073 :         tf2326.op1.vaddr = addr1;

  01273	8b 44 24 74	 mov	 eax, DWORD PTR addr1$[rsp]
  01277	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+32], rax

; 1074 :         tf2326.op2.vaddr = addr2;

  0127f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  01286	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+72], rax

; 1075 :         tf_2326( regs, &tf2326, inst[0], inst[1], b1, b2 );

  0128e	b8 01 00 00 00	 mov	 eax, 1
  01293	48 6b c0 01	 imul	 rax, rax, 1
  01297	b9 01 00 00 00	 mov	 ecx, 1
  0129c	48 6b c9 00	 imul	 rcx, rcx, 0
  012a0	8b 54 24 7c	 mov	 edx, DWORD PTR b2$[rsp]
  012a4	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  012a8	8b 54 24 78	 mov	 edx, DWORD PTR b1$[rsp]
  012ac	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  012b0	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  012b8	44 0f b6 0c 02	 movzx	 r9d, BYTE PTR [rdx+rax]
  012bd	48 8b 84 24 68
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  012c5	44 0f b6 04 08	 movzx	 r8d, BYTE PTR [rax+rcx]
  012ca	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  012d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  012d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326

; 1076 :     }

  012dd	e9 d8 04 00 00	 jmp	 $LN66@s390_displ
$LN65@s390_displ:

; 1077 :     else
; 1078 :     {
; 1079 :         /* Format storage at first storage operand location */
; 1080 :         if (b1 >= 0)

  012e2	83 7c 24 78 00	 cmp	 DWORD PTR b1$[rsp], 0
  012e7	0f 8c 52 02 00
	00		 jl	 $LN67@s390_displ

; 1081 :         {
; 1082 :             n = 0;

  012ed	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1083 :             buf2[0] = '\0';

  012f5	b8 01 00 00 00	 mov	 eax, 1
  012fa	48 6b c0 00	 imul	 rax, rax, 0
  012fe	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR $T8[rsp], rax
  01306	48 81 bc 24 00
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T8[rsp], 512	; 00000200H
  01312	73 02		 jae	 SHORT $LN112@s390_displ
  01314	eb 05		 jmp	 SHORT $LN113@s390_displ
$LN112@s390_displ:
  01316	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN113@s390_displ:
  0131b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  01323	c6 84 04 40 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1084 : 
; 1085 : #if defined( _FEATURE_SIE )
; 1086 :             if (SIE_MODE( regs ))

  0132b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01330	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01336	d1 e8		 shr	 eax, 1
  01338	83 e0 01	 and	 eax, 1
  0133b	85 c0		 test	 eax, eax
  0133d	74 2b		 je	 SHORT $LN68@s390_displ

; 1087 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  0133f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181144
  01346	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0134c	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  01354	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0135e	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01362	03 c8		 add	 ecx, eax
  01364	8b c1		 mov	 eax, ecx
  01366	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN68@s390_displ:

; 1088 : #endif
; 1089 :             if (sysblk.cpus > 1)

  0136a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01371	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  01378	7e 6f		 jle	 SHORT $LN69@s390_displ

; 1090 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  0137a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0137f	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01386	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv807[rsp], eax
  0138d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01392	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01399	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  013a0	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  013a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  013ae	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv807[rsp]
  013b5	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  013b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181146
  013c5	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  013cb	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  013d3	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  013d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  013dd	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  013e1	03 c8		 add	 ecx, eax
  013e3	8b c1		 mov	 eax, ecx
  013e5	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN69@s390_displ:

; 1091 :                               PTYPSTR( regs->cpuad ), regs->cpuad );
; 1092 : 
; 1093 :             if (REAL_MODE( &regs->psw ))

  013e9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  013ee	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  013f2	83 e0 04	 and	 eax, 4
  013f5	85 c0		 test	 eax, eax
  013f7	75 62		 jne	 SHORT $LN70@s390_displ

; 1094 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  013f9	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  013fe	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  01403	48 2b c8	 sub	 rcx, rax
  01406	48 8b c1	 mov	 rax, rcx
  01409	48 ff c8	 dec	 rax
  0140c	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  01411	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  01419	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  01421	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  01426	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181149
  0142d	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01432	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0143a	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR [rsp+32], -2
  01442	4c 8b c8	 mov	 r9, rax
  01445	4c 8b c1	 mov	 r8, rcx
  01448	8b 54 24 74	 mov	 edx, DWORD PTR addr1$[rsp]
  0144c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01451	e8 00 00 00 00	 call	 s390_display_virt
  01456	e9 a9 00 00 00	 jmp	 $LN71@s390_displ
$LN70@s390_displ:

; 1095 :                                           USE_REAL_ADDR, ACCTYPE_HW, "", &xcode );
; 1096 :             else
; 1097 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  0145b	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01460	83 f8 44	 cmp	 eax, 68			; 00000044H
  01463	75 0d		 jne	 SHORT $LN116@s390_displ
  01465	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv847[rsp], 0
  01470	eb 32		 jmp	 SHORT $LN117@s390_displ
$LN116@s390_displ:
  01472	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01477	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  0147c	75 0d		 jne	 SHORT $LN114@s390_displ
  0147e	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv846[rsp], 0
  01489	eb 0b		 jmp	 SHORT $LN115@s390_displ
$LN114@s390_displ:
  0148b	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv846[rsp], 0
$LN115@s390_displ:
  01496	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv846[rsp]
  0149d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv847[rsp], eax
$LN117@s390_displ:
  014a4	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  014a9	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  014ae	48 2b c8	 sub	 rcx, rax
  014b1	48 8b c1	 mov	 rax, rcx
  014b4	48 ff c8	 dec	 rax
  014b7	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  014bc	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  014c4	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  014cc	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  014d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181150
  014d8	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  014dd	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR tv847[rsp]
  014e4	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  014e8	8b 54 24 78	 mov	 edx, DWORD PTR b1$[rsp]
  014ec	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  014f0	4c 8b c8	 mov	 r9, rax
  014f3	4c 8b c1	 mov	 r8, rcx
  014f6	8b 54 24 74	 mov	 edx, DWORD PTR addr1$[rsp]
  014fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  014ff	e8 00 00 00 00	 call	 s390_display_virt
$LN71@s390_displ:

; 1098 :                                           b1, (opcode == 0x44                 // EX?
; 1099 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1100 :                                  || (opcode == 0xc6 && !(inst[1] & 0x0f) &&
; 1101 :                                      FACILITY_ENABLED( 035_EXECUTE_EXTN, regs )) // EXRL?
; 1102 : #endif
; 1103 :                                                     ? ACCTYPE_HW :     // EX/EXRL
; 1104 :                                      opcode == 0xB1 ? ACCTYPE_HW :
; 1105 :                                                       ACCTYPE_HW ), "", &xcode );
; 1106 : 
; 1107 :             MSGBUF( op1_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  01504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181151
  0150b	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  01513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  01519	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0151e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181152
  01525	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181153
  0152c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01531	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  01539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN67@s390_displ:

; 1108 :         }
; 1109 : 
; 1110 :         /* Format storage at second storage operand location */
; 1111 :         if (b2 >= 0)

  0153f	83 7c 24 7c 00	 cmp	 DWORD PTR b2$[rsp], 0
  01544	0f 8c 70 02 00
	00		 jl	 $LN72@s390_displ

; 1112 :         {
; 1113 :             int ar = b2;

  0154a	8b 44 24 7c	 mov	 eax, DWORD PTR b2$[rsp]
  0154e	89 84 24 b4 00
	00 00		 mov	 DWORD PTR ar$2[rsp], eax

; 1114 :             n = 0;

  01555	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1115 :             buf2[0] = '\0';

  0155d	b8 01 00 00 00	 mov	 eax, 1
  01562	48 6b c0 00	 imul	 rax, rax, 0
  01566	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR $T9[rsp], rax
  0156e	48 81 bc 24 08
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T9[rsp], 512	; 00000200H
  0157a	73 02		 jae	 SHORT $LN118@s390_displ
  0157c	eb 05		 jmp	 SHORT $LN119@s390_displ
$LN118@s390_displ:
  0157e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN119@s390_displ:
  01583	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  0158b	c6 84 04 40 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1116 : 
; 1117 : #if defined(_FEATURE_SIE)
; 1118 :             if (SIE_MODE( regs ))

  01593	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01598	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0159e	d1 e8		 shr	 eax, 1
  015a0	83 e0 01	 and	 eax, 1
  015a3	85 c0		 test	 eax, eax
  015a5	74 2b		 je	 SHORT $LN73@s390_displ

; 1119 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  015a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181156
  015ae	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  015b4	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  015bc	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  015c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  015c6	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  015ca	03 c8		 add	 ecx, eax
  015cc	8b c1		 mov	 eax, ecx
  015ce	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN73@s390_displ:

; 1120 : #endif
; 1121 :             if (sysblk.cpus > 1)

  015d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015d9	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  015e0	7e 6f		 jle	 SHORT $LN74@s390_displ

; 1122 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  015e2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  015e7	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  015ee	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv884[rsp], eax
  015f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  015fa	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01601	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01608	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01610	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01616	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv884[rsp]
  0161d	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01621	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01626	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181158
  0162d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01633	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  0163b	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0163f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01645	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01649	03 c8		 add	 ecx, eax
  0164b	8b c1		 mov	 eax, ecx
  0164d	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN74@s390_displ:

; 1123 :                                PTYPSTR( regs->cpuad ), regs->cpuad );
; 1124 :             if (0
; 1125 :                 || REAL_MODE( &regs->psw )
; 1126 :                 || IS_REAL_ADDR_OP( opcode, inst[1] )

  01651	33 c0		 xor	 eax, eax
  01653	85 c0		 test	 eax, eax
  01655	0f 85 b6 00 00
	00		 jne	 $LN76@s390_displ
  0165b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01660	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01664	83 e0 04	 and	 eax, 4
  01667	85 c0		 test	 eax, eax
  01669	0f 84 a2 00 00
	00		 je	 $LN76@s390_displ
  0166f	33 c0		 xor	 eax, eax
  01671	85 c0		 test	 eax, eax
  01673	0f 85 98 00 00
	00		 jne	 $LN77@s390_displ
  01679	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0167e	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  01683	75 1a		 jne	 SHORT $LN78@s390_displ
  01685	b8 01 00 00 00	 mov	 eax, 1
  0168a	48 6b c0 01	 imul	 rax, rax, 1
  0168e	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01696	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0169a	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0169d	74 72		 je	 SHORT $LN77@s390_displ
$LN78@s390_displ:
  0169f	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016a4	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  016a9	75 1a		 jne	 SHORT $LN79@s390_displ
  016ab	b8 01 00 00 00	 mov	 eax, 1
  016b0	48 6b c0 01	 imul	 rax, rax, 1
  016b4	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  016bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  016c0	83 f8 46	 cmp	 eax, 70			; 00000046H
  016c3	74 4c		 je	 SHORT $LN77@s390_displ
$LN79@s390_displ:
  016c5	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016ca	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  016cf	75 1a		 jne	 SHORT $LN80@s390_displ
  016d1	b8 01 00 00 00	 mov	 eax, 1
  016d6	48 6b c0 01	 imul	 rax, rax, 1
  016da	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  016e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  016e6	83 f8 05	 cmp	 eax, 5
  016e9	74 26		 je	 SHORT $LN77@s390_displ
$LN80@s390_displ:
  016eb	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016f0	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  016f5	75 25		 jne	 SHORT $LN75@s390_displ
  016f7	b8 01 00 00 00	 mov	 eax, 1
  016fc	48 6b c0 01	 imul	 rax, rax, 1
  01700	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01708	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0170c	83 f8 25	 cmp	 eax, 37			; 00000025H
  0170f	75 0b		 jne	 SHORT $LN75@s390_displ
$LN77@s390_displ:
$LN76@s390_displ:

; 1127 :             )
; 1128 :                 ar = USE_REAL_ADDR;

  01711	c7 84 24 b4 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR ar$2[rsp], -2
$LN75@s390_displ:

; 1129 : 
; 1130 :             ARCH_DEP( display_virt )( regs, addr2, buf2+n, sizeof( buf2 )-n-1,

  0171c	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  01721	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  01726	48 2b c8	 sub	 rcx, rax
  01729	48 8b c1	 mov	 rax, rcx
  0172c	48 ff c8	 dec	 rax
  0172f	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  01734	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  0173c	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  01744	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  01749	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181165
  01750	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01755	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0175d	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR ar$2[rsp]
  01764	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01768	4c 8b c8	 mov	 r9, rax
  0176b	4c 8b c1	 mov	 r8, rcx
  0176e	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  01775	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0177a	e8 00 00 00 00	 call	 s390_display_virt

; 1131 :                                       ar, ACCTYPE_HW, "", &xcode );
; 1132 : 
; 1133 :             MSGBUF( op2_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  0177f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181166
  01786	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  0178e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  01794	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01799	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG181167
  017a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181168
  017a7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  017ac	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  017b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN72@s390_displ:
$LN66@s390_displ:

; 1134 :         }
; 1135 :     }
; 1136 : 
; 1137 :     if (trace2file)

  017ba	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  017bf	85 c0		 test	 eax, eax
  017c1	74 47		 je	 SHORT $LN81@s390_displ

; 1138 :     {
; 1139 :         display_inst_regs( true, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  017c3	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  017cb	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  017d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017d8	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  017de	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  017e6	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  017eb	b1 01		 mov	 cl, 1
  017ed	e8 00 00 00 00	 call	 display_inst_regs

; 1140 :         tf_2324( regs, inst );

  017f2	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  017fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  017ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2324

; 1141 :     }

  01805	e9 ac 01 00 00	 jmp	 $LN82@s390_displ
$LN81@s390_displ:

; 1142 :     else
; 1143 :     {
; 1144 :         /* Format registers associated with the instruction */
; 1145 :         if (!sysblk.showregsnone)

  0180a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01811	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01817	c1 e8 11	 shr	 eax, 17
  0181a	83 e0 01	 and	 eax, 1
  0181d	85 c0		 test	 eax, eax
  0181f	75 2f		 jne	 SHORT $LN83@s390_displ

; 1146 :             display_inst_regs( false, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  01821	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  01829	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  01831	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01836	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  0183c	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  01844	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  01849	33 c9		 xor	 ecx, ecx
  0184b	e8 00 00 00 00	 call	 display_inst_regs
$LN83@s390_displ:

; 1147 : 
; 1148 :         if (sysblk.showregsfirst)

  01850	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01857	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0185d	c1 e8 10	 shr	 eax, 16
  01860	83 e0 01	 and	 eax, 1
  01863	85 c0		 test	 eax, eax
  01865	74 58		 je	 SHORT $LN84@s390_displ

; 1149 :         {
; 1150 :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 1151 :             size_t len = strlen( regs_msg_buf );

  01867	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  0186f	e8 00 00 00 00	 call	 strlen
  01874	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR len$10[rsp], rax

; 1152 :             if (len)

  0187c	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR len$10[rsp], 0
  01885	74 38		 je	 SHORT $LN85@s390_displ

; 1153 :                 regs_msg_buf[ len-1 ] = 0;

  01887	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR len$10[rsp]
  0188f	48 ff c8	 dec	 rax
  01892	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR $T11[rsp], rax
  0189a	48 81 bc 24 18
	01 00 00 00 08
	00 00		 cmp	 QWORD PTR $T11[rsp], 2048 ; 00000800H
  018a6	73 02		 jae	 SHORT $LN120@s390_displ
  018a8	eb 05		 jmp	 SHORT $LN121@s390_displ
$LN120@s390_displ:
  018aa	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN121@s390_displ:
  018af	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR $T11[rsp]
  018b7	c6 84 04 40 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN85@s390_displ:
$LN84@s390_displ:

; 1154 :         }
; 1155 : 
; 1156 :         /* Now display all instruction tracing messages all at once */
; 1157 :         if (sysblk.showregsfirst)

  018bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  018c6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  018cc	c1 e8 10	 shr	 eax, 16
  018cf	83 e0 01	 and	 eax, 1
  018d2	85 c0		 test	 eax, eax
  018d4	74 71		 je	 SHORT $LN86@s390_displ

; 1158 :              LOGMSG( "%s%s%s%s", regs_msg_buf,

  018d6	b9 01 00 00 00	 mov	 ecx, 1
  018db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018e1	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  018e9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  018ee	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  018f6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  018fb	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  01903	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01908	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01910	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01915	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181176
  0191c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01921	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01926	41 b9 03 00 00
	00		 mov	 r9d, 3
  0192c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181177
  01933	ba 87 04 00 00	 mov	 edx, 1159		; 00000487H
  01938	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181178
  0193f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01945	eb 6f		 jmp	 SHORT $LN87@s390_displ
$LN86@s390_displ:

; 1159 :                                  psw_inst_msg, op1_stor_msg, op2_stor_msg );
; 1160 :         else LOGMSG( "%s%s%s%s", psw_inst_msg, op1_stor_msg, op2_stor_msg,

  01947	b9 01 00 00 00	 mov	 ecx, 1
  0194c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01952	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  0195a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0195f	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  01967	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0196c	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  01974	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01979	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  01981	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01986	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181179
  0198d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01992	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01997	41 b9 03 00 00
	00		 mov	 r9d, 3
  0199d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181180
  019a4	ba 89 04 00 00	 mov	 edx, 1161		; 00000489H
  019a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181181
  019b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN87@s390_displ:
$LN82@s390_displ:

; 1161 :                                  regs_msg_buf );
; 1162 :     }
; 1163 : 
; 1164 :     if (!iregs->ghostregs)

  019b6	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  019be	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  019c4	c1 e8 0d	 shr	 eax, 13
  019c7	83 e0 01	 and	 eax, 1
  019ca	85 c0		 test	 eax, eax
  019cc	75 0b		 jne	 SHORT $LN88@s390_displ

; 1165 :         free_aligned( regs );

  019ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  019d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN88@s390_displ:
$LN1@s390_displ:
$LN89@s390_displ:

; 1166 : 
; 1167 : } /* end function display_inst_adj */

  019d9	48 8b 8c 24 40
	15 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  019e1	48 33 cc	 xor	 rcx, rsp
  019e4	e8 00 00 00 00	 call	 __security_check_cookie
  019e9	48 81 c4 50 15
	00 00		 add	 rsp, 5456		; 00001550H
  019f0	5f		 pop	 rdi
  019f1	c3		 ret	 0
s390_display_inst_adj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 96
xcode$ = 100
arn$ = 104
addrwid$1 = 108
raddr$ = 112
vaddr$ = 120
i$ = 124
stid$ = 128
saddr$ = 136
tv89 = 144
len$ = 148
aaddr$ = 152
totamt$ = 160
tv250 = 168
eaddr$ = 176
pageamt$2 = 184
opnd$ = 192
pageadr$3 = 200
tv191 = 208
tv274 = 212
pageoff$4 = 216
tv215 = 224
tv298 = 232
maxadr$ = 240
tv187 = 248
tv270 = 256
trans$ = 264
newval$ = 280
buf$ = 320
__$ArrayPad$ = 416
regs$ = 448
argc$ = 456
argv$ = 464
cmdline$ = 472
s390_alter_display_virt PROC

; 626  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 627  : char*   opnd;                           /* range/alteration operand  */
; 628  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 629  : U64     maxadr;                         /* Highest virt storage addr */
; 630  : VADR    vaddr;                          /* Virtual storage address   */
; 631  : RADR    raddr;                          /* Real storage address      */
; 632  : RADR    aaddr;                          /* Absolute storage address  */
; 633  : int     stid;                           /* Segment table indication  */
; 634  : int     len;                            /* Number of bytes to alter  */
; 635  : int     i;                              /* Loop counter              */
; 636  : int     arn = 0;                        /* Access register number    */

  0002c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
$LN4@s390_alter:

; 637  : U16     xcode;                          /* Exception code            */
; 638  : char    trans[16];                      /* Address translation mode  */
; 639  : BYTE    newval[32];                     /* Storage alteration value  */
; 640  : char    buf[96];                        /* Message buffer            */
; 641  : char    type;                           /* optional addr-space type  */
; 642  : size_t  totamt;                         /* Total amount to be dumped */
; 643  : 
; 644  :     UNREFERENCED(cmdline);

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN4@s390_alter

; 645  : 
; 646  :     /* We require only one operand */
; 647  :     if (argc != 1)

  0003a	83 bc 24 c8 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00042	74 4c		 je	 SHORT $LN22@s390_alter

; 648  :     {
; 649  :         // "Missing or invalid argument(s)"
; 650  :         WRMSG( HHC17000, "E" );

  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180904
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180905
  00062	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00067	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180906
  00079	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180907
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :         return;

  0008b	e9 06 09 00 00	 jmp	 $LN1@s390_alter
$LN22@s390_alter:

; 652  :     }
; 653  : 
; 654  :     /* Parse optional address-space prefix */
; 655  :     opnd = argv[0];

  00090	b8 08 00 00 00	 mov	 eax, 8
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 656  :     type = toupper( *opnd );

  000ad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c0	88 44 24 60	 mov	 BYTE PTR type$[rsp], al

; 657  : 
; 658  :     if (1
; 659  :         && type != 'P'
; 660  :         && type != 'S'
; 661  :         && type != 'H'

  000c4	33 c0		 xor	 eax, eax
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	74 28		 je	 SHORT $LN23@s390_alter
  000cb	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000d0	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d3	74 1e		 je	 SHORT $LN23@s390_alter
  000d5	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000da	83 f8 53	 cmp	 eax, 83			; 00000053H
  000dd	74 14		 je	 SHORT $LN23@s390_alter
  000df	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000e4	83 f8 48	 cmp	 eax, 72			; 00000048H
  000e7	74 0a		 je	 SHORT $LN23@s390_alter

; 662  :     )
; 663  :         arn = 0;

  000e9	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
  000f1	eb 5b		 jmp	 SHORT $LN24@s390_alter
$LN23@s390_alter:

; 664  :     else
; 665  :     {
; 666  :         switch (type)

  000f3	0f b6 44 24 60	 movzx	 eax, BYTE PTR type$[rsp]
  000f8	88 84 24 90 00
	00 00		 mov	 BYTE PTR tv89[rsp], al
  000ff	80 bc 24 90 00
	00 00 48	 cmp	 BYTE PTR tv89[rsp], 72	; 00000048H
  00107	74 2a		 je	 SHORT $LN27@s390_alter
  00109	80 bc 24 90 00
	00 00 50	 cmp	 BYTE PTR tv89[rsp], 80	; 00000050H
  00111	74 0c		 je	 SHORT $LN25@s390_alter
  00113	80 bc 24 90 00
	00 00 53	 cmp	 BYTE PTR tv89[rsp], 83	; 00000053H
  0011b	74 0c		 je	 SHORT $LN26@s390_alter
  0011d	eb 1c		 jmp	 SHORT $LN5@s390_alter
$LN25@s390_alter:

; 667  :         {
; 668  :             case 'P': arn = USE_PRIMARY_SPACE;   break;

  0011f	c7 44 24 68 fd
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -3
  00127	eb 12		 jmp	 SHORT $LN5@s390_alter
$LN26@s390_alter:

; 669  :             case 'S': arn = USE_SECONDARY_SPACE; break;

  00129	c7 44 24 68 fc
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -4
  00131	eb 08		 jmp	 SHORT $LN5@s390_alter
$LN27@s390_alter:

; 670  :             case 'H': arn = USE_HOME_SPACE;      break;

  00133	c7 44 24 68 fb
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -5
$LN5@s390_alter:

; 671  :         }
; 672  :         opnd++;

  0013b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  00143	48 ff c0	 inc	 rax
  00146	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
$LN24@s390_alter:

; 673  :     }
; 674  : 
; 675  :     /* Set limit for address range */
; 676  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 677  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 678  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 679  :     maxadr = 0x7FFFFFFF;

  0014e	48 c7 84 24 f0
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 680  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 681  : 
; 682  :     /* Parse the range or alteration operand */
; 683  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  0015a	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  0016f	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR saddr$[rsp]
  00177	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  0017f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  00187	e8 00 00 00 00	 call	 parse_range
  0018c	89 84 24 94 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 684  :     if (len < 0) return;

  00193	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0019b	7d 05		 jge	 SHORT $LN28@s390_alter
  0019d	e9 f4 07 00 00	 jmp	 $LN1@s390_alter
$LN28@s390_alter:

; 685  : 
; 686  :     if (regs->mainlim == 0)

  001a2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001b2	75 61		 jne	 SHORT $LN29@s390_alter

; 687  :     {
; 688  :         // "%c:"F_RADR"  Storage address is not valid"
; 689  :         WRMSG( HHC02327, "E", 'V', saddr );

  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001cc	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180915
  001db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180916
  001e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180917
  001fe	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180918
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 690  :         return;

  00210	e9 81 07 00 00	 jmp	 $LN1@s390_alter
$LN29@s390_alter:

; 691  :     }
; 692  : 
; 693  :     /* Alter virtual storage */
; 694  :     if (len > 0
; 695  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, arn, regs, ACCTYPE_HW) == 0
; 696  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, eaddr, arn, regs, ACCTYPE_HW) == 0

  00215	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0021d	0f 8e cd 02 00
	00		 jle	 $LN30@s390_alter
  00223	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0022b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00238	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0023d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR saddr$[rsp]
  00245	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  0024d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00252	e8 00 00 00 00	 call	 s390_virt_to_real
  00257	85 c0		 test	 eax, eax
  00259	0f 85 91 02 00
	00		 jne	 $LN30@s390_alter
  0025f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00267	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  00279	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR eaddr$[rsp]
  00281	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00289	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0028e	e8 00 00 00 00	 call	 s390_virt_to_real
  00293	85 c0		 test	 eax, eax
  00295	0f 85 55 02 00
	00		 jne	 $LN30@s390_alter

; 697  :     )
; 698  :     {
; 699  :         for (i=0; i < len; i++)

  0029b	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN9@s390_alter
$LN7@s390_alter:
  002a5	8b 44 24 7c	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 7c	 mov	 DWORD PTR i$[rsp], eax
$LN9@s390_alter:
  002af	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002b6	39 44 24 7c	 cmp	 DWORD PTR i$[rsp], eax
  002ba	0f 8d 30 02 00
	00		 jge	 $LN8@s390_alter

; 700  :         {
; 701  :             /* Address of next byte */
; 702  :             vaddr = saddr + i;

  002c0	48 63 44 24 7c	 movsxd	 rax, DWORD PTR i$[rsp]
  002c5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  002cd	48 03 c8	 add	 rcx, rax
  002d0	48 8b c1	 mov	 rax, rcx
  002d3	89 44 24 78	 mov	 DWORD PTR vaddr$[rsp], eax

; 703  : 
; 704  :             /* Convert virtual address to real address */
; 705  :             xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, vaddr,

  002d7	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  002db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002e3	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002f0	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  002f5	44 8b c0	 mov	 r8d, eax
  002f8	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00300	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00305	e8 00 00 00 00	 call	 s390_virt_to_real
  0030a	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 706  :                 arn, regs, ACCTYPE_HW);
; 707  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  0030f	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  00318	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  00320	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR stid$[rsp]
  00328	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  0032c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00334	e8 00 00 00 00	 call	 s390_bldtrans

; 708  : 
; 709  :             /* Check for Translation Exception */
; 710  :             if (0 != xcode)

  00339	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  0033e	85 c0		 test	 eax, eax
  00340	0f 84 a2 00 00
	00		 je	 $LN31@s390_alter

; 711  :             {
; 712  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 713  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  00346	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  0034b	8b c8		 mov	 ecx, eax
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00353	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  0035b	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00360	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv191[rsp], ecx
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00372	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  0037a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0037f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv187[rsp]
  00387	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0038c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv191[rsp]
  00393	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00397	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0039b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0039f	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180921
  003ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180922
  003ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180923
  003d1	ba ca 02 00 00	 mov	 edx, 714		; 000002caH
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180924
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 714  :                     trans );
; 715  :                 return;

  003e3	e9 ae 05 00 00	 jmp	 $LN1@s390_alter
$LN31@s390_alter:

; 716  :             }
; 717  : 
; 718  :             /* Convert real address to absolute address */
; 719  :             aaddr = APPLY_PREFIXING (raddr, regs->PX);

  003e8	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  003ec	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003f2	48 85 c0	 test	 rax, rax
  003f5	74 29		 je	 SHORT $LN44@s390_alter
  003f7	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  003fb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00401	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00409	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0040c	48 3b c1	 cmp	 rax, rcx
  0040f	74 0f		 je	 SHORT $LN44@s390_alter
  00411	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00416	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  0041e	eb 1d		 jmp	 SHORT $LN45@s390_alter
$LN44@s390_alter:
  00420	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00428	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0042b	8b 4c 24 70	 mov	 ecx, DWORD PTR raddr$[rsp]
  0042f	33 c8		 xor	 ecx, eax
  00431	8b c1		 mov	 eax, ecx
  00433	8b c0		 mov	 eax, eax
  00435	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN45@s390_alter:
  0043d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  00445	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 720  : 
; 721  :             /* Check for addressing exception */
; 722  :             if (aaddr > regs->mainlim)

  0044d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00455	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0045c	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00464	76 5e		 jbe	 SHORT $LN32@s390_alter

; 723  :             {
; 724  :                 // "%c:"F_RADR"  Addressing exception"
; 725  :                 WRMSG( HHC02328, "E", 'R', raddr );

  00466	b9 01 00 00 00	 mov	 ecx, 1
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00471	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  00476	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0047b	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180926
  0048a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180927
  00496	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180928
  004ad	ba d5 02 00 00	 mov	 edx, 725		; 000002d5H
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180929
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 726  :                 return;

  004bf	e9 d2 04 00 00	 jmp	 $LN1@s390_alter
$LN32@s390_alter:

; 727  :             }
; 728  : 
; 729  :             /* Update absolute storage */
; 730  :             regs->mainstor[aaddr] = newval[i];

  004c4	48 63 44 24 7c	 movsxd	 rax, DWORD PTR i$[rsp]
  004c9	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d1	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  004d8	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  004e0	0f b6 84 04 18
	01 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  004e8	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 731  :         }

  004eb	e9 b5 fd ff ff	 jmp	 $LN7@s390_alter
$LN8@s390_alter:
$LN30@s390_alter:
$LN12@s390_alter:

; 732  :     }
; 733  : 
; 734  :     /* Limit the amount to be displayed to a reasonable value */
; 735  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  004f0	48 81 bc 24 b0
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  004fc	76 2e		 jbe	 SHORT $LN33@s390_alter
  004fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00506	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  0050c	48 3b 84 24 88
	00 00 00	 cmp	 rax, QWORD PTR saddr$[rsp]
  00514	76 16		 jbe	 SHORT $LN33@s390_alter
  00516	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0051e	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00524	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@s390_alter:
  0052c	33 c0		 xor	 eax, eax
  0052e	85 c0		 test	 eax, eax
  00530	75 be		 jne	 SHORT $LN12@s390_alter

; 736  : 
; 737  :     /* Display virtual storage */
; 738  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  00532	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0053a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  00542	48 2b c8	 sub	 rcx, rax
  00545	48 8b c1	 mov	 rax, rcx
  00548	48 ff c0	 inc	 rax
  0054b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  00553	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  0055c	0f 86 34 04 00
	00		 jbe	 $LN34@s390_alter

; 739  :     {
; 740  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  00562	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0056a	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00570	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 741  :         size_t  pageoff  = saddr - pageadr;

  00578	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00580	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  00588	48 2b c8	 sub	 rcx, rax
  0058b	48 8b c1	 mov	 rax, rcx
  0058e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 742  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  00596	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0059b	48 2b 84 24 d8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  005a3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 743  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  005ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b2	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  005b9	75 0d		 jne	 SHORT $LN46@s390_alter
  005bb	c7 84 24 a8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv250[rsp], 64 ; 00000040H
  005c6	eb 0b		 jmp	 SHORT $LN47@s390_alter
$LN46@s390_alter:
  005c8	c7 84 24 a8 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv250[rsp], 32 ; 00000020H
$LN47@s390_alter:
  005d3	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv250[rsp]
  005db	88 44 24 6c	 mov	 BYTE PTR addrwid$1[rsp], al
$LN13@s390_alter:

; 744  : 
; 745  :         /* Dump absolute storage one whole page at a time */
; 746  : 
; 747  :         for (;;)
; 748  :         {
; 749  :             /* Next page to be dumped */
; 750  :             vaddr = pageadr;

  005df	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR pageadr$3[rsp]
  005e6	89 44 24 78	 mov	 DWORD PTR vaddr$[rsp], eax

; 751  : 
; 752  :             /* Make sure we don't dump too much */
; 753  :             if (pageamt > totamt)

  005ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  005f2	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  005fa	76 10		 jbe	 SHORT $LN35@s390_alter

; 754  :                 pageamt = totamt;

  005fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  00604	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@s390_alter:

; 755  : 
; 756  :             /* Convert virtual address to real address */
; 757  :             xcode = ARCH_DEP( virt_to_real )( &raddr, &stid, vaddr,

  0060c	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  00610	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00618	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00625	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0062a	44 8b c0	 mov	 r8d, eax
  0062d	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00635	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0063a	e8 00 00 00 00	 call	 s390_virt_to_real
  0063f	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 758  :                 arn, regs, ACCTYPE_HW );
; 759  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  00644	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  0064d	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  00655	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR stid$[rsp]
  0065d	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00661	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	e8 00 00 00 00	 call	 s390_bldtrans

; 760  : 
; 761  :             /* Check for Translation Exception */
; 762  :             if (0 != xcode)

  0066e	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00673	85 c0		 test	 eax, eax
  00675	0f 84 a2 00 00
	00		 je	 $LN36@s390_alter

; 763  :             {
; 764  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 765  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  0067b	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00680	8b c8		 mov	 ecx, eax
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00688	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv270[rsp], rax
  00690	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00695	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv274[rsp], ecx
  0069c	b9 01 00 00 00	 mov	 ecx, 1
  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a7	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  006af	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  006bc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006c1	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  006c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006cc	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  006d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d4	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180935
  006e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180936
  006ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180937
  00706	ba fe 02 00 00	 mov	 edx, 766		; 000002feH
  0070b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180938
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 766  :                     trans );
; 767  :             }

  00718	e9 1b 02 00 00	 jmp	 $LN37@s390_alter
$LN36@s390_alter:

; 768  :             else
; 769  :             {
; 770  :                 /* Convert real address to absolute address */
; 771  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  0071d	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  00721	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00727	48 85 c0	 test	 rax, rax
  0072a	74 29		 je	 SHORT $LN48@s390_alter
  0072c	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  00730	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00736	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0073e	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00741	48 3b c1	 cmp	 rax, rcx
  00744	74 0f		 je	 SHORT $LN48@s390_alter
  00746	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  0074b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rax
  00753	eb 1d		 jmp	 SHORT $LN49@s390_alter
$LN48@s390_alter:
  00755	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00760	8b 4c 24 70	 mov	 ecx, DWORD PTR raddr$[rsp]
  00764	33 c8		 xor	 ecx, eax
  00766	8b c1		 mov	 eax, ecx
  00768	8b c0		 mov	 eax, eax
  0076a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rax
$LN49@s390_alter:
  00772	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv298[rsp]
  0077a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 772  : 
; 773  :                 /* Check for addressing exception */
; 774  :                 if (aaddr > regs->mainlim)

  00782	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078a	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00791	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00799	76 5e		 jbe	 SHORT $LN38@s390_alter

; 775  :                 {
; 776  :                     // "%c:"F_RADR"  Addressing exception"
; 777  :                     WRMSG( HHC02328, "E", 'R', raddr );

  0079b	b9 01 00 00 00	 mov	 ecx, 1
  007a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  007ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007b0	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  007b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180940
  007bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180941
  007cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  007db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180942
  007e2	ba 09 03 00 00	 mov	 edx, 777		; 00000309H
  007e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180943
  007ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 778  :                     break;  /* (no sense in continuing) */

  007f4	e9 9d 01 00 00	 jmp	 $LN14@s390_alter
$LN38@s390_alter:

; 779  :                 }
; 780  : 
; 781  :                 /* Display storage key for page and how translated. Note: we
; 782  :                    use the internal "_get_storage_key" function here so that
; 783  :                    we can display our STORKEY_BADFRM bit too, if it's set.
; 784  :                 */
; 785  :                 MSGBUF( buf, "R:"F_RADR"  K:%2.2X  %s",

  007f9	b2 04		 mov	 dl, 4
  007fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00803	e8 00 00 00 00	 call	 s390__get_storage_key
  00808	0f b6 c0	 movzx	 eax, al
  0080b	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  00813	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00818	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0081c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR raddr$[rsp]
  00821	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180944
  00828	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0082d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00835	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 786  :                     raddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ), trans );
; 787  : 
; 788  :                 WRMSG( HHC02291, "I", buf );

  0083b	b9 01 00 00 00	 mov	 ecx, 1
  00840	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00846	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0084e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00853	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180945
  0085a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0085f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180946
  00866	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0086b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00870	41 b9 03 00 00
	00		 mov	 r9d, 3
  00876	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180947
  0087d	ba 14 03 00 00	 mov	 edx, 788		; 00000314H
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180948
  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@s390_alter:

; 789  : 
; 790  :                 /* Now hexdump that absolute page */
; 791  :                 VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, vaddr,

  0088f	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  00893	0f b6 4c 24 6c	 movzx	 ecx, BYTE PTR addrwid$1[rsp]
  00898	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  0089c	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  008a1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pageamt$2[rsp]
  008a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008ae	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  008b6	44 8b c0	 mov	 r8d, eax
  008b9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  008c1	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c9	e8 00 00 00 00	 call	 s390_dump_abs_page
  008ce	85 c0		 test	 eax, eax
  008d0	74 5c		 je	 SHORT $LN39@s390_alter
$LN21@s390_alter:
  008d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180950
  008d9	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  008df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180951
  008e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180952
  008ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  008f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  008f9	85 c0		 test	 eax, eax
  008fb	74 20		 je	 SHORT $LN40@s390_alter
  008fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180954
  00904	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  0090a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180955
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180956
  00918	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@s390_alter:
  0091d	33 c0		 xor	 eax, eax
  0091f	85 c0		 test	 eax, eax
  00921	75 af		 jne	 SHORT $LN21@s390_alter
  00923	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00929	85 c0		 test	 eax, eax
  0092b	74 01		 je	 SHORT $LN41@s390_alter
  0092d	cc		 int	 3
$LN41@s390_alter:
$LN39@s390_alter:
  0092e	33 c0		 xor	 eax, eax
  00930	85 c0		 test	 eax, eax
  00932	0f 85 57 ff ff
	ff		 jne	 $LN18@s390_alter
$LN37@s390_alter:

; 792  :                     pageoff, pageamt, 0, addrwid ) == 0);
; 793  :             }
; 794  : 
; 795  :             /* Check if we're done */
; 796  :             if (!(totamt -= pageamt))

  00938	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00940	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR totamt$[rsp]
  00948	48 2b c8	 sub	 rcx, rax
  0094b	48 8b c1	 mov	 rax, rcx
  0094e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  00956	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  0095f	75 02		 jne	 SHORT $LN42@s390_alter

; 797  :                 break;

  00961	eb 33		 jmp	 SHORT $LN14@s390_alter
$LN42@s390_alter:

; 798  : 
; 799  :             /* Go on to the next page */
; 800  :             pageoff =  0; // (from now on)

  00963	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 801  :             pageamt =  PAGEFRAME_PAGESIZE;

  0096f	48 c7 84 24 b8
	00 00 00 00 10
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 4096 ; 00001000H

; 802  :             pageadr += PAGEFRAME_PAGESIZE;

  0097b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00983	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00989	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 803  :         }

  00991	e9 49 fc ff ff	 jmp	 $LN13@s390_alter
$LN14@s390_alter:
$LN34@s390_alter:
$LN1@s390_alter:

; 804  :     }
; 805  : 
; 806  : } /* end function alter_display_virt */

  00996	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0099e	48 33 cc	 xor	 rcx, rsp
  009a1	e8 00 00 00 00	 call	 __security_check_cookie
  009a6	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  009ad	c3		 ret	 0
s390_alter_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 48
regs$ = 80
arn$ = 88
stid$ = 96
trans$ = 104
size$ = 112
s390_bldtrans PROC

; 607  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 608  :     /* Build string indicating how virtual address was translated    */
; 609  : 
; 610  :     char    buf[16];  /* Caller's buffer should be at least this big */
; 611  : 
; 612  :          if (REAL_MODE( &regs->psw )) MSGBUF( buf, "%s", "(dat off)"   );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0002f	83 e0 04	 and	 eax, 4
  00032	85 c0		 test	 eax, eax
  00034	75 23		 jne	 SHORT $LN2@s390_bldtr
  00036	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180828
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180829
  00044	ba 10 00 00 00	 mov	 edx, 16
  00049	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00054	e9 91 00 00 00	 jmp	 $LN3@s390_bldtr
$LN2@s390_bldtr:

; 613  :     else if (stid == TEA_ST_PRIMARY)  MSGBUF( buf, "%s", "(primary)"   );

  00059	83 7c 24 60 00	 cmp	 DWORD PTR stid$[rsp], 0
  0005e	75 20		 jne	 SHORT $LN4@s390_bldtr
  00060	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180832
  00067	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180833
  0006e	ba 10 00 00 00	 mov	 edx, 16
  00073	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0007e	eb 6a		 jmp	 SHORT $LN5@s390_bldtr
$LN4@s390_bldtr:

; 614  :     else if (stid == TEA_ST_SECNDRY)  MSGBUF( buf, "%s", "(secondary)" );

  00080	83 7c 24 60 02	 cmp	 DWORD PTR stid$[rsp], 2
  00085	75 20		 jne	 SHORT $LN6@s390_bldtr
  00087	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180836
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180837
  00095	ba 10 00 00 00	 mov	 edx, 16
  0009a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000a5	eb 43		 jmp	 SHORT $LN7@s390_bldtr
$LN6@s390_bldtr:

; 615  :     else if (stid == TEA_ST_HOME)     MSGBUF( buf, "%s", "(home)"      );

  000a7	83 7c 24 60 03	 cmp	 DWORD PTR stid$[rsp], 3
  000ac	75 20		 jne	 SHORT $LN8@s390_bldtr
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180840
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180841
  000bc	ba 10 00 00 00	 mov	 edx, 16
  000c1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000cc	eb 1c		 jmp	 SHORT $LN9@s390_bldtr
$LN8@s390_bldtr:

; 616  :     else                              MSGBUF( buf, "(AR%2.2d)", arn    );

  000ce	44 8b 4c 24 58	 mov	 r9d, DWORD PTR arn$[rsp]
  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180842
  000da	ba 10 00 00 00	 mov	 edx, 16
  000df	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@s390_bldtr:
$LN7@s390_bldtr:
$LN5@s390_bldtr:
$LN3@s390_bldtr:

; 617  : 
; 618  :     strlcpy( trans, buf, size);

  000ea	4c 8b 44 24 70	 mov	 r8, QWORD PTR size$[rsp]
  000ef	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  000f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR trans$[rsp]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 619  : }

  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00104	48 33 cc	 xor	 rcx, rsp
  00107	e8 00 00 00 00	 call	 __security_check_cookie
  0010c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00110	c3		 ret	 0
s390_bldtrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 80
addrwid$1 = 84
raddr$ = 88
aaddr$ = 96
len$ = 104
saddr$ = 112
totamt$ = 120
tv211 = 128
pageamt$2 = 136
eaddr$ = 144
pageadr$3 = 152
tv145 = 160
pageoff$4 = 168
$T5 = 176
tv176 = 184
tv229 = 192
maxadr$ = 200
opnd$ = 208
absorr$ = 216
newval$ = 224
buf$ = 256
__$ArrayPad$ = 320
regs$ = 352
argc$ = 360
argv$ = 368
cmdline$ = 376
s390_alter_display_real_or_abs PROC

; 464  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s390_alter:

; 465  : char*   opnd;                           /* range/alteration operand  */
; 466  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 467  : U64     maxadr;                         /* Highest real storage addr */
; 468  : RADR    raddr;                          /* Real storage address      */
; 469  : RADR    aaddr;                          /* Absolute storage address  */
; 470  : size_t  totamt;                         /* Total amount to be dumped */
; 471  : int     len;                            /* Number of bytes to alter  */
; 472  : int     i;                              /* Loop counter              */
; 473  : BYTE    newval[32];                     /* Storage alteration value  */
; 474  : char    buf[64];                        /* MSGBUF work buffer        */
; 475  : char    absorr[8];                      /* Uppercase command         */
; 476  : 
; 477  :     UNREFERENCED(argc);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN4@s390_alter
$LN7@s390_alter:

; 478  :     UNREFERENCED(cmdline);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN7@s390_alter

; 479  : 
; 480  :     /* We require only one operand */
; 481  :     if (argc != 2)

  00038	83 bc 24 68 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00040	74 4c		 je	 SHORT $LN26@s390_alter

; 482  :     {
; 483  :         // "Missing or invalid argument(s)"
; 484  :         WRMSG( HHC17000, "E" );

  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180770
  00054	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180771
  00060	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180772
  00077	ba e4 01 00 00	 mov	 edx, 484		; 000001e4H
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180773
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 485  :         return;

  00089	e9 79 06 00 00	 jmp	 $LN1@s390_alter
$LN26@s390_alter:

; 486  :     }
; 487  : 
; 488  :     /* Convert command to uppercase */
; 489  :     for (i = 0; argv[0][i]; i++)

  0008e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00096	eb 0a		 jmp	 SHORT $LN10@s390_alter
$LN8@s390_alter:
  00098	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_alter:
  000a2	b8 08 00 00 00	 mov	 eax, 8
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b0	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000b8	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000bc	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000c0	85 c0		 test	 eax, eax
  000c2	74 34		 je	 SHORT $LN9@s390_alter

; 490  :         absorr[i] = toupper(argv[0][i]);

  000c4	b8 08 00 00 00	 mov	 eax, 8
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d2	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000da	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000de	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000ea	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ef	88 84 0c d8 00
	00 00		 mov	 BYTE PTR absorr$[rsp+rcx], al
  000f6	eb a0		 jmp	 SHORT $LN8@s390_alter
$LN9@s390_alter:

; 491  :     absorr[i] = 0;

  000f8	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000fd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  00105	48 83 bc 24 b0
	00 00 00 08	 cmp	 QWORD PTR $T5[rsp], 8
  0010e	73 02		 jae	 SHORT $LN44@s390_alter
  00110	eb 05		 jmp	 SHORT $LN45@s390_alter
$LN44@s390_alter:
  00112	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN45@s390_alter:
  00117	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  0011f	c6 84 04 d8 00
	00 00 00	 mov	 BYTE PTR absorr$[rsp+rax], 0

; 492  :     opnd = argv[1];

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00138	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0013c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 493  : 
; 494  :     /* Set limit for address range */
; 495  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 496  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 497  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 498  :     maxadr = 0x7FFFFFFF;

  00144	48 c7 84 24 c8
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 499  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 500  : 
; 501  :     /* Parse the range or alteration operand */
; 502  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  00150	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015d	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00165	4c 8d 44 24 70	 lea	 r8, QWORD PTR saddr$[rsp]
  0016a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00172	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  0017a	e8 00 00 00 00	 call	 parse_range
  0017f	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 503  :     if (len < 0) return;

  00183	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  00188	7d 05		 jge	 SHORT $LN27@s390_alter
  0018a	e9 78 05 00 00	 jmp	 $LN1@s390_alter
$LN27@s390_alter:

; 504  : 
; 505  :     if (regs->mainlim == 0)

  0018f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0019f	75 79		 jne	 SHORT $LN28@s390_alter

; 506  :     {
; 507  :         // "%c:"F_RADR"  Storage address is not valid"
; 508  :         WRMSG( HHC02327, "E", absorr[0], saddr );

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 00	 imul	 rax, rax, 0
  001aa	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  001b2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  001b9	b9 01 00 00 00	 mov	 ecx, 1
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ce	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180776
  001e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180777
  001ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180778
  00203	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180779
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 509  :         return;

  00215	e9 ed 04 00 00	 jmp	 $LN1@s390_alter
$LN28@s390_alter:

; 510  :     }
; 511  : 
; 512  :     /* Alter real or absolute storage */
; 513  :     if (len > 0)

  0021a	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  0021f	0f 8e 58 01 00
	00		 jle	 $LN29@s390_alter

; 514  :     {
; 515  :         for (i=0; i < len; i++)

  00225	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0022d	eb 0a		 jmp	 SHORT $LN13@s390_alter
$LN11@s390_alter:
  0022f	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN13@s390_alter:
  00239	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0023d	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00241	0f 8d 36 01 00
	00		 jge	 $LN12@s390_alter

; 516  :         {
; 517  :             /* Address of next byte */
; 518  :             raddr = saddr + i;

  00247	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0024c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00251	48 03 c8	 add	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 519  : 
; 520  :             /* Convert real address to absolute address */
; 521  :             if ('R' == absorr[0])

  0025c	b8 01 00 00 00	 mov	 eax, 1
  00261	48 6b c0 00	 imul	 rax, rax, 0
  00265	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  0026d	83 f8 52	 cmp	 eax, 82			; 00000052H
  00270	75 64		 jne	 SHORT $LN30@s390_alter

; 522  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00272	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  00276	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0027c	48 85 c0	 test	 rax, rax
  0027f	74 29		 je	 SHORT $LN46@s390_alter
  00281	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  00285	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0028b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00296	48 3b c1	 cmp	 rax, rcx
  00299	74 0f		 je	 SHORT $LN46@s390_alter
  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002a0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002a8	eb 1d		 jmp	 SHORT $LN47@s390_alter
$LN46@s390_alter:
  002aa	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002b5	8b 4c 24 58	 mov	 ecx, DWORD PTR raddr$[rsp]
  002b9	33 c8		 xor	 ecx, eax
  002bb	8b c1		 mov	 eax, ecx
  002bd	8b c0		 mov	 eax, eax
  002bf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
$LN47@s390_alter:
  002c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv176[rsp]
  002cf	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  002d4	eb 0a		 jmp	 SHORT $LN31@s390_alter
$LN30@s390_alter:

; 523  :             else
; 524  :                 aaddr = raddr; /* (is already absolute) */

  002d6	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002db	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN31@s390_alter:

; 525  : 
; 526  :             /* Check for addressing exception */
; 527  :             if (aaddr > regs->mainlim)

  002e0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002ef	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  002f4	76 5e		 jbe	 SHORT $LN32@s390_alter

; 528  :             {
; 529  :                 // "%c:"F_RADR"  Addressing exception"
; 530  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  002f6	b9 01 00 00 00	 mov	 ecx, 1
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00301	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00306	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0030b	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180784
  0031a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180785
  00326	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00330	41 b9 03 00 00
	00		 mov	 r9d, 3
  00336	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180786
  0033d	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180787
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 531  :                 return;

  0034f	e9 b3 03 00 00	 jmp	 $LN1@s390_alter
$LN32@s390_alter:

; 532  :             }
; 533  : 
; 534  :             /* Update absolute storage */
; 535  :             regs->mainstor[aaddr] = newval[i];

  00354	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00359	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00368	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0036d	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  00375	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 536  : 
; 537  :         } /* end for(i) */

  00378	e9 b2 fe ff ff	 jmp	 $LN11@s390_alter
$LN12@s390_alter:
$LN29@s390_alter:
$LN16@s390_alter:

; 538  :     }
; 539  : 
; 540  :     /* Limit the amount to be displayed to a reasonable value */
; 541  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  0037d	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  00389	76 28		 jbe	 SHORT $LN33@s390_alter
  0038b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00393	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  00399	48 3b 44 24 70	 cmp	 rax, QWORD PTR saddr$[rsp]
  0039e	76 13		 jbe	 SHORT $LN33@s390_alter
  003a0	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003a5	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  003ab	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@s390_alter:
  003b3	33 c0		 xor	 eax, eax
  003b5	85 c0		 test	 eax, eax
  003b7	75 c4		 jne	 SHORT $LN16@s390_alter

; 542  : 
; 543  :     /* Display real or absolute storage */
; 544  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  003b9	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  003c6	48 2b c8	 sub	 rcx, rax
  003c9	48 8b c1	 mov	 rax, rcx
  003cc	48 ff c0	 inc	 rax
  003cf	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  003d4	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  003da	0f 86 27 03 00
	00		 jbe	 $LN34@s390_alter

; 545  :     {
; 546  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  003e0	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003e5	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  003eb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 547  :         size_t  pageoff  = saddr - pageadr;

  003f3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  003fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00400	48 2b c8	 sub	 rcx, rax
  00403	48 8b c1	 mov	 rax, rcx
  00406	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 548  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  0040e	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00413	48 2b 84 24 a8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  0041b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 549  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  00423	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0042a	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00431	75 0d		 jne	 SHORT $LN48@s390_alter
  00433	c7 84 24 80 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv211[rsp], 64 ; 00000040H
  0043e	eb 0b		 jmp	 SHORT $LN49@s390_alter
$LN48@s390_alter:
  00440	c7 84 24 80 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv211[rsp], 32 ; 00000020H
$LN49@s390_alter:
  0044b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR tv211[rsp]
  00453	88 44 24 54	 mov	 BYTE PTR addrwid$1[rsp], al
$LN17@s390_alter:

; 550  : 
; 551  :         /* Dump absolute storage one whole page at a time */
; 552  : 
; 553  :         for (;;)
; 554  :         {
; 555  :             /* Next page to be dumped */
; 556  :             raddr = pageadr;

  00457	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  0045f	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 557  : 
; 558  :             /* Make sure we don't dump too much */
; 559  :             if (pageamt > totamt)

  00464	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  00469	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  00471	76 0d		 jbe	 SHORT $LN35@s390_alter

; 560  :                 pageamt = totamt;

  00473	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  00478	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@s390_alter:

; 561  : 
; 562  :             /* Convert real address to absolute address */
; 563  :             if ('R' == absorr[0])

  00480	b8 01 00 00 00	 mov	 eax, 1
  00485	48 6b c0 00	 imul	 rax, rax, 0
  00489	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  00491	83 f8 52	 cmp	 eax, 82			; 00000052H
  00494	75 64		 jne	 SHORT $LN36@s390_alter

; 564  :                 aaddr = APPLY_PREFIXING( raddr, regs->PX );

  00496	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  0049a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  004a0	48 85 c0	 test	 rax, rax
  004a3	74 29		 je	 SHORT $LN50@s390_alter
  004a5	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  004a9	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  004af	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b7	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  004ba	48 3b c1	 cmp	 rax, rcx
  004bd	74 0f		 je	 SHORT $LN50@s390_alter
  004bf	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004c4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  004cc	eb 1d		 jmp	 SHORT $LN51@s390_alter
$LN50@s390_alter:
  004ce	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004d9	8b 4c 24 58	 mov	 ecx, DWORD PTR raddr$[rsp]
  004dd	33 c8		 xor	 ecx, eax
  004df	8b c1		 mov	 eax, ecx
  004e1	8b c0		 mov	 eax, eax
  004e3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
$LN51@s390_alter:
  004eb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv229[rsp]
  004f3	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  004f8	eb 0a		 jmp	 SHORT $LN37@s390_alter
$LN36@s390_alter:

; 565  :             else
; 566  :                 aaddr = raddr; /* (is already absolute) */

  004fa	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004ff	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN37@s390_alter:

; 567  : 
; 568  :             /* Check for addressing exception */
; 569  :             if (aaddr > regs->mainlim)

  00504	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050c	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00513	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  00518	76 5e		 jbe	 SHORT $LN38@s390_alter

; 570  :             {
; 571  :                 // "%c:"F_RADR"  Addressing exception"
; 572  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  0051a	b9 01 00 00 00	 mov	 ecx, 1
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00525	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0052a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0052f	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  00537	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180794
  0053e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180795
  0054a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00554	41 b9 03 00 00
	00		 mov	 r9d, 3
  0055a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180796
  00561	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180797
  0056d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 573  :                 break;

  00573	e9 8f 01 00 00	 jmp	 $LN18@s390_alter
$LN38@s390_alter:

; 574  :             }
; 575  : 
; 576  :             /* Display storage key for this page. Note: we use the
; 577  :                internal "_get_storage_key" function here so that we
; 578  :                can display our STORKEY_BADFRM bit too, if it's set.
; 579  :             */
; 580  :             MSGBUF( buf, "A:"F_RADR"  K:%2.2X",

  00578	b2 04		 mov	 dl, 4
  0057a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0057f	e8 00 00 00 00	 call	 s390__get_storage_key
  00584	0f b6 c0	 movzx	 eax, al
  00587	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0058b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR aaddr$[rsp]
  00590	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180798
  00597	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0059c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 581  :                 aaddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));
; 582  :             WRMSG( HHC02290, "I", buf );

  005aa	b9 01 00 00 00	 mov	 ecx, 1
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180799
  005c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180800
  005d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005df	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180801
  005ec	ba 46 02 00 00	 mov	 edx, 582		; 00000246H
  005f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180802
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@s390_alter:

; 583  : 
; 584  :             /* Now hexdump that absolute page */
; 585  :             VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, raddr,

  005fe	b8 01 00 00 00	 mov	 eax, 1
  00603	48 6b c0 00	 imul	 rax, rax, 0
  00607	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR addrwid$1[rsp]
  0060c	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  00610	0f b6 84 04 d8
	00 00 00	 movzx	 eax, BYTE PTR absorr$[rsp+rax]
  00618	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0061c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00624	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00629	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  00631	4c 8b 44 24 58	 mov	 r8, QWORD PTR raddr$[rsp]
  00636	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0063b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00643	e8 00 00 00 00	 call	 s390_dump_abs_page
  00648	85 c0		 test	 eax, eax
  0064a	74 5c		 je	 SHORT $LN39@s390_alter
$LN25@s390_alter:
  0064c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180804
  00653	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00659	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180805
  00660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180806
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0066d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00673	85 c0		 test	 eax, eax
  00675	74 20		 je	 SHORT $LN40@s390_alter
  00677	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180808
  0067e	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00684	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180809
  0068b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180810
  00692	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@s390_alter:
  00697	33 c0		 xor	 eax, eax
  00699	85 c0		 test	 eax, eax
  0069b	75 af		 jne	 SHORT $LN25@s390_alter
  0069d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006a3	85 c0		 test	 eax, eax
  006a5	74 01		 je	 SHORT $LN41@s390_alter
  006a7	cc		 int	 3
$LN41@s390_alter:
$LN39@s390_alter:
  006a8	33 c0		 xor	 eax, eax
  006aa	85 c0		 test	 eax, eax
  006ac	0f 85 4c ff ff
	ff		 jne	 $LN22@s390_alter

; 586  :                 pageoff, pageamt, absorr[0], addrwid ) == 0);
; 587  : 
; 588  :             /* Check if we're done */
; 589  :             if (!(totamt -= pageamt))

  006b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  006ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totamt$[rsp]
  006bf	48 2b c8	 sub	 rcx, rax
  006c2	48 8b c1	 mov	 rax, rcx
  006c5	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  006ca	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  006d0	75 02		 jne	 SHORT $LN42@s390_alter

; 590  :                 break;

  006d2	eb 33		 jmp	 SHORT $LN18@s390_alter
$LN42@s390_alter:

; 591  : 
; 592  :             /* Go on to the next page */
; 593  :             pageoff =  0; // (from now on)

  006d4	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 594  :             pageamt =  PAGEFRAME_PAGESIZE;

  006e0	48 c7 84 24 88
	00 00 00 00 10
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 4096 ; 00001000H

; 595  :             pageadr += PAGEFRAME_PAGESIZE;

  006ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  006f4	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006fa	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 596  :         }

  00702	e9 50 fd ff ff	 jmp	 $LN17@s390_alter
$LN18@s390_alter:
$LN34@s390_alter:
$LN1@s390_alter:
$LN43@s390_alter:

; 597  :     }
; 598  : 
; 599  : } /* end function alter_display_real_or_abs */

  00707	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0070f	48 33 cc	 xor	 rcx, rsp
  00712	e8 00 00 00 00	 call	 __security_check_cookie
  00717	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0071e	c3		 ret	 0
s390_alter_display_real_or_abs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 64
len$ = 68
opcode$ = 72
xcode$ = 76
ilc$ = 80
stid$ = 84
saddr$ = 88
raddr$ = 96
tv95 = 104
tv223 = 108
tv224 = 112
tv264 = 116
tv265 = 120
tv266 = 124
aaddr$ = 128
opnd$ = 136
eaddr$ = 144
tv199 = 152
maxadr$ = 160
inst$ = 168
buf$ = 176
__$ArrayPad$ = 688
regs$ = 736
argc$ = 744
argv$ = 752
cmdline$ = 760
s390_disasm_stor PROC

; 333  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 334  : char*   opnd;                           /* Range/alteration operand  */
; 335  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 336  : U64     maxadr;                         /* Highest real storage addr */
; 337  : RADR    raddr;                          /* Real storage address      */
; 338  : RADR    aaddr;                          /* Absolute storage address  */
; 339  : int     stid = -1;                      /* How translation was done  */

  0002e	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR stid$[rsp], -1
$LN4@s390_disas:

; 340  : int     len;                            /* Number of bytes to alter  */
; 341  : int     ilc;                            /* Instruction length counter*/
; 342  : BYTE    inst[6];                        /* Storage alteration value  */
; 343  : BYTE    opcode;                         /* Instruction opcode        */
; 344  : U16     xcode;                          /* Exception code            */
; 345  : char    type;                           /* Address space type        */
; 346  : char    buf[512];                       /* MSGBUF work buffer        */
; 347  : 
; 348  :     UNREFERENCED(cmdline);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN4@s390_disas

; 349  : 
; 350  :     /* We require only one operand */
; 351  :     if (argc != 1)

  0003c	83 bc 24 e8 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00044	74 4c		 je	 SHORT $LN10@s390_disas

; 352  :     {
; 353  :         // "Missing or invalid argument(s)"
; 354  :         WRMSG( HHC17000, "E" );

  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180661
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180662
  00064	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180663
  0007b	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180664
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 355  :         return;

  0008d	e9 fa 06 00 00	 jmp	 $LN1@s390_disas
$LN10@s390_disas:

; 356  :     }
; 357  : 
; 358  :     /* Parse optional address-space prefix */
; 359  :     opnd = argv[0];

  00092	b8 08 00 00 00	 mov	 eax, 8
  00097	48 6b c0 00	 imul	 rax, rax, 0
  0009b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 360  :     type = toupper( *opnd );

  000af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c2	88 44 24 40	 mov	 BYTE PTR type$[rsp], al

; 361  : 
; 362  :     if (0
; 363  :         || type == 'R'
; 364  :         || type == 'V'
; 365  :         || type == 'P'
; 366  :         || type == 'H'

  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 28		 jne	 SHORT $LN13@s390_disas
  000cc	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000d1	83 f8 52	 cmp	 eax, 82			; 00000052H
  000d4	74 1e		 je	 SHORT $LN13@s390_disas
  000d6	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000db	83 f8 56	 cmp	 eax, 86			; 00000056H
  000de	74 14		 je	 SHORT $LN13@s390_disas
  000e0	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000e5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000e8	74 0a		 je	 SHORT $LN13@s390_disas
  000ea	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000ef	83 f8 48	 cmp	 eax, 72			; 00000048H
  000f2	75 15		 jne	 SHORT $LN11@s390_disas
$LN13@s390_disas:

; 367  :     )
; 368  :         opnd++;

  000f4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
  00107	eb 2e		 jmp	 SHORT $LN12@s390_disas
$LN11@s390_disas:

; 369  :     else
; 370  :         type = REAL_MODE( &regs->psw ) ? 'R' : 'V';

  00109	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00111	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00115	83 e0 04	 and	 eax, 4
  00118	85 c0		 test	 eax, eax
  0011a	75 0a		 jne	 SHORT $LN27@s390_disas
  0011c	c7 44 24 68 52
	00 00 00	 mov	 DWORD PTR tv95[rsp], 82	; 00000052H
  00124	eb 08		 jmp	 SHORT $LN28@s390_disas
$LN27@s390_disas:
  00126	c7 44 24 68 56
	00 00 00	 mov	 DWORD PTR tv95[rsp], 86	; 00000056H
$LN28@s390_disas:
  0012e	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv95[rsp]
  00133	88 44 24 40	 mov	 BYTE PTR type$[rsp], al
$LN12@s390_disas:

; 371  : 
; 372  :     /* Set limit for address range */
; 373  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 374  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 375  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 376  :     maxadr = 0x7FFFFFFF;

  00137	48 c7 84 24 a0
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 377  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 378  : 
; 379  :     /* Parse the range or alteration operand */
; 380  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, NULL);

  00143	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0014c	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00154	4c 8d 44 24 58	 lea	 r8, QWORD PTR saddr$[rsp]
  00159	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00161	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  00169	e8 00 00 00 00	 call	 parse_range
  0016e	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 381  :     if (len < 0) return;

  00172	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00177	7d 05		 jge	 SHORT $LN14@s390_disas
  00179	e9 0e 06 00 00	 jmp	 $LN1@s390_disas
$LN14@s390_disas:

; 382  : 
; 383  :     if (regs->mainlim == 0)

  0017e	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00186	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0018e	75 58		 jne	 SHORT $LN15@s390_disas

; 384  :     {
; 385  :         WRMSG(HHC02289, "I", "Real address is not valid");

  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180670
  001a2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180671
  001ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180672
  001ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180673
  001d1	ba 81 01 00 00	 mov	 edx, 385		; 00000181H
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180674
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 386  :         return;

  001e3	e9 a4 05 00 00	 jmp	 $LN1@s390_disas
$LN15@s390_disas:
$LN7@s390_disas:

; 387  :     }
; 388  : 
; 389  :     /* Limit the amount to be displayed to a reasonable value */
; 390  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  001e8	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  001f4	76 28		 jbe	 SHORT $LN16@s390_disas
  001f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  001fe	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  00204	48 3b 44 24 58	 cmp	 rax, QWORD PTR saddr$[rsp]
  00209	76 13		 jbe	 SHORT $LN16@s390_disas
  0020b	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00210	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00216	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN16@s390_disas:
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 c4		 jne	 SHORT $LN7@s390_disas
$LN8@s390_disas:

; 391  : 
; 392  :     /* Display real storage */
; 393  :     while (saddr <= eaddr)

  00224	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  0022c	48 39 44 24 58	 cmp	 QWORD PTR saddr$[rsp], rax
  00231	0f 87 55 05 00
	00		 ja	 $LN9@s390_disas

; 394  :     {
; 395  :         if(type == 'R')

  00237	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  0023c	83 f8 52	 cmp	 eax, 82			; 00000052H
  0023f	75 0f		 jne	 SHORT $LN17@s390_disas

; 396  :             raddr = saddr;

  00241	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00246	48 89 44 24 60	 mov	 QWORD PTR raddr$[rsp], rax
  0024b	e9 d1 00 00 00	 jmp	 $LN18@s390_disas
$LN17@s390_disas:

; 397  :         else
; 398  :         {
; 399  :             /* Convert virtual address to real address */
; 400  :             if((xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, 0, regs, ACCTYPE_HW) ))

  00250	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00258	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00260	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00265	45 33 c9	 xor	 r9d, r9d
  00268	4c 8b 44 24 58	 mov	 r8, QWORD PTR saddr$[rsp]
  0026d	48 8d 54 24 54	 lea	 rdx, QWORD PTR stid$[rsp]
  00272	48 8d 4c 24 60	 lea	 rcx, QWORD PTR raddr$[rsp]
  00277	e8 00 00 00 00	 call	 s390_virt_to_real
  0027c	66 89 44 24 4c	 mov	 WORD PTR xcode$[rsp], ax
  00281	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  00286	85 c0		 test	 eax, eax
  00288	0f 84 93 00 00
	00		 je	 $LN19@s390_disas

; 401  :             {
; 402  :                 MSGBUF( buf, "R:"F_RADR"  Storage not accessible code = %4.4X (%s)",

  0028e	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  00293	8b c8		 mov	 ecx, eax
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  0029b	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR xcode$[rsp]
  002a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a5	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  002a9	4c 8b 4c 24 58	 mov	 r9, QWORD PTR saddr$[rsp]
  002ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180679
  002b5	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  002ba	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 403  :                     saddr, xcode, PIC2Name( xcode ));
; 404  :                 WRMSG( HHC02289, "I", buf );

  002c8	b9 01 00 00 00	 mov	 ecx, 1
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d3	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180680
  002e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180681
  002f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00303	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180682
  0030a	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180683
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  :                 return;

  0031c	e9 6b 04 00 00	 jmp	 $LN1@s390_disas
$LN19@s390_disas:
$LN18@s390_disas:

; 406  :             }
; 407  :         }
; 408  : 
; 409  :         /* Convert real address to absolute address */
; 410  :         aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00321	8b 44 24 60	 mov	 eax, DWORD PTR raddr$[rsp]
  00325	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0032b	48 85 c0	 test	 rax, rax
  0032e	74 29		 je	 SHORT $LN29@s390_disas
  00330	8b 44 24 60	 mov	 eax, DWORD PTR raddr$[rsp]
  00334	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0033a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00342	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00345	48 3b c1	 cmp	 rax, rcx
  00348	74 0f		 je	 SHORT $LN29@s390_disas
  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR raddr$[rsp]
  0034f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv199[rsp], rax
  00357	eb 1d		 jmp	 SHORT $LN30@s390_disas
$LN29@s390_disas:
  00359	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00361	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00364	8b 4c 24 60	 mov	 ecx, DWORD PTR raddr$[rsp]
  00368	33 c8		 xor	 ecx, eax
  0036a	8b c1		 mov	 eax, ecx
  0036c	8b c0		 mov	 eax, eax
  0036e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv199[rsp], rax
$LN30@s390_disas:
  00376	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv199[rsp]
  0037e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 411  :         if (aaddr > regs->mainlim)

  00386	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038e	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00395	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  0039d	76 78		 jbe	 SHORT $LN20@s390_disas

; 412  :         {
; 413  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", raddr );

  0039f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  003a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180685
  003ab	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  003b0	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 414  :             WRMSG( HHC02289, "I", buf );

  003be	b9 01 00 00 00	 mov	 ecx, 1
  003c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003d1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180686
  003dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180687
  003e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180688
  00400	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  00405	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180689
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 415  :             return;

  00412	e9 75 03 00 00	 jmp	 $LN1@s390_disas
$LN20@s390_disas:

; 416  :         }
; 417  : 
; 418  :         /* Determine opcode and check for addressing exception */
; 419  :         opcode = regs->mainstor[aaddr];

  00417	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00426	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0042e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00432	88 44 24 48	 mov	 BYTE PTR opcode$[rsp], al

; 420  :         ilc = ILC(opcode);

  00436	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  0043b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0043e	7d 0a		 jge	 SHORT $LN33@s390_disas
  00440	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv224[rsp], 2
  00448	eb 26		 jmp	 SHORT $LN34@s390_disas
$LN33@s390_disas:
  0044a	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  0044f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00454	7d 0a		 jge	 SHORT $LN31@s390_disas
  00456	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv223[rsp], 4
  0045e	eb 08		 jmp	 SHORT $LN32@s390_disas
$LN31@s390_disas:
  00460	c7 44 24 6c 06
	00 00 00	 mov	 DWORD PTR tv223[rsp], 6
$LN32@s390_disas:
  00468	8b 44 24 6c	 mov	 eax, DWORD PTR tv223[rsp]
  0046c	89 44 24 70	 mov	 DWORD PTR tv224[rsp], eax
$LN34@s390_disas:
  00470	8b 44 24 70	 mov	 eax, DWORD PTR tv224[rsp]
  00474	89 44 24 50	 mov	 DWORD PTR ilc$[rsp], eax

; 421  : 
; 422  :         if (aaddr + ilc > regs->mainlim)

  00478	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0047d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00485	48 03 c8	 add	 rcx, rax
  00488	48 8b c1	 mov	 rax, rcx
  0048b	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00493	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0049a	76 7b		 jbe	 SHORT $LN21@s390_disas

; 423  :         {
; 424  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", aaddr );

  0049c	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR aaddr$[rsp]
  004a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180691
  004ab	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  004b0	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 425  :             WRMSG( HHC02289, "I", buf );

  004be	b9 01 00 00 00	 mov	 ecx, 1
  004c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004d1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180692
  004dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180693
  004e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180694
  00500	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00505	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180695
  0050c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  :             return;

  00512	e9 75 02 00 00	 jmp	 $LN1@s390_disas
$LN21@s390_disas:

; 427  :         }
; 428  : 
; 429  :         /* Copy instruction to work area and hex print it */
; 430  :         memcpy(inst, regs->mainstor + aaddr, ilc);

  00517	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0051c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00524	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0052b	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR aaddr$[rsp]
  00533	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  0053b	48 8b fa	 mov	 rdi, rdx
  0053e	48 8b f1	 mov	 rsi, rcx
  00541	48 8b c8	 mov	 rcx, rax
  00544	f3 a4		 rep movsb

; 431  :         len = sprintf(buf, "%c:"F_RADR"  %2.2X%2.2X",

  00546	83 7c 24 54 00	 cmp	 DWORD PTR stid$[rsp], 0
  0054b	75 0a		 jne	 SHORT $LN39@s390_disas
  0054d	c7 44 24 7c 50
	00 00 00	 mov	 DWORD PTR tv266[rsp], 80 ; 00000050H
  00555	eb 3a		 jmp	 SHORT $LN40@s390_disas
$LN39@s390_disas:
  00557	83 7c 24 54 03	 cmp	 DWORD PTR stid$[rsp], 3
  0055c	75 0a		 jne	 SHORT $LN37@s390_disas
  0055e	c7 44 24 78 48
	00 00 00	 mov	 DWORD PTR tv265[rsp], 72 ; 00000048H
  00566	eb 21		 jmp	 SHORT $LN38@s390_disas
$LN37@s390_disas:
  00568	83 7c 24 54 02	 cmp	 DWORD PTR stid$[rsp], 2
  0056d	75 0a		 jne	 SHORT $LN35@s390_disas
  0056f	c7 44 24 74 53
	00 00 00	 mov	 DWORD PTR tv264[rsp], 83 ; 00000053H
  00577	eb 08		 jmp	 SHORT $LN36@s390_disas
$LN35@s390_disas:
  00579	c7 44 24 74 52
	00 00 00	 mov	 DWORD PTR tv264[rsp], 82 ; 00000052H
$LN36@s390_disas:
  00581	8b 44 24 74	 mov	 eax, DWORD PTR tv264[rsp]
  00585	89 44 24 78	 mov	 DWORD PTR tv265[rsp], eax
$LN38@s390_disas:
  00589	8b 44 24 78	 mov	 eax, DWORD PTR tv265[rsp]
  0058d	89 44 24 7c	 mov	 DWORD PTR tv266[rsp], eax
$LN40@s390_disas:
  00591	b8 01 00 00 00	 mov	 eax, 1
  00596	48 6b c0 01	 imul	 rax, rax, 1
  0059a	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  005a2	b9 01 00 00 00	 mov	 ecx, 1
  005a7	48 6b c9 00	 imul	 rcx, rcx, 0
  005ab	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  005b3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005b7	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005bb	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  005c0	44 8b 44 24 7c	 mov	 r8d, DWORD PTR tv266[rsp]
  005c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180696
  005cc	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005d4	e8 00 00 00 00	 call	 sprintf
  005d9	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 432  :           stid == TEA_ST_PRIMARY ? 'P' :
; 433  :           stid == TEA_ST_HOME ? 'H' :
; 434  :           stid == TEA_ST_SECNDRY ? 'S' : 'R',
; 435  :           raddr, inst[0], inst[1]);
; 436  : 
; 437  :         if(ilc > 2)

  005dd	83 7c 24 50 02	 cmp	 DWORD PTR ilc$[rsp], 2
  005e2	0f 8e e0 00 00
	00		 jle	 $LN22@s390_disas

; 438  :         {
; 439  :             len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X", inst[2], inst[3]);

  005e8	b8 01 00 00 00	 mov	 eax, 1
  005ed	48 6b c0 03	 imul	 rax, rax, 3
  005f1	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  005f9	b9 01 00 00 00	 mov	 ecx, 1
  005fe	48 6b c9 02	 imul	 rcx, rcx, 2
  00602	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  0060a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0060e	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00612	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180699
  00619	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0061f	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00627	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  0062b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00631	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00635	03 c8		 add	 ecx, eax
  00637	8b c1		 mov	 eax, ecx
  00639	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 440  :             if(ilc > 4)

  0063d	83 7c 24 50 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00642	7e 57		 jle	 SHORT $LN24@s390_disas

; 441  :                 len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X ", inst[4], inst[5]);

  00644	b8 01 00 00 00	 mov	 eax, 1
  00649	48 6b c0 05	 imul	 rax, rax, 5
  0064d	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  00655	b9 01 00 00 00	 mov	 ecx, 1
  0065a	48 6b c9 04	 imul	 rcx, rcx, 4
  0065e	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  00666	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0066a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0066e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180702
  00675	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0067b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00683	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00687	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0068d	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00691	03 c8		 add	 ecx, eax
  00693	8b c1		 mov	 eax, ecx
  00695	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
  00699	eb 2b		 jmp	 SHORT $LN25@s390_disas
$LN24@s390_disas:

; 442  :             else
; 443  :                 len += idx_snprintf( len, buf, sizeof(buf), "     ");

  0069b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180703
  006a2	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006a8	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006b0	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006ba	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006be	03 c8		 add	 ecx, eax
  006c0	8b c1		 mov	 eax, ecx
  006c2	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN25@s390_disas:

; 444  :         }

  006c6	eb 2b		 jmp	 SHORT $LN23@s390_disas
$LN22@s390_disas:

; 445  :         else
; 446  :             len += idx_snprintf( len, buf, sizeof(buf), "         ");

  006c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180704
  006cf	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006d5	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006dd	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006e7	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006eb	03 c8		 add	 ecx, eax
  006ed	8b c1		 mov	 eax, ecx
  006ef	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN23@s390_disas:

; 447  : 
; 448  :         /* Disassemble the instruction and display the results */
; 449  :         PRINT_INST( regs->arch_mode, inst, buf + len );

  006f3	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  006f8	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00700	4c 8b c8	 mov	 r9, rax
  00703	45 33 c0	 xor	 r8d, r8d
  00706	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  0070e	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00716	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  00719	e8 00 00 00 00	 call	 iprint_router_func

; 450  :         WRMSG( HHC02289, "I", buf );

  0071e	b9 01 00 00 00	 mov	 ecx, 1
  00723	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00729	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00731	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00736	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180705
  0073d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00742	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180706
  00749	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0074e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00753	41 b9 03 00 00
	00		 mov	 r9d, 3
  00759	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180707
  00760	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00765	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180708
  0076c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 451  : 
; 452  :         /* Go on to the next instruction */
; 453  :         saddr += ilc;

  00772	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00777	48 8b 4c 24 58	 mov	 rcx, QWORD PTR saddr$[rsp]
  0077c	48 03 c8	 add	 rcx, rax
  0077f	48 8b c1	 mov	 rax, rcx
  00782	48 89 44 24 58	 mov	 QWORD PTR saddr$[rsp], rax

; 454  : 
; 455  :     } /* end while (saddr <= eaddr) */

  00787	e9 98 fa ff ff	 jmp	 $LN8@s390_disas
$LN9@s390_disas:
$LN1@s390_disas:

; 456  : 
; 457  : } /* end function disasm_stor */

  0078c	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00794	48 33 cc	 xor	 rcx, rsp
  00797	e8 00 00 00 00	 call	 __security_check_cookie
  0079c	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  007a3	5f		 pop	 rdi
  007a4	5e		 pop	 rsi
  007a5	c3		 ret	 0
s390_disasm_stor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
dumpbuf$ = 80
tv129 = 88
tv159 = 92
msgnum$ = 96
tv66 = 104
dumpdata$ = 112
tv202 = 120
tv217 = 128
pfx$ = 144
__$ArrayPad$ = 208
regs$ = 240
aaddr$ = 248
adr$ = 256
offset$ = 264
amt$ = 272
vra$ = 280
wid$ = 288
s390_dump_abs_page PROC

; 238  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 239  :     char*   msgnum;                 /* "HHC02290" or "HHC02291"      */
; 240  :     char*   dumpdata;               /* pointer to data to be dumped  */
; 241  :     char*   dumpbuf = NULL;         /* pointer to hexdump buffer     */

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR dumpbuf$[rsp], 0

; 242  :     char    pfx[64];                /* string prefixed to each line  */
; 243  : 
; 244  :     msgnum = vra ? "HHC02290" : "HHC02291";

  00036	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0003e	85 c0		 test	 eax, eax
  00040	74 0e		 je	 SHORT $LN11@s390_dump_
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180581
  00049	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
  0004e	eb 0c		 jmp	 SHORT $LN12@s390_dump_
$LN11@s390_dump_:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180582
  00057	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
$LN12@s390_dump_:
  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR tv66[rsp]
  00061	48 89 44 24 60	 mov	 QWORD PTR msgnum$[rsp], rax

; 245  : 
; 246  :     if (0
; 247  :         || aaddr  &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 248  :         || adr    &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 249  :         || offset >= PAGEFRAME_PAGESIZE     /* offset >= pagesize    */
; 250  :         || amt    > (PAGEFRAME_PAGESIZE - offset)/* more than 1 page */
; 251  :         || (wid != 32 && wid != 64)         /* invalid address width */

  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 65		 jne	 SHORT $LN3@s390_dump_
  0006c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR aaddr$[rsp]
  00074	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0007a	48 85 c0	 test	 rax, rax
  0007d	75 52		 jne	 SHORT $LN3@s390_dump_
  0007f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00087	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0008d	48 85 c0	 test	 rax, rax
  00090	75 3f		 jne	 SHORT $LN3@s390_dump_
  00092	48 81 bc 24 08
	01 00 00 00 10
	00 00		 cmp	 QWORD PTR offset$[rsp], 4096 ; 00001000H
  0009e	73 31		 jae	 SHORT $LN3@s390_dump_
  000a0	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000a5	48 2b 84 24 08
	01 00 00	 sub	 rax, QWORD PTR offset$[rsp]
  000ad	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR amt$[rsp], rax
  000b5	77 1a		 ja	 SHORT $LN3@s390_dump_
  000b7	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c2	74 76		 je	 SHORT $LN2@s390_dump_
  000c4	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000cc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cf	74 69		 je	 SHORT $LN2@s390_dump_
$LN3@s390_dump_:

; 252  :     )
; 253  :     {
; 254  :         // "Error in function %s: %s"
; 255  :         WRMSG( HHC02219, "E", "dump_abs_page()", "invalid parameters" );

  000d1	b9 01 00 00 00	 mov	 ecx, 1
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180585
  000e3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180586
  000ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180587
  000fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180588
  00107	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	41 b9 03 00 00
	00		 mov	 r9d, 3
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180589
  0011e	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180590
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 256  :         return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 b0 03 00 00	 jmp	 $LN1@s390_dump_
$LN2@s390_dump_:

; 257  :     }
; 258  : 
; 259  :     /* Flush interval timer value to storage */
; 260  :     ITIMER_SYNC( adr + offset, amt, regs );
; 261  : 
; 262  :     /* Check for addressing exception */
; 263  :     if (aaddr > regs->mainlim)

  0013a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00149	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00151	0f 86 0e 01 00
	00		 jbe	 $LN4@s390_dump_

; 264  :     {
; 265  :         MSGBUF( pfx, "%c:"F_RADR"  Addressing exception",

  00157	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0015f	85 c0		 test	 eax, eax
  00161	74 0e		 je	 SHORT $LN13@s390_dump_
  00163	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0016b	89 44 24 58	 mov	 DWORD PTR tv129[rsp], eax
  0016f	eb 08		 jmp	 SHORT $LN14@s390_dump_
$LN13@s390_dump_:
  00171	c7 44 24 58 56
	00 00 00	 mov	 DWORD PTR tv129[rsp], 86 ; 00000056H
$LN14@s390_dump_:
  00179	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	44 8b 4c 24 58	 mov	 r9d, DWORD PTR tv129[rsp]
  0018b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180592
  00192	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00197	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 266  :             vra ? vra : 'V', adr );
; 267  :         if (vra)

  001a5	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  001ad	85 c0		 test	 eax, eax
  001af	74 56		 je	 SHORT $LN5@s390_dump_

; 268  :             WRMSG( HHC02290, "E", pfx );

  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bc	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  001c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180595
  001d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180596
  001dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180597
  001f3	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180598
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00205	eb 54		 jmp	 SHORT $LN6@s390_dump_
$LN5@s390_dump_:

; 269  :         else
; 270  :             WRMSG( HHC02291, "E", pfx );

  00207	b9 01 00 00 00	 mov	 ecx, 1
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0021a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180599
  00226	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180600
  00232	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00237	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00242	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180601
  00249	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180602
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@s390_dump_:

; 271  :         return -1;

  0025b	b8 ff ff ff ff	 mov	 eax, -1
  00260	e9 85 02 00 00	 jmp	 $LN1@s390_dump_
$LN4@s390_dump_:

; 272  :     }
; 273  : 
; 274  :     /* Format string each dump line should be prefixed with */
; 275  :     MSGBUF( pfx, "%sI %c:", msgnum, vra ? vra : 'V' );

  00265	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0026d	85 c0		 test	 eax, eax
  0026f	74 0e		 je	 SHORT $LN15@s390_dump_
  00271	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  00279	89 44 24 5c	 mov	 DWORD PTR tv159[rsp], eax
  0027d	eb 08		 jmp	 SHORT $LN16@s390_dump_
$LN15@s390_dump_:
  0027f	c7 44 24 5c 56
	00 00 00	 mov	 DWORD PTR tv159[rsp], 86 ; 00000056H
$LN16@s390_dump_:
  00287	8b 44 24 5c	 mov	 eax, DWORD PTR tv159[rsp]
  0028b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0028f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR msgnum$[rsp]
  00294	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180603
  0029b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  002a0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 276  : 
; 277  :     /* Point to first byte of actual storage to be dumped */
; 278  :     dumpdata = (char*) regs->mainstor + aaddr + offset;

  002ae	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002bd	48 03 84 24 f8
	00 00 00	 add	 rax, QWORD PTR aaddr$[rsp]
  002c5	48 03 84 24 08
	01 00 00	 add	 rax, QWORD PTR offset$[rsp]
  002cd	48 89 44 24 70	 mov	 QWORD PTR dumpdata$[rsp], rax

; 279  : 
; 280  :     /* Adjust cosmetic starting address of first line of dump */
; 281  :     adr += offset;                  /* exact cosmetic start address  */

  002d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  002da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adr$[rsp]
  002e2	48 03 c8	 add	 rcx, rax
  002e5	48 8b c1	 mov	 rax, rcx
  002e8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 282  :     adr &= ~0xF;                    /* align to 16-byte boundary     */

  002f0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  002f8	48 83 e0 f0	 and	 rax, -16
  002fc	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 283  :     offset &= 0xF;                  /* offset must be < (bpg * gpl)  */

  00304	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0030c	48 83 e0 0f	 and	 rax, 15
  00310	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 284  : 
; 285  :     /* Use hexdump to format 16-byte aligned absolute storage dump   */
; 286  : 
; 287  :     hexdumpew                       /* afterwards dumpbuf --> dump   */

  00318	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  00320	48 c7 44 24 40
	04 00 00 00	 mov	 QWORD PTR [rsp+64], 4
  00329	48 c7 44 24 38
	04 00 00 00	 mov	 QWORD PTR [rsp+56], 4
  00332	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00336	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  0033e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00343	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR amt$[rsp]
  0034b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00350	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR offset$[rsp]
  00358	4c 8b 44 24 70	 mov	 r8, QWORD PTR dumpdata$[rsp]
  0035d	48 8d 54 24 50	 lea	 rdx, QWORD PTR dumpbuf$[rsp]
  00362	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hexdumpew

; 288  :     (
; 289  :         pfx,                        /* string prefixed to each line  */
; 290  :         &dumpbuf,                   /* ptr to hexdump buffer pointer */
; 291  :                                     /* (if NULL hexdump will malloc) */
; 292  :         dumpdata,                   /* pointer to data to be dumped  */
; 293  :         offset,                     /* bytes to skip on first line   */
; 294  :         amt,                        /* amount of data to be dumped   */
; 295  :         adr,                        /* cosmetic dump address of data */
; 296  :         wid,                        /* width of dump address in bits */
; 297  :         4,                          /* bpg value (bytes per group)   */
; 298  :         4                           /* gpl value (groups per line)   */
; 299  :     );
; 300  : 
; 301  :     /* Check for internal hexdumpew error */
; 302  :     if (!dumpbuf)

  00370	48 83 7c 24 50
	00		 cmp	 QWORD PTR dumpbuf$[rsp], 0
  00376	75 69		 jne	 SHORT $LN7@s390_dump_

; 303  :     {
; 304  :         // "Error in function %s: %s"
; 305  :         WRMSG( HHC02219, "E", "dump_abs_page()", "hexdumpew failed" );

  00378	b9 01 00 00 00	 mov	 ecx, 1
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180605
  0038a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0038f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180606
  00396	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180607
  003a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180608
  003ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  003be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180609
  003c5	ba 31 01 00 00	 mov	 edx, 305		; 00000131H
  003ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180610
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 306  :         return -1;

  003d7	b8 ff ff ff ff	 mov	 eax, -1
  003dc	e9 09 01 00 00	 jmp	 $LN1@s390_dump_
$LN7@s390_dump_:

; 307  :     }
; 308  : 
; 309  :     /* Display the dump and free the buffer hexdump malloc'ed for us */
; 310  : 
; 311  :     /* Note: due to WRMSG requirements for multi-line messages, the
; 312  :        first line should not have a message number. Thus we skip past
; 313  :        it via +1 for "I" in message number +1 for blank following it.
; 314  :        We also remove the last newline since WRMSG does that for us. */
; 315  : 
; 316  :     *(dumpbuf + strlen( dumpbuf ) - 1) = 0; /* (remove last newline) */

  003e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  003e6	e8 00 00 00 00	 call	 strlen
  003eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  003f0	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 317  : 
; 318  :     if (vra)

  003f5	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  003fd	85 c0		 test	 eax, eax
  003ff	74 6c		 je	 SHORT $LN8@s390_dump_

; 319  :         WRMSG( HHC02290, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  00401	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msgnum$[rsp]
  00406	e8 00 00 00 00	 call	 strlen
  0040b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  00410	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00415	48 89 44 24 78	 mov	 QWORD PTR tv202[rsp], rax
  0041a	b9 01 00 00 00	 mov	 ecx, 1
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00425	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv202[rsp]
  0042a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0042f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180613
  00436	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180614
  00442	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00447	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00452	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180615
  00459	ba 3f 01 00 00	 mov	 edx, 319		; 0000013fH
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180616
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0046b	eb 70		 jmp	 SHORT $LN9@s390_dump_
$LN8@s390_dump_:

; 320  :     else
; 321  :         WRMSG( HHC02291, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  0046d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msgnum$[rsp]
  00472	e8 00 00 00 00	 call	 strlen
  00477	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  0047c	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00481	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  00489	b9 01 00 00 00	 mov	 ecx, 1
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00494	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv217[rsp]
  0049c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180617
  004a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180618
  004b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004be	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180619
  004cb	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  004d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180620
  004d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@s390_dump_:

; 322  : 
; 323  :     free( dumpbuf );

  004dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 324  :     return 0;

  004e8	33 c0		 xor	 eax, eax
$LN1@s390_dump_:

; 325  : 
; 326  : } /* end function dump_abs_page */

  004ea	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f2	48 33 cc	 xor	 rcx, rsp
  004f5	e8 00 00 00 00	 call	 __security_check_cookie
  004fa	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00501	c3		 ret	 0
s390_dump_abs_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
n$ = 48
tv136 = 52
stid$ = 56
raddr$ = 64
regs$ = 96
vaddr$ = 104
buf$ = 112
bufl$ = 120
ar$ = 128
acctype$ = 136
hdr$ = 144
xcode$ = 152
s390_display_virt PROC

; 188  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 189  : RADR    raddr;                          /* Real address              */
; 190  : int     n;                              /* Number of bytes in buffer */
; 191  : int     stid;                           /* Segment table indication  */
; 192  : 
; 193  :     /* Convert virtual address to real address */
; 194  :     *xcode = ARCH_DEP(virt_to_real) (&raddr, &stid,

  00017	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  0001b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00022	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00030	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR ar$[rsp]
  00038	44 8b c0	 mov	 r8d, eax
  0003b	48 8d 54 24 38	 lea	 rdx, QWORD PTR stid$[rsp]
  00040	48 8d 4c 24 40	 lea	 rcx, QWORD PTR raddr$[rsp]
  00045	e8 00 00 00 00	 call	 s390_virt_to_real
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  00052	66 89 01	 mov	 WORD PTR [rcx], ax

; 195  :                                      vaddr, ar, regs, acctype);
; 196  : 
; 197  :     if (*xcode == 0)

  00055	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  0005d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00060	85 c0		 test	 eax, eax
  00062	0f 85 c6 00 00
	00		 jne	 $LN2@s390_displ

; 198  :     {
; 199  :         if (ar == USE_REAL_ADDR)

  00068	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  00070	75 2d		 jne	 SHORT $LN4@s390_displ

; 200  :             n = snprintf( buf, bufl, "%sR:"F_VADR":", hdr, vaddr );

  00072	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  00076	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007a	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180553
  00089	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00099	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
  0009d	eb 35		 jmp	 SHORT $LN5@s390_displ
$LN4@s390_displ:

; 201  :         else
; 202  :             n = snprintf( buf, bufl, "%sV:"F_VADR":R:"F_RADR":", hdr, vaddr, raddr );

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR raddr$[rsp]
  000a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a9	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  000ad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b1	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180554
  000c0	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  000c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000d0	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN5@s390_displ:

; 203  : 
; 204  :         n += ARCH_DEP( display_real )( regs, raddr, buf+n, bufl-n, 0, "" );

  000d4	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bufl$[rsp]
  000de	48 2b c8	 sub	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR n$[rsp]
  000e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  000ee	48 03 d1	 add	 rdx, rcx
  000f1	48 8b ca	 mov	 rcx, rdx
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180555
  000fb	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00100	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00108	4c 8b c8	 mov	 r9, rax
  0010b	4c 8b c1	 mov	 r8, rcx
  0010e	48 8b 54 24 40	 mov	 rdx, QWORD PTR raddr$[rsp]
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	e8 00 00 00 00	 call	 s390_display_real
  0011d	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00121	03 c8		 add	 ecx, eax
  00123	8b c1		 mov	 eax, ecx
  00125	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 205  :     }

  00129	e9 9d 00 00 00	 jmp	 $LN3@s390_displ
$LN2@s390_displ:

; 206  :     else
; 207  :     {
; 208  :         n = snprintf (buf, bufl, "%s%c:"F_VADR":", hdr,

  0012e	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  00136	75 0a		 jne	 SHORT $LN7@s390_displ
  00138	c7 44 24 34 52
	00 00 00	 mov	 DWORD PTR tv136[rsp], 82 ; 00000052H
  00140	eb 08		 jmp	 SHORT $LN8@s390_displ
$LN7@s390_displ:
  00142	c7 44 24 34 56
	00 00 00	 mov	 DWORD PTR tv136[rsp], 86 ; 00000056H
$LN8@s390_displ:
  0014a	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  0014e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00152	8b 44 24 34	 mov	 eax, DWORD PTR tv136[rsp]
  00156	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0015a	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00162	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180556
  00169	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  0016e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00179	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 209  :                      ar == USE_REAL_ADDR ? 'R' : 'V', vaddr);
; 210  :         n += idx_snprintf( n, buf, bufl, " Translation exception %4.4hX (%s)",

  0017d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  00185	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00188	8b c8		 mov	 ecx, eax
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00190	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  00198	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0019b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a0	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001a4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180557
  001ab	4c 8b 44 24 78	 mov	 r8, QWORD PTR bufl$[rsp]
  001b0	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  001b5	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001bf	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001c3	03 c8		 add	 ecx, eax
  001c5	8b c1		 mov	 eax, ecx
  001c7	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN3@s390_displ:

; 211  :             *xcode, PIC2Name( *xcode ));
; 212  :     }
; 213  :     return n;

  001cb	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]

; 214  : 
; 215  : } /* end function display_virt */

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
s390_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
c$ = 48
n$ = 52
j$ = 56
aaddr$ = 64
i$ = 72
tv88 = 80
$T1 = 88
cbuf$ = 96
hbuf$ = 128
__$ArrayPad$ = 192
regs$ = 224
raddr$ = 232
buf$ = 240
bufl$ = 248
draflag$ = 256
hdr$ = 264
s390_display_real PROC

; 113  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 114  : RADR    aaddr;                          /* Absolute storage address  */
; 115  : int     i, j;                           /* Loop counters             */
; 116  : int     n = 0;                          /* Number of bytes in buffer */

  0002e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 117  : char    hbuf[64];                       /* Hexadecimal buffer        */
; 118  : BYTE    cbuf[17];                       /* Character buffer          */
; 119  : BYTE    c;                              /* Character work area       */
; 120  : 
; 121  : #if defined(FEATURE_INTERVAL_TIMER)
; 122  :     if(ITIMER_ACCESS(raddr,16))
; 123  :         ARCH_DEP(store_int_timer)(regs);
; 124  : #endif
; 125  : 
; 126  :     n = snprintf(buf, bufl, "%s", hdr);

  00036	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180508
  00045	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR bufl$[rsp]
  0004d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0005b	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 127  :     if (draflag)

  0005f	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR draflag$[rsp], 0
  00067	74 3a		 je	 SHORT $LN5@s390_displ

; 128  :     {
; 129  :         n += idx_snprintf( n, buf, bufl, "R:"F_RADR":", raddr);

  00069	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180510
  0007d	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00085	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0008d	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00097	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0009b	03 c8		 add	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN5@s390_displ:

; 130  :     }
; 131  : 
; 132  :     aaddr = APPLY_PREFIXING (raddr, regs->PX);

  000a3	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR raddr$[rsp]
  000aa	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000b0	48 85 c0	 test	 rax, rax
  000b3	74 2c		 je	 SHORT $LN17@s390_displ
  000b5	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR raddr$[rsp]
  000bc	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000c2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000cd	48 3b c1	 cmp	 rax, rcx
  000d0	74 0f		 je	 SHORT $LN17@s390_displ
  000d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  000da	48 89 44 24 50	 mov	 QWORD PTR tv88[rsp], rax
  000df	eb 1d		 jmp	 SHORT $LN18@s390_displ
$LN17@s390_displ:
  000e1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ec	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR raddr$[rsp]
  000f3	33 c8		 xor	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	8b c0		 mov	 eax, eax
  000f9	48 89 44 24 50	 mov	 QWORD PTR tv88[rsp], rax
$LN18@s390_displ:
  000fe	48 8b 44 24 50	 mov	 rax, QWORD PTR tv88[rsp]
  00103	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 133  :     if (SIE_MODE(regs))

  00108	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00116	d1 e8		 shr	 eax, 1
  00118	83 e0 01	 and	 eax, 1
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 b1 00 00
	00		 je	 $LN6@s390_displ

; 134  :     {
; 135  :         if (HOSTREGS->mainlim == 0 || aaddr > HOSTREGS->mainlim)

  00123	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00132	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0013a	74 1d		 je	 SHORT $LN10@s390_displ
  0013c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014b	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00152	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  00157	76 42		 jbe	 SHORT $LN8@s390_displ
$LN10@s390_displ:

; 136  :         {
; 137  :             n += idx_snprintf( n, buf, bufl,

  00159	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  0015e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00163	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180516
  0016a	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00172	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0017a	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00184	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00188	03 c8		 add	 ecx, eax
  0018a	8b c1		 mov	 eax, ecx
  0018c	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 138  :                 "A:"F_RADR" Guest real address is not valid", aaddr);
; 139  :             return n;

  00190	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00194	e9 71 02 00 00	 jmp	 $LN1@s390_displ

; 140  :         }

  00199	eb 37		 jmp	 SHORT $LN9@s390_displ
$LN8@s390_displ:

; 141  :         else
; 142  :         {
; 143  :             n += idx_snprintf( n, buf, bufl, "A:"F_RADR":", aaddr);

  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  001a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180517
  001ac	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  001b4	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001bc	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001c6	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001ca	03 c8		 add	 ecx, eax
  001cc	8b c1		 mov	 eax, ecx
  001ce	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN9@s390_displ:

; 144  :         }
; 145  :     }

  001d2	eb 6a		 jmp	 SHORT $LN7@s390_displ
$LN6@s390_displ:

; 146  :     else
; 147  :     if (regs->mainlim == 0 || aaddr > regs->mainlim)

  001d4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001e4	74 16		 je	 SHORT $LN12@s390_displ
  001e6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ee	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  001f5	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  001fa	76 42		 jbe	 SHORT $LN11@s390_displ
$LN12@s390_displ:

; 148  :     {
; 149  :         n += idx_snprintf( n, buf, bufl, "%s", " Real address is not valid");

  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180520
  00203	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00208	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180521
  0020f	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00217	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0021f	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00229	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0022d	03 c8		 add	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 150  :         return n;

  00235	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00239	e9 cc 01 00 00	 jmp	 $LN1@s390_displ
$LN11@s390_displ:
$LN7@s390_displ:

; 151  :     }
; 152  : 
; 153  :     /* Note: we use the internal "_get_storage_key" function here
; 154  :        so that we display the STORKEY_BADFRM bit too, if it's set.
; 155  :     */
; 156  :     n += idx_snprintf( n, buf, bufl, "K:%2.2X=", ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));

  0023e	b2 04		 mov	 dl, 4
  00240	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00245	e8 00 00 00 00	 call	 s390__get_storage_key
  0024a	0f b6 c0	 movzx	 eax, al
  0024d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00251	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180522
  00258	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00260	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00268	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00272	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00276	03 c8		 add	 ecx, eax
  00278	8b c1		 mov	 eax, ecx
  0027a	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 157  : 
; 158  :     memset (hbuf, SPACE, sizeof(hbuf));

  0027e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  00286	48 8b f8	 mov	 rdi, rax
  00289	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0028e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00293	f3 aa		 rep stosb

; 159  :     memset (cbuf, SPACE, sizeof(cbuf));

  00295	48 8d 44 24 60	 lea	 rax, QWORD PTR cbuf$[rsp]
  0029a	48 8b f8	 mov	 rdi, rax
  0029d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002a2	b9 11 00 00 00	 mov	 ecx, 17
  002a7	f3 aa		 rep stosb

; 160  : 
; 161  :     for (i = 0, j = 0; i < 16; i++)

  002a9	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002b1	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  002b9	eb 0a		 jmp	 SHORT $LN4@s390_displ
$LN2@s390_displ:
  002bb	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  002bf	ff c0		 inc	 eax
  002c1	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_displ:
  002c5	83 7c 24 48 10	 cmp	 DWORD PTR i$[rsp], 16
  002ca	0f 8d f2 00 00
	00		 jge	 $LN3@s390_displ

; 162  :     {
; 163  :         c = regs->mainstor[aaddr++];

  002d0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002e4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002e8	88 44 24 30	 mov	 BYTE PTR c$[rsp], al
  002ec	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  002f1	48 ff c0	 inc	 rax
  002f4	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 164  :         j += idx_snprintf( j, hbuf, sizeof(hbuf), "%2.2X", c);

  002f9	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  002fe	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00302	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180523
  00309	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0030f	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00317	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00321	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  00325	03 c8		 add	 ecx, eax
  00327	8b c1		 mov	 eax, ecx
  00329	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax

; 165  :         if ((aaddr & 0x3) == 0x0)

  0032d	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  00332	48 83 e0 03	 and	 rax, 3
  00336	48 85 c0	 test	 rax, rax
  00339	75 3d		 jne	 SHORT $LN13@s390_displ

; 166  :         {
; 167  :             hbuf[j] = SPACE;

  0033b	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  00340	c6 84 04 80 00
	00 00 20	 mov	 BYTE PTR hbuf$[rsp+rax], 32 ; 00000020H

; 168  :             hbuf[++j] = 0;

  00348	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  0034c	ff c0		 inc	 eax
  0034e	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  00352	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  00357	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  0035c	48 83 7c 24 58
	40		 cmp	 QWORD PTR $T1[rsp], 64	; 00000040H
  00362	73 02		 jae	 SHORT $LN19@s390_displ
  00364	eb 05		 jmp	 SHORT $LN20@s390_displ
$LN19@s390_displ:
  00366	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN20@s390_displ:
  0036b	48 8b 44 24 58	 mov	 rax, QWORD PTR $T1[rsp]
  00370	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR hbuf$[rsp+rax], 0
$LN13@s390_displ:

; 169  :         }
; 170  :         c = guest_to_host(c);

  00378	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00383	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 171  :         if (!isprint(c)) c = '.';

  00387	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0038c	8b c8		 mov	 ecx, eax
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00394	85 c0		 test	 eax, eax
  00396	75 05		 jne	 SHORT $LN14@s390_displ
  00398	c6 44 24 30 2e	 mov	 BYTE PTR c$[rsp], 46	; 0000002eH
$LN14@s390_displ:

; 172  :         cbuf[i] = c;

  0039d	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  003a2	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  003a7	88 4c 04 60	 mov	 BYTE PTR cbuf$[rsp+rax], cl

; 173  :         if ((aaddr & PAGEFRAME_BYTEMASK) == 0x000) break;

  003ab	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  003b0	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  003b6	48 85 c0	 test	 rax, rax
  003b9	75 02		 jne	 SHORT $LN15@s390_displ
  003bb	eb 05		 jmp	 SHORT $LN3@s390_displ
$LN15@s390_displ:

; 174  :     } /* end for(i) */

  003bd	e9 f9 fe ff ff	 jmp	 $LN2@s390_displ
$LN3@s390_displ:

; 175  : 
; 176  :     n += idx_snprintf( n, buf, bufl, "%-36.36s %-16.16s", hbuf, cbuf);

  003c2	48 8d 44 24 60	 lea	 rax, QWORD PTR cbuf$[rsp]
  003c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003cc	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  003d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180527
  003e0	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  003e8	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  003f0	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  003fa	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  003fe	03 c8		 add	 ecx, eax
  00400	8b c1		 mov	 eax, ecx
  00402	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 177  :     return n;

  00406	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
$LN1@s390_displ:
$LN16@s390_displ:

; 178  : 
; 179  : } /* end function display_real */

  0040a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00412	48 33 cc	 xor	 rcx, rsp
  00415	e8 00 00 00 00	 call	 __security_check_cookie
  0041a	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00421	5f		 pop	 rdi
  00422	c3		 ret	 0
s390_display_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s390__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s390__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@s390__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@s390__get_
$LN5@s390__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s390__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
s390__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
s390_display_pgmint_inst PROC

; 1181 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1182 :     ARCH_DEP( display_inst_adj )( iregs, inst, true );

  0000e	41 b0 01	 mov	 r8b, 1
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 s390_display_inst_adj

; 1183 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
s390_display_pgmint_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
opcode$ = 96
n$ = 100
regs$ = 104
trace2file$ = 112
addr1$ = 116
b1$ = 120
b2$ = 124
addr2$ = 128
ilc$ = 132
xcode$ = 136
relative_long_operand$1 = 140
tv136 = 144
tv138 = 148
tv145 = 152
tv181 = 156
tv232 = 160
tv233 = 164
x1$ = 168
tv850 = 172
tv851 = 176
ar$2 = 180
tv794 = 184
tv888 = 188
tv302 = 192
offset$3 = 200
$T4 = 208
len$5 = 216
$T6 = 224
tv402 = 232
tv403 = 240
$T7 = 248
$T8 = 256
$T9 = 264
len$10 = 272
$T11 = 280
tf2326$ = 288
qword$ = 400
psw_inst_msg$ = 416
op2_stor_msg$ = 576
op1_stor_msg$ = 704
buf2$ = 832
buf$ = 1344
regs_msg_buf$ = 3392
__$ArrayPad$ = 5440
iregs$ = 5472
inst$ = 5480
pgmint$ = 5488
s370_display_inst_adj PROC

; 812  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	b8 50 15 00 00	 mov	 eax, 5456		; 00001550H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 40
	15 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 813  : QWORD   qword;                          /* Doubleword work area      */
; 814  : BYTE    opcode;                         /* Instruction operation code*/
; 815  : int     ilc;                            /* Instruction length        */
; 816  : int     b1=-1, b2=-1, x1;               /* Register numbers          */

  0002f	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR b1$[rsp], -1
  00037	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR b2$[rsp], -1

; 817  : U16     xcode = 0;                      /* Exception code            */

  0003f	33 c0		 xor	 eax, eax
  00041	66 89 84 24 88
	00 00 00	 mov	 WORD PTR xcode$[rsp], ax

; 818  : VADR    addr1 = 0, addr2 = 0;           /* Operand addresses         */

  00049	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR addr1$[rsp], 0
  00051	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR addr2$[rsp], 0

; 819  : char    buf[2048];                      /* Message buffer            */
; 820  : char    buf2[512];
; 821  : int     n;                              /* Number of bytes in buffer */
; 822  : REGS*   regs;                           /* Copied regs               */
; 823  : 
; 824  : TF02326 tf2326 = {0};

  0005c	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR tf2326$[rsp]
  00064	48 8b f8	 mov	 rdi, rax
  00067	33 c0		 xor	 eax, eax
  00069	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0006e	f3 aa		 rep stosb

; 825  : bool    trace2file;
; 826  : 
; 827  : char    psw_inst_msg[160]   = {0};

  00070	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR psw_inst_msg$[rsp]
  00078	48 8b f8	 mov	 rdi, rax
  0007b	33 c0		 xor	 eax, eax
  0007d	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00082	f3 aa		 rep stosb

; 828  : char    op1_stor_msg[128]   = {0};

  00084	48 8d 84 24 c0
	02 00 00	 lea	 rax, QWORD PTR op1_stor_msg$[rsp]
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	33 c0		 xor	 eax, eax
  00091	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00096	f3 aa		 rep stosb

; 829  : char    op2_stor_msg[128]   = {0};

  00098	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR op2_stor_msg$[rsp]
  000a0	48 8b f8	 mov	 rdi, rax
  000a3	33 c0		 xor	 eax, eax
  000a5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000aa	f3 aa		 rep stosb

; 830  : char    regs_msg_buf[4*512] = {0};

  000ac	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	33 c0		 xor	 eax, eax
  000b9	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000be	f3 aa		 rep stosb
$LN4@s370_displ:

; 831  : 
; 832  :     PTT_PGM( "dinst", inst, 0, pgmint );

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ca	48 83 e0 20	 and	 rax, 32			; 00000020H
  000ce	48 85 c0	 test	 rax, rax
  000d1	74 3f		 je	 SHORT $LN20@s370_displ
  000d3	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  000db	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170288
  000f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f5	45 33 c9	 xor	 r9d, r9d
  000f8	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170289
  00107	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@s370_displ:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 a8		 jne	 SHORT $LN4@s370_displ

; 833  : 
; 834  :     OBTAIN_TRACEFILE_LOCK();

  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011f	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170290
  0012c	48 8b c8	 mov	 rcx, rax
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 835  :     {
; 836  :         trace2file = (iregs->insttrace && sysblk.traceFILE) ? true : false;

  00135	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  0013d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00143	c1 e8 0f	 shr	 eax, 15
  00146	83 e0 01	 and	 eax, 1
  00149	85 c0		 test	 eax, eax
  0014b	74 1e		 je	 SHORT $LN91@s370_displ
  0014d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00154	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0015c	74 0d		 je	 SHORT $LN91@s370_displ
  0015e	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv136[rsp], 1
  00169	eb 0b		 jmp	 SHORT $LN92@s370_displ
$LN91@s370_displ:
  0016b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
$LN92@s370_displ:
  00176	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv136[rsp], 0
  0017e	75 0d		 jne	 SHORT $LN93@s370_displ
  00180	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv138[rsp], 0
  0018b	eb 0b		 jmp	 SHORT $LN94@s370_displ
$LN93@s370_displ:
  0018d	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv138[rsp], 1
$LN94@s370_displ:
  00198	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR tv138[rsp]
  001a0	88 44 24 70	 mov	 BYTE PTR trace2file$[rsp], al

; 837  :     }
; 838  :     RELEASE_TRACEFILE_LOCK();

  001a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ab	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170291
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 839  : 
; 840  :     /* Ensure storage exists to attempt the display */
; 841  :     tf2326.valid = (iregs->mainlim != 0);

  001c1	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  001c9	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001d1	74 0d		 je	 SHORT $LN95@s370_displ
  001d3	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
  001de	eb 0b		 jmp	 SHORT $LN96@s370_displ
$LN95@s370_displ:
  001e0	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN96@s370_displ:
  001eb	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  001f3	88 84 24 38 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+24], al

; 842  :     if (!tf2326.valid)

  001fa	0f b6 84 24 38
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+24]
  00202	85 c0		 test	 eax, eax
  00204	0f 85 8f 00 00
	00		 jne	 $LN21@s370_displ

; 843  :     {
; 844  :         if (trace2file)

  0020a	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  0020f	85 c0		 test	 eax, eax
  00211	74 2e		 je	 SHORT $LN22@s370_displ

; 845  :             tf_2326( iregs, &tf2326, 0,0,0,0 );

  00213	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0021b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00223	45 33 c9	 xor	 r9d, r9d
  00226	45 33 c0	 xor	 r8d, r8d
  00229	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  00231	48 8b 8c 24 60
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326
  0023f	eb 53		 jmp	 SHORT $LN23@s370_displ
$LN22@s370_displ:

; 846  :         else
; 847  :             WRMSG( HHC02267, "I", "Real address is not valid" );

  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170295
  00253	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170296
  0025f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170297
  0026b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00270	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00275	41 b9 03 00 00
	00		 mov	 r9d, 3
  0027b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170298
  00282	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170299
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@s370_displ:

; 848  :         return;

  00294	e9 48 17 00 00	 jmp	 $LN1@s370_displ
$LN21@s370_displ:

; 849  :     }
; 850  : 
; 851  :     n = 0;

  00299	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 852  :     buf[0] = '\0';

  002a1	b8 01 00 00 00	 mov	 eax, 1
  002a6	48 6b c0 00	 imul	 rax, rax, 0
  002aa	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR $T4[rsp], rax
  002b2	48 81 bc 24 d0
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T4[rsp], 2048 ; 00000800H
  002be	73 02		 jae	 SHORT $LN97@s370_displ
  002c0	eb 05		 jmp	 SHORT $LN98@s370_displ
$LN97@s370_displ:
  002c2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN98@s370_displ:
  002c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  002cf	c6 84 04 40 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 853  : 
; 854  :     /* Get a working (modifiable) copy of the REGS */
; 855  :     if (iregs->ghostregs)

  002d7	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002df	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002e5	c1 e8 0d	 shr	 eax, 13
  002e8	83 e0 01	 and	 eax, 1
  002eb	85 c0		 test	 eax, eax
  002ed	74 0f		 je	 SHORT $LN24@s370_displ

; 856  :         regs = iregs;

  002ef	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  002f7	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  002fc	eb 1f		 jmp	 SHORT $LN25@s370_displ
$LN24@s370_displ:

; 857  :     else if (!(regs = copy_regs( iregs )))

  002fe	48 8b 8c 24 60
	15 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00306	e8 00 00 00 00	 call	 copy_regs
  0030b	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax
  00310	48 83 7c 24 68
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00316	75 05		 jne	 SHORT $LN26@s370_displ

; 858  :         return;

  00318	e9 c4 16 00 00	 jmp	 $LN1@s370_displ
$LN26@s370_displ:
$LN25@s370_displ:

; 859  : 
; 860  : #if defined( _FEATURE_SIE )
; 861  :     tf2326.sie = SIE_MODE( regs ) ? true : false;

  0031d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00328	d1 e8		 shr	 eax, 1
  0032a	83 e0 01	 and	 eax, 1
  0032d	85 c0		 test	 eax, eax
  0032f	74 0d		 je	 SHORT $LN99@s370_displ
  00331	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv181[rsp], 1
  0033c	eb 0b		 jmp	 SHORT $LN100@s370_displ
$LN99@s370_displ:
  0033e	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN100@s370_displ:
  00349	0f b6 84 24 9c
	00 00 00	 movzx	 eax, BYTE PTR tv181[rsp]
  00351	88 84 24 39 01
	00 00		 mov	 BYTE PTR tf2326$[rsp+25], al

; 862  :     if (tf2326.sie)

  00358	0f b6 84 24 39
	01 00 00	 movzx	 eax, BYTE PTR tf2326$[rsp+25]
  00360	85 c0		 test	 eax, eax
  00362	74 2b		 je	 SHORT $LN27@s370_displ

; 863  :         n += idx_snprintf( n, buf, sizeof( buf ), "SIE: " );

  00364	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170304
  0036b	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00371	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00379	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00383	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00387	03 c8		 add	 ecx, eax
  00389	8b c1		 mov	 eax, ecx
  0038b	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN27@s370_displ:

; 864  : #endif
; 865  : 
; 866  :     /* Exit if instruction is not valid */
; 867  :     if (!inst)

  0038f	48 83 bc 24 68
	15 00 00 00	 cmp	 QWORD PTR inst$[rsp], 0
  00398	0f 85 43 01 00
	00		 jne	 $LN28@s370_displ

; 868  :     {
; 869  :         if (trace2file)

  0039e	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  003a3	85 c0		 test	 eax, eax
  003a5	74 18		 je	 SHORT $LN29@s370_displ

; 870  :             tf_2269( regs, inst );

  003a7	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  003af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2269
  003ba	e9 1d 01 00 00	 jmp	 $LN30@s370_displ
$LN29@s370_displ:

; 871  :         else
; 872  :         {
; 873  :             size_t len;
; 874  :             MSGBUF( psw_inst_msg, "%s Instruction fetch error\n", buf );

  003bf	4c 8d 8c 24 40
	05 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  003c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170308
  003ce	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  003d3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 875  :             display_gregs( regs, regs_msg_buf, sizeof(regs_msg_buf)-1, "HHC02269I " );

  003e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170309
  003e8	41 b8 ff 07 00
	00		 mov	 r8d, 2047		; 000007ffH
  003ee	48 8d 94 24 40
	0d 00 00	 lea	 rdx, QWORD PTR regs_msg_buf$[rsp]
  003f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003fb	e8 00 00 00 00	 call	 display_gregs

; 876  :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 877  :             len = strlen( regs_msg_buf );

  00400	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  00408	e8 00 00 00 00	 call	 strlen
  0040d	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR len$5[rsp], rax

; 878  :             if (len)

  00415	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR len$5[rsp], 0
  0041e	74 38		 je	 SHORT $LN31@s370_displ

; 879  :                 regs_msg_buf[ len-1 ] = 0;

  00420	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR len$5[rsp]
  00428	48 ff c8	 dec	 rax
  0042b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  00433	48 81 bc 24 e0
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T6[rsp], 2048 ; 00000800H
  0043f	73 02		 jae	 SHORT $LN101@s370_displ
  00441	eb 05		 jmp	 SHORT $LN102@s370_displ
$LN101@s370_displ:
  00443	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN102@s370_displ:
  00448	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00450	c6 84 04 40 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN31@s370_displ:

; 880  :             // "%s%s" // (instruction fetch error + regs)
; 881  :             WRMSG( HHC02325, "E", psw_inst_msg, regs_msg_buf );

  00458	b9 01 00 00 00	 mov	 ecx, 1
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00463	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  0046b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00470	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  00478	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0047d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170311
  00484	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00489	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170312
  00490	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00495	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049a	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170313
  004a7	ba 71 03 00 00	 mov	 edx, 881		; 00000371H
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170314
  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 882  :             if (!iregs->ghostregs)

  004b9	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  004c1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  004c7	c1 e8 0d	 shr	 eax, 13
  004ca	83 e0 01	 and	 eax, 1
  004cd	85 c0		 test	 eax, eax
  004cf	75 0b		 jne	 SHORT $LN32@s370_displ

; 883  :                 free_aligned( regs );

  004d1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN32@s370_displ:
$LN30@s370_displ:

; 884  :         }
; 885  :         return;

  004dc	e9 00 15 00 00	 jmp	 $LN1@s370_displ
$LN28@s370_displ:

; 886  :     }
; 887  : 
; 888  :     /* Save the opcode and determine the instruction length */
; 889  :     opcode = inst[0];

  004e1	b8 01 00 00 00	 mov	 eax, 1
  004e6	48 6b c0 00	 imul	 rax, rax, 0
  004ea	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  004f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004f6	88 44 24 60	 mov	 BYTE PTR opcode$[rsp], al

; 890  :     ilc = ILC( opcode );

  004fa	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  004ff	83 f8 40	 cmp	 eax, 64			; 00000040H
  00502	7d 0d		 jge	 SHORT $LN105@s370_displ
  00504	c7 84 24 a4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv233[rsp], 2
  0050f	eb 32		 jmp	 SHORT $LN106@s370_displ
$LN105@s370_displ:
  00511	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00516	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0051b	7d 0d		 jge	 SHORT $LN103@s370_displ
  0051d	c7 84 24 a0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv232[rsp], 4
  00528	eb 0b		 jmp	 SHORT $LN104@s370_displ
$LN103@s370_displ:
  0052a	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv232[rsp], 6
$LN104@s370_displ:
  00535	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv232[rsp]
  0053c	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv233[rsp], eax
$LN106@s370_displ:
  00543	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv233[rsp]
  0054a	89 84 24 84 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN7@s370_displ:

; 891  : 
; 892  :     PTT_PGM( "dinst op,ilc", opcode, ilc, pgmint );

  00551	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00558	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0055b	48 83 e0 20	 and	 rax, 32			; 00000020H
  0055f	48 85 c0	 test	 rax, rax
  00562	74 47		 je	 SHORT $LN33@s370_displ
  00564	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  0056c	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR ilc$[rsp]
  00574	0f b6 54 24 60	 movzx	 edx, BYTE PTR opcode$[rsp]
  00579	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00582	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00587	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170317
  0058e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00593	4c 8b c9	 mov	 r9, rcx
  00596	44 8b c2	 mov	 r8d, edx
  00599	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170318
  005a0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@s370_displ:
  005ab	33 c0		 xor	 eax, eax
  005ad	85 c0		 test	 eax, eax
  005af	75 a0		 jne	 SHORT $LN7@s370_displ
$LN10@s370_displ:

; 893  : 
; 894  :     /* If we were called to display the instruction that program
; 895  :        checked, then since the "iregs" REGS value that was passed
; 896  :        to us (that we made a working copy of) was pointing PAST
; 897  :        the instruction that actually program checked (not at it),
; 898  :        we need to backup by the ilc amount so that it points at
; 899  :        the instruction that program checked, not past it.
; 900  :     */
; 901  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  005b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005bb	48 83 e0 20	 and	 rax, 32			; 00000020H
  005bf	48 85 c0	 test	 rax, rax
  005c2	74 4b		 je	 SHORT $LN34@s370_displ
  005c4	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  005cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  005d1	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  005d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005e0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170320
  005ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f1	44 8b c9	 mov	 r9d, ecx
  005f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  005f9	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  005fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170321
  00604	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00609	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s370_displ:
  0060f	33 c0		 xor	 eax, eax
  00611	85 c0		 test	 eax, eax
  00613	75 9c		 jne	 SHORT $LN10@s370_displ

; 902  :     if (pgmint)

  00615	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  0061d	85 c0		 test	 eax, eax
  0061f	74 57		 je	 SHORT $LN35@s370_displ

; 903  :     {
; 904  :         regs->ip -= ilc;

  00621	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00629	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00632	48 2b c8	 sub	 rcx, rax
  00635	48 8b c1	 mov	 rax, rcx
  00638	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0063d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 905  :         regs->psw.IA = PSW_IA_FROM_IP( regs, 0 );

  00641	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00646	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0064c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00651	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00656	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0065d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00661	48 2b ca	 sub	 rcx, rdx
  00664	48 03 c1	 add	 rax, rcx
  00667	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0066d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00672	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN35@s370_displ:
$LN13@s370_displ:

; 906  :     }
; 907  :     PTT_PGM( "dinst ip,IA", regs->ip, regs->psw.IA, pgmint );

  00678	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0067f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00682	48 83 e0 20	 and	 rax, 32			; 00000020H
  00686	48 85 c0	 test	 rax, rax
  00689	74 4b		 je	 SHORT $LN36@s370_displ
  0068b	0f b6 84 24 70
	15 00 00	 movzx	 eax, BYTE PTR pgmint$[rsp]
  00693	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00698	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0069e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170324
  006b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b8	44 8b c9	 mov	 r9d, ecx
  006bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  006c0	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  006c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170325
  006cb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@s370_displ:
  006d6	33 c0		 xor	 eax, eax
  006d8	85 c0		 test	 eax, eax
  006da	75 9c		 jne	 SHORT $LN13@s370_displ

; 908  : 
; 909  :     /* Display the PSW */
; 910  :     memset( qword, 0, sizeof( qword ));

  006dc	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR qword$[rsp]
  006e4	48 8b f8	 mov	 rdi, rax
  006e7	33 c0		 xor	 eax, eax
  006e9	b9 10 00 00 00	 mov	 ecx, 16
  006ee	f3 aa		 rep stosb

; 911  :     copy_psw( regs, qword );

  006f0	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR qword$[rsp]
  006f8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  006fd	e8 00 00 00 00	 call	 copy_psw

; 912  : 
; 913  :     if (!trace2file)

  00702	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00707	85 c0		 test	 eax, eax
  00709	0f 85 78 03 00
	00		 jne	 $LN37@s370_displ

; 914  :     {
; 915  :         if (sysblk.cpus > 1)

  0070f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00716	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  0071d	7e 6f		 jle	 SHORT $LN38@s370_displ

; 916  :             n += idx_snprintf( n, buf, sizeof( buf ), "%s%02X: ", PTYPSTR( regs->cpuad ), regs->cpuad );

  0071f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00724	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0072b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv302[rsp], eax
  00732	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0073e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00745	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0074d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00753	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv302[rsp]
  0075a	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0075e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00763	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170328
  0076a	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00770	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00778	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0077c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00782	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00786	03 c8		 add	 ecx, eax
  00788	8b c1		 mov	 eax, ecx
  0078a	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN38@s370_displ:

; 917  : 
; 918  :         n += idx_snprintf( n, buf, sizeof( buf ),

  0078e	b8 01 00 00 00	 mov	 eax, 1
  00793	48 6b c0 07	 imul	 rax, rax, 7
  00797	0f b6 84 04 90
	01 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  0079f	b9 01 00 00 00	 mov	 ecx, 1
  007a4	48 6b c9 06	 imul	 rcx, rcx, 6
  007a8	0f b6 8c 0c 90
	01 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  007b0	ba 01 00 00 00	 mov	 edx, 1
  007b5	48 6b d2 05	 imul	 rdx, rdx, 5
  007b9	0f b6 94 14 90
	01 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  007c1	bf 01 00 00 00	 mov	 edi, 1
  007c6	48 6b ff 04	 imul	 rdi, rdi, 4
  007ca	0f b6 bc 3c 90
	01 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  007d2	41 b8 01 00 00
	00		 mov	 r8d, 1
  007d8	4d 6b c0 03	 imul	 r8, r8, 3
  007dc	46 0f b6 84 04
	90 01 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  007e5	41 b9 01 00 00
	00		 mov	 r9d, 1
  007eb	4d 6b c9 02	 imul	 r9, r9, 2
  007ef	46 0f b6 8c 0c
	90 01 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  007f8	41 ba 01 00 00
	00		 mov	 r10d, 1
  007fe	4d 6b d2 01	 imul	 r10, r10, 1
  00802	46 0f b6 94 14
	90 01 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  0080b	41 bb 01 00 00
	00		 mov	 r11d, 1
  00811	4d 6b db 00	 imul	 r11, r11, 0
  00815	46 0f b6 9c 1c
	90 01 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  0081e	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00822	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00826	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  0082a	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0082e	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  00833	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00838	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0083d	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  00842	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170329
  00849	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0084f	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00857	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0085b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00861	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00865	03 c8		 add	 ecx, eax
  00867	8b c1		 mov	 eax, ecx
  00869	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 919  :                     "PSW=%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 920  :                     qword[0], qword[1], qword[2], qword[3],
; 921  :                     qword[4], qword[5], qword[6], qword[7] );
; 922  : 
; 923  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 924  :         n += idx_snprintf( n, buf, sizeof(buf),
; 925  :                     "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X ",
; 926  :                     qword[8], qword[9], qword[10], qword[11],
; 927  :                     qword[12], qword[13], qword[14], qword[15]);
; 928  : #endif
; 929  : 
; 930  :         /* Format instruction line */
; 931  :                      n += idx_snprintf( n, buf, sizeof( buf ), "INST=%2.2X%2.2X", inst[0], inst[1] );

  0086d	b8 01 00 00 00	 mov	 eax, 1
  00872	48 6b c0 01	 imul	 rax, rax, 1
  00876	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0087e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00882	b9 01 00 00 00	 mov	 ecx, 1
  00887	48 6b c9 00	 imul	 rcx, rcx, 0
  0088b	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00893	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00897	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0089b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0089f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170330
  008a6	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  008ac	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  008b4	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  008b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  008be	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  008c2	03 c8		 add	 ecx, eax
  008c4	8b c1		 mov	 eax, ecx
  008c6	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 932  :         if (ilc > 2){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[2], inst[3] );}

  008ca	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  008d2	7e 5d		 jle	 SHORT $LN39@s370_displ
  008d4	b8 01 00 00 00	 mov	 eax, 1
  008d9	48 6b c0 03	 imul	 rax, rax, 3
  008dd	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  008e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008e9	b9 01 00 00 00	 mov	 ecx, 1
  008ee	48 6b c9 02	 imul	 rcx, rcx, 2
  008f2	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  008fa	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  008fe	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00902	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00906	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170332
  0090d	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00913	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0091b	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0091f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00925	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00929	03 c8		 add	 ecx, eax
  0092b	8b c1		 mov	 eax, ecx
  0092d	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN39@s370_displ:

; 933  :         if (ilc > 4){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[4], inst[5] );}

  00931	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00939	7e 5d		 jle	 SHORT $LN40@s370_displ
  0093b	b8 01 00 00 00	 mov	 eax, 1
  00940	48 6b c0 05	 imul	 rax, rax, 5
  00944	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0094c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00950	b9 01 00 00 00	 mov	 ecx, 1
  00955	48 6b c9 04	 imul	 rcx, rcx, 4
  00959	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00961	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00965	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00969	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0096d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170334
  00974	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  0097a	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00982	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00986	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0098c	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00990	03 c8		 add	 ecx, eax
  00992	8b c1		 mov	 eax, ecx
  00994	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN40@s370_displ:

; 934  :                      n += idx_snprintf( n, buf, sizeof( buf ), " %s", (ilc < 4) ? "        " :

  00998	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  009a0	7d 11		 jge	 SHORT $LN109@s370_displ
  009a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170335
  009a9	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv403[rsp], rax
  009b1	eb 3a		 jmp	 SHORT $LN110@s370_displ
$LN109@s370_displ:
  009b3	83 bc 24 84 00
	00 00 06	 cmp	 DWORD PTR ilc$[rsp], 6
  009bb	7d 11		 jge	 SHORT $LN107@s370_displ
  009bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170336
  009c4	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
  009cc	eb 0f		 jmp	 SHORT $LN108@s370_displ
$LN107@s370_displ:
  009ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170337
  009d5	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
$LN108@s370_displ:
  009dd	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv402[rsp]
  009e5	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv403[rsp], rax
$LN110@s370_displ:
  009ed	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv403[rsp]
  009f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170338
  00a01	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00a07	48 8d 94 24 40
	05 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00a0f	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a13	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00a19	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a1d	03 c8		 add	 ecx, eax
  00a1f	8b c1		 mov	 eax, ecx
  00a21	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 935  :                                                                       (ilc < 6) ? "    " : "" );
; 936  :         n += PRINT_INST( regs->arch_mode, inst, buf + n );

  00a25	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  00a2a	48 8d 84 04 40
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00a32	4c 8b c8	 mov	 r9, rax
  00a35	45 33 c0	 xor	 r8d, r8d
  00a38	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00a40	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00a45	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  00a48	e8 00 00 00 00	 call	 iprint_router_func
  00a4d	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  00a51	03 c8		 add	 ecx, eax
  00a53	8b c1		 mov	 eax, ecx
  00a55	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 937  :         MSGBUF( psw_inst_msg, MSG( HHC02324, "I", buf ));

  00a59	48 8d 84 24 40
	05 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00a61	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a66	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170339
  00a6d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170340
  00a74	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00a79	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  00a81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN37@s370_displ:

; 938  :     }
; 939  : 
; 940  :     n = 0;

  00a87	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 941  :     buf[0] = '\0';

  00a8f	b8 01 00 00 00	 mov	 eax, 1
  00a94	48 6b c0 00	 imul	 rax, rax, 0
  00a98	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR $T7[rsp], rax
  00aa0	48 81 bc 24 f8
	00 00 00 00 08
	00 00		 cmp	 QWORD PTR $T7[rsp], 2048 ; 00000800H
  00aac	73 02		 jae	 SHORT $LN111@s370_displ
  00aae	eb 05		 jmp	 SHORT $LN112@s370_displ
$LN111@s370_displ:
  00ab0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN112@s370_displ:
  00ab5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  00abd	c6 84 04 40 05
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 942  : 
; 943  :     /* Process the first storage operand */
; 944  :     if (1
; 945  :         && ilc > 2
; 946  :         && opcode != 0x84   // BRXH
; 947  :         && opcode != 0x85   // BRXLE
; 948  :         && opcode != 0xA5   // RI-x     (relative)
; 949  :         && opcode != 0xA7   // RI-x     (relative)
; 950  :         && opcode != 0xB3   // RRE/RRF
; 951  :         && opcode != 0xC0   // RIL-x    (relative)
; 952  :         && opcode != 0xC4   // RIL-x    (relative)
; 953  :         && opcode != 0xC6   // RIL-x    (relative)
; 954  :         && opcode != 0xEC   // RIE-x

  00ac5	33 c0		 xor	 eax, eax
  00ac7	83 f8 01	 cmp	 eax, 1
  00aca	0f 84 b5 01 00
	00		 je	 $LN41@s370_displ
  00ad0	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR ilc$[rsp], 2
  00ad8	0f 8e a7 01 00
	00		 jle	 $LN41@s370_displ
  00ade	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ae3	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  00ae8	0f 84 97 01 00
	00		 je	 $LN41@s370_displ
  00aee	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00af3	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00af8	0f 84 87 01 00
	00		 je	 $LN41@s370_displ
  00afe	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b03	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  00b08	0f 84 77 01 00
	00		 je	 $LN41@s370_displ
  00b0e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b13	3d a7 00 00 00	 cmp	 eax, 167		; 000000a7H
  00b18	0f 84 67 01 00
	00		 je	 $LN41@s370_displ
  00b1e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b23	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00b28	0f 84 57 01 00
	00		 je	 $LN41@s370_displ
  00b2e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b33	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00b38	0f 84 47 01 00
	00		 je	 $LN41@s370_displ
  00b3e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b43	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00b48	0f 84 37 01 00
	00		 je	 $LN41@s370_displ
  00b4e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b53	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00b58	0f 84 27 01 00
	00		 je	 $LN41@s370_displ
  00b5e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00b63	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00b68	0f 84 17 01 00
	00		 je	 $LN41@s370_displ

; 955  :     )
; 956  :     {
; 957  :         /* Calculate the effective address of the first operand */
; 958  :         b1 = inst[2] >> 4;

  00b6e	b8 01 00 00 00	 mov	 eax, 1
  00b73	48 6b c0 02	 imul	 rax, rax, 2
  00b77	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00b7f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b83	c1 f8 04	 sar	 eax, 4
  00b86	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax

; 959  :         addr1 = ((inst[2] & 0x0F) << 8) | inst[3];

  00b8a	b8 01 00 00 00	 mov	 eax, 1
  00b8f	48 6b c0 02	 imul	 rax, rax, 2
  00b93	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00b9b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b9f	83 e0 0f	 and	 eax, 15
  00ba2	c1 e0 08	 shl	 eax, 8
  00ba5	b9 01 00 00 00	 mov	 ecx, 1
  00baa	48 6b c9 03	 imul	 rcx, rcx, 3
  00bae	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00bb6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00bba	0b c1		 or	 eax, ecx
  00bbc	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 960  :         if (b1 != 0)

  00bc0	83 7c 24 78 00	 cmp	 DWORD PTR b1$[rsp], 0
  00bc5	74 2a		 je	 SHORT $LN42@s370_displ

; 961  :         {
; 962  :             addr1 += regs->GR( b1 );

  00bc7	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00bcc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00bd8	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00bdc	03 c8		 add	 ecx, eax
  00bde	8b c1		 mov	 eax, ecx
  00be0	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 963  :             addr1 &= ADDRESS_MAXWRAP( regs );

  00be4	8b 44 24 74	 mov	 eax, DWORD PTR addr1$[rsp]
  00be8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00bed	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN42@s370_displ:

; 964  :         }
; 965  : 
; 966  :         /* Apply indexing for RX/RXE/RXF instructions */
; 967  :         if (0
; 968  :             || (opcode >= 0x40 && opcode <= 0x7F)
; 969  :             ||  opcode == 0xB1   // LRA
; 970  :             ||  opcode == 0xE3   // RXY-x
; 971  :             ||  opcode == 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00bf1	33 c0		 xor	 eax, eax
  00bf3	85 c0		 test	 eax, eax
  00bf5	75 38		 jne	 SHORT $LN44@s370_displ
  00bf7	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00bfc	83 f8 40	 cmp	 eax, 64			; 00000040H
  00bff	7c 0a		 jl	 SHORT $LN45@s370_displ
  00c01	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c06	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00c09	7e 24		 jle	 SHORT $LN44@s370_displ
$LN45@s370_displ:
  00c0b	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c10	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00c15	74 18		 je	 SHORT $LN44@s370_displ
  00c17	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c1c	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00c21	74 0c		 je	 SHORT $LN44@s370_displ
  00c23	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00c28	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00c2d	75 56		 jne	 SHORT $LN43@s370_displ
$LN44@s370_displ:

; 972  :         )
; 973  :         {
; 974  :             x1 = inst[1] & 0x0F;

  00c2f	b8 01 00 00 00	 mov	 eax, 1
  00c34	48 6b c0 01	 imul	 rax, rax, 1
  00c38	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00c40	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c44	83 e0 0f	 and	 eax, 15
  00c47	89 84 24 a8 00
	00 00		 mov	 DWORD PTR x1$[rsp], eax

; 975  :             if (x1 != 0)

  00c4e	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR x1$[rsp], 0
  00c56	74 2d		 je	 SHORT $LN46@s370_displ

; 976  :             {
; 977  :                 addr1 += regs->GR( x1 );

  00c58	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR x1$[rsp]
  00c60	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00c65	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00c6c	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  00c70	03 c8		 add	 ecx, eax
  00c72	8b c1		 mov	 eax, ecx
  00c74	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 978  :                 addr1 &= ADDRESS_MAXWRAP( regs );

  00c78	8b 44 24 74	 mov	 eax, DWORD PTR addr1$[rsp]
  00c7c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00c81	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN46@s370_displ:
$LN43@s370_displ:
$LN41@s370_displ:

; 979  :             }
; 980  :         }
; 981  :     }
; 982  : 
; 983  :     /* Process the second storage operand */
; 984  :     if (1
; 985  :         && ilc > 4
; 986  :         && opcode != 0xC0   // RIL-x    (relative)
; 987  :         && opcode != 0xC4   // RIL-x    (relative)
; 988  :         && opcode != 0xC6   // RIL-x    (relative)
; 989  :         && opcode != 0xE3   // RXY-x
; 990  :         && opcode != 0xEB   // RSY-x, SIY-x
; 991  :         && opcode != 0xEC   // RIE-x
; 992  :         && opcode != 0xED   // RXE-x, RXF-x, RXY-x, RSL-x

  00c85	33 c0		 xor	 eax, eax
  00c87	83 f8 01	 cmp	 eax, 1
  00c8a	0f 84 10 01 00
	00		 je	 $LN47@s370_displ
  00c90	83 bc 24 84 00
	00 00 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00c98	0f 8e 02 01 00
	00		 jle	 $LN47@s370_displ
  00c9e	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ca3	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00ca8	0f 84 f2 00 00
	00		 je	 $LN47@s370_displ
  00cae	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cb3	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00cb8	0f 84 e2 00 00
	00		 je	 $LN47@s370_displ
  00cbe	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cc3	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00cc8	0f 84 d2 00 00
	00		 je	 $LN47@s370_displ
  00cce	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cd3	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00cd8	0f 84 c2 00 00
	00		 je	 $LN47@s370_displ
  00cde	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00ce3	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00ce8	0f 84 b2 00 00
	00		 je	 $LN47@s370_displ
  00cee	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00cf3	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  00cf8	0f 84 a2 00 00
	00		 je	 $LN47@s370_displ
  00cfe	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00d03	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00d08	0f 84 92 00 00
	00		 je	 $LN47@s370_displ

; 993  :     )
; 994  :     {
; 995  :         /* Calculate the effective address of the second operand */
; 996  :         b2 = inst[4] >> 4;

  00d0e	b8 01 00 00 00	 mov	 eax, 1
  00d13	48 6b c0 04	 imul	 rax, rax, 4
  00d17	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00d1f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d23	c1 f8 04	 sar	 eax, 4
  00d26	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax

; 997  :         addr2 = ((inst[4] & 0x0F) << 8) | inst[5];

  00d2a	b8 01 00 00 00	 mov	 eax, 1
  00d2f	48 6b c0 04	 imul	 rax, rax, 4
  00d33	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00d3b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d3f	83 e0 0f	 and	 eax, 15
  00d42	c1 e0 08	 shl	 eax, 8
  00d45	b9 01 00 00 00	 mov	 ecx, 1
  00d4a	48 6b c9 05	 imul	 rcx, rcx, 5
  00d4e	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00d56	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d5a	0b c1		 or	 eax, ecx
  00d5c	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax

; 998  :         if (b2 != 0)

  00d63	83 7c 24 7c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00d68	74 36		 je	 SHORT $LN48@s370_displ

; 999  :         {
; 1000 :             addr2 += regs->GR( b2 );

  00d6a	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00d6f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00d74	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00d7b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr2$[rsp]
  00d82	03 c8		 add	 ecx, eax
  00d84	8b c1		 mov	 eax, ecx
  00d86	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax

; 1001 :             addr2 &= ADDRESS_MAXWRAP( regs );

  00d8d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  00d94	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00d99	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN48@s370_displ:
$LN47@s370_displ:

; 1002 :         }
; 1003 :     }
; 1004 : 
; 1005 :     /* Calculate the operand addresses for MVCL(E) and CLCL(E) */
; 1006 :     if (0
; 1007 :         || opcode == 0x0E   // MVCL
; 1008 :         || opcode == 0x0F   // CLCL
; 1009 :         || opcode == 0xA8   // MVCLE
; 1010 :         || opcode == 0xA9   // CLCLE

  00da0	33 c0		 xor	 eax, eax
  00da2	85 c0		 test	 eax, eax
  00da4	75 2c		 jne	 SHORT $LN50@s370_displ
  00da6	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00dab	83 f8 0e	 cmp	 eax, 14
  00dae	74 22		 je	 SHORT $LN50@s370_displ
  00db0	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00db5	83 f8 0f	 cmp	 eax, 15
  00db8	74 18		 je	 SHORT $LN50@s370_displ
  00dba	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00dbf	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  00dc4	74 0c		 je	 SHORT $LN50@s370_displ
  00dc6	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00dcb	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  00dd0	75 6f		 jne	 SHORT $LN49@s370_displ
$LN50@s370_displ:

; 1011 :     )
; 1012 :     {
; 1013 :         b1 = inst[1] >> 4;   addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  00dd2	b8 01 00 00 00	 mov	 eax, 1
  00dd7	48 6b c0 01	 imul	 rax, rax, 1
  00ddb	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00de3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00de7	c1 f8 04	 sar	 eax, 4
  00dea	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax
  00dee	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00df3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00df8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00dff	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00e04	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1014 :         b2 = inst[1] & 0x0F; addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  00e08	b8 01 00 00 00	 mov	 eax, 1
  00e0d	48 6b c0 01	 imul	 rax, rax, 1
  00e11	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e19	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e1d	83 e0 0f	 and	 eax, 15
  00e20	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax
  00e24	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00e29	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00e2e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00e35	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00e3a	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN49@s370_displ:

; 1015 :     }
; 1016 : 
; 1017 :     /* Calculate the operand addresses for RRE instructions */
; 1018 :     if (0
; 1019 :         || (opcode == 0xB2 &&
; 1020 :             (0
; 1021 :              || (inst[1] >= 0x20 && inst[1] <= 0x2F)
; 1022 :              || (inst[1] >= 0x40 && inst[1] <= 0x6F)
; 1023 :              || (inst[1] >= 0xA0 && inst[1] <= 0xAF)
; 1024 :             )
; 1025 :            )
; 1026 :         || (opcode == 0xB9 &&

  00e41	33 c0		 xor	 eax, eax
  00e43	85 c0		 test	 eax, eax
  00e45	0f 85 2a 01 00
	00		 jne	 $LN52@s370_displ
  00e4b	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00e50	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00e55	0f 85 b2 00 00
	00		 jne	 $LN53@s370_displ
  00e5b	33 c0		 xor	 eax, eax
  00e5d	85 c0		 test	 eax, eax
  00e5f	0f 85 10 01 00
	00		 jne	 $LN52@s370_displ
  00e65	b8 01 00 00 00	 mov	 eax, 1
  00e6a	48 6b c0 01	 imul	 rax, rax, 1
  00e6e	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e76	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e7a	83 f8 20	 cmp	 eax, 32			; 00000020H
  00e7d	7c 1e		 jl	 SHORT $LN54@s370_displ
  00e7f	b8 01 00 00 00	 mov	 eax, 1
  00e84	48 6b c0 01	 imul	 rax, rax, 1
  00e88	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00e90	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e94	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00e97	0f 8e d8 00 00
	00		 jle	 $LN52@s370_displ
$LN54@s370_displ:
  00e9d	b8 01 00 00 00	 mov	 eax, 1
  00ea2	48 6b c0 01	 imul	 rax, rax, 1
  00ea6	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00eae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00eb2	83 f8 40	 cmp	 eax, 64			; 00000040H
  00eb5	7c 1e		 jl	 SHORT $LN55@s370_displ
  00eb7	b8 01 00 00 00	 mov	 eax, 1
  00ebc	48 6b c0 01	 imul	 rax, rax, 1
  00ec0	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ec8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ecc	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00ecf	0f 8e a0 00 00
	00		 jle	 $LN52@s370_displ
$LN55@s370_displ:
  00ed5	b8 01 00 00 00	 mov	 eax, 1
  00eda	48 6b c0 01	 imul	 rax, rax, 1
  00ede	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ee6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00eea	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00eef	7c 1c		 jl	 SHORT $LN56@s370_displ
  00ef1	b8 01 00 00 00	 mov	 eax, 1
  00ef6	48 6b c0 01	 imul	 rax, rax, 1
  00efa	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f02	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f06	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  00f0b	7e 68		 jle	 SHORT $LN52@s370_displ
$LN56@s370_displ:
$LN53@s370_displ:
  00f0d	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  00f12	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00f17	0f 85 19 01 00
	00		 jne	 $LN51@s370_displ
  00f1d	33 c0		 xor	 eax, eax
  00f1f	85 c0		 test	 eax, eax
  00f21	75 52		 jne	 SHORT $LN57@s370_displ
  00f23	b8 01 00 00 00	 mov	 eax, 1
  00f28	48 6b c0 01	 imul	 rax, rax, 1
  00f2c	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f34	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f38	83 f8 05	 cmp	 eax, 5
  00f3b	74 38		 je	 SHORT $LN57@s370_displ
  00f3d	b8 01 00 00 00	 mov	 eax, 1
  00f42	48 6b c0 01	 imul	 rax, rax, 1
  00f46	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f4e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f52	83 f8 25	 cmp	 eax, 37			; 00000025H
  00f55	74 1e		 je	 SHORT $LN57@s370_displ
  00f57	b8 01 00 00 00	 mov	 eax, 1
  00f5c	48 6b c0 01	 imul	 rax, rax, 1
  00f60	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f68	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f6c	83 f8 31	 cmp	 eax, 49			; 00000031H
  00f6f	0f 8c c1 00 00
	00		 jl	 $LN51@s370_displ
$LN57@s370_displ:
$LN52@s370_displ:

; 1027 :             (0
; 1028 :              || (inst[1] == 0x05)   // LURAG
; 1029 :              || (inst[1] == 0x25)   // STURG
; 1030 :              || (inst[1] >= 0x31)   // CLGFR
; 1031 :             )
; 1032 :            )
; 1033 :     )
; 1034 :     {
; 1035 :         b1 = inst[3] >> 4;

  00f75	b8 01 00 00 00	 mov	 eax, 1
  00f7a	48 6b c0 03	 imul	 rax, rax, 3
  00f7e	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00f86	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f8a	c1 f8 04	 sar	 eax, 4
  00f8d	89 44 24 78	 mov	 DWORD PTR b1$[rsp], eax

; 1036 :         addr1 = regs->GR( b1 ) & ADDRESS_MAXWRAP( regs );

  00f91	48 63 44 24 78	 movsxd	 rax, DWORD PTR b1$[rsp]
  00f96	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00f9b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00fa2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00fa7	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1037 :         b2 = inst[3] & 0x0F;

  00fab	b8 01 00 00 00	 mov	 eax, 1
  00fb0	48 6b c0 03	 imul	 rax, rax, 3
  00fb4	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00fbc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fc0	83 e0 0f	 and	 eax, 15
  00fc3	89 44 24 7c	 mov	 DWORD PTR b2$[rsp], eax

; 1038 :         if (inst[1] >= 0x29 && inst[1] <= 0x2C)

  00fc7	b8 01 00 00 00	 mov	 eax, 1
  00fcc	48 6b c0 01	 imul	 rax, rax, 1
  00fd0	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00fd8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fdc	83 f8 29	 cmp	 eax, 41			; 00000029H
  00fdf	7c 38		 jl	 SHORT $LN58@s370_displ
  00fe1	b8 01 00 00 00	 mov	 eax, 1
  00fe6	48 6b c0 01	 imul	 rax, rax, 1
  00fea	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00ff2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ff6	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00ff9	7f 1e		 jg	 SHORT $LN58@s370_displ

; 1039 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP_E( regs );

  00ffb	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  01000	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01005	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0100c	0f ba f0 1f	 btr	 eax, 31
  01010	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
  01017	eb 1d		 jmp	 SHORT $LN59@s370_displ
$LN58@s370_displ:

; 1040 :         else
; 1041 :             addr2 = regs->GR( b2 ) & ADDRESS_MAXWRAP( regs );

  01019	48 63 44 24 7c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0101e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01023	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0102a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0102f	89 84 24 80 00
	00 00		 mov	 DWORD PTR addr2$[rsp], eax
$LN59@s370_displ:
$LN51@s370_displ:

; 1042 :     }
; 1043 : 
; 1044 :     /* Calculate the operand address for RIL-x (relative) instructions */
; 1045 :     if (0
; 1046 :         || (opcode == 0xC0 &&
; 1047 :             (0
; 1048 :              || (inst[1] & 0x0F) == 0x00    // LARL   (relative)
; 1049 :              || (inst[1] & 0x0F) == 0x04    // BRCL   (relative)
; 1050 :              || (inst[1] & 0x0F) == 0x05    // BRASL  (relative)
; 1051 :             )
; 1052 :            )
; 1053 :         || opcode == 0xC4   // RIL-x  (relative)
; 1054 :         || opcode == 0xC6   // RIL-x  (relative)

  01036	33 c0		 xor	 eax, eax
  01038	85 c0		 test	 eax, eax
  0103a	0f 85 84 00 00
	00		 jne	 $LN61@s370_displ
  01040	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01045	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0104a	75 5c		 jne	 SHORT $LN62@s370_displ
  0104c	33 c0		 xor	 eax, eax
  0104e	85 c0		 test	 eax, eax
  01050	75 72		 jne	 SHORT $LN61@s370_displ
  01052	b8 01 00 00 00	 mov	 eax, 1
  01057	48 6b c0 01	 imul	 rax, rax, 1
  0105b	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01067	83 e0 0f	 and	 eax, 15
  0106a	85 c0		 test	 eax, eax
  0106c	74 56		 je	 SHORT $LN61@s370_displ
  0106e	b8 01 00 00 00	 mov	 eax, 1
  01073	48 6b c0 01	 imul	 rax, rax, 1
  01077	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0107f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01083	83 e0 0f	 and	 eax, 15
  01086	83 f8 04	 cmp	 eax, 4
  01089	74 39		 je	 SHORT $LN61@s370_displ
  0108b	b8 01 00 00 00	 mov	 eax, 1
  01090	48 6b c0 01	 imul	 rax, rax, 1
  01094	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0109c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010a0	83 e0 0f	 and	 eax, 15
  010a3	83 f8 05	 cmp	 eax, 5
  010a6	74 1c		 je	 SHORT $LN61@s370_displ
$LN62@s370_displ:
  010a8	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  010ad	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  010b2	74 10		 je	 SHORT $LN61@s370_displ
  010b4	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  010b9	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  010be	0f 85 45 01 00
	00		 jne	 $LN60@s370_displ
$LN61@s370_displ:

; 1055 :     )
; 1056 :     {
; 1057 :         S64 offset;
; 1058 :         S32 relative_long_operand = fetch_fw( inst+2 );

  010c4	48 8b 84 24 68
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  010cc	48 83 c0 02	 add	 rax, 2
  010d0	48 8b c8	 mov	 rcx, rax
  010d3	e8 00 00 00 00	 call	 fetch_fw_noswap
  010d8	8b c8		 mov	 ecx, eax
  010da	e8 00 00 00 00	 call	 _byteswap_ulong
  010df	89 84 24 8c 00
	00 00		 mov	 DWORD PTR relative_long_operand$1[rsp], eax

; 1059 :         offset = 2LL * relative_long_operand;

  010e6	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  010ee	48 d1 e0	 shl	 rax, 1
  010f1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR offset$3[rsp], rax

; 1060 :         addr1 = PSW_IA_FROM_IP( regs, 0 );  // (current instruction address)

  010f9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  010fe	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01109	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0110e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01115	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01119	48 2b ca	 sub	 rcx, rdx
  0111c	48 03 c1	 add	 rax, rcx
  0111f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  01125	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax
$LN16@s370_displ:

; 1061 : 
; 1062 :         PTT_PGM( "dinst rel1:", addr1, offset, relative_long_operand );

  01129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01130	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01133	48 83 e0 20	 and	 rax, 32			; 00000020H
  01137	48 85 c0	 test	 rax, rax
  0113a	74 43		 je	 SHORT $LN63@s370_displ
  0113c	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  01144	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  01148	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01151	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01156	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170364
  0115d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01162	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  0116a	44 8b c1	 mov	 r8d, ecx
  0116d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170365
  01174	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@s370_displ:
  0117f	33 c0		 xor	 eax, eax
  01181	85 c0		 test	 eax, eax
  01183	75 a4		 jne	 SHORT $LN16@s370_displ

; 1063 : 
; 1064 :         addr1 += (VADR)offset;      // (plus relative offset)

  01185	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR offset$3[rsp]
  0118c	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  01190	03 c8		 add	 ecx, eax
  01192	8b c1		 mov	 eax, ecx
  01194	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1065 :         addr1 &= ADDRESS_MAXWRAP( regs );

  01198	8b 44 24 74	 mov	 eax, DWORD PTR addr1$[rsp]
  0119c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  011a1	89 44 24 74	 mov	 DWORD PTR addr1$[rsp], eax

; 1066 :         b1 = 0;

  011a5	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR b1$[rsp], 0
$LN19@s370_displ:

; 1067 : 
; 1068 :         PTT_PGM( "dinst rel1=", addr1, offset, relative_long_operand );

  011ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  011b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011b7	48 83 e0 20	 and	 rax, 32			; 00000020H
  011bb	48 85 c0	 test	 rax, rax
  011be	74 43		 je	 SHORT $LN64@s370_displ
  011c0	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR relative_long_operand$1[rsp]
  011c8	8b 4c 24 74	 mov	 ecx, DWORD PTR addr1$[rsp]
  011cc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  011d5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170367
  011e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011e6	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR offset$3[rsp]
  011ee	44 8b c1	 mov	 r8d, ecx
  011f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170368
  011f8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  011fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN64@s370_displ:
  01203	33 c0		 xor	 eax, eax
  01205	85 c0		 test	 eax, eax
  01207	75 a4		 jne	 SHORT $LN19@s370_displ
$LN60@s370_displ:

; 1069 :     }
; 1070 : 
; 1071 :     if (trace2file)

  01209	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  0120e	85 c0		 test	 eax, eax
  01210	74 6f		 je	 SHORT $LN65@s370_displ

; 1072 :     {
; 1073 :         tf2326.op1.vaddr = addr1;

  01212	8b 44 24 74	 mov	 eax, DWORD PTR addr1$[rsp]
  01216	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+32], rax

; 1074 :         tf2326.op2.vaddr = addr2;

  0121e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr2$[rsp]
  01225	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tf2326$[rsp+72], rax

; 1075 :         tf_2326( regs, &tf2326, inst[0], inst[1], b1, b2 );

  0122d	b8 01 00 00 00	 mov	 eax, 1
  01232	48 6b c0 01	 imul	 rax, rax, 1
  01236	b9 01 00 00 00	 mov	 ecx, 1
  0123b	48 6b c9 00	 imul	 rcx, rcx, 0
  0123f	8b 54 24 7c	 mov	 edx, DWORD PTR b2$[rsp]
  01243	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  01247	8b 54 24 78	 mov	 edx, DWORD PTR b1$[rsp]
  0124b	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0124f	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  01257	44 0f b6 0c 02	 movzx	 r9d, BYTE PTR [rdx+rax]
  0125c	48 8b 84 24 68
	15 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  01264	44 0f b6 04 08	 movzx	 r8d, BYTE PTR [rax+rcx]
  01269	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tf2326$[rsp]
  01271	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2326

; 1076 :     }

  0127c	e9 41 05 00 00	 jmp	 $LN66@s370_displ
$LN65@s370_displ:

; 1077 :     else
; 1078 :     {
; 1079 :         /* Format storage at first storage operand location */
; 1080 :         if (b1 >= 0)

  01281	83 7c 24 78 00	 cmp	 DWORD PTR b1$[rsp], 0
  01286	0f 8c a7 02 00
	00		 jl	 $LN67@s370_displ

; 1081 :         {
; 1082 :             n = 0;

  0128c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1083 :             buf2[0] = '\0';

  01294	b8 01 00 00 00	 mov	 eax, 1
  01299	48 6b c0 00	 imul	 rax, rax, 0
  0129d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR $T8[rsp], rax
  012a5	48 81 bc 24 00
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T8[rsp], 512	; 00000200H
  012b1	73 02		 jae	 SHORT $LN113@s370_displ
  012b3	eb 05		 jmp	 SHORT $LN114@s370_displ
$LN113@s370_displ:
  012b5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN114@s370_displ:
  012ba	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  012c2	c6 84 04 40 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1084 : 
; 1085 : #if defined( _FEATURE_SIE )
; 1086 :             if (SIE_MODE( regs ))

  012ca	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  012cf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  012d5	d1 e8		 shr	 eax, 1
  012d7	83 e0 01	 and	 eax, 1
  012da	85 c0		 test	 eax, eax
  012dc	74 2b		 je	 SHORT $LN68@s370_displ

; 1087 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  012de	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170373
  012e5	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  012eb	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  012f3	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  012f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  012fd	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01301	03 c8		 add	 ecx, eax
  01303	8b c1		 mov	 eax, ecx
  01305	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN68@s370_displ:

; 1088 : #endif
; 1089 :             if (sysblk.cpus > 1)

  01309	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01310	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  01317	7e 6f		 jle	 SHORT $LN69@s370_displ

; 1090 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  01319	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0131e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01325	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv794[rsp], eax
  0132c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01331	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01338	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0133f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0134d	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv794[rsp]
  01354	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01358	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0135d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170375
  01364	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0136a	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  01372	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0137c	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01380	03 c8		 add	 ecx, eax
  01382	8b c1		 mov	 eax, ecx
  01384	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN69@s370_displ:

; 1091 :                               PTYPSTR( regs->cpuad ), regs->cpuad );
; 1092 : 
; 1093 :             if (REAL_MODE( &regs->psw ))

  01388	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0138d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01391	83 e0 08	 and	 eax, 8
  01394	85 c0		 test	 eax, eax
  01396	74 10		 je	 SHORT $LN72@s370_displ
  01398	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0139d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  013a1	83 e0 04	 and	 eax, 4
  013a4	85 c0		 test	 eax, eax
  013a6	75 62		 jne	 SHORT $LN70@s370_displ
$LN72@s370_displ:

; 1094 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  013a8	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  013ad	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  013b2	48 2b c8	 sub	 rcx, rax
  013b5	48 8b c1	 mov	 rax, rcx
  013b8	48 ff c8	 dec	 rax
  013bb	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  013c0	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  013c8	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  013d0	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  013d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170379
  013dc	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  013e1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  013e9	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR [rsp+32], -2
  013f1	4c 8b c8	 mov	 r9, rax
  013f4	4c 8b c1	 mov	 r8, rcx
  013f7	8b 54 24 74	 mov	 edx, DWORD PTR addr1$[rsp]
  013fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01400	e8 00 00 00 00	 call	 s370_display_virt
  01405	e9 ee 00 00 00	 jmp	 $LN71@s370_displ
$LN70@s370_displ:

; 1095 :                                           USE_REAL_ADDR, ACCTYPE_HW, "", &xcode );
; 1096 :             else
; 1097 :                 ARCH_DEP( display_virt )( regs, addr1, buf2+n, sizeof( buf2 )-n-1,

  0140a	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0140f	83 f8 44	 cmp	 eax, 68			; 00000044H
  01412	74 79		 je	 SHORT $LN116@s370_displ
  01414	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01419	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  0141e	75 39		 jne	 SHORT $LN115@s370_displ
  01420	b8 01 00 00 00	 mov	 eax, 1
  01425	48 6b c0 01	 imul	 rax, rax, 1
  01429	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01431	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01435	83 e0 0f	 and	 eax, 15
  01438	85 c0		 test	 eax, eax
  0143a	75 1d		 jne	 SHORT $LN115@s370_displ
  0143c	b8 01 00 00 00	 mov	 eax, 1
  01441	48 6b c0 04	 imul	 rax, rax, 4
  01445	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0144a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  01452	83 e0 10	 and	 eax, 16
  01455	85 c0		 test	 eax, eax
  01457	75 34		 jne	 SHORT $LN116@s370_displ
$LN115@s370_displ:
  01459	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  0145e	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  01463	75 0d		 jne	 SHORT $LN117@s370_displ
  01465	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv850[rsp], 0
  01470	eb 0b		 jmp	 SHORT $LN118@s370_displ
$LN117@s370_displ:
  01472	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv850[rsp], 0
$LN118@s370_displ:
  0147d	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv850[rsp]
  01484	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv851[rsp], eax
  0148b	eb 0b		 jmp	 SHORT $LN119@s370_displ
$LN116@s370_displ:
  0148d	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv851[rsp], 0
$LN119@s370_displ:
  01498	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  0149d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  014a2	48 2b c8	 sub	 rcx, rax
  014a5	48 8b c1	 mov	 rax, rcx
  014a8	48 ff c8	 dec	 rax
  014ab	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  014b0	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  014b8	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  014c0	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  014c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170380
  014cc	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  014d1	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR tv851[rsp]
  014d8	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  014dc	8b 54 24 78	 mov	 edx, DWORD PTR b1$[rsp]
  014e0	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  014e4	4c 8b c8	 mov	 r9, rax
  014e7	4c 8b c1	 mov	 r8, rcx
  014ea	8b 54 24 74	 mov	 edx, DWORD PTR addr1$[rsp]
  014ee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  014f3	e8 00 00 00 00	 call	 s370_display_virt
$LN71@s370_displ:

; 1098 :                                           b1, (opcode == 0x44                 // EX?
; 1099 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1100 :                                  || (opcode == 0xc6 && !(inst[1] & 0x0f) &&
; 1101 :                                      FACILITY_ENABLED( 035_EXECUTE_EXTN, regs )) // EXRL?
; 1102 : #endif
; 1103 :                                                     ? ACCTYPE_HW :     // EX/EXRL
; 1104 :                                      opcode == 0xB1 ? ACCTYPE_HW :
; 1105 :                                                       ACCTYPE_HW ), "", &xcode );
; 1106 : 
; 1107 :             MSGBUF( op1_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  014f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170381
  014ff	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  01507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  0150d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01512	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170382
  01519	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170383
  01520	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01525	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  0152d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN67@s370_displ:

; 1108 :         }
; 1109 : 
; 1110 :         /* Format storage at second storage operand location */
; 1111 :         if (b2 >= 0)

  01533	83 7c 24 7c 00	 cmp	 DWORD PTR b2$[rsp], 0
  01538	0f 8c 84 02 00
	00		 jl	 $LN73@s370_displ

; 1112 :         {
; 1113 :             int ar = b2;

  0153e	8b 44 24 7c	 mov	 eax, DWORD PTR b2$[rsp]
  01542	89 84 24 b4 00
	00 00		 mov	 DWORD PTR ar$2[rsp], eax

; 1114 :             n = 0;

  01549	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 1115 :             buf2[0] = '\0';

  01551	b8 01 00 00 00	 mov	 eax, 1
  01556	48 6b c0 00	 imul	 rax, rax, 0
  0155a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR $T9[rsp], rax
  01562	48 81 bc 24 08
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR $T9[rsp], 512	; 00000200H
  0156e	73 02		 jae	 SHORT $LN120@s370_displ
  01570	eb 05		 jmp	 SHORT $LN121@s370_displ
$LN120@s370_displ:
  01572	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN121@s370_displ:
  01577	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  0157f	c6 84 04 40 03
	00 00 00	 mov	 BYTE PTR buf2$[rsp+rax], 0

; 1116 : 
; 1117 : #if defined(_FEATURE_SIE)
; 1118 :             if (SIE_MODE( regs ))

  01587	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0158c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01592	d1 e8		 shr	 eax, 1
  01594	83 e0 01	 and	 eax, 1
  01597	85 c0		 test	 eax, eax
  01599	74 2b		 je	 SHORT $LN74@s370_displ

; 1119 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "SIE: " );

  0159b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170386
  015a2	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  015a8	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  015b0	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  015b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  015ba	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  015be	03 c8		 add	 ecx, eax
  015c0	8b c1		 mov	 eax, ecx
  015c2	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN74@s370_displ:

; 1120 : #endif
; 1121 :             if (sysblk.cpus > 1)

  015c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015cd	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  015d4	7e 6f		 jle	 SHORT $LN75@s370_displ

; 1122 :                 n += idx_snprintf( n, buf2, sizeof( buf2 ), "%s%02X: ",

  015d6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  015db	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  015e2	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv888[rsp], eax
  015e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  015ee	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  015f5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  015fc	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0160a	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv888[rsp]
  01611	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01615	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0161a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170388
  01621	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01627	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  0162f	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  01633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01639	8b 4c 24 64	 mov	 ecx, DWORD PTR n$[rsp]
  0163d	03 c8		 add	 ecx, eax
  0163f	8b c1		 mov	 eax, ecx
  01641	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax
$LN75@s370_displ:

; 1123 :                                PTYPSTR( regs->cpuad ), regs->cpuad );
; 1124 :             if (0
; 1125 :                 || REAL_MODE( &regs->psw )
; 1126 :                 || IS_REAL_ADDR_OP( opcode, inst[1] )

  01645	33 c0		 xor	 eax, eax
  01647	85 c0		 test	 eax, eax
  01649	0f 85 ca 00 00
	00		 jne	 $LN77@s370_displ
  0164f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01654	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01658	83 e0 08	 and	 eax, 8
  0165b	85 c0		 test	 eax, eax
  0165d	0f 84 b6 00 00
	00		 je	 $LN77@s370_displ
  01663	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  01668	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0166c	83 e0 04	 and	 eax, 4
  0166f	85 c0		 test	 eax, eax
  01671	0f 84 a2 00 00
	00		 je	 $LN77@s370_displ
  01677	33 c0		 xor	 eax, eax
  01679	85 c0		 test	 eax, eax
  0167b	0f 85 98 00 00
	00		 jne	 $LN78@s370_displ
  01681	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  01686	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  0168b	75 1a		 jne	 SHORT $LN79@s370_displ
  0168d	b8 01 00 00 00	 mov	 eax, 1
  01692	48 6b c0 01	 imul	 rax, rax, 1
  01696	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0169e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  016a2	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  016a5	74 72		 je	 SHORT $LN78@s370_displ
$LN79@s370_displ:
  016a7	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016ac	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  016b1	75 1a		 jne	 SHORT $LN80@s370_displ
  016b3	b8 01 00 00 00	 mov	 eax, 1
  016b8	48 6b c0 01	 imul	 rax, rax, 1
  016bc	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  016c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  016c8	83 f8 46	 cmp	 eax, 70			; 00000046H
  016cb	74 4c		 je	 SHORT $LN78@s370_displ
$LN80@s370_displ:
  016cd	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016d2	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  016d7	75 1a		 jne	 SHORT $LN81@s370_displ
  016d9	b8 01 00 00 00	 mov	 eax, 1
  016de	48 6b c0 01	 imul	 rax, rax, 1
  016e2	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  016ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  016ee	83 f8 05	 cmp	 eax, 5
  016f1	74 26		 je	 SHORT $LN78@s370_displ
$LN81@s370_displ:
  016f3	0f b6 44 24 60	 movzx	 eax, BYTE PTR opcode$[rsp]
  016f8	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  016fd	75 25		 jne	 SHORT $LN76@s370_displ
  016ff	b8 01 00 00 00	 mov	 eax, 1
  01704	48 6b c0 01	 imul	 rax, rax, 1
  01708	48 8b 8c 24 68
	15 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  01710	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01714	83 f8 25	 cmp	 eax, 37			; 00000025H
  01717	75 0b		 jne	 SHORT $LN76@s370_displ
$LN78@s370_displ:
$LN77@s370_displ:

; 1127 :             )
; 1128 :                 ar = USE_REAL_ADDR;

  01719	c7 84 24 b4 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR ar$2[rsp], -2
$LN76@s370_displ:

; 1129 : 
; 1130 :             ARCH_DEP( display_virt )( regs, addr2, buf2+n, sizeof( buf2 )-n-1,

  01724	48 63 44 24 64	 movsxd	 rax, DWORD PTR n$[rsp]
  01729	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0172e	48 2b c8	 sub	 rcx, rax
  01731	48 8b c1	 mov	 rax, rcx
  01734	48 ff c8	 dec	 rax
  01737	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR n$[rsp]
  0173c	48 8d 8c 0c 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp+rcx]
  01744	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR xcode$[rsp]
  0174c	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  01751	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170395
  01758	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  0175d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  01765	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR ar$2[rsp]
  0176c	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01770	4c 8b c8	 mov	 r9, rax
  01773	4c 8b c1	 mov	 r8, rcx
  01776	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr2$[rsp]
  0177d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01782	e8 00 00 00 00	 call	 s370_display_virt

; 1131 :                                       ar, ACCTYPE_HW, "", &xcode );
; 1132 : 
; 1133 :             MSGBUF( op2_stor_msg, MSG( HHC02326, "I", RTRIM( buf2 )));

  01787	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170396
  0178e	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf2$[rsp]
  01796	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  0179c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017a1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170397
  017a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170398
  017af	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  017b4	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  017bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN73@s370_displ:
$LN66@s370_displ:

; 1134 :         }
; 1135 :     }
; 1136 : 
; 1137 :     if (trace2file)

  017c2	0f b6 44 24 70	 movzx	 eax, BYTE PTR trace2file$[rsp]
  017c7	85 c0		 test	 eax, eax
  017c9	74 47		 je	 SHORT $LN82@s370_displ

; 1138 :     {
; 1139 :         display_inst_regs( true, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  017cb	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  017d3	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  017db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017e0	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  017e6	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  017ee	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  017f3	b1 01		 mov	 cl, 1
  017f5	e8 00 00 00 00	 call	 display_inst_regs

; 1140 :         tf_2324( regs, inst );

  017fa	48 8b 94 24 68
	15 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  01802	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  01807	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2324

; 1141 :     }

  0180d	e9 ac 01 00 00	 jmp	 $LN83@s370_displ
$LN82@s370_displ:

; 1142 :     else
; 1143 :     {
; 1144 :         /* Format registers associated with the instruction */
; 1145 :         if (!sysblk.showregsnone)

  01812	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01819	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0181f	c1 e8 11	 shr	 eax, 17
  01822	83 e0 01	 and	 eax, 1
  01825	85 c0		 test	 eax, eax
  01827	75 2f		 jne	 SHORT $LN84@s370_displ

; 1146 :             display_inst_regs( false, regs, inst, opcode, regs_msg_buf, sizeof( regs_msg_buf )-1 );

  01829	c7 44 24 28 ff
	07 00 00	 mov	 DWORD PTR [rsp+40], 2047 ; 000007ffH
  01831	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR regs_msg_buf$[rsp]
  01839	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0183e	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR opcode$[rsp]
  01844	4c 8b 84 24 68
	15 00 00	 mov	 r8, QWORD PTR inst$[rsp]
  0184c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  01851	33 c9		 xor	 ecx, ecx
  01853	e8 00 00 00 00	 call	 display_inst_regs
$LN84@s370_displ:

; 1147 : 
; 1148 :         if (sysblk.showregsfirst)

  01858	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0185f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01865	c1 e8 10	 shr	 eax, 16
  01868	83 e0 01	 and	 eax, 1
  0186b	85 c0		 test	 eax, eax
  0186d	74 58		 je	 SHORT $LN85@s370_displ

; 1149 :         {
; 1150 :             /* Remove unwanted extra trailing newline from regs_msg_buf */
; 1151 :             size_t len = strlen( regs_msg_buf );

  0186f	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01877	e8 00 00 00 00	 call	 strlen
  0187c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR len$10[rsp], rax

; 1152 :             if (len)

  01884	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR len$10[rsp], 0
  0188d	74 38		 je	 SHORT $LN86@s370_displ

; 1153 :                 regs_msg_buf[ len-1 ] = 0;

  0188f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR len$10[rsp]
  01897	48 ff c8	 dec	 rax
  0189a	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR $T11[rsp], rax
  018a2	48 81 bc 24 18
	01 00 00 00 08
	00 00		 cmp	 QWORD PTR $T11[rsp], 2048 ; 00000800H
  018ae	73 02		 jae	 SHORT $LN122@s370_displ
  018b0	eb 05		 jmp	 SHORT $LN123@s370_displ
$LN122@s370_displ:
  018b2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN123@s370_displ:
  018b7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR $T11[rsp]
  018bf	c6 84 04 40 0d
	00 00 00	 mov	 BYTE PTR regs_msg_buf$[rsp+rax], 0
$LN86@s370_displ:
$LN85@s370_displ:

; 1154 :         }
; 1155 : 
; 1156 :         /* Now display all instruction tracing messages all at once */
; 1157 :         if (sysblk.showregsfirst)

  018c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  018ce	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  018d4	c1 e8 10	 shr	 eax, 16
  018d7	83 e0 01	 and	 eax, 1
  018da	85 c0		 test	 eax, eax
  018dc	74 71		 je	 SHORT $LN87@s370_displ

; 1158 :              LOGMSG( "%s%s%s%s", regs_msg_buf,

  018de	b9 01 00 00 00	 mov	 ecx, 1
  018e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018e9	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  018f1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  018f6	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  018fe	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01903	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  0190b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01910	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01918	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0191d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170406
  01924	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01929	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0192e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01934	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170407
  0193b	ba 87 04 00 00	 mov	 edx, 1159		; 00000487H
  01940	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170408
  01947	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0194d	eb 6f		 jmp	 SHORT $LN88@s370_displ
$LN87@s370_displ:

; 1159 :                                  psw_inst_msg, op1_stor_msg, op2_stor_msg );
; 1160 :         else LOGMSG( "%s%s%s%s", psw_inst_msg, op1_stor_msg, op2_stor_msg,

  0194f	b9 01 00 00 00	 mov	 ecx, 1
  01954	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0195a	48 8d 8c 24 40
	0d 00 00	 lea	 rcx, QWORD PTR regs_msg_buf$[rsp]
  01962	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01967	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR op2_stor_msg$[rsp]
  0196f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01974	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR op1_stor_msg$[rsp]
  0197c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01981	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR psw_inst_msg$[rsp]
  01989	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0198e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170409
  01995	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0199a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0199f	41 b9 03 00 00
	00		 mov	 r9d, 3
  019a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170410
  019ac	ba 89 04 00 00	 mov	 edx, 1161		; 00000489H
  019b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170411
  019b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN88@s370_displ:
$LN83@s370_displ:

; 1161 :                                  regs_msg_buf );
; 1162 :     }
; 1163 : 
; 1164 :     if (!iregs->ghostregs)

  019be	48 8b 84 24 60
	15 00 00	 mov	 rax, QWORD PTR iregs$[rsp]
  019c6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  019cc	c1 e8 0d	 shr	 eax, 13
  019cf	83 e0 01	 and	 eax, 1
  019d2	85 c0		 test	 eax, eax
  019d4	75 0b		 jne	 SHORT $LN89@s370_displ

; 1165 :         free_aligned( regs );

  019d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  019db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN89@s370_displ:
$LN1@s370_displ:
$LN90@s370_displ:

; 1166 : 
; 1167 : } /* end function display_inst_adj */

  019e1	48 8b 8c 24 40
	15 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  019e9	48 33 cc	 xor	 rcx, rsp
  019ec	e8 00 00 00 00	 call	 __security_check_cookie
  019f1	48 81 c4 50 15
	00 00		 add	 rsp, 5456		; 00001550H
  019f8	5f		 pop	 rdi
  019f9	c3		 ret	 0
s370_display_inst_adj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 96
xcode$ = 100
arn$ = 104
addrwid$1 = 108
raddr$ = 112
vaddr$ = 120
i$ = 124
stid$ = 128
saddr$ = 136
tv89 = 144
len$ = 148
aaddr$ = 152
totamt$ = 160
tv250 = 168
eaddr$ = 176
pageamt$2 = 184
opnd$ = 192
pageadr$3 = 200
tv191 = 208
tv274 = 212
pageoff$4 = 216
tv215 = 224
tv298 = 232
maxadr$ = 240
tv187 = 248
tv270 = 256
trans$ = 264
newval$ = 280
buf$ = 320
__$ArrayPad$ = 416
regs$ = 448
argc$ = 456
argv$ = 464
cmdline$ = 472
s370_alter_display_virt PROC

; 626  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 627  : char*   opnd;                           /* range/alteration operand  */
; 628  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 629  : U64     maxadr;                         /* Highest virt storage addr */
; 630  : VADR    vaddr;                          /* Virtual storage address   */
; 631  : RADR    raddr;                          /* Real storage address      */
; 632  : RADR    aaddr;                          /* Absolute storage address  */
; 633  : int     stid;                           /* Segment table indication  */
; 634  : int     len;                            /* Number of bytes to alter  */
; 635  : int     i;                              /* Loop counter              */
; 636  : int     arn = 0;                        /* Access register number    */

  0002c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
$LN4@s370_alter:

; 637  : U16     xcode;                          /* Exception code            */
; 638  : char    trans[16];                      /* Address translation mode  */
; 639  : BYTE    newval[32];                     /* Storage alteration value  */
; 640  : char    buf[96];                        /* Message buffer            */
; 641  : char    type;                           /* optional addr-space type  */
; 642  : size_t  totamt;                         /* Total amount to be dumped */
; 643  : 
; 644  :     UNREFERENCED(cmdline);

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN4@s370_alter

; 645  : 
; 646  :     /* We require only one operand */
; 647  :     if (argc != 1)

  0003a	83 bc 24 c8 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00042	74 4c		 je	 SHORT $LN22@s370_alter

; 648  :     {
; 649  :         // "Missing or invalid argument(s)"
; 650  :         WRMSG( HHC17000, "E" );

  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170131
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170132
  00062	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00067	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170133
  00079	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170134
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :         return;

  0008b	e9 06 09 00 00	 jmp	 $LN1@s370_alter
$LN22@s370_alter:

; 652  :     }
; 653  : 
; 654  :     /* Parse optional address-space prefix */
; 655  :     opnd = argv[0];

  00090	b8 08 00 00 00	 mov	 eax, 8
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a5	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 656  :     type = toupper( *opnd );

  000ad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c0	88 44 24 60	 mov	 BYTE PTR type$[rsp], al

; 657  : 
; 658  :     if (1
; 659  :         && type != 'P'
; 660  :         && type != 'S'
; 661  :         && type != 'H'

  000c4	33 c0		 xor	 eax, eax
  000c6	83 f8 01	 cmp	 eax, 1
  000c9	74 28		 je	 SHORT $LN23@s370_alter
  000cb	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000d0	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d3	74 1e		 je	 SHORT $LN23@s370_alter
  000d5	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000da	83 f8 53	 cmp	 eax, 83			; 00000053H
  000dd	74 14		 je	 SHORT $LN23@s370_alter
  000df	0f be 44 24 60	 movsx	 eax, BYTE PTR type$[rsp]
  000e4	83 f8 48	 cmp	 eax, 72			; 00000048H
  000e7	74 0a		 je	 SHORT $LN23@s370_alter

; 662  :     )
; 663  :         arn = 0;

  000e9	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR arn$[rsp], 0
  000f1	eb 5b		 jmp	 SHORT $LN24@s370_alter
$LN23@s370_alter:

; 664  :     else
; 665  :     {
; 666  :         switch (type)

  000f3	0f b6 44 24 60	 movzx	 eax, BYTE PTR type$[rsp]
  000f8	88 84 24 90 00
	00 00		 mov	 BYTE PTR tv89[rsp], al
  000ff	80 bc 24 90 00
	00 00 48	 cmp	 BYTE PTR tv89[rsp], 72	; 00000048H
  00107	74 2a		 je	 SHORT $LN27@s370_alter
  00109	80 bc 24 90 00
	00 00 50	 cmp	 BYTE PTR tv89[rsp], 80	; 00000050H
  00111	74 0c		 je	 SHORT $LN25@s370_alter
  00113	80 bc 24 90 00
	00 00 53	 cmp	 BYTE PTR tv89[rsp], 83	; 00000053H
  0011b	74 0c		 je	 SHORT $LN26@s370_alter
  0011d	eb 1c		 jmp	 SHORT $LN5@s370_alter
$LN25@s370_alter:

; 667  :         {
; 668  :             case 'P': arn = USE_PRIMARY_SPACE;   break;

  0011f	c7 44 24 68 fd
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -3
  00127	eb 12		 jmp	 SHORT $LN5@s370_alter
$LN26@s370_alter:

; 669  :             case 'S': arn = USE_SECONDARY_SPACE; break;

  00129	c7 44 24 68 fc
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -4
  00131	eb 08		 jmp	 SHORT $LN5@s370_alter
$LN27@s370_alter:

; 670  :             case 'H': arn = USE_HOME_SPACE;      break;

  00133	c7 44 24 68 fb
	ff ff ff	 mov	 DWORD PTR arn$[rsp], -5
$LN5@s370_alter:

; 671  :         }
; 672  :         opnd++;

  0013b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  00143	48 ff c0	 inc	 rax
  00146	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
$LN24@s370_alter:

; 673  :     }
; 674  : 
; 675  :     /* Set limit for address range */
; 676  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 677  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 678  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 679  :     maxadr = 0x7FFFFFFF;

  0014e	48 c7 84 24 f0
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 680  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 681  : 
; 682  :     /* Parse the range or alteration operand */
; 683  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  0015a	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  0016f	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR saddr$[rsp]
  00177	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  0017f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  00187	e8 00 00 00 00	 call	 parse_range
  0018c	89 84 24 94 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 684  :     if (len < 0) return;

  00193	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0019b	7d 05		 jge	 SHORT $LN28@s370_alter
  0019d	e9 f4 07 00 00	 jmp	 $LN1@s370_alter
$LN28@s370_alter:

; 685  : 
; 686  :     if (regs->mainlim == 0)

  001a2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001b2	75 61		 jne	 SHORT $LN29@s370_alter

; 687  :     {
; 688  :         // "%c:"F_RADR"  Storage address is not valid"
; 689  :         WRMSG( HHC02327, "E", 'V', saddr );

  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001cc	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170142
  001db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170143
  001e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170144
  001fe	ba b1 02 00 00	 mov	 edx, 689		; 000002b1H
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170145
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 690  :         return;

  00210	e9 81 07 00 00	 jmp	 $LN1@s370_alter
$LN29@s370_alter:

; 691  :     }
; 692  : 
; 693  :     /* Alter virtual storage */
; 694  :     if (len > 0
; 695  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, arn, regs, ACCTYPE_HW) == 0
; 696  :         && ARCH_DEP(virt_to_real) (&raddr, &stid, eaddr, arn, regs, ACCTYPE_HW) == 0

  00215	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0021d	0f 8e cd 02 00
	00		 jle	 $LN30@s370_alter
  00223	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0022b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00238	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0023d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR saddr$[rsp]
  00245	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  0024d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00252	e8 00 00 00 00	 call	 s370_virt_to_real
  00257	85 c0		 test	 eax, eax
  00259	0f 85 91 02 00
	00		 jne	 $LN30@s370_alter
  0025f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00267	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  00279	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR eaddr$[rsp]
  00281	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00289	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0028e	e8 00 00 00 00	 call	 s370_virt_to_real
  00293	85 c0		 test	 eax, eax
  00295	0f 85 55 02 00
	00		 jne	 $LN30@s370_alter

; 697  :     )
; 698  :     {
; 699  :         for (i=0; i < len; i++)

  0029b	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN9@s370_alter
$LN7@s370_alter:
  002a5	8b 44 24 7c	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 7c	 mov	 DWORD PTR i$[rsp], eax
$LN9@s370_alter:
  002af	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002b6	39 44 24 7c	 cmp	 DWORD PTR i$[rsp], eax
  002ba	0f 8d 30 02 00
	00		 jge	 $LN8@s370_alter

; 700  :         {
; 701  :             /* Address of next byte */
; 702  :             vaddr = saddr + i;

  002c0	48 63 44 24 7c	 movsxd	 rax, DWORD PTR i$[rsp]
  002c5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  002cd	48 03 c8	 add	 rcx, rax
  002d0	48 8b c1	 mov	 rax, rcx
  002d3	89 44 24 78	 mov	 DWORD PTR vaddr$[rsp], eax

; 703  : 
; 704  :             /* Convert virtual address to real address */
; 705  :             xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, vaddr,

  002d7	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  002db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002e3	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002f0	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  002f5	44 8b c0	 mov	 r8d, eax
  002f8	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00300	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  00305	e8 00 00 00 00	 call	 s370_virt_to_real
  0030a	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 706  :                 arn, regs, ACCTYPE_HW);
; 707  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  0030f	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  00318	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  00320	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR stid$[rsp]
  00328	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  0032c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00334	e8 00 00 00 00	 call	 s370_bldtrans

; 708  : 
; 709  :             /* Check for Translation Exception */
; 710  :             if (0 != xcode)

  00339	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  0033e	85 c0		 test	 eax, eax
  00340	0f 84 a2 00 00
	00		 je	 $LN31@s370_alter

; 711  :             {
; 712  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 713  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  00346	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  0034b	8b c8		 mov	 ecx, eax
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00353	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  0035b	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00360	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv191[rsp], ecx
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00372	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  0037a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0037f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv187[rsp]
  00387	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0038c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv191[rsp]
  00393	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00397	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0039b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0039f	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170148
  003ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170149
  003ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170150
  003d1	ba ca 02 00 00	 mov	 edx, 714		; 000002caH
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170151
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 714  :                     trans );
; 715  :                 return;

  003e3	e9 ae 05 00 00	 jmp	 $LN1@s370_alter
$LN31@s370_alter:

; 716  :             }
; 717  : 
; 718  :             /* Convert real address to absolute address */
; 719  :             aaddr = APPLY_PREFIXING (raddr, regs->PX);

  003e8	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  003ec	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  003f2	48 85 c0	 test	 rax, rax
  003f5	74 29		 je	 SHORT $LN44@s370_alter
  003f7	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  003fb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00401	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00409	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0040c	48 3b c1	 cmp	 rax, rcx
  0040f	74 0f		 je	 SHORT $LN44@s370_alter
  00411	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  00416	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  0041e	eb 1d		 jmp	 SHORT $LN45@s370_alter
$LN44@s370_alter:
  00420	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00428	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0042b	8b 4c 24 70	 mov	 ecx, DWORD PTR raddr$[rsp]
  0042f	33 c8		 xor	 ecx, eax
  00431	8b c1		 mov	 eax, ecx
  00433	8b c0		 mov	 eax, eax
  00435	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN45@s370_alter:
  0043d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  00445	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 720  : 
; 721  :             /* Check for addressing exception */
; 722  :             if (aaddr > regs->mainlim)

  0044d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00455	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0045c	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00464	76 5e		 jbe	 SHORT $LN32@s370_alter

; 723  :             {
; 724  :                 // "%c:"F_RADR"  Addressing exception"
; 725  :                 WRMSG( HHC02328, "E", 'R', raddr );

  00466	b9 01 00 00 00	 mov	 ecx, 1
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00471	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  00476	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0047b	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170153
  0048a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170154
  00496	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170155
  004ad	ba d5 02 00 00	 mov	 edx, 725		; 000002d5H
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170156
  004b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 726  :                 return;

  004bf	e9 d2 04 00 00	 jmp	 $LN1@s370_alter
$LN32@s370_alter:

; 727  :             }
; 728  : 
; 729  :             /* Update absolute storage */
; 730  :             regs->mainstor[aaddr] = newval[i];

  004c4	48 63 44 24 7c	 movsxd	 rax, DWORD PTR i$[rsp]
  004c9	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d1	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  004d8	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  004e0	0f b6 84 04 18
	01 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  004e8	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 731  :         }

  004eb	e9 b5 fd ff ff	 jmp	 $LN7@s370_alter
$LN8@s370_alter:
$LN30@s370_alter:
$LN12@s370_alter:

; 732  :     }
; 733  : 
; 734  :     /* Limit the amount to be displayed to a reasonable value */
; 735  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  004f0	48 81 bc 24 b0
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  004fc	76 2e		 jbe	 SHORT $LN33@s370_alter
  004fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00506	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  0050c	48 3b 84 24 88
	00 00 00	 cmp	 rax, QWORD PTR saddr$[rsp]
  00514	76 16		 jbe	 SHORT $LN33@s370_alter
  00516	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0051e	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00524	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@s370_alter:
  0052c	33 c0		 xor	 eax, eax
  0052e	85 c0		 test	 eax, eax
  00530	75 be		 jne	 SHORT $LN12@s370_alter

; 736  : 
; 737  :     /* Display virtual storage */
; 738  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  00532	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0053a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  00542	48 2b c8	 sub	 rcx, rax
  00545	48 8b c1	 mov	 rax, rcx
  00548	48 ff c0	 inc	 rax
  0054b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  00553	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  0055c	0f 86 34 04 00
	00		 jbe	 $LN34@s370_alter

; 739  :     {
; 740  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  00562	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR saddr$[rsp]
  0056a	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  00570	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 741  :         size_t  pageoff  = saddr - pageadr;

  00578	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00580	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR saddr$[rsp]
  00588	48 2b c8	 sub	 rcx, rax
  0058b	48 8b c1	 mov	 rax, rcx
  0058e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 742  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  00596	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  0059b	48 2b 84 24 d8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  005a3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 743  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  005ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b2	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  005b9	75 0d		 jne	 SHORT $LN46@s370_alter
  005bb	c7 84 24 a8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv250[rsp], 64 ; 00000040H
  005c6	eb 0b		 jmp	 SHORT $LN47@s370_alter
$LN46@s370_alter:
  005c8	c7 84 24 a8 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv250[rsp], 32 ; 00000020H
$LN47@s370_alter:
  005d3	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv250[rsp]
  005db	88 44 24 6c	 mov	 BYTE PTR addrwid$1[rsp], al
$LN13@s370_alter:

; 744  : 
; 745  :         /* Dump absolute storage one whole page at a time */
; 746  : 
; 747  :         for (;;)
; 748  :         {
; 749  :             /* Next page to be dumped */
; 750  :             vaddr = pageadr;

  005df	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR pageadr$3[rsp]
  005e6	89 44 24 78	 mov	 DWORD PTR vaddr$[rsp], eax

; 751  : 
; 752  :             /* Make sure we don't dump too much */
; 753  :             if (pageamt > totamt)

  005ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  005f2	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  005fa	76 10		 jbe	 SHORT $LN35@s370_alter

; 754  :                 pageamt = totamt;

  005fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR totamt$[rsp]
  00604	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@s370_alter:

; 755  : 
; 756  :             /* Convert virtual address to real address */
; 757  :             xcode = ARCH_DEP( virt_to_real )( &raddr, &stid, vaddr,

  0060c	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  00610	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00618	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00625	44 8b 4c 24 68	 mov	 r9d, DWORD PTR arn$[rsp]
  0062a	44 8b c0	 mov	 r8d, eax
  0062d	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR stid$[rsp]
  00635	48 8d 4c 24 70	 lea	 rcx, QWORD PTR raddr$[rsp]
  0063a	e8 00 00 00 00	 call	 s370_virt_to_real
  0063f	66 89 44 24 64	 mov	 WORD PTR xcode$[rsp], ax

; 758  :                 arn, regs, ACCTYPE_HW );
; 759  :             ARCH_DEP( bldtrans )(regs, arn, stid, trans, sizeof(trans));

  00644	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  0064d	4c 8d 8c 24 08
	01 00 00	 lea	 r9, QWORD PTR trans$[rsp]
  00655	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR stid$[rsp]
  0065d	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00661	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	e8 00 00 00 00	 call	 s370_bldtrans

; 760  : 
; 761  :             /* Check for Translation Exception */
; 762  :             if (0 != xcode)

  0066e	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00673	85 c0		 test	 eax, eax
  00675	0f 84 a2 00 00
	00		 je	 $LN36@s370_alter

; 763  :             {
; 764  :                 // "%c:"F_RADR"  Translation exception %4.4hX (%s)  %s"
; 765  :                 WRMSG( HHC02329, "E", 'V', vaddr, xcode, PIC2Name( xcode ),

  0067b	0f b7 44 24 64	 movzx	 eax, WORD PTR xcode$[rsp]
  00680	8b c8		 mov	 ecx, eax
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00688	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv270[rsp], rax
  00690	0f b7 4c 24 64	 movzx	 ecx, WORD PTR xcode$[rsp]
  00695	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv274[rsp], ecx
  0069c	b9 01 00 00 00	 mov	 ecx, 1
  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a7	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  006af	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  006bc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006c1	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  006c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006cc	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  006d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d4	c7 44 24 38 56
	00 00 00	 mov	 DWORD PTR [rsp+56], 86	; 00000056H
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170162
  006e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170163
  006ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170164
  00706	ba fe 02 00 00	 mov	 edx, 766		; 000002feH
  0070b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170165
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 766  :                     trans );
; 767  :             }

  00718	e9 1b 02 00 00	 jmp	 $LN37@s370_alter
$LN36@s370_alter:

; 768  :             else
; 769  :             {
; 770  :                 /* Convert real address to absolute address */
; 771  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  0071d	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  00721	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00727	48 85 c0	 test	 rax, rax
  0072a	74 29		 je	 SHORT $LN48@s370_alter
  0072c	8b 44 24 70	 mov	 eax, DWORD PTR raddr$[rsp]
  00730	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00736	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0073e	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00741	48 3b c1	 cmp	 rax, rcx
  00744	74 0f		 je	 SHORT $LN48@s370_alter
  00746	48 8b 44 24 70	 mov	 rax, QWORD PTR raddr$[rsp]
  0074b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rax
  00753	eb 1d		 jmp	 SHORT $LN49@s370_alter
$LN48@s370_alter:
  00755	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00760	8b 4c 24 70	 mov	 ecx, DWORD PTR raddr$[rsp]
  00764	33 c8		 xor	 ecx, eax
  00766	8b c1		 mov	 eax, ecx
  00768	8b c0		 mov	 eax, eax
  0076a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rax
$LN49@s370_alter:
  00772	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv298[rsp]
  0077a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 772  : 
; 773  :                 /* Check for addressing exception */
; 774  :                 if (aaddr > regs->mainlim)

  00782	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078a	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00791	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  00799	76 5e		 jbe	 SHORT $LN38@s370_alter

; 775  :                 {
; 776  :                     // "%c:"F_RADR"  Addressing exception"
; 777  :                     WRMSG( HHC02328, "E", 'R', raddr );

  0079b	b9 01 00 00 00	 mov	 ecx, 1
  007a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR raddr$[rsp]
  007ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007b0	c7 44 24 38 52
	00 00 00	 mov	 DWORD PTR [rsp+56], 82	; 00000052H
  007b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170167
  007bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170168
  007cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  007db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170169
  007e2	ba 09 03 00 00	 mov	 edx, 777		; 00000309H
  007e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170170
  007ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 778  :                     break;  /* (no sense in continuing) */

  007f4	e9 9d 01 00 00	 jmp	 $LN14@s370_alter
$LN38@s370_alter:

; 779  :                 }
; 780  : 
; 781  :                 /* Display storage key for page and how translated. Note: we
; 782  :                    use the internal "_get_storage_key" function here so that
; 783  :                    we can display our STORKEY_BADFRM bit too, if it's set.
; 784  :                 */
; 785  :                 MSGBUF( buf, "R:"F_RADR"  K:%2.2X  %s",

  007f9	b2 02		 mov	 dl, 2
  007fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00803	e8 00 00 00 00	 call	 s370__get_storage_key
  00808	0f b6 c0	 movzx	 eax, al
  0080b	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  00813	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00818	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0081c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR raddr$[rsp]
  00821	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170171
  00828	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0082d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00835	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 786  :                     raddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ), trans );
; 787  : 
; 788  :                 WRMSG( HHC02291, "I", buf );

  0083b	b9 01 00 00 00	 mov	 ecx, 1
  00840	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00846	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0084e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00853	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170172
  0085a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0085f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170173
  00866	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0086b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00870	41 b9 03 00 00
	00		 mov	 r9d, 3
  00876	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170174
  0087d	ba 14 03 00 00	 mov	 edx, 788		; 00000314H
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170175
  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@s370_alter:

; 789  : 
; 790  :                 /* Now hexdump that absolute page */
; 791  :                 VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, vaddr,

  0088f	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  00893	0f b6 4c 24 6c	 movzx	 ecx, BYTE PTR addrwid$1[rsp]
  00898	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  0089c	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  008a1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pageamt$2[rsp]
  008a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008ae	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  008b6	44 8b c0	 mov	 r8d, eax
  008b9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR aaddr$[rsp]
  008c1	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c9	e8 00 00 00 00	 call	 s370_dump_abs_page
  008ce	85 c0		 test	 eax, eax
  008d0	74 5c		 je	 SHORT $LN39@s370_alter
$LN21@s370_alter:
  008d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170177
  008d9	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  008df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170178
  008e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170179
  008ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  008f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  008f9	85 c0		 test	 eax, eax
  008fb	74 20		 je	 SHORT $LN40@s370_alter
  008fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170181
  00904	41 b8 18 03 00
	00		 mov	 r8d, 792		; 00000318H
  0090a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170182
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170183
  00918	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@s370_alter:
  0091d	33 c0		 xor	 eax, eax
  0091f	85 c0		 test	 eax, eax
  00921	75 af		 jne	 SHORT $LN21@s370_alter
  00923	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00929	85 c0		 test	 eax, eax
  0092b	74 01		 je	 SHORT $LN41@s370_alter
  0092d	cc		 int	 3
$LN41@s370_alter:
$LN39@s370_alter:
  0092e	33 c0		 xor	 eax, eax
  00930	85 c0		 test	 eax, eax
  00932	0f 85 57 ff ff
	ff		 jne	 $LN18@s370_alter
$LN37@s370_alter:

; 792  :                     pageoff, pageamt, 0, addrwid ) == 0);
; 793  :             }
; 794  : 
; 795  :             /* Check if we're done */
; 796  :             if (!(totamt -= pageamt))

  00938	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00940	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR totamt$[rsp]
  00948	48 2b c8	 sub	 rcx, rax
  0094b	48 8b c1	 mov	 rax, rcx
  0094e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR totamt$[rsp], rax
  00956	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR totamt$[rsp], 0
  0095f	75 02		 jne	 SHORT $LN42@s370_alter

; 797  :                 break;

  00961	eb 33		 jmp	 SHORT $LN14@s370_alter
$LN42@s370_alter:

; 798  : 
; 799  :             /* Go on to the next page */
; 800  :             pageoff =  0; // (from now on)

  00963	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 801  :             pageamt =  PAGEFRAME_PAGESIZE;

  0096f	48 c7 84 24 b8
	00 00 00 00 08
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 2048 ; 00000800H

; 802  :             pageadr += PAGEFRAME_PAGESIZE;

  0097b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  00983	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00989	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 803  :         }

  00991	e9 49 fc ff ff	 jmp	 $LN13@s370_alter
$LN14@s370_alter:
$LN34@s370_alter:
$LN1@s370_alter:

; 804  :     }
; 805  : 
; 806  : } /* end function alter_display_virt */

  00996	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0099e	48 33 cc	 xor	 rcx, rsp
  009a1	e8 00 00 00 00	 call	 __security_check_cookie
  009a6	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  009ad	c3		 ret	 0
s370_alter_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 48
regs$ = 80
arn$ = 88
stid$ = 96
trans$ = 104
size$ = 112
s370_bldtrans PROC

; 607  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 608  :     /* Build string indicating how virtual address was translated    */
; 609  : 
; 610  :     char    buf[16];  /* Caller's buffer should be at least this big */
; 611  : 
; 612  :          if (REAL_MODE( &regs->psw )) MSGBUF( buf, "%s", "(dat off)"   );

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0002f	83 e0 08	 and	 eax, 8
  00032	85 c0		 test	 eax, eax
  00034	74 10		 je	 SHORT $LN4@s370_bldtr
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0003f	83 e0 04	 and	 eax, 4
  00042	85 c0		 test	 eax, eax
  00044	75 23		 jne	 SHORT $LN2@s370_bldtr
$LN4@s370_bldtr:
  00046	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170055
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170056
  00054	ba 10 00 00 00	 mov	 edx, 16
  00059	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00064	e9 91 00 00 00	 jmp	 $LN3@s370_bldtr
$LN2@s370_bldtr:

; 613  :     else if (stid == TEA_ST_PRIMARY)  MSGBUF( buf, "%s", "(primary)"   );

  00069	83 7c 24 60 00	 cmp	 DWORD PTR stid$[rsp], 0
  0006e	75 20		 jne	 SHORT $LN5@s370_bldtr
  00070	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170059
  00077	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170060
  0007e	ba 10 00 00 00	 mov	 edx, 16
  00083	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0008e	eb 6a		 jmp	 SHORT $LN6@s370_bldtr
$LN5@s370_bldtr:

; 614  :     else if (stid == TEA_ST_SECNDRY)  MSGBUF( buf, "%s", "(secondary)" );

  00090	83 7c 24 60 02	 cmp	 DWORD PTR stid$[rsp], 2
  00095	75 20		 jne	 SHORT $LN7@s370_bldtr
  00097	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170063
  0009e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170064
  000a5	ba 10 00 00 00	 mov	 edx, 16
  000aa	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000b5	eb 43		 jmp	 SHORT $LN8@s370_bldtr
$LN7@s370_bldtr:

; 615  :     else if (stid == TEA_ST_HOME)     MSGBUF( buf, "%s", "(home)"      );

  000b7	83 7c 24 60 03	 cmp	 DWORD PTR stid$[rsp], 3
  000bc	75 20		 jne	 SHORT $LN9@s370_bldtr
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170067
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170068
  000cc	ba 10 00 00 00	 mov	 edx, 16
  000d1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000dc	eb 1c		 jmp	 SHORT $LN10@s370_bldtr
$LN9@s370_bldtr:

; 616  :     else                              MSGBUF( buf, "(AR%2.2d)", arn    );

  000de	44 8b 4c 24 58	 mov	 r9d, DWORD PTR arn$[rsp]
  000e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170069
  000ea	ba 10 00 00 00	 mov	 edx, 16
  000ef	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN10@s370_bldtr:
$LN8@s370_bldtr:
$LN6@s370_bldtr:
$LN3@s370_bldtr:

; 617  : 
; 618  :     strlcpy( trans, buf, size);

  000fa	4c 8b 44 24 70	 mov	 r8, QWORD PTR size$[rsp]
  000ff	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00104	48 8b 4c 24 68	 mov	 rcx, QWORD PTR trans$[rsp]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 619  : }

  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00114	48 33 cc	 xor	 rcx, rsp
  00117	e8 00 00 00 00	 call	 __security_check_cookie
  0011c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00120	c3		 ret	 0
s370_bldtrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 80
addrwid$1 = 84
raddr$ = 88
aaddr$ = 96
len$ = 104
saddr$ = 112
totamt$ = 120
tv211 = 128
pageamt$2 = 136
eaddr$ = 144
pageadr$3 = 152
tv145 = 160
pageoff$4 = 168
$T5 = 176
tv176 = 184
tv229 = 192
maxadr$ = 200
opnd$ = 208
absorr$ = 216
newval$ = 224
buf$ = 256
__$ArrayPad$ = 320
regs$ = 352
argc$ = 360
argv$ = 368
cmdline$ = 376
s370_alter_display_real_or_abs PROC

; 464  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_alter:

; 465  : char*   opnd;                           /* range/alteration operand  */
; 466  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 467  : U64     maxadr;                         /* Highest real storage addr */
; 468  : RADR    raddr;                          /* Real storage address      */
; 469  : RADR    aaddr;                          /* Absolute storage address  */
; 470  : size_t  totamt;                         /* Total amount to be dumped */
; 471  : int     len;                            /* Number of bytes to alter  */
; 472  : int     i;                              /* Loop counter              */
; 473  : BYTE    newval[32];                     /* Storage alteration value  */
; 474  : char    buf[64];                        /* MSGBUF work buffer        */
; 475  : char    absorr[8];                      /* Uppercase command         */
; 476  : 
; 477  :     UNREFERENCED(argc);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN4@s370_alter
$LN7@s370_alter:

; 478  :     UNREFERENCED(cmdline);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN7@s370_alter

; 479  : 
; 480  :     /* We require only one operand */
; 481  :     if (argc != 2)

  00038	83 bc 24 68 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00040	74 4c		 je	 SHORT $LN26@s370_alter

; 482  :     {
; 483  :         // "Missing or invalid argument(s)"
; 484  :         WRMSG( HHC17000, "E" );

  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169995
  00054	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169996
  00060	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169997
  00077	ba e4 01 00 00	 mov	 edx, 484		; 000001e4H
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169998
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 485  :         return;

  00089	e9 79 06 00 00	 jmp	 $LN1@s370_alter
$LN26@s370_alter:

; 486  :     }
; 487  : 
; 488  :     /* Convert command to uppercase */
; 489  :     for (i = 0; argv[0][i]; i++)

  0008e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00096	eb 0a		 jmp	 SHORT $LN10@s370_alter
$LN8@s370_alter:
  00098	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_alter:
  000a2	b8 08 00 00 00	 mov	 eax, 8
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b0	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000b8	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000bc	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000c0	85 c0		 test	 eax, eax
  000c2	74 34		 je	 SHORT $LN9@s370_alter

; 490  :         absorr[i] = toupper(argv[0][i]);

  000c4	b8 08 00 00 00	 mov	 eax, 8
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d2	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000da	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000de	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000e2	8b c8		 mov	 ecx, eax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000ea	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ef	88 84 0c d8 00
	00 00		 mov	 BYTE PTR absorr$[rsp+rcx], al
  000f6	eb a0		 jmp	 SHORT $LN8@s370_alter
$LN9@s370_alter:

; 491  :     absorr[i] = 0;

  000f8	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000fd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  00105	48 83 bc 24 b0
	00 00 00 08	 cmp	 QWORD PTR $T5[rsp], 8
  0010e	73 02		 jae	 SHORT $LN44@s370_alter
  00110	eb 05		 jmp	 SHORT $LN45@s370_alter
$LN44@s370_alter:
  00112	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN45@s370_alter:
  00117	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  0011f	c6 84 04 d8 00
	00 00 00	 mov	 BYTE PTR absorr$[rsp+rax], 0

; 492  :     opnd = argv[1];

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00138	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0013c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 493  : 
; 494  :     /* Set limit for address range */
; 495  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 496  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 497  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 498  :     maxadr = 0x7FFFFFFF;

  00144	48 c7 84 24 c8
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 499  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 500  : 
; 501  :     /* Parse the range or alteration operand */
; 502  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, newval);

  00150	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR newval$[rsp]
  00158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015d	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00165	4c 8d 44 24 70	 lea	 r8, QWORD PTR saddr$[rsp]
  0016a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00172	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  0017a	e8 00 00 00 00	 call	 parse_range
  0017f	89 44 24 68	 mov	 DWORD PTR len$[rsp], eax

; 503  :     if (len < 0) return;

  00183	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  00188	7d 05		 jge	 SHORT $LN27@s370_alter
  0018a	e9 78 05 00 00	 jmp	 $LN1@s370_alter
$LN27@s370_alter:

; 504  : 
; 505  :     if (regs->mainlim == 0)

  0018f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  0019f	75 79		 jne	 SHORT $LN28@s370_alter

; 506  :     {
; 507  :         // "%c:"F_RADR"  Storage address is not valid"
; 508  :         WRMSG( HHC02327, "E", absorr[0], saddr );

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 00	 imul	 rax, rax, 0
  001aa	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  001b2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  001b9	b9 01 00 00 00	 mov	 ecx, 1
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  001c9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ce	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001d5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170001
  001e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170002
  001ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170003
  00203	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170004
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 509  :         return;

  00215	e9 ed 04 00 00	 jmp	 $LN1@s370_alter
$LN28@s370_alter:

; 510  :     }
; 511  : 
; 512  :     /* Alter real or absolute storage */
; 513  :     if (len > 0)

  0021a	83 7c 24 68 00	 cmp	 DWORD PTR len$[rsp], 0
  0021f	0f 8e 58 01 00
	00		 jle	 $LN29@s370_alter

; 514  :     {
; 515  :         for (i=0; i < len; i++)

  00225	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0022d	eb 0a		 jmp	 SHORT $LN13@s370_alter
$LN11@s370_alter:
  0022f	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_alter:
  00239	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0023d	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00241	0f 8d 36 01 00
	00		 jge	 $LN12@s370_alter

; 516  :         {
; 517  :             /* Address of next byte */
; 518  :             raddr = saddr + i;

  00247	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0024c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00251	48 03 c8	 add	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 519  : 
; 520  :             /* Convert real address to absolute address */
; 521  :             if ('R' == absorr[0])

  0025c	b8 01 00 00 00	 mov	 eax, 1
  00261	48 6b c0 00	 imul	 rax, rax, 0
  00265	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  0026d	83 f8 52	 cmp	 eax, 82			; 00000052H
  00270	75 64		 jne	 SHORT $LN30@s370_alter

; 522  :                 aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00272	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  00276	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0027c	48 85 c0	 test	 rax, rax
  0027f	74 29		 je	 SHORT $LN46@s370_alter
  00281	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  00285	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0028b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00296	48 3b c1	 cmp	 rax, rcx
  00299	74 0f		 je	 SHORT $LN46@s370_alter
  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002a0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002a8	eb 1d		 jmp	 SHORT $LN47@s370_alter
$LN46@s370_alter:
  002aa	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002b5	8b 4c 24 58	 mov	 ecx, DWORD PTR raddr$[rsp]
  002b9	33 c8		 xor	 ecx, eax
  002bb	8b c1		 mov	 eax, ecx
  002bd	8b c0		 mov	 eax, eax
  002bf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
$LN47@s370_alter:
  002c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv176[rsp]
  002cf	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  002d4	eb 0a		 jmp	 SHORT $LN31@s370_alter
$LN30@s370_alter:

; 523  :             else
; 524  :                 aaddr = raddr; /* (is already absolute) */

  002d6	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  002db	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN31@s370_alter:

; 525  : 
; 526  :             /* Check for addressing exception */
; 527  :             if (aaddr > regs->mainlim)

  002e0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002ef	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  002f4	76 5e		 jbe	 SHORT $LN32@s370_alter

; 528  :             {
; 529  :                 // "%c:"F_RADR"  Addressing exception"
; 530  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  002f6	b9 01 00 00 00	 mov	 ecx, 1
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00301	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00306	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0030b	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170009
  0031a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170010
  00326	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00330	41 b9 03 00 00
	00		 mov	 r9d, 3
  00336	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170011
  0033d	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 531  :                 return;

  0034f	e9 b3 03 00 00	 jmp	 $LN1@s370_alter
$LN32@s370_alter:

; 532  :             }
; 533  : 
; 534  :             /* Update absolute storage */
; 535  :             regs->mainstor[aaddr] = newval[i];

  00354	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00359	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00368	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0036d	0f b6 84 04 e0
	00 00 00	 movzx	 eax, BYTE PTR newval$[rsp+rax]
  00375	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 536  : 
; 537  :         } /* end for(i) */

  00378	e9 b2 fe ff ff	 jmp	 $LN11@s370_alter
$LN12@s370_alter:
$LN29@s370_alter:
$LN16@s370_alter:

; 538  :     }
; 539  : 
; 540  :     /* Limit the amount to be displayed to a reasonable value */
; 541  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  0037d	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  00389	76 28		 jbe	 SHORT $LN33@s370_alter
  0038b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00393	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  00399	48 3b 44 24 70	 cmp	 rax, QWORD PTR saddr$[rsp]
  0039e	76 13		 jbe	 SHORT $LN33@s370_alter
  003a0	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003a5	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  003ab	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN33@s370_alter:
  003b3	33 c0		 xor	 eax, eax
  003b5	85 c0		 test	 eax, eax
  003b7	75 c4		 jne	 SHORT $LN16@s370_alter

; 542  : 
; 543  :     /* Display real or absolute storage */
; 544  :     if ((totamt = (eaddr - saddr) + 1) > 0)

  003b9	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR eaddr$[rsp]
  003c6	48 2b c8	 sub	 rcx, rax
  003c9	48 8b c1	 mov	 rax, rcx
  003cc	48 ff c0	 inc	 rax
  003cf	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  003d4	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  003da	0f 86 27 03 00
	00		 jbe	 $LN34@s370_alter

; 545  :     {
; 546  :         RADR    pageadr  = saddr & PAGEFRAME_PAGEMASK;

  003e0	48 8b 44 24 70	 mov	 rax, QWORD PTR saddr$[rsp]
  003e5	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  003eb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 547  :         size_t  pageoff  = saddr - pageadr;

  003f3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  003fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR saddr$[rsp]
  00400	48 2b c8	 sub	 rcx, rax
  00403	48 8b c1	 mov	 rax, rcx
  00406	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pageoff$4[rsp], rax

; 548  :         size_t  pageamt  = PAGEFRAME_PAGESIZE - pageoff;

  0040e	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00413	48 2b 84 24 a8
	00 00 00	 sub	 rax, QWORD PTR pageoff$4[rsp]
  0041b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax

; 549  :         BYTE    addrwid  = (ARCH_900_IDX == sysblk.arch_mode) ? 64: 32;

  00423	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0042a	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00431	75 0d		 jne	 SHORT $LN48@s370_alter
  00433	c7 84 24 80 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv211[rsp], 64 ; 00000040H
  0043e	eb 0b		 jmp	 SHORT $LN49@s370_alter
$LN48@s370_alter:
  00440	c7 84 24 80 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv211[rsp], 32 ; 00000020H
$LN49@s370_alter:
  0044b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR tv211[rsp]
  00453	88 44 24 54	 mov	 BYTE PTR addrwid$1[rsp], al
$LN17@s370_alter:

; 550  : 
; 551  :         /* Dump absolute storage one whole page at a time */
; 552  : 
; 553  :         for (;;)
; 554  :         {
; 555  :             /* Next page to be dumped */
; 556  :             raddr = pageadr;

  00457	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  0045f	48 89 44 24 58	 mov	 QWORD PTR raddr$[rsp], rax

; 557  : 
; 558  :             /* Make sure we don't dump too much */
; 559  :             if (pageamt > totamt)

  00464	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  00469	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR pageamt$2[rsp], rax
  00471	76 0d		 jbe	 SHORT $LN35@s370_alter

; 560  :                 pageamt = totamt;

  00473	48 8b 44 24 78	 mov	 rax, QWORD PTR totamt$[rsp]
  00478	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pageamt$2[rsp], rax
$LN35@s370_alter:

; 561  : 
; 562  :             /* Convert real address to absolute address */
; 563  :             if ('R' == absorr[0])

  00480	b8 01 00 00 00	 mov	 eax, 1
  00485	48 6b c0 00	 imul	 rax, rax, 0
  00489	0f be 84 04 d8
	00 00 00	 movsx	 eax, BYTE PTR absorr$[rsp+rax]
  00491	83 f8 52	 cmp	 eax, 82			; 00000052H
  00494	75 64		 jne	 SHORT $LN36@s370_alter

; 564  :                 aaddr = APPLY_PREFIXING( raddr, regs->PX );

  00496	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  0049a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  004a0	48 85 c0	 test	 rax, rax
  004a3	74 29		 je	 SHORT $LN50@s370_alter
  004a5	8b 44 24 58	 mov	 eax, DWORD PTR raddr$[rsp]
  004a9	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  004af	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b7	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  004ba	48 3b c1	 cmp	 rax, rcx
  004bd	74 0f		 je	 SHORT $LN50@s370_alter
  004bf	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004c4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  004cc	eb 1d		 jmp	 SHORT $LN51@s370_alter
$LN50@s370_alter:
  004ce	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004d9	8b 4c 24 58	 mov	 ecx, DWORD PTR raddr$[rsp]
  004dd	33 c8		 xor	 ecx, eax
  004df	8b c1		 mov	 eax, ecx
  004e1	8b c0		 mov	 eax, eax
  004e3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
$LN51@s370_alter:
  004eb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv229[rsp]
  004f3	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
  004f8	eb 0a		 jmp	 SHORT $LN37@s370_alter
$LN36@s370_alter:

; 565  :             else
; 566  :                 aaddr = raddr; /* (is already absolute) */

  004fa	48 8b 44 24 58	 mov	 rax, QWORD PTR raddr$[rsp]
  004ff	48 89 44 24 60	 mov	 QWORD PTR aaddr$[rsp], rax
$LN37@s370_alter:

; 567  : 
; 568  :             /* Check for addressing exception */
; 569  :             if (aaddr > regs->mainlim)

  00504	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050c	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00513	48 39 44 24 60	 cmp	 QWORD PTR aaddr$[rsp], rax
  00518	76 5e		 jbe	 SHORT $LN38@s370_alter

; 570  :             {
; 571  :                 // "%c:"F_RADR"  Addressing exception"
; 572  :                 WRMSG( HHC02328, "E", 'A', aaddr );

  0051a	b9 01 00 00 00	 mov	 ecx, 1
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00525	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0052a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0052f	c7 44 24 38 41
	00 00 00	 mov	 DWORD PTR [rsp+56], 65	; 00000041H
  00537	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170019
  0053e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170020
  0054a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00554	41 b9 03 00 00
	00		 mov	 r9d, 3
  0055a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170021
  00561	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170022
  0056d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 573  :                 break;

  00573	e9 8f 01 00 00	 jmp	 $LN18@s370_alter
$LN38@s370_alter:

; 574  :             }
; 575  : 
; 576  :             /* Display storage key for this page. Note: we use the
; 577  :                internal "_get_storage_key" function here so that we
; 578  :                can display our STORKEY_BADFRM bit too, if it's set.
; 579  :             */
; 580  :             MSGBUF( buf, "A:"F_RADR"  K:%2.2X",

  00578	b2 02		 mov	 dl, 2
  0057a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0057f	e8 00 00 00 00	 call	 s370__get_storage_key
  00584	0f b6 c0	 movzx	 eax, al
  00587	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0058b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR aaddr$[rsp]
  00590	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170023
  00597	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0059c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 581  :                 aaddr, ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));
; 582  :             WRMSG( HHC02290, "I", buf );

  005aa	b9 01 00 00 00	 mov	 ecx, 1
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170024
  005c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170025
  005d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005df	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170026
  005ec	ba 46 02 00 00	 mov	 edx, 582		; 00000246H
  005f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170027
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@s370_alter:

; 583  : 
; 584  :             /* Now hexdump that absolute page */
; 585  :             VERIFY( ARCH_DEP( dump_abs_page )( regs, aaddr, raddr,

  005fe	b8 01 00 00 00	 mov	 eax, 1
  00603	48 6b c0 00	 imul	 rax, rax, 0
  00607	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR addrwid$1[rsp]
  0060c	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  00610	0f b6 84 04 d8
	00 00 00	 movzx	 eax, BYTE PTR absorr$[rsp+rax]
  00618	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0061c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  00624	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00629	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pageoff$4[rsp]
  00631	4c 8b 44 24 58	 mov	 r8, QWORD PTR raddr$[rsp]
  00636	48 8b 54 24 60	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0063b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00643	e8 00 00 00 00	 call	 s370_dump_abs_page
  00648	85 c0		 test	 eax, eax
  0064a	74 5c		 je	 SHORT $LN39@s370_alter
$LN25@s370_alter:
  0064c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170029
  00653	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00659	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170030
  00660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170031
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0066d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00673	85 c0		 test	 eax, eax
  00675	74 20		 je	 SHORT $LN40@s370_alter
  00677	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170033
  0067e	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00684	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170034
  0068b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170035
  00692	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@s370_alter:
  00697	33 c0		 xor	 eax, eax
  00699	85 c0		 test	 eax, eax
  0069b	75 af		 jne	 SHORT $LN25@s370_alter
  0069d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006a3	85 c0		 test	 eax, eax
  006a5	74 01		 je	 SHORT $LN41@s370_alter
  006a7	cc		 int	 3
$LN41@s370_alter:
$LN39@s370_alter:
  006a8	33 c0		 xor	 eax, eax
  006aa	85 c0		 test	 eax, eax
  006ac	0f 85 4c ff ff
	ff		 jne	 $LN22@s370_alter

; 586  :                 pageoff, pageamt, absorr[0], addrwid ) == 0);
; 587  : 
; 588  :             /* Check if we're done */
; 589  :             if (!(totamt -= pageamt))

  006b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pageamt$2[rsp]
  006ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totamt$[rsp]
  006bf	48 2b c8	 sub	 rcx, rax
  006c2	48 8b c1	 mov	 rax, rcx
  006c5	48 89 44 24 78	 mov	 QWORD PTR totamt$[rsp], rax
  006ca	48 83 7c 24 78
	00		 cmp	 QWORD PTR totamt$[rsp], 0
  006d0	75 02		 jne	 SHORT $LN42@s370_alter

; 590  :                 break;

  006d2	eb 33		 jmp	 SHORT $LN18@s370_alter
$LN42@s370_alter:

; 591  : 
; 592  :             /* Go on to the next page */
; 593  :             pageoff =  0; // (from now on)

  006d4	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pageoff$4[rsp], 0

; 594  :             pageamt =  PAGEFRAME_PAGESIZE;

  006e0	48 c7 84 24 88
	00 00 00 00 08
	00 00		 mov	 QWORD PTR pageamt$2[rsp], 2048 ; 00000800H

; 595  :             pageadr += PAGEFRAME_PAGESIZE;

  006ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pageadr$3[rsp]
  006f4	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  006fa	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pageadr$3[rsp], rax

; 596  :         }

  00702	e9 50 fd ff ff	 jmp	 $LN17@s370_alter
$LN18@s370_alter:
$LN34@s370_alter:
$LN1@s370_alter:
$LN43@s370_alter:

; 597  :     }
; 598  : 
; 599  : } /* end function alter_display_real_or_abs */

  00707	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0070f	48 33 cc	 xor	 rcx, rsp
  00712	e8 00 00 00 00	 call	 __security_check_cookie
  00717	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0071e	c3		 ret	 0
s370_alter_display_real_or_abs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
type$ = 64
len$ = 68
opcode$ = 72
xcode$ = 76
ilc$ = 80
stid$ = 84
saddr$ = 88
raddr$ = 96
tv131 = 104
tv227 = 108
tv228 = 112
tv268 = 116
tv269 = 120
tv270 = 124
aaddr$ = 128
opnd$ = 136
eaddr$ = 144
tv203 = 152
maxadr$ = 160
inst$ = 168
buf$ = 176
__$ArrayPad$ = 688
regs$ = 736
argc$ = 744
argv$ = 752
cmdline$ = 760
s370_disasm_stor PROC

; 333  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 334  : char*   opnd;                           /* Range/alteration operand  */
; 335  : U64     saddr, eaddr;                   /* Range start/end addresses */
; 336  : U64     maxadr;                         /* Highest real storage addr */
; 337  : RADR    raddr;                          /* Real storage address      */
; 338  : RADR    aaddr;                          /* Absolute storage address  */
; 339  : int     stid = -1;                      /* How translation was done  */

  0002e	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR stid$[rsp], -1
$LN4@s370_disas:

; 340  : int     len;                            /* Number of bytes to alter  */
; 341  : int     ilc;                            /* Instruction length counter*/
; 342  : BYTE    inst[6];                        /* Storage alteration value  */
; 343  : BYTE    opcode;                         /* Instruction opcode        */
; 344  : U16     xcode;                          /* Exception code            */
; 345  : char    type;                           /* Address space type        */
; 346  : char    buf[512];                       /* MSGBUF work buffer        */
; 347  : 
; 348  :     UNREFERENCED(cmdline);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN4@s370_disas

; 349  : 
; 350  :     /* We require only one operand */
; 351  :     if (argc != 1)

  0003c	83 bc 24 e8 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00044	74 4c		 je	 SHORT $LN10@s370_disas

; 352  :     {
; 353  :         // "Missing or invalid argument(s)"
; 354  :         WRMSG( HHC17000, "E" );

  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169886
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169887
  00064	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169888
  0007b	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169889
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 355  :         return;

  0008d	e9 0d 07 00 00	 jmp	 $LN1@s370_disas
$LN10@s370_disas:

; 356  :     }
; 357  : 
; 358  :     /* Parse optional address-space prefix */
; 359  :     opnd = argv[0];

  00092	b8 08 00 00 00	 mov	 eax, 8
  00097	48 6b c0 00	 imul	 rax, rax, 0
  0009b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a3	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000a7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax

; 360  :     type = toupper( *opnd );

  000af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  000c2	88 44 24 40	 mov	 BYTE PTR type$[rsp], al

; 361  : 
; 362  :     if (0
; 363  :         || type == 'R'
; 364  :         || type == 'V'
; 365  :         || type == 'P'
; 366  :         || type == 'H'

  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 28		 jne	 SHORT $LN13@s370_disas
  000cc	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000d1	83 f8 52	 cmp	 eax, 82			; 00000052H
  000d4	74 1e		 je	 SHORT $LN13@s370_disas
  000d6	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000db	83 f8 56	 cmp	 eax, 86			; 00000056H
  000de	74 14		 je	 SHORT $LN13@s370_disas
  000e0	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000e5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000e8	74 0a		 je	 SHORT $LN13@s370_disas
  000ea	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  000ef	83 f8 48	 cmp	 eax, 72			; 00000048H
  000f2	75 15		 jne	 SHORT $LN11@s370_disas
$LN13@s370_disas:

; 367  :     )
; 368  :         opnd++;

  000f4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opnd$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opnd$[rsp], rax
  00107	eb 41		 jmp	 SHORT $LN12@s370_disas
$LN11@s370_disas:

; 369  :     else
; 370  :         type = REAL_MODE( &regs->psw ) ? 'R' : 'V';

  00109	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00111	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 1d		 je	 SHORT $LN27@s370_disas
  0011c	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00128	83 e0 04	 and	 eax, 4
  0012b	85 c0		 test	 eax, eax
  0012d	74 0a		 je	 SHORT $LN27@s370_disas
  0012f	c7 44 24 68 56
	00 00 00	 mov	 DWORD PTR tv131[rsp], 86 ; 00000056H
  00137	eb 08		 jmp	 SHORT $LN28@s370_disas
$LN27@s370_disas:
  00139	c7 44 24 68 52
	00 00 00	 mov	 DWORD PTR tv131[rsp], 82 ; 00000052H
$LN28@s370_disas:
  00141	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv131[rsp]
  00146	88 44 24 40	 mov	 BYTE PTR type$[rsp], al
$LN12@s370_disas:

; 371  : 
; 372  :     /* Set limit for address range */
; 373  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 374  :     maxadr = 0xFFFFFFFFFFFFFFFFULL;
; 375  :   #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 376  :     maxadr = 0x7FFFFFFF;

  0014a	48 c7 84 24 a0
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR maxadr$[rsp], 2147483647 ; 7fffffffH

; 377  :   #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 378  : 
; 379  :     /* Parse the range or alteration operand */
; 380  :     len = parse_range (opnd, maxadr, &saddr, &eaddr, NULL);

  00156	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0015f	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR eaddr$[rsp]
  00167	4c 8d 44 24 58	 lea	 r8, QWORD PTR saddr$[rsp]
  0016c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR maxadr$[rsp]
  00174	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opnd$[rsp]
  0017c	e8 00 00 00 00	 call	 parse_range
  00181	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 381  :     if (len < 0) return;

  00185	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  0018a	7d 05		 jge	 SHORT $LN14@s370_disas
  0018c	e9 0e 06 00 00	 jmp	 $LN1@s370_disas
$LN14@s370_disas:

; 382  : 
; 383  :     if (regs->mainlim == 0)

  00191	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  001a1	75 58		 jne	 SHORT $LN15@s370_disas

; 384  :     {
; 385  :         WRMSG(HHC02289, "I", "Real address is not valid");

  001a3	b9 01 00 00 00	 mov	 ecx, 1
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  001b5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169896
  001c1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169897
  001cd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169898
  001e4	ba 81 01 00 00	 mov	 edx, 385		; 00000181H
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169899
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 386  :         return;

  001f6	e9 a4 05 00 00	 jmp	 $LN1@s370_disas
$LN15@s370_disas:
$LN7@s370_disas:

; 387  :     }
; 388  : 
; 389  :     /* Limit the amount to be displayed to a reasonable value */
; 390  :     LIMIT_RANGE( saddr, eaddr, _64_KILOBYTE );

  001fb	48 81 bc 24 90
	00 00 00 00 00
	01 00		 cmp	 QWORD PTR eaddr$[rsp], 65536 ; 00010000H
  00207	76 28		 jbe	 SHORT $LN16@s370_disas
  00209	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  00211	48 2d ff ff 00
	00		 sub	 rax, 65535		; 0000ffffH
  00217	48 3b 44 24 58	 cmp	 rax, QWORD PTR saddr$[rsp]
  0021c	76 13		 jbe	 SHORT $LN16@s370_disas
  0021e	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00223	48 05 ff ff 00
	00		 add	 rax, 65535		; 0000ffffH
  00229	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eaddr$[rsp], rax
$LN16@s370_disas:
  00231	33 c0		 xor	 eax, eax
  00233	85 c0		 test	 eax, eax
  00235	75 c4		 jne	 SHORT $LN7@s370_disas
$LN8@s370_disas:

; 391  : 
; 392  :     /* Display real storage */
; 393  :     while (saddr <= eaddr)

  00237	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eaddr$[rsp]
  0023f	48 39 44 24 58	 cmp	 QWORD PTR saddr$[rsp], rax
  00244	0f 87 55 05 00
	00		 ja	 $LN9@s370_disas

; 394  :     {
; 395  :         if(type == 'R')

  0024a	0f be 44 24 40	 movsx	 eax, BYTE PTR type$[rsp]
  0024f	83 f8 52	 cmp	 eax, 82			; 00000052H
  00252	75 0f		 jne	 SHORT $LN17@s370_disas

; 396  :             raddr = saddr;

  00254	48 8b 44 24 58	 mov	 rax, QWORD PTR saddr$[rsp]
  00259	48 89 44 24 60	 mov	 QWORD PTR raddr$[rsp], rax
  0025e	e9 d1 00 00 00	 jmp	 $LN18@s370_disas
$LN17@s370_disas:

; 397  :         else
; 398  :         {
; 399  :             /* Convert virtual address to real address */
; 400  :             if((xcode = ARCH_DEP(virt_to_real) (&raddr, &stid, saddr, 0, regs, ACCTYPE_HW) ))

  00263	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0026b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00273	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00278	45 33 c9	 xor	 r9d, r9d
  0027b	4c 8b 44 24 58	 mov	 r8, QWORD PTR saddr$[rsp]
  00280	48 8d 54 24 54	 lea	 rdx, QWORD PTR stid$[rsp]
  00285	48 8d 4c 24 60	 lea	 rcx, QWORD PTR raddr$[rsp]
  0028a	e8 00 00 00 00	 call	 s370_virt_to_real
  0028f	66 89 44 24 4c	 mov	 WORD PTR xcode$[rsp], ax
  00294	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  00299	85 c0		 test	 eax, eax
  0029b	0f 84 93 00 00
	00		 je	 $LN19@s370_disas

; 401  :             {
; 402  :                 MSGBUF( buf, "R:"F_RADR"  Storage not accessible code = %4.4X (%s)",

  002a1	0f b7 44 24 4c	 movzx	 eax, WORD PTR xcode$[rsp]
  002a6	8b c8		 mov	 ecx, eax
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  002ae	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR xcode$[rsp]
  002b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b8	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  002bc	4c 8b 4c 24 58	 mov	 r9, QWORD PTR saddr$[rsp]
  002c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169904
  002c8	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  002cd	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 403  :                     saddr, xcode, PIC2Name( xcode ));
; 404  :                 WRMSG( HHC02289, "I", buf );

  002db	b9 01 00 00 00	 mov	 ecx, 1
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  002ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169905
  002fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169906
  00306	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00310	41 b9 03 00 00
	00		 mov	 r9d, 3
  00316	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169907
  0031d	ba 94 01 00 00	 mov	 edx, 404		; 00000194H
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169908
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  :                 return;

  0032f	e9 6b 04 00 00	 jmp	 $LN1@s370_disas
$LN19@s370_disas:
$LN18@s370_disas:

; 406  :             }
; 407  :         }
; 408  : 
; 409  :         /* Convert real address to absolute address */
; 410  :         aaddr = APPLY_PREFIXING (raddr, regs->PX);

  00334	8b 44 24 60	 mov	 eax, DWORD PTR raddr$[rsp]
  00338	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0033e	48 85 c0	 test	 rax, rax
  00341	74 29		 je	 SHORT $LN29@s370_disas
  00343	8b 44 24 60	 mov	 eax, DWORD PTR raddr$[rsp]
  00347	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0034d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00355	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00358	48 3b c1	 cmp	 rax, rcx
  0035b	74 0f		 je	 SHORT $LN29@s370_disas
  0035d	48 8b 44 24 60	 mov	 rax, QWORD PTR raddr$[rsp]
  00362	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
  0036a	eb 1d		 jmp	 SHORT $LN30@s370_disas
$LN29@s370_disas:
  0036c	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00374	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00377	8b 4c 24 60	 mov	 ecx, DWORD PTR raddr$[rsp]
  0037b	33 c8		 xor	 ecx, eax
  0037d	8b c1		 mov	 eax, ecx
  0037f	8b c0		 mov	 eax, eax
  00381	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv203[rsp], rax
$LN30@s370_disas:
  00389	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv203[rsp]
  00391	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR aaddr$[rsp], rax

; 411  :         if (aaddr > regs->mainlim)

  00399	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a1	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  003a8	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  003b0	76 78		 jbe	 SHORT $LN20@s370_disas

; 412  :         {
; 413  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", raddr );

  003b2	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  003b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169910
  003be	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  003c3	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 414  :             WRMSG( HHC02289, "I", buf );

  003d1	b9 01 00 00 00	 mov	 ecx, 1
  003d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003dc	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  003e4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169911
  003f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169912
  003fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00401	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00406	41 b9 03 00 00
	00		 mov	 r9d, 3
  0040c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169913
  00413	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169914
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 415  :             return;

  00425	e9 75 03 00 00	 jmp	 $LN1@s370_disas
$LN20@s370_disas:

; 416  :         }
; 417  : 
; 418  :         /* Determine opcode and check for addressing exception */
; 419  :         opcode = regs->mainstor[aaddr];

  0042a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00432	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00439	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00441	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00445	88 44 24 48	 mov	 BYTE PTR opcode$[rsp], al

; 420  :         ilc = ILC(opcode);

  00449	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  0044e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00451	7d 0a		 jge	 SHORT $LN33@s370_disas
  00453	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv228[rsp], 2
  0045b	eb 26		 jmp	 SHORT $LN34@s370_disas
$LN33@s370_disas:
  0045d	0f b6 44 24 48	 movzx	 eax, BYTE PTR opcode$[rsp]
  00462	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00467	7d 0a		 jge	 SHORT $LN31@s370_disas
  00469	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv227[rsp], 4
  00471	eb 08		 jmp	 SHORT $LN32@s370_disas
$LN31@s370_disas:
  00473	c7 44 24 6c 06
	00 00 00	 mov	 DWORD PTR tv227[rsp], 6
$LN32@s370_disas:
  0047b	8b 44 24 6c	 mov	 eax, DWORD PTR tv227[rsp]
  0047f	89 44 24 70	 mov	 DWORD PTR tv228[rsp], eax
$LN34@s370_disas:
  00483	8b 44 24 70	 mov	 eax, DWORD PTR tv228[rsp]
  00487	89 44 24 50	 mov	 DWORD PTR ilc$[rsp], eax

; 421  : 
; 422  :         if (aaddr + ilc > regs->mainlim)

  0048b	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00490	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00498	48 03 c8	 add	 rcx, rax
  0049b	48 8b c1	 mov	 rax, rcx
  0049e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a6	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  004ad	76 7b		 jbe	 SHORT $LN21@s370_disas

; 423  :         {
; 424  :             MSGBUF( buf, "R:"F_RADR"  Addressing exception", aaddr );

  004af	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR aaddr$[rsp]
  004b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169916
  004be	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  004c3	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 425  :             WRMSG( HHC02289, "I", buf );

  004d1	b9 01 00 00 00	 mov	 ecx, 1
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004dc	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  004e4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169917
  004f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169918
  004fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00501	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00506	41 b9 03 00 00
	00		 mov	 r9d, 3
  0050c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169919
  00513	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00518	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169920
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  :             return;

  00525	e9 75 02 00 00	 jmp	 $LN1@s370_disas
$LN21@s370_disas:

; 427  :         }
; 428  : 
; 429  :         /* Copy instruction to work area and hex print it */
; 430  :         memcpy(inst, regs->mainstor + aaddr, ilc);

  0052a	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0052f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00537	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0053e	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR aaddr$[rsp]
  00546	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  0054e	48 8b fa	 mov	 rdi, rdx
  00551	48 8b f1	 mov	 rsi, rcx
  00554	48 8b c8	 mov	 rcx, rax
  00557	f3 a4		 rep movsb

; 431  :         len = sprintf(buf, "%c:"F_RADR"  %2.2X%2.2X",

  00559	83 7c 24 54 00	 cmp	 DWORD PTR stid$[rsp], 0
  0055e	75 0a		 jne	 SHORT $LN39@s370_disas
  00560	c7 44 24 7c 50
	00 00 00	 mov	 DWORD PTR tv270[rsp], 80 ; 00000050H
  00568	eb 3a		 jmp	 SHORT $LN40@s370_disas
$LN39@s370_disas:
  0056a	83 7c 24 54 03	 cmp	 DWORD PTR stid$[rsp], 3
  0056f	75 0a		 jne	 SHORT $LN37@s370_disas
  00571	c7 44 24 78 48
	00 00 00	 mov	 DWORD PTR tv269[rsp], 72 ; 00000048H
  00579	eb 21		 jmp	 SHORT $LN38@s370_disas
$LN37@s370_disas:
  0057b	83 7c 24 54 02	 cmp	 DWORD PTR stid$[rsp], 2
  00580	75 0a		 jne	 SHORT $LN35@s370_disas
  00582	c7 44 24 74 53
	00 00 00	 mov	 DWORD PTR tv268[rsp], 83 ; 00000053H
  0058a	eb 08		 jmp	 SHORT $LN36@s370_disas
$LN35@s370_disas:
  0058c	c7 44 24 74 52
	00 00 00	 mov	 DWORD PTR tv268[rsp], 82 ; 00000052H
$LN36@s370_disas:
  00594	8b 44 24 74	 mov	 eax, DWORD PTR tv268[rsp]
  00598	89 44 24 78	 mov	 DWORD PTR tv269[rsp], eax
$LN38@s370_disas:
  0059c	8b 44 24 78	 mov	 eax, DWORD PTR tv269[rsp]
  005a0	89 44 24 7c	 mov	 DWORD PTR tv270[rsp], eax
$LN40@s370_disas:
  005a4	b8 01 00 00 00	 mov	 eax, 1
  005a9	48 6b c0 01	 imul	 rax, rax, 1
  005ad	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  005b5	b9 01 00 00 00	 mov	 ecx, 1
  005ba	48 6b c9 00	 imul	 rcx, rcx, 0
  005be	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  005c6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005ca	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005ce	4c 8b 4c 24 60	 mov	 r9, QWORD PTR raddr$[rsp]
  005d3	44 8b 44 24 7c	 mov	 r8d, DWORD PTR tv270[rsp]
  005d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169921
  005df	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  005e7	e8 00 00 00 00	 call	 sprintf
  005ec	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 432  :           stid == TEA_ST_PRIMARY ? 'P' :
; 433  :           stid == TEA_ST_HOME ? 'H' :
; 434  :           stid == TEA_ST_SECNDRY ? 'S' : 'R',
; 435  :           raddr, inst[0], inst[1]);
; 436  : 
; 437  :         if(ilc > 2)

  005f0	83 7c 24 50 02	 cmp	 DWORD PTR ilc$[rsp], 2
  005f5	0f 8e e0 00 00
	00		 jle	 $LN22@s370_disas

; 438  :         {
; 439  :             len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X", inst[2], inst[3]);

  005fb	b8 01 00 00 00	 mov	 eax, 1
  00600	48 6b c0 03	 imul	 rax, rax, 3
  00604	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  0060c	b9 01 00 00 00	 mov	 ecx, 1
  00611	48 6b c9 02	 imul	 rcx, rcx, 2
  00615	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  0061d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00621	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00625	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169924
  0062c	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00632	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0063a	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  0063e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00644	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00648	03 c8		 add	 ecx, eax
  0064a	8b c1		 mov	 eax, ecx
  0064c	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 440  :             if(ilc > 4)

  00650	83 7c 24 50 04	 cmp	 DWORD PTR ilc$[rsp], 4
  00655	7e 57		 jle	 SHORT $LN24@s370_disas

; 441  :                 len += idx_snprintf( len, buf, sizeof(buf), "%2.2X%2.2X ", inst[4], inst[5]);

  00657	b8 01 00 00 00	 mov	 eax, 1
  0065c	48 6b c0 05	 imul	 rax, rax, 5
  00660	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR inst$[rsp+rax]
  00668	b9 01 00 00 00	 mov	 ecx, 1
  0066d	48 6b c9 04	 imul	 rcx, rcx, 4
  00671	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR inst$[rsp+rcx]
  00679	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0067d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00681	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169927
  00688	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0068e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00696	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  0069a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006a0	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006a4	03 c8		 add	 ecx, eax
  006a6	8b c1		 mov	 eax, ecx
  006a8	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
  006ac	eb 2b		 jmp	 SHORT $LN25@s370_disas
$LN24@s370_disas:

; 442  :             else
; 443  :                 len += idx_snprintf( len, buf, sizeof(buf), "     ");

  006ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169928
  006b5	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006bb	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006c3	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006cd	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006d1	03 c8		 add	 ecx, eax
  006d3	8b c1		 mov	 eax, ecx
  006d5	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN25@s370_disas:

; 444  :         }

  006d9	eb 2b		 jmp	 SHORT $LN23@s370_disas
$LN22@s370_disas:

; 445  :         else
; 446  :             len += idx_snprintf( len, buf, sizeof(buf), "         ");

  006db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169929
  006e2	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  006e8	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006f0	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  006fa	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  006fe	03 c8		 add	 ecx, eax
  00700	8b c1		 mov	 eax, ecx
  00702	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN23@s370_disas:

; 447  : 
; 448  :         /* Disassemble the instruction and display the results */
; 449  :         PRINT_INST( regs->arch_mode, inst, buf + len );

  00706	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0070b	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00713	4c 8b c8	 mov	 r9, rax
  00716	45 33 c0	 xor	 r8d, r8d
  00719	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR inst$[rsp]
  00721	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00729	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  0072c	e8 00 00 00 00	 call	 iprint_router_func

; 450  :         WRMSG( HHC02289, "I", buf );

  00731	b9 01 00 00 00	 mov	 ecx, 1
  00736	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0073c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00744	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169930
  00750	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00755	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169931
  0075c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00761	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00766	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169932
  00773	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00778	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169933
  0077f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 451  : 
; 452  :         /* Go on to the next instruction */
; 453  :         saddr += ilc;

  00785	48 63 44 24 50	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0078a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR saddr$[rsp]
  0078f	48 03 c8	 add	 rcx, rax
  00792	48 8b c1	 mov	 rax, rcx
  00795	48 89 44 24 58	 mov	 QWORD PTR saddr$[rsp], rax

; 454  : 
; 455  :     } /* end while (saddr <= eaddr) */

  0079a	e9 98 fa ff ff	 jmp	 $LN8@s370_disas
$LN9@s370_disas:
$LN1@s370_disas:

; 456  : 
; 457  : } /* end function disasm_stor */

  0079f	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007a7	48 33 cc	 xor	 rcx, rsp
  007aa	e8 00 00 00 00	 call	 __security_check_cookie
  007af	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  007b6	5f		 pop	 rdi
  007b7	5e		 pop	 rsi
  007b8	c3		 ret	 0
s370_disasm_stor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
dumpbuf$ = 80
tv128 = 88
tv144 = 92
tv155 = 96
tv185 = 100
msgnum$ = 104
tv66 = 112
dumpdata$ = 120
tv228 = 128
tv243 = 136
pfx$ = 144
__$ArrayPad$ = 208
regs$ = 240
aaddr$ = 248
adr$ = 256
offset$ = 264
amt$ = 272
vra$ = 280
wid$ = 288
s370_dump_abs_page PROC

; 238  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 239  :     char*   msgnum;                 /* "HHC02290" or "HHC02291"      */
; 240  :     char*   dumpdata;               /* pointer to data to be dumped  */
; 241  :     char*   dumpbuf = NULL;         /* pointer to hexdump buffer     */

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR dumpbuf$[rsp], 0

; 242  :     char    pfx[64];                /* string prefixed to each line  */
; 243  : 
; 244  :     msgnum = vra ? "HHC02290" : "HHC02291";

  00036	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  0003e	85 c0		 test	 eax, eax
  00040	74 0e		 je	 SHORT $LN15@s370_dump_
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169804
  00049	48 89 44 24 70	 mov	 QWORD PTR tv66[rsp], rax
  0004e	eb 0c		 jmp	 SHORT $LN16@s370_dump_
$LN15@s370_dump_:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169805
  00057	48 89 44 24 70	 mov	 QWORD PTR tv66[rsp], rax
$LN16@s370_dump_:
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR tv66[rsp]
  00061	48 89 44 24 68	 mov	 QWORD PTR msgnum$[rsp], rax

; 245  : 
; 246  :     if (0
; 247  :         || aaddr  &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 248  :         || adr    &  PAGEFRAME_BYTEMASK     /* not page aligned      */
; 249  :         || offset >= PAGEFRAME_PAGESIZE     /* offset >= pagesize    */
; 250  :         || amt    > (PAGEFRAME_PAGESIZE - offset)/* more than 1 page */
; 251  :         || (wid != 32 && wid != 64)         /* invalid address width */

  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 65		 jne	 SHORT $LN6@s370_dump_
  0006c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR aaddr$[rsp]
  00074	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  0007a	48 85 c0	 test	 rax, rax
  0007d	75 52		 jne	 SHORT $LN6@s370_dump_
  0007f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00087	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  0008d	48 85 c0	 test	 rax, rax
  00090	75 3f		 jne	 SHORT $LN6@s370_dump_
  00092	48 81 bc 24 08
	01 00 00 00 08
	00 00		 cmp	 QWORD PTR offset$[rsp], 2048 ; 00000800H
  0009e	73 31		 jae	 SHORT $LN6@s370_dump_
  000a0	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  000a5	48 2b 84 24 08
	01 00 00	 sub	 rax, QWORD PTR offset$[rsp]
  000ad	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR amt$[rsp], rax
  000b5	77 1a		 ja	 SHORT $LN6@s370_dump_
  000b7	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c2	74 76		 je	 SHORT $LN5@s370_dump_
  000c4	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  000cc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cf	74 69		 je	 SHORT $LN5@s370_dump_
$LN6@s370_dump_:

; 252  :     )
; 253  :     {
; 254  :         // "Error in function %s: %s"
; 255  :         WRMSG( HHC02219, "E", "dump_abs_page()", "invalid parameters" );

  000d1	b9 01 00 00 00	 mov	 ecx, 1
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169808
  000e3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169809
  000ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169810
  000fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169811
  00107	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	41 b9 03 00 00
	00		 mov	 r9d, 3
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169812
  0011e	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169813
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 256  :         return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 3f 04 00 00	 jmp	 $LN1@s370_dump_
$LN5@s370_dump_:
$LN4@s370_dump_:

; 257  :     }
; 258  : 
; 259  :     /* Flush interval timer value to storage */
; 260  :     ITIMER_SYNC( adr + offset, amt, regs );

  0013a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00142	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adr$[rsp]
  0014a	48 03 c8	 add	 rcx, rax
  0014d	48 8b c1	 mov	 rax, rcx
  00150	48 83 f8 54	 cmp	 rax, 84			; 00000054H
  00154	73 0a		 jae	 SHORT $LN19@s370_dump_
  00156	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0015e	eb 08		 jmp	 SHORT $LN20@s370_dump_
$LN19@s370_dump_:
  00160	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN20@s370_dump_:
  00168	83 7c 24 58 00	 cmp	 DWORD PTR tv128[rsp], 0
  0016d	74 2e		 je	 SHORT $LN21@s370_dump_
  0016f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00177	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adr$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	48 8b c1	 mov	 rax, rcx
  00185	48 03 84 24 10
	01 00 00	 add	 rax, QWORD PTR amt$[rsp]
  0018d	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  00191	72 0a		 jb	 SHORT $LN21@s370_dump_
  00193	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN27@s370_dump_
$LN21@s370_dump_:
  0019d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN27@s370_dump_:
  001a5	83 7c 24 5c 00	 cmp	 DWORD PTR tv144[rsp], 0
  001aa	74 0d		 je	 SHORT $LN7@s370_dump_
  001ac	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_dump_:
  001b9	33 c0		 xor	 eax, eax
  001bb	85 c0		 test	 eax, eax
  001bd	0f 85 77 ff ff
	ff		 jne	 $LN4@s370_dump_

; 261  : 
; 262  :     /* Check for addressing exception */
; 263  :     if (aaddr > regs->mainlim)

  001c3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  001d2	48 39 84 24 f8
	00 00 00	 cmp	 QWORD PTR aaddr$[rsp], rax
  001da	0f 86 0e 01 00
	00		 jbe	 $LN8@s370_dump_

; 264  :     {
; 265  :         MSGBUF( pfx, "%c:"F_RADR"  Addressing exception",

  001e0	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  001e8	85 c0		 test	 eax, eax
  001ea	74 0e		 je	 SHORT $LN28@s370_dump_
  001ec	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  001f4	89 44 24 60	 mov	 DWORD PTR tv155[rsp], eax
  001f8	eb 08		 jmp	 SHORT $LN29@s370_dump_
$LN28@s370_dump_:
  001fa	c7 44 24 60 56
	00 00 00	 mov	 DWORD PTR tv155[rsp], 86 ; 00000056H
$LN29@s370_dump_:
  00202	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  0020a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020f	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv155[rsp]
  00214	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169816
  0021b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00220	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 266  :             vra ? vra : 'V', adr );
; 267  :         if (vra)

  0022e	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  00236	85 c0		 test	 eax, eax
  00238	74 56		 je	 SHORT $LN9@s370_dump_

; 268  :             WRMSG( HHC02290, "E", pfx );

  0023a	b9 01 00 00 00	 mov	 ecx, 1
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00245	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  0024d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169819
  00259	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169820
  00265	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00275	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169821
  0027c	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169822
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0028e	eb 54		 jmp	 SHORT $LN10@s370_dump_
$LN9@s370_dump_:

; 269  :         else
; 270  :             WRMSG( HHC02291, "E", pfx );

  00290	b9 01 00 00 00	 mov	 ecx, 1
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  002a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169823
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169824
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169825
  002d2	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169826
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@s370_dump_:

; 271  :         return -1;

  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	e9 8b 02 00 00	 jmp	 $LN1@s370_dump_
$LN8@s370_dump_:

; 272  :     }
; 273  : 
; 274  :     /* Format string each dump line should be prefixed with */
; 275  :     MSGBUF( pfx, "%sI %c:", msgnum, vra ? vra : 'V' );

  002ee	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  002f6	85 c0		 test	 eax, eax
  002f8	74 0e		 je	 SHORT $LN30@s370_dump_
  002fa	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  00302	89 44 24 64	 mov	 DWORD PTR tv185[rsp], eax
  00306	eb 08		 jmp	 SHORT $LN31@s370_dump_
$LN30@s370_dump_:
  00308	c7 44 24 64 56
	00 00 00	 mov	 DWORD PTR tv185[rsp], 86 ; 00000056H
$LN31@s370_dump_:
  00310	8b 44 24 64	 mov	 eax, DWORD PTR tv185[rsp]
  00314	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00318	4c 8b 4c 24 68	 mov	 r9, QWORD PTR msgnum$[rsp]
  0031d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169827
  00324	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00329	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 276  : 
; 277  :     /* Point to first byte of actual storage to be dumped */
; 278  :     dumpdata = (char*) regs->mainstor + aaddr + offset;

  00337	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00346	48 03 84 24 f8
	00 00 00	 add	 rax, QWORD PTR aaddr$[rsp]
  0034e	48 03 84 24 08
	01 00 00	 add	 rax, QWORD PTR offset$[rsp]
  00356	48 89 44 24 78	 mov	 QWORD PTR dumpdata$[rsp], rax

; 279  : 
; 280  :     /* Adjust cosmetic starting address of first line of dump */
; 281  :     adr += offset;                  /* exact cosmetic start address  */

  0035b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00363	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adr$[rsp]
  0036b	48 03 c8	 add	 rcx, rax
  0036e	48 8b c1	 mov	 rax, rcx
  00371	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 282  :     adr &= ~0xF;                    /* align to 16-byte boundary     */

  00379	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00381	48 83 e0 f0	 and	 rax, -16
  00385	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 283  :     offset &= 0xF;                  /* offset must be < (bpg * gpl)  */

  0038d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00395	48 83 e0 0f	 and	 rax, 15
  00399	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 284  : 
; 285  :     /* Use hexdump to format 16-byte aligned absolute storage dump   */
; 286  : 
; 287  :     hexdumpew                       /* afterwards dumpbuf --> dump   */

  003a1	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR wid$[rsp]
  003a9	48 c7 44 24 40
	04 00 00 00	 mov	 QWORD PTR [rsp+64], 4
  003b2	48 c7 44 24 38
	04 00 00 00	 mov	 QWORD PTR [rsp+56], 4
  003bb	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  003bf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  003c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003cc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR amt$[rsp]
  003d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d9	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR offset$[rsp]
  003e1	4c 8b 44 24 78	 mov	 r8, QWORD PTR dumpdata$[rsp]
  003e6	48 8d 54 24 50	 lea	 rdx, QWORD PTR dumpbuf$[rsp]
  003eb	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pfx$[rsp]
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hexdumpew

; 288  :     (
; 289  :         pfx,                        /* string prefixed to each line  */
; 290  :         &dumpbuf,                   /* ptr to hexdump buffer pointer */
; 291  :                                     /* (if NULL hexdump will malloc) */
; 292  :         dumpdata,                   /* pointer to data to be dumped  */
; 293  :         offset,                     /* bytes to skip on first line   */
; 294  :         amt,                        /* amount of data to be dumped   */
; 295  :         adr,                        /* cosmetic dump address of data */
; 296  :         wid,                        /* width of dump address in bits */
; 297  :         4,                          /* bpg value (bytes per group)   */
; 298  :         4                           /* gpl value (groups per line)   */
; 299  :     );
; 300  : 
; 301  :     /* Check for internal hexdumpew error */
; 302  :     if (!dumpbuf)

  003f9	48 83 7c 24 50
	00		 cmp	 QWORD PTR dumpbuf$[rsp], 0
  003ff	75 69		 jne	 SHORT $LN11@s370_dump_

; 303  :     {
; 304  :         // "Error in function %s: %s"
; 305  :         WRMSG( HHC02219, "E", "dump_abs_page()", "hexdumpew failed" );

  00401	b9 01 00 00 00	 mov	 ecx, 1
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169829
  00413	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169830
  0041f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00424	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169831
  0042b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169832
  00437	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0043c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00441	41 b9 03 00 00
	00		 mov	 r9d, 3
  00447	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169833
  0044e	ba 31 01 00 00	 mov	 edx, 305		; 00000131H
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169834
  0045a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 306  :         return -1;

  00460	b8 ff ff ff ff	 mov	 eax, -1
  00465	e9 0f 01 00 00	 jmp	 $LN1@s370_dump_
$LN11@s370_dump_:

; 307  :     }
; 308  : 
; 309  :     /* Display the dump and free the buffer hexdump malloc'ed for us */
; 310  : 
; 311  :     /* Note: due to WRMSG requirements for multi-line messages, the
; 312  :        first line should not have a message number. Thus we skip past
; 313  :        it via +1 for "I" in message number +1 for blank following it.
; 314  :        We also remove the last newline since WRMSG does that for us. */
; 315  : 
; 316  :     *(dumpbuf + strlen( dumpbuf ) - 1) = 0; /* (remove last newline) */

  0046a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  0046f	e8 00 00 00 00	 call	 strlen
  00474	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  00479	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 317  : 
; 318  :     if (vra)

  0047e	0f be 84 24 18
	01 00 00	 movsx	 eax, BYTE PTR vra$[rsp]
  00486	85 c0		 test	 eax, eax
  00488	74 72		 je	 SHORT $LN12@s370_dump_

; 319  :         WRMSG( HHC02290, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  0048a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR msgnum$[rsp]
  0048f	e8 00 00 00 00	 call	 strlen
  00494	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  00499	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  0049e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv228[rsp], rax
  004a6	b9 01 00 00 00	 mov	 ecx, 1
  004ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  004b9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169837
  004c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169838
  004d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004db	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169839
  004e8	ba 3f 01 00 00	 mov	 edx, 319		; 0000013fH
  004ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169840
  004f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  004fa	eb 70		 jmp	 SHORT $LN13@s370_dump_
$LN12@s370_dump_:

; 320  :     else
; 321  :         WRMSG( HHC02291, "I", dumpbuf + strlen( msgnum ) + 1 + 1 );

  004fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR msgnum$[rsp]
  00501	e8 00 00 00 00	 call	 strlen
  00506	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  0050b	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00510	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv243[rsp], rax
  00518	b9 01 00 00 00	 mov	 ecx, 1
  0051d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00523	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv243[rsp]
  0052b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00530	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169841
  00537	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169842
  00543	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00548	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0054d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00553	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169843
  0055a	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169844
  00566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@s370_dump_:

; 322  : 
; 323  :     free( dumpbuf );

  0056c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dumpbuf$[rsp]
  00571	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 324  :     return 0;

  00577	33 c0		 xor	 eax, eax
$LN1@s370_dump_:

; 325  : 
; 326  : } /* end function dump_abs_page */

  00579	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00581	48 33 cc	 xor	 rcx, rsp
  00584	e8 00 00 00 00	 call	 __security_check_cookie
  00589	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00590	c3		 ret	 0
s370_dump_abs_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
n$ = 48
tv136 = 52
stid$ = 56
raddr$ = 64
regs$ = 96
vaddr$ = 104
buf$ = 112
bufl$ = 120
ar$ = 128
acctype$ = 136
hdr$ = 144
xcode$ = 152
s370_display_virt PROC

; 188  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 189  : RADR    raddr;                          /* Real address              */
; 190  : int     n;                              /* Number of bytes in buffer */
; 191  : int     stid;                           /* Segment table indication  */
; 192  : 
; 193  :     /* Convert virtual address to real address */
; 194  :     *xcode = ARCH_DEP(virt_to_real) (&raddr, &stid,

  00017	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  0001b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00022	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00030	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR ar$[rsp]
  00038	44 8b c0	 mov	 r8d, eax
  0003b	48 8d 54 24 38	 lea	 rdx, QWORD PTR stid$[rsp]
  00040	48 8d 4c 24 40	 lea	 rcx, QWORD PTR raddr$[rsp]
  00045	e8 00 00 00 00	 call	 s370_virt_to_real
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  00052	66 89 01	 mov	 WORD PTR [rcx], ax

; 195  :                                      vaddr, ar, regs, acctype);
; 196  : 
; 197  :     if (*xcode == 0)

  00055	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  0005d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00060	85 c0		 test	 eax, eax
  00062	0f 85 c6 00 00
	00		 jne	 $LN2@s370_displ

; 198  :     {
; 199  :         if (ar == USE_REAL_ADDR)

  00068	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  00070	75 2d		 jne	 SHORT $LN4@s370_displ

; 200  :             n = snprintf( buf, bufl, "%sR:"F_VADR":", hdr, vaddr );

  00072	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  00076	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007a	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169773
  00089	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00099	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
  0009d	eb 35		 jmp	 SHORT $LN5@s370_displ
$LN4@s370_displ:

; 201  :         else
; 202  :             n = snprintf( buf, bufl, "%sV:"F_VADR":R:"F_RADR":", hdr, vaddr, raddr );

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR raddr$[rsp]
  000a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a9	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  000ad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b1	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169774
  000c0	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  000c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000d0	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN5@s370_displ:

; 203  : 
; 204  :         n += ARCH_DEP( display_real )( regs, raddr, buf+n, bufl-n, 0, "" );

  000d4	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bufl$[rsp]
  000de	48 2b c8	 sub	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR n$[rsp]
  000e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  000ee	48 03 d1	 add	 rdx, rcx
  000f1	48 8b ca	 mov	 rcx, rdx
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169775
  000fb	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00100	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00108	4c 8b c8	 mov	 r9, rax
  0010b	4c 8b c1	 mov	 r8, rcx
  0010e	48 8b 54 24 40	 mov	 rdx, QWORD PTR raddr$[rsp]
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	e8 00 00 00 00	 call	 s370_display_real
  0011d	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00121	03 c8		 add	 ecx, eax
  00123	8b c1		 mov	 eax, ecx
  00125	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 205  :     }

  00129	e9 9d 00 00 00	 jmp	 $LN3@s370_displ
$LN2@s370_displ:

; 206  :     else
; 207  :     {
; 208  :         n = snprintf (buf, bufl, "%s%c:"F_VADR":", hdr,

  0012e	83 bc 24 80 00
	00 00 fe	 cmp	 DWORD PTR ar$[rsp], -2
  00136	75 0a		 jne	 SHORT $LN7@s370_displ
  00138	c7 44 24 34 52
	00 00 00	 mov	 DWORD PTR tv136[rsp], 82 ; 00000052H
  00140	eb 08		 jmp	 SHORT $LN8@s370_displ
$LN7@s370_displ:
  00142	c7 44 24 34 56
	00 00 00	 mov	 DWORD PTR tv136[rsp], 86 ; 00000056H
$LN8@s370_displ:
  0014a	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  0014e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00152	8b 44 24 34	 mov	 eax, DWORD PTR tv136[rsp]
  00156	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0015a	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00162	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169776
  00169	48 8b 54 24 78	 mov	 rdx, QWORD PTR bufl$[rsp]
  0016e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00179	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 209  :                      ar == USE_REAL_ADDR ? 'R' : 'V', vaddr);
; 210  :         n += idx_snprintf( n, buf, bufl, " Translation exception %4.4hX (%s)",

  0017d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR xcode$[rsp]
  00185	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00188	8b c8		 mov	 ecx, eax
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00190	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR xcode$[rsp]
  00198	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0019b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a0	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001a4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169777
  001ab	4c 8b 44 24 78	 mov	 r8, QWORD PTR bufl$[rsp]
  001b0	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  001b5	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001bf	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  001c3	03 c8		 add	 ecx, eax
  001c5	8b c1		 mov	 eax, ecx
  001c7	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax
$LN3@s370_displ:

; 211  :             *xcode, PIC2Name( *xcode ));
; 212  :     }
; 213  :     return n;

  001cb	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]

; 214  : 
; 215  : } /* end function display_virt */

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
s370_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
c$ = 48
n$ = 52
j$ = 56
aaddr$ = 64
i$ = 72
tv68 = 76
tv80 = 80
tv139 = 88
$T1 = 96
cbuf$ = 104
hbuf$ = 128
__$ArrayPad$ = 192
regs$ = 224
raddr$ = 232
buf$ = 240
bufl$ = 248
draflag$ = 256
hdr$ = 264
s370_display_real PROC

; 113  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 114  : RADR    aaddr;                          /* Absolute storage address  */
; 115  : int     i, j;                           /* Loop counters             */
; 116  : int     n = 0;                          /* Number of bytes in buffer */

  0002e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 117  : char    hbuf[64];                       /* Hexadecimal buffer        */
; 118  : BYTE    cbuf[17];                       /* Character buffer          */
; 119  : BYTE    c;                              /* Character work area       */
; 120  : 
; 121  : #if defined(FEATURE_INTERVAL_TIMER)
; 122  :     if(ITIMER_ACCESS(raddr,16))

  00036	48 83 bc 24 e8
	00 00 00 54	 cmp	 QWORD PTR raddr$[rsp], 84 ; 00000054H
  0003f	73 0a		 jae	 SHORT $LN20@s370_displ
  00041	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00049	eb 08		 jmp	 SHORT $LN21@s370_displ
$LN20@s370_displ:
  0004b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN21@s370_displ:
  00053	83 7c 24 4c 00	 cmp	 DWORD PTR tv68[rsp], 0
  00058	74 1c		 je	 SHORT $LN22@s370_displ
  0005a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  00062	48 83 c0 10	 add	 rax, 16
  00066	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  0006a	72 0a		 jb	 SHORT $LN22@s370_displ
  0006c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00074	eb 08		 jmp	 SHORT $LN28@s370_displ
$LN22@s370_displ:
  00076	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN28@s370_displ:
  0007e	83 7c 24 50 00	 cmp	 DWORD PTR tv80[rsp], 0
  00083	74 0d		 je	 SHORT $LN5@s370_displ

; 123  :         ARCH_DEP(store_int_timer)(regs);

  00085	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	e8 00 00 00 00	 call	 s370_store_int_timer
$LN5@s370_displ:

; 124  : #endif
; 125  : 
; 126  :     n = snprintf(buf, bufl, "%s", hdr);

  00092	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169728
  000a1	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR bufl$[rsp]
  000a9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000b7	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 127  :     if (draflag)

  000bb	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR draflag$[rsp], 0
  000c3	74 3a		 je	 SHORT $LN6@s370_displ

; 128  :     {
; 129  :         n += idx_snprintf( n, buf, bufl, "R:"F_RADR":", raddr);

  000c5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  000cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169730
  000d9	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  000e1	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000e9	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  000f3	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  000f7	03 c8		 add	 ecx, eax
  000f9	8b c1		 mov	 eax, ecx
  000fb	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN6@s370_displ:

; 130  :     }
; 131  : 
; 132  :     aaddr = APPLY_PREFIXING (raddr, regs->PX);

  000ff	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR raddr$[rsp]
  00106	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 2c		 je	 SHORT $LN29@s370_displ
  00111	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR raddr$[rsp]
  00118	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0011e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00129	48 3b c1	 cmp	 rax, rcx
  0012c	74 0f		 je	 SHORT $LN29@s370_displ
  0012e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raddr$[rsp]
  00136	48 89 44 24 58	 mov	 QWORD PTR tv139[rsp], rax
  0013b	eb 1d		 jmp	 SHORT $LN30@s370_displ
$LN29@s370_displ:
  0013d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00148	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR raddr$[rsp]
  0014f	33 c8		 xor	 ecx, eax
  00151	8b c1		 mov	 eax, ecx
  00153	8b c0		 mov	 eax, eax
  00155	48 89 44 24 58	 mov	 QWORD PTR tv139[rsp], rax
$LN30@s370_displ:
  0015a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv139[rsp]
  0015f	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 133  :     if (SIE_MODE(regs))

  00164	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00172	d1 e8		 shr	 eax, 1
  00174	83 e0 01	 and	 eax, 1
  00177	85 c0		 test	 eax, eax
  00179	0f 84 b1 00 00
	00		 je	 $LN7@s370_displ

; 134  :     {
; 135  :         if (HOSTREGS->mainlim == 0 || aaddr > HOSTREGS->mainlim)

  0017f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00187	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0018e	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  00196	74 1d		 je	 SHORT $LN11@s370_displ
  00198	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001a7	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  001ae	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  001b3	76 42		 jbe	 SHORT $LN9@s370_displ
$LN11@s370_displ:

; 136  :         {
; 137  :             n += idx_snprintf( n, buf, bufl,

  001b5	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169736
  001c6	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  001ce	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001d6	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  001e0	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001e4	03 c8		 add	 ecx, eax
  001e6	8b c1		 mov	 eax, ecx
  001e8	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 138  :                 "A:"F_RADR" Guest real address is not valid", aaddr);
; 139  :             return n;

  001ec	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  001f0	e9 71 02 00 00	 jmp	 $LN1@s370_displ

; 140  :         }

  001f5	eb 37		 jmp	 SHORT $LN10@s370_displ
$LN9@s370_displ:

; 141  :         else
; 142  :         {
; 143  :             n += idx_snprintf( n, buf, bufl, "A:"F_RADR":", aaddr);

  001f7	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  001fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00201	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169737
  00208	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00210	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00218	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00222	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00226	03 c8		 add	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN10@s370_displ:

; 144  :         }
; 145  :     }

  0022e	eb 6a		 jmp	 SHORT $LN8@s370_displ
$LN7@s370_displ:

; 146  :     else
; 147  :     if (regs->mainlim == 0 || aaddr > regs->mainlim)

  00230	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00238	48 83 b8 58 08
	00 00 00	 cmp	 QWORD PTR [rax+2136], 0
  00240	74 16		 je	 SHORT $LN13@s370_displ
  00242	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00251	48 39 44 24 40	 cmp	 QWORD PTR aaddr$[rsp], rax
  00256	76 42		 jbe	 SHORT $LN12@s370_displ
$LN13@s370_displ:

; 148  :     {
; 149  :         n += idx_snprintf( n, buf, bufl, "%s", " Real address is not valid");

  00258	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169740
  0025f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00264	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169741
  0026b	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00273	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0027b	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00285	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00289	03 c8		 add	 ecx, eax
  0028b	8b c1		 mov	 eax, ecx
  0028d	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 150  :         return n;

  00291	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00295	e9 cc 01 00 00	 jmp	 $LN1@s370_displ
$LN12@s370_displ:
$LN8@s370_displ:

; 151  :     }
; 152  : 
; 153  :     /* Note: we use the internal "_get_storage_key" function here
; 154  :        so that we display the STORKEY_BADFRM bit too, if it's set.
; 155  :     */
; 156  :     n += idx_snprintf( n, buf, bufl, "K:%2.2X=", ARCH_DEP( _get_storage_key )( aaddr, SKEY_K ));

  0029a	b2 02		 mov	 dl, 2
  0029c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002a1	e8 00 00 00 00	 call	 s370__get_storage_key
  002a6	0f b6 c0	 movzx	 eax, al
  002a9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169742
  002b4	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  002bc	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002c4	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  002ce	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  002d2	03 c8		 add	 ecx, eax
  002d4	8b c1		 mov	 eax, ecx
  002d6	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 157  : 
; 158  :     memset (hbuf, SPACE, sizeof(hbuf));

  002da	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  002e2	48 8b f8	 mov	 rdi, rax
  002e5	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002ea	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002ef	f3 aa		 rep stosb

; 159  :     memset (cbuf, SPACE, sizeof(cbuf));

  002f1	48 8d 44 24 68	 lea	 rax, QWORD PTR cbuf$[rsp]
  002f6	48 8b f8	 mov	 rdi, rax
  002f9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002fe	b9 11 00 00 00	 mov	 ecx, 17
  00303	f3 aa		 rep stosb

; 160  : 
; 161  :     for (i = 0, j = 0; i < 16; i++)

  00305	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0030d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00315	eb 0a		 jmp	 SHORT $LN4@s370_displ
$LN2@s370_displ:
  00317	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0031b	ff c0		 inc	 eax
  0031d	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_displ:
  00321	83 7c 24 48 10	 cmp	 DWORD PTR i$[rsp], 16
  00326	0f 8d f2 00 00
	00		 jge	 $LN3@s370_displ

; 162  :     {
; 163  :         c = regs->mainstor[aaddr++];

  0032c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00334	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0033b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00340	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00344	88 44 24 30	 mov	 BYTE PTR c$[rsp], al
  00348	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  0034d	48 ff c0	 inc	 rax
  00350	48 89 44 24 40	 mov	 QWORD PTR aaddr$[rsp], rax

; 164  :         j += idx_snprintf( j, hbuf, sizeof(hbuf), "%2.2X", c);

  00355	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  0035a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0035e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169743
  00365	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0036b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00373	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0037d	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  00381	03 c8		 add	 ecx, eax
  00383	8b c1		 mov	 eax, ecx
  00385	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax

; 165  :         if ((aaddr & 0x3) == 0x0)

  00389	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  0038e	48 83 e0 03	 and	 rax, 3
  00392	48 85 c0	 test	 rax, rax
  00395	75 3d		 jne	 SHORT $LN14@s370_displ

; 166  :         {
; 167  :             hbuf[j] = SPACE;

  00397	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  0039c	c6 84 04 80 00
	00 00 20	 mov	 BYTE PTR hbuf$[rsp+rax], 32 ; 00000020H

; 168  :             hbuf[++j] = 0;

  003a4	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  003a8	ff c0		 inc	 eax
  003aa	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
  003ae	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  003b3	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  003b8	48 83 7c 24 60
	40		 cmp	 QWORD PTR $T1[rsp], 64	; 00000040H
  003be	73 02		 jae	 SHORT $LN31@s370_displ
  003c0	eb 05		 jmp	 SHORT $LN32@s370_displ
$LN31@s370_displ:
  003c2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN32@s370_displ:
  003c7	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  003cc	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR hbuf$[rsp+rax], 0
$LN14@s370_displ:

; 169  :         }
; 170  :         c = guest_to_host(c);

  003d4	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  003df	88 44 24 30	 mov	 BYTE PTR c$[rsp], al

; 171  :         if (!isprint(c)) c = '.';

  003e3	0f b6 44 24 30	 movzx	 eax, BYTE PTR c$[rsp]
  003e8	8b c8		 mov	 ecx, eax
  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  003f0	85 c0		 test	 eax, eax
  003f2	75 05		 jne	 SHORT $LN15@s370_displ
  003f4	c6 44 24 30 2e	 mov	 BYTE PTR c$[rsp], 46	; 0000002eH
$LN15@s370_displ:

; 172  :         cbuf[i] = c;

  003f9	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  003fe	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR c$[rsp]
  00403	88 4c 04 68	 mov	 BYTE PTR cbuf$[rsp+rax], cl

; 173  :         if ((aaddr & PAGEFRAME_BYTEMASK) == 0x000) break;

  00407	48 8b 44 24 40	 mov	 rax, QWORD PTR aaddr$[rsp]
  0040c	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  00412	48 85 c0	 test	 rax, rax
  00415	75 02		 jne	 SHORT $LN16@s370_displ
  00417	eb 05		 jmp	 SHORT $LN3@s370_displ
$LN16@s370_displ:

; 174  :     } /* end for(i) */

  00419	e9 f9 fe ff ff	 jmp	 $LN2@s370_displ
$LN3@s370_displ:

; 175  : 
; 176  :     n += idx_snprintf( n, buf, bufl, "%-36.36s %-16.16s", hbuf, cbuf);

  0041e	48 8d 44 24 68	 lea	 rax, QWORD PTR cbuf$[rsp]
  00423	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00428	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hbuf$[rsp]
  00430	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00435	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169747
  0043c	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR bufl$[rsp]
  00444	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0044c	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00456	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  0045a	03 c8		 add	 ecx, eax
  0045c	8b c1		 mov	 eax, ecx
  0045e	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 177  :     return n;

  00462	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
$LN1@s370_displ:
$LN17@s370_displ:

; 178  : 
; 179  : } /* end function display_real */

  00466	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0046e	48 33 cc	 xor	 rcx, rsp
  00471	e8 00 00 00 00	 call	 __security_check_cookie
  00476	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0047d	5f		 pop	 rdi
  0047e	c3		 ret	 0
s370_display_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s370__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s370__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	0f b6 44 24 48	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 39		 jne	 SHORT $LN5@s370__get_
  0001d	33 c0		 xor	 eax, eax
  0001f	83 f8 01	 cmp	 eax, 1
  00022	74 32		 je	 SHORT $LN5@s370__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00029	e8 00 00 00 00	 call	 _get_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0003a	e8 00 00 00 00	 call	 _get_storekey2_ptr
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00047	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx
  00050	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00054	eb 16		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  00056	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00060	e8 00 00 00 00	 call	 _get_storekey_ptr
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 140  :     return skey;

  0006c	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
s370__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_all_cpus_stopped_intlock_held PROC

; 516  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 517  :     int cpu;
; 518  : 
; 519  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_all_cp

; 520  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_all_cp
$LN2@are_all_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_all_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_all_cp

; 521  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_all_cp

; 522  :                 if (sysblk.regs[ cpu ]->cpustate != CPUSTATE_STOPPED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 03	 cmp	 eax, 3
  00067	74 04		 je	 SHORT $LN7@are_all_cp

; 523  :                     return false;

  00069	32 c0		 xor	 al, al
  0006b	eb 04		 jmp	 SHORT $LN1@are_all_cp
$LN7@are_all_cp:
$LN6@are_all_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_all_cp
$LN3@are_all_cp:
$LN5@are_all_cp:

; 524  :     return true;

  0006f	b0 01		 mov	 al, 1
$LN1@are_all_cp:

; 525  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_all_cpus_stopped_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
inst$ = 72
z900_display_guest_inst PROC

; 1189 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1190 :     switch (GUESTREGS->arch_mode)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0001a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001d	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00026	74 10		 je	 SHORT $LN7@z900_displ
  00028	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002d	74 21		 je	 SHORT $LN8@z900_displ
  0002f	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00034	74 32		 je	 SHORT $LN9@z900_displ
  00036	eb 48		 jmp	 SHORT $LN10@z900_displ
$LN7@z900_displ:

; 1191 :     {
; 1192 :     case ARCH_370_IDX: s370_display_inst( GUESTREGS, inst ); break;

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00049	e8 00 00 00 00	 call	 s370_display_inst
  0004e	eb 47		 jmp	 SHORT $LN2@z900_displ
$LN8@z900_displ:

; 1193 :     case ARCH_390_IDX: s390_display_inst( GUESTREGS, inst ); break;

  00050	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00061	e8 00 00 00 00	 call	 s390_display_inst
  00066	eb 2f		 jmp	 SHORT $LN2@z900_displ
$LN9@z900_displ:

; 1194 :     case ARCH_900_IDX: z900_display_inst( GUESTREGS, inst ); break;

  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00079	e8 00 00 00 00	 call	 z900_display_inst
  0007e	eb 17		 jmp	 SHORT $LN2@z900_displ
$LN10@z900_displ:
$LN6@z900_displ:

; 1195 :     default: CRASH();

  00080	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 e9		 jne	 SHORT $LN6@z900_displ
$LN2@z900_displ:

; 1196 :     }
; 1197 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
z900_display_guest_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
inst$ = 72
s390_display_guest_inst PROC

; 1189 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1190 :     switch (GUESTREGS->arch_mode)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0001a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001d	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00026	74 10		 je	 SHORT $LN7@s390_displ
  00028	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002d	74 21		 je	 SHORT $LN8@s390_displ
  0002f	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00034	74 32		 je	 SHORT $LN9@s390_displ
  00036	eb 48		 jmp	 SHORT $LN10@s390_displ
$LN7@s390_displ:

; 1191 :     {
; 1192 :     case ARCH_370_IDX: s370_display_inst( GUESTREGS, inst ); break;

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00049	e8 00 00 00 00	 call	 s370_display_inst
  0004e	eb 47		 jmp	 SHORT $LN2@s390_displ
$LN8@s390_displ:

; 1193 :     case ARCH_390_IDX: s390_display_inst( GUESTREGS, inst ); break;

  00050	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00061	e8 00 00 00 00	 call	 s390_display_inst
  00066	eb 2f		 jmp	 SHORT $LN2@s390_displ
$LN9@s390_displ:

; 1194 :     case ARCH_900_IDX: z900_display_inst( GUESTREGS, inst ); break;

  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00079	e8 00 00 00 00	 call	 z900_display_inst
  0007e	eb 17		 jmp	 SHORT $LN2@s390_displ
$LN10@s390_displ:
$LN6@s390_displ:

; 1195 :     default: CRASH();

  00080	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 e9		 jne	 SHORT $LN6@s390_displ
$LN2@s390_displ:

; 1196 :     }
; 1197 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
s390_display_guest_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
inst$ = 72
s370_display_guest_inst PROC

; 1189 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1190 :     switch (GUESTREGS->arch_mode)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0001a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001d	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00021	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00026	74 10		 je	 SHORT $LN7@s370_displ
  00028	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002d	74 21		 je	 SHORT $LN8@s370_displ
  0002f	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00034	74 32		 je	 SHORT $LN9@s370_displ
  00036	eb 48		 jmp	 SHORT $LN10@s370_displ
$LN7@s370_displ:

; 1191 :     {
; 1192 :     case ARCH_370_IDX: s370_display_inst( GUESTREGS, inst ); break;

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00049	e8 00 00 00 00	 call	 s370_display_inst
  0004e	eb 47		 jmp	 SHORT $LN2@s370_displ
$LN8@s370_displ:

; 1193 :     case ARCH_390_IDX: s390_display_inst( GUESTREGS, inst ); break;

  00050	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00061	e8 00 00 00 00	 call	 s390_display_inst
  00066	eb 2f		 jmp	 SHORT $LN2@s370_displ
$LN9@s370_displ:

; 1194 :     case ARCH_900_IDX: z900_display_inst( GUESTREGS, inst ); break;

  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR inst$[rsp]
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00079	e8 00 00 00 00	 call	 z900_display_inst
  0007e	eb 17		 jmp	 SHORT $LN2@s370_displ
$LN10@s370_displ:
$LN6@s370_displ:

; 1195 :     default: CRASH();

  00080	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	75 e9		 jne	 SHORT $LN6@s370_displ
$LN2@s370_displ:

; 1196 :     }
; 1197 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
s370_display_guest_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
z900_display_inst PROC

; 1173 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1174 :     ARCH_DEP( display_inst_adj )( iregs, inst, false );

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 z900_display_inst_adj

; 1175 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
z900_display_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
s390_display_inst PROC

; 1173 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1174 :     ARCH_DEP( display_inst_adj )( iregs, inst, false );

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 s390_display_inst_adj

; 1175 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
s390_display_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv72 = 32
regs$ = 40
p$1 = 48
iregs$ = 80
argc$ = 88
argv$ = 96
cmdline$ = 104
disasm_stor PROC

; 3062 : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3063 :  REGS *regs;
; 3064 : 
; 3065 :     if (iregs->ghostregs)

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  0001c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00022	c1 e8 0d	 shr	 eax, 13
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@disasm_sto

; 3066 :         regs = iregs;

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax
  00036	eb 1c		 jmp	 SHORT $LN8@disasm_sto
$LN7@disasm_sto:

; 3067 :     else if ((regs = copy_regs(iregs)) == NULL)

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iregs$[rsp]
  0003d	e8 00 00 00 00	 call	 copy_regs
  00042	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax
  00047	48 83 7c 24 28
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0004d	75 05		 jne	 SHORT $LN9@disasm_sto

; 3068 :         return;

  0004f	e9 a8 00 00 00	 jmp	 $LN1@disasm_sto
$LN9@disasm_sto:
$LN8@disasm_sto:

; 3069 : 
; 3070 :     switch(regs->arch_mode) {

  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00059	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0005c	89 44 24 20	 mov	 DWORD PTR tv72[rsp], eax
  00060	83 7c 24 20 00	 cmp	 DWORD PTR tv72[rsp], 0
  00065	74 10		 je	 SHORT $LN10@disasm_sto
  00067	83 7c 24 20 01	 cmp	 DWORD PTR tv72[rsp], 1
  0006c	74 23		 je	 SHORT $LN11@disasm_sto
  0006e	83 7c 24 20 02	 cmp	 DWORD PTR tv72[rsp], 2
  00073	74 36		 je	 SHORT $LN12@disasm_sto
  00075	eb 4e		 jmp	 SHORT $LN13@disasm_sto
$LN10@disasm_sto:

; 3071 : #if defined(_370)
; 3072 :         case ARCH_370_IDX:
; 3073 :             s370_disasm_stor(regs, argc, argv, cmdline);

  00077	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  0007c	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  00081	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	e8 00 00 00 00	 call	 s370_disasm_stor

; 3074 :             break;

  0008f	eb 4b		 jmp	 SHORT $LN2@disasm_sto
$LN11@disasm_sto:

; 3075 : #endif
; 3076 : #if defined(_390)
; 3077 :         case ARCH_390_IDX:
; 3078 :             s390_disasm_stor(regs, argc, argv, cmdline);

  00091	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  00096	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	e8 00 00 00 00	 call	 s390_disasm_stor

; 3079 :             break;

  000a9	eb 31		 jmp	 SHORT $LN2@disasm_sto
$LN12@disasm_sto:

; 3080 : #endif
; 3081 : #if defined(_900)
; 3082 :         case ARCH_900_IDX:
; 3083 :             z900_disasm_stor(regs, argc, argv, cmdline);

  000ab	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  000b0	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  000b5	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	e8 00 00 00 00	 call	 z900_disasm_stor

; 3084 :             break;

  000c3	eb 17		 jmp	 SHORT $LN2@disasm_sto
$LN13@disasm_sto:
$LN6@disasm_sto:

; 3085 : #endif
; 3086 :         default: CRASH();

  000c5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR p$1[rsp]
  000d3	c6 00 00	 mov	 BYTE PTR [rax], 0
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 e9		 jne	 SHORT $LN6@disasm_sto
$LN2@disasm_sto:

; 3087 :     }
; 3088 : 
; 3089 :     if (!iregs->ghostregs)

  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  000e1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e7	c1 e8 0d	 shr	 eax, 13
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	75 0b		 jne	 SHORT $LN14@disasm_sto

; 3090 :         free_aligned( regs );

  000f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN14@disasm_sto:
$LN1@disasm_sto:

; 3091 : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
disasm_stor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv72 = 32
regs$ = 40
p$1 = 48
iregs$ = 80
argc$ = 88
argv$ = 96
cmdline$ = 104
alter_display_virt PROC

; 3032 : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3033 :  REGS *regs;
; 3034 : 
; 3035 :     if (iregs->ghostregs)

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  0001c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00022	c1 e8 0d	 shr	 eax, 13
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@alter_disp

; 3036 :         regs = iregs;

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax
  00036	eb 1c		 jmp	 SHORT $LN8@alter_disp
$LN7@alter_disp:

; 3037 :     else if ((regs = copy_regs(iregs)) == NULL)

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iregs$[rsp]
  0003d	e8 00 00 00 00	 call	 copy_regs
  00042	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax
  00047	48 83 7c 24 28
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0004d	75 05		 jne	 SHORT $LN9@alter_disp

; 3038 :         return;

  0004f	e9 ad 00 00 00	 jmp	 $LN1@alter_disp
$LN9@alter_disp:
$LN8@alter_disp:

; 3039 : 
; 3040 :     switch(sysblk.arch_mode) {

  00054	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00061	89 44 24 20	 mov	 DWORD PTR tv72[rsp], eax
  00065	83 7c 24 20 00	 cmp	 DWORD PTR tv72[rsp], 0
  0006a	74 10		 je	 SHORT $LN10@alter_disp
  0006c	83 7c 24 20 01	 cmp	 DWORD PTR tv72[rsp], 1
  00071	74 23		 je	 SHORT $LN11@alter_disp
  00073	83 7c 24 20 02	 cmp	 DWORD PTR tv72[rsp], 2
  00078	74 36		 je	 SHORT $LN12@alter_disp
  0007a	eb 4e		 jmp	 SHORT $LN13@alter_disp
$LN10@alter_disp:

; 3041 : #if defined(_370)
; 3042 :         case ARCH_370_IDX:
; 3043 :             s370_alter_display_virt (regs, argc, argv, cmdline); break;

  0007c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  00081	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  00086	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  0008a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_alter_display_virt
  00094	eb 4b		 jmp	 SHORT $LN2@alter_disp
$LN11@alter_disp:

; 3044 : #endif
; 3045 : #if defined(_390)
; 3046 :         case ARCH_390_IDX:
; 3047 :             s390_alter_display_virt (regs, argc, argv, cmdline); break;

  00096	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  0009b	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  000a0	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	e8 00 00 00 00	 call	 s390_alter_display_virt
  000ae	eb 31		 jmp	 SHORT $LN2@alter_disp
$LN12@alter_disp:

; 3048 : #endif
; 3049 : #if defined(_900)
; 3050 :         case ARCH_900_IDX:
; 3051 :             z900_alter_display_virt (regs, argc, argv, cmdline); break;

  000b0	4c 8b 4c 24 68	 mov	 r9, QWORD PTR cmdline$[rsp]
  000b5	4c 8b 44 24 60	 mov	 r8, QWORD PTR argv$[rsp]
  000ba	8b 54 24 58	 mov	 edx, DWORD PTR argc$[rsp]
  000be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	e8 00 00 00 00	 call	 z900_alter_display_virt
  000c8	eb 17		 jmp	 SHORT $LN2@alter_disp
$LN13@alter_disp:
$LN6@alter_disp:

; 3052 : #endif
; 3053 :         default: CRASH();

  000ca	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR p$1[rsp]
  000d8	c6 00 00	 mov	 BYTE PTR [rax], 0
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 e9		 jne	 SHORT $LN6@alter_disp
$LN2@alter_disp:

; 3054 :     }
; 3055 : 
; 3056 :     if (!iregs->ghostregs)

  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR iregs$[rsp]
  000e6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ec	c1 e8 0d	 shr	 eax, 13
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	75 0b		 jne	 SHORT $LN14@alter_disp

; 3057 :         free_aligned( regs );

  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN14@alter_disp:
$LN1@alter_disp:

; 3058 : } /* end function alter_display_virt */

  00101	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00105	c3		 ret	 0
alter_display_virt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
regs$ = 64
argc$ = 72
argv$ = 80
cmdline$ = 88
alter_display_real_or_abs PROC

; 3011 : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3012 :     switch(sysblk.arch_mode) {

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00024	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00028	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  0002d	74 10		 je	 SHORT $LN7@alter_disp
  0002f	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00034	74 23		 je	 SHORT $LN8@alter_disp
  00036	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0003b	74 36		 je	 SHORT $LN9@alter_disp
  0003d	eb 4e		 jmp	 SHORT $LN10@alter_disp
$LN7@alter_disp:

; 3013 : #if defined(_370)
; 3014 :         case ARCH_370_IDX:
; 3015 :             s370_alter_display_real_or_abs (regs, argc, argv, cmdline); break;

  0003f	4c 8b 4c 24 58	 mov	 r9, QWORD PTR cmdline$[rsp]
  00044	4c 8b 44 24 50	 mov	 r8, QWORD PTR argv$[rsp]
  00049	8b 54 24 48	 mov	 edx, DWORD PTR argc$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	e8 00 00 00 00	 call	 s370_alter_display_real_or_abs
  00057	eb 4b		 jmp	 SHORT $LN2@alter_disp
$LN8@alter_disp:

; 3016 : #endif
; 3017 : #if defined(_390)
; 3018 :         case ARCH_390_IDX:
; 3019 :             s390_alter_display_real_or_abs (regs, argc, argv, cmdline); break;

  00059	4c 8b 4c 24 58	 mov	 r9, QWORD PTR cmdline$[rsp]
  0005e	4c 8b 44 24 50	 mov	 r8, QWORD PTR argv$[rsp]
  00063	8b 54 24 48	 mov	 edx, DWORD PTR argc$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	e8 00 00 00 00	 call	 s390_alter_display_real_or_abs
  00071	eb 31		 jmp	 SHORT $LN2@alter_disp
$LN9@alter_disp:

; 3020 : #endif
; 3021 : #if defined(_900)
; 3022 :         case ARCH_900_IDX:
; 3023 :             z900_alter_display_real_or_abs (regs, argc, argv, cmdline); break;

  00073	4c 8b 4c 24 58	 mov	 r9, QWORD PTR cmdline$[rsp]
  00078	4c 8b 44 24 50	 mov	 r8, QWORD PTR argv$[rsp]
  0007d	8b 54 24 48	 mov	 edx, DWORD PTR argc$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00086	e8 00 00 00 00	 call	 z900_alter_display_real_or_abs
  0008b	eb 17		 jmp	 SHORT $LN2@alter_disp
$LN10@alter_disp:
$LN6@alter_disp:

; 3024 : #endif
; 3025 :         default: CRASH();

  0008d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0009b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 e9		 jne	 SHORT $LN6@alter_disp
$LN2@alter_disp:

; 3026 :     }
; 3027 : 
; 3028 : } /* end function alter_display_real_or_abs */

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
alter_display_real_or_abs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
dev$ = 48
pclientip$ = 56
pclientname$ = 64
get_connected_client PROC

; 2209 : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2210 :     *pclientip   = NULL;

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR pclientip$[rsp]
  00018	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2211 :     *pclientname = NULL;

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR pclientname$[rsp]
  00024	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2212 : 
; 2213 :     obtain_lock (&dev->lock);

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00030	48 83 c0 38	 add	 rax, 56			; 00000038H
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195385
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2214 : 
; 2215 :     if (dev->bs             /* if device is a socket device,   */
; 2216 :         && dev->fd != -1)   /* and a client is connected to it */

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00051	74 4a		 je	 SHORT $LN2@get_connec
  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00058	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  0005f	74 3c		 je	 SHORT $LN2@get_connec

; 2217 :     {
; 2218 :         *pclientip   = strdup(dev->bs->clientip);

  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00066	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  0006d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00077	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pclientip$[rsp]
  0007c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2219 :         *pclientname = strdup(dev->bs->clientname);

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00084	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  0008b	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pclientname$[rsp]
  0009a	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN2@get_connec:

; 2220 :     }
; 2221 : 
; 2222 :     release_lock (&dev->lock);

  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195387
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2223 : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
get_connected_client ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
temp_arn$1 = 48
icode$ = 52
regs$ = 56
raptr$ = 96
siptr$ = 104
vaddr$ = 112
arn$ = 120
iregs$ = 128
acctype$ = 136
z900_virt_to_real PROC

; 77   : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 78   :     int icode;
; 79   :     REGS* regs = copy_regs( iregs );    /* (temporary working copy) */

  0001a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00022	e8 00 00 00 00	 call	 copy_regs
  00027	48 89 44 24 38	 mov	 QWORD PTR regs$[rsp], rax

; 80   : 
; 81   :     if (!(icode = setjmp( regs->progjmp )))

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00037	48 8b c8	 mov	 rcx, rax
  0003a	48 8b d4	 mov	 rdx, rsp
  0003d	e8 00 00 00 00	 call	 _setjmp
  00042	89 44 24 34	 mov	 DWORD PTR icode$[rsp], eax
  00046	83 7c 24 34 00	 cmp	 DWORD PTR icode$[rsp], 0
  0004b	75 7d		 jne	 SHORT $LN2@z900_virt_

; 82   :     {
; 83   :         int temp_arn = arn;     /* (bypass longjmp clobber warning) */

  0004d	8b 44 24 78	 mov	 eax, DWORD PTR arn$[rsp]
  00051	89 44 24 30	 mov	 DWORD PTR temp_arn$1[rsp], eax

; 84   : 
; 85   :         if (acctype == ACCTYPE_INSTFETCH)

  00055	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR acctype$[rsp], 4
  0005d	75 08		 jne	 SHORT $LN3@z900_virt_

; 86   :             temp_arn = USE_INST_SPACE;

  0005f	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR temp_arn$1[rsp], -1
$LN3@z900_virt_:

; 87   : 
; 88   :         if (SIE_MODE( regs ))

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00072	d1 e8		 shr	 eax, 1
  00074	83 e0 01	 and	 eax, 1
  00077	85 c0		 test	 eax, eax
  00079	74 26		 je	 SHORT $LN4@z900_virt_

; 89   :             memcpy( HOSTREGS->progjmp, regs->progjmp, sizeof( jmp_buf ));

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00087	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	48 8d b8 80 09
	00 00		 lea	 rdi, QWORD PTR [rax+2432]
  00093	48 8d b1 80 09
	00 00		 lea	 rsi, QWORD PTR [rcx+2432]
  0009a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0009f	f3 a4		 rep movsb
$LN4@z900_virt_:

; 90   : 
; 91   :         // akey (access key) = 0, len (length of data access) = 1
; 92   :         // since we're a "utility" and only interested in the address.
; 93   :         ARCH_DEP( logical_to_main_l )( (VADR)vaddr, temp_arn, regs, acctype, 0, 1 );

  000a1	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000af	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  000b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	8b 54 24 30	 mov	 edx, DWORD PTR temp_arn$1[rsp]
  000c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR vaddr$[rsp]
  000c5	e8 00 00 00 00	 call	 z900_logical_to_main_l
$LN2@z900_virt_:

; 94   :     }
; 95   : 
; 96   :     *siptr = regs->dat.stid;

  000ca	48 8b 44 24 68	 mov	 rax, QWORD PTR siptr$[rsp]
  000cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000d4	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  000da	89 08		 mov	 DWORD PTR [rax], ecx

; 97   :     *raptr = (U64) HOSTREGS->dat.raddr;

  000dc	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR raptr$[rsp]
  000ed	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  000f4	48 89 01	 mov	 QWORD PTR [rcx], rax

; 98   : 
; 99   :     free_aligned( regs );   /* (discard temporary REGS working copy) */

  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 100  : 
; 101  :     return icode;

  00102	8b 44 24 34	 mov	 eax, DWORD PTR icode$[rsp]

; 102  : 
; 103  : } /* end function virt_to_real */

  00106	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010a	5f		 pop	 rdi
  0010b	5e		 pop	 rsi
  0010c	c3		 ret	 0
z900_virt_to_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
temp_arn$1 = 48
icode$ = 52
regs$ = 56
raptr$ = 96
siptr$ = 104
vaddr$ = 112
arn$ = 120
iregs$ = 128
acctype$ = 136
s390_virt_to_real PROC

; 77   : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 78   :     int icode;
; 79   :     REGS* regs = copy_regs( iregs );    /* (temporary working copy) */

  0001a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00022	e8 00 00 00 00	 call	 copy_regs
  00027	48 89 44 24 38	 mov	 QWORD PTR regs$[rsp], rax

; 80   : 
; 81   :     if (!(icode = setjmp( regs->progjmp )))

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00037	48 8b c8	 mov	 rcx, rax
  0003a	48 8b d4	 mov	 rdx, rsp
  0003d	e8 00 00 00 00	 call	 _setjmp
  00042	89 44 24 34	 mov	 DWORD PTR icode$[rsp], eax
  00046	83 7c 24 34 00	 cmp	 DWORD PTR icode$[rsp], 0
  0004b	75 7c		 jne	 SHORT $LN2@s390_virt_

; 82   :     {
; 83   :         int temp_arn = arn;     /* (bypass longjmp clobber warning) */

  0004d	8b 44 24 78	 mov	 eax, DWORD PTR arn$[rsp]
  00051	89 44 24 30	 mov	 DWORD PTR temp_arn$1[rsp], eax

; 84   : 
; 85   :         if (acctype == ACCTYPE_INSTFETCH)

  00055	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR acctype$[rsp], 4
  0005d	75 08		 jne	 SHORT $LN3@s390_virt_

; 86   :             temp_arn = USE_INST_SPACE;

  0005f	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR temp_arn$1[rsp], -1
$LN3@s390_virt_:

; 87   : 
; 88   :         if (SIE_MODE( regs ))

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00072	d1 e8		 shr	 eax, 1
  00074	83 e0 01	 and	 eax, 1
  00077	85 c0		 test	 eax, eax
  00079	74 26		 je	 SHORT $LN4@s390_virt_

; 89   :             memcpy( HOSTREGS->progjmp, regs->progjmp, sizeof( jmp_buf ));

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00087	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	48 8d b8 80 09
	00 00		 lea	 rdi, QWORD PTR [rax+2432]
  00093	48 8d b1 80 09
	00 00		 lea	 rsi, QWORD PTR [rcx+2432]
  0009a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0009f	f3 a4		 rep movsb
$LN4@s390_virt_:

; 90   : 
; 91   :         // akey (access key) = 0, len (length of data access) = 1
; 92   :         // since we're a "utility" and only interested in the address.
; 93   :         ARCH_DEP( logical_to_main_l )( (VADR)vaddr, temp_arn, regs, acctype, 0, 1 );

  000a1	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000af	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  000b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	8b 54 24 30	 mov	 edx, DWORD PTR temp_arn$1[rsp]
  000c0	8b 4c 24 70	 mov	 ecx, DWORD PTR vaddr$[rsp]
  000c4	e8 00 00 00 00	 call	 s390_logical_to_main_l
$LN2@s390_virt_:

; 94   :     }
; 95   : 
; 96   :     *siptr = regs->dat.stid;

  000c9	48 8b 44 24 68	 mov	 rax, QWORD PTR siptr$[rsp]
  000ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  000d9	89 08		 mov	 DWORD PTR [rax], ecx

; 97   :     *raptr = (U64) HOSTREGS->dat.raddr;

  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR raptr$[rsp]
  000ec	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  000f3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 98   : 
; 99   :     free_aligned( regs );   /* (discard temporary REGS working copy) */

  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 100  : 
; 101  :     return icode;

  00101	8b 44 24 34	 mov	 eax, DWORD PTR icode$[rsp]

; 102  : 
; 103  : } /* end function virt_to_real */

  00105	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	c3		 ret	 0
s390_virt_to_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
temp_arn$1 = 48
icode$ = 52
regs$ = 56
raptr$ = 96
siptr$ = 104
vaddr$ = 112
arn$ = 120
iregs$ = 128
acctype$ = 136
s370_virt_to_real PROC

; 77   : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 78   :     int icode;
; 79   :     REGS* regs = copy_regs( iregs );    /* (temporary working copy) */

  0001a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR iregs$[rsp]
  00022	e8 00 00 00 00	 call	 copy_regs
  00027	48 89 44 24 38	 mov	 QWORD PTR regs$[rsp], rax

; 80   : 
; 81   :     if (!(icode = setjmp( regs->progjmp )))

  0002c	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00037	48 8b c8	 mov	 rcx, rax
  0003a	48 8b d4	 mov	 rdx, rsp
  0003d	e8 00 00 00 00	 call	 _setjmp
  00042	89 44 24 34	 mov	 DWORD PTR icode$[rsp], eax
  00046	83 7c 24 34 00	 cmp	 DWORD PTR icode$[rsp], 0
  0004b	75 7c		 jne	 SHORT $LN2@s370_virt_

; 82   :     {
; 83   :         int temp_arn = arn;     /* (bypass longjmp clobber warning) */

  0004d	8b 44 24 78	 mov	 eax, DWORD PTR arn$[rsp]
  00051	89 44 24 30	 mov	 DWORD PTR temp_arn$1[rsp], eax

; 84   : 
; 85   :         if (acctype == ACCTYPE_INSTFETCH)

  00055	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR acctype$[rsp], 4
  0005d	75 08		 jne	 SHORT $LN3@s370_virt_

; 86   :             temp_arn = USE_INST_SPACE;

  0005f	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR temp_arn$1[rsp], -1
$LN3@s370_virt_:

; 87   : 
; 88   :         if (SIE_MODE( regs ))

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00072	d1 e8		 shr	 eax, 1
  00074	83 e0 01	 and	 eax, 1
  00077	85 c0		 test	 eax, eax
  00079	74 26		 je	 SHORT $LN4@s370_virt_

; 89   :             memcpy( HOSTREGS->progjmp, regs->progjmp, sizeof( jmp_buf ));

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00087	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	48 8d b8 80 09
	00 00		 lea	 rdi, QWORD PTR [rax+2432]
  00093	48 8d b1 80 09
	00 00		 lea	 rsi, QWORD PTR [rcx+2432]
  0009a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0009f	f3 a4		 rep movsb
$LN4@s370_virt_:

; 90   : 
; 91   :         // akey (access key) = 0, len (length of data access) = 1
; 92   :         // since we're a "utility" and only interested in the address.
; 93   :         ARCH_DEP( logical_to_main_l )( (VADR)vaddr, temp_arn, regs, acctype, 0, 1 );

  000a1	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000af	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  000b7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	8b 54 24 30	 mov	 edx, DWORD PTR temp_arn$1[rsp]
  000c0	8b 4c 24 70	 mov	 ecx, DWORD PTR vaddr$[rsp]
  000c4	e8 00 00 00 00	 call	 s370_logical_to_main_l
$LN2@s370_virt_:

; 94   :     }
; 95   : 
; 96   :     *siptr = regs->dat.stid;

  000c9	48 8b 44 24 68	 mov	 rax, QWORD PTR siptr$[rsp]
  000ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  000d9	89 08		 mov	 DWORD PTR [rax], ecx

; 97   :     *raptr = (U64) HOSTREGS->dat.raddr;

  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR raptr$[rsp]
  000ec	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  000f3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 98   : 
; 99   :     free_aligned( regs );   /* (discard temporary REGS working copy) */

  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 100  : 
; 101  :     return icode;

  00101	8b 44 24 34	 mov	 eax, DWORD PTR icode$[rsp]

; 102  : 
; 103  : } /* end function virt_to_real */

  00105	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	c3		 ret	 0
s370_virt_to_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
nd$1 = 32
nq$2 = 40
work$3 = 48
__$ArrayPad$ = 304
rni$ = 336
len$ = 344
buf$ = 352
bufsz$ = 360
FormatRNI PROC

; 2867 : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2868 :     if (!buf)

  0002c	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00035	75 07		 jne	 SHORT $LN2@FormatRNI

; 2869 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 c8 01 00 00	 jmp	 $LN1@FormatRNI
$LN2@FormatRNI:

; 2870 :     if (bufsz)

  0003e	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00047	74 15		 je	 SHORT $LN3@FormatRNI

; 2871 :         buf[0] = 0;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0005a	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN3@FormatRNI:

; 2872 :     if (bufsz <= 1 || !rni || !len)

  0005e	48 83 bc 24 68
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00067	76 15		 jbe	 SHORT $LN5@FormatRNI
  00069	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR rni$[rsp], 0
  00072	74 0a		 je	 SHORT $LN5@FormatRNI
  00074	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0007c	75 0d		 jne	 SHORT $LN4@FormatRNI
$LN5@FormatRNI:

; 2873 :         return buf;

  0007e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00086	e9 7b 01 00 00	 jmp	 $LN1@FormatRNI
$LN4@FormatRNI:

; 2874 : 
; 2875 :     if (len >= (int)sizeof(ND))

  0008b	83 bc 24 58 01
	00 00 20	 cmp	 DWORD PTR len$[rsp], 32	; 00000020H
  00093	0f 8c 2c 01 00
	00		 jl	 $LN6@FormatRNI

; 2876 :     {
; 2877 :         char work[256];
; 2878 : 
; 2879 :         register ND* nd = (ND*) rni;

  00099	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rni$[rsp]
  000a1	48 89 44 24 20	 mov	 QWORD PTR nd$1[rsp], rax

; 2880 : 
; 2881 :         FormatND( nd, work, sizeof(work)-1);

  000a6	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  000ac	48 8d 54 24 30	 lea	 rdx, QWORD PTR work$3[rsp]
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR nd$1[rsp]
  000b6	e8 00 00 00 00	 call	 FormatND

; 2882 :         strlcat( buf, work, bufsz );

  000bb	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR bufsz$[rsp]
  000c3	48 8d 54 24 30	 lea	 rdx, QWORD PTR work$3[rsp]
  000c8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2883 : 
; 2884 :         len -= sizeof(ND);

  000d6	48 63 84 24 58
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000de	48 83 e8 20	 sub	 rax, 32			; 00000020H
  000e2	89 84 24 58 01
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 2885 :         rni += sizeof(ND);

  000e9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rni$[rsp]
  000f1	48 83 c0 20	 add	 rax, 32			; 00000020H
  000f5	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR rni$[rsp], rax

; 2886 : 
; 2887 :         if (len >= (int)sizeof(NQ))

  000fd	83 bc 24 58 01
	00 00 20	 cmp	 DWORD PTR len$[rsp], 32	; 00000020H
  00105	0f 8c 94 00 00
	00		 jl	 $LN8@FormatRNI

; 2888 :         {
; 2889 :             register NQ* nq = (NQ*) rni;

  0010b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rni$[rsp]
  00113	48 89 44 24 28	 mov	 QWORD PTR nq$2[rsp], rax

; 2890 : 
; 2891 :             FormatNQ( nq, work, sizeof(work)-1);

  00118	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  0011e	48 8d 54 24 30	 lea	 rdx, QWORD PTR work$3[rsp]
  00123	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nq$2[rsp]
  00128	e8 00 00 00 00	 call	 FormatNQ

; 2892 :             strlcat( buf, work, bufsz );

  0012d	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR bufsz$[rsp]
  00135	48 8d 54 24 30	 lea	 rdx, QWORD PTR work$3[rsp]
  0013a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2893 : 
; 2894 :             len -= sizeof(NQ);

  00148	48 63 84 24 58
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00150	48 83 e8 20	 sub	 rax, 32			; 00000020H
  00154	89 84 24 58 01
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 2895 :             rni += sizeof(NQ);

  0015b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rni$[rsp]
  00163	48 83 c0 20	 add	 rax, 32			; 00000020H
  00167	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR rni$[rsp], rax

; 2896 : 
; 2897 :             if (len)

  0016f	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00177	74 24		 je	 SHORT $LN10@FormatRNI

; 2898 :                 FormatBytes( rni, len, buf, bufsz );

  00179	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  00181	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00189	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00190	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rni$[rsp]
  00198	e8 00 00 00 00	 call	 FormatBytes
$LN10@FormatRNI:

; 2899 :         }

  0019d	eb 24		 jmp	 SHORT $LN9@FormatRNI
$LN8@FormatRNI:

; 2900 :         else
; 2901 :             FormatBytes( rni, len, buf, bufsz );

  0019f	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  001a7	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  001af	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  001b6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rni$[rsp]
  001be	e8 00 00 00 00	 call	 FormatBytes
$LN9@FormatRNI:

; 2902 :     }

  001c3	eb 24		 jmp	 SHORT $LN7@FormatRNI
$LN6@FormatRNI:

; 2903 :     else
; 2904 :         FormatBytes( rni, len, buf, bufsz );

  001c5	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  001cd	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  001d5	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  001dc	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rni$[rsp]
  001e4	e8 00 00 00 00	 call	 FormatBytes
$LN7@FormatRNI:

; 2905 : 
; 2906 :     RTRIM( buf );

  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195824
  001f0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2907 : 
; 2908 :     return buf;

  001fe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatRNI:

; 2909 : }

  00206	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020e	48 33 cc	 xor	 rcx, rsp
  00211	e8 00 00 00 00	 call	 __security_check_cookie
  00216	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0021d	c3		 ret	 0
FormatRNI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv85 = 32
temp$ = 48
__$ArrayPad$ = 304
rcd$ = 336
len$ = 344
buf$ = 352
bufsz$ = 360
FormatRCD PROC

; 2685 : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2686 :     char temp[256];
; 2687 : 
; 2688 :     if (!buf)

  0002c	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00035	75 07		 jne	 SHORT $LN7@FormatRCD

; 2689 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 79 01 00 00	 jmp	 $LN1@FormatRCD
$LN7@FormatRCD:

; 2690 :     if (bufsz)

  0003e	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00047	74 15		 je	 SHORT $LN8@FormatRCD

; 2691 :         buf[0] = 0;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0005a	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN8@FormatRCD:

; 2692 :     if (bufsz <= 1 || !rcd || !len)

  0005e	48 83 bc 24 68
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00067	76 15		 jbe	 SHORT $LN10@FormatRCD
  00069	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR rcd$[rsp], 0
  00072	74 0a		 je	 SHORT $LN10@FormatRCD
  00074	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0007c	75 0d		 jne	 SHORT $LN9@FormatRCD
$LN10@FormatRCD:

; 2693 :         return buf;

  0007e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00086	e9 2c 01 00 00	 jmp	 $LN1@FormatRCD
$LN9@FormatRCD:

; 2694 : 
; 2695 :     for (; len > 0; rcd += sizeof(NED), len -= sizeof(NED))

  0008b	eb 27		 jmp	 SHORT $LN4@FormatRCD
$LN2@FormatRCD:
  0008d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR rcd$[rsp]
  00095	48 83 c0 20	 add	 rax, 32			; 00000020H
  00099	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR rcd$[rsp], rax
  000a1	48 63 84 24 58
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000a9	48 83 e8 20	 sub	 rax, 32			; 00000020H
  000ad	89 84 24 58 01
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN4@FormatRCD:
  000b4	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  000bc	0f 8e d8 00 00
	00		 jle	 $LN3@FormatRCD

; 2696 :     {
; 2697 :         if (len < (int)sizeof(NED))

  000c2	83 bc 24 58 01
	00 00 20	 cmp	 DWORD PTR len$[rsp], 32	; 00000020H
  000ca	7d 29		 jge	 SHORT $LN11@FormatRCD

; 2698 :         {
; 2699 :             FormatBytes( rcd, len, buf, bufsz );

  000cc	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  000d4	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000dc	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  000e3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rcd$[rsp]
  000eb	e8 00 00 00 00	 call	 FormatBytes

; 2700 :             break;

  000f0	e9 a5 00 00 00	 jmp	 $LN3@FormatRCD
$LN11@FormatRCD:

; 2701 :         }
; 2702 : 
; 2703 :         switch (rcd[0] >> 6)

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rcd$[rsp]
  00106	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010a	c1 f8 06	 sar	 eax, 6
  0010d	89 44 24 20	 mov	 DWORD PTR tv85[rsp], eax
  00111	83 7c 24 20 00	 cmp	 DWORD PTR tv85[rsp], 0
  00116	74 4b		 je	 SHORT $LN15@FormatRCD
  00118	83 7c 24 20 01	 cmp	 DWORD PTR tv85[rsp], 1
  0011d	74 10		 je	 SHORT $LN12@FormatRCD
  0011f	83 7c 24 20 02	 cmp	 DWORD PTR tv85[rsp], 2
  00124	74 09		 je	 SHORT $LN13@FormatRCD
  00126	83 7c 24 20 03	 cmp	 DWORD PTR tv85[rsp], 3
  0012b	74 1c		 je	 SHORT $LN14@FormatRCD
  0012d	eb 4b		 jmp	 SHORT $LN5@FormatRCD
$LN12@FormatRCD:
$LN13@FormatRCD:

; 2704 :         {
; 2705 :         case FIELD_IS_NEQ:
; 2706 :         case FIELD_IS_GENEQ:
; 2707 : 
; 2708 :             FormatNEQ( (NEQ*)rcd, temp, sizeof(temp)-1);

  0012f	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00135	48 8d 54 24 30	 lea	 rdx, QWORD PTR temp$[rsp]
  0013a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rcd$[rsp]
  00142	e8 00 00 00 00	 call	 FormatNEQ

; 2709 :             break;

  00147	eb 31		 jmp	 SHORT $LN5@FormatRCD
$LN14@FormatRCD:

; 2710 : 
; 2711 :         case FIELD_IS_NED:
; 2712 : 
; 2713 :             FormatNED( (NED*)rcd, temp, sizeof(temp)-1);

  00149	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  0014f	48 8d 54 24 30	 lea	 rdx, QWORD PTR temp$[rsp]
  00154	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR rcd$[rsp]
  0015c	e8 00 00 00 00	 call	 FormatNED

; 2714 :             break;

  00161	eb 17		 jmp	 SHORT $LN5@FormatRCD
$LN15@FormatRCD:

; 2715 : 
; 2716 :         case FIELD_IS_UNUSED:
; 2717 : 
; 2718 :             snprintf( temp, sizeof(temp), "n/a\n" );

  00163	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195693
  0016a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0016f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR temp$[rsp]
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN5@FormatRCD:

; 2719 :             break;
; 2720 :         }
; 2721 : 
; 2722 :         strlcat( buf, temp, bufsz );

  0017a	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR bufsz$[rsp]
  00182	48 8d 54 24 30	 lea	 rdx, QWORD PTR temp$[rsp]
  00187	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2723 :     }

  00195	e9 f3 fe ff ff	 jmp	 $LN2@FormatRCD
$LN3@FormatRCD:

; 2724 : 
; 2725 :     RTRIM( buf );

  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195694
  001a1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2726 : 
; 2727 :     return buf;

  001af	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatRCD:

; 2728 : }

  001b7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bf	48 33 cc	 xor	 rcx, rsp
  001c2	e8 00 00 00 00	 call	 __security_check_cookie
  001c7	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  001ce	c3		 ret	 0
FormatRCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
temp$ = 96
__$ArrayPad$ = 224
ciw$ = 272
len$ = 280
buf$ = 288
bufsz$ = 296
FormatSID PROC

; 2963 : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	53		 push	 rbx
  00014	57		 push	 rdi
  00015	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2964 :     char temp[128];
; 2965 : 
; 2966 :     if (!buf)

  0002e	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00037	75 07		 jne	 SHORT $LN5@FormatSID

; 2967 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 48 02 00 00	 jmp	 $LN1@FormatSID
$LN5@FormatSID:

; 2968 :     if (bufsz)

  00040	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00049	74 15		 je	 SHORT $LN6@FormatSID

; 2969 :         buf[0] = 0;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	48 6b c0 00	 imul	 rax, rax, 0
  00054	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0005c	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN6@FormatSID:

; 2970 :     if (bufsz <= 1 || !ciw || !len)

  00060	48 83 bc 24 28
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00069	76 15		 jbe	 SHORT $LN8@FormatSID
  0006b	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR ciw$[rsp], 0
  00074	74 0a		 je	 SHORT $LN8@FormatSID
  00076	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0007e	75 0d		 jne	 SHORT $LN7@FormatSID
$LN8@FormatSID:

; 2971 :         return buf;

  00080	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00088	e9 fb 01 00 00	 jmp	 $LN1@FormatSID
$LN7@FormatSID:

; 2972 : 
; 2973 :     if (len < 8)

  0008d	83 bc 24 18 01
	00 00 08	 cmp	 DWORD PTR len$[rsp], 8
  00095	7d 29		 jge	 SHORT $LN9@FormatSID

; 2974 :         FormatBytes( ciw, len, buf, bufsz );

  00097	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  0009f	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000a7	8b 94 24 18 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  000ae	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ciw$[rsp]
  000b6	e8 00 00 00 00	 call	 FormatBytes
  000bb	e9 c0 01 00 00	 jmp	 $LN10@FormatSID
$LN9@FormatSID:

; 2975 :     else
; 2976 :     {
; 2977 :         snprintf( buf, bufsz,

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	48 6b c0 07	 imul	 rax, rax, 7
  000c9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ciw$[rsp]
  000d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	48 6b c9 06	 imul	 rcx, rcx, 6
  000de	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR ciw$[rsp]
  000e6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ea	ba 01 00 00 00	 mov	 edx, 1
  000ef	48 6b d2 05	 imul	 rdx, rdx, 5
  000f3	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR ciw$[rsp]
  000fb	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00100	41 b8 01 00 00
	00		 mov	 r8d, 1
  00106	4d 6b c0 04	 imul	 r8, r8, 4
  0010a	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR ciw$[rsp]
  00112	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00117	41 b9 01 00 00
	00		 mov	 r9d, 1
  0011d	4d 6b c9 03	 imul	 r9, r9, 3
  00121	4c 8b 94 24 10
	01 00 00	 mov	 r10, QWORD PTR ciw$[rsp]
  00129	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0012e	41 ba 01 00 00
	00		 mov	 r10d, 1
  00134	4d 6b d2 02	 imul	 r10, r10, 2
  00138	4c 8b 9c 24 10
	01 00 00	 mov	 r11, QWORD PTR ciw$[rsp]
  00140	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00145	41 bb 01 00 00
	00		 mov	 r11d, 1
  0014b	4d 6b db 01	 imul	 r11, r11, 1
  0014f	48 8b 9c 24 10
	01 00 00	 mov	 rbx, QWORD PTR ciw$[rsp]
  00157	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0015c	41 bb 01 00 00
	00		 mov	 r11d, 1
  00162	4d 6b db 00	 imul	 r11, r11, 0
  00166	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR ciw$[rsp]
  0016e	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00173	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00177	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0017b	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0017f	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  00184	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00189	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0018e	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00192	44 8b cf	 mov	 r9d, edi
  00195	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195880
  0019c	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  001a4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2978 : 
; 2979 :             "%02X CU=%02X%02X-%02X DEV=%02X%02X-%02X %02X\n"
; 2980 : 
; 2981 :             , ciw[0]
; 2982 :             , ciw[1], ciw[2], ciw[3]
; 2983 :             , ciw[4], ciw[5], ciw[6]
; 2984 :             , ciw[7]
; 2985 :         );
; 2986 : 
; 2987 :         ciw += 8;

  001b2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ciw$[rsp]
  001ba	48 83 c0 08	 add	 rax, 8
  001be	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ciw$[rsp], rax

; 2988 :         len -= 8;

  001c6	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001cd	83 e8 08	 sub	 eax, 8
  001d0	89 84 24 18 01
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 2989 : 
; 2990 :         for (; len >= 4; ciw += 4, len -= 4)

  001d7	eb 25		 jmp	 SHORT $LN4@FormatSID
$LN2@FormatSID:
  001d9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR ciw$[rsp]
  001e1	48 83 c0 04	 add	 rax, 4
  001e5	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ciw$[rsp], rax
  001ed	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f4	83 e8 04	 sub	 eax, 4
  001f7	89 84 24 18 01
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN4@FormatSID:
  001fe	83 bc 24 18 01
	00 00 04	 cmp	 DWORD PTR len$[rsp], 4
  00206	7c 35		 jl	 SHORT $LN3@FormatSID

; 2991 :         {
; 2992 :             FormatCIW( ciw, temp, sizeof(temp)-1);

  00208	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  0020e	48 8d 54 24 60	 lea	 rdx, QWORD PTR temp$[rsp]
  00213	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ciw$[rsp]
  0021b	e8 00 00 00 00	 call	 FormatCIW

; 2993 :             strlcat( buf, temp, bufsz );

  00220	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR bufsz$[rsp]
  00228	48 8d 54 24 60	 lea	 rdx, QWORD PTR temp$[rsp]
  0022d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 2994 :         }

  0023b	eb 9c		 jmp	 SHORT $LN2@FormatSID
$LN3@FormatSID:

; 2995 : 
; 2996 :         if (len)

  0023d	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00245	74 24		 je	 SHORT $LN11@FormatSID

; 2997 :             FormatBytes( ciw, len, buf, bufsz );

  00247	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR bufsz$[rsp]
  0024f	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00257	8b 94 24 18 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  0025e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ciw$[rsp]
  00266	e8 00 00 00 00	 call	 FormatBytes
$LN11@FormatSID:

; 2998 : 
; 2999 :         RTRIM( buf );

  0026b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195882
  00272	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
$LN10@FormatSID:

; 3000 :     }
; 3001 : 
; 3002 :     return buf;

  00280	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatSID:

; 3003 : }

  00288	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00290	48 33 cc	 xor	 rcx, rsp
  00293	e8 00 00 00 00	 call	 __security_check_cookie
  00298	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0029f	5f		 pop	 rdi
  002a0	5b		 pop	 rbx
  002a1	c3		 ret	 0
FormatSID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
newregs$ = 80
hostregs$ = 88
tv69 = 96
size$ = 104
tv77 = 112
buf$1 = 128
__$ArrayPad$ = 192
regs$ = 240
copy_regs PROC

; 2230 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2231 :  REGS  *newregs, *hostregs;
; 2232 :  size_t size;
; 2233 : 
; 2234 :     size = (SIE_MODE( regs ) || SIE_ACTIVE( regs )) ? 2 * sizeof( REGS )

  00020	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00028	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002e	d1 e8		 shr	 eax, 1
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 11		 jne	 SHORT $LN5@copy_regs
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 0b		 jne	 SHORT $LN5@copy_regs
  0003d	48 c7 44 24 60
	80 60 01 00	 mov	 QWORD PTR tv69[rsp], 90240 ; 00016080H
  00046	eb 09		 jmp	 SHORT $LN6@copy_regs
$LN5@copy_regs:
  00048	48 c7 44 24 60
	00 c1 02 00	 mov	 QWORD PTR tv69[rsp], 180480 ; 0002c100H
$LN6@copy_regs:
  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR tv69[rsp]
  00056	48 89 44 24 68	 mov	 QWORD PTR size$[rsp], rax

; 2235 :                                                     :     sizeof( REGS );
; 2236 :     if (!(newregs = malloc_aligned( size, 4096 )))

  0005b	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR size$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0006b	48 89 44 24 50	 mov	 QWORD PTR newregs$[rsp], rax
  00070	48 83 7c 24 50
	00		 cmp	 QWORD PTR newregs$[rsp], 0
  00076	0f 85 97 00 00
	00		 jne	 $LN2@copy_regs

; 2237 :     {
; 2238 :         char buf[64];
; 2239 :         MSGBUF( buf, "malloc(%d)", (int)size );

  0007c	44 8b 4c 24 68	 mov	 r9d, DWORD PTR size$[rsp]
  00081	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195403
  00088	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0008d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2240 :         // "Error in function %s: %s"
; 2241 :         WRMSG( HHC00075, "E", buf, strerror( errno ));

  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a1	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000a9	48 89 44 24 70	 mov	 QWORD PTR tv77[rsp], rax
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv77[rsp]
  000be	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000c3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000cb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195404
  000d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195405
  000e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195406
  000fa	ba c1 08 00 00	 mov	 edx, 2241		; 000008c1H
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195407
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2242 :         return NULL;

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 72 01 00 00	 jmp	 $LN1@copy_regs
$LN2@copy_regs:

; 2243 :     }
; 2244 : 
; 2245 :     /* Perform partial copy and clear the TLB */
; 2246 :     memcpy(  newregs, regs, sysblk.regs_copy_len );

  00113	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011a	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  00121	48 8b 7c 24 50	 mov	 rdi, QWORD PTR newregs$[rsp]
  00126	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR regs$[rsp]
  0012e	48 8b c8	 mov	 rcx, rax
  00131	f3 a4		 rep movsb

; 2247 :     memset( &newregs->tlb.vaddr, 0, TLBN * sizeof( DW ));

  00133	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00138	48 05 60 d0 00
	00		 add	 rax, 53344		; 0000d060H
  0013e	48 8b f8	 mov	 rdi, rax
  00141	33 c0		 xor	 eax, eax
  00143	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00148	f3 aa		 rep stosb

; 2248 : 
; 2249 :     newregs->tlbID      = 1;

  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  0014f	c7 80 58 b0 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+45144], 1

; 2250 :     newregs->ghostregs  = 1;      /* indicate these aren't real regs */

  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  0015e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00164	0f ba e8 0d	 bts	 eax, 13
  00168	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  0016d	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2251 :     HOST(  newregs )    = newregs;

  00173	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00178	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  0017d	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 2252 :     GUEST( newregs )    = NULL;

  00184	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00189	48 c7 80 70 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+2160], 0

; 2253 :     newregs->sie_active = 0;

  00194	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00199	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0019f	83 e0 fe	 and	 eax, -2			; fffffffeH
  001a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  001a7	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 2254 : 
; 2255 :     /* Copy host regs if in SIE mode (newregs is SIE guest regs) */
; 2256 :     if (SIE_MODE( newregs ))

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  001b2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b8	d1 e8		 shr	 eax, 1
  001ba	83 e0 01	 and	 eax, 1
  001bd	85 c0		 test	 eax, eax
  001bf	0f 84 bb 00 00
	00		 je	 $LN3@copy_regs

; 2257 :     {
; 2258 :         hostregs = newregs + 1;

  001c5	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  001ca	48 05 80 60 01
	00		 add	 rax, 90240		; 00016080H
  001d0	48 89 44 24 58	 mov	 QWORD PTR hostregs$[rsp], rax

; 2259 : 
; 2260 :         memcpy(  hostregs, HOSTREGS, sysblk.regs_copy_len );

  001d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001dc	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  001e3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	48 8b 7c 24 58	 mov	 rdi, QWORD PTR hostregs$[rsp]
  001f0	48 8b b1 68 08
	00 00		 mov	 rsi, QWORD PTR [rcx+2152]
  001f7	48 8b c8	 mov	 rcx, rax
  001fa	f3 a4		 rep movsb

; 2261 :         memset( &hostregs->tlb.vaddr, 0, TLBN * sizeof( DW ));

  001fc	48 8b 44 24 58	 mov	 rax, QWORD PTR hostregs$[rsp]
  00201	48 05 60 d0 00
	00		 add	 rax, 53344		; 0000d060H
  00207	48 8b f8	 mov	 rdi, rax
  0020a	33 c0		 xor	 eax, eax
  0020c	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00211	f3 aa		 rep stosb

; 2262 : 
; 2263 :         hostregs->tlbID     = 1;

  00213	48 8b 44 24 58	 mov	 rax, QWORD PTR hostregs$[rsp]
  00218	c7 80 58 b0 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+45144], 1

; 2264 :         hostregs->ghostregs = 1;  /* indicate these aren't real regs */

  00222	48 8b 44 24 58	 mov	 rax, QWORD PTR hostregs$[rsp]
  00227	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0022d	0f ba e8 0d	 bts	 eax, 13
  00231	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hostregs$[rsp]
  00236	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2265 : 
; 2266 :         HOST(  hostregs )   = hostregs;

  0023c	48 8b 44 24 58	 mov	 rax, QWORD PTR hostregs$[rsp]
  00241	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hostregs$[rsp]
  00246	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 2267 :         GUEST( hostregs )   = newregs;

  0024d	48 8b 44 24 58	 mov	 rax, QWORD PTR hostregs$[rsp]
  00252	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  00257	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx

; 2268 : 
; 2269 :         HOST(  newregs  )   = hostregs;

  0025e	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00263	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hostregs$[rsp]
  00268	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 2270 :         GUEST( newregs  )   = newregs;

  0026f	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
  00274	48 8b 4c 24 50	 mov	 rcx, QWORD PTR newregs$[rsp]
  00279	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx
$LN3@copy_regs:

; 2271 :     }
; 2272 : 
; 2273 :     return newregs;

  00280	48 8b 44 24 50	 mov	 rax, QWORD PTR newregs$[rsp]
$LN1@copy_regs:

; 2274 : }

  00285	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0028d	48 33 cc	 xor	 rcx, rsp
  00290	e8 00 00 00 00	 call	 __security_check_cookie
  00295	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0029c	5f		 pop	 rdi
  0029d	5e		 pop	 rsi
  0029e	c3		 ret	 0
copy_regs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
delim$ = 80
n$ = 84
h1$ = 88
h2$ = 92
s$ = 96
saddr$ = 104
rc$ = 112
eaddr$ = 120
c$ = 128
tv194 = 132
tv195 = 136
tv219 = 140
tv220 = 144
opnd1$ = 152
str$1 = 160
opnd2$ = 168
tv280 = 176
operand$ = 208
maxadr$ = 216
sadrp$ = 224
eadrp$ = 232
newval$ = 240
parse_range PROC

; 2070 : {

$LN42:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2071 : U64     opnd1, opnd2;                   /* Address/length operands   */
; 2072 : U64     saddr, eaddr;                   /* Range start/end addresses */
; 2073 : int     rc;                             /* Return code               */
; 2074 : int     n;                              /* Number of bytes altered   */
; 2075 : int     h1, h2;                         /* Hexadecimal digits        */
; 2076 : char    *s;                             /* Alteration value pointer  */
; 2077 : BYTE    delim;                          /* Operand delimiter         */
; 2078 : BYTE    c;                              /* Character work area       */
; 2079 : 
; 2080 :     if (!operand)

  0001b	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR operand$[rsp], 0
  00024	75 51		 jne	 SHORT $LN7@parse_rang

; 2081 :     {
; 2082 :         // "Missing or invalid argument(s)"
; 2083 :         WRMSG( HHC17000, "E" );

  00026	b9 01 00 00 00	 mov	 ecx, 1
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195312
  00038	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195313
  00044	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00049	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195314
  0005b	ba 23 08 00 00	 mov	 edx, 2083		; 00000823H
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195315
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2084 :         return -1;

  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	e9 43 07 00 00	 jmp	 $LN1@parse_rang
$LN7@parse_rang:

; 2085 :     }
; 2086 : 
; 2087 :     rc = sscanf(operand, "%"SCNx64"%c%"SCNx64"%c",

  00077	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR c$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR opnd2$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 4c 24 50	 lea	 r9, QWORD PTR delim$[rsp]
  00096	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR opnd1$[rsp]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195316
  000a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR operand$[rsp]
  000ad	e8 00 00 00 00	 call	 sscanf
  000b2	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2088 :                 &opnd1, &delim, &opnd2, &c);
; 2089 : 
; 2090 :     if (rc == 2 && delim == '=' && newval)

  000b6	83 7c 24 70 02	 cmp	 DWORD PTR rc$[rsp], 2
  000bb	0f 85 fa 01 00
	00		 jne	 $LN8@parse_rang
  000c1	0f b6 44 24 50	 movzx	 eax, BYTE PTR delim$[rsp]
  000c6	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  000c9	0f 85 ec 01 00
	00		 jne	 $LN8@parse_rang
  000cf	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR newval$[rsp], 0
  000d8	0f 84 dd 01 00
	00		 je	 $LN8@parse_rang

; 2091 :     {
; 2092 :         /* Parse new startaddr="string" syntax */
; 2093 : 
; 2094 :         s = strchr( operand, '=' );

  000de	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  000e3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR operand$[rsp]
  000eb	e8 00 00 00 00	 call	 strchr
  000f0	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 2095 :         if (s[1] == '"' || s[1] == '\'')

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 01	 imul	 rax, rax, 1
  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00103	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00107	83 f8 22	 cmp	 eax, 34			; 00000022H
  0010a	74 1b		 je	 SHORT $LN10@parse_rang
  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	48 6b c0 01	 imul	 rax, rax, 1
  00115	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0011a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0011e	83 f8 27	 cmp	 eax, 39			; 00000027H
  00121	0f 85 94 01 00
	00		 jne	 $LN9@parse_rang
$LN10@parse_rang:

; 2096 :         {
; 2097 :             char* str = s+2;

  00127	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0012c	48 83 c0 02	 add	 rax, 2
  00130	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR str$1[rsp], rax

; 2098 : 
; 2099 :             for (n=0; str[n]; ++n)

  00138	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00140	eb 0a		 jmp	 SHORT $LN4@parse_rang
$LN2@parse_rang:
  00142	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
$LN4@parse_rang:
  0014c	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00151	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR str$1[rsp]
  00159	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0015d	85 c0		 test	 eax, eax
  0015f	74 30		 je	 SHORT $LN3@parse_rang

; 2100 :                 if (n < 32)

  00161	83 7c 24 54 20	 cmp	 DWORD PTR n$[rsp], 32	; 00000020H
  00166	7d 27		 jge	 SHORT $LN11@parse_rang

; 2101 :                     newval[n] = host_to_guest( str[n] );

  00168	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0016d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR str$1[rsp]
  00175	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0017f	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR n$[rsp]
  00184	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR newval$[rsp]
  0018c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN11@parse_rang:
  0018f	eb b1		 jmp	 SHORT $LN2@parse_rang
$LN3@parse_rang:

; 2102 : 
; 2103 :             if (!n)

  00191	83 7c 24 54 00	 cmp	 DWORD PTR n$[rsp], 0
  00196	75 69		 jne	 SHORT $LN12@parse_rang

; 2104 :             {
; 2105 :                 // "Invalid argument %s%s"
; 2106 :                 WRMSG( HHC02205, "E", "\"", ": string expected");

  00198	b9 01 00 00 00	 mov	 ecx, 1
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195322
  001aa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195323
  001b6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195324
  001c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195325
  001ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  001de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195326
  001e5	ba 3a 08 00 00	 mov	 edx, 2106		; 0000083aH
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195327
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2107 :                 return -1;

  001f7	b8 ff ff ff ff	 mov	 eax, -1
  001fc	e9 b9 05 00 00	 jmp	 $LN1@parse_rang
$LN12@parse_rang:

; 2108 :             }
; 2109 : 
; 2110 :             if (n > 32)

  00201	83 7c 24 54 20	 cmp	 DWORD PTR n$[rsp], 32	; 00000020H
  00206	7e 69		 jle	 SHORT $LN13@parse_rang

; 2111 :             {
; 2112 :                 // "Invalid argument %s%s"
; 2113 :                 WRMSG( HHC02205, "E", "\"", ": maximum string length is 32 characters");

  00208	b9 01 00 00 00	 mov	 ecx, 1
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195329
  0021a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195330
  00226	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195331
  00232	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195332
  0023e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195333
  00255	ba 41 08 00 00	 mov	 edx, 2113		; 00000841H
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195334
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2114 :                 return -1;

  00267	b8 ff ff ff ff	 mov	 eax, -1
  0026c	e9 49 05 00 00	 jmp	 $LN1@parse_rang
$LN13@parse_rang:

; 2115 :             }
; 2116 : 
; 2117 :             saddr = opnd1;

  00271	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR opnd1$[rsp]
  00279	48 89 44 24 68	 mov	 QWORD PTR saddr$[rsp], rax

; 2118 :             eaddr = saddr + n - 1;

  0027e	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00283	48 8b 4c 24 68	 mov	 rcx, QWORD PTR saddr$[rsp]
  00288	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0028d	48 89 44 24 78	 mov	 QWORD PTR eaddr$[rsp], rax

; 2119 : 
; 2120 :             *sadrp = saddr;

  00292	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR sadrp$[rsp]
  0029a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR saddr$[rsp]
  0029f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2121 :             *eadrp = eaddr;

  002a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR eadrp$[rsp]
  002aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR eaddr$[rsp]
  002af	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2122 : 
; 2123 :             return n;

  002b2	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  002b6	e9 ff 04 00 00	 jmp	 $LN1@parse_rang
$LN9@parse_rang:
$LN8@parse_rang:

; 2124 :         }
; 2125 :     }
; 2126 : 
; 2127 :     /* Process storage alteration operand */
; 2128 :     if (rc > 2 && delim == '=' && newval)

  002bb	83 7c 24 70 02	 cmp	 DWORD PTR rc$[rsp], 2
  002c0	0f 8e 2c 03 00
	00		 jle	 $LN14@parse_rang
  002c6	0f b6 44 24 50	 movzx	 eax, BYTE PTR delim$[rsp]
  002cb	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  002ce	0f 85 1e 03 00
	00		 jne	 $LN14@parse_rang
  002d4	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR newval$[rsp], 0
  002dd	0f 84 0f 03 00
	00		 je	 $LN14@parse_rang

; 2129 :     {
; 2130 :         s = strchr (operand, '=');

  002e3	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  002e8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR operand$[rsp]
  002f0	e8 00 00 00 00	 call	 strchr
  002f5	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 2131 :         n = 0;

  002fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
$LN41@parse_rang:
$LN5@parse_rang:

; 2132 :         while (1)

  00302	33 c0		 xor	 eax, eax
  00304	83 f8 01	 cmp	 eax, 1
  00307	0f 84 bf 02 00
	00		 je	 $LN6@parse_rang

; 2133 :         {
; 2134 :             h1 = *(++s);

  0030d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00312	48 ff c0	 inc	 rax
  00315	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax
  0031a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0031f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00322	89 44 24 58	 mov	 DWORD PTR h1$[rsp], eax

; 2135 :             if (h1 == '\0'  || h1 == '#' ) break;

  00326	83 7c 24 58 00	 cmp	 DWORD PTR h1$[rsp], 0
  0032b	74 07		 je	 SHORT $LN17@parse_rang
  0032d	83 7c 24 58 23	 cmp	 DWORD PTR h1$[rsp], 35	; 00000023H
  00332	75 05		 jne	 SHORT $LN16@parse_rang
$LN17@parse_rang:
  00334	e9 93 02 00 00	 jmp	 $LN6@parse_rang
$LN16@parse_rang:

; 2136 :             if (h1 == SPACE || h1 == '\t') continue;

  00339	83 7c 24 58 20	 cmp	 DWORD PTR h1$[rsp], 32	; 00000020H
  0033e	74 07		 je	 SHORT $LN19@parse_rang
  00340	83 7c 24 58 09	 cmp	 DWORD PTR h1$[rsp], 9
  00345	75 02		 jne	 SHORT $LN18@parse_rang
$LN19@parse_rang:
  00347	eb b9		 jmp	 SHORT $LN5@parse_rang
$LN18@parse_rang:

; 2137 :             h1 = toupper(h1);

  00349	8b 4c 24 58	 mov	 ecx, DWORD PTR h1$[rsp]
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00353	89 44 24 58	 mov	 DWORD PTR h1$[rsp], eax

; 2138 :             h1 = (h1 >= '0' && h1 <= '9') ? h1 - '0' :

  00357	83 7c 24 58 30	 cmp	 DWORD PTR h1$[rsp], 48	; 00000030H
  0035c	7c 17		 jl	 SHORT $LN31@parse_rang
  0035e	83 7c 24 58 39	 cmp	 DWORD PTR h1$[rsp], 57	; 00000039H
  00363	7f 10		 jg	 SHORT $LN31@parse_rang
  00365	8b 44 24 58	 mov	 eax, DWORD PTR h1$[rsp]
  00369	83 e8 30	 sub	 eax, 48			; 00000030H
  0036c	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  00373	eb 37		 jmp	 SHORT $LN34@parse_rang
$LN31@parse_rang:
  00375	83 7c 24 58 41	 cmp	 DWORD PTR h1$[rsp], 65	; 00000041H
  0037a	7c 17		 jl	 SHORT $LN32@parse_rang
  0037c	83 7c 24 58 46	 cmp	 DWORD PTR h1$[rsp], 70	; 00000046H
  00381	7f 10		 jg	 SHORT $LN32@parse_rang
  00383	8b 44 24 58	 mov	 eax, DWORD PTR h1$[rsp]
  00387	83 e8 37	 sub	 eax, 55			; 00000037H
  0038a	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00391	eb 0b		 jmp	 SHORT $LN33@parse_rang
$LN32@parse_rang:
  00393	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv194[rsp], -1
$LN33@parse_rang:
  0039e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv194[rsp]
  003a5	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
$LN34@parse_rang:
  003ac	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv195[rsp]
  003b3	89 44 24 58	 mov	 DWORD PTR h1$[rsp], eax

; 2139 :                  (h1 >= 'A' && h1 <= 'F') ? h1 - 'A' + 10 : -1;
; 2140 :             if (h1 < 0)

  003b7	83 7c 24 58 00	 cmp	 DWORD PTR h1$[rsp], 0
  003bc	7d 67		 jge	 SHORT $LN20@parse_rang

; 2141 :             {
; 2142 :                 WRMSG(HHC02205, "E", s, ": invalid hex digit");

  003be	b9 01 00 00 00	 mov	 ecx, 1
  003c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195342
  003d0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003da	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195343
  003e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195344
  003f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00402	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195345
  00409	ba 5e 08 00 00	 mov	 edx, 2142		; 0000085eH
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195346
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2143 :                 return -1;

  0041b	b8 ff ff ff ff	 mov	 eax, -1
  00420	e9 95 03 00 00	 jmp	 $LN1@parse_rang
$LN20@parse_rang:

; 2144 :             }
; 2145 :             h2 = *(++s);

  00425	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0042a	48 ff c0	 inc	 rax
  0042d	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax
  00432	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00437	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0043a	89 44 24 5c	 mov	 DWORD PTR h2$[rsp], eax

; 2146 :             h2 = toupper(h2);

  0043e	8b 4c 24 5c	 mov	 ecx, DWORD PTR h2$[rsp]
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00448	89 44 24 5c	 mov	 DWORD PTR h2$[rsp], eax

; 2147 :             h2 = (h2 >= '0' && h2 <= '9') ? h2 - '0' :

  0044c	83 7c 24 5c 30	 cmp	 DWORD PTR h2$[rsp], 48	; 00000030H
  00451	7c 17		 jl	 SHORT $LN35@parse_rang
  00453	83 7c 24 5c 39	 cmp	 DWORD PTR h2$[rsp], 57	; 00000039H
  00458	7f 10		 jg	 SHORT $LN35@parse_rang
  0045a	8b 44 24 5c	 mov	 eax, DWORD PTR h2$[rsp]
  0045e	83 e8 30	 sub	 eax, 48			; 00000030H
  00461	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  00468	eb 37		 jmp	 SHORT $LN38@parse_rang
$LN35@parse_rang:
  0046a	83 7c 24 5c 41	 cmp	 DWORD PTR h2$[rsp], 65	; 00000041H
  0046f	7c 17		 jl	 SHORT $LN36@parse_rang
  00471	83 7c 24 5c 46	 cmp	 DWORD PTR h2$[rsp], 70	; 00000046H
  00476	7f 10		 jg	 SHORT $LN36@parse_rang
  00478	8b 44 24 5c	 mov	 eax, DWORD PTR h2$[rsp]
  0047c	83 e8 37	 sub	 eax, 55			; 00000037H
  0047f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
  00486	eb 0b		 jmp	 SHORT $LN37@parse_rang
$LN36@parse_rang:
  00488	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv219[rsp], -1
$LN37@parse_rang:
  00493	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv219[rsp]
  0049a	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv220[rsp], eax
$LN38@parse_rang:
  004a1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv220[rsp]
  004a8	89 44 24 5c	 mov	 DWORD PTR h2$[rsp], eax

; 2148 :                  (h2 >= 'A' && h2 <= 'F') ? h2 - 'A' + 10 : -1;
; 2149 :             if (h2 < 0)

  004ac	83 7c 24 5c 00	 cmp	 DWORD PTR h2$[rsp], 0
  004b1	7d 74		 jge	 SHORT $LN21@parse_rang

; 2150 :             {
; 2151 :                 WRMSG(HHC02205, "E", --s, ": invalid hex pair");

  004b3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  004b8	48 ff c8	 dec	 rax
  004bb	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax
  004c0	b9 01 00 00 00	 mov	 ecx, 1
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195348
  004d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004dc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195349
  004e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195350
  004f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00504	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195351
  0050b	ba 67 08 00 00	 mov	 edx, 2151		; 00000867H
  00510	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195352
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2152 :                 return -1;

  0051d	b8 ff ff ff ff	 mov	 eax, -1
  00522	e9 93 02 00 00	 jmp	 $LN1@parse_rang
$LN21@parse_rang:

; 2153 :             }
; 2154 :             if (n >= 32)

  00527	83 7c 24 54 20	 cmp	 DWORD PTR n$[rsp], 32	; 00000020H
  0052c	7c 74		 jl	 SHORT $LN22@parse_rang

; 2155 :             {
; 2156 :                 WRMSG(HHC02205, "E", --s, ": only a maximum of 32 bytes may be altered");

  0052e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00533	48 ff c8	 dec	 rax
  00536	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax
  0053b	b9 01 00 00 00	 mov	 ecx, 1
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00546	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195354
  0054d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00552	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00557	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195355
  00563	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195356
  0056f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00574	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00579	41 b9 03 00 00
	00		 mov	 r9d, 3
  0057f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195357
  00586	ba 6c 08 00 00	 mov	 edx, 2156		; 0000086cH
  0058b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195358
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2157 :                 return -1;

  00598	b8 ff ff ff ff	 mov	 eax, -1
  0059d	e9 18 02 00 00	 jmp	 $LN1@parse_rang
$LN22@parse_rang:

; 2158 :             }
; 2159 :             newval[n++] = (h1 << 4) | h2;

  005a2	8b 44 24 58	 mov	 eax, DWORD PTR h1$[rsp]
  005a6	c1 e0 04	 shl	 eax, 4
  005a9	0b 44 24 5c	 or	 eax, DWORD PTR h2$[rsp]
  005ad	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR n$[rsp]
  005b2	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR newval$[rsp]
  005ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005bd	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  005c1	ff c0		 inc	 eax
  005c3	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax

; 2160 :         } /* end for(n) */

  005c7	e9 36 fd ff ff	 jmp	 $LN41@parse_rang
$LN6@parse_rang:

; 2161 :         saddr = opnd1;

  005cc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR opnd1$[rsp]
  005d4	48 89 44 24 68	 mov	 QWORD PTR saddr$[rsp], rax

; 2162 :         eaddr = saddr + n - 1;

  005d9	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  005de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR saddr$[rsp]
  005e3	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  005e8	48 89 44 24 78	 mov	 QWORD PTR eaddr$[rsp], rax

; 2163 :     }

  005ed	e9 13 01 00 00	 jmp	 $LN15@parse_rang
$LN14@parse_rang:

; 2164 :     else
; 2165 :     {
; 2166 :         /* Process storage range operand */
; 2167 :         saddr = opnd1;

  005f2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR opnd1$[rsp]
  005fa	48 89 44 24 68	 mov	 QWORD PTR saddr$[rsp], rax

; 2168 :         if (rc == 1)

  005ff	83 7c 24 70 01	 cmp	 DWORD PTR rc$[rsp], 1
  00604	75 2f		 jne	 SHORT $LN23@parse_rang

; 2169 :         {
; 2170 :             /* If only starting address is specified, default to
; 2171 :                64 byte display, or less if near end of storage */
; 2172 :             eaddr = saddr + 0x3F;

  00606	48 8b 44 24 68	 mov	 rax, QWORD PTR saddr$[rsp]
  0060b	48 83 c0 3f	 add	 rax, 63			; 0000003fH
  0060f	48 89 44 24 78	 mov	 QWORD PTR eaddr$[rsp], rax

; 2173 :             if (eaddr > maxadr) eaddr = maxadr;

  00614	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR maxadr$[rsp]
  0061c	48 39 44 24 78	 cmp	 QWORD PTR eaddr$[rsp], rax
  00621	76 0d		 jbe	 SHORT $LN25@parse_rang
  00623	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR maxadr$[rsp]
  0062b	48 89 44 24 78	 mov	 QWORD PTR eaddr$[rsp], rax
$LN25@parse_rang:

; 2174 :         }

  00630	e9 c8 00 00 00	 jmp	 $LN24@parse_rang
$LN23@parse_rang:

; 2175 :         else
; 2176 :         {
; 2177 :             /* Ending address or length is specified */
; 2178 :             if (rc != 3 || !(delim == '-' || delim == '.'))

  00635	83 7c 24 70 03	 cmp	 DWORD PTR rc$[rsp], 3
  0063a	75 14		 jne	 SHORT $LN27@parse_rang
  0063c	0f b6 44 24 50	 movzx	 eax, BYTE PTR delim$[rsp]
  00641	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00644	74 74		 je	 SHORT $LN26@parse_rang
  00646	0f b6 44 24 50	 movzx	 eax, BYTE PTR delim$[rsp]
  0064b	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0064e	74 6a		 je	 SHORT $LN26@parse_rang
$LN27@parse_rang:

; 2179 :             {
; 2180 :                 WRMSG(HHC02205, "E", operand, "");

  00650	b9 01 00 00 00	 mov	 ecx, 1
  00655	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0065b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195364
  00662	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00667	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR operand$[rsp]
  0066f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00674	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195365
  0067b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00680	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195366
  00687	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0068c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00691	41 b9 03 00 00
	00		 mov	 r9d, 3
  00697	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195367
  0069e	ba 84 08 00 00	 mov	 edx, 2180		; 00000884H
  006a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195368
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2181 :                 return -1;

  006b0	b8 ff ff ff ff	 mov	 eax, -1
  006b5	e9 00 01 00 00	 jmp	 $LN1@parse_rang
$LN26@parse_rang:

; 2182 :             }
; 2183 :             eaddr = (delim == '.') ? saddr + opnd2 - 1 : opnd2;

  006ba	0f b6 44 24 50	 movzx	 eax, BYTE PTR delim$[rsp]
  006bf	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  006c2	75 1c		 jne	 SHORT $LN39@parse_rang
  006c4	48 8b 44 24 68	 mov	 rax, QWORD PTR saddr$[rsp]
  006c9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR opnd2$[rsp]
  006d1	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  006d6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  006de	eb 10		 jmp	 SHORT $LN40@parse_rang
$LN39@parse_rang:
  006e0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR opnd2$[rsp]
  006e8	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
$LN40@parse_rang:
  006f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv280[rsp]
  006f8	48 89 44 24 78	 mov	 QWORD PTR eaddr$[rsp], rax
$LN24@parse_rang:

; 2184 :         }
; 2185 :         /* Set n=0 to indicate storage display only */
; 2186 :         n = 0;

  006fd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
$LN15@parse_rang:

; 2187 :     }
; 2188 : 
; 2189 :     /* Check for valid range */
; 2190 :     if (saddr > maxadr || eaddr > maxadr || eaddr < saddr)

  00705	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR maxadr$[rsp]
  0070d	48 39 44 24 68	 cmp	 QWORD PTR saddr$[rsp], rax
  00712	77 1b		 ja	 SHORT $LN29@parse_rang
  00714	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR maxadr$[rsp]
  0071c	48 39 44 24 78	 cmp	 QWORD PTR eaddr$[rsp], rax
  00721	77 0c		 ja	 SHORT $LN29@parse_rang
  00723	48 8b 44 24 68	 mov	 rax, QWORD PTR saddr$[rsp]
  00728	48 39 44 24 78	 cmp	 QWORD PTR eaddr$[rsp], rax
  0072d	73 67		 jae	 SHORT $LN28@parse_rang
$LN29@parse_rang:

; 2191 :     {
; 2192 :         WRMSG(HHC02205, "E", operand, ": invalid range");

  0072f	b9 01 00 00 00	 mov	 ecx, 1
  00734	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0073a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195371
  00741	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00746	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR operand$[rsp]
  0074e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195372
  0075a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195373
  00766	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0076b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00770	41 b9 03 00 00
	00		 mov	 r9d, 3
  00776	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195374
  0077d	ba 90 08 00 00	 mov	 edx, 2192		; 00000890H
  00782	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195375
  00789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2193 :         return -1;

  0078f	b8 ff ff ff ff	 mov	 eax, -1
  00794	eb 24		 jmp	 SHORT $LN1@parse_rang
$LN28@parse_rang:

; 2194 :     }
; 2195 : 
; 2196 :     /* Return start/end addresses and number of bytes altered */
; 2197 :     *sadrp = saddr;

  00796	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR sadrp$[rsp]
  0079e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR saddr$[rsp]
  007a3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2198 :     *eadrp = eaddr;

  007a6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR eadrp$[rsp]
  007ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR eaddr$[rsp]
  007b3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2199 :     return n;

  007b6	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
$LN1@parse_rang:

; 2200 : 
; 2201 : } /* end function parse_range */

  007ba	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  007c1	c3		 ret	 0
parse_range ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv69 = 48
erw$ = 64
scl$ = 128
__$ArrayPad$ = 192
esw$ = 224
buf$ = 232
bufsz$ = 240
FormatESW PROC

; 2464 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2465 : char scl[64];                               /* Subchannel Logout     */
; 2466 : char erw[64];                               /* Extended-Report Word  */
; 2467 : 
; 2468 :     if (!buf)

  00028	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00031	75 07		 jne	 SHORT $LN2@FormatESW

; 2469 :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 a0 00 00 00	 jmp	 $LN1@FormatESW
$LN2@FormatESW:

; 2470 :     if (bufsz)

  0003a	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00043	74 0b		 je	 SHORT $LN3@FormatESW

; 2471 :         *buf = 0;

  00045	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0004d	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@FormatESW:

; 2472 :     if (bufsz <= 1 || !esw)

  00050	48 83 bc 24 f0
	00 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00059	76 0b		 jbe	 SHORT $LN5@FormatESW
  0005b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR esw$[rsp], 0
  00064	75 0a		 jne	 SHORT $LN4@FormatESW
$LN5@FormatESW:

; 2473 :         return buf;

  00066	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0006e	eb 6a		 jmp	 SHORT $LN1@FormatESW
$LN4@FormatESW:

; 2474 : 
; 2475 :     snprintf( buf, bufsz,

  00070	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00076	48 8d 54 24 40	 lea	 rdx, QWORD PTR erw$[rsp]
  0007b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR esw$[rsp]
  00083	e8 00 00 00 00	 call	 FormatERW
  00088	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
  0008d	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00093	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR scl$[rsp]
  0009b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR esw$[rsp]
  000a3	e8 00 00 00 00	 call	 FormatSCL
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv69[rsp]
  000ad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b2	4c 8b c8	 mov	 r9, rax
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195534
  000bc	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  000c4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2476 : 
; 2477 :         "SCL = %s, ERW = %s"
; 2478 : 
; 2479 :         , FormatSCL( esw, scl, _countof( scl ))
; 2480 :         , FormatERW( esw, erw, _countof( erw ))
; 2481 :     );
; 2482 : 
; 2483 :     return buf;

  000d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatESW:

; 2484 : }

  000da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e2	48 33 cc	 xor	 rcx, rsp
  000e5	e8 00 00 00 00	 call	 __security_check_cookie
  000ea	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  000f1	c3		 ret	 0
FormatESW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv77 = 112
tv83 = 116
tv89 = 120
tv95 = 124
tv133 = 128
tv139 = 132
tv145 = 136
tv151 = 140
tv157 = 144
tv163 = 148
esw$ = 176
buf$ = 184
bufsz$ = 192
FormatERW PROC

; 2429 : {

$LN27:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2430 :     if (!buf)

  00016	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@FormatERW

; 2431 :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 6a 02 00 00	 jmp	 $LN1@FormatERW
$LN2@FormatERW:

; 2432 :     if (bufsz)

  00028	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00031	74 0b		 je	 SHORT $LN3@FormatERW

; 2433 :         *buf = 0;

  00033	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0003b	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@FormatERW:

; 2434 :     if (bufsz <= 1 || !esw)

  0003e	48 83 bc 24 c0
	00 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00047	76 0b		 jbe	 SHORT $LN5@FormatERW
  00049	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR esw$[rsp], 0
  00052	75 0d		 jne	 SHORT $LN4@FormatERW
$LN5@FormatERW:

; 2435 :         return buf;

  00054	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0005c	e9 31 02 00 00	 jmp	 $LN1@FormatERW
$LN4@FormatERW:

; 2436 : 
; 2437 :     snprintf( buf, bufsz,

  00061	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00069	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0006d	83 e0 40	 and	 eax, 64			; 00000040H
  00070	85 c0		 test	 eax, eax
  00072	74 0a		 je	 SHORT $LN7@FormatERW
  00074	c7 44 24 70 52
	00 00 00	 mov	 DWORD PTR tv77[rsp], 82	; 00000052H
  0007c	eb 08		 jmp	 SHORT $LN8@FormatERW
$LN7@FormatERW:
  0007e	c7 44 24 70 2e
	00 00 00	 mov	 DWORD PTR tv77[rsp], 46	; 0000002eH
$LN8@FormatERW:
  00086	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0008e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	74 0a		 je	 SHORT $LN9@FormatERW
  0009b	c7 44 24 74 43
	00 00 00	 mov	 DWORD PTR tv83[rsp], 67	; 00000043H
  000a3	eb 08		 jmp	 SHORT $LN10@FormatERW
$LN9@FormatERW:
  000a5	c7 44 24 74 2e
	00 00 00	 mov	 DWORD PTR tv83[rsp], 46	; 0000002eH
$LN10@FormatERW:
  000ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  000b5	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000b9	83 e0 01	 and	 eax, 1
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN11@FormatERW
  000c0	c7 44 24 78 53
	00 00 00	 mov	 DWORD PTR tv89[rsp], 83	; 00000053H
  000c8	eb 08		 jmp	 SHORT $LN12@FormatERW
$LN11@FormatERW:
  000ca	c7 44 24 78 2e
	00 00 00	 mov	 DWORD PTR tv89[rsp], 46	; 0000002eH
$LN12@FormatERW:
  000d2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  000da	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000de	83 e0 02	 and	 eax, 2
  000e1	85 c0		 test	 eax, eax
  000e3	74 0a		 je	 SHORT $LN13@FormatERW
  000e5	c7 44 24 7c 46
	00 00 00	 mov	 DWORD PTR tv95[rsp], 70	; 00000046H
  000ed	eb 08		 jmp	 SHORT $LN14@FormatERW
$LN13@FormatERW:
  000ef	c7 44 24 7c 2e
	00 00 00	 mov	 DWORD PTR tv95[rsp], 46	; 0000002eH
$LN14@FormatERW:
  000f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  000ff	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00103	83 e0 04	 and	 eax, 4
  00106	85 c0		 test	 eax, eax
  00108	74 0d		 je	 SHORT $LN15@FormatERW
  0010a	c7 84 24 80 00
	00 00 54 00 00
	00		 mov	 DWORD PTR tv133[rsp], 84 ; 00000054H
  00115	eb 0b		 jmp	 SHORT $LN16@FormatERW
$LN15@FormatERW:
  00117	c7 84 24 80 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv133[rsp], 46 ; 0000002eH
$LN16@FormatERW:
  00122	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0012a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0012e	83 e0 08	 and	 eax, 8
  00131	85 c0		 test	 eax, eax
  00133	74 0d		 je	 SHORT $LN17@FormatERW
  00135	c7 84 24 84 00
	00 00 50 00 00
	00		 mov	 DWORD PTR tv139[rsp], 80 ; 00000050H
  00140	eb 0b		 jmp	 SHORT $LN18@FormatERW
$LN17@FormatERW:
  00142	c7 84 24 84 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv139[rsp], 46 ; 0000002eH
$LN18@FormatERW:
  0014d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00155	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00159	83 e0 10	 and	 eax, 16
  0015c	85 c0		 test	 eax, eax
  0015e	74 0d		 je	 SHORT $LN19@FormatERW
  00160	c7 84 24 88 00
	00 00 41 00 00
	00		 mov	 DWORD PTR tv145[rsp], 65 ; 00000041H
  0016b	eb 0b		 jmp	 SHORT $LN20@FormatERW
$LN19@FormatERW:
  0016d	c7 84 24 88 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv145[rsp], 46 ; 0000002eH
$LN20@FormatERW:
  00178	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00180	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00184	83 e0 20	 and	 eax, 32			; 00000020H
  00187	85 c0		 test	 eax, eax
  00189	74 0d		 je	 SHORT $LN21@FormatERW
  0018b	c7 84 24 8c 00
	00 00 45 00 00
	00		 mov	 DWORD PTR tv151[rsp], 69 ; 00000045H
  00196	eb 0b		 jmp	 SHORT $LN22@FormatERW
$LN21@FormatERW:
  00198	c7 84 24 8c 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv151[rsp], 46 ; 0000002eH
$LN22@FormatERW:
  001a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  001ab	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001af	83 e0 40	 and	 eax, 64			; 00000040H
  001b2	85 c0		 test	 eax, eax
  001b4	74 0d		 je	 SHORT $LN23@FormatERW
  001b6	c7 84 24 90 00
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv157[rsp], 76 ; 0000004cH
  001c1	eb 0b		 jmp	 SHORT $LN24@FormatERW
$LN23@FormatERW:
  001c3	c7 84 24 90 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv157[rsp], 46 ; 0000002eH
$LN24@FormatERW:
  001ce	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  001d6	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001da	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001df	85 c0		 test	 eax, eax
  001e1	74 0d		 je	 SHORT $LN25@FormatERW
  001e3	c7 84 24 94 00
	00 00 30 00 00
	00		 mov	 DWORD PTR tv163[rsp], 48 ; 00000030H
  001ee	eb 0b		 jmp	 SHORT $LN26@FormatERW
$LN25@FormatERW:
  001f0	c7 84 24 94 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv163[rsp], 46 ; 0000002eH
$LN26@FormatERW:
  001fb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00203	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00207	83 e0 3f	 and	 eax, 63			; 0000003fH
  0020a	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0020e	8b 44 24 70	 mov	 eax, DWORD PTR tv77[rsp]
  00212	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00216	8b 44 24 74	 mov	 eax, DWORD PTR tv83[rsp]
  0021a	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0021e	8b 44 24 78	 mov	 eax, DWORD PTR tv89[rsp]
  00222	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00226	8b 44 24 7c	 mov	 eax, DWORD PTR tv95[rsp]
  0022a	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0022e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv133[rsp]
  00235	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00239	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv139[rsp]
  00240	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00244	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  0024b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0024f	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv151[rsp]
  00256	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0025a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv157[rsp]
  00261	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00265	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR tv163[rsp]
  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195519
  00274	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  0027c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2438 : 
; 2439 :         "Flags:%c%c%c%c%c%c%c%c %c%c SCNT:%d"
; 2440 : 
; 2441 :         , ( esw->erw0 & ERW0_RSV ) ? '0' : '.'
; 2442 :         , ( esw->erw0 & ERW0_L   ) ? 'L' : '.'
; 2443 :         , ( esw->erw0 & ERW0_E   ) ? 'E' : '.'
; 2444 :         , ( esw->erw0 & ERW0_A   ) ? 'A' : '.'
; 2445 :         , ( esw->erw0 & ERW0_P   ) ? 'P' : '.'
; 2446 :         , ( esw->erw0 & ERW0_T   ) ? 'T' : '.'
; 2447 :         , ( esw->erw0 & ERW0_F   ) ? 'F' : '.'
; 2448 :         , ( esw->erw0 & ERW0_S   ) ? 'S' : '.'
; 2449 : 
; 2450 :         , ( esw->erw1 & ERW1_C   ) ? 'C' : '.'
; 2451 :         , ( esw->erw1 & ERW1_R   ) ? 'R' : '.'
; 2452 : 
; 2453 :         , ( esw->erw1 & ERW1_SCNT )
; 2454 :     );
; 2455 : 
; 2456 :     return buf;

  0028a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatERW:

; 2457 : }

  00292	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00299	c3		 ret	 0
FormatERW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv77 = 192
tv83 = 196
tv89 = 200
tv145 = 204
tv151 = 208
tv157 = 212
tv163 = 216
tv169 = 220
tv181 = 224
tv187 = 228
tv193 = 232
tv199 = 236
tv205 = 240
tv211 = 244
tv217 = 248
tv223 = 252
tv175 = 256
esw$ = 288
buf$ = 296
bufsz$ = 304
FormatSCL PROC

; 2364 : {

$LN41:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 2365 : static const char* sa[] =
; 2366 : {
; 2367 :     "00",
; 2368 :     "RD",
; 2369 :     "WR",
; 2370 :     "BW",
; 2371 : };
; 2372 : static const char* tc[] =
; 2373 : {
; 2374 :     "HA",
; 2375 :     "ST",
; 2376 :     "CL",
; 2377 :     "11",
; 2378 : };
; 2379 : 
; 2380 :     if (!buf)

  00016	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@FormatSCL

; 2381 :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 80 04 00 00	 jmp	 $LN1@FormatSCL
$LN2@FormatSCL:

; 2382 :     if (bufsz)

  00028	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00031	74 0b		 je	 SHORT $LN3@FormatSCL

; 2383 :         *buf = 0;

  00033	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0003b	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@FormatSCL:

; 2384 :     if (bufsz <= 1 || !esw)

  0003e	48 83 bc 24 30
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00047	76 0b		 jbe	 SHORT $LN5@FormatSCL
  00049	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR esw$[rsp], 0
  00052	75 0d		 jne	 SHORT $LN4@FormatSCL
$LN5@FormatSCL:

; 2385 :         return buf;

  00054	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0005c	e9 47 04 00 00	 jmp	 $LN1@FormatSCL
$LN4@FormatSCL:

; 2386 : 
; 2387 :     snprintf( buf, bufsz,

  00061	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00069	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0006d	83 e0 08	 and	 eax, 8
  00070	85 c0		 test	 eax, eax
  00072	74 0d		 je	 SHORT $LN7@FormatSCL
  00074	c7 84 24 c0 00
	00 00 41 00 00
	00		 mov	 DWORD PTR tv77[rsp], 65	; 00000041H
  0007f	eb 0b		 jmp	 SHORT $LN8@FormatSCL
$LN7@FormatSCL:
  00081	c7 84 24 c0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv77[rsp], 46	; 0000002eH
$LN8@FormatSCL:
  0008c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00094	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00098	83 e0 10	 and	 eax, 16
  0009b	85 c0		 test	 eax, eax
  0009d	74 0d		 je	 SHORT $LN9@FormatSCL
  0009f	c7 84 24 c4 00
	00 00 45 00 00
	00		 mov	 DWORD PTR tv83[rsp], 69	; 00000045H
  000aa	eb 0b		 jmp	 SHORT $LN10@FormatSCL
$LN9@FormatSCL:
  000ac	c7 84 24 c4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv83[rsp], 46	; 0000002eH
$LN10@FormatSCL:
  000b7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  000bf	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000c3	83 e0 20	 and	 eax, 32			; 00000020H
  000c6	85 c0		 test	 eax, eax
  000c8	74 0d		 je	 SHORT $LN11@FormatSCL
  000ca	c7 84 24 c8 00
	00 00 44 00 00
	00		 mov	 DWORD PTR tv89[rsp], 68	; 00000044H
  000d5	eb 0b		 jmp	 SHORT $LN12@FormatSCL
$LN11@FormatSCL:
  000d7	c7 84 24 c8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv89[rsp], 46	; 0000002eH
$LN12@FormatSCL:
  000e2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  000ea	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	74 0d		 je	 SHORT $LN13@FormatSCL
  000f5	c7 84 24 cc 00
	00 00 43 00 00
	00		 mov	 DWORD PTR tv145[rsp], 67 ; 00000043H
  00100	eb 0b		 jmp	 SHORT $LN14@FormatSCL
$LN13@FormatSCL:
  00102	c7 84 24 cc 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv145[rsp], 46 ; 0000002eH
$LN14@FormatSCL:
  0010d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00115	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00119	83 e0 08	 and	 eax, 8
  0011c	85 c0		 test	 eax, eax
  0011e	74 0d		 je	 SHORT $LN15@FormatSCL
  00120	c7 84 24 d0 00
	00 00 44 00 00
	00		 mov	 DWORD PTR tv151[rsp], 68 ; 00000044H
  0012b	eb 0b		 jmp	 SHORT $LN16@FormatSCL
$LN15@FormatSCL:
  0012d	c7 84 24 d0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv151[rsp], 46 ; 0000002eH
$LN16@FormatSCL:
  00138	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00140	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00144	83 e0 10	 and	 eax, 16
  00147	85 c0		 test	 eax, eax
  00149	74 0d		 je	 SHORT $LN17@FormatSCL
  0014b	c7 84 24 d4 00
	00 00 53 00 00
	00		 mov	 DWORD PTR tv157[rsp], 83 ; 00000053H
  00156	eb 0b		 jmp	 SHORT $LN18@FormatSCL
$LN17@FormatSCL:
  00158	c7 84 24 d4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv157[rsp], 46 ; 0000002eH
$LN18@FormatSCL:
  00163	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0016b	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0016f	83 e0 20	 and	 eax, 32			; 00000020H
  00172	85 c0		 test	 eax, eax
  00174	74 0d		 je	 SHORT $LN19@FormatSCL
  00176	c7 84 24 d8 00
	00 00 54 00 00
	00		 mov	 DWORD PTR tv163[rsp], 84 ; 00000054H
  00181	eb 0b		 jmp	 SHORT $LN20@FormatSCL
$LN19@FormatSCL:
  00183	c7 84 24 d8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv163[rsp], 46 ; 0000002eH
$LN20@FormatSCL:
  0018e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00196	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0019a	83 e0 40	 and	 eax, 64			; 00000040H
  0019d	85 c0		 test	 eax, eax
  0019f	74 0d		 je	 SHORT $LN21@FormatSCL
  001a1	c7 84 24 dc 00
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv169[rsp], 76 ; 0000004cH
  001ac	eb 0b		 jmp	 SHORT $LN22@FormatSCL
$LN21@FormatSCL:
  001ae	c7 84 24 dc 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv169[rsp], 46 ; 0000002eH
$LN22@FormatSCL:
  001b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  001c1	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001c5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ca	85 c0		 test	 eax, eax
  001cc	74 11		 je	 SHORT $LN23@FormatSCL
  001ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195504
  001d5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv175[rsp], rax
  001dd	eb 0f		 jmp	 SHORT $LN24@FormatSCL
$LN23@FormatSCL:
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195505
  001e6	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN24@FormatSCL:
  001ee	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  001f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f9	83 e0 01	 and	 eax, 1
  001fc	85 c0		 test	 eax, eax
  001fe	74 0d		 je	 SHORT $LN25@FormatSCL
  00200	c7 84 24 e0 00
	00 00 37 00 00
	00		 mov	 DWORD PTR tv181[rsp], 55 ; 00000037H
  0020b	eb 0b		 jmp	 SHORT $LN26@FormatSCL
$LN25@FormatSCL:
  0020d	c7 84 24 e0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv181[rsp], 46 ; 0000002eH
$LN26@FormatSCL:
  00218	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00220	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00223	83 e0 02	 and	 eax, 2
  00226	85 c0		 test	 eax, eax
  00228	74 0d		 je	 SHORT $LN27@FormatSCL
  0022a	c7 84 24 e4 00
	00 00 49 00 00
	00		 mov	 DWORD PTR tv187[rsp], 73 ; 00000049H
  00235	eb 0b		 jmp	 SHORT $LN28@FormatSCL
$LN27@FormatSCL:
  00237	c7 84 24 e4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv187[rsp], 46 ; 0000002eH
$LN28@FormatSCL:
  00242	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0024a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0024d	83 e0 04	 and	 eax, 4
  00250	85 c0		 test	 eax, eax
  00252	74 0d		 je	 SHORT $LN29@FormatSCL
  00254	c7 84 24 e8 00
	00 00 43 00 00
	00		 mov	 DWORD PTR tv193[rsp], 67 ; 00000043H
  0025f	eb 0b		 jmp	 SHORT $LN30@FormatSCL
$LN29@FormatSCL:
  00261	c7 84 24 e8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv193[rsp], 46 ; 0000002eH
$LN30@FormatSCL:
  0026c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00274	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00277	83 e0 08	 and	 eax, 8
  0027a	85 c0		 test	 eax, eax
  0027c	74 0d		 je	 SHORT $LN31@FormatSCL
  0027e	c7 84 24 ec 00
	00 00 50 00 00
	00		 mov	 DWORD PTR tv199[rsp], 80 ; 00000050H
  00289	eb 0b		 jmp	 SHORT $LN32@FormatSCL
$LN31@FormatSCL:
  0028b	c7 84 24 ec 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv199[rsp], 46 ; 0000002eH
$LN32@FormatSCL:
  00296	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0029e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a1	83 e0 10	 and	 eax, 16
  002a4	85 c0		 test	 eax, eax
  002a6	74 0d		 je	 SHORT $LN33@FormatSCL
  002a8	c7 84 24 f0 00
	00 00 44 00 00
	00		 mov	 DWORD PTR tv205[rsp], 68 ; 00000044H
  002b3	eb 0b		 jmp	 SHORT $LN34@FormatSCL
$LN33@FormatSCL:
  002b5	c7 84 24 f0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv205[rsp], 46 ; 0000002eH
$LN34@FormatSCL:
  002c0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  002c8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002cb	83 e0 20	 and	 eax, 32			; 00000020H
  002ce	85 c0		 test	 eax, eax
  002d0	74 0d		 je	 SHORT $LN35@FormatSCL
  002d2	c7 84 24 f4 00
	00 00 47 00 00
	00		 mov	 DWORD PTR tv211[rsp], 71 ; 00000047H
  002dd	eb 0b		 jmp	 SHORT $LN36@FormatSCL
$LN35@FormatSCL:
  002df	c7 84 24 f4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv211[rsp], 46 ; 0000002eH
$LN36@FormatSCL:
  002ea	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  002f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f5	83 e0 40	 and	 eax, 64			; 00000040H
  002f8	85 c0		 test	 eax, eax
  002fa	74 0d		 je	 SHORT $LN37@FormatSCL
  002fc	c7 84 24 f8 00
	00 00 4b 00 00
	00		 mov	 DWORD PTR tv217[rsp], 75 ; 0000004bH
  00307	eb 0b		 jmp	 SHORT $LN38@FormatSCL
$LN37@FormatSCL:
  00309	c7 84 24 f8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv217[rsp], 46 ; 0000002eH
$LN38@FormatSCL:
  00314	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  0031c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0031f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00324	85 c0		 test	 eax, eax
  00326	74 0d		 je	 SHORT $LN39@FormatSCL
  00328	c7 84 24 fc 00
	00 00 30 00 00
	00		 mov	 DWORD PTR tv223[rsp], 48 ; 00000030H
  00333	eb 0b		 jmp	 SHORT $LN40@FormatSCL
$LN39@FormatSCL:
  00335	c7 84 24 fc 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv223[rsp], 46 ; 0000002eH
$LN40@FormatSCL:
  00340	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR esw$[rsp]
  00348	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0034c	83 e0 07	 and	 eax, 7
  0034f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR esw$[rsp]
  00357	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0035b	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  00361	c1 f9 06	 sar	 ecx, 6
  00364	48 63 c9	 movsxd	 rcx, ecx
  00367	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tc@?1??FormatSCL@@9@9
  0036e	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR esw$[rsp]
  00376	45 0f b6 40 02	 movzx	 r8d, BYTE PTR [r8+2]
  0037b	41 83 e0 03	 and	 r8d, 3
  0037f	4d 63 c0	 movsxd	 r8, r8d
  00382	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?sa@?1??FormatSCL@@9@9
  00389	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR esw$[rsp]
  00391	45 0f b6 52 01	 movzx	 r10d, BYTE PTR [r10+1]
  00396	89 84 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], eax
  0039d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv77[rsp]
  003a4	89 84 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], eax
  003ab	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv83[rsp]
  003b2	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  003b9	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv89[rsp]
  003c0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  003c7	48 8b 04 ca	 mov	 rax, QWORD PTR [rdx+rcx*8]
  003cb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rax
  003d3	4b 8b 04 c1	 mov	 rax, QWORD PTR [r9+r8*8]
  003d7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  003df	44 89 94 24 88
	00 00 00	 mov	 DWORD PTR [rsp+136], r10d
  003e7	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  003ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  003f5	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv151[rsp]
  003fc	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  00400	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv157[rsp]
  00407	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  0040b	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv163[rsp]
  00412	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00416	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv169[rsp]
  0041d	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00421	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv175[rsp]
  00429	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0042e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv181[rsp]
  00435	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00439	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv187[rsp]
  00440	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00444	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv193[rsp]
  0044b	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0044f	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv199[rsp]
  00456	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0045a	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv205[rsp]
  00461	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00465	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv211[rsp]
  0046c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00470	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv217[rsp]
  00477	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0047b	44 8b 8c 24 fc
	00 00 00	 mov	 r9d, DWORD PTR tv223[rsp]
  00483	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195506
  0048a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00492	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0049a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2388 : 
; 2389 :         "ESF:%c%c%c%c%c%c%c%c%s FVF:%c%c%c%c%c LPUM:%2.2X SA:%s TC:%s Flgs:%c%c%c SC=%d"
; 2390 : 
; 2391 :         , ( esw->scl0 & 0x80           ) ? '0' : '.'
; 2392 :         , ( esw->scl0 & SCL0_ESF_KEY   ) ? 'K' : '.'
; 2393 :         , ( esw->scl0 & SCL0_ESF_MBPGK ) ? 'G' : '.'
; 2394 :         , ( esw->scl0 & SCL0_ESF_MBDCK ) ? 'D' : '.'
; 2395 :         , ( esw->scl0 & SCL0_ESF_MBPTK ) ? 'P' : '.'
; 2396 :         , ( esw->scl0 & SCL0_ESF_CCWCK ) ? 'C' : '.'
; 2397 :         , ( esw->scl0 & SCL0_ESF_IDACK ) ? 'I' : '.'
; 2398 :         , ( esw->scl0 & 0x01           ) ? '7' : '.'
; 2399 : 
; 2400 :         , ( esw->scl2 & SCL2_R ) ? " (R)" : ""
; 2401 : 
; 2402 :         , ( esw->scl2 & SCL2_FVF_LPUM  ) ? 'L' : '.'
; 2403 :         , ( esw->scl2 & SCL2_FVF_TC    ) ? 'T' : '.'
; 2404 :         , ( esw->scl2 & SCL2_FVF_SC    ) ? 'S' : '.'
; 2405 :         , ( esw->scl2 & SCL2_FVF_USTAT ) ? 'D' : '.'
; 2406 :         , ( esw->scl2 & SCL2_FVF_CCWAD ) ? 'C' : '.'
; 2407 : 
; 2408 :         , esw->lpum
; 2409 : 
; 2410 :         , sa[  esw->scl2 & SCL2_SA ]
; 2411 : 
; 2412 :         , tc[ (esw->scl3 & SCL3_TC) >> 6 ]
; 2413 : 
; 2414 :         , ( esw->scl3 & SCL3_D ) ? 'D' : '.'
; 2415 :         , ( esw->scl3 & SCL3_E ) ? 'E' : '.'
; 2416 :         , ( esw->scl3 & SCL3_A ) ? 'A' : '.'
; 2417 : 
; 2418 :         , ( esw->scl3 & SCL3_SC )
; 2419 :     );
; 2420 : 
; 2421 :     return buf;

  004a0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatSCL:

; 2422 : }

  004a8	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  004af	c3		 ret	 0
FormatSCL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
erc$1 = 128
rsc$2 = 129
flags$3 = 132
rsid$4 = 136
tv80 = 144
tv84 = 152
tv88 = 160
tv92 = 168
tv128 = 176
tv132 = 184
tv136 = 192
tv148 = 200
tv158 = 208
crw$ = 240
buf$ = 248
bufsz$ = 256
FormatCRW PROC

; 2281 : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 2282 :     static const char* rsctab[] =
; 2283 :     {
; 2284 :         "0",
; 2285 :         "1",
; 2286 :         "MONIT",
; 2287 :         "SUBCH",
; 2288 :         "CHPID",
; 2289 :         "5",
; 2290 :         "6",
; 2291 :         "7",
; 2292 :         "8",
; 2293 :         "CAF",
; 2294 :         "10",
; 2295 :         "CSS",
; 2296 :     };
; 2297 :     static const BYTE  numrsc  =  _countof( rsctab );
; 2298 : 
; 2299 :     static const char* erctab[] =
; 2300 :     {
; 2301 :         "NULL",
; 2302 :         "AVAIL",
; 2303 :         "INIT",
; 2304 :         "TEMP",
; 2305 :         "ALERT",
; 2306 :         "ABORT",
; 2307 :         "ERROR",
; 2308 :         "RESET",
; 2309 :         "MODFY",
; 2310 :         "9",
; 2311 :         "RSTRD",
; 2312 :     };
; 2313 :     static const BYTE  numerc  =  _countof( erctab );
; 2314 : 
; 2315 :     if (!buf)

  00015	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN2@FormatCRW

; 2316 :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	e9 5b 03 00 00	 jmp	 $LN1@FormatCRW
$LN2@FormatCRW:

; 2317 :     if (bufsz)

  00027	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR bufsz$[rsp], 0
  00030	74 0b		 je	 SHORT $LN3@FormatCRW

; 2318 :         *buf = 0;

  00032	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0003a	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@FormatCRW:

; 2319 :     if (bufsz <= 1)

  0003d	48 83 bc 24 00
	01 00 00 01	 cmp	 QWORD PTR bufsz$[rsp], 1
  00046	77 0d		 ja	 SHORT $LN4@FormatCRW

; 2320 :         return buf;

  00048	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00050	e9 2d 03 00 00	 jmp	 $LN1@FormatCRW
$LN4@FormatCRW:

; 2321 : 
; 2322 :     if (crw)

  00055	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR crw$[rsp], 0
  0005d	0f 84 fa 02 00
	00		 je	 $LN5@FormatCRW

; 2323 :     {
; 2324 :         U32     flags   =  (U32)    ( crw & CRW_FLAGS_MASK );

  00063	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR crw$[rsp]
  0006a	25 00 00 c0 f0	 and	 eax, -255852544		; f0c00000H
  0006f	89 84 24 84 00
	00 00		 mov	 DWORD PTR flags$3[rsp], eax

; 2325 :         BYTE    erc     =  (BYTE) ( ( crw & CRW_ERC_MASK   ) >> 16 );

  00076	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR crw$[rsp]
  0007d	25 00 00 3f 00	 and	 eax, 4128768		; 003f0000H
  00082	c1 e8 10	 shr	 eax, 16
  00085	88 84 24 80 00
	00 00		 mov	 BYTE PTR erc$1[rsp], al

; 2326 :         BYTE    rsc     =  (BYTE) ( ( crw & CRW_RSC_MASK   ) >> 24 );

  0008c	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR crw$[rsp]
  00093	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  00098	c1 e8 18	 shr	 eax, 24
  0009b	88 84 24 81 00
	00 00		 mov	 BYTE PTR rsc$2[rsp], al

; 2327 :         U16     rsid    =  (U16)    ( crw & CRW_RSID_MASK  );

  000a2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR crw$[rsp]
  000a9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000ae	66 89 84 24 88
	00 00 00	 mov	 WORD PTR rsid$4[rsp], ax

; 2328 : 
; 2329 :         snprintf( buf, bufsz,

  000b6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  000bd	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  000c2	85 c0		 test	 eax, eax
  000c4	74 11		 je	 SHORT $LN8@FormatCRW
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195461
  000cd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  000d5	eb 0f		 jmp	 SHORT $LN9@FormatCRW
$LN8@FormatCRW:
  000d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195462
  000de	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN9@FormatCRW:
  000e6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  000ed	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  000f2	85 c0		 test	 eax, eax
  000f4	74 11		 je	 SHORT $LN10@FormatCRW
  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195463
  000fd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  00105	eb 0f		 jmp	 SHORT $LN11@FormatCRW
$LN10@FormatCRW:
  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195464
  0010e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN11@FormatCRW:
  00116	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  0011d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00122	85 c0		 test	 eax, eax
  00124	74 11		 je	 SHORT $LN12@FormatCRW
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195465
  0012d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
  00135	eb 0f		 jmp	 SHORT $LN13@FormatCRW
$LN12@FormatCRW:
  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195466
  0013e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
$LN13@FormatCRW:
  00146	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  0014d	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00152	85 c0		 test	 eax, eax
  00154	74 11		 je	 SHORT $LN14@FormatCRW
  00156	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195467
  0015d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00165	eb 0f		 jmp	 SHORT $LN15@FormatCRW
$LN14@FormatCRW:
  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195468
  0016e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
$LN15@FormatCRW:
  00176	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  0017d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00182	85 c0		 test	 eax, eax
  00184	74 11		 je	 SHORT $LN16@FormatCRW
  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195469
  0018d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00195	eb 0f		 jmp	 SHORT $LN17@FormatCRW
$LN16@FormatCRW:
  00197	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195470
  0019e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
$LN17@FormatCRW:
  001a6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  001ad	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001b2	85 c0		 test	 eax, eax
  001b4	74 11		 je	 SHORT $LN18@FormatCRW
  001b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195471
  001bd	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001c5	eb 0f		 jmp	 SHORT $LN19@FormatCRW
$LN18@FormatCRW:
  001c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195472
  001ce	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
$LN19@FormatCRW:
  001d6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR flags$3[rsp]
  001dd	25 00 00 c0 f0	 and	 eax, -255852544		; f0c00000H
  001e2	85 c0		 test	 eax, eax
  001e4	74 11		 je	 SHORT $LN20@FormatCRW
  001e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195473
  001ed	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  001f5	eb 0f		 jmp	 SHORT $LN21@FormatCRW
$LN20@FormatCRW:
  001f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195474
  001fe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
$LN21@FormatCRW:
  00206	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR erc$1[rsp]
  0020e	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?numerc@?1??FormatCRW@@9@9
  00215	3b c1		 cmp	 eax, ecx
  00217	7d 1d		 jge	 SHORT $LN22@FormatCRW
  00219	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR erc$1[rsp]
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?erctab@?1??FormatCRW@@9@9
  00228	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0022c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00234	eb 0f		 jmp	 SHORT $LN23@FormatCRW
$LN22@FormatCRW:
  00236	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195475
  0023d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
$LN23@FormatCRW:
  00245	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR rsc$2[rsp]
  0024d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?numrsc@?1??FormatCRW@@9@9
  00254	3b c1		 cmp	 eax, ecx
  00256	7d 1d		 jge	 SHORT $LN24@FormatCRW
  00258	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR rsc$2[rsp]
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?rsctab@?1??FormatCRW@@9@9
  00267	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0026b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  00273	eb 0f		 jmp	 SHORT $LN25@FormatCRW
$LN24@FormatCRW:
  00275	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195476
  0027c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
$LN25@FormatCRW:
  00284	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR rsid$4[rsp]
  0028c	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR rsid$4[rsp]
  00294	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR erc$1[rsp]
  0029c	44 0f b6 84 24
	81 00 00 00	 movzx	 r8d, BYTE PTR rsc$2[rsp]
  002a5	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR tv80[rsp]
  002ad	4c 89 4c 24 78	 mov	 QWORD PTR [rsp+120], r9
  002b2	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR tv84[rsp]
  002ba	4c 89 4c 24 70	 mov	 QWORD PTR [rsp+112], r9
  002bf	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR tv88[rsp]
  002c7	4c 89 4c 24 68	 mov	 QWORD PTR [rsp+104], r9
  002cc	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR tv92[rsp]
  002d4	4c 89 4c 24 60	 mov	 QWORD PTR [rsp+96], r9
  002d9	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR tv128[rsp]
  002e1	4c 89 4c 24 58	 mov	 QWORD PTR [rsp+88], r9
  002e6	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR tv132[rsp]
  002ee	4c 89 4c 24 50	 mov	 QWORD PTR [rsp+80], r9
  002f3	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR tv136[rsp]
  002fb	4c 89 4c 24 48	 mov	 QWORD PTR [rsp+72], r9
  00300	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00304	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00308	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv148[rsp]
  00310	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00315	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00319	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv158[rsp]
  00321	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00326	45 8b c8	 mov	 r9d, r8d
  00329	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195477
  00330	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  00338	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2330 : 
; 2331 :             "RSC:%d=%s, ERC:%d=%s, RSID:%d=0x%4.4X Flags:%s%s%s%s%s%s%s"
; 2332 : 
; 2333 :             , rsc
; 2334 :             , rsc < numrsc ? rsctab[ rsc ] : "???"
; 2335 : 
; 2336 :             , erc
; 2337 :             , erc < numerc ? erctab[ erc ] : "???"
; 2338 : 
; 2339 :             , rsid
; 2340 :             , rsid
; 2341 : 
; 2342 :             , ( flags & CRW_FLAGS_MASK ) ? ""            : "0"
; 2343 :             , ( flags & 0x80000000     ) ? "0x80000000," : ""
; 2344 :             , ( flags & CRW_SOL        ) ? "SOL,"        : ""
; 2345 :             , ( flags & CRW_OFLOW      ) ? "OFLOW,"      : ""
; 2346 :             , ( flags & CRW_CHAIN      ) ? "CHAIN,"      : ""
; 2347 :             , ( flags & CRW_AR         ) ? "AR,"         : ""
; 2348 :             , ( flags & 0x00400000     ) ? "0x00400000," : ""
; 2349 :         );
; 2350 : 
; 2351 :         rtrim( buf, "," );              // (remove trailing comma)

  00346	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195478
  0034d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2352 :     }

  0035b	eb 1d		 jmp	 SHORT $LN6@FormatCRW
$LN5@FormatCRW:

; 2353 :     else
; 2354 :         strlcpy( buf, "(end)", bufsz ); // (end of channel report)

  0035d	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR bufsz$[rsp]
  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195479
  0036c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00374	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@FormatCRW:

; 2355 : 
; 2356 :     return buf;

  0037a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
$LN1@FormatCRW:

; 2357 : }

  00382	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00389	c3		 ret	 0
FormatCRW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
len$ = 48
trace2file$ = 80
regs$ = 88
inst$ = 96
opcode$ = 104
buf$ = 112
buflen$ = 120
display_inst_regs PROC

; 1604 : {

$LN63:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1605 :     int len=0;

  00017	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 1606 : 
; 1607 :     /* Display the general purpose registers */
; 1608 :     if (!(opcode == 0xB3 || (opcode >= 0x20 && opcode <= 0x3F))
; 1609 :         || (opcode == 0xB3 && (

  0001f	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00024	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00029	74 14		 je	 SHORT $LN4@display_in
  0002b	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00030	83 f8 20	 cmp	 eax, 32			; 00000020H
  00033	7c 7e		 jl	 SHORT $LN3@display_in
  00035	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0003a	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0003d	7f 74		 jg	 SHORT $LN3@display_in
$LN4@display_in:
  0003f	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00044	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00049	0f 85 c0 00 00
	00		 jne	 $LN2@display_in
  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	48 6b c0 01	 imul	 rax, rax, 1
  00058	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0005d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00061	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00066	7c 19		 jl	 SHORT $LN6@display_in
  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 01	 imul	 rax, rax, 1
  00071	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00076	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007a	3d cf 00 00 00	 cmp	 eax, 207		; 000000cfH
  0007f	7e 32		 jle	 SHORT $LN5@display_in
$LN6@display_in:
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0008f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00093	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  00098	7c 75		 jl	 SHORT $LN2@display_in
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000b1	7f 5c		 jg	 SHORT $LN2@display_in
$LN5@display_in:
$LN3@display_in:

; 1610 :                 (inst[1] >= 0x80 && inst[1] <= 0xCF)
; 1611 :                 || (inst[1] >= 0xE1 && inst[1] <= 0xFE)
; 1612 :            )))
; 1613 :     {
; 1614 :         if (trace2file)

  000b3	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	74 12		 je	 SHORT $LN7@display_in

; 1615 :             tf_2269( regs, inst );

  000bc	48 8b 54 24 60	 mov	 rdx, QWORD PTR inst$[rsp]
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2269
  000cc	eb 41		 jmp	 SHORT $LN8@display_in
$LN7@display_in:

; 1616 :         else
; 1617 :             len += display_gregs (regs, buf + len, buflen - len - 1, "HHC02269I " );

  000ce	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000d2	8b 4c 24 78	 mov	 ecx, DWORD PTR buflen$[rsp]
  000d6	2b c8		 sub	 ecx, eax
  000d8	8b c1		 mov	 eax, ecx
  000da	ff c8		 dec	 eax
  000dc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e1	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  000e6	48 03 d1	 add	 rdx, rcx
  000e9	48 8b ca	 mov	 rcx, rdx
  000ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195045
  000f3	44 8b c0	 mov	 r8d, eax
  000f6	48 8b d1	 mov	 rdx, rcx
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 display_gregs
  00103	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00107	03 c8		 add	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN8@display_in:
$LN2@display_in:

; 1618 :     }
; 1619 : 
; 1620 :     /* Display control registers if appropriate */
; 1621 :     if (!REAL_MODE(&regs->psw) || opcode == 0xB2 || opcode == 0xB6 || opcode == 0xB7)

  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00114	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00118	83 e0 04	 and	 eax, 4
  0011b	85 c0		 test	 eax, eax
  0011d	75 24		 jne	 SHORT $LN10@display_in
  0011f	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00124	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00129	74 18		 je	 SHORT $LN10@display_in
  0012b	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00130	3d b6 00 00 00	 cmp	 eax, 182		; 000000b6H
  00135	74 0c		 je	 SHORT $LN10@display_in
  00137	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0013c	3d b7 00 00 00	 cmp	 eax, 183		; 000000b7H
  00141	75 57		 jne	 SHORT $LN9@display_in
$LN10@display_in:

; 1622 :     {
; 1623 :         if (trace2file)

  00143	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00148	85 c0		 test	 eax, eax
  0014a	74 0d		 je	 SHORT $LN11@display_in

; 1624 :             tf_2271( regs );

  0014c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2271
  00157	eb 41		 jmp	 SHORT $LN12@display_in
$LN11@display_in:

; 1625 :         else
; 1626 :             len += display_cregs (regs, buf + len, buflen - len - 1, "HHC02271I ");

  00159	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0015d	8b 4c 24 78	 mov	 ecx, DWORD PTR buflen$[rsp]
  00161	2b c8		 sub	 ecx, eax
  00163	8b c1		 mov	 eax, ecx
  00165	ff c8		 dec	 eax
  00167	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  0016c	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  00171	48 03 d1	 add	 rdx, rcx
  00174	48 8b ca	 mov	 rcx, rdx
  00177	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195050
  0017e	44 8b c0	 mov	 r8d, eax
  00181	48 8b d1	 mov	 rdx, rcx
  00184	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	e8 00 00 00 00	 call	 display_cregs
  0018e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00192	03 c8		 add	 ecx, eax
  00194	8b c1		 mov	 eax, ecx
  00196	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN12@display_in:
$LN9@display_in:

; 1627 :     }
; 1628 : 
; 1629 :     /* Display access registers if appropriate */
; 1630 :     if (!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0019a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001a3	83 e0 04	 and	 eax, 4
  001a6	85 c0		 test	 eax, eax
  001a8	74 65		 je	 SHORT $LN13@display_in
  001aa	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001af	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001b3	83 f8 40	 cmp	 eax, 64			; 00000040H
  001b6	75 57		 jne	 SHORT $LN13@display_in

; 1631 :     {
; 1632 :         if (trace2file)

  001b8	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  001bd	85 c0		 test	 eax, eax
  001bf	74 0d		 je	 SHORT $LN14@display_in

; 1633 :             tf_2272( regs );

  001c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2272
  001cc	eb 41		 jmp	 SHORT $LN15@display_in
$LN14@display_in:

; 1634 :         else
; 1635 :             len += display_aregs (regs, buf + len, buflen - len - 1, "HHC02272I ");

  001ce	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  001d2	8b 4c 24 78	 mov	 ecx, DWORD PTR buflen$[rsp]
  001d6	2b c8		 sub	 ecx, eax
  001d8	8b c1		 mov	 eax, ecx
  001da	ff c8		 dec	 eax
  001dc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  001e1	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  001e6	48 03 d1	 add	 rdx, rcx
  001e9	48 8b ca	 mov	 rcx, rdx
  001ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195054
  001f3	44 8b c0	 mov	 r8d, eax
  001f6	48 8b d1	 mov	 rdx, rcx
  001f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	e8 00 00 00 00	 call	 display_aregs
  00203	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00207	03 c8		 add	 ecx, eax
  00209	8b c1		 mov	 eax, ecx
  0020b	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN15@display_in:
$LN13@display_in:

; 1636 :     }
; 1637 : 
; 1638 :     /* Display floating point control register if AFP enabled */
; 1639 :     if ((regs->CR(0) & CR0_AFP) && (

  0020f	b8 08 00 00 00	 mov	 eax, 8
  00214	48 6b c0 01	 imul	 rax, rax, 1
  00218	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0021d	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00225	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0022b	48 85 c0	 test	 rax, rax
  0022e	0f 84 a3 03 00
	00		 je	 $LN16@display_in
  00234	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00239	83 f8 01	 cmp	 eax, 1
  0023c	75 1b		 jne	 SHORT $LN18@display_in
  0023e	b8 01 00 00 00	 mov	 eax, 1
  00243	48 6b c0 01	 imul	 rax, rax, 1
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0024c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00250	83 f8 0a	 cmp	 eax, 10
  00253	0f 84 23 03 00
	00		 je	 $LN17@display_in
$LN18@display_in:
  00259	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0025e	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00263	75 1d		 jne	 SHORT $LN19@display_in
  00265	b8 01 00 00 00	 mov	 eax, 1
  0026a	48 6b c0 01	 imul	 rax, rax, 1
  0026e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00273	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00277	3d 99 00 00 00	 cmp	 eax, 153		; 00000099H
  0027c	0f 84 fa 02 00
	00		 je	 $LN17@display_in
$LN19@display_in:
  00282	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00287	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  0028c	75 1d		 jne	 SHORT $LN20@display_in
  0028e	b8 01 00 00 00	 mov	 eax, 1
  00293	48 6b c0 01	 imul	 rax, rax, 1
  00297	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0029c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a0	3d 9c 00 00 00	 cmp	 eax, 156		; 0000009cH
  002a5	0f 84 d1 02 00
	00		 je	 $LN17@display_in
$LN20@display_in:
  002ab	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  002b0	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  002b5	75 1d		 jne	 SHORT $LN21@display_in
  002b7	b8 01 00 00 00	 mov	 eax, 1
  002bc	48 6b c0 01	 imul	 rax, rax, 1
  002c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  002c5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c9	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  002ce	0f 84 a8 02 00
	00		 je	 $LN17@display_in
$LN21@display_in:
  002d4	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  002d9	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  002de	75 1d		 jne	 SHORT $LN22@display_in
  002e0	b8 01 00 00 00	 mov	 eax, 1
  002e5	48 6b c0 01	 imul	 rax, rax, 1
  002e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  002ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f2	3d b8 00 00 00	 cmp	 eax, 184		; 000000b8H
  002f7	0f 84 7f 02 00
	00		 je	 $LN17@display_in
$LN22@display_in:
  002fd	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00302	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00307	75 1d		 jne	 SHORT $LN23@display_in
  00309	b8 01 00 00 00	 mov	 eax, 1
  0030e	48 6b c0 01	 imul	 rax, rax, 1
  00312	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00317	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031b	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00320	0f 84 56 02 00
	00		 je	 $LN17@display_in
$LN23@display_in:
  00326	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0032b	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00330	75 1d		 jne	 SHORT $LN24@display_in
  00332	b8 01 00 00 00	 mov	 eax, 1
  00337	48 6b c0 01	 imul	 rax, rax, 1
  0033b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00340	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00344	3d bd 00 00 00	 cmp	 eax, 189		; 000000bdH
  00349	0f 84 2d 02 00
	00		 je	 $LN17@display_in
$LN24@display_in:
  0034f	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00354	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00359	75 1b		 jne	 SHORT $LN25@display_in
  0035b	b8 01 00 00 00	 mov	 eax, 1
  00360	48 6b c0 01	 imul	 rax, rax, 1
  00364	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00369	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036d	83 f8 1f	 cmp	 eax, 31
  00370	0f 8e 06 02 00
	00		 jle	 $LN17@display_in
$LN25@display_in:
  00376	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0037b	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00380	75 32		 jne	 SHORT $LN26@display_in
  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 01	 imul	 rax, rax, 1
  0038b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00390	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00394	83 f8 40	 cmp	 eax, 64			; 00000040H
  00397	7c 1b		 jl	 SHORT $LN27@display_in
  00399	b8 01 00 00 00	 mov	 eax, 1
  0039e	48 6b c0 01	 imul	 rax, rax, 1
  003a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  003a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ab	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  003ae	0f 8e c8 01 00
	00		 jle	 $LN17@display_in
$LN27@display_in:
$LN26@display_in:
  003b4	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  003b9	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  003be	75 36		 jne	 SHORT $LN28@display_in
  003c0	b8 01 00 00 00	 mov	 eax, 1
  003c5	48 6b c0 01	 imul	 rax, rax, 1
  003c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  003ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d2	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  003d7	7c 1d		 jl	 SHORT $LN29@display_in
  003d9	b8 01 00 00 00	 mov	 eax, 1
  003de	48 6b c0 01	 imul	 rax, rax, 1
  003e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  003e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003eb	3d 8c 00 00 00	 cmp	 eax, 140		; 0000008cH
  003f0	0f 8e 86 01 00
	00		 jle	 $LN17@display_in
$LN29@display_in:
$LN28@display_in:
  003f6	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  003fb	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00400	75 36		 jne	 SHORT $LN30@display_in
  00402	b8 01 00 00 00	 mov	 eax, 1
  00407	48 6b c0 01	 imul	 rax, rax, 1
  0040b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00410	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00414	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00419	7c 1d		 jl	 SHORT $LN31@display_in
  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	48 6b c0 01	 imul	 rax, rax, 1
  00424	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00429	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0042d	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  00432	0f 8e 44 01 00
	00		 jle	 $LN17@display_in
$LN31@display_in:
$LN30@display_in:
  00438	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0043d	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  00442	75 1d		 jne	 SHORT $LN32@display_in
  00444	b8 01 00 00 00	 mov	 eax, 1
  00449	48 6b c0 01	 imul	 rax, rax, 1
  0044d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00452	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00456	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  0045b	0f 8d 1b 01 00
	00		 jge	 $LN17@display_in
$LN32@display_in:
  00461	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00466	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  0046b	75 32		 jne	 SHORT $LN33@display_in
  0046d	b8 01 00 00 00	 mov	 eax, 1
  00472	48 6b c0 01	 imul	 rax, rax, 1
  00476	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0047b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0047f	83 f8 41	 cmp	 eax, 65			; 00000041H
  00482	7c 1b		 jl	 SHORT $LN34@display_in
  00484	b8 01 00 00 00	 mov	 eax, 1
  00489	48 6b c0 01	 imul	 rax, rax, 1
  0048d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00492	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00496	83 f8 43	 cmp	 eax, 67			; 00000043H
  00499	0f 8e dd 00 00
	00		 jle	 $LN17@display_in
$LN34@display_in:
$LN33@display_in:
  0049f	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  004a4	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  004a9	75 32		 jne	 SHORT $LN35@display_in
  004ab	b8 01 00 00 00	 mov	 eax, 1
  004b0	48 6b c0 01	 imul	 rax, rax, 1
  004b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  004b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004bd	83 f8 49	 cmp	 eax, 73			; 00000049H
  004c0	7c 1b		 jl	 SHORT $LN36@display_in
  004c2	b8 01 00 00 00	 mov	 eax, 1
  004c7	48 6b c0 01	 imul	 rax, rax, 1
  004cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  004d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d4	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  004d7	0f 8e 9f 00 00
	00		 jle	 $LN17@display_in
$LN36@display_in:
$LN35@display_in:
  004dd	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  004e2	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  004e7	75 17		 jne	 SHORT $LN37@display_in
  004e9	b8 01 00 00 00	 mov	 eax, 1
  004ee	48 6b c0 01	 imul	 rax, rax, 1
  004f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  004f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004fb	83 f8 1f	 cmp	 eax, 31
  004fe	7e 7c		 jle	 SHORT $LN17@display_in
$LN37@display_in:
  00500	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00505	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  0050a	75 2e		 jne	 SHORT $LN38@display_in
  0050c	b8 01 00 00 00	 mov	 eax, 1
  00511	48 6b c0 01	 imul	 rax, rax, 1
  00515	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0051a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00521	7c 17		 jl	 SHORT $LN39@display_in
  00523	b8 01 00 00 00	 mov	 eax, 1
  00528	48 6b c0 01	 imul	 rax, rax, 1
  0052c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00531	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00535	83 f8 59	 cmp	 eax, 89			; 00000059H
  00538	7e 42		 jle	 SHORT $LN17@display_in
$LN39@display_in:
$LN38@display_in:
  0053a	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0053f	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00544	0f 85 8d 00 00
	00		 jne	 $LN16@display_in
  0054a	b8 01 00 00 00	 mov	 eax, 1
  0054f	48 6b c0 01	 imul	 rax, rax, 1
  00553	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00558	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0055c	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  00561	7c 74		 jl	 SHORT $LN16@display_in
  00563	b8 01 00 00 00	 mov	 eax, 1
  00568	48 6b c0 01	 imul	 rax, rax, 1
  0056c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00571	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00575	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  0057a	7f 5b		 jg	 SHORT $LN16@display_in
$LN17@display_in:

; 1640 :                                 (opcode == 0x01 && inst[1] == 0x0A)          /* PFPO Perform Floating Point Operation  */
; 1641 :                                 || (opcode == 0xB2 && inst[1] == 0x99)       /* SRNM   Set BFP Rounding mode 2-bit     */
; 1642 :                                 || (opcode == 0xB2 && inst[1] == 0x9C)       /* STFPC  Store FPC                       */
; 1643 :                                 || (opcode == 0xB2 && inst[1] == 0x9D)       /* LFPC   Load FPC                        */
; 1644 :                                 || (opcode == 0xB2 && inst[1] == 0xB8)       /* SRNMB  Set BFP Rounding mode 3-bit     */
; 1645 :                                 || (opcode == 0xB2 && inst[1] == 0xB9)       /* SRNMT  Set DFP Rounding mode           */
; 1646 :                                 || (opcode == 0xB2 && inst[1] == 0xBD)       /* LFAS   Load FPC and Signal             */
; 1647 :                                 || (opcode == 0xB3 && (inst[1] <= 0x1F))                       /* RRE BFP arithmetic   */
; 1648 :                                 || (opcode == 0xB3 && (inst[1] >= 0x40 && inst[1] <= 0x5F))    /* RRE BFP arithmetic   */
; 1649 :                                 || (opcode == 0xB3 && (inst[1] >= 0x84 && inst[1] <= 0x8C))    /* SFPC, SFASR, EFPC    */
; 1650 :                                 || (opcode == 0xB3 && (inst[1] >= 0x90 && inst[1] <= 0xAF))    /* RRE BFP arithmetic   */
; 1651 :                                 || (opcode == 0xB3 && (inst[1] >= 0xD0))/*inst[1] <= 0xFF)) */ /* RRE DFP arithmetic   */
; 1652 :                                 || (opcode == 0xB9 && (inst[1] >= 0x41 && inst[1] <= 0x43))    /* DFP Conversions      */
; 1653 :                                 || (opcode == 0xB9 && (inst[1] >= 0x49 && inst[1] <= 0x5B))    /* DFP Conversions      */
; 1654 :                                 || (opcode == 0xED && (inst[1] <= 0x1F))                       /* RXE BFP arithmetic   */
; 1655 :                                 || (opcode == 0xED && (inst[1] >= 0x40 && inst[1] <= 0x59))    /* RXE DFP shifts, tests*/
; 1656 :                                 || (opcode == 0xED && (inst[1] >= 0xA8 && inst[1] <= 0xAF)))   /* RXE DFP conversions  */
; 1657 :         )
; 1658 :     {
; 1659 :         if (trace2file)

  0057c	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00581	85 c0		 test	 eax, eax
  00583	74 0d		 je	 SHORT $LN40@display_in

; 1660 :             tf_2276( regs );

  00585	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0058a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2276
  00590	eb 45		 jmp	 SHORT $LN41@display_in
$LN40@display_in:

; 1661 :         else
; 1662 :             len += idx_snprintf( len, buf, buflen, MSG( HHC02276,"I", regs->fpc ));

  00592	48 63 44 24 78	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00597	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0059c	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  005a2	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  005a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195081
  005ad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195082
  005b9	4c 8b c0	 mov	 r8, rax
  005bc	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  005c1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  005cb	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  005cf	03 c8		 add	 ecx, eax
  005d1	8b c1		 mov	 eax, ecx
  005d3	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN41@display_in:
$LN16@display_in:

; 1663 :     }
; 1664 : 
; 1665 :     /* Display floating-point registers if appropriate */
; 1666 :     if ( (opcode == 0xB3 && !((inst[1] == 0x84) || (inst[1] == 0x85) || (inst[1] == 0x8C)))  /* exclude FPC-only instrs  */
; 1667 :         || (opcode == 0xED)
; 1668 :         || (opcode >= 0x20 && opcode <= 0x3F)  /* HFP Arithmetic and load/store  */
; 1669 :         || (opcode >= 0x60 && opcode <= 0x70)  /* HFP Arithmetic and load/store  */
; 1670 :         || (opcode >= 0x78 && opcode <= 0x7F)  /* HFP Arithmetic and load/store  */
; 1671 :         || (opcode == 0xB2 && inst[1] == 0x2D) /* DXR  Divide HFP extended               */
; 1672 :         || (opcode == 0xB2 && inst[1] == 0x44) /* SQDR Square Root HFP long              */
; 1673 :         || (opcode == 0xB2 && inst[1] == 0x45) /* SQER Square Root HFP short             */
; 1674 :         || (opcode == 0xB9 && (inst[1] >= 0x41 && inst[1] <= 0x43)) /* DFP Conversions*/
; 1675 :         || (opcode == 0xB9 && (inst[1] >= 0x49 && inst[1] <= 0x5B)) /* DFP Conversions*/
; 1676 :         || (opcode == 0x01 && inst[1] == 0x0A) /* PFPO Perform Floating Point Operation  */

  005d7	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  005dc	3d b3 00 00 00	 cmp	 eax, 179		; 000000b3H
  005e1	75 4f		 jne	 SHORT $LN44@display_in
  005e3	b8 01 00 00 00	 mov	 eax, 1
  005e8	48 6b c0 01	 imul	 rax, rax, 1
  005ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  005f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005f5	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  005fa	74 36		 je	 SHORT $LN45@display_in
  005fc	b8 01 00 00 00	 mov	 eax, 1
  00601	48 6b c0 01	 imul	 rax, rax, 1
  00605	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0060a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0060e	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  00613	74 1d		 je	 SHORT $LN45@display_in
  00615	b8 01 00 00 00	 mov	 eax, 1
  0061a	48 6b c0 01	 imul	 rax, rax, 1
  0061e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00623	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00627	3d 8c 00 00 00	 cmp	 eax, 140		; 0000008cH
  0062c	0f 85 62 01 00
	00		 jne	 $LN43@display_in
$LN45@display_in:
$LN44@display_in:
  00632	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00637	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  0063c	0f 84 52 01 00
	00		 je	 $LN43@display_in
  00642	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00647	83 f8 20	 cmp	 eax, 32			; 00000020H
  0064a	7c 0e		 jl	 SHORT $LN46@display_in
  0064c	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00651	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00654	0f 8e 3a 01 00
	00		 jle	 $LN43@display_in
$LN46@display_in:
  0065a	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0065f	83 f8 60	 cmp	 eax, 96			; 00000060H
  00662	7c 0e		 jl	 SHORT $LN47@display_in
  00664	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00669	83 f8 70	 cmp	 eax, 112		; 00000070H
  0066c	0f 8e 22 01 00
	00		 jle	 $LN43@display_in
$LN47@display_in:
  00672	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00677	83 f8 78	 cmp	 eax, 120		; 00000078H
  0067a	7c 0e		 jl	 SHORT $LN48@display_in
  0067c	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00681	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00684	0f 8e 0a 01 00
	00		 jle	 $LN43@display_in
$LN48@display_in:
  0068a	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0068f	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  00694	75 1b		 jne	 SHORT $LN49@display_in
  00696	b8 01 00 00 00	 mov	 eax, 1
  0069b	48 6b c0 01	 imul	 rax, rax, 1
  0069f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  006a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006a8	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  006ab	0f 84 e3 00 00
	00		 je	 $LN43@display_in
$LN49@display_in:
  006b1	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  006b6	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  006bb	75 1b		 jne	 SHORT $LN50@display_in
  006bd	b8 01 00 00 00	 mov	 eax, 1
  006c2	48 6b c0 01	 imul	 rax, rax, 1
  006c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  006cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006cf	83 f8 44	 cmp	 eax, 68			; 00000044H
  006d2	0f 84 bc 00 00
	00		 je	 $LN43@display_in
$LN50@display_in:
  006d8	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  006dd	3d b2 00 00 00	 cmp	 eax, 178		; 000000b2H
  006e2	75 1b		 jne	 SHORT $LN51@display_in
  006e4	b8 01 00 00 00	 mov	 eax, 1
  006e9	48 6b c0 01	 imul	 rax, rax, 1
  006ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  006f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006f6	83 f8 45	 cmp	 eax, 69			; 00000045H
  006f9	0f 84 95 00 00
	00		 je	 $LN43@display_in
$LN51@display_in:
  006ff	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00704	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00709	75 2e		 jne	 SHORT $LN52@display_in
  0070b	b8 01 00 00 00	 mov	 eax, 1
  00710	48 6b c0 01	 imul	 rax, rax, 1
  00714	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00719	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0071d	83 f8 41	 cmp	 eax, 65			; 00000041H
  00720	7c 17		 jl	 SHORT $LN53@display_in
  00722	b8 01 00 00 00	 mov	 eax, 1
  00727	48 6b c0 01	 imul	 rax, rax, 1
  0072b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00730	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00734	83 f8 43	 cmp	 eax, 67			; 00000043H
  00737	7e 5b		 jle	 SHORT $LN43@display_in
$LN53@display_in:
$LN52@display_in:
  00739	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  0073e	3d b9 00 00 00	 cmp	 eax, 185		; 000000b9H
  00743	75 2e		 jne	 SHORT $LN54@display_in
  00745	b8 01 00 00 00	 mov	 eax, 1
  0074a	48 6b c0 01	 imul	 rax, rax, 1
  0074e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00753	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00757	83 f8 49	 cmp	 eax, 73			; 00000049H
  0075a	7c 17		 jl	 SHORT $LN55@display_in
  0075c	b8 01 00 00 00	 mov	 eax, 1
  00761	48 6b c0 01	 imul	 rax, rax, 1
  00765	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0076a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0076e	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00771	7e 21		 jle	 SHORT $LN43@display_in
$LN55@display_in:
$LN54@display_in:
  00773	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  00778	83 f8 01	 cmp	 eax, 1
  0077b	75 6e		 jne	 SHORT $LN42@display_in
  0077d	b8 01 00 00 00	 mov	 eax, 1
  00782	48 6b c0 01	 imul	 rax, rax, 1
  00786	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0078b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0078f	83 f8 0a	 cmp	 eax, 10
  00792	75 57		 jne	 SHORT $LN42@display_in
$LN43@display_in:

; 1677 :         )
; 1678 :     {
; 1679 :         if (trace2file)

  00794	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  00799	85 c0		 test	 eax, eax
  0079b	74 0d		 je	 SHORT $LN56@display_in

; 1680 :             tf_2270( regs );

  0079d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  007a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2270
  007a8	eb 41		 jmp	 SHORT $LN57@display_in
$LN56@display_in:

; 1681 :         else
; 1682 :             len += display_fregs (regs, buf + len, buflen - len - 1, "HHC02270I ");

  007aa	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  007ae	8b 4c 24 78	 mov	 ecx, DWORD PTR buflen$[rsp]
  007b2	2b c8		 sub	 ecx, eax
  007b4	8b c1		 mov	 eax, ecx
  007b6	ff c8		 dec	 eax
  007b8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  007bd	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  007c2	48 03 d1	 add	 rdx, rcx
  007c5	48 8b ca	 mov	 rcx, rdx
  007c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195099
  007cf	44 8b c0	 mov	 r8d, eax
  007d2	48 8b d1	 mov	 rdx, rcx
  007d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  007da	e8 00 00 00 00	 call	 display_fregs
  007df	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  007e3	03 c8		 add	 ecx, eax
  007e5	8b c1		 mov	 eax, ecx
  007e7	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN57@display_in:
$LN42@display_in:

; 1683 :     }
; 1684 :     
; 1685 :     /* Display vector registers if appropriate */
; 1686 :     if (opcode == 0xE7)

  007eb	0f b6 44 24 68	 movzx	 eax, BYTE PTR opcode$[rsp]
  007f0	3d e7 00 00 00	 cmp	 eax, 231		; 000000e7H
  007f5	75 57		 jne	 SHORT $LN58@display_in

; 1687 :     {
; 1688 :         if (trace2file)

  007f7	0f b6 44 24 50	 movzx	 eax, BYTE PTR trace2file$[rsp]
  007fc	85 c0		 test	 eax, eax
  007fe	74 0d		 je	 SHORT $LN59@display_in

; 1689 :             tf_2277(regs);

  00800	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00805	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_2277
  0080b	eb 41		 jmp	 SHORT $LN60@display_in
$LN59@display_in:

; 1690 :         else
; 1691 :             len += display_vregs(regs, buf + len, buflen - len - 1, "HHC02277I ");

  0080d	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00811	8b 4c 24 78	 mov	 ecx, DWORD PTR buflen$[rsp]
  00815	2b c8		 sub	 ecx, eax
  00817	8b c1		 mov	 eax, ecx
  00819	ff c8		 dec	 eax
  0081b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00820	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  00825	48 03 d1	 add	 rdx, rcx
  00828	48 8b ca	 mov	 rcx, rdx
  0082b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195103
  00832	44 8b c0	 mov	 r8d, eax
  00835	48 8b d1	 mov	 rdx, rcx
  00838	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0083d	e8 00 00 00 00	 call	 display_vregs
  00842	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00846	03 c8		 add	 ecx, eax
  00848	8b c1		 mov	 eax, ecx
  0084a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN60@display_in:
$LN58@display_in:

; 1692 :     }
; 1693 :     
; 1694 :     if (len && sysblk.showregsfirst)

  0084e	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  00853	74 41		 je	 SHORT $LN61@display_in
  00855	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0085c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00862	c1 e8 10	 shr	 eax, 16
  00865	83 e0 01	 and	 eax, 1
  00868	85 c0		 test	 eax, eax
  0086a	74 2a		 je	 SHORT $LN61@display_in

; 1695 :         len += idx_snprintf( len, buf, buflen, "\n" );

  0086c	48 63 44 24 78	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00871	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195105
  00878	4c 8b c0	 mov	 r8, rax
  0087b	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  00880	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00884	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0088a	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0088e	03 c8		 add	 ecx, eax
  00890	8b c1		 mov	 eax, ecx
  00892	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN61@display_in:

; 1696 : 
; 1697 :     return len;

  00896	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]

; 1698 : }

  0089a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0089e	c3		 ret	 0
display_inst_regs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
u$ = 512
len$ = 516
tv71 = 520
tv77 = 524
tv697 = 528
tv245 = 532
tv250 = 536
tv255 = 540
tv259 = 544
tv262 = 548
tv265 = 552
tv268 = 556
tv274 = 560
tv279 = 564
tv282 = 568
tv285 = 572
tv291 = 576
tv296 = 580
tv301 = 584
tv311 = 588
tv395 = 592
tv400 = 596
tv406 = 600
tv411 = 604
tv416 = 608
tv420 = 612
tv426 = 616
tv431 = 620
tv437 = 624
tv442 = 628
tv448 = 632
tv453 = 636
tv460 = 640
tv466 = 644
tv471 = 648
tv476 = 652
tv479 = 656
tv482 = 660
tv488 = 664
tv493 = 668
tv498 = 672
tv503 = 676
tv512 = 680
tv515 = 684
tv518 = 688
tv521 = 692
tv766 = 696
tv536 = 704
tv542 = 712
tv548 = 720
tv554 = 728
tv560 = 736
tv566 = 744
tv572 = 752
tv578 = 760
tv582 = 768
tv586 = 776
tv602 = 784
tv608 = 792
tv614 = 800
tv620 = 808
tv626 = 816
tv632 = 824
tv638 = 832
tv676 = 840
tv680 = 848
tv771 = 856
dev$ = 944
buf$ = 952
buflen$ = 960
hdr$ = 968
display_subchannel PROC

; 1866 : {

$LN48:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 55		 push	 r13
  0001c	41 56		 push	 r14
  0001e	41 57		 push	 r15
  00020	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H

; 1867 :     static const char*  status_type[3] = {"Device Status    ",
; 1868 :                                           "Unit Status      ",
; 1869 :                                           "Subchannel Status"};
; 1870 : 
; 1871 :     struct BITS { U8 b7:1; U8 b6:1; U8 b5:1; U8 b4:1; U8 b3:1; U8 b2:1; U8 b1:1; U8 b0:1; };
; 1872 :     union ByteToBits { struct BITS b; U8 status; } u;
; 1873 :     int len = 0;

  00027	c7 84 24 04 02
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 1874 : 
; 1875 :     len += idx_snprintf( len, buf, buflen,

  00032	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0003b	74 15		 je	 SHORT $LN4@display_su
  0003d	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00049	89 84 24 08 02
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  00050	eb 0b		 jmp	 SHORT $LN5@display_su
$LN4@display_su:
  00052	c7 84 24 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
$LN5@display_su:
  0005d	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00066	74 17		 je	 SHORT $LN6@display_su
  00068	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00070	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00074	d1 f8		 sar	 eax, 1
  00076	89 84 24 0c 02
	00 00		 mov	 DWORD PTR tv77[rsp], eax
  0007d	eb 0b		 jmp	 SHORT $LN7@display_su
$LN6@display_su:
  0007f	c7 84 24 0c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv77[rsp], 0
$LN7@display_su:
  0008a	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00092	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00096	48 63 8c 24 c0
	03 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  0009e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000a2	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR tv71[rsp]
  000a9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000ad	8b 84 24 0c 02
	00 00		 mov	 eax, DWORD PTR tv77[rsp]
  000b4	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b8	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195239
  000cc	4c 8b c1	 mov	 r8, rcx
  000cf	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000d7	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  000e4	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  000eb	03 c8		 add	 ecx, eax
  000ed	8b c1		 mov	 eax, ecx
  000ef	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1876 :         "%s%1d:%04X D/T%04X\n",
; 1877 :         hdr, LCSS_DEVNUM, dev->devtype);
; 1878 : 
; 1879 :     if (ARCH_370_IDX == sysblk.arch_mode)

  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fd	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00104	0f 85 c6 01 00
	00		 jne	 $LN2@display_su

; 1880 :     {
; 1881 :         len += idx_snprintf( len, buf, buflen,

  0010a	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b6 80 08 03
	00 00		 movzx	 eax, BYTE PTR [rax+776]
  00119	83 e0 03	 and	 eax, 3
  0011c	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00124	0f b6 89 08 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+776]
  0012b	83 e1 04	 and	 ecx, 4
  0012e	c1 f9 02	 sar	 ecx, 2
  00131	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00139	0f b6 92 08 03
	00 00		 movzx	 edx, BYTE PTR [rdx+776]
  00140	83 e2 08	 and	 edx, 8
  00143	c1 fa 03	 sar	 edx, 3
  00146	4c 8b 84 24 b0
	03 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0014e	45 0f b6 80 08
	03 00 00	 movzx	 r8d, BYTE PTR [r8+776]
  00156	41 81 e0 f0 00
	00 00		 and	 r8d, 240		; 000000f0H
  0015d	41 c1 f8 04	 sar	 r8d, 4
  00161	41 b9 01 00 00
	00		 mov	 r9d, 1
  00167	4d 6b c9 01	 imul	 r9, r9, 1
  0016b	4c 8b 94 24 b0
	03 00 00	 mov	 r10, QWORD PTR dev$[rsp]
  00173	47 0f b6 8c 0a
	12 03 00 00	 movzx	 r9d, BYTE PTR [r10+r9+786]
  0017c	41 ba 01 00 00
	00		 mov	 r10d, 1
  00182	4d 6b d2 00	 imul	 r10, r10, 0
  00186	4c 8b 9c 24 b0
	03 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  0018e	47 0f b6 94 13
	12 03 00 00	 movzx	 r10d, BYTE PTR [r11+r10+786]
  00197	4c 8b 9c 24 b0
	03 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  0019f	45 0f b6 9b 11
	03 00 00	 movzx	 r11d, BYTE PTR [r11+785]
  001a7	48 8b 9c 24 b0
	03 00 00	 mov	 rbx, QWORD PTR dev$[rsp]
  001af	0f b6 9b 10 03
	00 00		 movzx	 ebx, BYTE PTR [rbx+784]
  001b6	bf 01 00 00 00	 mov	 edi, 1
  001bb	48 6b ff 03	 imul	 rdi, rdi, 3
  001bf	48 8b b4 24 b0
	03 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  001c7	0f b6 bc 3e 0c
	03 00 00	 movzx	 edi, BYTE PTR [rsi+rdi+780]
  001cf	be 01 00 00 00	 mov	 esi, 1
  001d4	48 6b f6 02	 imul	 rsi, rsi, 2
  001d8	48 8b ac 24 b0
	03 00 00	 mov	 rbp, QWORD PTR dev$[rsp]
  001e0	0f b6 b4 2e 0c
	03 00 00	 movzx	 esi, BYTE PTR [rsi+rbp+780]
  001e8	bd 01 00 00 00	 mov	 ebp, 1
  001ed	48 6b ed 01	 imul	 rbp, rbp, 1
  001f1	4c 8b b4 24 b0
	03 00 00	 mov	 r14, QWORD PTR dev$[rsp]
  001f9	41 0f b6 ac 2e
	0c 03 00 00	 movzx	 ebp, BYTE PTR [r14+rbp+780]
  00202	4c 8b b4 24 b0
	03 00 00	 mov	 r14, QWORD PTR dev$[rsp]
  0020a	45 0f b6 b6 08
	03 00 00	 movzx	 r14d, BYTE PTR [r14+776]
  00212	4c 63 bc 24 c0
	03 00 00	 movsxd	 r15, DWORD PTR buflen$[rsp]
  0021a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  00221	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00229	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rax
  00231	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00238	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00240	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  00248	89 94 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], edx
  0024f	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00257	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0025c	44 89 44 24 70	 mov	 DWORD PTR [rsp+112], r8d
  00261	44 89 4c 24 68	 mov	 DWORD PTR [rsp+104], r9d
  00266	44 89 54 24 60	 mov	 DWORD PTR [rsp+96], r10d
  0026b	44 89 5c 24 58	 mov	 DWORD PTR [rsp+88], r11d
  00270	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  00274	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0027c	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00281	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00285	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  00289	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0028d	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  00292	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0029a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195241
  002a6	4d 8b c7	 mov	 r8, r15
  002a9	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002b1	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  002be	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  002c5	03 c8		 add	 ecx, eax
  002c7	8b c1		 mov	 eax, ecx
  002c9	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN2@display_su:

; 1882 :             "%s  CSW Flags:%2.2X CCW:%2.2X%2.2X%2.2X            Flags\n"
; 1883 :             "%s         US:%2.2X  CS:%2.2X Count:%2.2X%2.2X       (Key) Subchannel key          %1.1X\n"
; 1884 :             "%s                                       (S)   Suspend control         %1.1X\n"
; 1885 :             "%s                                       (L)   Extended format         %1.1X\n"
; 1886 :             "%s  Subchannel Internal Management       (CC)  Deferred condition code %1.1X\n",
; 1887 :             hdr, dev->scsw.flag0,
; 1888 :                  dev->scsw.ccwaddr[1], dev->scsw.ccwaddr[2], dev->scsw.ccwaddr[3],
; 1889 :             hdr, dev->scsw.unitstat, dev->scsw.chanstat,
; 1890 :                  dev->scsw.count[0], dev->scsw.count[1],
; 1891 :                  (dev->scsw.flag0 & SCSW0_KEY)      >> 4,
; 1892 :             hdr, (dev->scsw.flag0 & SCSW0_S)        >> 3,
; 1893 :             hdr, (dev->scsw.flag0 & SCSW0_L)        >> 2,
; 1894 :             hdr, (dev->scsw.flag0 & SCSW0_CC));
; 1895 :     }
; 1896 : 
; 1897 :     len += idx_snprintf( len, buf, buflen,

  002d0	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d8	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  002df	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e7	0f b6 89 06 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+774]
  002ee	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002f6	0f b6 92 05 03
	00 00		 movzx	 edx, BYTE PTR [rdx+773]
  002fd	48 8b 9c 24 b0
	03 00 00	 mov	 rbx, QWORD PTR dev$[rsp]
  00305	0f b6 9b 04 03
	00 00		 movzx	 ebx, BYTE PTR [rbx+772]
  0030c	bf 01 00 00 00	 mov	 edi, 1
  00311	48 6b ff 07	 imul	 rdi, rdi, 7
  00315	48 8b b4 24 b0
	03 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  0031d	0f b6 bc 3e fc
	02 00 00	 movzx	 edi, BYTE PTR [rsi+rdi+764]
  00325	be 01 00 00 00	 mov	 esi, 1
  0032a	48 6b f6 06	 imul	 rsi, rsi, 6
  0032e	48 8b ac 24 b0
	03 00 00	 mov	 rbp, QWORD PTR dev$[rsp]
  00336	0f b6 b4 2e fc
	02 00 00	 movzx	 esi, BYTE PTR [rsi+rbp+764]
  0033e	bd 01 00 00 00	 mov	 ebp, 1
  00343	48 6b ed 05	 imul	 rbp, rbp, 5
  00347	4c 8b 84 24 b0
	03 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0034f	41 0f b6 ac 28
	fc 02 00 00	 movzx	 ebp, BYTE PTR [r8+rbp+764]
  00358	41 b8 01 00 00
	00		 mov	 r8d, 1
  0035e	4d 6b c0 04	 imul	 r8, r8, 4
  00362	4c 8b 8c 24 b0
	03 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0036a	47 0f b6 84 01
	fc 02 00 00	 movzx	 r8d, BYTE PTR [r9+r8+764]
  00373	41 b9 01 00 00
	00		 mov	 r9d, 1
  00379	4d 6b c9 03	 imul	 r9, r9, 3
  0037d	4c 8b 94 24 b0
	03 00 00	 mov	 r10, QWORD PTR dev$[rsp]
  00385	47 0f b6 8c 0a
	fc 02 00 00	 movzx	 r9d, BYTE PTR [r10+r9+764]
  0038e	41 ba 01 00 00
	00		 mov	 r10d, 1
  00394	4d 6b d2 02	 imul	 r10, r10, 2
  00398	4c 8b 9c 24 b0
	03 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  003a0	47 0f b6 94 13
	fc 02 00 00	 movzx	 r10d, BYTE PTR [r11+r10+764]
  003a9	41 bb 01 00 00
	00		 mov	 r11d, 1
  003af	4d 6b db 01	 imul	 r11, r11, 1
  003b3	4c 8b b4 24 b0
	03 00 00	 mov	 r14, QWORD PTR dev$[rsp]
  003bb	47 0f b6 9c 1e
	fc 02 00 00	 movzx	 r11d, BYTE PTR [r14+r11+764]
  003c4	41 be 01 00 00
	00		 mov	 r14d, 1
  003ca	4d 6b f6 00	 imul	 r14, r14, 0
  003ce	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR dev$[rsp]
  003d6	47 0f b6 b4 37
	fc 02 00 00	 movzx	 r14d, BYTE PTR [r15+r14+764]
  003df	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR dev$[rsp]
  003e7	45 0f b6 bf fb
	02 00 00	 movzx	 r15d, BYTE PTR [r15+763]
  003ef	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  003f7	45 0f b6 a4 24
	fa 02 00 00	 movzx	 r12d, BYTE PTR [r12+762]
  00400	44 89 a4 24 14
	02 00 00	 mov	 DWORD PTR tv245[rsp], r12d
  00408	41 bd 01 00 00
	00		 mov	 r13d, 1
  0040e	4d 6b ed 01	 imul	 r13, r13, 1
  00412	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  0041a	47 0f b6 a4 2c
	f8 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+760]
  00423	44 89 a4 24 18
	02 00 00	 mov	 DWORD PTR tv250[rsp], r12d
  0042b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00431	4d 6b ed 00	 imul	 r13, r13, 0
  00435	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  0043d	47 0f b6 a4 2c
	f8 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+760]
  00446	44 89 a4 24 1c
	02 00 00	 mov	 DWORD PTR tv255[rsp], r12d
  0044e	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00456	45 0f b6 ad f7
	02 00 00	 movzx	 r13d, BYTE PTR [r13+759]
  0045e	44 89 ac 24 20
	02 00 00	 mov	 DWORD PTR tv259[rsp], r13d
  00466	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  0046e	45 0f b6 ad f6
	02 00 00	 movzx	 r13d, BYTE PTR [r13+758]
  00476	44 89 ac 24 24
	02 00 00	 mov	 DWORD PTR tv262[rsp], r13d
  0047e	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00486	45 0f b6 ad f5
	02 00 00	 movzx	 r13d, BYTE PTR [r13+757]
  0048e	44 89 ac 24 28
	02 00 00	 mov	 DWORD PTR tv265[rsp], r13d
  00496	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  0049e	45 0f b6 ad f4
	02 00 00	 movzx	 r13d, BYTE PTR [r13+756]
  004a6	44 89 ac 24 2c
	02 00 00	 mov	 DWORD PTR tv268[rsp], r13d
  004ae	41 bd 01 00 00
	00		 mov	 r13d, 1
  004b4	4d 6b ed 01	 imul	 r13, r13, 1
  004b8	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  004c0	47 0f b6 a4 2c
	f2 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+754]
  004c9	44 89 a4 24 30
	02 00 00	 mov	 DWORD PTR tv274[rsp], r12d
  004d1	41 bd 01 00 00
	00		 mov	 r13d, 1
  004d7	4d 6b ed 00	 imul	 r13, r13, 0
  004db	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  004e3	47 0f b6 a4 2c
	f2 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+754]
  004ec	44 89 a4 24 34
	02 00 00	 mov	 DWORD PTR tv279[rsp], r12d
  004f4	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  004fc	45 0f b6 ad f1
	02 00 00	 movzx	 r13d, BYTE PTR [r13+753]
  00504	44 89 ac 24 38
	02 00 00	 mov	 DWORD PTR tv282[rsp], r13d
  0050c	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00514	45 0f b6 ad f0
	02 00 00	 movzx	 r13d, BYTE PTR [r13+752]
  0051c	44 89 ac 24 3c
	02 00 00	 mov	 DWORD PTR tv285[rsp], r13d
  00524	41 bd 01 00 00
	00		 mov	 r13d, 1
  0052a	4d 6b ed 03	 imul	 r13, r13, 3
  0052e	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00536	47 0f b6 a4 2c
	ec 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+748]
  0053f	44 89 a4 24 40
	02 00 00	 mov	 DWORD PTR tv291[rsp], r12d
  00547	41 bd 01 00 00
	00		 mov	 r13d, 1
  0054d	4d 6b ed 02	 imul	 r13, r13, 2
  00551	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00559	47 0f b6 a4 2c
	ec 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+748]
  00562	44 89 a4 24 44
	02 00 00	 mov	 DWORD PTR tv296[rsp], r12d
  0056a	41 bd 01 00 00
	00		 mov	 r13d, 1
  00570	4d 6b ed 01	 imul	 r13, r13, 1
  00574	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  0057c	47 0f b6 a4 2c
	ec 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+748]
  00585	44 89 a4 24 48
	02 00 00	 mov	 DWORD PTR tv301[rsp], r12d
  0058d	41 bd 01 00 00
	00		 mov	 r13d, 1
  00593	4d 6b ed 00	 imul	 r13, r13, 0
  00597	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  0059f	47 0f b6 a4 2c
	ec 02 00 00	 movzx	 r12d, BYTE PTR [r12+r13+748]
  005a8	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  005b0	45 0f b7 6d 46	 movzx	 r13d, WORD PTR [r13+70]
  005b5	44 89 ac 24 4c
	02 00 00	 mov	 DWORD PTR tv311[rsp], r13d
  005bd	4c 63 ac 24 c0
	03 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  005c5	89 84 24 48 01
	00 00		 mov	 DWORD PTR [rsp+328], eax
  005cc	89 8c 24 40 01
	00 00		 mov	 DWORD PTR [rsp+320], ecx
  005d3	89 94 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], edx
  005da	89 9c 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], ebx
  005e1	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  005e9	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rax
  005f1	89 bc 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], edi
  005f8	89 b4 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], esi
  005ff	89 ac 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], ebp
  00606	44 89 84 24 08
	01 00 00	 mov	 DWORD PTR [rsp+264], r8d
  0060e	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00616	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rax
  0061e	44 89 8c 24 f8
	00 00 00	 mov	 DWORD PTR [rsp+248], r9d
  00626	44 89 94 24 f0
	00 00 00	 mov	 DWORD PTR [rsp+240], r10d
  0062e	44 89 9c 24 e8
	00 00 00	 mov	 DWORD PTR [rsp+232], r11d
  00636	44 89 b4 24 e0
	00 00 00	 mov	 DWORD PTR [rsp+224], r14d
  0063e	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00646	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rax
  0064e	44 89 bc 24 d0
	00 00 00	 mov	 DWORD PTR [rsp+208], r15d
  00656	8b 84 24 14 02
	00 00		 mov	 eax, DWORD PTR tv245[rsp]
  0065d	89 84 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], eax
  00664	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR tv250[rsp]
  0066b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], eax
  00672	8b 84 24 1c 02
	00 00		 mov	 eax, DWORD PTR tv255[rsp]
  00679	89 84 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], eax
  00680	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00688	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rax
  00690	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR tv259[rsp]
  00697	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  0069e	8b 84 24 24 02
	00 00		 mov	 eax, DWORD PTR tv262[rsp]
  006a5	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  006ac	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR tv265[rsp]
  006b3	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  006ba	8b 84 24 2c 02
	00 00		 mov	 eax, DWORD PTR tv268[rsp]
  006c1	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  006c8	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  006d0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  006d8	8b 84 24 30 02
	00 00		 mov	 eax, DWORD PTR tv274[rsp]
  006df	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  006e6	8b 84 24 34 02
	00 00		 mov	 eax, DWORD PTR tv279[rsp]
  006ed	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  006f1	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR tv282[rsp]
  006f8	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  006fc	8b 84 24 3c 02
	00 00		 mov	 eax, DWORD PTR tv285[rsp]
  00703	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00707	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0070f	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00714	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR tv291[rsp]
  0071b	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0071f	8b 84 24 44 02
	00 00		 mov	 eax, DWORD PTR tv296[rsp]
  00726	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0072a	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR tv301[rsp]
  00731	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00735	44 89 64 24 40	 mov	 DWORD PTR [rsp+64], r12d
  0073a	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00742	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00747	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0074f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00754	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR tv311[rsp]
  0075b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0075f	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00767	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195242
  00773	4d 8b c5	 mov	 r8, r13
  00776	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0077e	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0078b	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00792	03 c8		 add	 ecx, eax
  00794	8b c1		 mov	 eax, ecx
  00796	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1898 :         "%s  Subchannel Number[%04X]\n"
; 1899 :         "%s    Path Management Control Word (PMCW)\n"
; 1900 :         "%s  IntParm:%2.2X%2.2X%2.2X%2.2X\n"
; 1901 :         "%s    Flags:%2.2X%2.2X        Dev:%2.2X%2.2X\n"
; 1902 :         "%s      LPM:%2.2X PNOM:%2.2X LPUM:%2.2X PIM:%2.2X\n"
; 1903 :         "%s      MBI:%2.2X%2.2X        POM:%2.2X PAM:%2.2X\n"
; 1904 :         "%s  CHPID 0:%2.2X    1:%2.2X    2:%2.2X   3:%2.2X\n"
; 1905 :         "%s        4:%2.2X    5:%2.2X    6:%2.2X   7:%2.2X\n"
; 1906 :         "%s     Misc:%2.2X%2.2X%2.2X%2.2X\n",
; 1907 :         hdr, dev->subchan,
; 1908 :         hdr,
; 1909 :         hdr, dev->pmcw.intparm[0], dev->pmcw.intparm[1],
; 1910 :         dev->pmcw.intparm[2], dev->pmcw.intparm[3],
; 1911 :         hdr, dev->pmcw.flag4, dev->pmcw.flag5,
; 1912 :         dev->pmcw.devnum[0], dev->pmcw.devnum[1],
; 1913 :         hdr, dev->pmcw.lpm, dev->pmcw.pnom, dev->pmcw.lpum, dev->pmcw.pim,
; 1914 :         hdr, dev->pmcw.mbi[0], dev->pmcw.mbi[1],
; 1915 :         dev->pmcw.pom, dev->pmcw.pam,
; 1916 :         hdr, dev->pmcw.chpid[0], dev->pmcw.chpid[1],
; 1917 :         dev->pmcw.chpid[2], dev->pmcw.chpid[3],
; 1918 :         hdr, dev->pmcw.chpid[4], dev->pmcw.chpid[5],
; 1919 :         dev->pmcw.chpid[6], dev->pmcw.chpid[7],
; 1920 :         hdr,dev->pmcw.zone, dev->pmcw.flag25,
; 1921 :         dev->pmcw.flag26, dev->pmcw.flag27);
; 1922 : 
; 1923 :     len += idx_snprintf( len, buf, buflen,

  0079d	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007a5	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  007ac	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007b1	c1 f8 07	 sar	 eax, 7
  007b4	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007bc	0f b6 89 0b 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+779]
  007c3	83 e1 01	 and	 ecx, 1
  007c6	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007ce	0f b6 92 09 03
	00 00		 movzx	 edx, BYTE PTR [rdx+777]
  007d5	83 e2 01	 and	 edx, 1
  007d8	48 8b 9c 24 b0
	03 00 00	 mov	 rbx, QWORD PTR dev$[rsp]
  007e0	0f b6 9b 0b 03
	00 00		 movzx	 ebx, BYTE PTR [rbx+779]
  007e7	83 e3 02	 and	 ebx, 2
  007ea	d1 fb		 sar	 ebx, 1
  007ec	48 8b bc 24 b0
	03 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  007f4	0f b6 bf 09 03
	00 00		 movzx	 edi, BYTE PTR [rdi+777]
  007fb	83 e7 02	 and	 edi, 2
  007fe	d1 ff		 sar	 edi, 1
  00800	48 8b b4 24 b0
	03 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  00808	0f b6 b6 0b 03
	00 00		 movzx	 esi, BYTE PTR [rsi+779]
  0080f	83 e6 04	 and	 esi, 4
  00812	c1 fe 02	 sar	 esi, 2
  00815	48 8b ac 24 b0
	03 00 00	 mov	 rbp, QWORD PTR dev$[rsp]
  0081d	0f b6 ad 09 03
	00 00		 movzx	 ebp, BYTE PTR [rbp+777]
  00824	83 e5 04	 and	 ebp, 4
  00827	c1 fd 02	 sar	 ebp, 2
  0082a	4c 8b 84 24 b0
	03 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00832	45 0f b6 80 0b
	03 00 00	 movzx	 r8d, BYTE PTR [r8+779]
  0083a	41 83 e0 08	 and	 r8d, 8
  0083e	41 c1 f8 03	 sar	 r8d, 3
  00842	4c 8b 8c 24 b0
	03 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0084a	45 0f b6 89 0b
	03 00 00	 movzx	 r9d, BYTE PTR [r9+779]
  00852	41 83 e1 10	 and	 r9d, 16
  00856	41 c1 f9 04	 sar	 r9d, 4
  0085a	4c 8b 94 24 b0
	03 00 00	 mov	 r10, QWORD PTR dev$[rsp]
  00862	45 0f b6 92 09
	03 00 00	 movzx	 r10d, BYTE PTR [r10+777]
  0086a	41 83 e2 08	 and	 r10d, 8
  0086e	41 c1 fa 03	 sar	 r10d, 3
  00872	4c 8b 9c 24 b0
	03 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  0087a	45 0f b6 9b 09
	03 00 00	 movzx	 r11d, BYTE PTR [r11+777]
  00882	41 83 e3 10	 and	 r11d, 16
  00886	41 c1 fb 04	 sar	 r11d, 4
  0088a	4c 8b b4 24 b0
	03 00 00	 mov	 r14, QWORD PTR dev$[rsp]
  00892	45 0f b6 b6 0b
	03 00 00	 movzx	 r14d, BYTE PTR [r14+779]
  0089a	41 83 e6 20	 and	 r14d, 32		; 00000020H
  0089e	41 c1 fe 05	 sar	 r14d, 5
  008a2	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR dev$[rsp]
  008aa	45 0f b6 bf 09
	03 00 00	 movzx	 r15d, BYTE PTR [r15+777]
  008b2	41 83 e7 20	 and	 r15d, 32		; 00000020H
  008b6	41 c1 ff 05	 sar	 r15d, 5
  008ba	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  008c2	45 0f b6 a4 24
	0b 03 00 00	 movzx	 r12d, BYTE PTR [r12+779]
  008cb	41 83 e4 40	 and	 r12d, 64		; 00000040H
  008cf	41 c1 fc 06	 sar	 r12d, 6
  008d3	44 89 a4 24 50
	02 00 00	 mov	 DWORD PTR tv395[rsp], r12d
  008db	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  008e3	45 0f b6 ad 09
	03 00 00	 movzx	 r13d, BYTE PTR [r13+777]
  008eb	41 83 e5 40	 and	 r13d, 64		; 00000040H
  008ef	41 c1 fd 06	 sar	 r13d, 6
  008f3	44 89 ac 24 54
	02 00 00	 mov	 DWORD PTR tv400[rsp], r13d
  008fb	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00903	45 0f b6 ad 0b
	03 00 00	 movzx	 r13d, BYTE PTR [r13+779]
  0090b	41 81 e5 80 00
	00 00		 and	 r13d, 128		; 00000080H
  00912	41 c1 fd 07	 sar	 r13d, 7
  00916	44 89 ac 24 58
	02 00 00	 mov	 DWORD PTR tv406[rsp], r13d
  0091e	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00926	45 0f b6 ad 09
	03 00 00	 movzx	 r13d, BYTE PTR [r13+777]
  0092e	41 81 e5 80 00
	00 00		 and	 r13d, 128		; 00000080H
  00935	41 c1 fd 07	 sar	 r13d, 7
  00939	44 89 ac 24 5c
	02 00 00	 mov	 DWORD PTR tv411[rsp], r13d
  00941	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00949	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00951	41 83 e5 01	 and	 r13d, 1
  00955	44 89 ac 24 60
	02 00 00	 mov	 DWORD PTR tv416[rsp], r13d
  0095d	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00965	45 0f b6 ad 08
	03 00 00	 movzx	 r13d, BYTE PTR [r13+776]
  0096d	41 83 e5 03	 and	 r13d, 3
  00971	44 89 ac 24 64
	02 00 00	 mov	 DWORD PTR tv420[rsp], r13d
  00979	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00981	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00989	41 83 e5 02	 and	 r13d, 2
  0098d	41 d1 fd	 sar	 r13d, 1
  00990	44 89 ac 24 68
	02 00 00	 mov	 DWORD PTR tv426[rsp], r13d
  00998	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  009a0	45 0f b6 ad 08
	03 00 00	 movzx	 r13d, BYTE PTR [r13+776]
  009a8	41 83 e5 04	 and	 r13d, 4
  009ac	41 c1 fd 02	 sar	 r13d, 2
  009b0	44 89 ac 24 6c
	02 00 00	 mov	 DWORD PTR tv431[rsp], r13d
  009b8	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  009c0	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  009c8	41 83 e5 04	 and	 r13d, 4
  009cc	41 c1 fd 02	 sar	 r13d, 2
  009d0	44 89 ac 24 70
	02 00 00	 mov	 DWORD PTR tv437[rsp], r13d
  009d8	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  009e0	45 0f b6 ad 08
	03 00 00	 movzx	 r13d, BYTE PTR [r13+776]
  009e8	41 83 e5 08	 and	 r13d, 8
  009ec	41 c1 fd 03	 sar	 r13d, 3
  009f0	44 89 ac 24 74
	02 00 00	 mov	 DWORD PTR tv442[rsp], r13d
  009f8	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00a00	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00a08	41 83 e5 08	 and	 r13d, 8
  00a0c	41 c1 fd 03	 sar	 r13d, 3
  00a10	44 89 ac 24 78
	02 00 00	 mov	 DWORD PTR tv448[rsp], r13d
  00a18	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00a20	45 0f b6 ad 08
	03 00 00	 movzx	 r13d, BYTE PTR [r13+776]
  00a28	41 81 e5 f0 00
	00 00		 and	 r13d, 240		; 000000f0H
  00a2f	41 c1 fd 04	 sar	 r13d, 4
  00a33	44 89 ac 24 7c
	02 00 00	 mov	 DWORD PTR tv453[rsp], r13d
  00a3b	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00a43	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00a4b	41 83 e5 10	 and	 r13d, 16
  00a4f	41 c1 fd 04	 sar	 r13d, 4
  00a53	44 89 ac 24 80
	02 00 00	 mov	 DWORD PTR tv460[rsp], r13d
  00a5b	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00a63	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00a6b	41 83 e5 20	 and	 r13d, 32		; 00000020H
  00a6f	41 c1 fd 05	 sar	 r13d, 5
  00a73	44 89 ac 24 84
	02 00 00	 mov	 DWORD PTR tv466[rsp], r13d
  00a7b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00a81	4d 6b ed 01	 imul	 r13, r13, 1
  00a85	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00a8d	47 0f b6 a4 2c
	12 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+786]
  00a96	44 89 a4 24 88
	02 00 00	 mov	 DWORD PTR tv471[rsp], r12d
  00a9e	41 bd 01 00 00
	00		 mov	 r13d, 1
  00aa4	4d 6b ed 00	 imul	 r13, r13, 0
  00aa8	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00ab0	47 0f b6 a4 2c
	12 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+786]
  00ab9	44 89 a4 24 8c
	02 00 00	 mov	 DWORD PTR tv476[rsp], r12d
  00ac1	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00ac9	45 0f b6 ad 11
	03 00 00	 movzx	 r13d, BYTE PTR [r13+785]
  00ad1	44 89 ac 24 90
	02 00 00	 mov	 DWORD PTR tv479[rsp], r13d
  00ad9	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00ae1	45 0f b6 ad 10
	03 00 00	 movzx	 r13d, BYTE PTR [r13+784]
  00ae9	44 89 ac 24 94
	02 00 00	 mov	 DWORD PTR tv482[rsp], r13d
  00af1	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00af9	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00b01	41 83 e5 40	 and	 r13d, 64		; 00000040H
  00b05	41 c1 fd 06	 sar	 r13d, 6
  00b09	44 89 ac 24 98
	02 00 00	 mov	 DWORD PTR tv488[rsp], r13d
  00b11	41 bd 01 00 00
	00		 mov	 r13d, 1
  00b17	4d 6b ed 03	 imul	 r13, r13, 3
  00b1b	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00b23	47 0f b6 a4 2c
	0c 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+780]
  00b2c	44 89 a4 24 9c
	02 00 00	 mov	 DWORD PTR tv493[rsp], r12d
  00b34	41 bd 01 00 00
	00		 mov	 r13d, 1
  00b3a	4d 6b ed 02	 imul	 r13, r13, 2
  00b3e	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00b46	47 0f b6 a4 2c
	0c 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+780]
  00b4f	44 89 a4 24 a0
	02 00 00	 mov	 DWORD PTR tv498[rsp], r12d
  00b57	41 bd 01 00 00
	00		 mov	 r13d, 1
  00b5d	4d 6b ed 01	 imul	 r13, r13, 1
  00b61	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00b69	47 0f b6 a4 2c
	0c 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+780]
  00b72	44 89 a4 24 a4
	02 00 00	 mov	 DWORD PTR tv503[rsp], r12d
  00b7a	41 bd 01 00 00
	00		 mov	 r13d, 1
  00b80	4d 6b ed 00	 imul	 r13, r13, 0
  00b84	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  00b8c	47 0f b6 a4 2c
	0c 03 00 00	 movzx	 r12d, BYTE PTR [r12+r13+780]
  00b95	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00b9d	45 0f b6 ad 0b
	03 00 00	 movzx	 r13d, BYTE PTR [r13+779]
  00ba5	44 89 ac 24 a8
	02 00 00	 mov	 DWORD PTR tv512[rsp], r13d
  00bad	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00bb5	45 0f b6 ad 0a
	03 00 00	 movzx	 r13d, BYTE PTR [r13+778]
  00bbd	44 89 ac 24 ac
	02 00 00	 mov	 DWORD PTR tv515[rsp], r13d
  00bc5	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00bcd	45 0f b6 ad 09
	03 00 00	 movzx	 r13d, BYTE PTR [r13+777]
  00bd5	44 89 ac 24 b0
	02 00 00	 mov	 DWORD PTR tv518[rsp], r13d
  00bdd	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  00be5	45 0f b6 ad 08
	03 00 00	 movzx	 r13d, BYTE PTR [r13+776]
  00bed	44 89 ac 24 b4
	02 00 00	 mov	 DWORD PTR tv521[rsp], r13d
  00bf5	4c 63 ac 24 c0
	03 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  00bfd	89 84 24 f8 01
	00 00		 mov	 DWORD PTR [rsp+504], eax
  00c04	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c0c	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR [rsp+496], rax
  00c14	89 8c 24 e8 01
	00 00		 mov	 DWORD PTR [rsp+488], ecx
  00c1b	89 94 24 e0 01
	00 00		 mov	 DWORD PTR [rsp+480], edx
  00c22	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c2a	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR [rsp+472], rax
  00c32	89 9c 24 d0 01
	00 00		 mov	 DWORD PTR [rsp+464], ebx
  00c39	89 bc 24 c8 01
	00 00		 mov	 DWORD PTR [rsp+456], edi
  00c40	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c48	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR [rsp+448], rax
  00c50	89 b4 24 b8 01
	00 00		 mov	 DWORD PTR [rsp+440], esi
  00c57	89 ac 24 b0 01
	00 00		 mov	 DWORD PTR [rsp+432], ebp
  00c5e	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c66	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR [rsp+424], rax
  00c6e	44 89 84 24 a0
	01 00 00	 mov	 DWORD PTR [rsp+416], r8d
  00c76	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c7e	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR [rsp+408], rax
  00c86	44 89 8c 24 90
	01 00 00	 mov	 DWORD PTR [rsp+400], r9d
  00c8e	44 89 94 24 88
	01 00 00	 mov	 DWORD PTR [rsp+392], r10d
  00c96	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00c9e	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR [rsp+384], rax
  00ca6	44 89 9c 24 78
	01 00 00	 mov	 DWORD PTR [rsp+376], r11d
  00cae	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00cb6	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR [rsp+368], rax
  00cbe	44 89 b4 24 68
	01 00 00	 mov	 DWORD PTR [rsp+360], r14d
  00cc6	44 89 bc 24 60
	01 00 00	 mov	 DWORD PTR [rsp+352], r15d
  00cce	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00cd6	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR [rsp+344], rax
  00cde	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR tv395[rsp]
  00ce5	89 84 24 50 01
	00 00		 mov	 DWORD PTR [rsp+336], eax
  00cec	8b 84 24 54 02
	00 00		 mov	 eax, DWORD PTR tv400[rsp]
  00cf3	89 84 24 48 01
	00 00		 mov	 DWORD PTR [rsp+328], eax
  00cfa	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00d02	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR [rsp+320], rax
  00d0a	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR tv406[rsp]
  00d11	89 84 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], eax
  00d18	8b 84 24 5c 02
	00 00		 mov	 eax, DWORD PTR tv411[rsp]
  00d1f	89 84 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], eax
  00d26	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00d2e	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rax
  00d36	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR tv416[rsp]
  00d3d	89 84 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], eax
  00d44	8b 84 24 64 02
	00 00		 mov	 eax, DWORD PTR tv420[rsp]
  00d4b	89 84 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], eax
  00d52	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00d5a	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR [rsp+272], rax
  00d62	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR tv426[rsp]
  00d69	89 84 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], eax
  00d70	8b 84 24 6c 02
	00 00		 mov	 eax, DWORD PTR tv431[rsp]
  00d77	89 84 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], eax
  00d7e	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00d86	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR [rsp+248], rax
  00d8e	8b 84 24 70 02
	00 00		 mov	 eax, DWORD PTR tv437[rsp]
  00d95	89 84 24 f0 00
	00 00		 mov	 DWORD PTR [rsp+240], eax
  00d9c	8b 84 24 74 02
	00 00		 mov	 eax, DWORD PTR tv442[rsp]
  00da3	89 84 24 e8 00
	00 00		 mov	 DWORD PTR [rsp+232], eax
  00daa	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00db2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rax
  00dba	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR tv448[rsp]
  00dc1	89 84 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], eax
  00dc8	8b 84 24 7c 02
	00 00		 mov	 eax, DWORD PTR tv453[rsp]
  00dcf	89 84 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], eax
  00dd6	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00dde	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rax
  00de6	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00dee	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rax
  00df6	8b 84 24 80 02
	00 00		 mov	 eax, DWORD PTR tv460[rsp]
  00dfd	89 84 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], eax
  00e04	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00e0c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rax
  00e14	8b 84 24 84 02
	00 00		 mov	 eax, DWORD PTR tv466[rsp]
  00e1b	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  00e22	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR tv471[rsp]
  00e29	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  00e30	8b 84 24 8c 02
	00 00		 mov	 eax, DWORD PTR tv476[rsp]
  00e37	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  00e3e	8b 84 24 90 02
	00 00		 mov	 eax, DWORD PTR tv479[rsp]
  00e45	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  00e4c	8b 84 24 94 02
	00 00		 mov	 eax, DWORD PTR tv482[rsp]
  00e53	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  00e5a	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00e62	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  00e6a	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR tv488[rsp]
  00e71	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  00e75	8b 84 24 9c 02
	00 00		 mov	 eax, DWORD PTR tv493[rsp]
  00e7c	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00e80	8b 84 24 a0 02
	00 00		 mov	 eax, DWORD PTR tv498[rsp]
  00e87	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00e8b	8b 84 24 a4 02
	00 00		 mov	 eax, DWORD PTR tv503[rsp]
  00e92	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00e96	44 89 64 24 58	 mov	 DWORD PTR [rsp+88], r12d
  00e9b	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00ea3	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00ea8	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR tv512[rsp]
  00eaf	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00eb3	8b 84 24 ac 02
	00 00		 mov	 eax, DWORD PTR tv515[rsp]
  00eba	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00ebe	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR tv518[rsp]
  00ec5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00ec9	8b 84 24 b4 02
	00 00		 mov	 eax, DWORD PTR tv521[rsp]
  00ed0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ed4	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00edc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ee1	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00ee9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00eee	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195243
  00ef5	4d 8b c5	 mov	 r8, r13
  00ef8	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00f00	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00f07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00f0d	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00f14	03 c8		 add	 ecx, eax
  00f16	8b c1		 mov	 eax, ecx
  00f18	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1924 :         "%s  Subchannel Status Word (SCSW)\n"
; 1925 :         "%s    Flags: %2.2X%2.2X  Subchan Ctl: %2.2X%2.2X     (FC)  Function Control\n"
; 1926 :         "%s      CCW: %2.2X%2.2X%2.2X%2.2X                          Start                   %1.1X\n"
; 1927 :         "%s       DS: %2.2X  SS: %2.2X  Count: %2.2X%2.2X           Halt                    %1.1X\n"
; 1928 :         "%s                                             Clear                   %1.1X\n"
; 1929 :         "%s    Flags                              (AC)  Activity Control\n"
; 1930 :         "%s      (Key) Subchannel key          %1.1X        Resume pending          %1.1X\n"
; 1931 :         "%s      (S)   Suspend control         %1.1X        Start pending           %1.1X\n"
; 1932 :         "%s      (L)   Extended format         %1.1X        Halt pending            %1.1X\n"
; 1933 :         "%s      (CC)  Deferred condition code %1.1X        Clear pending           %1.1X\n"
; 1934 :         "%s      (F)   CCW-format control      %1.1X        Subchannel active       %1.1X\n"
; 1935 :         "%s      (P)   Prefetch control        %1.1X        Device active           %1.1X\n"
; 1936 :         "%s      (I)   Initial-status control  %1.1X        Suspended               %1.1X\n"
; 1937 :         "%s      (A)   Address-limit control   %1.1X  (SC)  Status Control\n"
; 1938 :         "%s      (U)   Suppress-suspend int.   %1.1X        Alert                   %1.1X\n"
; 1939 :         "%s    Subchannel Control                       Intermediate            %1.1X\n"
; 1940 :         "%s      (Z)   Zero condition code     %1.1X        Primary                 %1.1X\n"
; 1941 :         "%s      (E)   Extended control (ECW)  %1.1X        Secondary               %1.1X\n"
; 1942 :         "%s      (N)   Path not operational    %1.1X        Status pending          %1.1X\n"
; 1943 :         "%s      (Q)   QDIO active             %1.1X\n",
; 1944 :         hdr,
; 1945 :         hdr, dev->scsw.flag0, dev->scsw.flag1, dev->scsw.flag2, dev->scsw.flag3,
; 1946 :         hdr, dev->scsw.ccwaddr[0], dev->scsw.ccwaddr[1],
; 1947 :              dev->scsw.ccwaddr[2], dev->scsw.ccwaddr[3],
; 1948 :              (dev->scsw.flag2 & SCSW2_FC_START) >> 6,
; 1949 :         hdr, dev->scsw.unitstat, dev->scsw.chanstat,
; 1950 :              dev->scsw.count[0], dev->scsw.count[1],
; 1951 :              (dev->scsw.flag2 & SCSW2_FC_HALT)  >> 5,
; 1952 :         hdr, (dev->scsw.flag2 & SCSW2_FC_CLEAR) >> 4,
; 1953 :         hdr,
; 1954 :         hdr, (dev->scsw.flag0 & SCSW0_KEY)      >> 4,
; 1955 :              (dev->scsw.flag2 & SCSW2_AC_RESUM) >> 3,
; 1956 :         hdr, (dev->scsw.flag0 & SCSW0_S)        >> 3,
; 1957 :              (dev->scsw.flag2 & SCSW2_AC_START) >> 2,
; 1958 :         hdr, (dev->scsw.flag0 & SCSW0_L)        >> 2,
; 1959 :              (dev->scsw.flag2 & SCSW2_AC_HALT)  >> 1,
; 1960 :         hdr, (dev->scsw.flag0 & SCSW0_CC),
; 1961 :              (dev->scsw.flag2 & SCSW2_AC_CLEAR),
; 1962 :         hdr, (dev->scsw.flag1 & SCSW1_F)        >> 7,
; 1963 :              (dev->scsw.flag3 & SCSW3_AC_SCHAC) >> 7,
; 1964 :         hdr, (dev->scsw.flag1 & SCSW1_P)        >> 6,
; 1965 :              (dev->scsw.flag3 & SCSW3_AC_DEVAC) >> 6,
; 1966 :         hdr, (dev->scsw.flag1 & SCSW1_I)        >> 5,
; 1967 :              (dev->scsw.flag3 & SCSW3_AC_SUSP)  >> 5,
; 1968 :         hdr, (dev->scsw.flag1 & SCSW1_A)        >> 4,
; 1969 :         hdr, (dev->scsw.flag1 & SCSW1_U)        >> 3,
; 1970 :              (dev->scsw.flag3 & SCSW3_SC_ALERT) >> 4,
; 1971 :         hdr, (dev->scsw.flag3 & SCSW3_SC_INTER) >> 3,
; 1972 :         hdr, (dev->scsw.flag1 & SCSW1_Z)        >> 2,
; 1973 :              (dev->scsw.flag3 & SCSW3_SC_PRI)   >> 2,
; 1974 :         hdr, (dev->scsw.flag1 & SCSW1_E)        >> 1,
; 1975 :              (dev->scsw.flag3 & SCSW3_SC_SEC)   >> 1,
; 1976 :         hdr, (dev->scsw.flag1 & SCSW1_N),
; 1977 :              (dev->scsw.flag3 & SCSW3_SC_PEND),
; 1978 :         hdr, (dev->scsw.flag2 & SCSW2_Q)        >> 7);
; 1979 : 
; 1980 :     u.status = (U8)dev->scsw.unitstat;

  00f1f	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f27	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  00f2e	88 84 24 00 02
	00 00		 mov	 BYTE PTR u$[rsp], al

; 1981 :     len += idx_snprintf( len, buf, buflen,

  00f35	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  00f3d	24 01		 and	 al, 1
  00f3f	0f b6 c0	 movzx	 eax, al
  00f42	85 c0		 test	 eax, eax
  00f44	74 11		 je	 SHORT $LN8@display_su
  00f46	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195244
  00f4d	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR tv536[rsp], rax
  00f55	eb 0f		 jmp	 SHORT $LN9@display_su
$LN8@display_su:
  00f57	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195245
  00f5e	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR tv536[rsp], rax
$LN9@display_su:
  00f66	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  00f6e	d0 e8		 shr	 al, 1
  00f70	24 01		 and	 al, 1
  00f72	0f b6 c0	 movzx	 eax, al
  00f75	85 c0		 test	 eax, eax
  00f77	74 11		 je	 SHORT $LN10@display_su
  00f79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195246
  00f80	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv542[rsp], rax
  00f88	eb 0f		 jmp	 SHORT $LN11@display_su
$LN10@display_su:
  00f8a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195247
  00f91	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv542[rsp], rax
$LN11@display_su:
  00f99	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  00fa1	c0 e8 02	 shr	 al, 2
  00fa4	24 01		 and	 al, 1
  00fa6	0f b6 c0	 movzx	 eax, al
  00fa9	85 c0		 test	 eax, eax
  00fab	74 11		 je	 SHORT $LN12@display_su
  00fad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195248
  00fb4	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR tv548[rsp], rax
  00fbc	eb 0f		 jmp	 SHORT $LN13@display_su
$LN12@display_su:
  00fbe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195249
  00fc5	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR tv548[rsp], rax
$LN13@display_su:
  00fcd	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  00fd5	c0 e8 03	 shr	 al, 3
  00fd8	24 01		 and	 al, 1
  00fda	0f b6 c0	 movzx	 eax, al
  00fdd	85 c0		 test	 eax, eax
  00fdf	74 11		 je	 SHORT $LN14@display_su
  00fe1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195250
  00fe8	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv554[rsp], rax
  00ff0	eb 0f		 jmp	 SHORT $LN15@display_su
$LN14@display_su:
  00ff2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195251
  00ff9	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv554[rsp], rax
$LN15@display_su:
  01001	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01009	c0 e8 04	 shr	 al, 4
  0100c	24 01		 and	 al, 1
  0100e	0f b6 c0	 movzx	 eax, al
  01011	85 c0		 test	 eax, eax
  01013	74 11		 je	 SHORT $LN16@display_su
  01015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195252
  0101c	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv560[rsp], rax
  01024	eb 0f		 jmp	 SHORT $LN17@display_su
$LN16@display_su:
  01026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195253
  0102d	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv560[rsp], rax
$LN17@display_su:
  01035	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  0103d	c0 e8 05	 shr	 al, 5
  01040	24 01		 and	 al, 1
  01042	0f b6 c0	 movzx	 eax, al
  01045	85 c0		 test	 eax, eax
  01047	74 11		 je	 SHORT $LN18@display_su
  01049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195254
  01050	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR tv566[rsp], rax
  01058	eb 0f		 jmp	 SHORT $LN19@display_su
$LN18@display_su:
  0105a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195255
  01061	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR tv566[rsp], rax
$LN19@display_su:
  01069	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01071	c0 e8 06	 shr	 al, 6
  01074	24 01		 and	 al, 1
  01076	0f b6 c0	 movzx	 eax, al
  01079	85 c0		 test	 eax, eax
  0107b	74 11		 je	 SHORT $LN20@display_su
  0107d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195256
  01084	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv572[rsp], rax
  0108c	eb 0f		 jmp	 SHORT $LN21@display_su
$LN20@display_su:
  0108e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195257
  01095	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv572[rsp], rax
$LN21@display_su:
  0109d	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  010a5	c0 e8 07	 shr	 al, 7
  010a8	24 01		 and	 al, 1
  010aa	0f b6 c0	 movzx	 eax, al
  010ad	85 c0		 test	 eax, eax
  010af	74 11		 je	 SHORT $LN22@display_su
  010b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195258
  010b8	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv578[rsp], rax
  010c0	eb 0f		 jmp	 SHORT $LN23@display_su
$LN22@display_su:
  010c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195259
  010c9	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv578[rsp], rax
$LN23@display_su:
  010d1	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  010d9	85 c0		 test	 eax, eax
  010db	75 11		 jne	 SHORT $LN24@display_su
  010dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195260
  010e4	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv582[rsp], rax
  010ec	eb 0f		 jmp	 SHORT $LN25@display_su
$LN24@display_su:
  010ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195261
  010f5	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv582[rsp], rax
$LN25@display_su:
  010fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01104	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0110b	75 0e		 jne	 SHORT $LN26@display_su
  0110d	48 c7 84 24 08
	03 00 00 01 00
	00 00		 mov	 QWORD PTR tv586[rsp], 1
  01119	eb 0c		 jmp	 SHORT $LN27@display_su
$LN26@display_su:
  0111b	48 c7 84 24 08
	03 00 00 00 00
	00 00		 mov	 QWORD PTR tv586[rsp], 0
$LN27@display_su:
  01127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?status_type@?1??display_subchannel@@9@9
  0112e	48 63 8c 24 c0
	03 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  01136	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR tv536[rsp]
  0113e	48 89 54 24 70	 mov	 QWORD PTR [rsp+112], rdx
  01143	48 8b 94 24 c8
	02 00 00	 mov	 rdx, QWORD PTR tv542[rsp]
  0114b	48 89 54 24 68	 mov	 QWORD PTR [rsp+104], rdx
  01150	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR tv548[rsp]
  01158	48 89 54 24 60	 mov	 QWORD PTR [rsp+96], rdx
  0115d	48 8b 94 24 d8
	02 00 00	 mov	 rdx, QWORD PTR tv554[rsp]
  01165	48 89 54 24 58	 mov	 QWORD PTR [rsp+88], rdx
  0116a	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR tv560[rsp]
  01172	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  01177	48 8b 94 24 e8
	02 00 00	 mov	 rdx, QWORD PTR tv566[rsp]
  0117f	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  01184	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR tv572[rsp]
  0118c	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  01191	48 8b 94 24 f8
	02 00 00	 mov	 rdx, QWORD PTR tv578[rsp]
  01199	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  0119e	48 8b 94 24 00
	03 00 00	 mov	 rdx, QWORD PTR tv582[rsp]
  011a6	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  011ab	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR tv586[rsp]
  011b3	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]
  011b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011bc	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  011c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195262
  011d0	4c 8b c1	 mov	 r8, rcx
  011d3	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  011db	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  011e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  011e8	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  011ef	03 c8		 add	 ecx, eax
  011f1	8b c1		 mov	 eax, ecx
  011f3	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1982 :         "%s    %s %s%s%s%s%s%s%s%s%s\n",
; 1983 :         hdr, status_type[(sysblk.arch_mode == ARCH_370_IDX)],
; 1984 :         u.status == 0 ? "is Normal" : "",
; 1985 :         u.b.b0 ? "Attention " : "",
; 1986 :         u.b.b1 ? "SM " : "",
; 1987 :         u.b.b2 ? "CUE " : "",
; 1988 :         u.b.b3 ? "Busy " : "",
; 1989 :         u.b.b4 ? "CE " : "",
; 1990 :         u.b.b5 ? "DE " : "",
; 1991 :         u.b.b6 ? "UC " : "",
; 1992 :         u.b.b7 ? "UE " : "");
; 1993 : 
; 1994 :     u.status = (U8)dev->scsw.chanstat;

  011fa	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01202	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  01209	88 84 24 00 02
	00 00		 mov	 BYTE PTR u$[rsp], al

; 1995 :     len += idx_snprintf( len, buf, buflen,

  01210	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01218	24 01		 and	 al, 1
  0121a	0f b6 c0	 movzx	 eax, al
  0121d	85 c0		 test	 eax, eax
  0121f	74 11		 je	 SHORT $LN28@display_su
  01221	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195263
  01228	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv602[rsp], rax
  01230	eb 0f		 jmp	 SHORT $LN29@display_su
$LN28@display_su:
  01232	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195264
  01239	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv602[rsp], rax
$LN29@display_su:
  01241	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01249	d0 e8		 shr	 al, 1
  0124b	24 01		 and	 al, 1
  0124d	0f b6 c0	 movzx	 eax, al
  01250	85 c0		 test	 eax, eax
  01252	74 11		 je	 SHORT $LN30@display_su
  01254	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195265
  0125b	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv608[rsp], rax
  01263	eb 0f		 jmp	 SHORT $LN31@display_su
$LN30@display_su:
  01265	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195266
  0126c	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv608[rsp], rax
$LN31@display_su:
  01274	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  0127c	c0 e8 02	 shr	 al, 2
  0127f	24 01		 and	 al, 1
  01281	0f b6 c0	 movzx	 eax, al
  01284	85 c0		 test	 eax, eax
  01286	74 11		 je	 SHORT $LN32@display_su
  01288	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195267
  0128f	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR tv614[rsp], rax
  01297	eb 0f		 jmp	 SHORT $LN33@display_su
$LN32@display_su:
  01299	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195268
  012a0	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR tv614[rsp], rax
$LN33@display_su:
  012a8	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  012b0	c0 e8 03	 shr	 al, 3
  012b3	24 01		 and	 al, 1
  012b5	0f b6 c0	 movzx	 eax, al
  012b8	85 c0		 test	 eax, eax
  012ba	74 11		 je	 SHORT $LN34@display_su
  012bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195269
  012c3	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv620[rsp], rax
  012cb	eb 0f		 jmp	 SHORT $LN35@display_su
$LN34@display_su:
  012cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195270
  012d4	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv620[rsp], rax
$LN35@display_su:
  012dc	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  012e4	c0 e8 04	 shr	 al, 4
  012e7	24 01		 and	 al, 1
  012e9	0f b6 c0	 movzx	 eax, al
  012ec	85 c0		 test	 eax, eax
  012ee	74 11		 je	 SHORT $LN36@display_su
  012f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195271
  012f7	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv626[rsp], rax
  012ff	eb 0f		 jmp	 SHORT $LN37@display_su
$LN36@display_su:
  01301	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195272
  01308	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv626[rsp], rax
$LN37@display_su:
  01310	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01318	c0 e8 05	 shr	 al, 5
  0131b	24 01		 and	 al, 1
  0131d	0f b6 c0	 movzx	 eax, al
  01320	85 c0		 test	 eax, eax
  01322	74 11		 je	 SHORT $LN38@display_su
  01324	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195273
  0132b	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR tv632[rsp], rax
  01333	eb 0f		 jmp	 SHORT $LN39@display_su
$LN38@display_su:
  01335	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195274
  0133c	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR tv632[rsp], rax
$LN39@display_su:
  01344	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  0134c	c0 e8 06	 shr	 al, 6
  0134f	24 01		 and	 al, 1
  01351	0f b6 c0	 movzx	 eax, al
  01354	85 c0		 test	 eax, eax
  01356	74 11		 je	 SHORT $LN40@display_su
  01358	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195275
  0135f	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR tv638[rsp], rax
  01367	eb 0f		 jmp	 SHORT $LN41@display_su
$LN40@display_su:
  01369	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195276
  01370	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR tv638[rsp], rax
$LN41@display_su:
  01378	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  01380	c0 e8 07	 shr	 al, 7
  01383	24 01		 and	 al, 1
  01385	0f b6 c0	 movzx	 eax, al
  01388	85 c0		 test	 eax, eax
  0138a	74 11		 je	 SHORT $LN42@display_su
  0138c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195277
  01393	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv676[rsp], rax
  0139b	eb 0f		 jmp	 SHORT $LN43@display_su
$LN42@display_su:
  0139d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195278
  013a4	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv676[rsp], rax
$LN43@display_su:
  013ac	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR u$[rsp]
  013b4	85 c0		 test	 eax, eax
  013b6	75 11		 jne	 SHORT $LN44@display_su
  013b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195279
  013bf	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv680[rsp], rax
  013c7	eb 0f		 jmp	 SHORT $LN45@display_su
$LN44@display_su:
  013c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195280
  013d0	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv680[rsp], rax
$LN45@display_su:
  013d8	b8 08 00 00 00	 mov	 eax, 8
  013dd	48 6b c0 02	 imul	 rax, rax, 2
  013e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?status_type@?1??display_subchannel@@9@9
  013e8	48 63 94 24 c0
	03 00 00	 movsxd	 rdx, DWORD PTR buflen$[rsp]
  013f0	48 8b 9c 24 10
	03 00 00	 mov	 rbx, QWORD PTR tv602[rsp]
  013f8	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  013fd	48 8b 9c 24 18
	03 00 00	 mov	 rbx, QWORD PTR tv608[rsp]
  01405	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  0140a	48 8b 9c 24 20
	03 00 00	 mov	 rbx, QWORD PTR tv614[rsp]
  01412	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  01417	48 8b 9c 24 28
	03 00 00	 mov	 rbx, QWORD PTR tv620[rsp]
  0141f	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  01424	48 8b 9c 24 30
	03 00 00	 mov	 rbx, QWORD PTR tv626[rsp]
  0142c	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  01431	48 8b 9c 24 38
	03 00 00	 mov	 rbx, QWORD PTR tv632[rsp]
  01439	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  0143e	48 8b 9c 24 40
	03 00 00	 mov	 rbx, QWORD PTR tv638[rsp]
  01446	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0144b	48 8b 9c 24 48
	03 00 00	 mov	 rbx, QWORD PTR tv676[rsp]
  01453	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  01458	48 8b 9c 24 50
	03 00 00	 mov	 rbx, QWORD PTR tv680[rsp]
  01460	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  01465	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  01469	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0146e	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01476	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0147b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195281
  01482	4c 8b c2	 mov	 r8, rdx
  01485	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0148d	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  01494	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0149a	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  014a1	03 c8		 add	 ecx, eax
  014a3	8b c1		 mov	 eax, ecx
  014a5	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1996 :         "%s    %s %s%s%s%s%s%s%s%s%s\n",
; 1997 :         hdr, status_type[2],
; 1998 :         u.status == 0 ? "is Normal" : "",
; 1999 :         u.b.b0 ? "PCI " : "",
; 2000 :         u.b.b1 ? "IL " : "",
; 2001 :         u.b.b2 ? "PC " : "",
; 2002 :         u.b.b3 ? "ProtC " : "",
; 2003 :         u.b.b4 ? "CDC " : "",
; 2004 :         u.b.b5 ? "CCC " : "",
; 2005 :         u.b.b6 ? "ICC " : "",
; 2006 :         u.b.b7 ? "CC " : "");
; 2007 : 
; 2008 :     // PROGRAMMING NOTE: the following ugliness is needed
; 2009 :     // because 'snprintf' is a macro on Windows builds and
; 2010 :     // you obviously can't use the preprocessor to select
; 2011 :     // the arguments to be passed to a preprocessor macro.
; 2012 : 
; 2013 : #if defined( OPTION_SHARED_DEVICES )
; 2014 :   #define BUSYSHAREABLELINE_PATTERN     "%s    busy             %1.1X    shareable     %1.1X\n"
; 2015 :   #define BUSYSHAREABLELINE_VALUE       hdr, dev->busy, dev->shareable,
; 2016 : #else // !defined( OPTION_SHARED_DEVICES )
; 2017 :   #define BUSYSHAREABLELINE_PATTERN     "%s    busy             %1.1X\n"
; 2018 :   #define BUSYSHAREABLELINE_VALUE       hdr, dev->busy,
; 2019 : #endif // defined( OPTION_SHARED_DEVICES )
; 2020 : 
; 2021 :     len += idx_snprintf( len, buf, buflen,

  014ac	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014b4	48 83 c0 38	 add	 rax, 56			; 00000038H
  014b8	48 8b c8	 mov	 rcx, rax
  014bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_test_lock
  014c1	85 c0		 test	 eax, eax
  014c3	74 0d		 je	 SHORT $LN46@display_su
  014c5	c7 84 24 10 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv697[rsp], 1
  014d0	eb 0b		 jmp	 SHORT $LN47@display_su
$LN46@display_su:
  014d2	c7 84 24 10 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv697[rsp], 0
$LN47@display_su:
  014dd	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014e5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014eb	c1 e8 1b	 shr	 eax, 27
  014ee	83 e0 01	 and	 eax, 1
  014f1	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  014f9	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  014ff	c1 e9 14	 shr	 ecx, 20
  01502	83 e1 01	 and	 ecx, 1
  01505	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0150d	8b 92 f8 05 00
	00		 mov	 edx, DWORD PTR [rdx+1528]
  01513	c1 ea 1a	 shr	 edx, 26
  01516	83 e2 01	 and	 edx, 1
  01519	48 8b 9c 24 b0
	03 00 00	 mov	 rbx, QWORD PTR dev$[rsp]
  01521	8b 9b f8 05 00
	00		 mov	 ebx, DWORD PTR [rbx+1528]
  01527	c1 eb 09	 shr	 ebx, 9
  0152a	83 e3 01	 and	 ebx, 1
  0152d	48 8b bc 24 b0
	03 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  01535	8b bf f8 05 00
	00		 mov	 edi, DWORD PTR [rdi+1528]
  0153b	c1 ef 19	 shr	 edi, 25
  0153e	83 e7 01	 and	 edi, 1
  01541	48 8b b4 24 b0
	03 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  01549	8b b6 f8 05 00
	00		 mov	 esi, DWORD PTR [rsi+1528]
  0154f	c1 ee 08	 shr	 esi, 8
  01552	83 e6 01	 and	 esi, 1
  01555	48 8b ac 24 b0
	03 00 00	 mov	 rbp, QWORD PTR dev$[rsp]
  0155d	8b ad f8 05 00
	00		 mov	 ebp, DWORD PTR [rbp+1528]
  01563	c1 ed 18	 shr	 ebp, 24
  01566	83 e5 01	 and	 ebp, 1
  01569	4c 8b 84 24 b0
	03 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  01571	45 8b 80 f8 05
	00 00		 mov	 r8d, DWORD PTR [r8+1528]
  01578	41 c1 e8 06	 shr	 r8d, 6
  0157c	41 83 e0 03	 and	 r8d, 3
  01580	4c 8b 8c 24 b0
	03 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01588	45 8b 89 f8 05
	00 00		 mov	 r9d, DWORD PTR [r9+1528]
  0158f	41 c1 e9 17	 shr	 r9d, 23
  01593	41 83 e1 01	 and	 r9d, 1
  01597	4c 8b 94 24 b0
	03 00 00	 mov	 r10, QWORD PTR dev$[rsp]
  0159f	45 8b 92 f8 05
	00 00		 mov	 r10d, DWORD PTR [r10+1528]
  015a6	41 c1 ea 05	 shr	 r10d, 5
  015aa	41 83 e2 01	 and	 r10d, 1
  015ae	4c 8b 9c 24 b0
	03 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  015b6	45 8b 9b f8 05
	00 00		 mov	 r11d, DWORD PTR [r11+1528]
  015bd	41 c1 eb 16	 shr	 r11d, 22
  015c1	41 83 e3 01	 and	 r11d, 1
  015c5	4c 8b b4 24 b0
	03 00 00	 mov	 r14, QWORD PTR dev$[rsp]
  015cd	45 8b b6 f8 05
	00 00		 mov	 r14d, DWORD PTR [r14+1528]
  015d4	41 c1 ee 04	 shr	 r14d, 4
  015d8	41 83 e6 01	 and	 r14d, 1
  015dc	4c 8b bc 24 b0
	03 00 00	 mov	 r15, QWORD PTR dev$[rsp]
  015e4	45 8b bf f8 05
	00 00		 mov	 r15d, DWORD PTR [r15+1528]
  015eb	41 c1 ef 15	 shr	 r15d, 21
  015ef	41 83 e7 01	 and	 r15d, 1
  015f3	4c 8b a4 24 b0
	03 00 00	 mov	 r12, QWORD PTR dev$[rsp]
  015fb	45 8b a4 24 f8
	05 00 00	 mov	 r12d, DWORD PTR [r12+1528]
  01603	41 c1 ec 03	 shr	 r12d, 3
  01607	41 83 e4 01	 and	 r12d, 1
  0160b	4c 8b ac 24 b0
	03 00 00	 mov	 r13, QWORD PTR dev$[rsp]
  01613	45 8b ad f8 05
	00 00		 mov	 r13d, DWORD PTR [r13+1528]
  0161a	41 c1 ed 13	 shr	 r13d, 19
  0161e	41 83 e5 01	 and	 r13d, 1
  01622	44 89 ac 24 b8
	02 00 00	 mov	 DWORD PTR tv766[rsp], r13d
  0162a	4c 63 ac 24 c0
	03 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  01632	4c 89 ac 24 58
	03 00 00	 mov	 QWORD PTR tv771[rsp], r13
  0163a	44 8b ac 24 10
	02 00 00	 mov	 r13d, DWORD PTR tv697[rsp]
  01642	44 89 ac 24 e8
	00 00 00	 mov	 DWORD PTR [rsp+232], r13d
  0164a	89 84 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], eax
  01651	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01659	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rax
  01661	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  01668	89 94 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], edx
  0166f	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01677	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rax
  0167f	89 9c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ebx
  01686	89 bc 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], edi
  0168d	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01695	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rax
  0169d	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], esi
  016a4	89 ac 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ebp
  016ab	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  016b3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  016bb	44 89 84 24 88
	00 00 00	 mov	 DWORD PTR [rsp+136], r8d
  016c3	44 89 8c 24 80
	00 00 00	 mov	 DWORD PTR [rsp+128], r9d
  016cb	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  016d3	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  016d8	44 89 54 24 70	 mov	 DWORD PTR [rsp+112], r10d
  016dd	44 89 5c 24 68	 mov	 DWORD PTR [rsp+104], r11d
  016e2	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  016ea	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  016ef	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016f7	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  016fd	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  01701	44 89 74 24 50	 mov	 DWORD PTR [rsp+80], r14d
  01706	44 89 7c 24 48	 mov	 DWORD PTR [rsp+72], r15d
  0170b	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01713	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  01718	44 89 64 24 38	 mov	 DWORD PTR [rsp+56], r12d
  0171d	8b 84 24 b8 02
	00 00		 mov	 eax, DWORD PTR tv766[rsp]
  01724	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01728	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  01730	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01735	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0173d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01742	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195282
  01749	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR tv771[rsp]
  01751	4c 8b c0	 mov	 r8, rax
  01754	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0175c	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  01763	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01769	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  01770	03 c8		 add	 ecx, eax
  01772	8b c1		 mov	 eax, ecx
  01774	89 84 24 04 02
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 2022 :         "%s  DEVBLK Status\n"
; 2023 :         BUSYSHAREABLELINE_PATTERN
; 2024 :         "%s    suspended        %1.1X    console       %1.1X    rlen3270 %5d\n"
; 2025 :         "%s    pending          %1.1X    connected     %1.1X\n"
; 2026 :         "%s    pcipending       %1.1X    readpending   %1.1X\n"
; 2027 :         "%s    attnpending      %1.1X    connecting    %1.1X\n"
; 2028 :         "%s    startpending     %1.1X    localhost     %1.1X\n"
; 2029 :         "%s    resumesuspended  %1.1X    reserved      %1.1X\n"
; 2030 :         "%s    tschpending      %1.1X    locked        %1.1X\n",
; 2031 :         hdr,
; 2032 :         BUSYSHAREABLELINE_VALUE
; 2033 :         hdr, dev->suspended,          dev->console,     dev->rlen3270,
; 2034 :         hdr, dev->pending,            dev->connected,
; 2035 :         hdr, dev->pcipending,         dev->readpending,
; 2036 :         hdr, dev->attnpending,        dev->connecting,
; 2037 :         hdr, dev->startpending,       dev->localhost,
; 2038 :         hdr, dev->resumesuspended,    dev->reserved,
; 2039 :         hdr, dev->tschpending,        test_lock(&dev->lock) ? 1 : 0);
; 2040 : 
; 2041 :     return(len);

  0177b	8b 84 24 04 02
	00 00		 mov	 eax, DWORD PTR len$[rsp]

; 2042 : 
; 2043 : } /* end function display_subchannel */

  01782	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  01789	41 5f		 pop	 r15
  0178b	41 5e		 pop	 r14
  0178d	41 5d		 pop	 r13
  0178f	41 5c		 pop	 r12
  01791	5f		 pop	 rdi
  01792	5e		 pop	 rsi
  01793	5d		 pop	 rbp
  01794	5b		 pop	 rbx
  01795	c3		 ret	 0
display_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 64
ars$ = 80
__$ArrayPad$ = 144
regs$ = 176
buf$ = 184
buflen$ = 192
hdr$ = 200
display_aregs PROC

; 1775 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1776 :     int i;
; 1777 :     U32 ars[16];
; 1778 : 
; 1779 :     for(i=0;i<16;i++)

  0002d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00035	eb 0a		 jmp	 SHORT $LN4@display_ar
$LN2@display_ar:
  00037	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0003b	ff c0		 inc	 eax
  0003d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@display_ar:
  00041	83 7c 24 40 10	 cmp	 DWORD PTR i$[rsp], 16
  00046	7d 1f		 jge	 SHORT $LN3@display_ar

; 1780 :     {
; 1781 :         ars[i]=regs->AR(i);

  00048	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00052	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005a	8b 84 82 00 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+768]
  00061	89 44 8c 50	 mov	 DWORD PTR ars$[rsp+rcx*4], eax

; 1782 :     }

  00065	eb d0		 jmp	 SHORT $LN2@display_ar
$LN3@display_ar:

; 1783 :     return(display_regs32("AR",regs->cpuad,ars,sysblk.cpus,buf,buflen,hdr));

  00067	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00074	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0007b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	44 8b 88 04 01
	00 00		 mov	 r9d, DWORD PTR [rax+260]
  0009a	4c 8d 44 24 50	 lea	 r8, QWORD PTR ars$[rsp]
  0009f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	0f b7 90 3c 08
	00 00		 movzx	 edx, WORD PTR [rax+2108]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195164
  000b5	e8 00 00 00 00	 call	 display_regs32

; 1784 : 
; 1785 : } /* end function display_aregs */

  000ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c2	48 33 cc	 xor	 rcx, rsp
  000c5	e8 00 00 00 00	 call	 __security_check_cookie
  000ca	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  000d1	c3		 ret	 0
display_aregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 64
crs$ = 80
gcrs$ = 144
__$ArrayPad$ = 272
regs$ = 304
buf$ = 312
buflen$ = 320
hdr$ = 328
display_cregs PROC

; 1740 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1741 :     int i;
; 1742 :     U32 crs[16];
; 1743 : #if defined(_900)
; 1744 :     U64 gcrs[16];
; 1745 : #endif
; 1746 : 
; 1747 : #if defined(_900)
; 1748 :     if(regs->arch_mode != ARCH_900_IDX)

  0002d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00035	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00039	0f 84 9a 00 00
	00		 je	 $LN8@display_cr

; 1749 :     {
; 1750 : #endif
; 1751 :         for(i=0;i<16;i++)

  0003f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00047	eb 0a		 jmp	 SHORT $LN4@display_cr
$LN2@display_cr:
  00049	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0004d	ff c0		 inc	 eax
  0004f	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@display_cr:
  00053	83 7c 24 40 10	 cmp	 DWORD PTR i$[rsp], 16
  00058	7d 22		 jge	 SHORT $LN3@display_cr

; 1752 :         {
; 1753 :             crs[i]=regs->CR_L(i);

  0005a	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0005e	ff c0		 inc	 eax
  00060	48 98		 cdqe
  00062	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00067	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0006f	8b 84 c2 00 06
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+1536]
  00076	89 44 8c 50	 mov	 DWORD PTR crs$[rsp+rcx*4], eax

; 1754 :         }

  0007a	eb cd		 jmp	 SHORT $LN2@display_cr
$LN3@display_cr:

; 1755 :         return(display_regs32("CR",regs->cpuad,crs,sysblk.cpus,buf,buflen,hdr));

  0007c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00084	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00089	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00090	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00094	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0009c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a8	44 8b 88 04 01
	00 00		 mov	 r9d, DWORD PTR [rax+260]
  000af	4c 8d 44 24 50	 lea	 r8, QWORD PTR crs$[rsp]
  000b4	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b7 90 3c 08
	00 00		 movzx	 edx, WORD PTR [rax+2108]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195148
  000ca	e8 00 00 00 00	 call	 display_regs32
  000cf	e9 9d 00 00 00	 jmp	 $LN1@display_cr

; 1756 : #if defined(_900)
; 1757 :     }

  000d4	e9 98 00 00 00	 jmp	 $LN9@display_cr
$LN8@display_cr:

; 1758 :     else
; 1759 :     {
; 1760 :         for(i=0;i<16;i++)

  000d9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e1	eb 0a		 jmp	 SHORT $LN7@display_cr
$LN5@display_cr:
  000e3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000e7	ff c0		 inc	 eax
  000e9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@display_cr:
  000ed	83 7c 24 40 10	 cmp	 DWORD PTR i$[rsp], 16
  000f2	7d 27		 jge	 SHORT $LN6@display_cr

; 1761 :         {
; 1762 :             gcrs[i]=regs->CR_G(i);

  000f4	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	48 98		 cdqe
  000fc	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00101	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00109	48 8b 84 c2 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+1536]
  00111	48 89 84 cc 90
	00 00 00	 mov	 QWORD PTR gcrs$[rsp+rcx*8], rax

; 1763 :         }

  00119	eb c8		 jmp	 SHORT $LN5@display_cr
$LN6@display_cr:

; 1764 :         return(display_regs64("C",regs->cpuad,gcrs,sysblk.cpus,buf,buflen,hdr));

  0011b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00123	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00128	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0012f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00133	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00147	44 8b 88 04 01
	00 00		 mov	 r9d, DWORD PTR [rax+260]
  0014e	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR gcrs$[rsp]
  00156	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	0f b7 90 3c 08
	00 00		 movzx	 edx, WORD PTR [rax+2108]
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195149
  0016c	e8 00 00 00 00	 call	 display_regs64
$LN9@display_cr:
$LN1@display_cr:

; 1765 :     }
; 1766 : #endif
; 1767 : 
; 1768 : } /* end function display_cregs */

  00171	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00179	48 33 cc	 xor	 rcx, rsp
  0017c	e8 00 00 00 00	 call	 __security_check_cookie
  00181	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00188	c3		 ret	 0
display_cregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
x$1 = 416
i$2 = 424
tv94 = 428
tv204 = 432
tv208 = 436
tv212 = 440
tv275 = 448
tv278 = 456
tv282 = 464
tv285 = 472
tv289 = 480
tv292 = 488
tv296 = 496
tv299 = 504
tv303 = 512
tv306 = 520
tv310 = 528
tv313 = 536
tv317 = 544
tv320 = 552
tv324 = 560
tv327 = 568
tv331 = 576
tv334 = 584
cpustr$ = 592
vrstr$ = 624
__$ArrayPad$ = 1680
regs$ = 1776
buf$ = 1784
buflen$ = 1792
hdr$ = 1800
display_vregs PROC

; 1834 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 55		 push	 r13
  0001c	41 56		 push	 r14
  0001e	41 57		 push	 r15
  00020	48 81 ec a8 06
	00 00		 sub	 rsp, 1704		; 000006a8H
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002e	48 33 c4	 xor	 rax, rsp
  00031	48 89 84 24 90
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1835 :     char cpustr[32] = "";

  00039	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG195200
  00040	88 84 24 50 02
	00 00		 mov	 BYTE PTR cpustr$[rsp], al
  00047	48 8d 84 24 51
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp+1]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 1f 00 00 00	 mov	 ecx, 31
  00059	f3 aa		 rep stosb

; 1836 :     char vrstr[32][33] = { "" };

  0005b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG195202
  00062	88 84 24 70 02
	00 00		 mov	 BYTE PTR vrstr$[rsp], al
  00069	48 8d 84 24 71
	02 00 00	 lea	 rax, QWORD PTR vrstr$[rsp+1]
  00071	48 8b f8	 mov	 rdi, rax
  00074	33 c0		 xor	 eax, eax
  00076	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007b	f3 aa		 rep stosb
  0007d	48 8d 84 24 91
	02 00 00	 lea	 rax, QWORD PTR vrstr$[rsp+33]
  00085	48 8b f8	 mov	 rdi, rax
  00088	33 c0		 xor	 eax, eax
  0008a	b9 ff 03 00 00	 mov	 ecx, 1023		; 000003ffH
  0008f	f3 aa		 rep stosb

; 1837 : 
; 1838 :     if (sysblk.cpus > 1)

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  0009f	7e 6e		 jle	 SHORT $LN5@display_vr

; 1839 :         MSGBUF(cpustr, "%s%s%02X: ", hdr, PTYPSTR(regs->cpuad), regs->cpuad);

  000a1	48 8b 84 24 f0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000b0	89 84 24 ac 01
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  000b7	48 8b 8c 24 f0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000c6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000cd	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000db	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  000e2	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	4c 8b 8c 24 08
	07 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195205
  000fa	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000ff	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR cpustr$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0010d	eb 22		 jmp	 SHORT $LN6@display_vr
$LN5@display_vr:

; 1840 :     else
; 1841 :         MSGBUF(cpustr, "%s", hdr);

  0010f	4c 8b 8c 24 08
	07 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195206
  0011e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00123	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR cpustr$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN6@display_vr:

; 1842 :     
; 1843 :     for (int i = 0; i < 32; i++) {

  00131	c7 84 24 a8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$2[rsp], 0
  0013c	eb 10		 jmp	 SHORT $LN4@display_vr
$LN2@display_vr:
  0013e	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR i$2[rsp]
  00145	ff c0		 inc	 eax
  00147	89 84 24 a8 01
	00 00		 mov	 DWORD PTR i$2[rsp], eax
$LN4@display_vr:
  0014e	83 bc 24 a8 01
	00 00 20	 cmp	 DWORD PTR i$2[rsp], 32	; 00000020H
  00156	0f 8d 61 02 00
	00		 jge	 $LN3@display_vr

; 1844 :         uint8_t *x = regs->vr[i];

  0015c	48 63 84 24 a8
	01 00 00	 movsxd	 rax, DWORD PTR i$2[rsp]
  00164	48 6b c0 10	 imul	 rax, rax, 16
  00168	48 8b 8c 24 f0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8d 84 01 c4
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax+964]
  00178	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR x$1[rsp], rax

; 1845 :         MSGBUF(vrstr[i], "VR%02d=%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", i,

  00180	b8 01 00 00 00	 mov	 eax, 1
  00185	48 6b c0 0f	 imul	 rax, rax, 15
  00189	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR x$1[rsp]
  00191	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00195	b9 01 00 00 00	 mov	 ecx, 1
  0019a	48 6b c9 0e	 imul	 rcx, rcx, 14
  0019e	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR x$1[rsp]
  001a6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001aa	ba 01 00 00 00	 mov	 edx, 1
  001af	48 6b d2 0d	 imul	 rdx, rdx, 13
  001b3	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR x$1[rsp]
  001bb	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  001bf	bf 01 00 00 00	 mov	 edi, 1
  001c4	48 6b ff 0c	 imul	 rdi, rdi, 12
  001c8	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR x$1[rsp]
  001d0	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  001d5	41 b8 01 00 00
	00		 mov	 r8d, 1
  001db	4d 6b c0 0b	 imul	 r8, r8, 11
  001df	4c 8b 8c 24 a0
	01 00 00	 mov	 r9, QWORD PTR x$1[rsp]
  001e7	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  001ec	41 b9 01 00 00
	00		 mov	 r9d, 1
  001f2	4d 6b c9 0a	 imul	 r9, r9, 10
  001f6	4c 8b 94 24 a0
	01 00 00	 mov	 r10, QWORD PTR x$1[rsp]
  001fe	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00203	41 ba 01 00 00
	00		 mov	 r10d, 1
  00209	4d 6b d2 09	 imul	 r10, r10, 9
  0020d	4c 8b 9c 24 a0
	01 00 00	 mov	 r11, QWORD PTR x$1[rsp]
  00215	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  0021a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00220	4d 6b db 08	 imul	 r11, r11, 8
  00224	48 8b 9c 24 a0
	01 00 00	 mov	 rbx, QWORD PTR x$1[rsp]
  0022c	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00231	41 bb 01 00 00
	00		 mov	 r11d, 1
  00237	4d 6b db 07	 imul	 r11, r11, 7
  0023b	48 8b b4 24 a0
	01 00 00	 mov	 rsi, QWORD PTR x$1[rsp]
  00243	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00248	41 bb 01 00 00
	00		 mov	 r11d, 1
  0024e	4d 6b db 07	 imul	 r11, r11, 7
  00252	48 8b ac 24 a0
	01 00 00	 mov	 rbp, QWORD PTR x$1[rsp]
  0025a	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  0025f	41 bb 01 00 00
	00		 mov	 r11d, 1
  00265	4d 6b db 06	 imul	 r11, r11, 6
  00269	4c 8b b4 24 a0
	01 00 00	 mov	 r14, QWORD PTR x$1[rsp]
  00271	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  00276	41 be 01 00 00
	00		 mov	 r14d, 1
  0027c	4d 6b f6 05	 imul	 r14, r14, 5
  00280	4c 8b bc 24 a0
	01 00 00	 mov	 r15, QWORD PTR x$1[rsp]
  00288	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  0028d	41 bf 01 00 00
	00		 mov	 r15d, 1
  00293	4d 6b ff 04	 imul	 r15, r15, 4
  00297	4c 8b a4 24 a0
	01 00 00	 mov	 r12, QWORD PTR x$1[rsp]
  0029f	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  002a4	41 bc 01 00 00
	00		 mov	 r12d, 1
  002aa	4d 6b e4 03	 imul	 r12, r12, 3
  002ae	4c 8b ac 24 a0
	01 00 00	 mov	 r13, QWORD PTR x$1[rsp]
  002b6	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002bb	44 89 a4 24 b0
	01 00 00	 mov	 DWORD PTR tv204[rsp], r12d
  002c3	41 bd 01 00 00
	00		 mov	 r13d, 1
  002c9	4d 6b ed 02	 imul	 r13, r13, 2
  002cd	4c 8b a4 24 a0
	01 00 00	 mov	 r12, QWORD PTR x$1[rsp]
  002d5	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002da	44 89 a4 24 b4
	01 00 00	 mov	 DWORD PTR tv208[rsp], r12d
  002e2	41 bd 01 00 00
	00		 mov	 r13d, 1
  002e8	4d 6b ed 01	 imul	 r13, r13, 1
  002ec	4c 8b a4 24 a0
	01 00 00	 mov	 r12, QWORD PTR x$1[rsp]
  002f4	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  002f9	44 89 a4 24 b8
	01 00 00	 mov	 DWORD PTR tv212[rsp], r12d
  00301	41 bd 01 00 00
	00		 mov	 r13d, 1
  00307	4d 6b ed 00	 imul	 r13, r13, 0
  0030b	4c 8b a4 24 a0
	01 00 00	 mov	 r12, QWORD PTR x$1[rsp]
  00313	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  00318	4c 63 ac 24 a8
	01 00 00	 movsxd	 r13, DWORD PTR i$2[rsp]
  00320	4d 6b ed 21	 imul	 r13, r13, 33		; 00000021H
  00324	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  0032c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  00333	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  0033a	89 94 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], edx
  00341	89 bc 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], edi
  00348	44 89 84 24 80
	00 00 00	 mov	 DWORD PTR [rsp+128], r8d
  00350	44 89 4c 24 78	 mov	 DWORD PTR [rsp+120], r9d
  00355	44 89 54 24 70	 mov	 DWORD PTR [rsp+112], r10d
  0035a	89 5c 24 68	 mov	 DWORD PTR [rsp+104], ebx
  0035e	89 74 24 60	 mov	 DWORD PTR [rsp+96], esi
  00362	89 6c 24 58	 mov	 DWORD PTR [rsp+88], ebp
  00366	44 89 5c 24 50	 mov	 DWORD PTR [rsp+80], r11d
  0036b	44 89 74 24 48	 mov	 DWORD PTR [rsp+72], r14d
  00370	44 89 7c 24 40	 mov	 DWORD PTR [rsp+64], r15d
  00375	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv204[rsp]
  0037c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00380	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  00387	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0038b	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR tv212[rsp]
  00392	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00396	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0039b	44 8b 8c 24 a8
	01 00 00	 mov	 r9d, DWORD PTR i$2[rsp]
  003a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195207
  003aa	ba 21 00 00 00	 mov	 edx, 33			; 00000021H
  003af	49 8b cd	 mov	 rcx, r13
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1846 :             x[0], x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]);
; 1847 :     }

  003b8	e9 81 fd ff ff	 jmp	 $LN2@display_vr
$LN3@display_vr:

; 1848 : 
; 1849 :     return(snprintf(buf, buflen,

  003bd	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
  003c2	48 6b c0 1f	 imul	 rax, rax, 31
  003c6	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR vrstr$[rsp+rax]
  003ce	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  003d3	48 6b c9 1e	 imul	 rcx, rcx, 30
  003d7	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR vrstr$[rsp+rcx]
  003df	ba 21 00 00 00	 mov	 edx, 33			; 00000021H
  003e4	48 6b d2 1d	 imul	 rdx, rdx, 29
  003e8	48 8d 94 14 70
	02 00 00	 lea	 rdx, QWORD PTR vrstr$[rsp+rdx]
  003f0	bb 21 00 00 00	 mov	 ebx, 33			; 00000021H
  003f5	48 6b db 1c	 imul	 rbx, rbx, 28
  003f9	48 8d 9c 1c 70
	02 00 00	 lea	 rbx, QWORD PTR vrstr$[rsp+rbx]
  00401	bf 21 00 00 00	 mov	 edi, 33			; 00000021H
  00406	48 6b ff 1b	 imul	 rdi, rdi, 27
  0040a	48 8d bc 3c 70
	02 00 00	 lea	 rdi, QWORD PTR vrstr$[rsp+rdi]
  00412	be 21 00 00 00	 mov	 esi, 33			; 00000021H
  00417	48 6b f6 1a	 imul	 rsi, rsi, 26
  0041b	48 8d b4 34 70
	02 00 00	 lea	 rsi, QWORD PTR vrstr$[rsp+rsi]
  00423	bd 21 00 00 00	 mov	 ebp, 33			; 00000021H
  00428	48 6b ed 19	 imul	 rbp, rbp, 25
  0042c	48 8d ac 2c 70
	02 00 00	 lea	 rbp, QWORD PTR vrstr$[rsp+rbp]
  00434	41 b8 21 00 00
	00		 mov	 r8d, 33			; 00000021H
  0043a	4d 6b c0 18	 imul	 r8, r8, 24
  0043e	4e 8d 84 04 70
	02 00 00	 lea	 r8, QWORD PTR vrstr$[rsp+r8]
  00446	41 b9 21 00 00
	00		 mov	 r9d, 33			; 00000021H
  0044c	4d 6b c9 17	 imul	 r9, r9, 23
  00450	4e 8d 8c 0c 70
	02 00 00	 lea	 r9, QWORD PTR vrstr$[rsp+r9]
  00458	41 ba 21 00 00
	00		 mov	 r10d, 33		; 00000021H
  0045e	4d 6b d2 16	 imul	 r10, r10, 22
  00462	4e 8d 94 14 70
	02 00 00	 lea	 r10, QWORD PTR vrstr$[rsp+r10]
  0046a	41 bb 21 00 00
	00		 mov	 r11d, 33		; 00000021H
  00470	4d 6b db 15	 imul	 r11, r11, 21
  00474	4e 8d 9c 1c 70
	02 00 00	 lea	 r11, QWORD PTR vrstr$[rsp+r11]
  0047c	41 be 21 00 00
	00		 mov	 r14d, 33		; 00000021H
  00482	4d 6b f6 14	 imul	 r14, r14, 20
  00486	4e 8d b4 34 70
	02 00 00	 lea	 r14, QWORD PTR vrstr$[rsp+r14]
  0048e	41 bf 21 00 00
	00		 mov	 r15d, 33		; 00000021H
  00494	4d 6b ff 13	 imul	 r15, r15, 19
  00498	4e 8d bc 3c 70
	02 00 00	 lea	 r15, QWORD PTR vrstr$[rsp+r15]
  004a0	41 bc 21 00 00
	00		 mov	 r12d, 33		; 00000021H
  004a6	4d 6b e4 12	 imul	 r12, r12, 18
  004aa	4e 8d a4 24 70
	02 00 00	 lea	 r12, QWORD PTR vrstr$[rsp+r12]
  004b2	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  004b8	4d 6b ed 11	 imul	 r13, r13, 17
  004bc	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  004c4	4c 89 ac 24 c0
	01 00 00	 mov	 QWORD PTR tv275[rsp], r13
  004cc	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  004d2	4d 6b ed 10	 imul	 r13, r13, 16
  004d6	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  004de	4c 89 ac 24 c8
	01 00 00	 mov	 QWORD PTR tv278[rsp], r13
  004e6	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  004ec	4d 6b ed 0f	 imul	 r13, r13, 15
  004f0	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  004f8	4c 89 ac 24 d0
	01 00 00	 mov	 QWORD PTR tv282[rsp], r13
  00500	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00506	4d 6b ed 0e	 imul	 r13, r13, 14
  0050a	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00512	4c 89 ac 24 d8
	01 00 00	 mov	 QWORD PTR tv285[rsp], r13
  0051a	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00520	4d 6b ed 0d	 imul	 r13, r13, 13
  00524	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  0052c	4c 89 ac 24 e0
	01 00 00	 mov	 QWORD PTR tv289[rsp], r13
  00534	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  0053a	4d 6b ed 0c	 imul	 r13, r13, 12
  0053e	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00546	4c 89 ac 24 e8
	01 00 00	 mov	 QWORD PTR tv292[rsp], r13
  0054e	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00554	4d 6b ed 0b	 imul	 r13, r13, 11
  00558	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00560	4c 89 ac 24 f0
	01 00 00	 mov	 QWORD PTR tv296[rsp], r13
  00568	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  0056e	4d 6b ed 0a	 imul	 r13, r13, 10
  00572	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  0057a	4c 89 ac 24 f8
	01 00 00	 mov	 QWORD PTR tv299[rsp], r13
  00582	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00588	4d 6b ed 09	 imul	 r13, r13, 9
  0058c	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00594	4c 89 ac 24 00
	02 00 00	 mov	 QWORD PTR tv303[rsp], r13
  0059c	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  005a2	4d 6b ed 08	 imul	 r13, r13, 8
  005a6	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  005ae	4c 89 ac 24 08
	02 00 00	 mov	 QWORD PTR tv306[rsp], r13
  005b6	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  005bc	4d 6b ed 07	 imul	 r13, r13, 7
  005c0	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  005c8	4c 89 ac 24 10
	02 00 00	 mov	 QWORD PTR tv310[rsp], r13
  005d0	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  005d6	4d 6b ed 06	 imul	 r13, r13, 6
  005da	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  005e2	4c 89 ac 24 18
	02 00 00	 mov	 QWORD PTR tv313[rsp], r13
  005ea	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  005f0	4d 6b ed 05	 imul	 r13, r13, 5
  005f4	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  005fc	4c 89 ac 24 20
	02 00 00	 mov	 QWORD PTR tv317[rsp], r13
  00604	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  0060a	4d 6b ed 04	 imul	 r13, r13, 4
  0060e	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00616	4c 89 ac 24 28
	02 00 00	 mov	 QWORD PTR tv320[rsp], r13
  0061e	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00624	4d 6b ed 03	 imul	 r13, r13, 3
  00628	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00630	4c 89 ac 24 30
	02 00 00	 mov	 QWORD PTR tv324[rsp], r13
  00638	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  0063e	4d 6b ed 02	 imul	 r13, r13, 2
  00642	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  0064a	4c 89 ac 24 38
	02 00 00	 mov	 QWORD PTR tv327[rsp], r13
  00652	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00658	4d 6b ed 01	 imul	 r13, r13, 1
  0065c	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  00664	4c 89 ac 24 40
	02 00 00	 mov	 QWORD PTR tv331[rsp], r13
  0066c	41 bd 21 00 00
	00		 mov	 r13d, 33		; 00000021H
  00672	4d 6b ed 00	 imul	 r13, r13, 0
  00676	4e 8d ac 2c 70
	02 00 00	 lea	 r13, QWORD PTR vrstr$[rsp+r13]
  0067e	4c 89 ac 24 48
	02 00 00	 mov	 QWORD PTR tv334[rsp], r13
  00686	4c 63 ac 24 00
	07 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  0068e	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR [rsp+400], rax
  00696	48 89 8c 24 88
	01 00 00	 mov	 QWORD PTR [rsp+392], rcx
  0069e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  006a6	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR [rsp+384], rax
  006ae	48 89 94 24 78
	01 00 00	 mov	 QWORD PTR [rsp+376], rdx
  006b6	48 89 9c 24 70
	01 00 00	 mov	 QWORD PTR [rsp+368], rbx
  006be	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  006c6	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR [rsp+360], rax
  006ce	48 89 bc 24 60
	01 00 00	 mov	 QWORD PTR [rsp+352], rdi
  006d6	48 89 b4 24 58
	01 00 00	 mov	 QWORD PTR [rsp+344], rsi
  006de	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  006e6	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR [rsp+336], rax
  006ee	48 89 ac 24 48
	01 00 00	 mov	 QWORD PTR [rsp+328], rbp
  006f6	4c 89 84 24 40
	01 00 00	 mov	 QWORD PTR [rsp+320], r8
  006fe	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00706	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR [rsp+312], rax
  0070e	4c 89 8c 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], r9
  00716	4c 89 94 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], r10
  0071e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00726	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rax
  0072e	4c 89 9c 24 18
	01 00 00	 mov	 QWORD PTR [rsp+280], r11
  00736	4c 89 b4 24 10
	01 00 00	 mov	 QWORD PTR [rsp+272], r14
  0073e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00746	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rax
  0074e	4c 89 bc 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], r15
  00756	4c 89 a4 24 f8
	00 00 00	 mov	 QWORD PTR [rsp+248], r12
  0075e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00766	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], rax
  0076e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR tv275[rsp]
  00776	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rax
  0077e	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR tv278[rsp]
  00786	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rax
  0078e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00796	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rax
  0079e	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR tv282[rsp]
  007a6	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rax
  007ae	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR tv285[rsp]
  007b6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rax
  007be	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  007c6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rax
  007ce	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR tv289[rsp]
  007d6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rax
  007de	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR tv292[rsp]
  007e6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rax
  007ee	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  007f6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rax
  007fe	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR tv296[rsp]
  00806	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rax
  0080e	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR tv299[rsp]
  00816	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rax
  0081e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00826	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  0082e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR tv303[rsp]
  00836	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  0083e	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR tv306[rsp]
  00846	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  0084e	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00856	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0085b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR tv310[rsp]
  00863	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00868	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR tv313[rsp]
  00870	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00875	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  0087d	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00882	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  0088a	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0088f	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR tv320[rsp]
  00897	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0089c	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  008a4	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  008a9	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR tv324[rsp]
  008b1	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  008b6	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR tv327[rsp]
  008be	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  008c3	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  008cb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  008d0	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR tv331[rsp]
  008d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008dd	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR tv334[rsp]
  008e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ea	4c 8d 8c 24 50
	02 00 00	 lea	 r9, QWORD PTR cpustr$[rsp]
  008f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195208
  008f9	49 8b d5	 mov	 rdx, r13
  008fc	48 8b 8c 24 f8
	06 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00904	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1850 :         "%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n"
; 1851 :         "%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n%s%s %s\n"
; 1852 :         , cpustr, vrstr[0], vrstr[1], cpustr, vrstr[2], vrstr[3], cpustr, vrstr[4], vrstr[5]
; 1853 :         , cpustr, vrstr[6], vrstr[7], cpustr, vrstr[8], vrstr[9], cpustr, vrstr[10], vrstr[11]
; 1854 :         , cpustr, vrstr[12], vrstr[13], cpustr, vrstr[14], vrstr[15], cpustr, vrstr[16], vrstr[17]
; 1855 :         , cpustr, vrstr[18], vrstr[19], cpustr, vrstr[20], vrstr[21], cpustr, vrstr[22], vrstr[23]
; 1856 :         , cpustr, vrstr[24], vrstr[25], cpustr, vrstr[26], vrstr[27], cpustr, vrstr[28], vrstr[29]
; 1857 :         , cpustr, vrstr[30], vrstr[31]
; 1858 :     ));
; 1859 : 
; 1860 : } /* end function display_vregs */

  0090a	48 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00912	48 33 cc	 xor	 rcx, rsp
  00915	e8 00 00 00 00	 call	 __security_check_cookie
  0091a	48 81 c4 a8 06
	00 00		 add	 rsp, 1704		; 000006a8H
  00921	41 5f		 pop	 r15
  00923	41 5e		 pop	 r14
  00925	41 5d		 pop	 r13
  00927	41 5c		 pop	 r12
  00929	5f		 pop	 rdi
  0092a	5e		 pop	 rsi
  0092b	5d		 pop	 rbp
  0092c	5b		 pop	 rbx
  0092d	c3		 ret	 0
display_vregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tv79 = 352
tv195 = 360
tv199 = 368
tv204 = 376
tv208 = 384
tv212 = 392
tv216 = 400
tv221 = 408
tv225 = 416
tv229 = 424
tv233 = 432
tv238 = 440
tv242 = 448
tv246 = 456
tv250 = 464
tv255 = 472
tv259 = 480
tv263 = 488
tv267 = 496
tv272 = 504
tv311 = 512
cpustr$ = 520
__$ArrayPad$ = 552
regs$ = 640
buf$ = 648
buflen$ = 656
hdr$ = 664
display_fregs PROC

; 1792 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 55		 push	 r13
  0001c	41 56		 push	 r14
  0001e	41 57		 push	 r15
  00020	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002e	48 33 c4	 xor	 rax, rsp
  00031	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1793 : char cpustr[32] = "";

  00039	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG195175
  00040	88 84 24 08 02
	00 00		 mov	 BYTE PTR cpustr$[rsp], al
  00047	48 8d 84 24 09
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp+1]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 1f 00 00 00	 mov	 ecx, 31
  00059	f3 aa		 rep stosb

; 1794 : 
; 1795 :     if(sysblk.cpus>1)

  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00062	83 b8 04 01 00
	00 01		 cmp	 DWORD PTR [rax+260], 1
  00069	7e 6e		 jle	 SHORT $LN2@display_fr

; 1796 :         MSGBUF(cpustr, "%s%s%02X: ", hdr, PTYPSTR(regs->cpuad), regs->cpuad);

  0006b	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0007a	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00081	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00090	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00097	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000a5	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  000ac	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  000b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b5	4c 8b 8c 24 98
	02 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195178
  000c4	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000c9	48 8d 8c 24 08
	02 00 00	 lea	 rcx, QWORD PTR cpustr$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  000d7	eb 22		 jmp	 SHORT $LN3@display_fr
$LN2@display_fr:

; 1797 :     else
; 1798 :         MSGBUF(cpustr, "%s", hdr);

  000d9	4c 8b 8c 24 98
	02 00 00	 mov	 r9, QWORD PTR hdr$[rsp]
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195179
  000e8	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000ed	48 8d 8c 24 08
	02 00 00	 lea	 rcx, QWORD PTR cpustr$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN3@display_fr:

; 1799 : 
; 1800 :     if(regs->CR(0) & CR0_AFP)

  000fb	b8 08 00 00 00	 mov	 eax, 8
  00100	48 6b c0 01	 imul	 rax, rax, 1
  00104	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00114	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011a	48 85 c0	 test	 rax, rax
  0011d	0f 84 af 05 00
	00		 je	 $LN4@display_fr

; 1801 :         return(snprintf(buf,buflen,

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	48 6b c0 1f	 imul	 rax, rax, 31
  0012c	b9 04 00 00 00	 mov	 ecx, 4
  00131	48 6b c9 1e	 imul	 rcx, rcx, 30
  00135	ba 04 00 00 00	 mov	 edx, 4
  0013a	48 6b d2 1b	 imul	 rdx, rdx, 27
  0013e	bf 04 00 00 00	 mov	 edi, 4
  00143	48 6b ff 1a	 imul	 rdi, rdi, 26
  00147	41 b8 04 00 00
	00		 mov	 r8d, 4
  0014d	4d 6b c0 1d	 imul	 r8, r8, 29
  00151	41 b9 04 00 00
	00		 mov	 r9d, 4
  00157	4d 6b c9 1c	 imul	 r9, r9, 28
  0015b	41 ba 04 00 00
	00		 mov	 r10d, 4
  00161	4d 6b d2 19	 imul	 r10, r10, 25
  00165	41 bb 04 00 00
	00		 mov	 r11d, 4
  0016b	4d 6b db 18	 imul	 r11, r11, 24
  0016f	bb 04 00 00 00	 mov	 ebx, 4
  00174	48 6b db 17	 imul	 rbx, rbx, 23
  00178	be 04 00 00 00	 mov	 esi, 4
  0017d	48 6b f6 16	 imul	 rsi, rsi, 22
  00181	bd 04 00 00 00	 mov	 ebp, 4
  00186	48 6b ed 13	 imul	 rbp, rbp, 19
  0018a	41 be 04 00 00
	00		 mov	 r14d, 4
  00190	4d 6b f6 12	 imul	 r14, r14, 18
  00194	41 bf 04 00 00
	00		 mov	 r15d, 4
  0019a	4d 6b ff 15	 imul	 r15, r15, 21
  0019e	41 bc 04 00 00
	00		 mov	 r12d, 4
  001a4	4d 6b e4 14	 imul	 r12, r12, 20
  001a8	41 bd 04 00 00
	00		 mov	 r13d, 4
  001ae	4d 6b ed 11	 imul	 r13, r13, 17
  001b2	4c 89 ac 24 68
	01 00 00	 mov	 QWORD PTR tv195[rsp], r13
  001ba	41 bd 04 00 00
	00		 mov	 r13d, 4
  001c0	4d 6b ed 10	 imul	 r13, r13, 16
  001c4	4c 89 ac 24 70
	01 00 00	 mov	 QWORD PTR tv199[rsp], r13
  001cc	41 bd 04 00 00
	00		 mov	 r13d, 4
  001d2	4d 6b ed 0f	 imul	 r13, r13, 15
  001d6	4c 89 ac 24 78
	01 00 00	 mov	 QWORD PTR tv204[rsp], r13
  001de	41 bd 04 00 00
	00		 mov	 r13d, 4
  001e4	4d 6b ed 0e	 imul	 r13, r13, 14
  001e8	4c 89 ac 24 80
	01 00 00	 mov	 QWORD PTR tv208[rsp], r13
  001f0	41 bd 04 00 00
	00		 mov	 r13d, 4
  001f6	4d 6b ed 0b	 imul	 r13, r13, 11
  001fa	4c 89 ac 24 88
	01 00 00	 mov	 QWORD PTR tv212[rsp], r13
  00202	41 bd 04 00 00
	00		 mov	 r13d, 4
  00208	4d 6b ed 0a	 imul	 r13, r13, 10
  0020c	4c 89 ac 24 90
	01 00 00	 mov	 QWORD PTR tv216[rsp], r13
  00214	41 bd 04 00 00
	00		 mov	 r13d, 4
  0021a	4d 6b ed 0d	 imul	 r13, r13, 13
  0021e	4c 89 ac 24 98
	01 00 00	 mov	 QWORD PTR tv221[rsp], r13
  00226	41 bd 04 00 00
	00		 mov	 r13d, 4
  0022c	4d 6b ed 0c	 imul	 r13, r13, 12
  00230	4c 89 ac 24 a0
	01 00 00	 mov	 QWORD PTR tv225[rsp], r13
  00238	41 bd 04 00 00
	00		 mov	 r13d, 4
  0023e	4d 6b ed 09	 imul	 r13, r13, 9
  00242	4c 89 ac 24 a8
	01 00 00	 mov	 QWORD PTR tv229[rsp], r13
  0024a	41 bd 04 00 00
	00		 mov	 r13d, 4
  00250	4d 6b ed 08	 imul	 r13, r13, 8
  00254	4c 89 ac 24 b0
	01 00 00	 mov	 QWORD PTR tv233[rsp], r13
  0025c	41 bd 04 00 00
	00		 mov	 r13d, 4
  00262	4d 6b ed 07	 imul	 r13, r13, 7
  00266	4c 89 ac 24 b8
	01 00 00	 mov	 QWORD PTR tv238[rsp], r13
  0026e	41 bd 04 00 00
	00		 mov	 r13d, 4
  00274	4d 6b ed 06	 imul	 r13, r13, 6
  00278	4c 89 ac 24 c0
	01 00 00	 mov	 QWORD PTR tv242[rsp], r13
  00280	41 bd 04 00 00
	00		 mov	 r13d, 4
  00286	4d 6b ed 03	 imul	 r13, r13, 3
  0028a	4c 89 ac 24 c8
	01 00 00	 mov	 QWORD PTR tv246[rsp], r13
  00292	41 bd 04 00 00
	00		 mov	 r13d, 4
  00298	4d 6b ed 02	 imul	 r13, r13, 2
  0029c	4c 89 ac 24 d0
	01 00 00	 mov	 QWORD PTR tv250[rsp], r13
  002a4	41 bd 04 00 00
	00		 mov	 r13d, 4
  002aa	4d 6b ed 05	 imul	 r13, r13, 5
  002ae	4c 89 ac 24 d8
	01 00 00	 mov	 QWORD PTR tv255[rsp], r13
  002b6	41 bd 04 00 00
	00		 mov	 r13d, 4
  002bc	4d 6b ed 04	 imul	 r13, r13, 4
  002c0	4c 89 ac 24 e0
	01 00 00	 mov	 QWORD PTR tv259[rsp], r13
  002c8	41 bd 04 00 00
	00		 mov	 r13d, 4
  002ce	4d 6b ed 01	 imul	 r13, r13, 1
  002d2	4c 89 ac 24 e8
	01 00 00	 mov	 QWORD PTR tv263[rsp], r13
  002da	41 bd 04 00 00
	00		 mov	 r13d, 4
  002e0	4d 6b ed 00	 imul	 r13, r13, 0
  002e4	4c 89 ac 24 f0
	01 00 00	 mov	 QWORD PTR tv267[rsp], r13
  002ec	4c 63 ac 24 90
	02 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  002f4	4c 89 ac 24 f8
	01 00 00	 mov	 QWORD PTR tv272[rsp], r13
  002fc	4c 8b ac 24 80
	02 00 00	 mov	 r13, QWORD PTR regs$[rsp]
  00304	42 8b 84 28 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r13+832]
  0030c	89 84 24 50 01
	00 00		 mov	 DWORD PTR [rsp+336], eax
  00313	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031b	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00322	89 84 24 48 01
	00 00		 mov	 DWORD PTR [rsp+328], eax
  00329	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00331	8b 84 10 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rdx+832]
  00338	89 84 24 40 01
	00 00		 mov	 DWORD PTR [rsp+320], eax
  0033f	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00347	8b 84 38 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rdi+832]
  0034e	89 84 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], eax
  00355	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  0035d	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], rax
  00365	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	42 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r8+832]
  00375	89 84 24 28 01
	00 00		 mov	 DWORD PTR [rsp+296], eax
  0037c	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00384	42 8b 84 08 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r9+832]
  0038c	89 84 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], eax
  00393	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039b	42 8b 84 10 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r10+832]
  003a3	89 84 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], eax
  003aa	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b2	42 8b 84 18 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r11+832]
  003ba	89 84 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], eax
  003c1	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  003c9	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rax
  003d1	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d9	8b 84 18 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rbx+832]
  003e0	89 84 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], eax
  003e7	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ef	8b 84 30 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rsi+832]
  003f6	89 84 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], eax
  003fd	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00405	8b 84 28 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rbp+832]
  0040c	89 84 24 f0 00
	00 00		 mov	 DWORD PTR [rsp+240], eax
  00413	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041b	42 8b 84 30 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r14+832]
  00423	89 84 24 e8 00
	00 00		 mov	 DWORD PTR [rsp+232], eax
  0042a	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00432	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rax
  0043a	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00442	42 8b 84 38 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r15+832]
  0044a	89 84 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], eax
  00451	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00459	42 8b 84 20 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r12+832]
  00461	89 84 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], eax
  00468	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00470	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv195[rsp]
  00478	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0047f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], eax
  00486	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv199[rsp]
  00496	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0049d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], eax
  004a4	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  004ac	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rax
  004b4	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bc	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv204[rsp]
  004c4	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  004cb	89 84 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], eax
  004d2	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004da	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv208[rsp]
  004e2	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  004e9	89 84 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], eax
  004f0	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f8	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv212[rsp]
  00500	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00507	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  0050e	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00516	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  0051e	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00525	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  0052c	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00534	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  0053c	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00544	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv221[rsp]
  0054c	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00553	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  0055a	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00562	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  0056a	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00571	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  00578	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00580	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  00588	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0058f	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  00593	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv233[rsp]
  005a3	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  005aa	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  005ae	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  005b6	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  005bb	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c3	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv238[rsp]
  005cb	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  005d2	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  005d6	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005de	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv242[rsp]
  005e6	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  005ed	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  005f1	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f9	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv246[rsp]
  00601	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00608	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0060c	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00614	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv250[rsp]
  0061c	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00623	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00627	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  0062f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00634	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063c	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv255[rsp]
  00644	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0064b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0064f	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00657	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv259[rsp]
  0065f	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00666	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0066a	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00672	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR tv263[rsp]
  0067a	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  00681	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00685	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068d	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR tv267[rsp]
  00695	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0069c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  006a0	4c 8d 8c 24 08
	02 00 00	 lea	 r9, QWORD PTR cpustr$[rsp]
  006a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195182
  006af	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR tv272[rsp]
  006b7	48 8b d0	 mov	 rdx, rax
  006ba	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  006c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  006c8	e9 2d 01 00 00	 jmp	 $LN1@display_fr
  006cd	e9 28 01 00 00	 jmp	 $LN5@display_fr
$LN4@display_fr:

; 1802 :             "%sFPR0=%8.8X%8.8X FPR2=%8.8X%8.8X\n"
; 1803 :             "%sFPR1=%8.8X%8.8X FPR3=%8.8X%8.8X\n"
; 1804 :             "%sFPR4=%8.8X%8.8X FPR6=%8.8X%8.8X\n"
; 1805 :             "%sFPR5=%8.8X%8.8X FPR7=%8.8X%8.8X\n"
; 1806 :             "%sFPR8=%8.8X%8.8X FP10=%8.8X%8.8X\n"
; 1807 :             "%sFPR9=%8.8X%8.8X FP11=%8.8X%8.8X\n"
; 1808 :             "%sFP12=%8.8X%8.8X FP14=%8.8X%8.8X\n"
; 1809 :             "%sFP13=%8.8X%8.8X FP15=%8.8X%8.8X\n"
; 1810 :             ,cpustr, regs->fpr[0],  regs->fpr[1],  regs->fpr[4],  regs->fpr[5]
; 1811 :             ,cpustr, regs->fpr[2],  regs->fpr[3],  regs->fpr[6],  regs->fpr[7]
; 1812 :             ,cpustr, regs->fpr[8],  regs->fpr[9],  regs->fpr[12], regs->fpr[13]
; 1813 :             ,cpustr, regs->fpr[10], regs->fpr[11], regs->fpr[14], regs->fpr[15]
; 1814 :             ,cpustr, regs->fpr[16], regs->fpr[17], regs->fpr[20], regs->fpr[21]
; 1815 :             ,cpustr, regs->fpr[18], regs->fpr[19], regs->fpr[22], regs->fpr[23]
; 1816 :             ,cpustr, regs->fpr[24], regs->fpr[25], regs->fpr[28], regs->fpr[29]
; 1817 :             ,cpustr, regs->fpr[26], regs->fpr[27], regs->fpr[30], regs->fpr[31]
; 1818 :         ));
; 1819 :     else
; 1820 :         return(snprintf(buf,buflen,

  006d2	b8 04 00 00 00	 mov	 eax, 4
  006d7	48 6b c0 07	 imul	 rax, rax, 7
  006db	b9 04 00 00 00	 mov	 ecx, 4
  006e0	48 6b c9 06	 imul	 rcx, rcx, 6
  006e4	ba 04 00 00 00	 mov	 edx, 4
  006e9	48 6b d2 05	 imul	 rdx, rdx, 5
  006ed	bb 04 00 00 00	 mov	 ebx, 4
  006f2	48 6b db 04	 imul	 rbx, rbx, 4
  006f6	bf 04 00 00 00	 mov	 edi, 4
  006fb	48 6b ff 03	 imul	 rdi, rdi, 3
  006ff	be 04 00 00 00	 mov	 esi, 4
  00704	48 6b f6 02	 imul	 rsi, rsi, 2
  00708	bd 04 00 00 00	 mov	 ebp, 4
  0070d	48 6b ed 01	 imul	 rbp, rbp, 1
  00711	41 b8 04 00 00
	00		 mov	 r8d, 4
  00717	4d 6b c0 00	 imul	 r8, r8, 0
  0071b	4c 63 8c 24 90
	02 00 00	 movsxd	 r9, DWORD PTR buflen$[rsp]
  00723	4c 89 8c 24 00
	02 00 00	 mov	 QWORD PTR tv311[rsp], r9
  0072b	4c 8b 94 24 80
	02 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  00733	41 8b 84 02 40
	03 00 00	 mov	 eax, DWORD PTR [r10+rax+832]
  0073b	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0073f	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00747	8b 84 08 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rcx+832]
  0074e	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00752	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075a	8b 84 10 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rdx+832]
  00761	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00765	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076d	8b 84 18 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rbx+832]
  00774	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00778	48 8d 84 24 08
	02 00 00	 lea	 rax, QWORD PTR cpustr$[rsp]
  00780	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00785	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078d	8b 84 38 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rdi+832]
  00794	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00798	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a0	8b 84 30 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rsi+832]
  007a7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007ab	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b3	8b 84 28 40 03
	00 00		 mov	 eax, DWORD PTR [rax+rbp+832]
  007ba	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  007be	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c6	42 8b 84 00 40
	03 00 00	 mov	 eax, DWORD PTR [rax+r8+832]
  007ce	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007d2	4c 8d 8c 24 08
	02 00 00	 lea	 r9, QWORD PTR cpustr$[rsp]
  007da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195183
  007e1	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR tv311[rsp]
  007e9	48 8b d0	 mov	 rdx, rax
  007ec	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  007f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN5@display_fr:
$LN1@display_fr:

; 1821 :             "%sFPR0=%8.8X%8.8X FPR2=%8.8X%8.8X\n"
; 1822 :             "%sFPR4=%8.8X%8.8X FPR6=%8.8X%8.8X\n"
; 1823 :             ,cpustr, regs->fpr[0], regs->fpr[1], regs->fpr[2], regs->fpr[3]
; 1824 :             ,cpustr, regs->fpr[4], regs->fpr[5], regs->fpr[6], regs->fpr[7]
; 1825 :         ));
; 1826 : 
; 1827 : } /* end function display_fregs */

  007fa	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00802	48 33 cc	 xor	 rcx, rsp
  00805	e8 00 00 00 00	 call	 __security_check_cookie
  0080a	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  00811	41 5f		 pop	 r15
  00813	41 5e		 pop	 r14
  00815	41 5d		 pop	 r13
  00817	41 5c		 pop	 r12
  00819	5f		 pop	 rdi
  0081a	5e		 pop	 rsi
  0081b	5d		 pop	 rbp
  0081c	5b		 pop	 rbx
  0081d	c3		 ret	 0
display_fregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
i$ = 64
gprs$ = 80
ggprs$ = 144
__$ArrayPad$ = 272
regs$ = 304
buf$ = 312
buflen$ = 320
hdr$ = 328
display_gregs PROC

; 1705 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1706 :     int i;
; 1707 :     U32 gprs[16];
; 1708 : #if defined(_900)
; 1709 :     U64 ggprs[16];
; 1710 : #endif
; 1711 : 
; 1712 : #if defined(_900)
; 1713 :     if(regs->arch_mode != ARCH_900_IDX)

  0002d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00035	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00039	0f 84 97 00 00
	00		 je	 $LN8@display_gr

; 1714 :     {
; 1715 : #endif
; 1716 :         for(i=0;i<16;i++)

  0003f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00047	eb 0a		 jmp	 SHORT $LN4@display_gr
$LN2@display_gr:
  00049	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0004d	ff c0		 inc	 eax
  0004f	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@display_gr:
  00053	83 7c 24 40 10	 cmp	 DWORD PTR i$[rsp], 16
  00058	7d 1f		 jge	 SHORT $LN3@display_gr

; 1717 :         {
; 1718 :             gprs[i]=regs->GR_L(i);

  0005a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0005f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00064	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0006c	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00073	89 44 8c 50	 mov	 DWORD PTR gprs$[rsp+rcx*4], eax

; 1719 :         }

  00077	eb d0		 jmp	 SHORT $LN2@display_gr
$LN3@display_gr:

; 1720 :         return(display_regs32("GR",regs->cpuad,gprs,sysblk.cpus,buf,buflen,hdr));

  00079	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  00081	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00086	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0008d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00091	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a5	44 8b 88 04 01
	00 00		 mov	 r9d, DWORD PTR [rax+260]
  000ac	4c 8d 44 24 50	 lea	 r8, QWORD PTR gprs$[rsp]
  000b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b7 90 3c 08
	00 00		 movzx	 edx, WORD PTR [rax+2108]
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195126
  000c7	e8 00 00 00 00	 call	 display_regs32
  000cc	e9 9a 00 00 00	 jmp	 $LN1@display_gr

; 1721 : #if defined(_900)
; 1722 :     }

  000d1	e9 95 00 00 00	 jmp	 $LN9@display_gr
$LN8@display_gr:

; 1723 :     else
; 1724 :     {
; 1725 :         for(i=0;i<16;i++)

  000d6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000de	eb 0a		 jmp	 SHORT $LN7@display_gr
$LN5@display_gr:
  000e0	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@display_gr:
  000ea	83 7c 24 40 10	 cmp	 DWORD PTR i$[rsp], 16
  000ef	7d 24		 jge	 SHORT $LN6@display_gr

; 1726 :         {
; 1727 :             ggprs[i]=regs->GR_G(i);

  000f1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  000f6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  000fb	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00103	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0010b	48 89 84 cc 90
	00 00 00	 mov	 QWORD PTR ggprs$[rsp+rcx*8], rax

; 1728 :         }

  00113	eb cb		 jmp	 SHORT $LN5@display_gr
$LN6@display_gr:

; 1729 :         return(display_regs64("R",regs->cpuad,ggprs,sysblk.cpus,buf,buflen,hdr));

  00115	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0011d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00122	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00129	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00141	44 8b 88 04 01
	00 00		 mov	 r9d, DWORD PTR [rax+260]
  00148	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR ggprs$[rsp]
  00150	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	0f b7 90 3c 08
	00 00		 movzx	 edx, WORD PTR [rax+2108]
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195127
  00166	e8 00 00 00 00	 call	 display_regs64
$LN9@display_gr:
$LN1@display_gr:

; 1730 :     }
; 1731 : #endif
; 1732 : 
; 1733 : } /* end function display_gregs */

  0016b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00182	c3		 ret	 0
display_gregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
cpu$1 = 0
insttrace_all PROC

; 3176 : {

$LN9:
  00000	48 83 ec 18	 sub	 rsp, 24

; 3177 :     if (sysblk.insttrace)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	c1 e8 08	 shr	 eax, 8
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 66		 je	 SHORT $LN5@insttrace_

; 3178 :     {
; 3179 :         int  cpu;
; 3180 :         for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$1[rsp], 0
  00022	eb 08		 jmp	 SHORT $LN4@insttrace_
$LN2@insttrace_:
  00024	8b 04 24	 mov	 eax, DWORD PTR cpu$1[rsp]
  00027	ff c0		 inc	 eax
  00029	89 04 24	 mov	 DWORD PTR cpu$1[rsp], eax
$LN4@insttrace_:
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00033	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00039	39 04 24	 cmp	 DWORD PTR cpu$1[rsp], eax
  0003c	7d 3f		 jge	 SHORT $LN3@insttrace_

; 3181 :         {
; 3182 :             if (IS_CPU_ONLINE( cpu ))

  0003e	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$1[rsp]
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00049	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00052	74 27		 je	 SHORT $LN6@insttrace_

; 3183 :             {
; 3184 :                 if (!sysblk.regs[ cpu ]->insttrace)

  00054	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$1[rsp]
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00067	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0006d	c1 e8 0f	 shr	 eax, 15
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	75 04		 jne	 SHORT $LN7@insttrace_

; 3185 :                     return false;

  00077	32 c0		 xor	 al, al
  00079	eb 08		 jmp	 SHORT $LN1@insttrace_
$LN7@insttrace_:
$LN6@insttrace_:

; 3186 :             }
; 3187 :         }

  0007b	eb a7		 jmp	 SHORT $LN2@insttrace_
$LN3@insttrace_:

; 3188 :         return true;  /* insttrace is active on all CPUs */

  0007d	b0 01		 mov	 al, 1
  0007f	eb 02		 jmp	 SHORT $LN1@insttrace_
$LN5@insttrace_:

; 3189 :     }
; 3190 :     return false;     /* insttrace NOT active for at least one CPU */

  00081	32 c0		 xor	 al, al
$LN1@insttrace_:

; 3191 : }

  00083	48 83 c4 18	 add	 rsp, 24
  00087	c3		 ret	 0
insttrace_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
tid$1 = 48
do_shutdown PROC

; 1464 : {

$LN9:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1465 :     /* If an immediate shutdown has been triggered, then do so now! */
; 1466 :     if (sysblk.shutimmed)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	c1 e8 0d	 shr	 eax, 13
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN2@do_shutdow

; 1467 :     {
; 1468 :         do_shutdown_now();

  0001b	e8 00 00 00 00	 call	 do_shutdown_now

; 1469 :     }

  00020	eb 6a		 jmp	 SHORT $LN3@do_shutdow
$LN2@do_shutdow:

; 1470 :     else
; 1471 :     {
; 1472 :         /* If this was the second time we've been called, give up
; 1473 :            waiting for the guest to quiesce. This should cause the
; 1474 :            "wait_for_guest_to_quiesce" function the "do_shutdown_wait"
; 1475 :            thread called to immediately give up and return, thereby
; 1476 :            causing it to proceed on to performing a normal shutdown.
; 1477 : 
; 1478 :            Otherwise, if this is our first time here, signal the guest
; 1479 :            to quiesce itself and then create a worker thread to WAIT
; 1480 :            for it to finish quiescing itself before then continuing on
; 1481 :            with our own normal Hercules shutdown.
; 1482 :         */
; 1483 : 
; 1484 :         if (!is_guest_quiesced())             // (second request?)

  00022	e8 00 00 00 00	 call	 is_guest_quiesced
  00027	85 c0		 test	 eax, eax
  00029	75 07		 jne	 SHORT $LN4@do_shutdow

; 1485 :         {
; 1486 :             cancel_wait_for_guest_quiesce();  // (then stop waiting!)

  0002b	e8 00 00 00 00	 call	 cancel_wait_for_guest_quiesce

; 1487 :         }

  00030	eb 5a		 jmp	 SHORT $LN5@do_shutdow
$LN4@do_shutdow:

; 1488 :         else
; 1489 :         {
; 1490 :             TID tid;  // (work for create_thread)
; 1491 : 
; 1492 :             /* This is our first time here. If the guest supports
; 1493 :                the quiesce signal (SigQuiesce), then send the signal
; 1494 :                and then create a thread that waits for the guest to
; 1495 :                finish quiescing itself before then continuing with
; 1496 :                our own shutdown.
; 1497 :             */
; 1498 :             if (can_signal_quiesce() && signal_quiesce( 0,0 ) == 0)

  00032	e8 00 00 00 00	 call	 can_signal_quiesce
  00037	85 c0		 test	 eax, eax
  00039	74 4c		 je	 SHORT $LN6@do_shutdow
  0003b	33 d2		 xor	 edx, edx
  0003d	33 c9		 xor	 ecx, ecx
  0003f	e8 00 00 00 00	 call	 signal_quiesce
  00044	85 c0		 test	 eax, eax
  00046	75 3f		 jne	 SHORT $LN6@do_shutdow

; 1499 :             {
; 1500 :                 create_thread( &tid,

  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004f	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194951
  0005c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194952
  00068	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0006d	45 33 c9	 xor	 r9d, r9d
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:do_shutdown_wait
  00077	48 8b d0	 mov	 rdx, rax
  0007a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tid$1[rsp]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread

; 1501 :                                DETACHED, do_shutdown_wait,
; 1502 :                                NULL,    "do_shutdown_wait" );
; 1503 :             }

  00085	eb 05		 jmp	 SHORT $LN7@do_shutdow
$LN6@do_shutdow:

; 1504 :             else
; 1505 :             {
; 1506 :                 /* Otherwise the guest does not support the quiesce
; 1507 :                    signal, so just do a normal Hercules shutdown.
; 1508 :                 */
; 1509 :                 do_shutdown_now();

  00087	e8 00 00 00 00	 call	 do_shutdown_now
$LN7@do_shutdow:
$LN5@do_shutdow:
$LN3@do_shutdow:

; 1510 :             }
; 1511 :         }
; 1512 :     }
; 1513 : }

  0008c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00090	c3		 ret	 0
do_shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
rc$ = 32
pszNewCommandLine$ = 40
tv64 = 48
command$ = 80
herc_system PROC

; 3100 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3101 : #if HOW_TO_IMPLEMENT_SH_COMMAND == USE_ANSI_SYSTEM_API_FOR_SH_COMMAND
; 3102 : 
; 3103 :     return system(command);
; 3104 : 
; 3105 : #elif HOW_TO_IMPLEMENT_SH_COMMAND == USE_W32_POOR_MANS_FORK
; 3106 : 
; 3107 :   #define  SHELL_CMD_SHIM_PGM   "conspawn "
; 3108 : 
; 3109 :     int rc = (int)(strlen(SHELL_CMD_SHIM_PGM) + strlen(command) + 1);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195963
  00010	e8 00 00 00 00	 call	 strlen
  00015	48 89 44 24 30	 mov	 QWORD PTR tv64[rsp], rax
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR command$[rsp]
  0001f	e8 00 00 00 00	 call	 strlen
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv64[rsp]
  00029	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0002e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 3110 :     char* pszNewCommandLine = malloc( rc );

  00032	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00040	48 89 44 24 28	 mov	 QWORD PTR pszNewCommandLine$[rsp], rax

; 3111 :     strlcpy( pszNewCommandLine, SHELL_CMD_SHIM_PGM, rc );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  0004a	4c 8b c0	 mov	 r8, rax
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195964
  00054	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3112 :     strlcat( pszNewCommandLine, command,            rc );

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  00064	4c 8b c0	 mov	 r8, rax
  00067	48 8b 54 24 50	 mov	 rdx, QWORD PTR command$[rsp]
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3113 :     rc = w32_poor_mans_fork( pszNewCommandLine, NULL );

  00077	33 d2		 xor	 edx, edx
  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_poor_mans_fork
  00084	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 3114 :     free( pszNewCommandLine );

  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3115 :     return rc;

  00093	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 3116 : 
; 3117 : #elif HOW_TO_IMPLEMENT_SH_COMMAND == USE_FORK_API_FOR_SH_COMMAND
; 3118 : 
; 3119 : extern char **environ;
; 3120 : int pid, status;
; 3121 : 
; 3122 :     if (command == 0)
; 3123 :         return 1;
; 3124 : 
; 3125 :     pid = fork();
; 3126 : 
; 3127 :     if (pid == -1)
; 3128 :         return -1;
; 3129 : 
; 3130 :     if (pid == 0)
; 3131 :     {
; 3132 :         char *argv[4];
; 3133 : 
; 3134 :         /* Redirect stderr (screen) to hercules log task */
; 3135 :         dup2(STDOUT_FILENO, STDERR_FILENO);
; 3136 : 
; 3137 :         /* Drop ROOT authority (saved uid) */
; 3138 :         SETMODE(TERM);
; 3139 :         DROP_ALL_CAPS();
; 3140 : 
; 3141 :         argv[0] = "sh";
; 3142 :         argv[1] = "-c";
; 3143 :         argv[2] = command;
; 3144 :         argv[3] = 0;
; 3145 :         execve("/bin/sh", argv, environ);
; 3146 : 
; 3147 :         _exit(127);
; 3148 :     }
; 3149 : 
; 3150 :     do
; 3151 :     {
; 3152 :         if (waitpid(pid, &status, 0) == -1)
; 3153 :         {
; 3154 :             if (errno != EINTR)
; 3155 :                 return -1;
; 3156 :         } else
; 3157 :             return status;
; 3158 :     } while(1);
; 3159 : #else
; 3160 :   #error 'HOW_TO_IMPLEMENT_SH_COMMAND' not #defined correctly
; 3161 : #endif
; 3162 : } /* end function herc_system */

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
herc_system ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
s370_display_pgmint_inst PROC

; 1181 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1182 :     ARCH_DEP( display_inst_adj )( iregs, inst, true );

  0000e	41 b0 01	 mov	 r8b, 1
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 s370_display_inst_adj

; 1183 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
s370_display_pgmint_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hscmisc.c
_TEXT	SEGMENT
iregs$ = 48
inst$ = 56
s370_display_inst PROC

; 1173 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1174 :     ARCH_DEP( display_inst_adj )( iregs, inst, false );

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR inst$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iregs$[rsp]
  0001b	e8 00 00 00 00	 call	 s370_display_inst_adj

; 1175 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
s370_display_inst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
