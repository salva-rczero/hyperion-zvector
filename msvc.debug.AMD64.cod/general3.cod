; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_add_immediate_long_storage
PUBLIC	s370_add_immediate_storage
PUBLIC	s370_add_logical_with_signed_immediate
PUBLIC	s370_add_logical_with_signed_immediate_long
PUBLIC	s370_compare_and_branch_register
PUBLIC	s370_compare_and_branch_relative_register
PUBLIC	s370_compare_and_trap_register
PUBLIC	s370_compare_halfword_immediate_halfword_storage
PUBLIC	s370_compare_halfword_immediate_long_storage
PUBLIC	s370_compare_halfword_immediate_storage
PUBLIC	s370_compare_halfword_relative_long
PUBLIC	s370_compare_immediate_and_branch
PUBLIC	s370_compare_immediate_and_branch_relative
PUBLIC	s370_compare_immediate_and_trap
PUBLIC	s370_compare_logical_and_branch_register
PUBLIC	s370_compare_logical_and_branch_relative_register
PUBLIC	s370_compare_logical_and_trap_register
PUBLIC	s370_compare_logical_immediate_and_branch
PUBLIC	s370_compare_logical_immediate_and_branch_relative
PUBLIC	s370_compare_logical_immediate_and_trap_fullword
PUBLIC	s370_compare_logical_immediate_fullword_storage
PUBLIC	s370_compare_logical_immediate_halfword_storage
PUBLIC	s370_compare_logical_immediate_long_storage
PUBLIC	s370_compare_logical_relative_long
PUBLIC	s370_compare_logical_relative_long_halfword
PUBLIC	s370_compare_relative_long
PUBLIC	s370_load_halfword_relative_long
PUBLIC	s370_load_logical_halfword_relative_long
PUBLIC	s370_load_relative_long
PUBLIC	s370_move_fullword_from_halfword_immediate
PUBLIC	s370_move_halfword_from_halfword_immediate
PUBLIC	s370_move_long_from_halfword_immediate
PUBLIC	s370_multiply_halfword_y
PUBLIC	s370_multiply_single_immediate_fullword
PUBLIC	s370_multiply_y
PUBLIC	s370_prefetch_data
PUBLIC	s370_prefetch_data_relative_long
PUBLIC	s370_store_halfword_relative_long
PUBLIC	s370_store_relative_long
PUBLIC	s370_store_relative_long_long
PUBLIC	s370_add_distinct_register
PUBLIC	s370_add_distinct_halfword_immediate
PUBLIC	s370_add_logical_distinct_register
PUBLIC	s370_add_logical_distinct_signed_halfword_immediate
PUBLIC	s370_and_distinct_register
PUBLIC	s370_exclusive_or_distinct_register
PUBLIC	s370_or_distinct_register
PUBLIC	s370_shift_right_single_distinct
PUBLIC	s370_shift_left_single_distinct
PUBLIC	s370_shift_right_single_logical_distinct
PUBLIC	s370_shift_left_single_logical_distinct
PUBLIC	s370_subtract_distinct_register
PUBLIC	s370_subtract_logical_distinct_register
PUBLIC	s370_add_high_high_high_register
PUBLIC	s370_add_high_high_low_register
PUBLIC	s370_add_high_immediate
PUBLIC	s370_add_logical_high_high_high_register
PUBLIC	s370_add_logical_high_high_low_register
PUBLIC	s370_add_logical_with_signed_immediate_high
PUBLIC	s370_add_logical_with_signed_immediate_high_n
PUBLIC	s370_branch_relative_on_count_high
PUBLIC	s370_compare_high_high_register
PUBLIC	s370_compare_high_low_register
PUBLIC	s370_compare_high_fullword
PUBLIC	s370_compare_high_immediate
PUBLIC	s370_compare_logical_high_high_register
PUBLIC	s370_compare_logical_high_low_register
PUBLIC	s370_compare_logical_high_fullword
PUBLIC	s370_compare_logical_high_immediate
PUBLIC	s370_load_byte_high
PUBLIC	s370_load_fullword_high
PUBLIC	s370_load_halfword_high
PUBLIC	s370_load_logical_character_high
PUBLIC	s370_load_logical_halfword_high
PUBLIC	s370_rotate_then_insert_selected_bits_high_long_reg
PUBLIC	s370_rotate_then_insert_selected_bits_low_long_reg
PUBLIC	s370_store_character_high
PUBLIC	s370_store_fullword_high
PUBLIC	s370_store_halfword_high
PUBLIC	s370_subtract_high_high_high_register
PUBLIC	s370_subtract_high_high_low_register
PUBLIC	s370_subtract_logical_high_high_high_register
PUBLIC	s370_subtract_logical_high_high_low_register
PUBLIC	s370_load_and_add
PUBLIC	s370_load_and_add_logical
PUBLIC	s370_load_and_and
PUBLIC	s370_load_and_exclusive_or
PUBLIC	s370_load_and_or
PUBLIC	s370_load_pair_disjoint
PUBLIC	s370_load_and_add_long
PUBLIC	s370_load_and_add_logical_long
PUBLIC	s370_load_and_and_long
PUBLIC	s370_load_and_exclusive_or_long
PUBLIC	s370_load_and_or_long
PUBLIC	s370_load_pair_disjoint_long
PUBLIC	s370_load_on_condition_register
PUBLIC	s370_load_on_condition
PUBLIC	s370_store_on_condition
PUBLIC	s370_population_count
PUBLIC	cmpxchg8_x86
PUBLIC	cmpxchg4_x86
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	add_logical
PUBLIC	sub_logical
PUBLIC	add_signed
PUBLIC	sub_signed
PUBLIC	mul_signed
PUBLIC	mul_unsigned_long
PUBLIC	mul_signed_long
PUBLIC	add_logical_long
PUBLIC	sub_logical_long
PUBLIC	add_signed_long
PUBLIC	sub_signed_long
PUBLIC	s370_maddr_l
PUBLIC	s370_vstore2_full
PUBLIC	s370_vstore4_full
PUBLIC	s370_vstore8_full
PUBLIC	s370_vfetch2_full
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vfetch8_full
PUBLIC	s370_vstoreb
PUBLIC	s370_vstore2
PUBLIC	s370_vstore4
PUBLIC	s370_vstore8
PUBLIC	s370_vfetchb
PUBLIC	s370_vfetch2
PUBLIC	s370_vfetch4
PUBLIC	s370_vfetch8
PUBLIC	s370_perform_interlocked_storage_immediate
PUBLIC	s370_perform_interlocked_long_storage_immediate
PUBLIC	s370_rotate_then_xxx_selected_bits_long_reg
PUBLIC	s370_load_and_perform_interlocked_access
PUBLIC	s370_load_and_perform_interlocked_access_long
PUBLIC	z900_add_immediate_long_storage
PUBLIC	z900_add_immediate_storage
PUBLIC	z900_add_logical_with_signed_immediate
PUBLIC	z900_add_logical_with_signed_immediate_long
PUBLIC	z900_compare_and_branch_register
PUBLIC	z900_compare_and_branch_long_register
PUBLIC	z900_compare_and_branch_relative_register
PUBLIC	z900_compare_and_branch_relative_long_register
PUBLIC	z900_compare_and_trap_long_register
PUBLIC	z900_compare_and_trap_register
PUBLIC	z900_compare_halfword_immediate_halfword_storage
PUBLIC	z900_compare_halfword_immediate_long_storage
PUBLIC	z900_compare_halfword_immediate_storage
PUBLIC	z900_compare_halfword_long
PUBLIC	z900_compare_halfword_relative_long
PUBLIC	z900_compare_halfword_relative_long_long
PUBLIC	z900_compare_immediate_and_branch
PUBLIC	z900_compare_immediate_and_branch_long
PUBLIC	z900_compare_immediate_and_branch_relative
PUBLIC	z900_compare_immediate_and_branch_relative_long
PUBLIC	z900_compare_immediate_and_trap
PUBLIC	z900_compare_immediate_and_trap_long
PUBLIC	z900_compare_logical_and_branch_long_register
PUBLIC	z900_compare_logical_and_branch_register
PUBLIC	z900_compare_logical_and_branch_relative_long_register
PUBLIC	z900_compare_logical_and_branch_relative_register
PUBLIC	z900_compare_logical_and_trap_long_register
PUBLIC	z900_compare_logical_and_trap_register
PUBLIC	z900_compare_logical_immediate_and_branch
PUBLIC	z900_compare_logical_immediate_and_branch_long
PUBLIC	z900_compare_logical_immediate_and_branch_relative
PUBLIC	z900_compare_logical_immediate_and_branch_relative_long
PUBLIC	z900_compare_logical_immediate_and_trap_fullword
PUBLIC	z900_compare_logical_immediate_and_trap_long
PUBLIC	z900_compare_logical_immediate_fullword_storage
PUBLIC	z900_compare_logical_immediate_halfword_storage
PUBLIC	z900_compare_logical_immediate_long_storage
PUBLIC	z900_compare_logical_relative_long
PUBLIC	z900_compare_logical_relative_long_halfword
PUBLIC	z900_compare_logical_relative_long_long
PUBLIC	z900_compare_logical_relative_long_long_fullword
PUBLIC	z900_compare_logical_relative_long_long_halfword
PUBLIC	z900_compare_relative_long
PUBLIC	z900_compare_relative_long_long
PUBLIC	z900_compare_relative_long_long_fullword
PUBLIC	z900_extract_cpu_attribute
PUBLIC	z900_load_address_extended_y
PUBLIC	z900_load_and_test_long_fullword
PUBLIC	z900_load_halfword_relative_long
PUBLIC	z900_load_halfword_relative_long_long
PUBLIC	z900_load_logical_halfword_relative_long
PUBLIC	z900_load_logical_halfword_relative_long_long
PUBLIC	z900_load_logical_relative_long_long_fullword
PUBLIC	z900_load_relative_long
PUBLIC	z900_load_relative_long_long
PUBLIC	z900_load_relative_long_long_fullword
PUBLIC	z900_move_fullword_from_halfword_immediate
PUBLIC	z900_move_halfword_from_halfword_immediate
PUBLIC	z900_move_long_from_halfword_immediate
PUBLIC	z900_multiply_halfword_y
PUBLIC	z900_multiply_single_immediate_fullword
PUBLIC	z900_multiply_single_immediate_long_fullword
PUBLIC	z900_multiply_y
PUBLIC	z900_prefetch_data
PUBLIC	z900_prefetch_data_relative_long
PUBLIC	z900_rotate_then_and_selected_bits_long_reg
PUBLIC	z900_rotate_then_exclusive_or_selected_bits_long_reg
PUBLIC	z900_rotate_then_insert_selected_bits_long_reg
PUBLIC	z900_rotate_then_or_selected_bits_long_reg
PUBLIC	z900_store_halfword_relative_long
PUBLIC	z900_store_relative_long
PUBLIC	z900_store_relative_long_long
PUBLIC	z900_add_distinct_register
PUBLIC	z900_add_distinct_long_register
PUBLIC	z900_add_distinct_halfword_immediate
PUBLIC	z900_add_distinct_long_halfword_immediate
PUBLIC	z900_add_logical_distinct_register
PUBLIC	z900_add_logical_distinct_long_register
PUBLIC	z900_add_logical_distinct_signed_halfword_immediate
PUBLIC	z900_add_logical_distinct_long_signed_halfword_immediate
PUBLIC	z900_and_distinct_register
PUBLIC	z900_and_distinct_long_register
PUBLIC	z900_exclusive_or_distinct_register
PUBLIC	z900_exclusive_or_distinct_long_register
PUBLIC	z900_or_distinct_register
PUBLIC	z900_or_distinct_long_register
PUBLIC	z900_shift_right_single_distinct
PUBLIC	z900_shift_left_single_distinct
PUBLIC	z900_shift_right_single_logical_distinct
PUBLIC	z900_shift_left_single_logical_distinct
PUBLIC	z900_subtract_distinct_register
PUBLIC	z900_subtract_distinct_long_register
PUBLIC	z900_subtract_logical_distinct_register
PUBLIC	z900_subtract_logical_distinct_long_register
PUBLIC	z900_add_high_high_high_register
PUBLIC	z900_add_high_high_low_register
PUBLIC	z900_add_high_immediate
PUBLIC	z900_add_logical_high_high_high_register
PUBLIC	z900_add_logical_high_high_low_register
PUBLIC	z900_add_logical_with_signed_immediate_high
PUBLIC	z900_add_logical_with_signed_immediate_high_n
PUBLIC	z900_branch_relative_on_count_high
PUBLIC	z900_compare_high_high_register
PUBLIC	z900_compare_high_low_register
PUBLIC	z900_compare_high_fullword
PUBLIC	z900_compare_high_immediate
PUBLIC	z900_compare_logical_high_high_register
PUBLIC	z900_compare_logical_high_low_register
PUBLIC	z900_compare_logical_high_fullword
PUBLIC	z900_compare_logical_high_immediate
PUBLIC	z900_load_byte_high
PUBLIC	z900_load_fullword_high
PUBLIC	z900_load_halfword_high
PUBLIC	z900_load_logical_character_high
PUBLIC	z900_load_logical_halfword_high
PUBLIC	z900_rotate_then_insert_selected_bits_high_long_reg
PUBLIC	z900_rotate_then_insert_selected_bits_low_long_reg
PUBLIC	z900_store_character_high
PUBLIC	z900_store_fullword_high
PUBLIC	z900_store_halfword_high
PUBLIC	z900_subtract_high_high_high_register
PUBLIC	z900_subtract_high_high_low_register
PUBLIC	z900_subtract_logical_high_high_high_register
PUBLIC	z900_subtract_logical_high_high_low_register
PUBLIC	z900_load_and_add
PUBLIC	z900_load_and_add_logical
PUBLIC	z900_load_and_and
PUBLIC	z900_load_and_exclusive_or
PUBLIC	z900_load_and_or
PUBLIC	z900_load_pair_disjoint
PUBLIC	z900_load_and_add_long
PUBLIC	z900_load_and_add_logical_long
PUBLIC	z900_load_and_and_long
PUBLIC	z900_load_and_exclusive_or_long
PUBLIC	z900_load_and_or_long
PUBLIC	z900_load_pair_disjoint_long
PUBLIC	z900_load_on_condition_register
PUBLIC	z900_load_on_condition_long_register
PUBLIC	z900_load_on_condition
PUBLIC	z900_load_on_condition_long
PUBLIC	z900_store_on_condition
PUBLIC	z900_store_on_condition_long
PUBLIC	z900_population_count
PUBLIC	z900_branch_prediction_preload
PUBLIC	z900_branch_prediction_relative_preload
PUBLIC	z900_next_instruction_access_intent
PUBLIC	z900_load_and_trap
PUBLIC	z900_load_long_and_trap
PUBLIC	z900_load_fullword_high_and_trap
PUBLIC	z900_load_logical_long_fullword_and_trap
PUBLIC	z900_load_logical_long_thirtyone_and_trap
PUBLIC	z900_compare_logical_and_trap
PUBLIC	z900_compare_logical_and_trap_long
PUBLIC	z900_rotate_then_insert_selected_bits_long_reg_n
PUBLIC	z900_load_halfword_high_immediate_on_condition
PUBLIC	z900_load_halfword_immediate_on_condition
PUBLIC	z900_load_halfword_immediate_on_condition_grande
PUBLIC	z900_load_high_on_condition
PUBLIC	z900_load_high_on_condition_register
PUBLIC	z900_store_high_on_condition
PUBLIC	z900_load_and_zero_rightmost_byte_grande
PUBLIC	z900_load_logical_and_zero_rightmost_byte
PUBLIC	z900_load_and_zero_rightmost_byte
PUBLIC	z900_multiply_long_register
PUBLIC	z900_multiply_long
PUBLIC	z900_multiply_long_halfword
PUBLIC	z900_select_register
PUBLIC	z900_select_register_long
PUBLIC	z900_select_fullword_high_register
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore2_full
PUBLIC	z900_vstore4_full
PUBLIC	z900_vstore8_full
PUBLIC	z900_vfetch2_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vstoreb
PUBLIC	z900_vstore2
PUBLIC	z900_vstore4
PUBLIC	z900_vstore8
PUBLIC	z900_vfetchb
PUBLIC	z900_vfetch2
PUBLIC	z900_vfetch4
PUBLIC	z900_vfetch8
PUBLIC	z900_perform_interlocked_storage_immediate
PUBLIC	z900_perform_interlocked_long_storage_immediate
PUBLIC	z900_rotate_then_xxx_selected_bits_long_reg
PUBLIC	z900_load_and_perform_interlocked_access
PUBLIC	z900_load_and_perform_interlocked_access_long
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	s370_SuccessfulBranch:PROC
EXTRN	s370_SuccessfulRelativeBranch:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	z900_SuccessfulBranch:PROC
EXTRN	z900_SuccessfulRelativeBranch:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_add_immediate_long_storage DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$s370_add_immediate_long_storage
$pdata$s370_add_immediate_storage DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$s370_add_immediate_storage
$pdata$s370_add_logical_with_signed_immediate DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_add_logical_with_signed_immediate
$pdata$s370_add_logical_with_signed_immediate_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_add_logical_with_signed_immediate_long
$pdata$s370_compare_and_branch_register DD imagerel $LN14
	DD	imagerel $LN14+396
	DD	imagerel $unwind$s370_compare_and_branch_register
$pdata$s370_compare_and_branch_relative_register DD imagerel $LN13
	DD	imagerel $LN13+349
	DD	imagerel $unwind$s370_compare_and_branch_relative_register
$pdata$s370_compare_and_trap_register DD imagerel $LN12
	DD	imagerel $LN12+304
	DD	imagerel $unwind$s370_compare_and_trap_register
$pdata$s370_compare_halfword_immediate_halfword_storage DD imagerel $LN12
	DD	imagerel $LN12+298
	DD	imagerel $unwind$s370_compare_halfword_immediate_halfword_storage
$pdata$s370_compare_halfword_immediate_long_storage DD imagerel $LN12
	DD	imagerel $LN12+296
	DD	imagerel $unwind$s370_compare_halfword_immediate_long_storage
$pdata$s370_compare_halfword_immediate_storage DD imagerel $LN12
	DD	imagerel $LN12+291
	DD	imagerel $unwind$s370_compare_halfword_immediate_storage
$pdata$s370_compare_halfword_relative_long DD imagerel $LN19
	DD	imagerel $LN19+430
	DD	imagerel $unwind$s370_compare_halfword_relative_long
$pdata$s370_compare_immediate_and_branch DD imagerel $LN14
	DD	imagerel $LN14+364
	DD	imagerel $unwind$s370_compare_immediate_and_branch
$pdata$s370_compare_immediate_and_branch_relative DD imagerel $LN13
	DD	imagerel $LN13+322
	DD	imagerel $unwind$s370_compare_immediate_and_branch_relative
$pdata$s370_compare_immediate_and_trap DD imagerel $LN12
	DD	imagerel $LN12+302
	DD	imagerel $unwind$s370_compare_immediate_and_trap
$pdata$s370_compare_logical_and_branch_register DD imagerel $LN14
	DD	imagerel $LN14+396
	DD	imagerel $unwind$s370_compare_logical_and_branch_register
$pdata$s370_compare_logical_and_branch_relative_register DD imagerel $LN13
	DD	imagerel $LN13+349
	DD	imagerel $unwind$s370_compare_logical_and_branch_relative_register
$pdata$s370_compare_logical_and_trap_register DD imagerel $LN12
	DD	imagerel $LN12+304
	DD	imagerel $unwind$s370_compare_logical_and_trap_register
$pdata$s370_compare_logical_immediate_and_branch DD imagerel $LN14
	DD	imagerel $LN14+364
	DD	imagerel $unwind$s370_compare_logical_immediate_and_branch
$pdata$s370_compare_logical_immediate_and_branch_relative DD imagerel $LN13
	DD	imagerel $LN13+322
	DD	imagerel $unwind$s370_compare_logical_immediate_and_branch_relative
$pdata$s370_compare_logical_immediate_and_trap_fullword DD imagerel $LN12
	DD	imagerel $LN12+302
	DD	imagerel $unwind$s370_compare_logical_immediate_and_trap_fullword
$pdata$s370_compare_logical_immediate_fullword_storage DD imagerel $LN12
	DD	imagerel $LN12+291
	DD	imagerel $unwind$s370_compare_logical_immediate_fullword_storage
$pdata$s370_compare_logical_immediate_halfword_storage DD imagerel $LN12
	DD	imagerel $LN12+298
	DD	imagerel $unwind$s370_compare_logical_immediate_halfword_storage
$pdata$s370_compare_logical_immediate_long_storage DD imagerel $LN12
	DD	imagerel $LN12+294
	DD	imagerel $unwind$s370_compare_logical_immediate_long_storage
$pdata$s370_compare_logical_relative_long DD imagerel $LN20
	DD	imagerel $LN20+459
	DD	imagerel $unwind$s370_compare_logical_relative_long
$pdata$s370_compare_logical_relative_long_halfword DD imagerel $LN19
	DD	imagerel $LN19+430
	DD	imagerel $unwind$s370_compare_logical_relative_long_halfword
$pdata$s370_compare_relative_long DD imagerel $LN20
	DD	imagerel $LN20+459
	DD	imagerel $unwind$s370_compare_relative_long
$pdata$s370_load_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+355
	DD	imagerel $unwind$s370_load_halfword_relative_long
$pdata$s370_load_logical_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+355
	DD	imagerel $unwind$s370_load_logical_halfword_relative_long
$pdata$s370_load_relative_long DD imagerel $LN16
	DD	imagerel $LN16+385
	DD	imagerel $unwind$s370_load_relative_long
$pdata$s370_move_fullword_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+230
	DD	imagerel $unwind$s370_move_fullword_from_halfword_immediate
$pdata$s370_move_halfword_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+222
	DD	imagerel $unwind$s370_move_halfword_from_halfword_immediate
$pdata$s370_move_long_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+233
	DD	imagerel $unwind$s370_move_long_from_halfword_immediate
$pdata$s370_multiply_halfword_y DD imagerel $LN16
	DD	imagerel $LN16+441
	DD	imagerel $unwind$s370_multiply_halfword_y
$pdata$s370_multiply_single_immediate_fullword DD imagerel $LN7
	DD	imagerel $LN7+197
	DD	imagerel $unwind$s370_multiply_single_immediate_fullword
$pdata$s370_multiply_y DD imagerel $LN17
	DD	imagerel $LN17+505
	DD	imagerel $unwind$s370_multiply_y
$pdata$s370_prefetch_data DD imagerel $LN16
	DD	imagerel $LN16+364
	DD	imagerel $unwind$s370_prefetch_data
$pdata$s370_prefetch_data_relative_long DD imagerel $LN15
	DD	imagerel $LN15+309
	DD	imagerel $unwind$s370_prefetch_data_relative_long
$pdata$s370_store_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+347
	DD	imagerel $unwind$s370_store_halfword_relative_long
$pdata$s370_store_relative_long DD imagerel $LN16
	DD	imagerel $LN16+378
	DD	imagerel $unwind$s370_store_relative_long
$pdata$s370_store_relative_long_long DD imagerel $LN16
	DD	imagerel $LN16+379
	DD	imagerel $unwind$s370_store_relative_long_long
$pdata$s370_add_distinct_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_add_distinct_register
$pdata$s370_add_distinct_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+249
	DD	imagerel $unwind$s370_add_distinct_halfword_immediate
$pdata$s370_add_logical_distinct_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_add_logical_distinct_register
$pdata$s370_add_logical_distinct_signed_halfword_immediate DD imagerel $LN9
	DD	imagerel $LN9+285
	DD	imagerel $unwind$s370_add_logical_distinct_signed_halfword_immediate
$pdata$s370_and_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$s370_and_distinct_register
$pdata$s370_exclusive_or_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$s370_exclusive_or_distinct_register
$pdata$s370_or_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$s370_or_distinct_register
$pdata$s370_shift_right_single_distinct DD imagerel $LN23
	DD	imagerel $LN23+531
	DD	imagerel $unwind$s370_shift_right_single_distinct
$pdata$s370_shift_left_single_distinct DD imagerel $LN28
	DD	imagerel $LN28+762
	DD	imagerel $unwind$s370_shift_left_single_distinct
$pdata$s370_shift_right_single_logical_distinct DD imagerel $LN17
	DD	imagerel $LN17+404
	DD	imagerel $unwind$s370_shift_right_single_logical_distinct
$pdata$s370_shift_left_single_logical_distinct DD imagerel $LN17
	DD	imagerel $LN17+404
	DD	imagerel $unwind$s370_shift_left_single_logical_distinct
$pdata$s370_subtract_distinct_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_subtract_distinct_register
$pdata$s370_subtract_logical_distinct_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_subtract_logical_distinct_register
$pdata$s370_add_high_high_high_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_add_high_high_high_register
$pdata$s370_add_high_high_low_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_add_high_high_low_register
$pdata$s370_add_high_immediate DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$s370_add_high_immediate
$pdata$s370_add_logical_high_high_high_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_add_logical_high_high_high_register
$pdata$s370_add_logical_high_high_low_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_add_logical_high_high_low_register
$pdata$s370_add_logical_with_signed_immediate_high DD imagerel $LN9
	DD	imagerel $LN9+295
	DD	imagerel $unwind$s370_add_logical_with_signed_immediate_high
$pdata$s370_add_logical_with_signed_immediate_high_n DD imagerel $LN9
	DD	imagerel $LN9+274
	DD	imagerel $unwind$s370_add_logical_with_signed_immediate_high_n
$pdata$s370_branch_relative_on_count_high DD imagerel $LN9
	DD	imagerel $LN9+245
	DD	imagerel $unwind$s370_branch_relative_on_count_high
$pdata$s370_compare_high_high_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$s370_compare_high_high_register
$pdata$s370_compare_high_low_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$s370_compare_high_low_register
$pdata$s370_compare_high_fullword DD imagerel $LN20
	DD	imagerel $LN20+481
	DD	imagerel $unwind$s370_compare_high_fullword
$pdata$s370_compare_high_immediate DD imagerel $LN11
	DD	imagerel $LN11+253
	DD	imagerel $unwind$s370_compare_high_immediate
$pdata$s370_compare_logical_high_high_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$s370_compare_logical_high_high_register
$pdata$s370_compare_logical_high_low_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$s370_compare_logical_high_low_register
$pdata$s370_compare_logical_high_fullword DD imagerel $LN20
	DD	imagerel $LN20+481
	DD	imagerel $unwind$s370_compare_logical_high_fullword
$pdata$s370_compare_logical_high_immediate DD imagerel $LN11
	DD	imagerel $LN11+253
	DD	imagerel $unwind$s370_compare_logical_high_immediate
$pdata$s370_load_byte_high DD imagerel $LN16
	DD	imagerel $LN16+402
	DD	imagerel $unwind$s370_load_byte_high
$pdata$s370_load_fullword_high DD imagerel $LN16
	DD	imagerel $LN16+399
	DD	imagerel $unwind$s370_load_fullword_high
$pdata$s370_load_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+400
	DD	imagerel $unwind$s370_load_halfword_high
$pdata$s370_load_logical_character_high DD imagerel $LN16
	DD	imagerel $LN16+402
	DD	imagerel $unwind$s370_load_logical_character_high
$pdata$s370_load_logical_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+402
	DD	imagerel $unwind$s370_load_logical_halfword_high
$pdata$s370_rotate_then_insert_selected_bits_high_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_rotate_then_insert_selected_bits_high_long_reg
$pdata$s370_rotate_then_insert_selected_bits_low_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_rotate_then_insert_selected_bits_low_long_reg
$pdata$s370_store_character_high DD imagerel $LN16
	DD	imagerel $LN16+401
	DD	imagerel $unwind$s370_store_character_high
$pdata$s370_store_fullword_high DD imagerel $LN16
	DD	imagerel $LN16+400
	DD	imagerel $unwind$s370_store_fullword_high
$pdata$s370_store_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+401
	DD	imagerel $unwind$s370_store_halfword_high
$pdata$s370_subtract_high_high_high_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_subtract_high_high_high_register
$pdata$s370_subtract_high_high_low_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$s370_subtract_high_high_low_register
$pdata$s370_subtract_logical_high_high_high_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_subtract_logical_high_high_high_register
$pdata$s370_subtract_logical_high_high_low_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$s370_subtract_logical_high_high_low_register
$pdata$s370_load_and_add DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$s370_load_and_add
$pdata$s370_load_and_add_logical DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_add_logical
$pdata$s370_load_and_and DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_and
$pdata$s370_load_and_exclusive_or DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_exclusive_or
$pdata$s370_load_and_or DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_or
$pdata$s370_load_pair_disjoint DD imagerel $LN12
	DD	imagerel $LN12+493
	DD	imagerel $unwind$s370_load_pair_disjoint
$pdata$s370_load_and_add_long DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$s370_load_and_add_long
$pdata$s370_load_and_add_logical_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_add_logical_long
$pdata$s370_load_and_and_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_and_long
$pdata$s370_load_and_exclusive_or_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_exclusive_or_long
$pdata$s370_load_and_or_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_load_and_or_long
$pdata$s370_load_pair_disjoint_long DD imagerel $LN12
	DD	imagerel $LN12+505
	DD	imagerel $unwind$s370_load_pair_disjoint_long
$pdata$s370_load_on_condition_register DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$s370_load_on_condition_register
$pdata$s370_load_on_condition DD imagerel $LN16
	DD	imagerel $LN16+410
	DD	imagerel $unwind$s370_load_on_condition
$pdata$s370_store_on_condition DD imagerel $LN16
	DD	imagerel $LN16+403
	DD	imagerel $unwind$s370_store_on_condition
$pdata$s370_population_count DD imagerel $LN12
	DD	imagerel $LN12+309
	DD	imagerel $unwind$s370_population_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpxchg8_x86 DD imagerel $LN5
	DD	imagerel $LN5+113
	DD	imagerel $unwind$cmpxchg8_x86
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpxchg4_x86 DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$cmpxchg4_x86
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_logical DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$add_logical
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_logical DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$sub_logical
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_signed DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$add_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_signed DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$sub_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_signed DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$mul_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_unsigned_long DD imagerel $LN3
	DD	imagerel $LN3+255
	DD	imagerel $unwind$mul_unsigned_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_signed_long DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$mul_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_logical_long DD imagerel $LN7
	DD	imagerel $LN7+119
	DD	imagerel $unwind$add_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_logical_long DD imagerel $LN7
	DD	imagerel $LN7+119
	DD	imagerel $unwind$sub_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_signed_long DD imagerel $LN11
	DD	imagerel $LN11+218
	DD	imagerel $unwind$add_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_signed_long DD imagerel $LN11
	DD	imagerel $LN11+234
	DD	imagerel $unwind$sub_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$s370_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+313
	DD	imagerel $unwind$s370_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+356
	DD	imagerel $unwind$s370_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$s370_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstoreb DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$s370_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2 DD imagerel $LN24
	DD	imagerel $LN24+267
	DD	imagerel $unwind$s370_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4 DD imagerel $LN27
	DD	imagerel $LN27+289
	DD	imagerel $unwind$s370_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore8 DD imagerel $LN24
	DD	imagerel $LN24+253
	DD	imagerel $unwind$s370_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchb DD imagerel $LN18
	DD	imagerel $LN18+160
	DD	imagerel $unwind$s370_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch8 DD imagerel $LN23
	DD	imagerel $LN23+240
	DD	imagerel $unwind$s370_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$s370_perform_interlocked_storage_immediate DD imagerel $LN25
	DD	imagerel $LN25+704
	DD	imagerel $unwind$s370_perform_interlocked_storage_immediate
$pdata$s370_perform_interlocked_long_storage_immediate DD imagerel $LN25
	DD	imagerel $LN25+725
	DD	imagerel $unwind$s370_perform_interlocked_long_storage_immediate
$pdata$s370_rotate_then_xxx_selected_bits_long_reg DD imagerel $LN44
	DD	imagerel $LN44+1364
	DD	imagerel $unwind$s370_rotate_then_xxx_selected_bits_long_reg
$pdata$s370_load_and_perform_interlocked_access DD imagerel $LN33
	DD	imagerel $LN33+915
	DD	imagerel $unwind$s370_load_and_perform_interlocked_access
$pdata$s370_load_and_perform_interlocked_access_long DD imagerel $LN33
	DD	imagerel $LN33+964
	DD	imagerel $unwind$s370_load_and_perform_interlocked_access_long
$pdata$z900_add_immediate_long_storage DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$z900_add_immediate_long_storage
$pdata$z900_add_immediate_storage DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$z900_add_immediate_storage
$pdata$z900_add_logical_with_signed_immediate DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_add_logical_with_signed_immediate
$pdata$z900_add_logical_with_signed_immediate_long DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_add_logical_with_signed_immediate_long
$pdata$z900_compare_and_branch_register DD imagerel $LN18
	DD	imagerel $LN18+496
	DD	imagerel $unwind$z900_compare_and_branch_register
$pdata$z900_compare_and_branch_long_register DD imagerel $LN18
	DD	imagerel $LN18+498
	DD	imagerel $unwind$z900_compare_and_branch_long_register
$pdata$z900_compare_and_branch_relative_register DD imagerel $LN18
	DD	imagerel $LN18+447
	DD	imagerel $unwind$z900_compare_and_branch_relative_register
$pdata$z900_compare_and_branch_relative_long_register DD imagerel $LN18
	DD	imagerel $LN18+449
	DD	imagerel $unwind$z900_compare_and_branch_relative_long_register
$pdata$z900_compare_and_trap_long_register DD imagerel $LN12
	DD	imagerel $LN12+306
	DD	imagerel $unwind$z900_compare_and_trap_long_register
$pdata$z900_compare_and_trap_register DD imagerel $LN12
	DD	imagerel $LN12+304
	DD	imagerel $unwind$z900_compare_and_trap_register
$pdata$z900_compare_halfword_immediate_halfword_storage DD imagerel $LN12
	DD	imagerel $LN12+336
	DD	imagerel $unwind$z900_compare_halfword_immediate_halfword_storage
$pdata$z900_compare_halfword_immediate_long_storage DD imagerel $LN12
	DD	imagerel $LN12+334
	DD	imagerel $unwind$z900_compare_halfword_immediate_long_storage
$pdata$z900_compare_halfword_immediate_storage DD imagerel $LN12
	DD	imagerel $LN12+329
	DD	imagerel $unwind$z900_compare_halfword_immediate_storage
$pdata$z900_compare_halfword_long DD imagerel $LN20
	DD	imagerel $LN20+541
	DD	imagerel $unwind$z900_compare_halfword_long
$pdata$z900_compare_halfword_relative_long DD imagerel $LN19
	DD	imagerel $LN19+439
	DD	imagerel $unwind$z900_compare_halfword_relative_long
$pdata$z900_compare_halfword_relative_long_long DD imagerel $LN19
	DD	imagerel $LN19+443
	DD	imagerel $unwind$z900_compare_halfword_relative_long_long
$pdata$z900_compare_immediate_and_branch DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$z900_compare_immediate_and_branch
$pdata$z900_compare_immediate_and_branch_long DD imagerel $LN18
	DD	imagerel $LN18+468
	DD	imagerel $unwind$z900_compare_immediate_and_branch_long
$pdata$z900_compare_immediate_and_branch_relative DD imagerel $LN18
	DD	imagerel $LN18+420
	DD	imagerel $unwind$z900_compare_immediate_and_branch_relative
$pdata$z900_compare_immediate_and_branch_relative_long DD imagerel $LN18
	DD	imagerel $LN18+424
	DD	imagerel $unwind$z900_compare_immediate_and_branch_relative_long
$pdata$z900_compare_immediate_and_trap DD imagerel $LN12
	DD	imagerel $LN12+302
	DD	imagerel $unwind$z900_compare_immediate_and_trap
$pdata$z900_compare_immediate_and_trap_long DD imagerel $LN12
	DD	imagerel $LN12+306
	DD	imagerel $unwind$z900_compare_immediate_and_trap_long
$pdata$z900_compare_logical_and_branch_long_register DD imagerel $LN18
	DD	imagerel $LN18+498
	DD	imagerel $unwind$z900_compare_logical_and_branch_long_register
$pdata$z900_compare_logical_and_branch_register DD imagerel $LN18
	DD	imagerel $LN18+496
	DD	imagerel $unwind$z900_compare_logical_and_branch_register
$pdata$z900_compare_logical_and_branch_relative_long_register DD imagerel $LN18
	DD	imagerel $LN18+449
	DD	imagerel $unwind$z900_compare_logical_and_branch_relative_long_register
$pdata$z900_compare_logical_and_branch_relative_register DD imagerel $LN18
	DD	imagerel $LN18+447
	DD	imagerel $unwind$z900_compare_logical_and_branch_relative_register
$pdata$z900_compare_logical_and_trap_long_register DD imagerel $LN12
	DD	imagerel $LN12+306
	DD	imagerel $unwind$z900_compare_logical_and_trap_long_register
$pdata$z900_compare_logical_and_trap_register DD imagerel $LN12
	DD	imagerel $LN12+304
	DD	imagerel $unwind$z900_compare_logical_and_trap_register
$pdata$z900_compare_logical_immediate_and_branch DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$z900_compare_logical_immediate_and_branch
$pdata$z900_compare_logical_immediate_and_branch_long DD imagerel $LN18
	DD	imagerel $LN18+466
	DD	imagerel $unwind$z900_compare_logical_immediate_and_branch_long
$pdata$z900_compare_logical_immediate_and_branch_relative DD imagerel $LN18
	DD	imagerel $LN18+420
	DD	imagerel $unwind$z900_compare_logical_immediate_and_branch_relative
$pdata$z900_compare_logical_immediate_and_branch_relative_long DD imagerel $LN18
	DD	imagerel $LN18+422
	DD	imagerel $unwind$z900_compare_logical_immediate_and_branch_relative_long
$pdata$z900_compare_logical_immediate_and_trap_fullword DD imagerel $LN12
	DD	imagerel $LN12+302
	DD	imagerel $unwind$z900_compare_logical_immediate_and_trap_fullword
$pdata$z900_compare_logical_immediate_and_trap_long DD imagerel $LN12
	DD	imagerel $LN12+304
	DD	imagerel $unwind$z900_compare_logical_immediate_and_trap_long
$pdata$z900_compare_logical_immediate_fullword_storage DD imagerel $LN12
	DD	imagerel $LN12+329
	DD	imagerel $unwind$z900_compare_logical_immediate_fullword_storage
$pdata$z900_compare_logical_immediate_halfword_storage DD imagerel $LN12
	DD	imagerel $LN12+336
	DD	imagerel $unwind$z900_compare_logical_immediate_halfword_storage
$pdata$z900_compare_logical_immediate_long_storage DD imagerel $LN12
	DD	imagerel $LN12+332
	DD	imagerel $unwind$z900_compare_logical_immediate_long_storage
$pdata$z900_compare_logical_relative_long DD imagerel $LN20
	DD	imagerel $LN20+471
	DD	imagerel $unwind$z900_compare_logical_relative_long
$pdata$z900_compare_logical_relative_long_halfword DD imagerel $LN19
	DD	imagerel $LN19+439
	DD	imagerel $unwind$z900_compare_logical_relative_long_halfword
$pdata$z900_compare_logical_relative_long_long DD imagerel $LN20
	DD	imagerel $LN20+476
	DD	imagerel $unwind$z900_compare_logical_relative_long_long
$pdata$z900_compare_logical_relative_long_long_fullword DD imagerel $LN20
	DD	imagerel $LN20+473
	DD	imagerel $unwind$z900_compare_logical_relative_long_long_fullword
$pdata$z900_compare_logical_relative_long_long_halfword DD imagerel $LN19
	DD	imagerel $LN19+441
	DD	imagerel $unwind$z900_compare_logical_relative_long_long_halfword
$pdata$z900_compare_relative_long DD imagerel $LN20
	DD	imagerel $LN20+471
	DD	imagerel $unwind$z900_compare_relative_long
$pdata$z900_compare_relative_long_long DD imagerel $LN20
	DD	imagerel $LN20+476
	DD	imagerel $unwind$z900_compare_relative_long_long
$pdata$z900_compare_relative_long_long_fullword DD imagerel $LN20
	DD	imagerel $LN20+475
	DD	imagerel $unwind$z900_compare_relative_long_long_fullword
$pdata$z900_extract_cpu_attribute DD imagerel $LN24
	DD	imagerel $LN24+702
	DD	imagerel $unwind$z900_extract_cpu_attribute
$pdata$z900_load_address_extended_y DD imagerel $LN37
	DD	imagerel $LN37+791
	DD	imagerel $unwind$z900_load_address_extended_y
$pdata$z900_load_and_test_long_fullword DD imagerel $LN20
	DD	imagerel $LN20+551
	DD	imagerel $unwind$z900_load_and_test_long_fullword
$pdata$z900_load_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+364
	DD	imagerel $unwind$z900_load_halfword_relative_long
$pdata$z900_load_halfword_relative_long_long DD imagerel $LN15
	DD	imagerel $LN15+366
	DD	imagerel $unwind$z900_load_halfword_relative_long_long
$pdata$z900_load_logical_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+364
	DD	imagerel $unwind$z900_load_logical_halfword_relative_long
$pdata$z900_load_logical_halfword_relative_long_long DD imagerel $LN15
	DD	imagerel $LN15+365
	DD	imagerel $unwind$z900_load_logical_halfword_relative_long_long
$pdata$z900_load_logical_relative_long_long_fullword DD imagerel $LN16
	DD	imagerel $LN16+398
	DD	imagerel $unwind$z900_load_logical_relative_long_long_fullword
$pdata$z900_load_relative_long DD imagerel $LN16
	DD	imagerel $LN16+411
	DD	imagerel $unwind$z900_load_relative_long
$pdata$z900_load_relative_long_long DD imagerel $LN16
	DD	imagerel $LN16+400
	DD	imagerel $unwind$z900_load_relative_long_long
$pdata$z900_load_relative_long_long_fullword DD imagerel $LN16
	DD	imagerel $LN16+399
	DD	imagerel $unwind$z900_load_relative_long_long_fullword
$pdata$z900_move_fullword_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+268
	DD	imagerel $unwind$z900_move_fullword_from_halfword_immediate
$pdata$z900_move_halfword_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+260
	DD	imagerel $unwind$z900_move_halfword_from_halfword_immediate
$pdata$z900_move_long_from_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+271
	DD	imagerel $unwind$z900_move_long_from_halfword_immediate
$pdata$z900_multiply_halfword_y DD imagerel $LN16
	DD	imagerel $LN16+492
	DD	imagerel $unwind$z900_multiply_halfword_y
$pdata$z900_multiply_single_immediate_fullword DD imagerel $LN7
	DD	imagerel $LN7+197
	DD	imagerel $unwind$z900_multiply_single_immediate_fullword
$pdata$z900_multiply_single_immediate_long_fullword DD imagerel $LN7
	DD	imagerel $LN7+203
	DD	imagerel $unwind$z900_multiply_single_immediate_long_fullword
$pdata$z900_multiply_y DD imagerel $LN17
	DD	imagerel $LN17+556
	DD	imagerel $unwind$z900_multiply_y
$pdata$z900_prefetch_data DD imagerel $LN16
	DD	imagerel $LN16+395
	DD	imagerel $unwind$z900_prefetch_data
$pdata$z900_prefetch_data_relative_long DD imagerel $LN15
	DD	imagerel $LN15+317
	DD	imagerel $unwind$z900_prefetch_data_relative_long
$pdata$z900_rotate_then_and_selected_bits_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_and_selected_bits_long_reg
$pdata$z900_rotate_then_exclusive_or_selected_bits_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_exclusive_or_selected_bits_long_reg
$pdata$z900_rotate_then_insert_selected_bits_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_insert_selected_bits_long_reg
$pdata$z900_rotate_then_or_selected_bits_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_or_selected_bits_long_reg
$pdata$z900_store_halfword_relative_long DD imagerel $LN15
	DD	imagerel $LN15+356
	DD	imagerel $unwind$z900_store_halfword_relative_long
$pdata$z900_store_relative_long DD imagerel $LN16
	DD	imagerel $LN16+390
	DD	imagerel $unwind$z900_store_relative_long
$pdata$z900_store_relative_long_long DD imagerel $LN16
	DD	imagerel $LN16+391
	DD	imagerel $unwind$z900_store_relative_long_long
$pdata$z900_add_distinct_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_add_distinct_register
$pdata$z900_add_distinct_long_register DD imagerel $LN8
	DD	imagerel $LN8+257
	DD	imagerel $unwind$z900_add_distinct_long_register
$pdata$z900_add_distinct_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+249
	DD	imagerel $unwind$z900_add_distinct_halfword_immediate
$pdata$z900_add_distinct_long_halfword_immediate DD imagerel $LN8
	DD	imagerel $LN8+251
	DD	imagerel $unwind$z900_add_distinct_long_halfword_immediate
$pdata$z900_add_logical_distinct_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_add_logical_distinct_register
$pdata$z900_add_logical_distinct_long_register DD imagerel $LN7
	DD	imagerel $LN7+206
	DD	imagerel $unwind$z900_add_logical_distinct_long_register
$pdata$z900_add_logical_distinct_signed_halfword_immediate DD imagerel $LN9
	DD	imagerel $LN9+285
	DD	imagerel $unwind$z900_add_logical_distinct_signed_halfword_immediate
$pdata$z900_add_logical_distinct_long_signed_halfword_immediate DD imagerel $LN9
	DD	imagerel $LN9+290
	DD	imagerel $unwind$z900_add_logical_distinct_long_signed_halfword_immediate
$pdata$z900_and_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$z900_and_distinct_register
$pdata$z900_and_distinct_long_register DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$z900_and_distinct_long_register
$pdata$z900_exclusive_or_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$z900_exclusive_or_distinct_register
$pdata$z900_exclusive_or_distinct_long_register DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$z900_exclusive_or_distinct_long_register
$pdata$z900_or_distinct_register DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$z900_or_distinct_register
$pdata$z900_or_distinct_long_register DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$z900_or_distinct_long_register
$pdata$z900_shift_right_single_distinct DD imagerel $LN23
	DD	imagerel $LN23+559
	DD	imagerel $unwind$z900_shift_right_single_distinct
$pdata$z900_shift_left_single_distinct DD imagerel $LN28
	DD	imagerel $LN28+859
	DD	imagerel $unwind$z900_shift_left_single_distinct
$pdata$z900_shift_right_single_logical_distinct DD imagerel $LN17
	DD	imagerel $LN17+432
	DD	imagerel $unwind$z900_shift_right_single_logical_distinct
$pdata$z900_shift_left_single_logical_distinct DD imagerel $LN17
	DD	imagerel $LN17+432
	DD	imagerel $unwind$z900_shift_left_single_logical_distinct
$pdata$z900_subtract_distinct_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_subtract_distinct_register
$pdata$z900_subtract_distinct_long_register DD imagerel $LN8
	DD	imagerel $LN8+257
	DD	imagerel $unwind$z900_subtract_distinct_long_register
$pdata$z900_subtract_logical_distinct_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_subtract_logical_distinct_register
$pdata$z900_subtract_logical_distinct_long_register DD imagerel $LN7
	DD	imagerel $LN7+206
	DD	imagerel $unwind$z900_subtract_logical_distinct_long_register
$pdata$z900_add_high_high_high_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_add_high_high_high_register
$pdata$z900_add_high_high_low_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_add_high_high_low_register
$pdata$z900_add_high_immediate DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$z900_add_high_immediate
$pdata$z900_add_logical_high_high_high_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_add_logical_high_high_high_register
$pdata$z900_add_logical_high_high_low_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_add_logical_high_high_low_register
$pdata$z900_add_logical_with_signed_immediate_high DD imagerel $LN9
	DD	imagerel $LN9+295
	DD	imagerel $unwind$z900_add_logical_with_signed_immediate_high
$pdata$z900_add_logical_with_signed_immediate_high_n DD imagerel $LN9
	DD	imagerel $LN9+274
	DD	imagerel $unwind$z900_add_logical_with_signed_immediate_high_n
$pdata$z900_branch_relative_on_count_high DD imagerel $LN13
	DD	imagerel $LN13+321
	DD	imagerel $unwind$z900_branch_relative_on_count_high
$pdata$z900_compare_high_high_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$z900_compare_high_high_register
$pdata$z900_compare_high_low_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$z900_compare_high_low_register
$pdata$z900_compare_high_fullword DD imagerel $LN20
	DD	imagerel $LN20+532
	DD	imagerel $unwind$z900_compare_high_fullword
$pdata$z900_compare_high_immediate DD imagerel $LN11
	DD	imagerel $LN11+253
	DD	imagerel $unwind$z900_compare_high_immediate
$pdata$z900_compare_logical_high_high_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$z900_compare_logical_high_high_register
$pdata$z900_compare_logical_high_low_register DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$z900_compare_logical_high_low_register
$pdata$z900_compare_logical_high_fullword DD imagerel $LN20
	DD	imagerel $LN20+532
	DD	imagerel $unwind$z900_compare_logical_high_fullword
$pdata$z900_compare_logical_high_immediate DD imagerel $LN11
	DD	imagerel $LN11+253
	DD	imagerel $unwind$z900_compare_logical_high_immediate
$pdata$z900_load_byte_high DD imagerel $LN16
	DD	imagerel $LN16+453
	DD	imagerel $unwind$z900_load_byte_high
$pdata$z900_load_fullword_high DD imagerel $LN16
	DD	imagerel $LN16+450
	DD	imagerel $unwind$z900_load_fullword_high
$pdata$z900_load_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+451
	DD	imagerel $unwind$z900_load_halfword_high
$pdata$z900_load_logical_character_high DD imagerel $LN16
	DD	imagerel $LN16+453
	DD	imagerel $unwind$z900_load_logical_character_high
$pdata$z900_load_logical_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+453
	DD	imagerel $unwind$z900_load_logical_halfword_high
$pdata$z900_rotate_then_insert_selected_bits_high_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_insert_selected_bits_high_long_reg
$pdata$z900_rotate_then_insert_selected_bits_low_long_reg DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_insert_selected_bits_low_long_reg
$pdata$z900_store_character_high DD imagerel $LN16
	DD	imagerel $LN16+452
	DD	imagerel $unwind$z900_store_character_high
$pdata$z900_store_fullword_high DD imagerel $LN16
	DD	imagerel $LN16+451
	DD	imagerel $unwind$z900_store_fullword_high
$pdata$z900_store_halfword_high DD imagerel $LN16
	DD	imagerel $LN16+452
	DD	imagerel $unwind$z900_store_halfword_high
$pdata$z900_subtract_high_high_high_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_subtract_high_high_high_register
$pdata$z900_subtract_high_high_low_register DD imagerel $LN8
	DD	imagerel $LN8+256
	DD	imagerel $unwind$z900_subtract_high_high_low_register
$pdata$z900_subtract_logical_high_high_high_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_subtract_logical_high_high_high_register
$pdata$z900_subtract_logical_high_high_low_register DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_subtract_logical_high_high_low_register
$pdata$z900_load_and_add DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$z900_load_and_add
$pdata$z900_load_and_add_logical DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_add_logical
$pdata$z900_load_and_and DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_and
$pdata$z900_load_and_exclusive_or DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_exclusive_or
$pdata$z900_load_and_or DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_or
$pdata$z900_load_pair_disjoint DD imagerel $LN16
	DD	imagerel $LN16+638
	DD	imagerel $unwind$z900_load_pair_disjoint
$pdata$z900_load_and_add_long DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$z900_load_and_add_long
$pdata$z900_load_and_add_logical_long DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_add_logical_long
$pdata$z900_load_and_and_long DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_and_long
$pdata$z900_load_and_exclusive_or_long DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_exclusive_or_long
$pdata$z900_load_and_or_long DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$z900_load_and_or_long
$pdata$z900_load_pair_disjoint_long DD imagerel $LN16
	DD	imagerel $LN16+719
	DD	imagerel $unwind$z900_load_pair_disjoint_long
$pdata$z900_load_on_condition_register DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$z900_load_on_condition_register
$pdata$z900_load_on_condition_long_register DD imagerel $LN8
	DD	imagerel $LN8+201
	DD	imagerel $unwind$z900_load_on_condition_long_register
$pdata$z900_load_on_condition DD imagerel $LN16
	DD	imagerel $LN16+451
	DD	imagerel $unwind$z900_load_on_condition
$pdata$z900_load_on_condition_long DD imagerel $LN16
	DD	imagerel $LN16+454
	DD	imagerel $unwind$z900_load_on_condition_long
$pdata$z900_store_on_condition DD imagerel $LN17
	DD	imagerel $LN17+492
	DD	imagerel $unwind$z900_store_on_condition
$pdata$z900_store_on_condition_long DD imagerel $LN17
	DD	imagerel $LN17+493
	DD	imagerel $unwind$z900_store_on_condition_long
$pdata$z900_population_count DD imagerel $LN18
	DD	imagerel $LN18+470
	DD	imagerel $unwind$z900_population_count
$pdata$z900_branch_prediction_preload DD imagerel $LN20
	DD	imagerel $LN20+515
	DD	imagerel $unwind$z900_branch_prediction_preload
$pdata$z900_branch_prediction_relative_preload DD imagerel $LN27
	DD	imagerel $LN27+701
	DD	imagerel $unwind$z900_branch_prediction_relative_preload
$pdata$z900_next_instruction_access_intent DD imagerel $LN7
	DD	imagerel $LN7+112
	DD	imagerel $unwind$z900_next_instruction_access_intent
$pdata$z900_load_and_trap DD imagerel $LN17
	DD	imagerel $LN17+500
	DD	imagerel $unwind$z900_load_and_trap
$pdata$z900_load_long_and_trap DD imagerel $LN17
	DD	imagerel $LN17+502
	DD	imagerel $unwind$z900_load_long_and_trap
$pdata$z900_load_fullword_high_and_trap DD imagerel $LN17
	DD	imagerel $LN17+500
	DD	imagerel $unwind$z900_load_fullword_high_and_trap
$pdata$z900_load_logical_long_fullword_and_trap DD imagerel $LN17
	DD	imagerel $LN17+504
	DD	imagerel $unwind$z900_load_logical_long_fullword_and_trap
$pdata$z900_load_logical_long_thirtyone_and_trap DD imagerel $LN17
	DD	imagerel $LN17+508
	DD	imagerel $unwind$z900_load_logical_long_thirtyone_and_trap
$pdata$z900_compare_logical_and_trap DD imagerel $LN20
	DD	imagerel $LN20+541
	DD	imagerel $unwind$z900_compare_logical_and_trap
$pdata$z900_compare_logical_and_trap_long DD imagerel $LN20
	DD	imagerel $LN20+546
	DD	imagerel $unwind$z900_compare_logical_and_trap_long
$pdata$z900_rotate_then_insert_selected_bits_long_reg_n DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_rotate_then_insert_selected_bits_long_reg_n
$pdata$z900_load_halfword_high_immediate_on_condition DD imagerel $LN8
	DD	imagerel $LN8+190
	DD	imagerel $unwind$z900_load_halfword_high_immediate_on_condition
$pdata$z900_load_halfword_immediate_on_condition DD imagerel $LN8
	DD	imagerel $LN8+190
	DD	imagerel $unwind$z900_load_halfword_immediate_on_condition
$pdata$z900_load_halfword_immediate_on_condition_grande DD imagerel $LN8
	DD	imagerel $LN8+192
	DD	imagerel $unwind$z900_load_halfword_immediate_on_condition_grande
$pdata$z900_load_high_on_condition DD imagerel $LN16
	DD	imagerel $LN16+451
	DD	imagerel $unwind$z900_load_high_on_condition
$pdata$z900_load_high_on_condition_register DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$z900_load_high_on_condition_register
$pdata$z900_store_high_on_condition DD imagerel $LN17
	DD	imagerel $LN17+492
	DD	imagerel $unwind$z900_store_high_on_condition
$pdata$z900_load_and_zero_rightmost_byte_grande DD imagerel $LN16
	DD	imagerel $LN16+477
	DD	imagerel $unwind$z900_load_and_zero_rightmost_byte_grande
$pdata$z900_load_logical_and_zero_rightmost_byte DD imagerel $LN16
	DD	imagerel $LN16+492
	DD	imagerel $unwind$z900_load_logical_and_zero_rightmost_byte
$pdata$z900_load_and_zero_rightmost_byte DD imagerel $LN16
	DD	imagerel $LN16+471
	DD	imagerel $unwind$z900_load_and_zero_rightmost_byte
$pdata$z900_multiply_long_register DD imagerel $LN8
	DD	imagerel $LN8+252
	DD	imagerel $unwind$z900_multiply_long_register
$pdata$z900_multiply_long DD imagerel $LN17
	DD	imagerel $LN17+557
	DD	imagerel $unwind$z900_multiply_long
$pdata$z900_multiply_long_halfword DD imagerel $LN16
	DD	imagerel $LN16+493
	DD	imagerel $unwind$z900_multiply_long_halfword
$pdata$z900_select_register DD imagerel $LN9
	DD	imagerel $LN9+241
	DD	imagerel $unwind$z900_select_register
$pdata$z900_select_register_long DD imagerel $LN9
	DD	imagerel $LN9+243
	DD	imagerel $unwind$z900_select_register_long
$pdata$z900_select_fullword_high_register DD imagerel $LN9
	DD	imagerel $LN9+241
	DD	imagerel $unwind$z900_select_fullword_high_register
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+216
	DD	imagerel $unwind$z900_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+186
	DD	imagerel $unwind$z900_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore2 DD imagerel $LN9
	DD	imagerel $LN9+188
	DD	imagerel $unwind$z900_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2 DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$z900_vfetch2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$z900_perform_interlocked_storage_immediate DD imagerel $LN25
	DD	imagerel $LN25+756
	DD	imagerel $unwind$z900_perform_interlocked_storage_immediate
$pdata$z900_perform_interlocked_long_storage_immediate DD imagerel $LN25
	DD	imagerel $LN25+783
	DD	imagerel $unwind$z900_perform_interlocked_long_storage_immediate
$pdata$z900_rotate_then_xxx_selected_bits_long_reg DD imagerel $LN44
	DD	imagerel $LN44+1364
	DD	imagerel $unwind$z900_rotate_then_xxx_selected_bits_long_reg
$pdata$z900_load_and_perform_interlocked_access DD imagerel $LN33
	DD	imagerel $LN33+972
	DD	imagerel $unwind$z900_load_and_perform_interlocked_access
$pdata$z900_load_and_perform_interlocked_access_long DD imagerel $LN33
	DD	imagerel $LN33+1015
	DD	imagerel $unwind$z900_load_and_perform_interlocked_access_long
pdata	ENDS
_DATA	SEGMENT
$SG194354 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:340', 00H
	ORG $+2
$SG194382 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:372', 00H
	ORG $+2
$SG194409 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:403', 00H
	ORG $+2
$SG194436 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:434', 00H
	ORG $+2
$SG194618 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:658', 00H
	ORG $+2
$SG194648 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:691', 00H
	ORG $+2
$SG194677 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:723', 00H
	ORG $+2
$SG194706 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:755', 00H
	ORG $+2
$SG194772 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:841', 00H
	ORG $+2
$SG194796 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:873', 00H
	ORG $+2
$SG194819 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:904', 00H
	ORG $+2
$SG194842 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:935', 00H
	ORG $+2
$SG194896 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:1020', 00H
	ORG $+1
$SG194920 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:1053', 00H
	ORG $+1
$SG194943 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:1085', 00H
	ORG $+1
$SG194966 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:1117', 00H
	ORG $+1
$SG195224 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:1473', 00H
	ORG $+1
$SG195897 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:2456', 00H
	ORG $+1
$SG196350 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3061', 00H
	ORG $+1
$SG196362 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3077', 00H
	ORG $+1
$SG196373 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3093', 00H
	ORG $+1
$SG196383 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3104', 00H
	ORG $+1
$SG196393 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3115', 00H
	ORG $+1
$SG196403 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3126', 00H
	ORG $+1
$SG196413 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3137', 00H
	ORG $+1
$SG196423 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3148', 00H
	ORG $+1
$SG196433 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3159', 00H
	ORG $+1
$SG196443 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3170', 00H
	ORG $+1
$SG196469 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3191', 00H
	ORG $+1
$SG196496 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:3229', 00H
	ORG $+1
$SG197217 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:4265', 00H
	ORG $+1
$SG197247 DB	'C:\papa\MyGit\hyperion-zvector\general3.c:4286', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchb DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore2 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2_full DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore2_full DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore8 DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4 DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2 DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0150H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore8_full DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2_full DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_signed_long DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_signed_long DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_logical_long DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_logical_long DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_signed_long DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_unsigned_long DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_signed DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_signed DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_signed DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_logical DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_logical DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpxchg4_x86 DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpxchg8_x86 DD 011301H
	DD	04213H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_add_immediate_long_storage DD 010e01H
	DD	0420eH
$unwind$s370_add_immediate_storage DD 010e01H
	DD	0420eH
$unwind$s370_add_logical_with_signed_immediate DD 010e01H
	DD	0420eH
$unwind$s370_add_logical_with_signed_immediate_long DD 010e01H
	DD	0420eH
$unwind$s370_compare_and_branch_register DD 010e01H
	DD	0a20eH
$unwind$s370_compare_and_branch_relative_register DD 010e01H
	DD	0a20eH
$unwind$s370_compare_and_trap_register DD 010e01H
	DD	0820eH
$unwind$s370_compare_halfword_immediate_halfword_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_halfword_immediate_long_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_halfword_immediate_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_compare_immediate_and_branch DD 010e01H
	DD	0a20eH
$unwind$s370_compare_immediate_and_branch_relative DD 010e01H
	DD	0a20eH
$unwind$s370_compare_immediate_and_trap DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_and_branch_register DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_and_branch_relative_register DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_and_trap_register DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_immediate_and_branch DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_immediate_and_branch_relative DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_immediate_and_trap_fullword DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_immediate_fullword_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_immediate_halfword_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_immediate_long_storage DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_relative_long_halfword DD 010e01H
	DD	0a20eH
$unwind$s370_compare_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_load_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_load_logical_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_load_relative_long DD 010e01H
	DD	0a20eH
$unwind$s370_move_fullword_from_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$s370_move_halfword_from_halfword_immediate DD 010e01H
	DD	0620eH
$unwind$s370_move_long_from_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$s370_multiply_halfword_y DD 010e01H
	DD	0820eH
$unwind$s370_multiply_single_immediate_fullword DD 010e01H
	DD	0620eH
$unwind$s370_multiply_y DD 010e01H
	DD	0a20eH
$unwind$s370_prefetch_data DD 010e01H
	DD	0820eH
$unwind$s370_prefetch_data_relative_long DD 010e01H
	DD	0820eH
$unwind$s370_store_halfword_relative_long DD 010e01H
	DD	0820eH
$unwind$s370_store_relative_long DD 010e01H
	DD	0820eH
$unwind$s370_store_relative_long_long DD 010e01H
	DD	0820eH
$unwind$s370_add_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_add_distinct_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$s370_add_logical_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_add_logical_distinct_signed_halfword_immediate DD 010e01H
	DD	0a20eH
$unwind$s370_and_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_exclusive_or_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_or_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_shift_right_single_distinct DD 010e01H
	DD	0a20eH
$unwind$s370_shift_left_single_distinct DD 010e01H
	DD	0c20eH
$unwind$s370_shift_right_single_logical_distinct DD 010e01H
	DD	0a20eH
$unwind$s370_shift_left_single_logical_distinct DD 010e01H
	DD	0a20eH
$unwind$s370_subtract_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_subtract_logical_distinct_register DD 010e01H
	DD	0820eH
$unwind$s370_add_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$s370_add_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$s370_add_high_immediate DD 010e01H
	DD	0620eH
$unwind$s370_add_logical_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$s370_add_logical_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$s370_add_logical_with_signed_immediate_high DD 010e01H
	DD	0820eH
$unwind$s370_add_logical_with_signed_immediate_high_n DD 010e01H
	DD	0820eH
$unwind$s370_branch_relative_on_count_high DD 010e01H
	DD	0620eH
$unwind$s370_compare_high_high_register DD 010e01H
	DD	0420eH
$unwind$s370_compare_high_low_register DD 010e01H
	DD	0420eH
$unwind$s370_compare_high_fullword DD 010e01H
	DD	0a20eH
$unwind$s370_compare_high_immediate DD 010e01H
	DD	0820eH
$unwind$s370_compare_logical_high_high_register DD 010e01H
	DD	0420eH
$unwind$s370_compare_logical_high_low_register DD 010e01H
	DD	0420eH
$unwind$s370_compare_logical_high_fullword DD 010e01H
	DD	0a20eH
$unwind$s370_compare_logical_high_immediate DD 010e01H
	DD	0820eH
$unwind$s370_load_byte_high DD 010e01H
	DD	0820eH
$unwind$s370_load_fullword_high DD 010e01H
	DD	0820eH
$unwind$s370_load_halfword_high DD 010e01H
	DD	0820eH
$unwind$s370_load_logical_character_high DD 010e01H
	DD	0820eH
$unwind$s370_load_logical_halfword_high DD 010e01H
	DD	0820eH
$unwind$s370_rotate_then_insert_selected_bits_high_long_reg DD 010e01H
	DD	0420eH
$unwind$s370_rotate_then_insert_selected_bits_low_long_reg DD 010e01H
	DD	0420eH
$unwind$s370_store_character_high DD 010e01H
	DD	0820eH
$unwind$s370_store_fullword_high DD 010e01H
	DD	0820eH
$unwind$s370_store_halfword_high DD 010e01H
	DD	0820eH
$unwind$s370_subtract_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$s370_subtract_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$s370_subtract_logical_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$s370_subtract_logical_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$s370_load_and_add DD 010e01H
	DD	0420eH
$unwind$s370_load_and_add_logical DD 010e01H
	DD	0420eH
$unwind$s370_load_and_and DD 010e01H
	DD	0420eH
$unwind$s370_load_and_exclusive_or DD 010e01H
	DD	0420eH
$unwind$s370_load_and_or DD 010e01H
	DD	0420eH
$unwind$s370_load_pair_disjoint DD 010e01H
	DD	0a20eH
$unwind$s370_load_and_add_long DD 010e01H
	DD	0420eH
$unwind$s370_load_and_add_logical_long DD 010e01H
	DD	0420eH
$unwind$s370_load_and_and_long DD 010e01H
	DD	0420eH
$unwind$s370_load_and_exclusive_or_long DD 010e01H
	DD	0420eH
$unwind$s370_load_and_or_long DD 010e01H
	DD	0420eH
$unwind$s370_load_pair_disjoint_long DD 010e01H
	DD	0c20eH
$unwind$s370_load_on_condition_register DD 010e01H
	DD	0820eH
$unwind$s370_load_on_condition DD 010e01H
	DD	0a20eH
$unwind$s370_store_on_condition DD 010e01H
	DD	0820eH
$unwind$s370_population_count DD 010e01H
	DD	0a20eH
$unwind$s370_perform_interlocked_storage_immediate DD 021101H
	DD	0110111H
$unwind$s370_perform_interlocked_long_storage_immediate DD 021101H
	DD	0130111H
$unwind$s370_rotate_then_xxx_selected_bits_long_reg DD 021101H
	DD	0150111H
$unwind$s370_load_and_perform_interlocked_access DD 021101H
	DD	0130111H
$unwind$s370_load_and_perform_interlocked_access_long DD 021101H
	DD	0150111H
$unwind$z900_add_immediate_long_storage DD 010e01H
	DD	0420eH
$unwind$z900_add_immediate_storage DD 010e01H
	DD	0420eH
$unwind$z900_add_logical_with_signed_immediate DD 010e01H
	DD	0420eH
$unwind$z900_add_logical_with_signed_immediate_long DD 010e01H
	DD	0420eH
$unwind$z900_compare_and_branch_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_branch_long_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_branch_relative_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_branch_relative_long_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_and_trap_long_register DD 010e01H
	DD	0820eH
$unwind$z900_compare_and_trap_register DD 010e01H
	DD	0820eH
$unwind$z900_compare_halfword_immediate_halfword_storage DD 010e01H
	DD	0820eH
$unwind$z900_compare_halfword_immediate_long_storage DD 010e01H
	DD	0a20eH
$unwind$z900_compare_halfword_immediate_storage DD 010e01H
	DD	0820eH
$unwind$z900_compare_halfword_long DD 010e01H
	DD	0c20eH
$unwind$z900_compare_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_halfword_relative_long_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_immediate_and_branch DD 010e01H
	DD	0a20eH
$unwind$z900_compare_immediate_and_branch_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_immediate_and_branch_relative DD 010e01H
	DD	0a20eH
$unwind$z900_compare_immediate_and_branch_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_immediate_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_compare_immediate_and_trap_long DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_and_branch_long_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_and_branch_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_and_branch_relative_long_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_and_branch_relative_register DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_and_trap_long_register DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_and_trap_register DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_immediate_and_branch DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_immediate_and_branch_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_immediate_and_branch_relative DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_immediate_and_branch_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_immediate_and_trap_fullword DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_immediate_and_trap_long DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_immediate_fullword_storage DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_immediate_halfword_storage DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_immediate_long_storage DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_relative_long_halfword DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_relative_long_long DD 010e01H
	DD	0c20eH
$unwind$z900_compare_logical_relative_long_long_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_relative_long_long_halfword DD 010e01H
	DD	0a20eH
$unwind$z900_compare_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_compare_relative_long_long DD 010e01H
	DD	0c20eH
$unwind$z900_compare_relative_long_long_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_extract_cpu_attribute DD 010e01H
	DD	0a20eH
$unwind$z900_load_address_extended_y DD 010e01H
	DD	0a20eH
$unwind$z900_load_and_test_long_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_load_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_halfword_relative_long_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_logical_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_logical_halfword_relative_long_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_logical_relative_long_long_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_load_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_relative_long_long DD 010e01H
	DD	0a20eH
$unwind$z900_load_relative_long_long_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_move_fullword_from_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$z900_move_halfword_from_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$z900_move_long_from_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$z900_multiply_halfword_y DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_single_immediate_fullword DD 010e01H
	DD	0620eH
$unwind$z900_multiply_single_immediate_long_fullword DD 010e01H
	DD	0620eH
$unwind$z900_multiply_y DD 010e01H
	DD	0a20eH
$unwind$z900_prefetch_data DD 010e01H
	DD	0820eH
$unwind$z900_prefetch_data_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_rotate_then_and_selected_bits_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_rotate_then_exclusive_or_selected_bits_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_rotate_then_insert_selected_bits_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_rotate_then_or_selected_bits_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_store_halfword_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_store_relative_long DD 010e01H
	DD	0a20eH
$unwind$z900_store_relative_long_long DD 010e01H
	DD	0a20eH
$unwind$z900_add_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_add_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_add_distinct_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$z900_add_distinct_long_halfword_immediate DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_distinct_signed_halfword_immediate DD 010e01H
	DD	0a20eH
$unwind$z900_add_logical_distinct_long_signed_halfword_immediate DD 010e01H
	DD	0a20eH
$unwind$z900_and_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_and_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_exclusive_or_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_exclusive_or_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_or_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_or_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_shift_right_single_distinct DD 010e01H
	DD	0c20eH
$unwind$z900_shift_left_single_distinct DD 010e01H
	DD	0e20eH
$unwind$z900_shift_right_single_logical_distinct DD 010e01H
	DD	0a20eH
$unwind$z900_shift_left_single_logical_distinct DD 010e01H
	DD	0a20eH
$unwind$z900_subtract_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_logical_distinct_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_logical_distinct_long_register DD 010e01H
	DD	0820eH
$unwind$z900_add_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$z900_add_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$z900_add_high_immediate DD 010e01H
	DD	0620eH
$unwind$z900_add_logical_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_with_signed_immediate_high DD 010e01H
	DD	0820eH
$unwind$z900_add_logical_with_signed_immediate_high_n DD 010e01H
	DD	0820eH
$unwind$z900_branch_relative_on_count_high DD 010e01H
	DD	0620eH
$unwind$z900_compare_high_high_register DD 010e01H
	DD	0420eH
$unwind$z900_compare_high_low_register DD 010e01H
	DD	0420eH
$unwind$z900_compare_high_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_compare_high_immediate DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_high_high_register DD 010e01H
	DD	0420eH
$unwind$z900_compare_logical_high_low_register DD 010e01H
	DD	0420eH
$unwind$z900_compare_logical_high_fullword DD 010e01H
	DD	0a20eH
$unwind$z900_compare_logical_high_immediate DD 010e01H
	DD	0820eH
$unwind$z900_load_byte_high DD 010e01H
	DD	0820eH
$unwind$z900_load_fullword_high DD 010e01H
	DD	0820eH
$unwind$z900_load_halfword_high DD 010e01H
	DD	0820eH
$unwind$z900_load_logical_character_high DD 010e01H
	DD	0820eH
$unwind$z900_load_logical_halfword_high DD 010e01H
	DD	0820eH
$unwind$z900_rotate_then_insert_selected_bits_high_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_rotate_then_insert_selected_bits_low_long_reg DD 010e01H
	DD	0420eH
$unwind$z900_store_character_high DD 010e01H
	DD	0820eH
$unwind$z900_store_fullword_high DD 010e01H
	DD	0820eH
$unwind$z900_store_halfword_high DD 010e01H
	DD	0820eH
$unwind$z900_subtract_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_logical_high_high_high_register DD 010e01H
	DD	0820eH
$unwind$z900_subtract_logical_high_high_low_register DD 010e01H
	DD	0820eH
$unwind$z900_load_and_add DD 010e01H
	DD	0420eH
$unwind$z900_load_and_add_logical DD 010e01H
	DD	0420eH
$unwind$z900_load_and_and DD 010e01H
	DD	0420eH
$unwind$z900_load_and_exclusive_or DD 010e01H
	DD	0420eH
$unwind$z900_load_and_or DD 010e01H
	DD	0420eH
$unwind$z900_load_pair_disjoint DD 010e01H
	DD	0c20eH
$unwind$z900_load_and_add_long DD 010e01H
	DD	0420eH
$unwind$z900_load_and_add_logical_long DD 010e01H
	DD	0420eH
$unwind$z900_load_and_and_long DD 010e01H
	DD	0420eH
$unwind$z900_load_and_exclusive_or_long DD 010e01H
	DD	0420eH
$unwind$z900_load_and_or_long DD 010e01H
	DD	0420eH
$unwind$z900_load_pair_disjoint_long DD 010e01H
	DD	0e20eH
$unwind$z900_load_on_condition_register DD 010e01H
	DD	0820eH
$unwind$z900_load_on_condition_long_register DD 010e01H
	DD	0820eH
$unwind$z900_load_on_condition DD 010e01H
	DD	0a20eH
$unwind$z900_load_on_condition_long DD 010e01H
	DD	0a20eH
$unwind$z900_store_on_condition DD 010e01H
	DD	0c20eH
$unwind$z900_store_on_condition_long DD 010e01H
	DD	0c20eH
$unwind$z900_population_count DD 010e01H
	DD	0c20eH
$unwind$z900_branch_prediction_preload DD 010e01H
	DD	0c20eH
$unwind$z900_branch_prediction_relative_preload DD 010e01H
	DD	0e20eH
$unwind$z900_next_instruction_access_intent DD 010e01H
	DD	0220eH
$unwind$z900_load_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_load_long_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_load_fullword_high_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_load_logical_long_fullword_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_load_logical_long_thirtyone_and_trap DD 010e01H
	DD	0820eH
$unwind$z900_compare_logical_and_trap DD 010e01H
	DD	0c20eH
$unwind$z900_compare_logical_and_trap_long DD 010e01H
	DD	0c20eH
$unwind$z900_rotate_then_insert_selected_bits_long_reg_n DD 010e01H
	DD	0420eH
$unwind$z900_load_halfword_high_immediate_on_condition DD 010e01H
	DD	0820eH
$unwind$z900_load_halfword_immediate_on_condition DD 010e01H
	DD	0820eH
$unwind$z900_load_halfword_immediate_on_condition_grande DD 010e01H
	DD	0820eH
$unwind$z900_load_high_on_condition DD 010e01H
	DD	0a20eH
$unwind$z900_load_high_on_condition_register DD 010e01H
	DD	0820eH
$unwind$z900_store_high_on_condition DD 010e01H
	DD	0c20eH
$unwind$z900_load_and_zero_rightmost_byte_grande DD 010e01H
	DD	0a20eH
$unwind$z900_load_logical_and_zero_rightmost_byte DD 010e01H
	DD	0a20eH
$unwind$z900_load_and_zero_rightmost_byte DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_long_register DD 010e01H
	DD	0820eH
$unwind$z900_multiply_long DD 010e01H
	DD	0a20eH
$unwind$z900_multiply_long_halfword DD 010e01H
	DD	0a20eH
$unwind$z900_select_register DD 010e01H
	DD	0820eH
$unwind$z900_select_register_long DD 010e01H
	DD	0820eH
$unwind$z900_select_fullword_high_register DD 010e01H
	DD	0820eH
$unwind$z900_perform_interlocked_storage_immediate DD 021101H
	DD	0110111H
$unwind$z900_perform_interlocked_long_storage_immediate DD 021101H
	DD	0130111H
$unwind$z900_rotate_then_xxx_selected_bits_long_reg DD 021101H
	DD	0150111H
$unwind$z900_load_and_perform_interlocked_access DD 021101H
	DD	0130111H
$unwind$z900_load_and_perform_interlocked_access_long DD 021101H
	DD	0150111H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
opcode$ = 48
disp2$1 = 52
cc$ = 56
b2$ = 60
tv172 = 64
temp$2 = 68
effective_addr2$ = 72
result$ = 80
v2$ = 88
tv92 = 96
tv175 = 100
tv178 = 104
tv181 = 108
v3$ = 112
r3$ = 120
rc$ = 124
r1$ = 128
m2$ = 136
new$ = 144
old$ = 152
inst$ = 176
regs$ = 184
z900_load_and_perform_interlocked_access_long PROC

; 2974 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2975 : int     r1, r3;                         /* Register numbers          */
; 2976 : int     b2;                             /* Base of effective addr    */
; 2977 : VADR    effective_addr2;                /* Effective address         */
; 2978 : BYTE    *m2;                            /* Mainstor address          */
; 2979 : U64     v2, v3;                         /* Operand values            */
; 2980 : U64     result;                         /* Result value              */
; 2981 : U64     old, new;                       /* Values for cmpxchg4       */
; 2982 : int     cc;                             /* Condition code            */
; 2983 : int     rc;                             /* Return code               */
; 2984 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2985 : 
; 2986 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  00011	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 44	 mov	 DWORD PTR temp$2[rsp], eax
  00029	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  00032	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 34	 mov	 DWORD PTR disp2$1[rsp], eax
  0003f	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 3c	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 78	 mov	 DWORD PTR r3$[rsp], eax
  0005b	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 84 24 80 00
	00 00		 mov	 DWORD PTR r1$[rsp], eax
  0006c	83 7c 24 3c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00071	74 25		 je	 SHORT $LN10@z900_load_
  00073	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00078	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008d	48 03 c8	 add	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN10@z900_load_:
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 04	 imul	 rax, rax, 4
  000a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ad	85 c0		 test	 eax, eax
  000af	74 0a		 je	 SHORT $LN25@z900_load_
  000b1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  000bb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN26@z900_load_:
  000c3	83 7c 24 60 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c8	74 3e		 je	 SHORT $LN11@z900_load_
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 04	 imul	 rax, rax, 4
  000d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000df	c1 e0 0c	 shl	 eax, 12
  000e2	8b 4c 24 34	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000e6	0b c8		 or	 ecx, eax
  000e8	8b c1		 mov	 eax, ecx
  000ea	89 44 24 34	 mov	 DWORD PTR disp2$1[rsp], eax
  000ee	8b 44 24 34	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f2	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000f7	85 c0		 test	 eax, eax
  000f9	74 0d		 je	 SHORT $LN12@z900_load_
  000fb	8b 44 24 34	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ff	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00104	89 44 24 34	 mov	 DWORD PTR disp2$1[rsp], eax
$LN12@z900_load_:
$LN11@z900_load_:
  00108	48 63 44 24 34	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  0010d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0011d	33 c0		 xor	 eax, eax
  0011f	83 f8 06	 cmp	 eax, 6
  00122	74 1f		 je	 SHORT $LN13@z900_load_
  00124	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00133	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00138	48 23 c8	 and	 rcx, rax
  0013b	48 8b c1	 mov	 rax, rcx
  0013e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN13@z900_load_:
$LN4@z900_load_:
  00143	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014f	48 83 c0 06	 add	 rax, 6
  00153	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0015f	33 c0		 xor	 eax, eax
  00161	83 f8 06	 cmp	 eax, 6
  00164	74 0f		 je	 SHORT $LN14@z900_load_
  00166	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN14@z900_load_:
  00175	33 c0		 xor	 eax, eax
  00177	85 c0		 test	 eax, eax
  00179	75 c8		 jne	 SHORT $LN4@z900_load_

; 2987 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0017b	8b 54 24 3c	 mov	 edx, DWORD PTR b2$[rsp]
  0017f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 2988 : 
; 2989 :     /* Program check if operand not on doubleword boundary */
; 2990 :     DW_CHECK( effective_addr2, regs );

  0018c	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00191	48 83 e0 07	 and	 rax, 7
  00195	48 85 c0	 test	 rax, rax
  00198	74 1b		 je	 SHORT $LN15@z900_load_
  0019a	ba 06 00 00 00	 mov	 edx, 6
  0019f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_load_:

; 2991 : 
; 2992 :     /* Extract second byte of instruction opcode */
; 2993 :     opcode = inst[5];

  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	48 6b c0 05	 imul	 rax, rax, 5
  001be	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	88 44 24 30	 mov	 BYTE PTR opcode$[rsp], al

; 2994 : 
; 2995 :     /* Obtain third operand value from R3 register */
; 2996 :     v3 = regs->GR_G(r3);

  001ce	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  001d3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001e3	48 89 44 24 70	 mov	 QWORD PTR v3$[rsp], rax

; 2997 : 
; 2998 :     /* Get mainstor address of storage operand */
; 2999 :     m2 = MADDRL (effective_addr2, 8, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  001e8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f0	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001f4	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001f8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00200	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00208	44 8b 44 24 3c	 mov	 r8d, DWORD PTR b2$[rsp]
  0020d	ba 08 00 00 00	 mov	 edx, 8
  00212	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00217	e8 00 00 00 00	 call	 z900_maddr_l
  0021c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR m2$[rsp], rax
$LN7@z900_load_:

; 3000 : 
; 3001 :     do {
; 3002 :         /* Load storage operand value from operand address */
; 3003 :         v2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00224	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022c	8b 54 24 3c	 mov	 edx, DWORD PTR b2$[rsp]
  00230	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00235	e8 00 00 00 00	 call	 z900_vfetch8
  0023a	48 89 44 24 58	 mov	 QWORD PTR v2$[rsp], rax

; 3004 : 
; 3005 :         switch (opcode) {

  0023f	0f b6 44 24 30	 movzx	 eax, BYTE PTR opcode$[rsp]
  00244	88 44 24 40	 mov	 BYTE PTR tv172[rsp], al
  00248	80 7c 24 40 e4	 cmp	 BYTE PTR tv172[rsp], 228 ; 000000e4H
  0024d	74 2d		 je	 SHORT $LN16@z900_load_
  0024f	80 7c 24 40 e6	 cmp	 BYTE PTR tv172[rsp], 230 ; 000000e6H
  00254	74 62		 je	 SHORT $LN17@z900_load_
  00256	80 7c 24 40 e7	 cmp	 BYTE PTR tv172[rsp], 231 ; 000000e7H
  0025b	0f 84 90 00 00
	00		 je	 $LN18@z900_load_
  00261	80 7c 24 40 e8	 cmp	 BYTE PTR tv172[rsp], 232 ; 000000e8H
  00266	0f 84 be 00 00
	00		 je	 $LN19@z900_load_
  0026c	80 7c 24 40 ea	 cmp	 BYTE PTR tv172[rsp], 234 ; 000000eaH
  00271	0f 84 cd 00 00
	00		 je	 $LN20@z900_load_
  00277	e9 e2 00 00 00	 jmp	 $LN21@z900_load_
$LN16@z900_load_:

; 3006 :         case 0xE4: /* Load and And Long */
; 3007 :             /* AND operand values and set condition code */
; 3008 :             result = v2 & v3;

  0027c	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  00286	48 23 c8	 and	 rcx, rax
  00289	48 8b c1	 mov	 rax, rcx
  0028c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3009 :             cc = result ? 1 : 0;

  00291	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00297	74 0a		 je	 SHORT $LN27@z900_load_
  00299	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  002a1	eb 08		 jmp	 SHORT $LN28@z900_load_
$LN27@z900_load_:
  002a3	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN28@z900_load_:
  002ab	8b 44 24 64	 mov	 eax, DWORD PTR tv175[rsp]
  002af	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 3010 :             break;

  002b3	e9 b7 00 00 00	 jmp	 $LN8@z900_load_
$LN17@z900_load_:

; 3011 :         case 0xE6: /* Load and Or Long */
; 3012 :             /* OR operand values and set condition code */
; 3013 :             result = v2 | v3;

  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  002bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  002c2	48 0b c8	 or	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3014 :             cc = result ? 1 : 0;

  002cd	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  002d3	74 0a		 je	 SHORT $LN29@z900_load_
  002d5	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  002dd	eb 08		 jmp	 SHORT $LN30@z900_load_
$LN29@z900_load_:
  002df	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN30@z900_load_:
  002e7	8b 44 24 68	 mov	 eax, DWORD PTR tv178[rsp]
  002eb	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 3015 :             break;

  002ef	eb 7e		 jmp	 SHORT $LN8@z900_load_
$LN18@z900_load_:

; 3016 :         case 0xE7: /* Load and Exclusive Or Long */
; 3017 :             /* XOR operand values and set condition code */
; 3018 :             result = v2 ^ v3;

  002f1	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  002f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  002fb	48 33 c8	 xor	 rcx, rax
  002fe	48 8b c1	 mov	 rax, rcx
  00301	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3019 :             cc = result ? 1 : 0;

  00306	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  0030c	74 0a		 je	 SHORT $LN31@z900_load_
  0030e	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  00316	eb 08		 jmp	 SHORT $LN32@z900_load_
$LN31@z900_load_:
  00318	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN32@z900_load_:
  00320	8b 44 24 6c	 mov	 eax, DWORD PTR tv181[rsp]
  00324	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 3020 :             break;

  00328	eb 45		 jmp	 SHORT $LN8@z900_load_
$LN19@z900_load_:

; 3021 :         case 0xE8: /* Load and Add Long */
; 3022 :             /* Add signed operands and set condition code */
; 3023 :             cc = add_signed_long (&result, v2, v3);

  0032a	4c 8b 44 24 70	 mov	 r8, QWORD PTR v3$[rsp]
  0032f	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  00334	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00339	e8 00 00 00 00	 call	 add_signed_long
  0033e	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 3024 :             break;

  00342	eb 2b		 jmp	 SHORT $LN8@z900_load_
$LN20@z900_load_:

; 3025 :         case 0xEA: /* Load and Add Logical Long */
; 3026 :             /* Add unsigned operands and set condition code */
; 3027 :             cc = add_logical_long (&result, v2, v3);

  00344	4c 8b 44 24 70	 mov	 r8, QWORD PTR v3$[rsp]
  00349	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  0034e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00353	e8 00 00 00 00	 call	 add_logical_long
  00358	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 3028 :             break;

  0035c	eb 11		 jmp	 SHORT $LN8@z900_load_
$LN21@z900_load_:

; 3029 :         default: /* To prevent compiler warnings */
; 3030 :             result = 0;

  0035e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3031 :             cc = 0;

  00367	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@z900_load_:

; 3032 :         } /* end switch(opcode) */
; 3033 : 
; 3034 :         /* Interlocked exchange to storage location */
; 3035 :         old = CSWAP64(v2);

  0036f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  00374	e8 00 00 00 00	 call	 _byteswap_uint64
  00379	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR old$[rsp], rax

; 3036 :         new = CSWAP64(result);

  00381	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  00386	e8 00 00 00 00	 call	 _byteswap_uint64
  0038b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR new$[rsp], rax

; 3037 : 
; 3038 :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 3039 :         OBTAIN_MAINLOCK( regs );
; 3040 :         {
; 3041 :             rc = cmpxchg8( &old, new, m2 );

  00393	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR m2$[rsp]
  0039b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR new$[rsp]
  003a3	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR old$[rsp]
  003ab	e8 00 00 00 00	 call	 cmpxchg8_x86
  003b0	0f b6 c0	 movzx	 eax, al
  003b3	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 3042 :         }
; 3043 :         RELEASE_MAINLOCK( regs );
; 3044 : 
; 3045 :     } while (rc != 0);

  003b7	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  003bc	0f 85 62 fe ff
	ff		 jne	 $LN7@z900_load_

; 3046 : 
; 3047 :     /* Load original storage operand value into R1 register */
; 3048 :     regs->GR_G(r1) = v2;

  003c2	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003ca	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d2	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  003d7	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3049 : 
; 3050 :     /* Set condition code in PSW */
; 3051 :     regs->psw.cc = cc;

  003df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR cc$[rsp]
  003ec	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3052 : 
; 3053 : } /* end DEF_INST(load_and_perform_interlocked_access_long) */

  003ef	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003f6	c3		 ret	 0
z900_load_and_perform_interlocked_access_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
result$ = 48
opcode$ = 52
v2$ = 56
disp2$1 = 60
cc$ = 64
b2$ = 68
tv172 = 72
v3$ = 76
temp$2 = 80
effective_addr2$ = 88
tv92 = 96
tv175 = 100
tv178 = 104
tv181 = 108
r3$ = 112
new$ = 116
old$ = 120
rc$ = 124
r1$ = 128
m2$ = 136
inst$ = 160
regs$ = 168
z900_load_and_perform_interlocked_access PROC

; 2882 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2883 : int     r1, r3;                         /* Register numbers          */
; 2884 : int     b2;                             /* Base of effective addr    */
; 2885 : VADR    effective_addr2;                /* Effective address         */
; 2886 : BYTE    *m2;                            /* Mainstor address          */
; 2887 : U32     v2, v3;                         /* Operand values            */
; 2888 : U32     result;                         /* Result value              */
; 2889 : U32     old, new;                       /* Values for cmpxchg4       */
; 2890 : int     cc;                             /* Condition code            */
; 2891 : int     rc;                             /* Return code               */
; 2892 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2893 : 
; 2894 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 50	 mov	 DWORD PTR temp$2[rsp], eax
  00029	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  00032	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 3c	 mov	 DWORD PTR disp2$1[rsp], eax
  0003f	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 70	 mov	 DWORD PTR r3$[rsp], eax
  0005b	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 84 24 80 00
	00 00		 mov	 DWORD PTR r1$[rsp], eax
  0006c	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00071	74 25		 je	 SHORT $LN10@z900_load_
  00073	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  00078	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00088	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008d	48 03 c8	 add	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN10@z900_load_:
  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 04	 imul	 rax, rax, 4
  000a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ad	85 c0		 test	 eax, eax
  000af	74 0a		 je	 SHORT $LN25@z900_load_
  000b1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  000bb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN26@z900_load_:
  000c3	83 7c 24 60 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c8	74 3e		 je	 SHORT $LN11@z900_load_
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 04	 imul	 rax, rax, 4
  000d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000db	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000df	c1 e0 0c	 shl	 eax, 12
  000e2	8b 4c 24 3c	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000e6	0b c8		 or	 ecx, eax
  000e8	8b c1		 mov	 eax, ecx
  000ea	89 44 24 3c	 mov	 DWORD PTR disp2$1[rsp], eax
  000ee	8b 44 24 3c	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f2	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000f7	85 c0		 test	 eax, eax
  000f9	74 0d		 je	 SHORT $LN12@z900_load_
  000fb	8b 44 24 3c	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ff	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00104	89 44 24 3c	 mov	 DWORD PTR disp2$1[rsp], eax
$LN12@z900_load_:
$LN11@z900_load_:
  00108	48 63 44 24 3c	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  0010d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0011d	33 c0		 xor	 eax, eax
  0011f	83 f8 06	 cmp	 eax, 6
  00122	74 1f		 je	 SHORT $LN13@z900_load_
  00124	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00133	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00138	48 23 c8	 and	 rcx, rax
  0013b	48 8b c1	 mov	 rax, rcx
  0013e	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN13@z900_load_:
$LN4@z900_load_:
  00143	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014f	48 83 c0 06	 add	 rax, 6
  00153	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0015f	33 c0		 xor	 eax, eax
  00161	83 f8 06	 cmp	 eax, 6
  00164	74 0f		 je	 SHORT $LN14@z900_load_
  00166	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN14@z900_load_:
  00175	33 c0		 xor	 eax, eax
  00177	85 c0		 test	 eax, eax
  00179	75 c8		 jne	 SHORT $LN4@z900_load_

; 2895 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0017b	8b 54 24 44	 mov	 edx, DWORD PTR b2$[rsp]
  0017f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 2896 : 
; 2897 :     /* Program check if operand not on fullword boundary */
; 2898 :     FW_CHECK( effective_addr2, regs );

  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00191	48 83 e0 03	 and	 rax, 3
  00195	48 85 c0	 test	 rax, rax
  00198	74 1b		 je	 SHORT $LN15@z900_load_
  0019a	ba 06 00 00 00	 mov	 edx, 6
  0019f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_load_:

; 2899 : 
; 2900 :     /* Extract second byte of instruction opcode */
; 2901 :     opcode = inst[5];

  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	48 6b c0 05	 imul	 rax, rax, 5
  001be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  001c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ca	88 44 24 34	 mov	 BYTE PTR opcode$[rsp], al

; 2902 : 
; 2903 :     /* Obtain third operand value from R3 register */
; 2904 :     v3 = regs->GR_L(r3);

  001ce	48 63 44 24 70	 movsxd	 rax, DWORD PTR r3$[rsp]
  001d3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001e2	89 44 24 4c	 mov	 DWORD PTR v3$[rsp], eax

; 2905 : 
; 2906 :     /* Get mainstor address of storage operand */
; 2907 :     m2 = MADDRL (effective_addr2, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  001e6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ee	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001f2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001f6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001fe	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00206	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  0020b	ba 04 00 00 00	 mov	 edx, 4
  00210	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00215	e8 00 00 00 00	 call	 z900_maddr_l
  0021a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR m2$[rsp], rax
$LN7@z900_load_:

; 2908 : 
; 2909 :     do {
; 2910 :         /* Load storage operand value from operand address */
; 2911 :         v2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00222	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	8b 54 24 44	 mov	 edx, DWORD PTR b2$[rsp]
  0022e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00233	e8 00 00 00 00	 call	 z900_vfetch4
  00238	89 44 24 38	 mov	 DWORD PTR v2$[rsp], eax

; 2912 : 
; 2913 :         switch (opcode) {

  0023c	0f b6 44 24 34	 movzx	 eax, BYTE PTR opcode$[rsp]
  00241	88 44 24 48	 mov	 BYTE PTR tv172[rsp], al
  00245	80 7c 24 48 f4	 cmp	 BYTE PTR tv172[rsp], 244 ; 000000f4H
  0024a	74 2d		 je	 SHORT $LN16@z900_load_
  0024c	80 7c 24 48 f6	 cmp	 BYTE PTR tv172[rsp], 246 ; 000000f6H
  00251	74 5c		 je	 SHORT $LN17@z900_load_
  00253	80 7c 24 48 f7	 cmp	 BYTE PTR tv172[rsp], 247 ; 000000f7H
  00258	0f 84 84 00 00
	00		 je	 $LN18@z900_load_
  0025e	80 7c 24 48 f8	 cmp	 BYTE PTR tv172[rsp], 248 ; 000000f8H
  00263	0f 84 ac 00 00
	00		 je	 $LN19@z900_load_
  00269	80 7c 24 48 fa	 cmp	 BYTE PTR tv172[rsp], 250 ; 000000faH
  0026e	0f 84 ba 00 00
	00		 je	 $LN20@z900_load_
  00274	e9 ce 00 00 00	 jmp	 $LN21@z900_load_
$LN16@z900_load_:

; 2914 :         case 0xF4: /* Load and And */
; 2915 :             /* AND operand values and set condition code */
; 2916 :             result = v2 & v3;

  00279	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  0027d	8b 4c 24 38	 mov	 ecx, DWORD PTR v2$[rsp]
  00281	23 c8		 and	 ecx, eax
  00283	8b c1		 mov	 eax, ecx
  00285	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 2917 :             cc = result ? 1 : 0;

  00289	83 7c 24 30 00	 cmp	 DWORD PTR result$[rsp], 0
  0028e	74 0a		 je	 SHORT $LN27@z900_load_
  00290	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  00298	eb 08		 jmp	 SHORT $LN28@z900_load_
$LN27@z900_load_:
  0029a	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN28@z900_load_:
  002a2	8b 44 24 64	 mov	 eax, DWORD PTR tv175[rsp]
  002a6	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 2918 :             break;

  002aa	e9 a8 00 00 00	 jmp	 $LN8@z900_load_
$LN17@z900_load_:

; 2919 :         case 0xF6: /* Load and Or */
; 2920 :             /* OR operand values and set condition code */
; 2921 :             result = v2 | v3;

  002af	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  002b3	8b 4c 24 38	 mov	 ecx, DWORD PTR v2$[rsp]
  002b7	0b c8		 or	 ecx, eax
  002b9	8b c1		 mov	 eax, ecx
  002bb	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 2922 :             cc = result ? 1 : 0;

  002bf	83 7c 24 30 00	 cmp	 DWORD PTR result$[rsp], 0
  002c4	74 0a		 je	 SHORT $LN29@z900_load_
  002c6	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  002ce	eb 08		 jmp	 SHORT $LN30@z900_load_
$LN29@z900_load_:
  002d0	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN30@z900_load_:
  002d8	8b 44 24 68	 mov	 eax, DWORD PTR tv178[rsp]
  002dc	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 2923 :             break;

  002e0	eb 75		 jmp	 SHORT $LN8@z900_load_
$LN18@z900_load_:

; 2924 :         case 0xF7: /* Load and Exclusive Or */
; 2925 :             /* XOR operand values and set condition code */
; 2926 :             result = v2 ^ v3;

  002e2	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  002e6	8b 4c 24 38	 mov	 ecx, DWORD PTR v2$[rsp]
  002ea	33 c8		 xor	 ecx, eax
  002ec	8b c1		 mov	 eax, ecx
  002ee	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 2927 :             cc = result ? 1 : 0;

  002f2	83 7c 24 30 00	 cmp	 DWORD PTR result$[rsp], 0
  002f7	74 0a		 je	 SHORT $LN31@z900_load_
  002f9	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  00301	eb 08		 jmp	 SHORT $LN32@z900_load_
$LN31@z900_load_:
  00303	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN32@z900_load_:
  0030b	8b 44 24 6c	 mov	 eax, DWORD PTR tv181[rsp]
  0030f	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 2928 :             break;

  00313	eb 42		 jmp	 SHORT $LN8@z900_load_
$LN19@z900_load_:

; 2929 :         case 0xF8: /* Load and Add */
; 2930 :             /* Add signed operands and set condition code */
; 2931 :             cc = add_signed (&result, v2, v3);

  00315	44 8b 44 24 4c	 mov	 r8d, DWORD PTR v3$[rsp]
  0031a	8b 54 24 38	 mov	 edx, DWORD PTR v2$[rsp]
  0031e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  00323	e8 00 00 00 00	 call	 add_signed
  00328	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 2932 :             break;

  0032c	eb 29		 jmp	 SHORT $LN8@z900_load_
$LN20@z900_load_:

; 2933 :         case 0xFA: /* Load and Add Logical */
; 2934 :             /* Add unsigned operands and set condition code */
; 2935 :             cc = add_logical (&result, v2, v3);

  0032e	44 8b 44 24 4c	 mov	 r8d, DWORD PTR v3$[rsp]
  00333	8b 54 24 38	 mov	 edx, DWORD PTR v2$[rsp]
  00337	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  0033c	e8 00 00 00 00	 call	 add_logical
  00341	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 2936 :             break;

  00345	eb 10		 jmp	 SHORT $LN8@z900_load_
$LN21@z900_load_:

; 2937 :         default: /* To prevent compiler warnings */
; 2938 :             result = 0;

  00347	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2939 :             cc = 0;

  0034f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@z900_load_:

; 2940 :         } /* end switch(opcode) */
; 2941 : 
; 2942 :         /* Interlocked exchange to storage location */
; 2943 :         old = CSWAP32(v2);

  00357	8b 4c 24 38	 mov	 ecx, DWORD PTR v2$[rsp]
  0035b	e8 00 00 00 00	 call	 _byteswap_ulong
  00360	89 44 24 78	 mov	 DWORD PTR old$[rsp], eax

; 2944 :         new = CSWAP32(result);

  00364	8b 4c 24 30	 mov	 ecx, DWORD PTR result$[rsp]
  00368	e8 00 00 00 00	 call	 _byteswap_ulong
  0036d	89 44 24 74	 mov	 DWORD PTR new$[rsp], eax

; 2945 : 
; 2946 :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 2947 :         OBTAIN_MAINLOCK( regs );
; 2948 :         {
; 2949 :             rc = cmpxchg4( &old, new, m2 );

  00371	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR m2$[rsp]
  00379	8b 54 24 74	 mov	 edx, DWORD PTR new$[rsp]
  0037d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR old$[rsp]
  00382	e8 00 00 00 00	 call	 cmpxchg4_x86
  00387	0f b6 c0	 movzx	 eax, al
  0038a	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 2950 :         }
; 2951 :         RELEASE_MAINLOCK( regs );
; 2952 : 
; 2953 :     } while (rc != 0);

  0038e	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00393	0f 85 89 fe ff
	ff		 jne	 $LN7@z900_load_

; 2954 : 
; 2955 :     /* Load original storage operand value into R1 register */
; 2956 :     regs->GR_L(r1) = v2;

  00399	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003a1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	8b 54 24 38	 mov	 edx, DWORD PTR v2$[rsp]
  003ad	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2957 : 
; 2958 :     /* Set condition code in PSW */
; 2959 :     regs->psw.cc = cc;

  003b4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bc	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR cc$[rsp]
  003c1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2960 : 
; 2961 : } /* end DEF_INST(load_and_perform_interlocked_access) */

  003c4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003cb	c3		 ret	 0
z900_load_and_perform_interlocked_access ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
opcode$ = 32
i4$ = 33
i3$ = 34
end$ = 36
start$ = 40
mask$ = 48
r1$ = 56
i5$ = 60
resu$ = 64
temp$1 = 72
tv191 = 76
n$ = 80
rota$ = 88
r2$ = 96
tv203 = 100
t_bit$ = 104
z_bit$ = 108
tv258 = 112
tv259 = 116
tv159 = 120
tv331 = 128
tv345 = 136
p$2 = 144
inst$ = 176
regs$ = 184
z900_rotate_then_xxx_selected_bits_long_reg PROC

; 2062 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2063 : int     r1, r2;                         /* Register numbers          */
; 2064 : int     start, end;                     /* Start and end bit number  */
; 2065 : U64     mask, rota, resu;               /* 64-bit work areas         */
; 2066 : int     n;                              /* Number of bits to shift   */
; 2067 : int     t_bit = 0;                      /* Test-results indicator    */

  00011	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR t_bit$[rsp], 0

; 2068 : int     z_bit = 0;                      /* Zero-remaining indicator  */

  00019	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR z_bit$[rsp], 0

; 2069 : BYTE    i3, i4, i5;                     /* Immediate values          */
; 2070 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2071 : 
; 2072 :     RIE_RRIII( inst, regs, r1, r2, i3, i4, i5 );

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	48 6b c0 01	 imul	 rax, rax, 1
  0002a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 _byteswap_ulong
  00047	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0004b	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00054	88 44 24 3c	 mov	 BYTE PTR i5$[rsp], al
  00058	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 08	 shr	 eax, 8
  0005f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00064	88 44 24 21	 mov	 BYTE PTR i4$[rsp], al
  00068	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 10	 shr	 eax, 16
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	88 44 24 22	 mov	 BYTE PTR i3$[rsp], al
  00078	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 18	 shr	 eax, 24
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 60	 mov	 DWORD PTR r2$[rsp], eax
  00086	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0008a	c1 e8 1c	 shr	 eax, 28
  0008d	83 e0 0f	 and	 eax, 15
  00090	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_rotat:
  00094	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a0	48 83 c0 06	 add	 rax, 6
  000a4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b0	33 c0		 xor	 eax, eax
  000b2	83 f8 06	 cmp	 eax, 6
  000b5	74 0f		 je	 SHORT $LN10@z900_rotat
  000b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_rotat:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 c8		 jne	 SHORT $LN4@z900_rotat

; 2073 : 
; 2074 :     /* Extract second byte of instruction opcode */
; 2075 :     opcode = inst[5];

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	48 6b c0 05	 imul	 rax, rax, 5
  000d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000dd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e1	88 44 24 20	 mov	 BYTE PTR opcode$[rsp], al

; 2076 : 
; 2077 :     /* Extract parameters from immediate fields */
; 2078 :     start = i3 & 0x3F;

  000e5	0f b6 44 24 22	 movzx	 eax, BYTE PTR i3$[rsp]
  000ea	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ed	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2079 :     end   = i4 & 0x3F;

  000f1	0f b6 44 24 21	 movzx	 eax, BYTE PTR i4$[rsp]
  000f6	83 e0 3f	 and	 eax, 63			; 0000003fH
  000f9	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax

; 2080 : 
; 2081 :     n = i5 & 0x3F;

  000fd	0f b6 44 24 3c	 movzx	 eax, BYTE PTR i5$[rsp]
  00102	83 e0 3f	 and	 eax, 63			; 0000003fH
  00105	89 44 24 50	 mov	 DWORD PTR n$[rsp], eax

; 2082 : 
; 2083 :     if ((opcode & 0xFC) == 0x50 /*Low*/ ) {

  00109	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  0010e	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00113	83 f8 50	 cmp	 eax, 80			; 00000050H
  00116	75 16		 jne	 SHORT $LN11@z900_rotat

; 2084 :         start |= 0x20;

  00118	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  0011c	83 c8 20	 or	 eax, 32			; 00000020H
  0011f	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2085 :         end   |= 0x20;

  00123	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  00127	83 c8 20	 or	 eax, 32			; 00000020H
  0012a	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax
$LN11@z900_rotat:

; 2086 :     }
; 2087 :     if ((opcode & 0xFC) == 0x5C /*High*/ ) {

  0012e	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00133	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00138	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0013b	75 16		 jne	 SHORT $LN12@z900_rotat

; 2088 :         start &= 0x1F;

  0013d	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  00141	83 e0 1f	 and	 eax, 31
  00144	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2089 :         end   &= 0x1F;

  00148	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  0014c	83 e0 1f	 and	 eax, 31
  0014f	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax
$LN12@z900_rotat:

; 2090 :     }
; 2091 :     if ((opcode & 0x03) == 0x01 /*Insert*/ )

  00153	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00158	83 e0 03	 and	 eax, 3
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	75 0e		 jne	 SHORT $LN13@z900_rotat

; 2092 :         z_bit = i4 >> 7;

  00160	0f b6 44 24 21	 movzx	 eax, BYTE PTR i4$[rsp]
  00165	c1 f8 07	 sar	 eax, 7
  00168	89 44 24 6c	 mov	 DWORD PTR z_bit$[rsp], eax
  0016c	eb 0c		 jmp	 SHORT $LN14@z900_rotat
$LN13@z900_rotat:

; 2093 :     else
; 2094 :         t_bit = i3 >> 7;

  0016e	0f b6 44 24 22	 movzx	 eax, BYTE PTR i3$[rsp]
  00173	c1 f8 07	 sar	 eax, 7
  00176	89 44 24 68	 mov	 DWORD PTR t_bit$[rsp], eax
$LN14@z900_rotat:

; 2095 : 
; 2096 :     /* Copy value from R2 register and rotate left n bits */
; 2097 :     rota = (regs->GR_G( r2 ) << n)

  0017a	83 7c 24 50 00	 cmp	 DWORD PTR n$[rsp], 0
  0017f	75 0b		 jne	 SHORT $LN35@z900_rotat
  00181	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv159[rsp], 0
  0018a	eb 26		 jmp	 SHORT $LN36@z900_rotat
$LN35@z900_rotat:
  0018c	48 63 44 24 60	 movsxd	 rax, DWORD PTR r2$[rsp]
  00191	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00196	2b 4c 24 50	 sub	 ecx, DWORD PTR n$[rsp]
  0019a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a2	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  001aa	48 d3 e8	 shr	 rax, cl
  001ad	48 89 44 24 78	 mov	 QWORD PTR tv159[rsp], rax
$LN36@z900_rotat:
  001b2	48 63 44 24 60	 movsxd	 rax, DWORD PTR r2$[rsp]
  001b7	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  001bb	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  001cb	48 d3 e0	 shl	 rax, cl
  001ce	48 0b 44 24 78	 or	 rax, QWORD PTR tv159[rsp]
  001d3	48 89 44 24 58	 mov	 QWORD PTR rota$[rsp], rax

; 2098 :             | ((n == 0) ? 0 : (regs->GR_G( r2 ) >> (64 - n)));
; 2099 : 
; 2100 : #if 0 // (old way; TEMPORARILY retained for reference)
; 2101 : 
; 2102 :     /* Construct mask for selected bits */
; 2103 :     {
; 2104 :         int i;
; 2105 : 
; 2106 :         for (i=0, mask=0; i < 64; i++)
; 2107 :         {
; 2108 :             mask <<= 1;
; 2109 :             if (start <= end) {
; 2110 :                 if (i >= start && i <= end) mask |= 1;
; 2111 :             } else {
; 2112 :                 if (i <= end || i >= start) mask |= 1;
; 2113 :             }
; 2114 :         }
; 2115 :     }
; 2116 : 
; 2117 : #else // (Ivan Warren performance enhancement)
; 2118 : 
; 2119 :     /* Construct mask for selected bits */
; 2120 :     if (start <= end)

  001d8	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  001dc	39 44 24 28	 cmp	 DWORD PTR start$[rsp], eax
  001e0	7f 76		 jg	 SHORT $LN15@z900_rotat

; 2121 :     {
; 2122 :         // (clear high-order bits)
; 2123 :         mask   = 0xffffffffffffffffll << start;

  001e2	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  001e6	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  001ed	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv331[rsp], rcx
  001f5	0f b6 c8	 movzx	 ecx, al
  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv331[rsp]
  00200	48 d3 e0	 shl	 rax, cl
  00203	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2124 :         mask >>=                         start;

  00208	48 63 44 24 28	 movsxd	 rax, DWORD PTR start$[rsp]
  0020d	0f b6 c8	 movzx	 ecx, al
  00210	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00215	48 d3 e8	 shr	 rax, cl
  00218	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2125 : 
; 2126 :         // (clear low-order bits)
; 2127 :         mask >>= (63 - end);

  0021d	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00222	2b 44 24 24	 sub	 eax, DWORD PTR end$[rsp]
  00226	48 98		 cdqe
  00228	0f b6 c8	 movzx	 ecx, al
  0022b	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00230	48 d3 e8	 shr	 rax, cl
  00233	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2128 :         mask <<= (63 - end);

  00238	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0023d	2b 44 24 24	 sub	 eax, DWORD PTR end$[rsp]
  00241	48 98		 cdqe
  00243	0f b6 c8	 movzx	 ecx, al
  00246	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  0024b	48 d3 e0	 shl	 rax, cl
  0024e	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2129 :     }

  00253	e9 84 00 00 00	 jmp	 $LN16@z900_rotat
$LN15@z900_rotat:

; 2130 :     else // (start > end)
; 2131 :     {
; 2132 :         // (clear high-order bits)
; 2133 :         mask   = 0xffffffffffffffffll << (end + 1);

  00258	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  0025c	ff c0		 inc	 eax
  0025e	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00265	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv345[rsp], rcx
  0026d	0f b6 c8	 movzx	 ecx, al
  00270	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv345[rsp]
  00278	48 d3 e0	 shl	 rax, cl
  0027b	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2134 :         mask >>=                         (end + 1);

  00280	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  00284	ff c0		 inc	 eax
  00286	48 98		 cdqe
  00288	0f b6 c8	 movzx	 ecx, al
  0028b	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00290	48 d3 e8	 shr	 rax, cl
  00293	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2135 : 
; 2136 :         // (clear low-order bits)
; 2137 :         mask >>= (64 - start);

  00298	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0029d	2b 44 24 28	 sub	 eax, DWORD PTR start$[rsp]
  002a1	48 98		 cdqe
  002a3	0f b6 c8	 movzx	 ecx, al
  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002ab	48 d3 e8	 shr	 rax, cl
  002ae	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2138 :         mask <<= (64 - start);

  002b3	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  002b8	2b 44 24 28	 sub	 eax, DWORD PTR start$[rsp]
  002bc	48 98		 cdqe
  002be	0f b6 c8	 movzx	 ecx, al
  002c1	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002c6	48 d3 e0	 shl	 rax, cl
  002c9	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2139 : 
; 2140 :         // (invert mask to select opposite bits)
; 2141 :         mask ^= 0xffffffffffffffffll;

  002ce	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002d3	48 83 f0 ff	 xor	 rax, -1
  002d7	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax
$LN16@z900_rotat:

; 2142 :     }
; 2143 : 
; 2144 : #endif
; 2145 : 
; 2146 :     /* Isolate selected bits of rotated second operand */
; 2147 :     rota &= mask;

  002dc	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rota$[rsp]
  002e6	48 23 c8	 and	 rcx, rax
  002e9	48 8b c1	 mov	 rax, rcx
  002ec	48 89 44 24 58	 mov	 QWORD PTR rota$[rsp], rax

; 2148 : 
; 2149 :     /* Isolate selected bits of first operand */
; 2150 :     resu = regs->GR_G( r1 ) & mask;

  002f1	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  002f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	48 8b 54 24 30	 mov	 rdx, QWORD PTR mask$[rsp]
  00303	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0030b	48 23 c2	 and	 rax, rdx
  0030e	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2151 : 
; 2152 :     /* Perform operation on selected bits */
; 2153 :     switch (opcode)

  00313	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00318	89 44 24 4c	 mov	 DWORD PTR tv191[rsp], eax
  0031c	8b 44 24 4c	 mov	 eax, DWORD PTR tv191[rsp]
  00320	83 e8 51	 sub	 eax, 81			; 00000051H
  00323	89 44 24 4c	 mov	 DWORD PTR tv191[rsp], eax
  00327	83 7c 24 4c 0c	 cmp	 DWORD PTR tv191[rsp], 12
  0032c	77 69		 ja	 SHORT $LN24@z900_rotat
  0032e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv191[rsp]
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0033a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@z900_rotat[rcx+rax*4]
  00341	48 03 c1	 add	 rax, rcx
  00344	ff e0		 jmp	 rax
$LN17@z900_rotat:

; 2154 :     {
; 2155 :     case 0x54:  /* And */
; 2156 :         resu &= rota;

  00346	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  0034b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  00350	48 23 c8	 and	 rcx, rax
  00353	48 8b c1	 mov	 rax, rcx
  00356	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2157 :         break;

  0035b	eb 57		 jmp	 SHORT $LN5@z900_rotat
$LN18@z900_rotat:
$LN19@z900_rotat:
$LN20@z900_rotat:
$LN21@z900_rotat:

; 2158 :     case 0x51:  /* Insert Low            */
; 2159 :     case 0x55:  /* Insert                */
; 2160 :     case 0x5D:  /* Insert High           */
; 2161 :     case 0x59:  /* Insert - no CC change */
; 2162 :         resu = rota;

  0035d	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  00362	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2163 :         break;

  00367	eb 4b		 jmp	 SHORT $LN5@z900_rotat
$LN22@z900_rotat:

; 2164 :     case 0x56:  /* Or */
; 2165 :         resu |= rota;

  00369	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  0036e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  00373	48 0b c8	 or	 rcx, rax
  00376	48 8b c1	 mov	 rax, rcx
  00379	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2166 :         break;

  0037e	eb 34		 jmp	 SHORT $LN5@z900_rotat
$LN23@z900_rotat:

; 2167 :     case 0x57:  /* Exclusive Or */
; 2168 :         resu ^= rota;

  00380	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  00385	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  0038a	48 33 c8	 xor	 rcx, rax
  0038d	48 8b c1	 mov	 rax, rcx
  00390	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2169 :         break;

  00395	eb 1d		 jmp	 SHORT $LN5@z900_rotat
$LN24@z900_rotat:
$LN9@z900_rotat:

; 2170 :     default:    /* Should not EVER occur! */
; 2171 :         CRASH();

  00397	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$2[rsp], 0
  003a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$2[rsp]
  003ab	c6 00 00	 mov	 BYTE PTR [rax], 0
  003ae	33 c0		 xor	 eax, eax
  003b0	85 c0		 test	 eax, eax
  003b2	75 e3		 jne	 SHORT $LN9@z900_rotat
$LN5@z900_rotat:

; 2172 :     }
; 2173 : 
; 2174 :     /* And/Or/Xor set condition code according to result bits */
; 2175 :     if ((opcode & 0x03) != 0x01 /*Insert*/ )

  003b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  003b9	83 e0 03	 and	 eax, 3
  003bc	83 f8 01	 cmp	 eax, 1
  003bf	74 2a		 je	 SHORT $LN25@z900_rotat

; 2176 :         regs->psw.cc = (resu == 0) ? 0 : 1;

  003c1	48 83 7c 24 40
	00		 cmp	 QWORD PTR resu$[rsp], 0
  003c7	75 0a		 jne	 SHORT $LN37@z900_rotat
  003c9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
  003d1	eb 08		 jmp	 SHORT $LN38@z900_rotat
$LN37@z900_rotat:
  003d3	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv203[rsp], 1
$LN38@z900_rotat:
  003db	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv203[rsp]
  003e8	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN25@z900_rotat:

; 2177 : 
; 2178 :     /* Insert result bits into R1 register */
; 2179 :     if (t_bit == 0)

  003eb	83 7c 24 68 00	 cmp	 DWORD PTR t_bit$[rsp], 0
  003f0	0f 85 b4 00 00
	00		 jne	 $LN26@z900_rotat

; 2180 :     {
; 2181 :         if (z_bit == 0)

  003f6	83 7c 24 6c 00	 cmp	 DWORD PTR z_bit$[rsp], 0
  003fb	75 3c		 jne	 SHORT $LN27@z900_rotat

; 2182 :         {
; 2183 :             regs->GR_G( r1 ) = (regs->GR_G( r1 ) & ~mask) | resu;

  003fd	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00402	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mask$[rsp]
  00407	48 f7 d1	 not	 rcx
  0040a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00412	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0041a	48 23 c1	 and	 rax, rcx
  0041d	48 0b 44 24 40	 or	 rax, QWORD PTR resu$[rsp]
  00422	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00427	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0042f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 2184 :         }

  00437	eb 71		 jmp	 SHORT $LN28@z900_rotat
$LN27@z900_rotat:

; 2185 :         else if ((opcode & 0xFC) == 0x50 /*Low*/ )

  00439	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  0043e	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00443	83 f8 50	 cmp	 eax, 80			; 00000050H
  00446	75 1a		 jne	 SHORT $LN29@z900_rotat

; 2186 :         {
; 2187 :             regs->GR_L( r1 ) = (U32) resu;

  00448	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  0044d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	8b 54 24 40	 mov	 edx, DWORD PTR resu$[rsp]
  00459	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2188 :         }

  00460	eb 48		 jmp	 SHORT $LN30@z900_rotat
$LN29@z900_rotat:

; 2189 :         else if ((opcode & 0xFC) == 0x5C /*High*/ )

  00462	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00467	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  0046c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0046f	75 1f		 jne	 SHORT $LN31@z900_rotat

; 2190 :         {
; 2191 :             regs->GR_H( r1 ) = (U32) (resu >> 32);

  00471	48 8b 44 24 40	 mov	 rax, QWORD PTR resu$[rsp]
  00476	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0047a	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0047f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00487	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2192 :         }

  0048e	eb 1a		 jmp	 SHORT $LN32@z900_rotat
$LN31@z900_rotat:

; 2193 :         else
; 2194 :             regs->GR_G( r1 ) = resu;

  00490	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00495	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049d	48 8b 54 24 40	 mov	 rdx, QWORD PTR resu$[rsp]
  004a2	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
$LN32@z900_rotat:
$LN30@z900_rotat:
$LN28@z900_rotat:
$LN26@z900_rotat:

; 2195 :     }
; 2196 : 
; 2197 :     /* For RISBHG, RISBLG the condition code remains unchanged.
; 2198 :        For RISBGN the condition code remains unchanged.
; 2199 :        For RISBG set condition code according to signed result.
; 2200 :     */
; 2201 :     if (opcode == 0x55) // (RISBG?)

  004aa	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  004af	83 f8 55	 cmp	 eax, 85			; 00000055H
  004b2	75 64		 jne	 SHORT $LN33@z900_rotat

; 2202 :         regs->psw.cc =

  004b4	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c1	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  004ca	7d 0a		 jge	 SHORT $LN41@z900_rotat
  004cc	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv259[rsp], 1
  004d4	eb 32		 jmp	 SHORT $LN42@z900_rotat
$LN41@z900_rotat:
  004d6	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  004db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  004ec	7e 0a		 jle	 SHORT $LN39@z900_rotat
  004ee	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv258[rsp], 2
  004f6	eb 08		 jmp	 SHORT $LN40@z900_rotat
$LN39@z900_rotat:
  004f8	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
$LN40@z900_rotat:
  00500	8b 44 24 70	 mov	 eax, DWORD PTR tv258[rsp]
  00504	89 44 24 74	 mov	 DWORD PTR tv259[rsp], eax
$LN42@z900_rotat:
  00508	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00510	0f b6 4c 24 74	 movzx	 ecx, BYTE PTR tv259[rsp]
  00515	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN33@z900_rotat:

; 2203 :                 (((S64) regs->GR_G( r1 )) < 0) ? 1 :
; 2204 :                 (((S64) regs->GR_G( r1 )) > 0) ? 2 : 0;
; 2205 : 
; 2206 : } /* end DEF_INST( rotate_then_xxx_selected_bits_long_reg ) */

  00518	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0051f	c3		 ret	 0
$LN43@z900_rotat:
  00520	00 00 00 00	 DD	 $LN18@z900_rotat
  00524	00 00 00 00	 DD	 $LN24@z900_rotat
  00528	00 00 00 00	 DD	 $LN24@z900_rotat
  0052c	00 00 00 00	 DD	 $LN17@z900_rotat
  00530	00 00 00 00	 DD	 $LN19@z900_rotat
  00534	00 00 00 00	 DD	 $LN22@z900_rotat
  00538	00 00 00 00	 DD	 $LN23@z900_rotat
  0053c	00 00 00 00	 DD	 $LN24@z900_rotat
  00540	00 00 00 00	 DD	 $LN21@z900_rotat
  00544	00 00 00 00	 DD	 $LN24@z900_rotat
  00548	00 00 00 00	 DD	 $LN24@z900_rotat
  0054c	00 00 00 00	 DD	 $LN24@z900_rotat
  00550	00 00 00 00	 DD	 $LN20@z900_rotat
z900_rotate_then_xxx_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 48
opcode$ = 49
disp$1 = 52
b1$ = 56
effective_addr1$ = 64
temp$2 = 72
cc$ = 76
tv91 = 80
tv160 = 84
tv180 = 88
result$ = 96
n$ = 104
rc$ = 112
m1$ = 120
new$ = 128
old$ = 136
inst$ = 160
regs$ = 168
z900_perform_interlocked_long_storage_immediate PROC

; 113  : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 114  : BYTE    opcode;                         /* 2nd byte of opcode        */
; 115  : BYTE    i2;                             /* Immediate byte            */
; 116  : int     b1;                             /* Base of effective addr    */
; 117  : VADR    effective_addr1;                /* Effective address         */
; 118  : BYTE    *m1;                            /* Mainstor address          */
; 119  : U64     n;                              /* 64-bit operand value      */
; 120  : U64     result;                         /* Result value              */
; 121  : U64     old, new;                       /* Values for cmpxchg4       */
; 122  : int     cc;                             /* Condition code            */
; 123  : int     rc;                             /* Return code               */
; 124  : 
; 125  :     SIY(inst, regs, i2, b1, effective_addr1);

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 48	 mov	 DWORD PTR temp$2[rsp], eax
  00029	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr1$[rsp], 0
  00032	8b 44 24 48	 mov	 eax, DWORD PTR temp$2[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
  0003f	8b 44 24 48	 mov	 eax, DWORD PTR temp$2[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  0004d	8b 44 24 48	 mov	 eax, DWORD PTR temp$2[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00059	88 44 24 30	 mov	 BYTE PTR i2$[rsp], al
  0005d	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00062	74 25		 je	 SHORT $LN10@z900_perfo
  00064	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00069	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0007e	48 03 c8	 add	 rcx, rax
  00081	48 8b c1	 mov	 rax, rcx
  00084	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN10@z900_perfo:
  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	48 6b c0 04	 imul	 rax, rax, 4
  00092	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN21@z900_perfo
  000a2	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN22@z900_perfo
$LN21@z900_perfo:
  000ac	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN22@z900_perfo:
  000b4	83 7c 24 50 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b9	74 3e		 je	 SHORT $LN11@z900_perfo
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d0	c1 e0 0c	 shl	 eax, 12
  000d3	8b 4c 24 34	 mov	 ecx, DWORD PTR disp$1[rsp]
  000d7	0b c8		 or	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
  000df	8b 44 24 34	 mov	 eax, DWORD PTR disp$1[rsp]
  000e3	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e8	85 c0		 test	 eax, eax
  000ea	74 0d		 je	 SHORT $LN12@z900_perfo
  000ec	8b 44 24 34	 mov	 eax, DWORD PTR disp$1[rsp]
  000f0	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f5	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
$LN12@z900_perfo:
$LN11@z900_perfo:
  000f9	48 63 44 24 34	 movsxd	 rax, DWORD PTR disp$1[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00103	48 03 c8	 add	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0010e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00122	48 23 c8	 and	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN4@z900_perfo:
  0012d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00135	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00139	48 83 c0 06	 add	 rax, 6
  0013d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00149	33 c0		 xor	 eax, eax
  0014b	83 f8 06	 cmp	 eax, 6
  0014e	74 0f		 je	 SHORT $LN13@z900_perfo
  00150	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_perfo:
  0015f	33 c0		 xor	 eax, eax
  00161	85 c0		 test	 eax, eax
  00163	75 c8		 jne	 SHORT $LN4@z900_perfo

; 126  :     PER_ZEROADDR_XCHECK( regs, b1 );

  00165	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00169	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 127  : 
; 128  :     /* Extract second byte of instruction opcode */
; 129  :     opcode = inst[5];

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 05	 imul	 rax, rax, 5
  0017f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00187	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018b	88 44 24 31	 mov	 BYTE PTR opcode$[rsp], al

; 130  : 
; 131  :     /* Get mainstor address of storage operand */
; 132  :     m1 = MADDRL (effective_addr1, 8, b1, regs, ACCTYPE_WRITE, regs->psw.pkey);

  0018f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0019b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0019f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001a7	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001af	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  001b4	ba 08 00 00 00	 mov	 edx, 8
  001b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001be	e8 00 00 00 00	 call	 z900_maddr_l
  001c3	48 89 44 24 78	 mov	 QWORD PTR m1$[rsp], rax
$LN7@z900_perfo:

; 133  : 
; 134  :     do {
; 135  :         /* Load 64-bit operand from operand address */
; 136  :         n = ARCH_DEP(vfetch8) (effective_addr1, b1, regs);

  001c8	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d0	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001d9	e8 00 00 00 00	 call	 z900_vfetch8
  001de	48 89 44 24 68	 mov	 QWORD PTR n$[rsp], rax

; 137  : 
; 138  :         switch (opcode) {

  001e3	0f b6 44 24 31	 movzx	 eax, BYTE PTR opcode$[rsp]
  001e8	88 44 24 54	 mov	 BYTE PTR tv160[rsp], al
  001ec	80 7c 24 54 7a	 cmp	 BYTE PTR tv160[rsp], 122 ; 0000007aH
  001f1	74 09		 je	 SHORT $LN14@z900_perfo
  001f3	80 7c 24 54 7e	 cmp	 BYTE PTR tv160[rsp], 126 ; 0000007eH
  001f8	74 20		 je	 SHORT $LN15@z900_perfo
  001fa	eb 6e		 jmp	 SHORT $LN16@z900_perfo
$LN14@z900_perfo:

; 139  :         case 0x7A: /* Add Long Storage Immediate */
; 140  :             /* Add signed operands and set condition code */
; 141  :             cc = add_signed_long (&result, n, (S64)(S8)i2);

  001fc	48 0f be 44 24
	30		 movsx	 rax, BYTE PTR i2$[rsp]
  00202	4c 8b c0	 mov	 r8, rax
  00205	48 8b 54 24 68	 mov	 rdx, QWORD PTR n$[rsp]
  0020a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR result$[rsp]
  0020f	e8 00 00 00 00	 call	 add_signed_long
  00214	89 44 24 4c	 mov	 DWORD PTR cc$[rsp], eax

; 142  :             break;

  00218	eb 61		 jmp	 SHORT $LN8@z900_perfo
$LN15@z900_perfo:

; 143  :         case 0x7E: /* Add Logical Long Storage with Signed Immediate */
; 144  :             /* Add operands and set condition code */
; 145  :             cc = (S8)i2 < 0 ?

  0021a	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  0021f	85 c0		 test	 eax, eax
  00221	7d 21		 jge	 SHORT $LN23@z900_perfo
  00223	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  00228	f7 d8		 neg	 eax
  0022a	48 98		 cdqe
  0022c	4c 8b c0	 mov	 r8, rax
  0022f	48 8b 54 24 68	 mov	 rdx, QWORD PTR n$[rsp]
  00234	48 8d 4c 24 60	 lea	 rcx, QWORD PTR result$[rsp]
  00239	e8 00 00 00 00	 call	 sub_logical_long
  0023e	89 44 24 58	 mov	 DWORD PTR tv180[rsp], eax
  00242	eb 1c		 jmp	 SHORT $LN24@z900_perfo
$LN23@z900_perfo:
  00244	48 0f be 44 24
	30		 movsx	 rax, BYTE PTR i2$[rsp]
  0024a	4c 8b c0	 mov	 r8, rax
  0024d	48 8b 54 24 68	 mov	 rdx, QWORD PTR n$[rsp]
  00252	48 8d 4c 24 60	 lea	 rcx, QWORD PTR result$[rsp]
  00257	e8 00 00 00 00	 call	 add_logical_long
  0025c	89 44 24 58	 mov	 DWORD PTR tv180[rsp], eax
$LN24@z900_perfo:
  00260	8b 44 24 58	 mov	 eax, DWORD PTR tv180[rsp]
  00264	89 44 24 4c	 mov	 DWORD PTR cc$[rsp], eax

; 146  :                 sub_logical_long (&result, n, (S64)(-(S8)i2)) :
; 147  :                 add_logical_long (&result, n, (S64)(S8)i2);
; 148  :             break;

  00268	eb 11		 jmp	 SHORT $LN8@z900_perfo
$LN16@z900_perfo:

; 149  :         default: /* To prevent compiler warnings */
; 150  :             result = 0;

  0026a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 151  :             cc = 0;

  00273	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@z900_perfo:

; 152  :         } /* end switch(opcode) */
; 153  : 
; 154  :         /* Regular store if operand is not on a doubleword boundary */
; 155  :         if ((effective_addr1 & 0x07) != 0) {

  0027b	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  00280	48 83 e0 07	 and	 rax, 7
  00284	48 85 c0	 test	 rax, rax
  00287	74 1e		 je	 SHORT $LN17@z900_perfo

; 156  :             ARCH_DEP(vstore8) (result, effective_addr1, b1, regs);

  00289	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00291	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  00296	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  0029b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_vstore8

; 157  :             break;

  002a5	eb 50		 jmp	 SHORT $LN6@z900_perfo
$LN17@z900_perfo:

; 158  :         }
; 159  : 
; 160  :         /* Interlocked exchange if operand is on doubleword boundary */
; 161  :         old = CSWAP64(n);

  002a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  002ac	e8 00 00 00 00	 call	 _byteswap_uint64
  002b1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR old$[rsp], rax

; 162  :         new = CSWAP64(result);

  002b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  002be	e8 00 00 00 00	 call	 _byteswap_uint64
  002c3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR new$[rsp], rax

; 163  : 
; 164  :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 165  :         OBTAIN_MAINLOCK( regs );
; 166  :         {
; 167  :             rc = cmpxchg8( &old, new, m1 );

  002cb	4c 8b 44 24 78	 mov	 r8, QWORD PTR m1$[rsp]
  002d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR new$[rsp]
  002d8	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR old$[rsp]
  002e0	e8 00 00 00 00	 call	 cmpxchg8_x86
  002e5	0f b6 c0	 movzx	 eax, al
  002e8	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 168  :         }
; 169  :         RELEASE_MAINLOCK( regs );
; 170  : 
; 171  :     } while (rc != 0);

  002ec	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  002f1	0f 85 d1 fe ff
	ff		 jne	 $LN7@z900_perfo
$LN6@z900_perfo:

; 172  : 
; 173  :     /* Set condition code in PSW */
; 174  :     regs->psw.cc = cc;

  002f7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ff	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00304	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 175  : 
; 176  : } /* end DEF_INST(perform_interlocked_long_storage_immediate) */

  00307	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0030e	c3		 ret	 0
z900_perform_interlocked_long_storage_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 48
opcode$ = 49
disp$1 = 52
b1$ = 56
result$ = 60
effective_addr1$ = 64
n$ = 72
temp$2 = 76
cc$ = 80
tv91 = 84
tv160 = 88
tv179 = 92
new$ = 96
old$ = 100
rc$ = 104
m1$ = 112
inst$ = 144
regs$ = 152
z900_perform_interlocked_storage_immediate PROC

; 40   : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 41   : BYTE    opcode;                         /* 2nd byte of opcode        */
; 42   : BYTE    i2;                             /* Immediate byte            */
; 43   : int     b1;                             /* Base of effective addr    */
; 44   : VADR    effective_addr1;                /* Effective address         */
; 45   : BYTE    *m1;                            /* Mainstor address          */
; 46   : U32     n;                              /* 32-bit operand value      */
; 47   : U32     result;                         /* Result value              */
; 48   : U32     old, new;                       /* Values for cmpxchg4       */
; 49   : int     cc;                             /* Condition code            */
; 50   : int     rc;                             /* Return code               */
; 51   : 
; 52   :     SIY(inst, regs, i2, b1, effective_addr1);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 4c	 mov	 DWORD PTR temp$2[rsp], eax
  00029	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr1$[rsp], 0
  00032	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
  0003f	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  0004d	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00059	88 44 24 30	 mov	 BYTE PTR i2$[rsp], al
  0005d	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00062	74 25		 je	 SHORT $LN10@z900_perfo
  00064	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00069	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0007e	48 03 c8	 add	 rcx, rax
  00081	48 8b c1	 mov	 rax, rcx
  00084	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN10@z900_perfo:
  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	48 6b c0 04	 imul	 rax, rax, 4
  00092	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN21@z900_perfo
  000a2	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN22@z900_perfo
$LN21@z900_perfo:
  000ac	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN22@z900_perfo:
  000b4	83 7c 24 54 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b9	74 3e		 je	 SHORT $LN11@z900_perfo
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d0	c1 e0 0c	 shl	 eax, 12
  000d3	8b 4c 24 34	 mov	 ecx, DWORD PTR disp$1[rsp]
  000d7	0b c8		 or	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
  000df	8b 44 24 34	 mov	 eax, DWORD PTR disp$1[rsp]
  000e3	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e8	85 c0		 test	 eax, eax
  000ea	74 0d		 je	 SHORT $LN12@z900_perfo
  000ec	8b 44 24 34	 mov	 eax, DWORD PTR disp$1[rsp]
  000f0	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f5	89 44 24 34	 mov	 DWORD PTR disp$1[rsp], eax
$LN12@z900_perfo:
$LN11@z900_perfo:
  000f9	48 63 44 24 34	 movsxd	 rax, DWORD PTR disp$1[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00103	48 03 c8	 add	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0010e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00122	48 23 c8	 and	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN4@z900_perfo:
  0012d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00135	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00139	48 83 c0 06	 add	 rax, 6
  0013d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00149	33 c0		 xor	 eax, eax
  0014b	83 f8 06	 cmp	 eax, 6
  0014e	74 0f		 je	 SHORT $LN13@z900_perfo
  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@z900_perfo:
  0015f	33 c0		 xor	 eax, eax
  00161	85 c0		 test	 eax, eax
  00163	75 c8		 jne	 SHORT $LN4@z900_perfo

; 53   :     PER_ZEROADDR_XCHECK( regs, b1 );

  00165	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  00169	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 54   : 
; 55   :     /* Extract second byte of instruction opcode */
; 56   :     opcode = inst[5];

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 05	 imul	 rax, rax, 5
  0017f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00187	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018b	88 44 24 31	 mov	 BYTE PTR opcode$[rsp], al

; 57   : 
; 58   :     /* Get mainstor address of storage operand */
; 59   :     m1 = MADDRL (effective_addr1, 4, b1, regs, ACCTYPE_WRITE, regs->psw.pkey);

  0018f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00197	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0019b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0019f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001a7	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001af	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  001b4	ba 04 00 00 00	 mov	 edx, 4
  001b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001be	e8 00 00 00 00	 call	 z900_maddr_l
  001c3	48 89 44 24 70	 mov	 QWORD PTR m1$[rsp], rax
$LN7@z900_perfo:

; 60   : 
; 61   :     do {
; 62   :         /* Load 32-bit operand from operand address */
; 63   :         n = ARCH_DEP(vfetch4) (effective_addr1, b1, regs);

  001c8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d0	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001d9	e8 00 00 00 00	 call	 z900_vfetch4
  001de	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 64   : 
; 65   :         switch (opcode) {

  001e2	0f b6 44 24 31	 movzx	 eax, BYTE PTR opcode$[rsp]
  001e7	88 44 24 58	 mov	 BYTE PTR tv160[rsp], al
  001eb	80 7c 24 58 6a	 cmp	 BYTE PTR tv160[rsp], 106 ; 0000006aH
  001f0	74 09		 je	 SHORT $LN14@z900_perfo
  001f2	80 7c 24 58 6e	 cmp	 BYTE PTR tv160[rsp], 110 ; 0000006eH
  001f7	74 1e		 je	 SHORT $LN15@z900_perfo
  001f9	eb 67		 jmp	 SHORT $LN16@z900_perfo
$LN14@z900_perfo:

; 66   :         case 0x6A: /* Add Storage Immediate */
; 67   :             /* Add signed operands and set condition code */
; 68   :             cc = add_signed (&result, n, (S32)(S8)i2);

  001fb	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  00200	44 8b c0	 mov	 r8d, eax
  00203	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00207	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR result$[rsp]
  0020c	e8 00 00 00 00	 call	 add_signed
  00211	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 69   :             break;

  00215	eb 5b		 jmp	 SHORT $LN8@z900_perfo
$LN15@z900_perfo:

; 70   :         case 0x6E: /* Add Logical Storage with Signed Immediate */
; 71   :             /* Add operands and set condition code */
; 72   :             cc = (S8)i2 < 0 ?

  00217	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  0021c	85 c0		 test	 eax, eax
  0021e	7d 1e		 jge	 SHORT $LN23@z900_perfo
  00220	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  00225	f7 d8		 neg	 eax
  00227	44 8b c0	 mov	 r8d, eax
  0022a	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0022e	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR result$[rsp]
  00233	e8 00 00 00 00	 call	 sub_logical
  00238	89 44 24 5c	 mov	 DWORD PTR tv179[rsp], eax
  0023c	eb 1a		 jmp	 SHORT $LN24@z900_perfo
$LN23@z900_perfo:
  0023e	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  00243	44 8b c0	 mov	 r8d, eax
  00246	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0024a	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR result$[rsp]
  0024f	e8 00 00 00 00	 call	 add_logical
  00254	89 44 24 5c	 mov	 DWORD PTR tv179[rsp], eax
$LN24@z900_perfo:
  00258	8b 44 24 5c	 mov	 eax, DWORD PTR tv179[rsp]
  0025c	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 73   :                 sub_logical (&result, n, (S32)(-(S8)i2)) :
; 74   :                 add_logical (&result, n, (S32)(S8)i2);
; 75   :             break;

  00260	eb 10		 jmp	 SHORT $LN8@z900_perfo
$LN16@z900_perfo:

; 76   :         default: /* To prevent compiler warnings */
; 77   :             result = 0;

  00262	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 78   :             cc = 0;

  0026a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@z900_perfo:

; 79   :         } /* end switch(opcode) */
; 80   : 
; 81   :         /* Regular store if operand is not on a fullword boundary */
; 82   :         if ((effective_addr1 & 0x03) != 0) {

  00272	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  00277	48 83 e0 03	 and	 rax, 3
  0027b	48 85 c0	 test	 rax, rax
  0027e	74 1d		 je	 SHORT $LN17@z900_perfo

; 83   :             ARCH_DEP(vstore4) (result, effective_addr1, b1, regs);

  00280	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00288	44 8b 44 24 38	 mov	 r8d, DWORD PTR b1$[rsp]
  0028d	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  00292	8b 4c 24 3c	 mov	 ecx, DWORD PTR result$[rsp]
  00296	e8 00 00 00 00	 call	 z900_vstore4

; 84   :             break;

  0029b	eb 3f		 jmp	 SHORT $LN6@z900_perfo
$LN17@z900_perfo:

; 85   :         }
; 86   : 
; 87   :         /* Interlocked exchange if operand is on a fullword boundary */
; 88   :         old = CSWAP32(n);

  0029d	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  002a1	e8 00 00 00 00	 call	 _byteswap_ulong
  002a6	89 44 24 64	 mov	 DWORD PTR old$[rsp], eax

; 89   :         new = CSWAP32(result);

  002aa	8b 4c 24 3c	 mov	 ecx, DWORD PTR result$[rsp]
  002ae	e8 00 00 00 00	 call	 _byteswap_ulong
  002b3	89 44 24 60	 mov	 DWORD PTR new$[rsp], eax

; 90   : 
; 91   :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 92   :         OBTAIN_MAINLOCK( regs );
; 93   :         {
; 94   :             rc = cmpxchg4( &old, new, m1 );

  002b7	4c 8b 44 24 70	 mov	 r8, QWORD PTR m1$[rsp]
  002bc	8b 54 24 60	 mov	 edx, DWORD PTR new$[rsp]
  002c0	48 8d 4c 24 64	 lea	 rcx, QWORD PTR old$[rsp]
  002c5	e8 00 00 00 00	 call	 cmpxchg4_x86
  002ca	0f b6 c0	 movzx	 eax, al
  002cd	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 95   :         }
; 96   :         RELEASE_MAINLOCK( regs );
; 97   : 
; 98   :     } while (rc != 0);

  002d1	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  002d6	0f 85 ec fe ff
	ff		 jne	 $LN7@z900_perfo
$LN6@z900_perfo:

; 99   : 
; 100  :     /* Set condition code in PSW */
; 101  :     regs->psw.cc = cc;

  002dc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e4	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR cc$[rsp]
  002e9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 102  : 
; 103  : } /* end DEF_INST(perform_interlocked_storage_immediate) */

  002ec	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002f3	c3		 ret	 0
z900_perform_interlocked_storage_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2 PROC					; COMDAT

; 679  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 01	 and	 rax, 1
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  00063	74 47		 je	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );
; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 02 00 00 00	 mov	 edx, 2
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	e8 00 00 00 00	 call	 _byteswap_ushort
  000aa	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000ac	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000ba	e8 00 00 00 00	 call	 z900_vfetch2_full
$LN1@z900_vfetc:

; 689  : }

  000bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c3	c3		 ret	 0
z900_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
z900_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore2
_TEXT	SEGMENT
tv73 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore2 PROC					; COMDAT

; 541  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 83 e0 01	 and	 rax, 1
  00021	48 85 c0	 test	 rax, rax
  00024	74 1d		 je	 SHORT $LN5@z900_vstor
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  00037	75 0a		 jne	 SHORT $LN5@z900_vstor
  00039	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN5@z900_vstor:
  00043	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN8@z900_vstor:
  0004b	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00050	74 4c		 je	 SHORT $LN2@z900_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00057	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0005b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0005f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00067	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0006c	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00071	ba 02 00 00 00	 mov	 edx, 2
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0007b	e8 00 00 00 00	 call	 z900_maddr_l
  00080	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  00085	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  0008a	e8 00 00 00 00	 call	 _byteswap_ushort
  0008f	0f b7 d0	 movzx	 edx, ax
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00097	e8 00 00 00 00	 call	 store_hw_noswap

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );
; 550  :     }

  0009c	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  0009e	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000ad	0f b7 4c 24 50	 movzx	 ecx, WORD PTR value$[rsp]
  000b2	e8 00 00 00 00	 call	 z900_vstore2_full
$LN3@z900_vstor:

; 553  : }

  000b7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bb	c3		 ret	 0
z900_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004d	c1 e0 08	 shl	 eax, 8
  00050	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0005a	48 ff c0	 inc	 rax
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00072	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00076	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00083	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00088	ba 01 00 00 00	 mov	 edx, 1
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 z900_maddr_l
  00095	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0009f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a2	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  000a7	0b c8		 or	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000b0	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
z900_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
z900_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00018	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00021	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00025	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002d	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00032	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00037	ba 01 00 00 00	 mov	 edx, 1
  0003c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  00041	e8 00 00 00 00	 call	 z900_maddr_l
  00046	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  0004b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00057	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR addr$[rsp]
  00061	48 ff c0	 inc	 rax
  00064	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00070	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00079	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0007d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00085	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0008a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 z900_maddr_l
  0009c	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a9	83 c8 06	 or	 eax, 6
  000ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000b1	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000b3	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000b8	c1 f8 08	 sar	 eax, 8
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000c0	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000c2	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000d1	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000d3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d7	c3		 ret	 0
z900_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
m4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_select_fullword_high_register PROC

; 3461 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3462 : int     r1, r2, r3;                     /* Value of R fields         */
; 3463 : BYTE    m4;                             /* Value of M field          */
; 3464 : 
; 3465 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 20	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_selec:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN5@z900_selec
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_selec:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@z900_selec

; 3466 : 
; 3467 :     /* Test M4 mask bit corresponding to condition code */
; 3468 :     if (m4 & (0x08 >> regs->psw.cc))

  00087	0f b6 44 24 20	 movzx	 eax, BYTE PTR m4$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	0f b6 49 7c	 movzx	 ecx, BYTE PTR [rcx+124]
  00095	ba 08 00 00 00	 mov	 edx, 8
  0009a	d3 fa		 sar	 edx, cl
  0009c	8b ca		 mov	 ecx, edx
  0009e	23 c1		 and	 eax, ecx
  000a0	85 c0		 test	 eax, eax
  000a2	74 25		 je	 SHORT $LN6@z900_selec

; 3469 :     {
; 3470 :         /* Load R1 bits 0-31 with R2 bits 0-31 */
; 3471 :         regs->GR_H(r1) = regs->GR_H(r2);

  000a4	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a9	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ae	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b8	41 8b 84 c0 84
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+644]
  000c0	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 3472 :     }

  000c7	eb 23		 jmp	 SHORT $LN7@z900_selec
$LN6@z900_selec:

; 3473 :     else
; 3474 :     {
; 3475 :         /* Load R1 bits 0-31 with R3 bits 0-31 */
; 3476 :         regs->GR_H(r1) = regs->GR_H(r3);

  000c9	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  000ce	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000d3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000d8	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000dd	41 8b 84 c0 84
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+644]
  000e5	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax
$LN7@z900_selec:

; 3477 :     }
; 3478 : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
z900_select_fullword_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
m4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_select_register_long PROC

; 3438 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3439 : int     r1, r2, r3;                     /* Value of R fields         */
; 3440 : BYTE    m4;                             /* Value of M field          */
; 3441 : 
; 3442 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 20	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_selec:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN5@z900_selec
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_selec:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@z900_selec

; 3443 : 
; 3444 :     /* Test M4 mask bit corresponding to condition code */
; 3445 :     if (m4 & (0x08 >> regs->psw.cc))

  00087	0f b6 44 24 20	 movzx	 eax, BYTE PTR m4$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	0f b6 49 7c	 movzx	 ecx, BYTE PTR [rcx+124]
  00095	ba 08 00 00 00	 mov	 edx, 8
  0009a	d3 fa		 sar	 edx, cl
  0009c	8b ca		 mov	 ecx, edx
  0009e	23 c1		 and	 eax, ecx
  000a0	85 c0		 test	 eax, eax
  000a2	74 26		 je	 SHORT $LN6@z900_selec

; 3446 :     {
; 3447 :         /* Load R1 bits 0-63 with R2 bits 0-63 */
; 3448 :         regs->GR_G(r1) = regs->GR_G(r2);

  000a4	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a9	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ae	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b8	49 8b 84 c0 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax*8+640]
  000c0	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3449 :     }

  000c8	eb 24		 jmp	 SHORT $LN7@z900_selec
$LN6@z900_selec:

; 3450 :     else
; 3451 :     {
; 3452 :         /* Load R1 bits 0-63 with R3 bits 0-63 */
; 3453 :         regs->GR_G(r1) = regs->GR_G(r3);

  000ca	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  000cf	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000d4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000d9	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000de	49 8b 84 c0 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax*8+640]
  000e6	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
$LN7@z900_selec:

; 3454 :     }
; 3455 : }

  000ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f2	c3		 ret	 0
z900_select_register_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
m4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_select_register PROC

; 3415 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3416 : int     r1, r2, r3;                     /* Value of R fields         */
; 3417 : BYTE    m4;                             /* Value of M field          */
; 3418 : 
; 3419 :     RRF_RM( inst, regs, r1, r2, r3, m4 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 08	 shr	 eax, 8
  00043	83 e0 0f	 and	 eax, 15
  00046	88 44 24 20	 mov	 BYTE PTR m4$[rsp], al
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_selec:
  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0c		 je	 SHORT $LN5@z900_selec
  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_selec:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 d1		 jne	 SHORT $LN4@z900_selec

; 3420 : 
; 3421 :     /* Test M4 mask bit corresponding to condition code */
; 3422 :     if (m4 & (0x08 >> regs->psw.cc))

  00087	0f b6 44 24 20	 movzx	 eax, BYTE PTR m4$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	0f b6 49 7c	 movzx	 ecx, BYTE PTR [rcx+124]
  00095	ba 08 00 00 00	 mov	 edx, 8
  0009a	d3 fa		 sar	 edx, cl
  0009c	8b ca		 mov	 ecx, edx
  0009e	23 c1		 and	 eax, ecx
  000a0	85 c0		 test	 eax, eax
  000a2	74 25		 je	 SHORT $LN6@z900_selec

; 3423 :     {
; 3424 :         /* Load R1 bits 32-63 with R2 bits 32-63 */
; 3425 :         regs->GR_L(r1) = regs->GR_L(r2);

  000a4	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a9	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ae	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b8	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  000c0	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3426 :     }

  000c7	eb 23		 jmp	 SHORT $LN7@z900_selec
$LN6@z900_selec:

; 3427 :     else
; 3428 :     {
; 3429 :         /* Load R1 bits 32-63 with R3 bits 32-63 */
; 3430 :         regs->GR_L(r1) = regs->GR_L(r3);

  000c9	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  000ce	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000d3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000d8	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000dd	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  000e5	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN7@z900_selec:

; 3431 :     }
; 3432 : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
z900_select_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
op2$ = 56
x2$ = 60
tv131 = 64
r1$ = 68
resulthi$ = 72
inst$ = 96
regs$ = 104
z900_multiply_long_halfword PROC

; 1870 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1871 : int     r1;                             /* Value of R field          */
; 1872 : int     x2;                             /* Index register            */
; 1873 : int     b2;                             /* Base of effective addr    */
; 1874 : VADR    effective_addr2;                /* Effective address         */
; 1875 : S64     resulthi;                       /* high 64-bits of result    */
; 1876 : S16     op2;                            /* 16-bit operand-2 value    */
; 1877 : 
; 1878 :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 3c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 3c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_multi
  0005c	48 63 44 24 3c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_multi:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_multi
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_multi:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_multi
  000cb	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_multi
$LN14@z900_multi:
  000d5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_multi:
  000dd	83 7c 24 40 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_multi
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_multi
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_multi:
$LN7@z900_multi:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
$LN4@z900_multi:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_multi
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_multi

; 1879 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 3c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 1880 : 
; 1881 :     /* Load signed 16-bit operand-2 value */
; 1882 :     op2 = ARCH_DEP( vfetch2 )( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch2
  001ac	66 89 44 24 38	 mov	 WORD PTR op2$[rsp], ax

; 1883 : 
; 1884 :     /* Multiply R1 register by n, ignore leftmost 64 bits of
; 1885 :        result, and place rightmost 64 bits in R1 register */
; 1886 :     mul_signed_long( &resulthi,

  001b1	48 0f bf 44 24
	38		 movsx	 rax, WORD PTR op2$[rsp]
  001b7	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001bc	48 63 54 24 44	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001c1	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001c6	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  001ce	4c 8b c8	 mov	 r9, rax
  001d1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	4c 8b 84 c8 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx*8+640]
  001de	48 8d 4c 24 48	 lea	 rcx, QWORD PTR resulthi$[rsp]
  001e3	e8 00 00 00 00	 call	 mul_signed_long

; 1887 :                      &(regs->GR_G(r1)),
; 1888 :                        regs->GR_G(r1),
; 1889 :                        op2 );
; 1890 : }

  001e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ec	c3		 ret	 0
z900_multiply_long_halfword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
r1$ = 44
effective_addr2$ = 48
x2$ = 56
tv131 = 60
op2$ = 64
tv183 = 72
inst$ = 96
regs$ = 104
z900_multiply_long PROC

; 1986 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1987 : int     r1;                             /* Value of R field          */
; 1988 : int     x2;                             /* Index register            */
; 1989 : int     b2;                             /* Base of effective addr    */
; 1990 : VADR    effective_addr2;                /* Effective address         */
; 1991 : S64     op2;                            /* Fetched operand-2 value   */
; 1992 : 
; 1993 :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_multi
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_multi:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_multi
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_multi:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_multi
  000cb	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_multi
$LN15@z900_multi:
  000d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_multi:
  000dd	83 7c 24 3c 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_multi
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_multi
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_multi:
$LN7@z900_multi:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
$LN4@z900_multi:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_multi
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_multi

; 1994 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 1995 : 
; 1996 :     ODD_CHECK( r1, regs );

  00199	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0019d	83 e0 01	 and	 eax, 1
  001a0	85 c0		 test	 eax, eax
  001a2	74 15		 je	 SHORT $LN11@z900_multi
  001a4	ba 06 00 00 00	 mov	 edx, 6
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_multi:

; 1997 : 
; 1998 :     /* Fetch 64-bit second operand value from storage */
; 1999 :     op2 = ARCH_DEP( vfetch8 )( effective_addr2, b2, regs );

  001b9	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_vfetch8
  001cc	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 2000 : 
; 2001 :     /* Multiply r1+1 by op2 and place result in r1 and r1+1 */
; 2002 :     mul_signed_long( &(regs->GR_G(r1)),

  001d1	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	ff c0		 inc	 eax
  001d7	48 98		 cdqe
  001d9	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001dd	ff c1		 inc	 ecx
  001df	48 63 c9	 movsxd	 rcx, ecx
  001e2	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001e7	48 8d 8c ca 80
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+640]
  001ef	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001f4	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001f9	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00201	48 89 54 24 48	 mov	 QWORD PTR tv183[rsp], rdx
  00206	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op2$[rsp]
  0020b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00210	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  00218	48 8b d1	 mov	 rdx, rcx
  0021b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv183[rsp]
  00220	48 8b c8	 mov	 rcx, rax
  00223	e8 00 00 00 00	 call	 mul_signed_long

; 2003 :                      &(regs->GR_G(r1+1)),
; 2004 :                        regs->GR_G(r1+1),
; 2005 :                        op2 );
; 2006 : }

  00228	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0022c	c3		 ret	 0
z900_multiply_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
r3$ = 44
tv139 = 48
inst$ = 80
regs$ = 88
z900_multiply_long_register PROC

; 1965 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1966 : int     r1, r2, r3;                     /* Value of R fields         */
; 1967 : 
; 1968 :     RRR( inst, regs, r1, r2, r3 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_multi:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_multi
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_multi:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_multi

; 1969 : 
; 1970 :     ODD_CHECK( r1, regs );

  00079	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0007d	83 e0 01	 and	 eax, 1
  00080	85 c0		 test	 eax, eax
  00082	74 15		 je	 SHORT $LN6@z900_multi
  00084	ba 06 00 00 00	 mov	 edx, 6
  00089	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00093	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_multi:

; 1971 : 
; 1972 :     /* Multiply r2 by r3 and place result in r1 and r1+1 */
; 1973 :     mul_signed_long( &(regs->GR_G(r1)),

  00099	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  0009e	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR r1$[rsp]
  000a7	ff c2		 inc	 edx
  000a9	48 63 d2	 movsxd	 rdx, edx
  000ac	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000b9	4c 63 44 24 24	 movsxd	 r8, DWORD PTR r1$[rsp]
  000be	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000c3	4f 8d 84 c1 80
	02 00 00	 lea	 r8, QWORD PTR [r9+r8*8+640]
  000cb	4c 89 44 24 30	 mov	 QWORD PTR tv139[rsp], r8
  000d0	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000d5	4d 8b 8c c1 80
	02 00 00	 mov	 r9, QWORD PTR [r9+rax*8+640]
  000dd	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	4c 8b 84 c8 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx*8+640]
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR tv139[rsp]
  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 mul_signed_long

; 1974 :                      &(regs->GR_G(r1+1)),
; 1975 :                        regs->GR_G(r3),
; 1976 :                        regs->GR_G(r2) );
; 1977 : }

  000f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fb	c3		 ret	 0
z900_multiply_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
u32$ = 48
tv131 = 52
r1$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_and_zero_rightmost_byte PROC

; 4511 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4512 : int     r1;                             /* Value of R field          */
; 4513 : int     x2;                             /* Index register            */
; 4514 : int     b2;                             /* Base of effective addr    */
; 4515 : VADR    effective_addr2;                /* Effective address         */
; 4516 : U32     u32;                            /* Second operand value      */
; 4517 : 
; 4518 :     /* Decode instruction */
; 4519 :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4520 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4521 : 
; 4522 :     /* Load 32-bit second operand from storage */
; 4523 :     u32 = ARCH_DEP( vfetch4 )( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	89 44 24 30	 mov	 DWORD PTR u32$[rsp], eax

; 4524 : 
; 4525 :     /* Zero rightmost byte */
; 4526 :     u32 &= 0xFFFFFF00UL;

  001b0	8b 44 24 30	 mov	 eax, DWORD PTR u32$[rsp]
  001b4	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  001b9	89 44 24 30	 mov	 DWORD PTR u32$[rsp], eax

; 4527 : 
; 4528 :     /* Place 32-bit result into bits 32-63 of first operand */
; 4529 :     regs->GR_L( r1 ) = u32;

  001bd	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	8b 54 24 30	 mov	 edx, DWORD PTR u32$[rsp]
  001cb	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 4530 : }

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
z900_load_and_zero_rightmost_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
u32$ = 48
tv131 = 52
r1$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_logical_and_zero_rightmost_byte PROC

; 4483 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4484 : int     r1;                             /* Value of R field          */
; 4485 : int     x2;                             /* Index register            */
; 4486 : int     b2;                             /* Base of effective addr    */
; 4487 : VADR    effective_addr2;                /* Effective address         */
; 4488 : U32     u32;                            /* Second operand value      */
; 4489 : 
; 4490 :     /* Decode instruction */
; 4491 :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4492 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4493 : 
; 4494 :     /* Load 64-bit second operand from storage */
; 4495 :     u32 = ARCH_DEP( vfetch4 )( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	89 44 24 30	 mov	 DWORD PTR u32$[rsp], eax

; 4496 : 
; 4497 :     /* Zero rightmost byte */
; 4498 :     u32 &= 0xFFFFFF00UL;

  001b0	8b 44 24 30	 mov	 eax, DWORD PTR u32$[rsp]
  001b4	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  001b9	89 44 24 30	 mov	 DWORD PTR u32$[rsp], eax

; 4499 : 
; 4500 :     /* Place 32-bit result into bits 32-63 of */
; 4501 :     /* first operand and set bits 0-31 to zeros */
; 4502 :     regs->GR_L( r1 ) = u32;

  001bd	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	8b 54 24 30	 mov	 edx, DWORD PTR u32$[rsp]
  001cb	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 4503 :     regs->GR_H( r1 ) = 0;

  001d2	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001dc	c7 84 c1 84 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+644], 0

; 4504 : }

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
z900_load_logical_and_zero_rightmost_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
u64$ = 64
inst$ = 96
regs$ = 104
z900_load_and_zero_rightmost_byte_grande PROC

; 4457 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4458 : int     r1;                             /* Value of R field          */
; 4459 : int     x2;                             /* Index register            */
; 4460 : int     b2;                             /* Base of effective addr    */
; 4461 : VADR    effective_addr2;                /* Effective address         */
; 4462 : U64     u64;                            /* Second operand value      */
; 4463 : 
; 4464 :     /* Decode instruction */
; 4465 :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4466 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4467 : 
; 4468 :     /* Load 64-bit second operand from storage */
; 4469 :     u64 = ARCH_DEP( vfetch8 )( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch8
  001ac	48 89 44 24 40	 mov	 QWORD PTR u64$[rsp], rax

; 4470 : 
; 4471 :     /* Zero rightmost byte */
; 4472 :     u64 &= 0xFFFFFFFFFFFFFF00ULL;

  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR u64$[rsp]
  001b6	48 25 00 ff ff
	ff		 and	 rax, -256		; ffffffffffffff00H
  001bc	48 89 44 24 40	 mov	 QWORD PTR u64$[rsp], rax

; 4473 : 
; 4474 :     /* Place 64-bit result into bits 0-63 of first operand */
; 4475 :     regs->GR_G( r1 ) = u64;

  001c1	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 54 24 40	 mov	 rdx, QWORD PTR u64$[rsp]
  001d0	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4476 : }

  001d8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001dc	c3		 ret	 0
z900_load_and_zero_rightmost_byte_grande ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 48
b2$ = 52
temp$2 = 56
tv92 = 60
tv206 = 64
m3$ = 68
r1$ = 72
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_store_high_on_condition PROC

; 4426 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4427 : int     r1, m3;                         /* Register number, mask     */
; 4428 : int     b2;                             /* Base of effective addr    */
; 4429 : VADR    effective_addr2;                /* Effective address         */
; 4430 : 
; 4431 :     /* Decode instruction */
; 4432 :     RSY( inst, regs, r1, m3, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 38	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_store
  0006a	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN15@z900_store
  000a2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN16@z900_store
$LN15@z900_store:
  000ac	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@z900_store:
  000b4	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_store
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 30	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_store
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_store:
$LN6@z900_store:
  000f6	48 63 44 24 30	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_store
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_store:
$LN4@z900_store:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_store
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_store:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_store

; 4433 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 4434 : 
; 4435 :     /* Test M3 mask bit corresponding to condition code */
; 4436 :     if (m3 & (0x08 >> regs->psw.cc))

  0016b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00170	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	89 4c 24 40	 mov	 DWORD PTR tv206[rsp], ecx
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 44 24 40	 mov	 eax, DWORD PTR tv206[rsp]
  00184	d3 f8		 sar	 eax, cl
  00186	8b 4c 24 44	 mov	 ecx, DWORD PTR m3$[rsp]
  0018a	23 c8		 and	 ecx, eax
  0018c	8b c1		 mov	 eax, ecx
  0018e	85 c0		 test	 eax, eax
  00190	74 27		 je	 SHORT $LN10@z900_store

; 4437 :     {
; 4438 :         /* Store R1 register bits 0-31 at second operand address */
; 4439 :         ARCH_DEP( vstore4 )( regs->GR_H( r1 ), effective_addr2, b2, regs );

  00192	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00197	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0019c	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	8b 8c c1 84 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+644]
  001b2	e8 00 00 00 00	 call	 z900_vstore4

; 4440 :     }

  001b7	eb 2e		 jmp	 SHORT $LN11@z900_store
$LN10@z900_store:

; 4441 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 4442 :     else
; 4443 :         /* TXF requires storage reference regardless of cc */
; 4444 :         MADDRL( effective_addr2, 4, b2, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  001b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001c6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001ce	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  001d3	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001d8	ba 04 00 00 00	 mov	 edx, 4
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001e2	e8 00 00 00 00	 call	 z900_maddr_l
$LN11@z900_store:

; 4445 : #endif
; 4446 : }

  001e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001eb	c3		 ret	 0
z900_store_high_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
tv145 = 36
m3$ = 40
r2$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_high_on_condition_register PROC

; 4321 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4322 : int     r1, r2, m3;                     /* Register numbers, mask    */
; 4323 : 
; 4324 :     /* Decode instruction */
; 4325 :     RRF_M( inst, regs, r1, r2, m3 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_load_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_load_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_load_

; 4326 : 
; 4327 :     /* Test M3 mask bit corresponding to condition code */
; 4328 :     if (m3 & (0x08 >> regs->psw.cc))

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00082	b9 08 00 00 00	 mov	 ecx, 8
  00087	89 4c 24 24	 mov	 DWORD PTR tv145[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 24	 mov	 eax, DWORD PTR tv145[rsp]
  00092	d3 f8		 sar	 eax, cl
  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR m3$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	85 c0		 test	 eax, eax
  0009e	74 23		 je	 SHORT $LN6@z900_load_

; 4329 :     {
; 4330 :         /* Load R1 register bits 0-31 from R2 register bits 0-31 */
; 4331 :         regs->GR_H( r1 ) = regs->GR_H( r2 );

  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000aa	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b4	41 8b 84 c0 84
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+644]
  000bc	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax
$LN6@z900_load_:

; 4332 :     }
; 4333 : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
z900_load_high_on_condition_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
tv92 = 56
tv201 = 60
m3$ = 64
r1$ = 68
data$ = 72
inst$ = 96
regs$ = 104
z900_load_high_on_condition PROC

; 4400 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4401 : int     r1, m3;                         /* Register number, mask     */
; 4402 : int     b2;                             /* Base of effective addr    */
; 4403 : VADR    effective_addr2;                /* Effective address         */
; 4404 : U32     data;
; 4405 : 
; 4406 :     /* Decode instruction */
; 4407 :     RSY( inst, regs, r1, m3, b2, effective_addr2 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_load_
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN14@z900_load_
  000a2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000ac	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@z900_load_:
  000b4	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_load_
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_load_
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_load_:
$LN6@z900_load_:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_load_
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
$LN4@z900_load_:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_load_
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_load_:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_load_

; 4408 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 4409 : 
; 4410 :     /* TXF requires storage reference regardless of cc */
; 4411 :     data = ARCH_DEP( vfetch4 )( effective_addr2, b2, regs );

  0016b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetch4
  0017e	89 44 24 48	 mov	 DWORD PTR data$[rsp], eax

; 4412 : 
; 4413 :     /* Test M3 mask bit corresponding to condition code */
; 4414 :     if (m3 & (0x08 >> regs->psw.cc))

  00182	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00187	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0018b	b9 08 00 00 00	 mov	 ecx, 8
  00190	89 4c 24 3c	 mov	 DWORD PTR tv201[rsp], ecx
  00194	0f b6 c8	 movzx	 ecx, al
  00197	8b 44 24 3c	 mov	 eax, DWORD PTR tv201[rsp]
  0019b	d3 f8		 sar	 eax, cl
  0019d	8b 4c 24 40	 mov	 ecx, DWORD PTR m3$[rsp]
  001a1	23 c8		 and	 ecx, eax
  001a3	8b c1		 mov	 eax, ecx
  001a5	85 c0		 test	 eax, eax
  001a7	74 15		 je	 SHORT $LN10@z900_load_

; 4415 :     {
; 4416 :         /* Load R1 register bits 0-31 from second operand */
; 4417 :         regs->GR_H( r1 ) = data;

  001a9	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	8b 54 24 48	 mov	 edx, DWORD PTR data$[rsp]
  001b7	89 94 c1 84 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+644], edx
$LN10@z900_load_:

; 4418 :     }
; 4419 : }

  001be	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c2	c3		 ret	 0
z900_load_high_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
tv142 = 40
m3$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_halfword_immediate_on_condition_grande PROC

; 4380 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4381 : int     r1, m3;                         /* Register number, mask     */
; 4382 : U16     i2;                             /* 16-bit immediate operand  */
; 4383 : 
; 4384 :     /* Decode instruction */
; 4385 :     RIE( inst, regs, r1, m3, i2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 2c	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_load_
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_load_

; 4386 : 
; 4387 :     /* Test M3 mask bit corresponding to condition code */
; 4388 :     if (m3 & (0x08 >> regs->psw.cc))

  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00085	b9 08 00 00 00	 mov	 ecx, 8
  0008a	89 4c 24 28	 mov	 DWORD PTR tv142[rsp], ecx
  0008e	0f b6 c8	 movzx	 ecx, al
  00091	8b 44 24 28	 mov	 eax, DWORD PTR tv142[rsp]
  00095	d3 f8		 sar	 eax, cl
  00097	8b 4c 24 2c	 mov	 ecx, DWORD PTR m3$[rsp]
  0009b	23 c8		 and	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	85 c0		 test	 eax, eax
  000a1	74 18		 je	 SHORT $LN6@z900_load_

; 4389 :     {
; 4390 :         /* Load R1 register bits 0-63 w/sign extended immediate data */
; 4391 :         regs->GR_G( r1 ) = (S64)((S16)i2);

  000a3	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000a9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ae	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
$LN6@z900_load_:

; 4392 :     }
; 4393 : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
z900_load_halfword_immediate_on_condition_grande ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
tv142 = 40
m3$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_halfword_immediate_on_condition PROC

; 4360 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4361 : int     r1, m3;                         /* Register number, mask     */
; 4362 : U16     i2;                             /* 16-bit immediate operand  */
; 4363 : 
; 4364 :     /* Decode instruction */
; 4365 :     RIE( inst, regs, r1, m3, i2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 2c	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_load_
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_load_

; 4366 : 
; 4367 :     /* Test M3 mask bit corresponding to condition code */
; 4368 :     if (m3 & (0x08 >> regs->psw.cc))

  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00085	b9 08 00 00 00	 mov	 ecx, 8
  0008a	89 4c 24 28	 mov	 DWORD PTR tv142[rsp], ecx
  0008e	0f b6 c8	 movzx	 ecx, al
  00091	8b 44 24 28	 mov	 eax, DWORD PTR tv142[rsp]
  00095	d3 f8		 sar	 eax, cl
  00097	8b 4c 24 2c	 mov	 ecx, DWORD PTR m3$[rsp]
  0009b	23 c8		 and	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	85 c0		 test	 eax, eax
  000a1	74 16		 je	 SHORT $LN6@z900_load_

; 4369 :     {
; 4370 :         /* Load R1 register bits 32-63 w/sign extended immediate data */
; 4371 :         regs->GR_L( r1 ) = (S32)((S16)i2);

  000a3	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000a8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ad	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b2	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN6@z900_load_:

; 4372 :     }
; 4373 : }

  000b9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bd	c3		 ret	 0
z900_load_halfword_immediate_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
tv142 = 40
m3$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_halfword_high_immediate_on_condition PROC

; 4340 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4341 : int     r1, m3;                         /* Register number, mask     */
; 4342 : U16     i2;                             /* 16-bit immediate operand  */
; 4343 : 
; 4344 :     /* Decode instruction */
; 4345 :     RIE( inst, regs, r1, m3, i2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 2c	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_load_
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_load_

; 4346 : 
; 4347 :     /* Test M3 mask bit corresponding to condition code */
; 4348 :     if (m3 & (0x08 >> regs->psw.cc))

  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00085	b9 08 00 00 00	 mov	 ecx, 8
  0008a	89 4c 24 28	 mov	 DWORD PTR tv142[rsp], ecx
  0008e	0f b6 c8	 movzx	 ecx, al
  00091	8b 44 24 28	 mov	 eax, DWORD PTR tv142[rsp]
  00095	d3 f8		 sar	 eax, cl
  00097	8b 4c 24 2c	 mov	 ecx, DWORD PTR m3$[rsp]
  0009b	23 c8		 and	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	85 c0		 test	 eax, eax
  000a1	74 16		 je	 SHORT $LN6@z900_load_

; 4349 :     {
; 4350 :         /* Load R1 register bits 0-31 w/sign extended immediate data */
; 4351 :         regs->GR_H( r1 ) = (S32)((S16)i2);

  000a3	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000a8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ad	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b2	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax
$LN6@z900_load_:

; 4352 :     }
; 4353 : }

  000b9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bd	c3		 ret	 0
z900_load_halfword_high_immediate_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_insert_selected_bits_long_reg_n PROC

; 4244 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4245 :     ARCH_DEP(rotate_then_xxx_selected_bits_long_reg) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 4246 : } /* end DEF_INST(rotate_then_insert_selected_bits_long_reg_n) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_insert_selected_bits_long_reg_n ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
tv92 = 56
r1$ = 60
tv163 = 64
tv164 = 68
cc$ = 72
tv215 = 76
m3$ = 80
n$ = 88
inst$ = 112
regs$ = 120
z900_compare_logical_and_trap_long PROC

; 4210 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4211 : int     r1;                             /* Register number           */
; 4212 : int     b2;                             /* Base of effective addr    */
; 4213 : VADR    effective_addr2;                /* Effective address         */
; 4214 : U64     n;                              /* 64-bit operand value      */
; 4215 : int     m3;                             /* Mask bits                 */
; 4216 : int     cc;                             /* Comparison result         */
; 4217 : 
; 4218 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 50	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_compa
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_compa:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN14@z900_compa
  000a2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000ac	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@z900_compa:
  000b4	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_compa
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_compa
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_compa:
$LN6@z900_compa:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_compa
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_compa
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_compa

; 4219 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 4220 : 
; 4221 :     /* Load second operand from operand address */
; 4222 :     n = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0016b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetch8
  0017e	48 89 44 24 58	 mov	 QWORD PTR n$[rsp], rax

; 4223 : 
; 4224 :     /* Compare unsigned operands and set comparison result */
; 4225 :     cc = regs->GR_G(r1) < n ? 1 :

  00183	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00188	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 54 24 58	 mov	 rdx, QWORD PTR n$[rsp]
  00192	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0019a	73 0a		 jae	 SHORT $LN18@z900_compa
  0019c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  001a4	eb 33		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  001a6	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 54 24 58	 mov	 rdx, QWORD PTR n$[rsp]
  001b5	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  001bd	76 0a		 jbe	 SHORT $LN16@z900_compa
  001bf	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv163[rsp], 2
  001c7	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001c9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN17@z900_compa:
  001d1	8b 44 24 40	 mov	 eax, DWORD PTR tv163[rsp]
  001d5	89 44 24 44	 mov	 DWORD PTR tv164[rsp], eax
$LN19@z900_compa:
  001d9	8b 44 24 44	 mov	 eax, DWORD PTR tv164[rsp]
  001dd	89 44 24 48	 mov	 DWORD PTR cc$[rsp], eax

; 4226 :          regs->GR_G(r1) > n ? 2 : 0;
; 4227 : 
; 4228 :     /* Raise data exception if m3 mask bit is set */
; 4229 :     if ((0x8 >> cc) & m3)

  001e1	8b 44 24 48	 mov	 eax, DWORD PTR cc$[rsp]
  001e5	b9 08 00 00 00	 mov	 ecx, 8
  001ea	89 4c 24 4c	 mov	 DWORD PTR tv215[rsp], ecx
  001ee	0f b6 c8	 movzx	 ecx, al
  001f1	8b 44 24 4c	 mov	 eax, DWORD PTR tv215[rsp]
  001f5	d3 f8		 sar	 eax, cl
  001f7	23 44 24 50	 and	 eax, DWORD PTR m3$[rsp]
  001fb	85 c0		 test	 eax, eax
  001fd	74 1e		 je	 SHORT $LN10@z900_compa

; 4230 :     {
; 4231 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001ff	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00204	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4232 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0020e	ba 07 00 00 00	 mov	 edx, 7
  00213	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_compa:

; 4233 :     }
; 4234 : 
; 4235 : } /* end DEF_INST(compare_logical_and_trap_long) */

  0021d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00221	c3		 ret	 0
z900_compare_logical_and_trap_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
tv92 = 56
r1$ = 60
n$ = 64
tv163 = 68
tv164 = 72
cc$ = 76
tv216 = 80
m3$ = 84
inst$ = 112
regs$ = 120
z900_compare_logical_and_trap PROC

; 4177 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4178 : int     r1;                             /* Register number           */
; 4179 : int     b2;                             /* Base of effective addr    */
; 4180 : VADR    effective_addr2;                /* Effective address         */
; 4181 : U32     n;                              /* 32-bit operand value      */
; 4182 : int     m3;                             /* Mask bits                 */
; 4183 : int     cc;                             /* Comparison result         */
; 4184 : 
; 4185 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 54	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_compa
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_compa:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN14@z900_compa
  000a2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000ac	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@z900_compa:
  000b4	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_compa
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_compa
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_compa:
$LN6@z900_compa:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_compa
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_compa
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_compa

; 4186 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 4187 : 
; 4188 :     /* Load second operand from operand address */
; 4189 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  0016b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetch4
  0017e	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4190 : 
; 4191 :     /* Compare unsigned operands and set comparison result */
; 4192 :     cc = regs->GR_L(r1) < n ? 1 :

  00182	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00187	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018c	8b 54 24 40	 mov	 edx, DWORD PTR n$[rsp]
  00190	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00197	73 0a		 jae	 SHORT $LN18@z900_compa
  00199	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  001a1	eb 31		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  001a3	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	8b 54 24 40	 mov	 edx, DWORD PTR n$[rsp]
  001b1	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  001b8	76 0a		 jbe	 SHORT $LN16@z900_compa
  001ba	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv163[rsp], 2
  001c2	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001c4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN17@z900_compa:
  001cc	8b 44 24 44	 mov	 eax, DWORD PTR tv163[rsp]
  001d0	89 44 24 48	 mov	 DWORD PTR tv164[rsp], eax
$LN19@z900_compa:
  001d4	8b 44 24 48	 mov	 eax, DWORD PTR tv164[rsp]
  001d8	89 44 24 4c	 mov	 DWORD PTR cc$[rsp], eax

; 4193 :          regs->GR_L(r1) > n ? 2 : 0;
; 4194 : 
; 4195 :     /* Raise data exception if m3 mask bit is set */
; 4196 :     if ((0x8 >> cc) & m3)

  001dc	8b 44 24 4c	 mov	 eax, DWORD PTR cc$[rsp]
  001e0	b9 08 00 00 00	 mov	 ecx, 8
  001e5	89 4c 24 50	 mov	 DWORD PTR tv216[rsp], ecx
  001e9	0f b6 c8	 movzx	 ecx, al
  001ec	8b 44 24 50	 mov	 eax, DWORD PTR tv216[rsp]
  001f0	d3 f8		 sar	 eax, cl
  001f2	23 44 24 54	 and	 eax, DWORD PTR m3$[rsp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 1e		 je	 SHORT $LN10@z900_compa

; 4197 :     {
; 4198 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001fa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4199 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00209	ba 07 00 00 00	 mov	 edx, 7
  0020e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_compa:

; 4200 :     }
; 4201 : 
; 4202 : } /* end DEF_INST(compare_logical_and_trap) */

  00218	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0021c	c3		 ret	 0
z900_compare_logical_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_logical_long_thirtyone_and_trap PROC

; 4145 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4146 : int     r1;                             /* Value of R field          */
; 4147 : int     x2;                             /* Index register            */
; 4148 : int     b2;                             /* Base of effective addr    */
; 4149 : VADR    effective_addr2;                /* Effective address         */
; 4150 : 
; 4151 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4152 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4153 : 
; 4154 :     /* Load R1 register from second operand */
; 4155 :     regs->GR_G(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs )

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	0f ba f0 1f	 btr	 eax, 31
  001b0	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b5	8b c0		 mov	 eax, eax
  001b7	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001bc	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 4156 :                                                         & 0x7FFFFFFF;
; 4157 : 
; 4158 :     /* Raise data exception if result is zero */
; 4159 :     if (regs->GR_G(r1) == 0)

  001c4	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  001d7	75 1e		 jne	 SHORT $LN11@z900_load_

; 4160 :     {
; 4161 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001de	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4162 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001e8	ba 07 00 00 00	 mov	 edx, 7
  001ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001f2	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_load_:

; 4163 :     }
; 4164 : 
; 4165 : } /* end DEF_INST(load_logical_long_thirtyone_and_trap) */

  001f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001fb	c3		 ret	 0
z900_load_logical_long_thirtyone_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_logical_long_fullword_and_trap PROC

; 4117 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4118 : int     r1;                             /* Value of R field          */
; 4119 : int     x2;                             /* Index register            */
; 4120 : int     b2;                             /* Base of effective addr    */
; 4121 : VADR    effective_addr2;                /* Effective address         */
; 4122 : 
; 4123 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4124 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4125 : 
; 4126 :     /* Load R1 register from second operand */
; 4127 :     regs->GR_G(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	8b c0		 mov	 eax, eax
  001b3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b8	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 4128 : 
; 4129 :     /* Raise data exception if result is zero */
; 4130 :     if (regs->GR_G(r1) == 0)

  001c0	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  001d3	75 1e		 jne	 SHORT $LN11@z900_load_

; 4131 :     {
; 4132 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001da	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4133 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001e4	ba 07 00 00 00	 mov	 edx, 7
  001e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_load_:

; 4134 :     }
; 4135 : 
; 4136 : } /* end DEF_INST(load_logical_long_fullword_and_trap) */

  001f3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f7	c3		 ret	 0
z900_load_logical_long_fullword_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_fullword_high_and_trap PROC

; 4089 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4090 : int     r1;                             /* Value of R field          */
; 4091 : int     x2;                             /* Index register            */
; 4092 : int     b2;                             /* Base of effective addr    */
; 4093 : VADR    effective_addr2;                /* Effective address         */
; 4094 : 
; 4095 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4096 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4097 : 
; 4098 :     /* Load R1 register bits 0-31 from second operand */
; 4099 :     regs->GR_H(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b6	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 4100 : 
; 4101 :     /* Raise data exception if result is zero */
; 4102 :     if (regs->GR_H(r1) == 0)

  001bd	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	83 bc c1 84 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+644], 0
  001cf	75 1e		 jne	 SHORT $LN11@z900_load_

; 4103 :     {
; 4104 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001d1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4105 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001e0	ba 07 00 00 00	 mov	 edx, 7
  001e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ea	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_load_:

; 4106 :     }
; 4107 : 
; 4108 : } /* end DEF_INST(load_fullword_high_and_trap) */

  001ef	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f3	c3		 ret	 0
z900_load_fullword_high_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_long_and_trap PROC

; 4061 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4062 : int     r1;                             /* Value of R field          */
; 4063 : int     x2;                             /* Index register            */
; 4064 : int     b2;                             /* Base of effective addr    */
; 4065 : VADR    effective_addr2;                /* Effective address         */
; 4066 : 
; 4067 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4068 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4069 : 
; 4070 :     /* Load R1 register from second operand */
; 4071 :     regs->GR_G(r1) = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch8
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b6	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 4072 : 
; 4073 :     /* Raise data exception if result is zero */
; 4074 :     if (regs->GR_G(r1) == 0)

  001be	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c8	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  001d1	75 1e		 jne	 SHORT $LN11@z900_load_

; 4075 :     {
; 4076 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001d3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d8	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4077 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001e2	ba 07 00 00 00	 mov	 edx, 7
  001e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_load_:

; 4078 :     }
; 4079 : 
; 4080 : } /* end DEF_INST(load_long_and_trap) */

  001f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f5	c3		 ret	 0
z900_load_long_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_and_trap PROC

; 4034 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4035 : int     r1;                             /* Value of R field          */
; 4036 : int     x2;                             /* Index register            */
; 4037 : int     b2;                             /* Base of effective addr    */
; 4038 : VADR    effective_addr2;                /* Effective address         */
; 4039 : 
; 4040 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 4041 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 4042 : 
; 4043 :     /* Load R1 register from second operand */
; 4044 :     regs->GR_L(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 4045 : 
; 4046 :     /* Raise data exception if result is zero */
; 4047 :     if (regs->GR_L(r1) == 0)

  001bd	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001cf	75 1e		 jne	 SHORT $LN11@z900_load_

; 4048 :     {
; 4049 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  001d1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 4050 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001e0	ba 07 00 00 00	 mov	 edx, 7
  001e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ea	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_load_:

; 4051 :     }
; 4052 : 
; 4053 : } /* end DEF_INST(load_and_trap) */

  001ef	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f3	c3		 ret	 0
z900_load_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 0
i1$ = 1
i$1 = 4
inst$ = 32
regs$ = 40
z900_next_instruction_access_intent PROC

; 4300 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 4301 : BYTE    i1, i2;                         /* Immediate fields          */
; 4302 : 
; 4303 :     IE(inst, regs, i1, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 20	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 04	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 04	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	88 04 24	 mov	 BYTE PTR i2$[rsp], al
  0002e	8b 44 24 04	 mov	 eax, DWORD PTR i$1[rsp]
  00032	c1 f8 04	 sar	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	88 44 24 01	 mov	 BYTE PTR i1$[rsp], al
$LN4@z900_next_:
  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00045	48 83 c0 04	 add	 rax, 4
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00052	33 c0		 xor	 eax, eax
  00054	83 f8 04	 cmp	 eax, 4
  00057	74 0c		 je	 SHORT $LN5@z900_next_
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_next_:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 d1		 jne	 SHORT $LN4@z900_next_

; 4304 : 
; 4305 :     /* Depending on the model, the CPU may not recognize all of the
; 4306 :        access intents. For access intents that are not recognized by
; 4307 :        the CPU, the NIAI instruction acts as a no-operation */
; 4308 : 
; 4309 : } /* end DEF_INST(next_instruction_access_intent) */

  0006b	48 83 c4 18	 add	 rsp, 24
  0006f	c3		 ret	 0
z900_next_instruction_access_intent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 32
temp$2 = 36
tv84 = 40
tv91 = 44
tv143 = 48
tv150 = 52
offset$3 = 56
ri2$4 = 64
ri3$5 = 68
tv137 = 72
tv164 = 80
m1$ = 88
effective_addr2$ = 96
effective_addr3$ = 104
inst$ = 128
regs$ = 136
z900_branch_prediction_relative_preload PROC

; 4279 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4280 : VADR    effective_addr2;                /* Effective address         */
; 4281 : VADR    effective_addr3;                /* Effective address         */
; 4282 : int     m1;                             /* Mask value                */
; 4283 : 
; 4284 :     MII_A(inst, regs, m1, effective_addr2, effective_addr3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	48 6b c0 01	 imul	 rax, rax, 1
  00041	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00049	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004d	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00051	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00055	c1 f8 04	 sar	 eax, 4
  00058	83 e0 0f	 and	 eax, 15
  0005b	89 44 24 58	 mov	 DWORD PTR m1$[rsp], eax
  0005f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00063	c1 e0 04	 shl	 eax, 4
  00066	8b 4c 24 24	 mov	 ecx, DWORD PTR temp$2[rsp]
  0006a	c1 e9 18	 shr	 ecx, 24
  0006d	0b c1		 or	 eax, ecx
  0006f	89 44 24 40	 mov	 DWORD PTR ri2$4[rsp], eax
  00073	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00077	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0007c	89 44 24 44	 mov	 DWORD PTR ri3$5[rsp], eax
  00080	48 63 44 24 40	 movsxd	 rax, DWORD PTR ri2$4[rsp]
  00085	48 d1 e0	 shl	 rax, 1
  00088	48 89 44 24 38	 mov	 QWORD PTR offset$3[rsp], rax
  0008d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00095	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0009b	83 e0 01	 and	 eax, 1
  0009e	85 c0		 test	 eax, eax
  000a0	75 0a		 jne	 SHORT $LN11@z900_branc
  000a2	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN12@z900_branc
$LN11@z900_branc:
  000ac	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN12@z900_branc:
  000b4	83 7c 24 28 00	 cmp	 DWORD PTR tv84[rsp], 0
  000b9	74 0a		 je	 SHORT $LN15@z900_branc
  000bb	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000c3	eb 08		 jmp	 SHORT $LN16@z900_branc
$LN15@z900_branc:
  000c5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN16@z900_branc:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv91[rsp], 0
  000d2	74 4e		 je	 SHORT $LN17@z900_branc
  000d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  000eb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ef	48 2b c1	 sub	 rax, rcx
  000f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00101	48 03 c8	 add	 rcx, rax
  00104	48 8b c1	 mov	 rax, rcx
  00107	48 03 44 24 38	 add	 rax, QWORD PTR offset$3[rsp]
  0010c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0011b	48 89 44 24 48	 mov	 QWORD PTR tv137[rsp], rax
  00120	eb 28		 jmp	 SHORT $LN18@z900_branc
$LN17@z900_branc:
  00122	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00131	48 03 44 24 38	 add	 rax, QWORD PTR offset$3[rsp]
  00136	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00145	48 89 44 24 48	 mov	 QWORD PTR tv137[rsp], rax
$LN18@z900_branc:
  0014a	48 8b 44 24 48	 mov	 rax, QWORD PTR tv137[rsp]
  0014f	48 89 44 24 60	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00154	48 63 44 24 44	 movsxd	 rax, DWORD PTR ri3$5[rsp]
  00159	48 d1 e0	 shl	 rax, 1
  0015c	48 89 44 24 38	 mov	 QWORD PTR offset$3[rsp], rax
  00161	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	75 0a		 jne	 SHORT $LN19@z900_branc
  00176	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  0017e	eb 08		 jmp	 SHORT $LN20@z900_branc
$LN19@z900_branc:
  00180	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN20@z900_branc:
  00188	83 7c 24 30 00	 cmp	 DWORD PTR tv143[rsp], 0
  0018d	74 0a		 je	 SHORT $LN23@z900_branc
  0018f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  00197	eb 08		 jmp	 SHORT $LN24@z900_branc
$LN23@z900_branc:
  00199	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN24@z900_branc:
  001a1	83 7c 24 34 00	 cmp	 DWORD PTR tv150[rsp], 0
  001a6	74 4e		 je	 SHORT $LN25@z900_branc
  001a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  001bf	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001c3	48 2b c1	 sub	 rax, rcx
  001c6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  001d5	48 03 c8	 add	 rcx, rax
  001d8	48 8b c1	 mov	 rax, rcx
  001db	48 03 44 24 38	 add	 rax, QWORD PTR offset$3[rsp]
  001e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001ef	48 89 44 24 50	 mov	 QWORD PTR tv164[rsp], rax
  001f4	eb 28		 jmp	 SHORT $LN26@z900_branc
$LN25@z900_branc:
  001f6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00205	48 03 44 24 38	 add	 rax, QWORD PTR offset$3[rsp]
  0020a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00219	48 89 44 24 50	 mov	 QWORD PTR tv164[rsp], rax
$LN26@z900_branc:
  0021e	48 8b 44 24 50	 mov	 rax, QWORD PTR tv164[rsp]
  00223	48 89 44 24 68	 mov	 QWORD PTR effective_addr3$[rsp], rax
$LN4@z900_branc:
  00228	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00230	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00234	48 83 c0 06	 add	 rax, 6
  00238	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00240	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00244	33 c0		 xor	 eax, eax
  00246	83 f8 06	 cmp	 eax, 6
  00249	74 0f		 je	 SHORT $LN8@z900_branc
  0024b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00253	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_branc:
  0025a	33 c0		 xor	 eax, eax
  0025c	85 c0		 test	 eax, eax
  0025e	75 c8		 jne	 SHORT $LN4@z900_branc
$LN7@z900_branc:

; 4285 : 
; 4286 :     TXFC_INSTR_CHECK( regs );

  00260	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00268	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0026f	85 c0		 test	 eax, eax
  00271	74 3f		 je	 SHORT $LN9@z900_branc
  00273	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027b	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00281	0f ba e8 0f	 bts	 eax, 15
  00285	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00293	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197247
  0029a	41 b8 0b 00 00
	00		 mov	 r8d, 11
  002a0	ba 02 00 00 00	 mov	 edx, 2
  002a5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_branc:
  002b2	33 c0		 xor	 eax, eax
  002b4	85 c0		 test	 eax, eax
  002b6	75 a8		 jne	 SHORT $LN7@z900_branc

; 4287 : 
; 4288 :     /* Depending on the model, the CPU may not implement
; 4289 :        all of the branch-attribute codes. For codes that
; 4290 :        are not recognized by the CPU, and for reserved
; 4291 :        codes, the BPRP instruction acts as a no-operation */
; 4292 : 
; 4293 : } /* end DEF_INST(branch_prediction_relative_preload) */

  002b8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002bc	c3		 ret	 0
z900_branch_prediction_relative_preload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
b3$ = 36
tv95 = 40
tv134 = 44
effective_addr3$ = 48
ri2$2 = 56
offset$3 = 64
tv148 = 72
m1$ = 80
effective_addr2$ = 88
inst$ = 112
regs$ = 120
z900_branch_prediction_preload PROC

; 4257 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4258 : VADR    effective_addr2;                /* Effective address         */
; 4259 : VADR    effective_addr3;                /* Effective address         */
; 4260 : int     b3;                             /* Base of effective address */
; 4261 : int     m1;                             /* Mask value                */
; 4262 : 
; 4263 :     SMI_A(inst, regs, m1, effective_addr2, b3, effective_addr3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	89 44 24 38	 mov	 DWORD PTR ri2$2[rsp], eax
  00042	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 10	 shr	 eax, 16
  00049	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004e	8b c0		 mov	 eax, eax
  00050	48 89 44 24 30	 mov	 QWORD PTR effective_addr3$[rsp], rax
  00055	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 24	 mov	 DWORD PTR b3$[rsp], eax
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	48 6b c0 01	 imul	 rax, rax, 1
  0006c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00071	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00075	c1 f8 04	 sar	 eax, 4
  00078	83 e0 0f	 and	 eax, 15
  0007b	89 44 24 50	 mov	 DWORD PTR m1$[rsp], eax
  0007f	83 7c 24 24 00	 cmp	 DWORD PTR b3$[rsp], 0
  00084	74 3e		 je	 SHORT $LN8@z900_branc
  00086	48 63 44 24 24	 movsxd	 rax, DWORD PTR b3$[rsp]
  0008b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr3$[rsp]
  0009d	48 03 c8	 add	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 89 44 24 30	 mov	 QWORD PTR effective_addr3$[rsp], rax
  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr3$[rsp]
  000b9	48 23 c8	 and	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	48 89 44 24 30	 mov	 QWORD PTR effective_addr3$[rsp], rax
$LN8@z900_branc:
  000c4	48 63 44 24 38	 movsxd	 rax, DWORD PTR ri2$2[rsp]
  000c9	48 d1 e0	 shl	 rax, 1
  000cc	48 89 44 24 40	 mov	 QWORD PTR offset$3[rsp], rax
  000d1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000dc	83 e0 01	 and	 eax, 1
  000df	85 c0		 test	 eax, eax
  000e1	75 0a		 jne	 SHORT $LN12@z900_branc
  000e3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  000eb	eb 08		 jmp	 SHORT $LN13@z900_branc
$LN12@z900_branc:
  000ed	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN13@z900_branc:
  000f5	83 7c 24 28 00	 cmp	 DWORD PTR tv95[rsp], 0
  000fa	74 0a		 je	 SHORT $LN16@z900_branc
  000fc	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN17@z900_branc
$LN16@z900_branc:
  00106	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN17@z900_branc:
  0010e	83 7c 24 2c 00	 cmp	 DWORD PTR tv134[rsp], 0
  00113	74 42		 je	 SHORT $LN18@z900_branc
  00115	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00126	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012a	48 2b c1	 sub	 rax, rcx
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00139	48 03 c8	 add	 rcx, rax
  0013c	48 8b c1	 mov	 rax, rcx
  0013f	48 03 44 24 40	 add	 rax, QWORD PTR offset$3[rsp]
  00144	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00150	48 89 44 24 48	 mov	 QWORD PTR tv148[rsp], rax
  00155	eb 22		 jmp	 SHORT $LN19@z900_branc
$LN18@z900_branc:
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00163	48 03 44 24 40	 add	 rax, QWORD PTR offset$3[rsp]
  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00174	48 89 44 24 48	 mov	 QWORD PTR tv148[rsp], rax
$LN19@z900_branc:
  00179	48 8b 44 24 48	 mov	 rax, QWORD PTR tv148[rsp]
  0017e	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_branc:
  00183	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00188	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0018c	48 83 c0 06	 add	 rax, 6
  00190	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00199	33 c0		 xor	 eax, eax
  0019b	83 f8 06	 cmp	 eax, 6
  0019e	74 0c		 je	 SHORT $LN9@z900_branc
  001a0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001a5	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_branc:
  001ac	33 c0		 xor	 eax, eax
  001ae	85 c0		 test	 eax, eax
  001b0	75 d1		 jne	 SHORT $LN4@z900_branc
$LN7@z900_branc:

; 4264 : 
; 4265 :     TXFC_INSTR_CHECK( regs );

  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001be	85 c0		 test	 eax, eax
  001c0	74 36		 je	 SHORT $LN10@z900_branc
  001c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001cd	0f ba e8 0f	 bts	 eax, 15
  001d1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001dc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197217
  001e3	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001e9	ba 02 00 00 00	 mov	 edx, 2
  001ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_branc:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 b4		 jne	 SHORT $LN7@z900_branc

; 4266 : 
; 4267 :     /* Depending on the model, the CPU may not implement
; 4268 :        all of the branch-attribute codes. For codes that
; 4269 :        are not recognized by the CPU, and for reserved
; 4270 :        codes, the BPP instruction acts as a no-operation */
; 4271 : 
; 4272 : } /* end DEF_INST(branch_prediction_preload) */

  001fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00202	c3		 ret	 0
z900_branch_prediction_preload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
m3$ = 32
result$ = 40
temp$1 = 48
i$ = 52
n$ = 56
tv137 = 64
r1$ = 68
tv151 = 72
r2$ = 76
mask$ = 80
inst$ = 112
regs$ = 120
z900_population_count PROC

; 3977 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3978 : BYTE    m3;                             /* Optional m3 mask field    */
; 3979 : int     r1, r2;                         /* Values of R fields        */
; 3980 : int     i;                              /* Loop counter              */
; 3981 : U64     n;                              /* Contents of R2 register   */
; 3982 : U64     result = 0;                     /* Result counter            */

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3983 : U64     mask = 0x0101010101010101ULL;   /* Bit mask                  */

  00017	48 b8 01 01 01
	01 01 01 01 01	 mov	 rax, 72340172838076673	; 0101010101010101H
  00021	48 89 44 24 50	 mov	 QWORD PTR mask$[rsp], rax

; 3984 : 
; 3985 :     RRF_M( inst, regs, r1, r2, m3 );

  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@z900_popul:
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0c		 je	 SHORT $LN11@z900_popul
  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_popul:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@z900_popul

; 3986 : 
; 3987 :     /* Load the value to be counted from the R2 register */
; 3988 :     n = regs->GR_G(r2);

  00091	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00096	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a3	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 3989 : 
; 3990 : #if defined( FEATURE_061_MISC_INSTR_EXT_FACILITY_3 )
; 3991 : 
; 3992 :     if (FACILITY_ENABLED( 061_MISC_INSTR_EXT_3, regs ) && (m3 & 0x08))

  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	48 6b c0 07	 imul	 rax, rax, 7
  000b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  000be	83 e0 04	 and	 eax, 4
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 80 00 00
	00		 je	 $LN12@z900_popul
  000c9	0f b6 44 24 20	 movzx	 eax, BYTE PTR m3$[rsp]
  000ce	83 e0 08	 and	 eax, 8
  000d1	85 c0		 test	 eax, eax
  000d3	74 74		 je	 SHORT $LN12@z900_popul

; 3993 :     {
; 3994 :         /* The following algorithm works best when most bits are 0
; 3995 :            and works the same for all data sizes, using 3 arithmetic
; 3996 :            operations and 1 comparison/branch per "1" bit.
; 3997 :         */
; 3998 :         for (; n; result++)

  000d5	eb 0d		 jmp	 SHORT $LN7@z900_popul
$LN5@z900_popul:
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN7@z900_popul:
  000e4	48 83 7c 24 38
	00		 cmp	 QWORD PTR n$[rsp], 0
  000ea	74 1a		 je	 SHORT $LN6@z900_popul

; 3999 :             n &= n - 1;

  000ec	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  000f1	48 ff c8	 dec	 rax
  000f4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  000f9	48 23 c8	 and	 rcx, rax
  000fc	48 8b c1	 mov	 rax, rcx
  000ff	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax
  00104	eb d1		 jmp	 SHORT $LN5@z900_popul
$LN6@z900_popul:

; 4000 : 
; 4001 :         /* Load the result into the R1 register */
; 4002 :         regs->GR_G(r1) = result;

  00106	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  0010b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	48 8b 54 24 28	 mov	 rdx, QWORD PTR result$[rsp]
  00115	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4003 : 
; 4004 :         /* Set condition code 0 if result is zero, or 1 if non-zero */
; 4005 :         regs->psw.cc = (result == 0) ? 0 : 1;

  0011d	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00123	75 0a		 jne	 SHORT $LN14@z900_popul
  00125	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
  0012d	eb 08		 jmp	 SHORT $LN15@z900_popul
$LN14@z900_popul:
  0012f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
$LN15@z900_popul:
  00137	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv137[rsp]
  00141	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4006 :         return;

  00144	e9 88 00 00 00	 jmp	 $LN1@z900_popul
$LN12@z900_popul:

; 4007 :     }
; 4008 : 
; 4009 : #endif /* defined( FEATURE_061_MISC_INSTR_EXT_FACILITY_3 ) */
; 4010 : 
; 4011 :     /* Count the number of 1 bits in each byte */
; 4012 :     for (i=0; i < 8; i++)

  00149	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00151	eb 0a		 jmp	 SHORT $LN10@z900_popul
$LN8@z900_popul:
  00153	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00157	ff c0		 inc	 eax
  00159	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_popul:
  0015d	83 7c 24 34 08	 cmp	 DWORD PTR i$[rsp], 8
  00162	7d 2f		 jge	 SHORT $LN9@z900_popul

; 4013 :     {
; 4014 :         result += n & mask;

  00164	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$[rsp]
  00169	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  0016e	48 23 c8	 and	 rcx, rax
  00171	48 8b c1	 mov	 rax, rcx
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00179	48 03 c8	 add	 rcx, rax
  0017c	48 8b c1	 mov	 rax, rcx
  0017f	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 4015 :         n >>= 1;

  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00189	48 d1 e8	 shr	 rax, 1
  0018c	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 4016 :     }

  00191	eb c0		 jmp	 SHORT $LN8@z900_popul
$LN9@z900_popul:

; 4017 : 
; 4018 :     /* Load the result into the R1 register */
; 4019 :     regs->GR_G(r1) = result;

  00193	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  00198	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	48 8b 54 24 28	 mov	 rdx, QWORD PTR result$[rsp]
  001a2	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4020 : 
; 4021 :     /* Set condition code 0 if result is zero, or 1 if non-zero */
; 4022 :     regs->psw.cc = (result == 0) ? 0 : 1;

  001aa	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  001b0	75 0a		 jne	 SHORT $LN16@z900_popul
  001b2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
  001ba	eb 08		 jmp	 SHORT $LN17@z900_popul
$LN16@z900_popul:
  001bc	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
$LN17@z900_popul:
  001c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv151[rsp]
  001ce	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN1@z900_popul:

; 4023 : 
; 4024 : } /* end DEF_INST(population_count) */

  001d1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d5	c3		 ret	 0
z900_population_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 48
b2$ = 52
temp$2 = 56
tv92 = 60
tv206 = 64
m3$ = 68
r1$ = 72
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_store_on_condition_long PROC

; 3384 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3385 : int     r1;                             /* Value of R field          */
; 3386 : int     m3;                             /* Value of M field          */
; 3387 : int     b2;                             /* Base of effective addr    */
; 3388 : VADR    effective_addr2;                /* Effective address         */
; 3389 : 
; 3390 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 38	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_store
  0006a	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN15@z900_store
  000a2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN16@z900_store
$LN15@z900_store:
  000ac	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@z900_store:
  000b4	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_store
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 30	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_store
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_store:
$LN6@z900_store:
  000f6	48 63 44 24 30	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_store
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_store:
$LN4@z900_store:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_store
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_store:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_store

; 3391 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 3392 : 
; 3393 :     /* Test M3 mask bit corresponding to condition code */
; 3394 :     if (m3 & (0x08 >> regs->psw.cc))

  0016b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00170	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	89 4c 24 40	 mov	 DWORD PTR tv206[rsp], ecx
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 44 24 40	 mov	 eax, DWORD PTR tv206[rsp]
  00184	d3 f8		 sar	 eax, cl
  00186	8b 4c 24 44	 mov	 ecx, DWORD PTR m3$[rsp]
  0018a	23 c8		 and	 ecx, eax
  0018c	8b c1		 mov	 eax, ecx
  0018e	85 c0		 test	 eax, eax
  00190	74 28		 je	 SHORT $LN10@z900_store

; 3395 :     {
; 3396 :         /* Store R1 register bits 0-63 at operand address */
; 3397 :         ARCH_DEP(vstore8) ( regs->GR_G(r1), effective_addr2, b2, regs );

  00192	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00197	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0019c	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001b3	e8 00 00 00 00	 call	 z900_vstore8

; 3398 :     }

  001b8	eb 2e		 jmp	 SHORT $LN11@z900_store
$LN10@z900_store:

; 3399 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 3400 :     else
; 3401 :         /* TXF requires storage reference regardless of cc */
; 3402 :         MADDRL( effective_addr2, 8, b2, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  001ba	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c3	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001c7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001cf	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  001d4	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001d9	ba 08 00 00 00	 mov	 edx, 8
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001e3	e8 00 00 00 00	 call	 z900_maddr_l
$LN11@z900_store:

; 3403 : #endif
; 3404 : }

  001e8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ec	c3		 ret	 0
z900_store_on_condition_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 48
b2$ = 52
temp$2 = 56
tv92 = 60
tv206 = 64
m3$ = 68
r1$ = 72
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_store_on_condition PROC

; 3356 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3357 : int     r1;                             /* Value of R field          */
; 3358 : int     m3;                             /* Value of M field          */
; 3359 : int     b2;                             /* Base of effective addr    */
; 3360 : VADR    effective_addr2;                /* Effective address         */
; 3361 : 
; 3362 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 38	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 38	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_store
  0006a	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN15@z900_store
  000a2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN16@z900_store
$LN15@z900_store:
  000ac	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@z900_store:
  000b4	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_store
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 30	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_store
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 30	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_store:
$LN6@z900_store:
  000f6	48 63 44 24 30	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_store
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_store:
$LN4@z900_store:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_store
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_store:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_store

; 3363 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 3364 : 
; 3365 :     /* Test M3 mask bit corresponding to condition code */
; 3366 :     if (m3 & (0x08 >> regs->psw.cc))

  0016b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00170	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	89 4c 24 40	 mov	 DWORD PTR tv206[rsp], ecx
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 44 24 40	 mov	 eax, DWORD PTR tv206[rsp]
  00184	d3 f8		 sar	 eax, cl
  00186	8b 4c 24 44	 mov	 ecx, DWORD PTR m3$[rsp]
  0018a	23 c8		 and	 ecx, eax
  0018c	8b c1		 mov	 eax, ecx
  0018e	85 c0		 test	 eax, eax
  00190	74 27		 je	 SHORT $LN10@z900_store

; 3367 :     {
; 3368 :         /* Store R1 register bits 32-63 at operand address */
; 3369 :         ARCH_DEP(vstore4) ( regs->GR_L(r1), effective_addr2, b2, regs );

  00192	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00197	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0019c	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001b2	e8 00 00 00 00	 call	 z900_vstore4

; 3370 :     }

  001b7	eb 2e		 jmp	 SHORT $LN11@z900_store
$LN10@z900_store:

; 3371 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 3372 :     else
; 3373 :         /* TXF requires storage reference regardless of cc */
; 3374 :         MADDRL( effective_addr2, 4, b2, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  001b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001c6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001ce	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  001d3	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  001d8	ba 04 00 00 00	 mov	 edx, 4
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001e2	e8 00 00 00 00	 call	 z900_maddr_l
$LN11@z900_store:

; 3375 : #endif
; 3376 : }

  001e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001eb	c3		 ret	 0
z900_store_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
tv92 = 56
tv200 = 60
m3$ = 64
r1$ = 68
data$ = 72
inst$ = 96
regs$ = 104
z900_load_on_condition_long PROC

; 3329 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3330 : int     r1;                             /* Value of R field          */
; 3331 : int     m3;                             /* Value of M field          */
; 3332 : int     b2;                             /* Base of effective addr    */
; 3333 : VADR    effective_addr2;                /* Effective address         */
; 3334 : U64     data;
; 3335 : 
; 3336 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_load_
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN14@z900_load_
  000a2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000ac	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@z900_load_:
  000b4	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_load_
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_load_
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_load_:
$LN6@z900_load_:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_load_
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
$LN4@z900_load_:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_load_
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_load_:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_load_

; 3337 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 3338 : 
; 3339 :     /* TXF requires storage reference regardless of cc */
; 3340 :     data = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0016b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetch8
  0017e	48 89 44 24 48	 mov	 QWORD PTR data$[rsp], rax

; 3341 : 
; 3342 :     /* Test M3 mask bit corresponding to condition code */
; 3343 :     if (m3 & (0x08 >> regs->psw.cc))

  00183	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00188	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0018c	b9 08 00 00 00	 mov	 ecx, 8
  00191	89 4c 24 3c	 mov	 DWORD PTR tv200[rsp], ecx
  00195	0f b6 c8	 movzx	 ecx, al
  00198	8b 44 24 3c	 mov	 eax, DWORD PTR tv200[rsp]
  0019c	d3 f8		 sar	 eax, cl
  0019e	8b 4c 24 40	 mov	 ecx, DWORD PTR m3$[rsp]
  001a2	23 c8		 and	 ecx, eax
  001a4	8b c1		 mov	 eax, ecx
  001a6	85 c0		 test	 eax, eax
  001a8	74 17		 je	 SHORT $LN10@z900_load_

; 3344 :     {
; 3345 :         /* Load R1 register bits 0-63 from second operand */
; 3346 :         regs->GR_G(r1) = data;

  001aa	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  001af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR data$[rsp]
  001b9	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
$LN10@z900_load_:

; 3347 :     }
; 3348 : }

  001c1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c5	c3		 ret	 0
z900_load_on_condition_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
tv92 = 56
tv201 = 60
m3$ = 64
r1$ = 68
data$ = 72
inst$ = 96
regs$ = 104
z900_load_on_condition PROC

; 3302 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3303 : int     r1;                             /* Value of R field          */
; 3304 : int     m3;                             /* Value of M field          */
; 3305 : int     b2;                             /* Base of effective addr    */
; 3306 : VADR    effective_addr2;                /* Effective address         */
; 3307 : U32     data;
; 3308 : 
; 3309 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_load_
  0006a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN14@z900_load_
  000a2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000ac	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@z900_load_:
  000b4	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_load_
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_load_
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_load_:
$LN6@z900_load_:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_load_
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
$LN4@z900_load_:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_load_
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_load_:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_load_

; 3310 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0015d	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00161	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 3311 : 
; 3312 :     /* TXF requires storage reference regardless of cc */
; 3313 :     data = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  0016b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00170	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetch4
  0017e	89 44 24 48	 mov	 DWORD PTR data$[rsp], eax

; 3314 : 
; 3315 :     /* Test M3 mask bit corresponding to condition code */
; 3316 :     if (m3 & (0x08 >> regs->psw.cc))

  00182	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00187	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0018b	b9 08 00 00 00	 mov	 ecx, 8
  00190	89 4c 24 3c	 mov	 DWORD PTR tv201[rsp], ecx
  00194	0f b6 c8	 movzx	 ecx, al
  00197	8b 44 24 3c	 mov	 eax, DWORD PTR tv201[rsp]
  0019b	d3 f8		 sar	 eax, cl
  0019d	8b 4c 24 40	 mov	 ecx, DWORD PTR m3$[rsp]
  001a1	23 c8		 and	 ecx, eax
  001a3	8b c1		 mov	 eax, ecx
  001a5	85 c0		 test	 eax, eax
  001a7	74 15		 je	 SHORT $LN10@z900_load_

; 3317 :     {
; 3318 :         /* Load R1 register bits 32-63 from second operand */
; 3319 :         regs->GR_L(r1) = data;

  001a9	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	8b 54 24 48	 mov	 edx, DWORD PTR data$[rsp]
  001b7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx
$LN10@z900_load_:

; 3320 :     }
; 3321 : }

  001be	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c2	c3		 ret	 0
z900_load_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
tv145 = 36
m3$ = 40
r2$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_on_condition_long_register PROC

; 3281 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3282 : int     r1, r2;                         /* Values of R fields        */
; 3283 : int     m3;                             /* Value of M field          */
; 3284 : 
; 3285 :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_load_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_load_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_load_

; 3286 : 
; 3287 :     /* Test M3 mask bit corresponding to condition code */
; 3288 :     if (m3 & (0x08 >> regs->psw.cc))

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00082	b9 08 00 00 00	 mov	 ecx, 8
  00087	89 4c 24 24	 mov	 DWORD PTR tv145[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 24	 mov	 eax, DWORD PTR tv145[rsp]
  00092	d3 f8		 sar	 eax, cl
  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR m3$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	85 c0		 test	 eax, eax
  0009e	74 24		 je	 SHORT $LN6@z900_load_

; 3289 :     {
; 3290 :         /* Copy R2 register bits 0-63 to R1 register */
; 3291 :         regs->GR_G(r1) = regs->GR_G(r2);

  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000aa	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b4	49 8b 84 c0 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax*8+640]
  000bc	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
$LN6@z900_load_:

; 3292 :     }
; 3293 : 
; 3294 : } /* end DEF_INST(load_on_condition_long_register) */

  000c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c8	c3		 ret	 0
z900_load_on_condition_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
tv145 = 36
m3$ = 40
r2$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
z900_load_on_condition_register PROC

; 3260 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3261 : int     r1, r2;                         /* Values of R fields        */
; 3262 : int     m3;                             /* Value of M field          */
; 3263 : 
; 3264 :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_load_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_load_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_load_

; 3265 : 
; 3266 :     /* Test M3 mask bit corresponding to condition code */
; 3267 :     if (m3 & (0x08 >> regs->psw.cc))

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00082	b9 08 00 00 00	 mov	 ecx, 8
  00087	89 4c 24 24	 mov	 DWORD PTR tv145[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 24	 mov	 eax, DWORD PTR tv145[rsp]
  00092	d3 f8		 sar	 eax, cl
  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR m3$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	85 c0		 test	 eax, eax
  0009e	74 23		 je	 SHORT $LN6@z900_load_

; 3268 :     {
; 3269 :         /* Copy R2 register bits 32-63 to R1 register */
; 3270 :         regs->GR_L(r1) = regs->GR_L(r2);

  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000aa	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b4	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  000bc	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN6@z900_load_:

; 3271 :     }
; 3272 : 
; 3273 : } /* end DEF_INST(load_on_condition_register) */

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
z900_load_on_condition_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
b1$ = 32
b2$ = 36
temp$1 = 40
r3$ = 44
effective_addr1$ = 48
effective_addr2$ = 56
tv188 = 64
v1$ = 72
v2$ = 80
w1$ = 88
w2$ = 96
inst$ = 128
regs$ = 136
z900_load_pair_disjoint_long PROC

; 3218 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3219 : int     r3;                             /* Register number           */
; 3220 : int     b1, b2;                         /* Base register numbers     */
; 3221 : VADR    effective_addr1,
; 3222 :         effective_addr2;                /* Effective addresses       */
; 3223 : U64     v1, v2;                         /* Operand values            */
; 3224 : U64     w1, w2;                         /* Refetched values          */
; 3225 : 
; 3226 :     SSF(inst, regs, b1, effective_addr1, b2, effective_addr2, r3);

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00016	48 83 c0 02	 add	 rax, 2
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 _byteswap_ulong
  00029	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 01	 imul	 rax, rax, 1
  00036	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	c1 f8 04	 sar	 eax, 4
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
  0004c	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00055	8b c0		 mov	 eax, eax
  00057	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0005c	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00060	c1 e8 0c	 shr	 eax, 12
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  0006a	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006e	c1 e8 10	 shr	 eax, 16
  00071	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00076	8b c0		 mov	 eax, eax
  00078	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0007d	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00081	c1 e8 1c	 shr	 eax, 28
  00084	83 e0 0f	 and	 eax, 15
  00087	89 44 24 20	 mov	 DWORD PTR b1$[rsp], eax
  0008b	83 7c 24 20 00	 cmp	 DWORD PTR b1$[rsp], 0
  00090	74 44		 je	 SHORT $LN8@z900_load_
  00092	48 63 44 24 20	 movsxd	 rax, DWORD PTR b1$[rsp]
  00097	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000b7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000cb	48 23 c8	 and	 rcx, rax
  000ce	48 8b c1	 mov	 rax, rcx
  000d1	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_load_:
  000d6	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  000db	74 44		 je	 SHORT $LN9@z900_load_
  000dd	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  000e2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00102	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00111	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00116	48 23 c8	 and	 rcx, rax
  00119	48 8b c1	 mov	 rax, rcx
  0011c	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00121	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00129	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012d	48 83 c0 06	 add	 rax, 6
  00131	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013d	33 c0		 xor	 eax, eax
  0013f	83 f8 06	 cmp	 eax, 6
  00142	74 0f		 je	 SHORT $LN10@z900_load_
  00144	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00153	33 c0		 xor	 eax, eax
  00155	85 c0		 test	 eax, eax
  00157	75 c8		 jne	 SHORT $LN4@z900_load_

; 3227 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00159	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  0015e	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  00162	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_load_:

; 3228 : 
; 3229 :     TXFC_INSTR_CHECK( regs );

  0016f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00177	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0017e	85 c0		 test	 eax, eax
  00180	74 3f		 je	 SHORT $LN11@z900_load_
  00182	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00190	0f ba e8 0f	 bts	 eax, 15
  00194	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196496
  001a9	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001af	ba 02 00 00 00	 mov	 edx, 2
  001b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_load_:
  001c1	33 c0		 xor	 eax, eax
  001c3	85 c0		 test	 eax, eax
  001c5	75 a8		 jne	 SHORT $LN7@z900_load_

; 3230 :     ODD_CHECK(r3, regs);

  001c7	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001cb	83 e0 01	 and	 eax, 1
  001ce	85 c0		 test	 eax, eax
  001d0	74 1b		 je	 SHORT $LN12@z900_load_
  001d2	ba 06 00 00 00	 mov	 edx, 6
  001d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:

; 3231 : 
; 3232 :     /* Fetch the values of the storage operands */
; 3233 :     v1 = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  001ed	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f5	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  001f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001fe	e8 00 00 00 00	 call	 z900_vfetch8
  00203	48 89 44 24 48	 mov	 QWORD PTR v1$[rsp], rax

; 3234 :     v2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00208	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00210	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00214	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00219	e8 00 00 00 00	 call	 z900_vfetch8
  0021e	48 89 44 24 50	 mov	 QWORD PTR v2$[rsp], rax

; 3235 : 
; 3236 :     /* Fetch operands again to check for alteration by another CPU */
; 3237 :     w1 = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  00223	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022b	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  0022f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00234	e8 00 00 00 00	 call	 z900_vfetch8
  00239	48 89 44 24 58	 mov	 QWORD PTR w1$[rsp], rax

; 3238 :     w2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0023e	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00246	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  0024a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0024f	e8 00 00 00 00	 call	 z900_vfetch8
  00254	48 89 44 24 60	 mov	 QWORD PTR w2$[rsp], rax

; 3239 : 
; 3240 :     /* Load R3 register from first storage operand */
; 3241 :     regs->GR_G(r3) = v1;

  00259	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  0025e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 8b 54 24 48	 mov	 rdx, QWORD PTR v1$[rsp]
  0026b	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3242 : 
; 3243 :     /* Load R3+1 register from second storage operand */
; 3244 :     regs->GR_G(r3+1) = v2;

  00273	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00277	ff c0		 inc	 eax
  00279	48 98		 cdqe
  0027b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	48 8b 54 24 50	 mov	 rdx, QWORD PTR v2$[rsp]
  00288	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3245 : 
; 3246 :     /* Set condition code 0 if operands unaltered, or 3 if altered */
; 3247 :     regs->psw.cc = (v1 == w1 && v2 == w2) ? 0 : 3;

  00290	48 8b 44 24 58	 mov	 rax, QWORD PTR w1$[rsp]
  00295	48 39 44 24 48	 cmp	 QWORD PTR v1$[rsp], rax
  0029a	75 16		 jne	 SHORT $LN14@z900_load_
  0029c	48 8b 44 24 60	 mov	 rax, QWORD PTR w2$[rsp]
  002a1	48 39 44 24 50	 cmp	 QWORD PTR v2$[rsp], rax
  002a6	75 0a		 jne	 SHORT $LN14@z900_load_
  002a8	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
  002b0	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  002b2	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv188[rsp], 3
$LN15@z900_load_:
  002ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c2	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv188[rsp]
  002c7	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3248 : 
; 3249 : } /* end DEF_INST(load_pair_disjoint_long) */

  002ca	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002ce	c3		 ret	 0
z900_load_pair_disjoint_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_or_long PROC

; 3169 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3170 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196443
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3171 : 
; 3172 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access_long

; 3173 : } /* end DEF_INST(load_and_or_long) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_or_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_exclusive_or_long PROC

; 3147 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3148 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196423
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3149 : 
; 3150 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access_long

; 3151 : } /* end DEF_INST(load_and_exclusive_or_long) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_exclusive_or_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_and_long PROC

; 3125 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3126 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196403
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3127 : 
; 3128 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access_long

; 3129 : } /* end DEF_INST(load_and_and_long) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_and_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_add_logical_long PROC

; 3103 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3104 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196383
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3105 : 
; 3106 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access_long

; 3107 : } /* end DEF_INST(load_and_add_logical_long) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_add_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_add_long PROC

; 3076 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3077 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196362
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3078 : 
; 3079 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access_long

; 3080 : 
; 3081 :     /* Program check if fixed-point overflow */
; 3082 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00072	83 f8 03	 cmp	 eax, 3
  00075	75 25		 jne	 SHORT $LN6@z900_load_
  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00080	83 e0 08	 and	 eax, 8
  00083	85 c0		 test	 eax, eax
  00085	74 15		 je	 SHORT $LN6@z900_load_

; 3083 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  00087	ba 08 00 00 00	 mov	 edx, 8
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00096	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 3084 : 
; 3085 : } /* end DEF_INST(load_and_add_long) */

  0009c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a0	c3		 ret	 0
z900_load_and_add_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
b1$ = 32
b2$ = 36
temp$1 = 40
r3$ = 44
effective_addr1$ = 48
effective_addr2$ = 56
v1$ = 64
v2$ = 68
tv188 = 72
w1$ = 76
w2$ = 80
inst$ = 112
regs$ = 120
z900_load_pair_disjoint PROC

; 3180 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3181 : int     r3;                             /* Register number           */
; 3182 : int     b1, b2;                         /* Base register numbers     */
; 3183 : VADR    effective_addr1,
; 3184 :         effective_addr2;                /* Effective addresses       */
; 3185 : U32     v1, v2;                         /* Operand values            */
; 3186 : U32     w1, w2;                         /* Refetched values          */
; 3187 : 
; 3188 :     SSF(inst, regs, b1, effective_addr1, b2, effective_addr2, r3);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 01	 imul	 rax, rax, 1
  00033	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00038	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003c	c1 f8 04	 sar	 eax, 4
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 0c	 shr	 eax, 12
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  00064	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00068	c1 e8 10	 shr	 eax, 16
  0006b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00070	8b c0		 mov	 eax, eax
  00072	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00077	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0007b	c1 e8 1c	 shr	 eax, 28
  0007e	83 e0 0f	 and	 eax, 15
  00081	89 44 24 20	 mov	 DWORD PTR b1$[rsp], eax
  00085	83 7c 24 20 00	 cmp	 DWORD PTR b1$[rsp], 0
  0008a	74 3e		 je	 SHORT $LN8@z900_load_
  0008c	48 63 44 24 20	 movsxd	 rax, DWORD PTR b1$[rsp]
  00091	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000bf	48 23 c8	 and	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_load_:
  000ca	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  000cf	74 3e		 je	 SHORT $LN9@z900_load_
  000d1	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  000d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000db	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000f3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00104	48 23 c8	 and	 rcx, rax
  00107	48 8b c1	 mov	 rax, rcx
  0010a	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  0010f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00114	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00118	48 83 c0 06	 add	 rax, 6
  0011c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00125	33 c0		 xor	 eax, eax
  00127	83 f8 06	 cmp	 eax, 6
  0012a	74 0c		 je	 SHORT $LN10@z900_load_
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	75 d1		 jne	 SHORT $LN4@z900_load_

; 3189 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0013e	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$[rsp]
  00143	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  00147	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_load_:

; 3190 : 
; 3191 :     TXFC_INSTR_CHECK( regs );

  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00156	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015d	85 c0		 test	 eax, eax
  0015f	74 36		 je	 SHORT $LN11@z900_load_
  00161	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00166	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0016c	0f ba e8 0f	 bts	 eax, 15
  00170	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0017b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196469
  00182	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00188	ba 02 00 00 00	 mov	 edx, 2
  0018d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_load_:
  00197	33 c0		 xor	 eax, eax
  00199	85 c0		 test	 eax, eax
  0019b	75 b4		 jne	 SHORT $LN7@z900_load_

; 3192 :     ODD_CHECK(r3, regs);

  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001a1	83 e0 01	 and	 eax, 1
  001a4	85 c0		 test	 eax, eax
  001a6	74 15		 je	 SHORT $LN12@z900_load_
  001a8	ba 06 00 00 00	 mov	 edx, 6
  001ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:

; 3193 : 
; 3194 :     /* Fetch the values of the storage operands */
; 3195 :     v1 = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  001bd	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c2	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  001c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001cb	e8 00 00 00 00	 call	 z900_vfetch4
  001d0	89 44 24 40	 mov	 DWORD PTR v1$[rsp], eax

; 3196 :     v2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  001d4	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001d9	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  001dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001e2	e8 00 00 00 00	 call	 z900_vfetch4
  001e7	89 44 24 44	 mov	 DWORD PTR v2$[rsp], eax

; 3197 : 
; 3198 :     /* Fetch operands again to check for alteration by another CPU */
; 3199 :     w1 = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  001eb	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001f0	8b 54 24 20	 mov	 edx, DWORD PTR b1$[rsp]
  001f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  001f9	e8 00 00 00 00	 call	 z900_vfetch4
  001fe	89 44 24 4c	 mov	 DWORD PTR w1$[rsp], eax

; 3200 :     w2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00202	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00207	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  0020b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00210	e8 00 00 00 00	 call	 z900_vfetch4
  00215	89 44 24 50	 mov	 DWORD PTR w2$[rsp], eax

; 3201 : 
; 3202 :     /* Load R3 register from first storage operand */
; 3203 :     regs->GR_L(r3) = v1;

  00219	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  0021e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00223	8b 54 24 40	 mov	 edx, DWORD PTR v1$[rsp]
  00227	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3204 : 
; 3205 :     /* Load R3+1 register from second storage operand */
; 3206 :     regs->GR_L(r3+1) = v2;

  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00232	ff c0		 inc	 eax
  00234	48 98		 cdqe
  00236	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0023b	8b 54 24 44	 mov	 edx, DWORD PTR v2$[rsp]
  0023f	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3207 : 
; 3208 :     /* Set condition code 0 if operands unaltered, or 3 if altered */
; 3209 :     regs->psw.cc = (v1 == w1 && v2 == w2) ? 0 : 3;

  00246	8b 44 24 4c	 mov	 eax, DWORD PTR w1$[rsp]
  0024a	39 44 24 40	 cmp	 DWORD PTR v1$[rsp], eax
  0024e	75 14		 jne	 SHORT $LN14@z900_load_
  00250	8b 44 24 50	 mov	 eax, DWORD PTR w2$[rsp]
  00254	39 44 24 44	 cmp	 DWORD PTR v2$[rsp], eax
  00258	75 0a		 jne	 SHORT $LN14@z900_load_
  0025a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
  00262	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  00264	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR tv188[rsp], 3
$LN15@z900_load_:
  0026c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00271	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv188[rsp]
  00276	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3210 : 
; 3211 : } /* end DEF_INST(load_pair_disjoint) */

  00279	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0027d	c3		 ret	 0
z900_load_pair_disjoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_or PROC

; 3158 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3159 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196433
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3160 : 
; 3161 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access

; 3162 : } /* end DEF_INST(load_and_or) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_or ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_exclusive_or PROC

; 3136 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3137 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196413
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3138 : 
; 3139 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access

; 3140 : } /* end DEF_INST(load_and_exclusive_or) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_exclusive_or ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_and PROC

; 3114 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3115 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196393
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3116 : 
; 3117 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access

; 3118 : } /* end DEF_INST(load_and_and) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_and ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_add_logical PROC

; 3092 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3093 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196373
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3094 : 
; 3095 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access

; 3096 : } /* end DEF_INST(load_and_add_logical) */

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
z900_load_and_add_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_load_and_add PROC

; 3060 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_load_:

; 3061 :     TXFC_INSTR_CHECK( regs );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00013	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0001a	85 c0		 test	 eax, eax
  0001c	74 36		 je	 SHORT $LN5@z900_load_
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00029	0f ba e8 0f	 bts	 eax, 15
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196350
  0003f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00045	ba 02 00 00 00	 mov	 edx, 2
  0004a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN5@z900_load_:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b4		 jne	 SHORT $LN4@z900_load_

; 3062 : 
; 3063 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0005a	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  0005f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00064	e8 00 00 00 00	 call	 z900_load_and_perform_interlocked_access

; 3064 : 
; 3065 :     /* Program check if fixed-point overflow */
; 3066 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  00069	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00072	83 f8 03	 cmp	 eax, 3
  00075	75 25		 jne	 SHORT $LN6@z900_load_
  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00080	83 e0 08	 and	 eax, 8
  00083	85 c0		 test	 eax, eax
  00085	74 15		 je	 SHORT $LN6@z900_load_

; 3067 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  00087	ba 08 00 00 00	 mov	 edx, 8
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00096	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 3068 : 
; 3069 : } /* end DEF_INST(load_and_add) */

  0009c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a0	c3		 ret	 0
z900_load_and_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_logical_high_high_low_register PROC

; 2854 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2855 : int     r1, r2, r3;                     /* Values of R fields        */
; 2856 : 
; 2857 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 2858 : 
; 2859 :     /* Subtract unsigned operands and set condition code */
; 2860 :     regs->psw.cc = sub_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2861 :                                   regs->GR_H(r2),
; 2862 :                                   regs->GR_L(r3));
; 2863 : 
; 2864 : } /* end DEF_INST(subtract_logical_high_high_low_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_subtract_logical_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_logical_high_high_high_register PROC

; 2837 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2838 : int     r1, r2, r3;                     /* Values of R fields        */
; 2839 : 
; 2840 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 2841 : 
; 2842 :     /* Subtract unsigned operands and set condition code */
; 2843 :     regs->psw.cc = sub_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2844 :                                   regs->GR_H(r2),
; 2845 :                                   regs->GR_H(r3));
; 2846 : 
; 2847 : } /* end DEF_INST(subtract_logical_high_high_high_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_subtract_logical_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_high_high_low_register PROC

; 2816 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2817 : int     r1, r2, r3;                     /* Values of R fields        */
; 2818 : 
; 2819 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 2820 : 
; 2821 :     /* Subtract signed operands and set condition code */
; 2822 :     regs->psw.cc = sub_signed (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2823 :                                  regs->GR_H(r2),
; 2824 :                                  regs->GR_L(r3));
; 2825 : 
; 2826 :     /* Program check if fixed-point overflow */
; 2827 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_subtr

; 2828 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_subtr:

; 2829 : 
; 2830 : } /* end DEF_INST(subtract_high_high_low_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_subtract_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_high_high_high_register PROC

; 2795 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2796 : int     r1, r2, r3;                     /* Values of R fields        */
; 2797 : 
; 2798 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 2799 : 
; 2800 :     /* Subtract signed operands and set condition code */
; 2801 :     regs->psw.cc = sub_signed (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2802 :                                  regs->GR_H(r2),
; 2803 :                                  regs->GR_H(r3));
; 2804 : 
; 2805 :     /* Program check if fixed-point overflow */
; 2806 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_subtr

; 2807 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_subtr:

; 2808 : 
; 2809 : } /* end DEF_INST(subtract_high_high_high_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_subtract_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_store_halfword_high PROC

; 2776 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2777 : int     r1;                             /* Value of R field          */
; 2778 : int     x2;                             /* Index register            */
; 2779 : int     b2;                             /* Base of effective addr    */
; 2780 : VADR    effective_addr2;                /* Effective address         */
; 2781 : 
; 2782 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_store
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_store
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_store:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_store
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_store
$LN14@z900_store:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_store:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_store
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_store
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_store:
$LN7@z900_store:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_store
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_store:
$LN4@z900_store:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_store
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_store:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_store

; 2783 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2784 : 
; 2785 :     /* Store bits 16-31 of R1 register at operand address */
; 2786 :     ARCH_DEP(vstore2) ( regs->GR_HHL(r1), effective_addr2, b2, regs );

  00199	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019e	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  001a3	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  001a8	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	0f b7 8c c1 84
	02 00 00	 movzx	 ecx, WORD PTR [rcx+rax*8+644]
  001ba	e8 00 00 00 00	 call	 z900_vstore2

; 2787 : 
; 2788 : } /* end DEF_INST(store_halfword_high) */

  001bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c3	c3		 ret	 0
z900_store_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_store_fullword_high PROC

; 2757 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2758 : int     r1;                             /* Values of R fields        */
; 2759 : int     x2;                             /* Index register            */
; 2760 : int     b2;                             /* Base of effective addr    */
; 2761 : VADR    effective_addr2;                /* Effective address         */
; 2762 : 
; 2763 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_store
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_store
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_store:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_store
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_store
$LN14@z900_store:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_store:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_store
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_store
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_store:
$LN7@z900_store:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_store
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_store:
$LN4@z900_store:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_store
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_store:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_store

; 2764 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2765 : 
; 2766 :     /* Store bits 0-31 of R1 register at operand address */
; 2767 :     ARCH_DEP(vstore4) ( regs->GR_H(r1), effective_addr2, b2, regs );

  00199	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019e	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  001a3	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  001a8	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	8b 8c c1 84 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+644]
  001b9	e8 00 00 00 00	 call	 z900_vstore4

; 2768 : 
; 2769 : } /* end DEF_INST(store_fullword_high) */

  001be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c2	c3		 ret	 0
z900_store_fullword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_store_character_high PROC

; 2738 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2739 : int     r1;                             /* Value of R field          */
; 2740 : int     x2;                             /* Index register            */
; 2741 : int     b2;                             /* Base of effective addr    */
; 2742 : VADR    effective_addr2;                /* Effective address         */
; 2743 : 
; 2744 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_store
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_store:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_store
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_store:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_store
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_store
$LN14@z900_store:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_store:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_store
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_store
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_store:
$LN7@z900_store:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_store
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_store:
$LN4@z900_store:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_store
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_store:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_store

; 2745 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2746 : 
; 2747 :     /* Store bits 24-31 of R1 register at operand address */
; 2748 :     ARCH_DEP(vstoreb) ( regs->GR_HHLCL(r1), effective_addr2, b2, regs );

  00199	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019e	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  001a3	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  001a8	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	0f b6 8c c1 84
	02 00 00	 movzx	 ecx, BYTE PTR [rcx+rax*8+644]
  001ba	e8 00 00 00 00	 call	 z900_vstoreb

; 2749 : 
; 2750 : } /* end DEF_INST(store_character_high) */

  001bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c3	c3		 ret	 0
z900_store_character_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_insert_selected_bits_low_long_reg PROC

; 2729 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2730 :     ARCH_DEP(rotate_then_xxx_selected_bits_long_reg) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2731 : } /* end DEF_INST(rotate_then_insert_selected_bits_low_long_reg) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_insert_selected_bits_low_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_insert_selected_bits_high_long_reg PROC

; 2720 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2721 :     ARCH_DEP(rotate_then_xxx_selected_bits_long_reg) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2722 : } /* end DEF_INST(rotate_then_insert_selected_bits_high_long_reg) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_insert_selected_bits_high_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_logical_halfword_high PROC

; 2701 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2702 : int     r1;                             /* Value of R field          */
; 2703 : int     x2;                             /* Index register            */
; 2704 : int     b2;                             /* Base of effective addr    */
; 2705 : VADR    effective_addr2;                /* Effective address         */
; 2706 : 
; 2707 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 2708 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2709 : 
; 2710 :     /* Load halfword into R1 register bits 16-31 and clear bits 0-15 */
; 2711 :     regs->GR_H(r1) = ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch2
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	0f b7 c0	 movzx	 eax, ax
  001b4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b9	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2712 : 
; 2713 : } /* end DEF_INST(load_logical_halfword_high) */

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
z900_load_logical_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_logical_character_high PROC

; 2682 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2683 : int     r1;                             /* Value of R field          */
; 2684 : int     x2;                             /* Index register            */
; 2685 : int     b2;                             /* Base of effective addr    */
; 2686 : VADR    effective_addr2;                /* Effective address         */
; 2687 : 
; 2688 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 2689 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2690 : 
; 2691 :     /* Load byte into R1 register bits 24-31 and clear bits 0-23 */
; 2692 :     regs->GR_H(r1) = ARCH_DEP(vfetchb) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetchb
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	0f b6 c0	 movzx	 eax, al
  001b4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b9	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2693 : 
; 2694 : } /* end DEF_INST(load_logical_character_high) */

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
z900_load_logical_character_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_halfword_high PROC

; 2663 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2664 : int     r1;                             /* Value of R field          */
; 2665 : int     x2;                             /* Index register            */
; 2666 : int     b2;                             /* Base of effective addr    */
; 2667 : VADR    effective_addr2;                /* Effective address         */
; 2668 : 
; 2669 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 2670 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2671 : 
; 2672 :     /* Load sign-extended halfword from operand address */
; 2673 :     regs->GR_H(r1) = (S16)ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch2
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	98		 cwde
  001b2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b7	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2674 : 
; 2675 : } /* end DEF_INST(load_halfword_high) */

  001be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c2	c3		 ret	 0
z900_load_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_fullword_high PROC

; 2644 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2645 : int     r1;                             /* Value of R field          */
; 2646 : int     x2;                             /* Index register            */
; 2647 : int     b2;                             /* Base of effective addr    */
; 2648 : VADR    effective_addr2;                /* Effective address         */
; 2649 : 
; 2650 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 2651 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2652 : 
; 2653 :     /* Load R1 register bits 0-31 from second operand */
; 2654 :     regs->GR_H(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b6	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2655 : 
; 2656 : } /* end DEF_INST(load_fullword_high) */

  001bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c1	c3		 ret	 0
z900_load_fullword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_byte_high PROC

; 2625 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2626 : int     r1;                             /* Value of R field          */
; 2627 : int     x2;                             /* Index register            */
; 2628 : int     b2;                             /* Base of effective addr    */
; 2629 : VADR    effective_addr2;                /* Effective address         */
; 2630 : 
; 2631 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 2632 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2633 : 
; 2634 :     /* Load sign-extended byte from operand address */
; 2635 :     regs->GR_H(r1) = (S8)ARCH_DEP(vfetchb) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetchb
  001ac	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001b1	0f be c0	 movsx	 eax, al
  001b4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001b9	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2636 : 
; 2637 : } /* end DEF_INST(load_byte_high) */

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
z900_load_byte_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv130 = 40
tv131 = 44
opcd$ = 48
inst$ = 80
regs$ = 88
z900_compare_logical_high_immediate PROC

; 2607 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2608 : int     r1;                             /* Register number           */
; 2609 : int     opcd;                           /* Opcode                    */
; 2610 : U32     i2;                             /* 32-bit operand value      */
; 2611 : 
; 2612 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 30	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_compa
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_compa

; 2613 : 
; 2614 :     /* Compare unsigned operands and set condition code */
; 2615 :     regs->psw.cc = regs->GR_H(r1) < i2 ? 1 :

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000a7	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000ae	73 0a		 jae	 SHORT $LN9@z900_compa
  000b0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b8	eb 31		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  000ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000c8	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000cf	76 0a		 jbe	 SHORT $LN7@z900_compa
  000d1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d9	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN8@z900_compa:
  000e3	8b 44 24 28	 mov	 eax, DWORD PTR tv130[rsp]
  000e7	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN10@z900_compa:
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv131[rsp]
  000f5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2616 :                    regs->GR_H(r1) > i2 ? 2 : 0;
; 2617 : 
; 2618 : } /* end DEF_INST(compare_logical_high_immediate) */

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
z900_compare_logical_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
x2$ = 56
tv131 = 60
r1$ = 64
n$ = 68
tv172 = 72
tv173 = 76
inst$ = 96
regs$ = 104
z900_compare_logical_high_fullword PROC

; 2583 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2584 : int     r1;                             /* Values of R fields        */
; 2585 : int     x2;                             /* Index register            */
; 2586 : int     b2;                             /* Base of effective addr    */
; 2587 : VADR    effective_addr2;                /* Effective address         */
; 2588 : U32     n;                              /* 32-bit operand values     */
; 2589 : 
; 2590 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_compa
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_compa:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_compa
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_compa:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_compa
  000cb	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_compa:
  000dd	83 7c 24 3c 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_compa
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_compa
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_compa:
$LN7@z900_compa:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_compa
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
$LN4@z900_compa:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_compa
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_compa

; 2591 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2592 : 
; 2593 :     /* Load second operand from operand address */
; 2594 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 2595 : 
; 2596 :     /* Compare unsigned operands and set condition code */
; 2597 :     regs->psw.cc = regs->GR_H(r1) < n ? 1 :

  001b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ba	8b 54 24 44	 mov	 edx, DWORD PTR n$[rsp]
  001be	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001c5	73 0a		 jae	 SHORT $LN18@z900_compa
  001c7	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  001cf	eb 31		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  001d1	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	8b 54 24 44	 mov	 edx, DWORD PTR n$[rsp]
  001df	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001e6	76 0a		 jbe	 SHORT $LN16@z900_compa
  001e8	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv172[rsp], 2
  001f0	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001f2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN17@z900_compa:
  001fa	8b 44 24 48	 mov	 eax, DWORD PTR tv172[rsp]
  001fe	89 44 24 4c	 mov	 DWORD PTR tv173[rsp], eax
$LN19@z900_compa:
  00202	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00207	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv173[rsp]
  0020c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2598 :                    regs->GR_H(r1) > n ? 2 : 0;
; 2599 : 
; 2600 : } /* end DEF_INST(compare_logical_high_fullword) */

  0020f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00213	c3		 ret	 0
z900_compare_logical_high_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
z900_compare_logical_high_low_register PROC

; 2567 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2568 : int     r1, r2;                         /* Values of R fields        */
; 2569 : 
; 2570 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@z900_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@z900_compa

; 2571 : 
; 2572 :     /* Compare unsigned operands and set condition code */
; 2573 :     regs->psw.cc = regs->GR_H(r1) < regs->GR_L(r2) ? 1 :

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	73 0a		 jae	 SHORT $LN9@z900_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	76 0a		 jbe	 SHORT $LN7@z900_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@z900_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@z900_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2574 :                    regs->GR_H(r1) > regs->GR_L(r2) ? 2 : 0;
; 2575 : 
; 2576 : } /* end DEF_INST(compare_logical_high_low_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
z900_compare_logical_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
z900_compare_logical_high_high_register PROC

; 2551 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2552 : int     r1, r2;                         /* Values of R fields        */
; 2553 : 
; 2554 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@z900_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@z900_compa

; 2555 : 
; 2556 :     /* Compare unsigned operands and set condition code */
; 2557 :     regs->psw.cc = regs->GR_H(r1) < regs->GR_H(r2) ? 1 :

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	73 0a		 jae	 SHORT $LN9@z900_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	76 0a		 jbe	 SHORT $LN7@z900_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@z900_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@z900_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2558 :                    regs->GR_H(r1) > regs->GR_H(r2) ? 2 : 0;
; 2559 : 
; 2560 : } /* end DEF_INST(compare_logical_high_high_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
z900_compare_logical_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv130 = 40
tv131 = 44
opcd$ = 48
inst$ = 80
regs$ = 88
z900_compare_high_immediate PROC

; 2533 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2534 : int     r1;                             /* Register number           */
; 2535 : int     opcd;                           /* Opcode                    */
; 2536 : U32     i2;                             /* 32-bit operand value      */
; 2537 : 
; 2538 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 30	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_compa
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_compa

; 2539 : 
; 2540 :     /* Compare signed operands and set condition code */
; 2541 :     regs->psw.cc = (S32)regs->GR_H(r1) < (S32)i2 ? 1 :

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000a7	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000ae	7d 0a		 jge	 SHORT $LN9@z900_compa
  000b0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b8	eb 31		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  000ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000c8	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000cf	7e 0a		 jle	 SHORT $LN7@z900_compa
  000d1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d9	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN8@z900_compa:
  000e3	8b 44 24 28	 mov	 eax, DWORD PTR tv130[rsp]
  000e7	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN10@z900_compa:
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv131[rsp]
  000f5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2542 :                    (S32)regs->GR_H(r1) > (S32)i2 ? 2 : 0;
; 2543 : 
; 2544 : } /* end DEF_INST(compare_high_immediate) */

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
z900_compare_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
x2$ = 56
tv131 = 60
r1$ = 64
n$ = 68
tv172 = 72
tv173 = 76
inst$ = 96
regs$ = 104
z900_compare_high_fullword PROC

; 2508 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2509 : int     r1;                             /* Values of R fields        */
; 2510 : int     x2;                             /* Index register            */
; 2511 : int     b2;                             /* Base of effective addr    */
; 2512 : VADR    effective_addr2;                /* Effective address         */
; 2513 : U32     n;                              /* 32-bit operand values     */
; 2514 : 
; 2515 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_compa
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_compa:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_compa
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_compa:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_compa
  000cb	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_compa:
  000dd	83 7c 24 3c 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_compa
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_compa
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_compa:
$LN7@z900_compa:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_compa
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
$LN4@z900_compa:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_compa
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_compa

; 2516 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 2517 : 
; 2518 :     /* Load second operand from operand address */
; 2519 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 2520 : 
; 2521 :     /* Compare signed operands and set condition code */
; 2522 :     regs->psw.cc =

  001b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ba	8b 54 24 44	 mov	 edx, DWORD PTR n$[rsp]
  001be	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001c5	7d 0a		 jge	 SHORT $LN18@z900_compa
  001c7	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  001cf	eb 31		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  001d1	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	8b 54 24 44	 mov	 edx, DWORD PTR n$[rsp]
  001df	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001e6	7e 0a		 jle	 SHORT $LN16@z900_compa
  001e8	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv172[rsp], 2
  001f0	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001f2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN17@z900_compa:
  001fa	8b 44 24 48	 mov	 eax, DWORD PTR tv172[rsp]
  001fe	89 44 24 4c	 mov	 DWORD PTR tv173[rsp], eax
$LN19@z900_compa:
  00202	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00207	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv173[rsp]
  0020c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2523 :             (S32)regs->GR_H(r1) < (S32)n ? 1 :
; 2524 :             (S32)regs->GR_H(r1) > (S32)n ? 2 : 0;
; 2525 : 
; 2526 : } /* DEF_INST(compare_high_fullword) */

  0020f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00213	c3		 ret	 0
z900_compare_high_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
z900_compare_high_low_register PROC

; 2491 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2492 : int     r1, r2;                         /* Values of R fields        */
; 2493 : 
; 2494 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@z900_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@z900_compa

; 2495 : 
; 2496 :     /* Compare signed operands and set condition code */
; 2497 :     regs->psw.cc =

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	7d 0a		 jge	 SHORT $LN9@z900_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	7e 0a		 jle	 SHORT $LN7@z900_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@z900_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@z900_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2498 :                 (S32)regs->GR_H(r1) < (S32)regs->GR_L(r2) ? 1 :
; 2499 :                 (S32)regs->GR_H(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 2500 : 
; 2501 : } /* DEF_INST(compare_high_low_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
z900_compare_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
z900_compare_high_high_register PROC

; 2474 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2475 : int     r1, r2;                         /* Values of R fields        */
; 2476 : 
; 2477 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@z900_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@z900_compa

; 2478 : 
; 2479 :     /* Compare signed operands and set condition code */
; 2480 :     regs->psw.cc =

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	7d 0a		 jge	 SHORT $LN9@z900_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@z900_compa
$LN9@z900_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	7e 0a		 jle	 SHORT $LN7@z900_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@z900_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@z900_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2481 :                 (S32)regs->GR_H(r1) < (S32)regs->GR_H(r2) ? 1 :
; 2482 :                 (S32)regs->GR_H(r1) > (S32)regs->GR_H(r2) ? 2 : 0;
; 2483 : 
; 2484 : } /* DEF_INST(compare_high_high_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
z900_compare_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
xop$ = 32
r1$ = 36
tv138 = 40
ri2$ = 44
inst$ = 64
regs$ = 72
z900_branch_relative_on_count_high PROC

; 2449 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2450 : int     r1;                             /* Register number           */
; 2451 : U8      xop;                            /* Extended opcode           */
; 2452 : S32     ri2;                            /* 32-bit relative operand   */
; 2453 : 
; 2454 :     RIL_B( inst, regs, r1, xop, ri2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR ri2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	88 44 24 20	 mov	 BYTE PTR xop$[rsp], al
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_branc:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00073	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 06	 cmp	 eax, 6
  0007c	74 0c		 je	 SHORT $LN8@z900_branc
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00083	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_branc:
  0008a	33 c0		 xor	 eax, eax
  0008c	85 c0		 test	 eax, eax
  0008e	75 da		 jne	 SHORT $LN4@z900_branc
$LN7@z900_branc:

; 2455 : 
; 2456 :     TXFC_INSTR_CHECK_IP( regs );

  00090	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00095	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0009c	85 c0		 test	 eax, eax
  0009e	74 36		 je	 SHORT $LN9@z900_branc
  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ab	0f ba e8 0f	 bts	 eax, 15
  000af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ba	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195897
  000c1	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000c7	ba fe ff ff ff	 mov	 edx, -2
  000cc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_branc:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 b4		 jne	 SHORT $LN7@z900_branc

; 2457 : 
; 2458 :     /* Subtract 1 from the R1 operand and branch if non-zero */
; 2459 :     if (--(regs->GR_H( r1 )))

  000dc	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000e1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000e6	8b 84 c1 84 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+644]
  000ed	ff c8		 dec	 eax
  000ef	89 44 24 28	 mov	 DWORD PTR tv138[rsp], eax
  000f3	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	8b 54 24 28	 mov	 edx, DWORD PTR tv138[rsp]
  00101	89 94 c1 84 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+644], edx
  00108	83 7c 24 28 00	 cmp	 DWORD PTR tv138[rsp], 0
  0010d	74 17		 je	 SHORT $LN10@z900_branc

; 2460 :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri2 );

  0010f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR ri2$[rsp]
  00114	48 d1 e0	 shl	 rax, 1
  00117	48 8b d0	 mov	 rdx, rax
  0011a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  00124	eb 16		 jmp	 SHORT $LN11@z900_branc
$LN10@z900_branc:

; 2461 :     else
; 2462 :     {
; 2463 :         /* Bump ip to next sequential instruction */
; 2464 :         regs->ip += 6;

  00126	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012f	48 83 c0 06	 add	 rax, 6
  00133	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN11@z900_branc:

; 2465 :     }
; 2466 : 
; 2467 : } /* end DEF_INST( branch_relative_on_count_high ) */

  0013c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00140	c3		 ret	 0
z900_branch_relative_on_count_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
tv131 = 48
inst$ = 80
regs$ = 88
z900_add_logical_with_signed_immediate_high_n PROC

; 2428 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2429 : int     r1;                             /* Register number           */
; 2430 : int     opcd;                           /* Opcode                    */
; 2431 : U32     i2;                             /* 32-bit operand value      */
; 2432 : 
; 2433 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_l:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_add_l
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_l:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_add_l

; 2434 : 
; 2435 :     /* Add operands without setting condition code */
; 2436 :     if ((S32)i2 < 0) {

  00099	83 7c 24 24 00	 cmp	 DWORD PTR i2$[rsp], 0
  0009e	7d 40		 jge	 SHORT $LN6@z900_add_l

; 2437 :         sub_logical (&(regs->GR_H(r1)), regs->GR_H(r1), -(S32)i2);

  000a0	8b 44 24 24	 mov	 eax, DWORD PTR i2$[rsp]
  000a4	f7 d8		 neg	 eax
  000a6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ab	48 63 54 24 20	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000b0	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b5	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  000bd	48 89 54 24 30	 mov	 QWORD PTR tv131[rsp], rdx
  000c2	44 8b c0	 mov	 r8d, eax
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR tv131[rsp]
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 sub_logical

; 2438 :     } else {

  000de	eb 2d		 jmp	 SHORT $LN7@z900_add_l
$LN6@z900_add_l:

; 2439 :         add_logical (&(regs->GR_H(r1)), regs->GR_H(r1), i2);

  000e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000e5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ea	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000ef	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000f7	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  000fc	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00101	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  00108	e8 00 00 00 00	 call	 add_logical
$LN7@z900_add_l:

; 2440 :     }
; 2441 : 
; 2442 : } /* end DEF_INST(add_logical_with_signed_immediate_high_n) */

  0010d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00111	c3		 ret	 0
z900_add_logical_with_signed_immediate_high_n ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv148 = 40
opcd$ = 44
tv132 = 48
inst$ = 80
regs$ = 88
z900_add_logical_with_signed_immediate_high PROC

; 2409 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2410 : int     r1;                             /* Register number           */
; 2411 : int     opcd;                           /* Opcode                    */
; 2412 : U32     i2;                             /* 32-bit operand value      */
; 2413 : 
; 2414 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 2c	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_l:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_add_l
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_l:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_add_l

; 2415 : 
; 2416 :     /* Add operands and set condition code */
; 2417 :     regs->psw.cc = (S32)i2 < 0 ?

  00099	83 7c 24 24 00	 cmp	 DWORD PTR i2$[rsp], 0
  0009e	7d 44		 jge	 SHORT $LN7@z900_add_l
  000a0	8b 44 24 24	 mov	 eax, DWORD PTR i2$[rsp]
  000a4	f7 d8		 neg	 eax
  000a6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ab	48 63 54 24 20	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000b0	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b5	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  000bd	48 89 54 24 30	 mov	 QWORD PTR tv132[rsp], rdx
  000c2	44 8b c0	 mov	 r8d, eax
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR tv132[rsp]
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 sub_logical
  000de	89 44 24 28	 mov	 DWORD PTR tv148[rsp], eax
  000e2	eb 31		 jmp	 SHORT $LN8@z900_add_l
$LN7@z900_add_l:
  000e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000e9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ee	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000f3	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000fb	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  00100	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00105	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  0010c	e8 00 00 00 00	 call	 add_logical
  00111	89 44 24 28	 mov	 DWORD PTR tv148[rsp], eax
$LN8@z900_add_l:
  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv148[rsp]
  0011f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2418 :         sub_logical (&(regs->GR_H(r1)), regs->GR_H(r1), -(S32)i2) :
; 2419 :         add_logical (&(regs->GR_H(r1)), regs->GR_H(r1), i2);
; 2420 : 
; 2421 : } /* end DEF_INST(add_logical_with_signed_immediate_high) */

  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
z900_add_logical_with_signed_immediate_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_logical_high_high_low_register PROC

; 2392 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2393 : int     r1, r2, r3;                     /* Values of R fields        */
; 2394 : 
; 2395 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_l

; 2396 : 
; 2397 :     /* Add signed operands and set condition code */
; 2398 :     regs->psw.cc = add_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2399 :                                   regs->GR_H(r2),
; 2400 :                                   regs->GR_L(r3));
; 2401 : 
; 2402 : } /* end DEF_INST(add_logical_high_high_low_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_add_logical_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_logical_high_high_high_register PROC

; 2375 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2376 : int     r1, r2, r3;                     /* Values of R fields        */
; 2377 : 
; 2378 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_l

; 2379 : 
; 2380 :     /* Add signed operands and set condition code */
; 2381 :     regs->psw.cc = add_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2382 :                                   regs->GR_H(r2),
; 2383 :                                   regs->GR_H(r3));
; 2384 : 
; 2385 : } /* end DEF_INST(add_logical_high_high_high_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_add_logical_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
inst$ = 64
regs$ = 72
z900_add_high_immediate PROC

; 2352 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2353 : int     r1;                             /* Register number           */
; 2354 : int     opcd;                           /* Opcode                    */
; 2355 : U32     i2;                             /* 32-bit operand value      */
; 2356 : 
; 2357 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_h:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_add_h
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_h:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_add_h

; 2358 : 
; 2359 :     /* Add signed operands and set condition code */
; 2360 :     regs->psw.cc = add_signed (&(regs->GR_H(r1)),

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000b0	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  000b5	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000ba	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  000c1	e8 00 00 00 00	 call	 add_signed
  000c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2361 :                                 regs->GR_H(r1),
; 2362 :                                 (S32)i2);
; 2363 : 
; 2364 :     /* Program check if fixed-point overflow */
; 2365 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d7	83 f8 03	 cmp	 eax, 3
  000da	75 25		 jne	 SHORT $LN6@z900_add_h
  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000e5	83 e0 08	 and	 eax, 8
  000e8	85 c0		 test	 eax, eax
  000ea	74 15		 je	 SHORT $LN6@z900_add_h

; 2366 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000ec	ba 08 00 00 00	 mov	 edx, 8
  000f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_h:

; 2367 : 
; 2368 : } /* end DEF_INST(add_high_immediate) */

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
z900_add_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_high_high_low_register PROC

; 2331 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2332 : int     r1, r2, r3;                     /* Values of R fields        */
; 2333 : 
; 2334 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_h:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_h
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_h:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_h

; 2335 : 
; 2336 :     /* Add signed operands and set condition code */
; 2337 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2338 :             add_signed (&(regs->GR_H(r1)),
; 2339 :                     regs->GR_H(r2),
; 2340 :                     regs->GR_L(r3));
; 2341 : 
; 2342 :     /* Program check if fixed-point overflow */
; 2343 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_add_h
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_add_h

; 2344 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_h:

; 2345 : 
; 2346 : } /* end DEF_INST(add_high_high_low_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_add_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_high_high_high_register PROC

; 2309 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2310 : int     r1, r2, r3;                     /* Values of R fields        */
; 2311 : 
; 2312 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_h:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_h
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_h:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_h

; 2313 : 
; 2314 :     /* Add signed operands and set condition code */
; 2315 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2316 :             add_signed (&(regs->GR_H(r1)),
; 2317 :                     regs->GR_H(r2),
; 2318 :                     regs->GR_H(r3));
; 2319 : 
; 2320 :     /* Program check if fixed-point overflow */
; 2321 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_add_h
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_add_h

; 2322 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_h:

; 2323 : 
; 2324 : } /* end DEF_INST(add_high_high_high_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_add_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_logical_distinct_long_register PROC

; 3956 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3957 : int     r1, r2, r3;                     /* Values of R fields        */
; 3958 : 
; 3959 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 3960 : 
; 3961 :     /* Subtract unsigned operands and set condition code */
; 3962 :     regs->psw.cc = sub_logical_long(&(regs->GR_G(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 sub_logical_long
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3963 :                                       regs->GR_G(r2),
; 3964 :                                       regs->GR_G(r3));
; 3965 : 
; 3966 : } /* end DEF_INST(subtract_logical_distinct_long_register) */

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
z900_subtract_logical_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_logical_distinct_register PROC

; 3938 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3939 : int     r1, r2, r3;                     /* Values of R fields        */
; 3940 : 
; 3941 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 3942 : 
; 3943 :     /* Subtract unsigned operands and set condition code */
; 3944 :     regs->psw.cc = sub_logical (&(regs->GR_L(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3945 :                                   regs->GR_L(r2),
; 3946 :                                   regs->GR_L(r3));
; 3947 : 
; 3948 : } /* end DEF_INST(subtract_logical_distinct_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_subtract_logical_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_distinct_long_register PROC

; 3916 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3917 : int     r1, r2, r3;                     /* Values of R fields        */
; 3918 : 
; 3919 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 3920 : 
; 3921 :     /* Subtract signed operands and set condition code */
; 3922 :     regs->psw.cc = sub_signed_long(&(regs->GR_G(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 sub_signed_long
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3923 :                                      regs->GR_G(r2),
; 3924 :                                      regs->GR_G(r3));
; 3925 : 
; 3926 :     /* Program check if fixed-point overflow */
; 3927 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d2	83 f8 03	 cmp	 eax, 3
  000d5	75 25		 jne	 SHORT $LN6@z900_subtr
  000d7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000e0	83 e0 08	 and	 eax, 8
  000e3	85 c0		 test	 eax, eax
  000e5	74 15		 je	 SHORT $LN6@z900_subtr

; 3928 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e7	ba 08 00 00 00	 mov	 edx, 8
  000ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_subtr:

; 3929 : 
; 3930 : } /* end DEF_INST(subtract_distinct_long_register) */

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
z900_subtract_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_subtract_distinct_register PROC

; 3893 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3894 : int     r1, r2, r3;                     /* Values of R fields        */
; 3895 : 
; 3896 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_subtr

; 3897 : 
; 3898 :     /* Subtract signed operands and set condition code */
; 3899 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3900 :             sub_signed (&(regs->GR_L(r1)),
; 3901 :                     regs->GR_L(r2),
; 3902 :                     regs->GR_L(r3));
; 3903 : 
; 3904 :     /* Program check if fixed-point overflow */
; 3905 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_subtr

; 3906 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_subtr:

; 3907 : 
; 3908 : } /* end DEF_INST(subtract_distinct_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_subtract_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
effective_addr2$ = 40
b2$ = 48
tv92 = 52
n$ = 56
tv159 = 60
r3$ = 64
r1$ = 68
inst$ = 96
regs$ = 104
z900_shift_left_single_logical_distinct PROC

; 3872 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3873 : int     r1, r3;                         /* Register numbers          */
; 3874 : int     b2;                             /* Base of effective addr    */
; 3875 : VADR    effective_addr2;                /* Effective address         */
; 3876 : U32     n;                              /* Integer work area         */
; 3877 : 
; 3878 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR r3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_shift
  0006a	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_shift:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN13@z900_shift
  000a2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN14@z900_shift
$LN13@z900_shift:
  000ac	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@z900_shift:
  000b4	83 7c 24 34 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_shift
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_shift
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_shift:
$LN6@z900_shift:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_shift
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
$LN4@z900_shift:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_shift
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_shift:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_shift

; 3879 : 
; 3880 :     /* Use rightmost six bits of operand address as shift count */
; 3881 :     n = effective_addr2 & 0x3F;

  0015d	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00162	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00166	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 3882 : 
; 3883 :     /* Shift the R3 register and place the result in the R1 register */
; 3884 :     regs->GR_L(r1) = n > 31 ? 0 : regs->GR_L(r3) << n;

  0016a	83 7c 24 38 1f	 cmp	 DWORD PTR n$[rsp], 31
  0016f	76 0a		 jbe	 SHORT $LN15@z900_shift
  00171	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  00179	eb 1b		 jmp	 SHORT $LN16@z900_shift
$LN15@z900_shift:
  0017b	48 63 44 24 40	 movsxd	 rax, DWORD PTR r3$[rsp]
  00180	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00184	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00189	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00190	d3 e0		 shl	 eax, cl
  00192	89 44 24 3c	 mov	 DWORD PTR tv159[rsp], eax
$LN16@z900_shift:
  00196	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	8b 54 24 3c	 mov	 edx, DWORD PTR tv159[rsp]
  001a4	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3885 : 
; 3886 : } /* end DEF_INST(shift_left_single_logical_distinct) */

  001ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001af	c3		 ret	 0
z900_shift_left_single_logical_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
effective_addr2$ = 40
b2$ = 48
tv92 = 52
n$ = 56
tv159 = 60
r3$ = 64
r1$ = 68
inst$ = 96
regs$ = 104
z900_shift_right_single_logical_distinct PROC

; 3851 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3852 : int     r1, r3;                         /* Register numbers          */
; 3853 : int     b2;                             /* Base of effective addr    */
; 3854 : VADR    effective_addr2;                /* Effective address         */
; 3855 : U32     n;                              /* Integer work area         */
; 3856 : 
; 3857 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR r3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_shift
  0006a	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_shift:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN13@z900_shift
  000a2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN14@z900_shift
$LN13@z900_shift:
  000ac	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@z900_shift:
  000b4	83 7c 24 34 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_shift
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_shift
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_shift:
$LN6@z900_shift:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_shift
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
$LN4@z900_shift:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_shift
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_shift:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_shift

; 3858 : 
; 3859 :     /* Use rightmost six bits of operand address as shift count */
; 3860 :     n = effective_addr2 & 0x3F;

  0015d	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00162	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00166	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 3861 : 
; 3862 :     /* Shift the R3 register and place the result in the R1 register */
; 3863 :     regs->GR_L(r1) = n > 31 ? 0 : regs->GR_L(r3) >> n;

  0016a	83 7c 24 38 1f	 cmp	 DWORD PTR n$[rsp], 31
  0016f	76 0a		 jbe	 SHORT $LN15@z900_shift
  00171	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  00179	eb 1b		 jmp	 SHORT $LN16@z900_shift
$LN15@z900_shift:
  0017b	48 63 44 24 40	 movsxd	 rax, DWORD PTR r3$[rsp]
  00180	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00184	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00189	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00190	d3 e8		 shr	 eax, cl
  00192	89 44 24 3c	 mov	 DWORD PTR tv159[rsp], eax
$LN16@z900_shift:
  00196	48 63 44 24 44	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	8b 54 24 3c	 mov	 edx, DWORD PTR tv159[rsp]
  001a4	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3864 : 
; 3865 : } /* end DEF_INST(shift_right_single_logical_distinct) */

  001ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001af	c3		 ret	 0
z900_shift_right_single_logical_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
r1$ = 36
temp$2 = 40
r3$ = 44
n1$ = 48
n$ = 52
i$ = 56
effective_addr2$ = 64
b2$ = 72
tv92 = 76
tv172 = 80
n2$ = 84
j$ = 88
tv220 = 92
tv221 = 96
inst$ = 128
regs$ = 136
z900_shift_left_single_distinct PROC

; 3793 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3794 : int     r1, r3;                         /* Register numbers          */
; 3795 : int     b2;                             /* Base of effective addr    */
; 3796 : VADR    effective_addr2;                /* Effective address         */
; 3797 : U32     n, n1, n2;                      /* 32-bit operand values     */
; 3798 : U32     i, j;                           /* Integer work areas        */
; 3799 : 
; 3800 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00016	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 _byteswap_ulong
  00022	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00026	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002f	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00033	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00038	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  0003c	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0004a	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004e	c1 e8 10	 shr	 eax, 16
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
  00058	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0005c	c1 e8 14	 shr	 eax, 20
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00066	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0006b	74 25		 je	 SHORT $LN8@z900_shift
  0006d	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00072	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	48 6b c0 04	 imul	 rax, rax, 4
  0009b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a7	85 c0		 test	 eax, eax
  000a9	74 0a		 je	 SHORT $LN20@z900_shift
  000ab	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b3	eb 08		 jmp	 SHORT $LN21@z900_shift
$LN20@z900_shift:
  000b5	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN21@z900_shift:
  000bd	83 7c 24 4c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c2	74 3e		 je	 SHORT $LN9@z900_shift
  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	48 6b c0 04	 imul	 rax, rax, 4
  000cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d9	c1 e0 0c	 shl	 eax, 12
  000dc	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000e0	0b c8		 or	 ecx, eax
  000e2	8b c1		 mov	 eax, ecx
  000e4	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000e8	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ec	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000f1	85 c0		 test	 eax, eax
  000f3	74 0d		 je	 SHORT $LN10@z900_shift
  000f5	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f9	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000fe	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN10@z900_shift:
$LN9@z900_shift:
  00102	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 1f		 je	 SHORT $LN11@z900_shift
  0011e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0012d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00132	48 23 c8	 and	 rcx, rax
  00135	48 8b c1	 mov	 rax, rcx
  00138	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_shift:
$LN4@z900_shift:
  0013d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00149	48 83 c0 06	 add	 rax, 6
  0014d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00159	33 c0		 xor	 eax, eax
  0015b	83 f8 06	 cmp	 eax, 6
  0015e	74 0f		 je	 SHORT $LN12@z900_shift
  00160	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN12@z900_shift:
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	75 c8		 jne	 SHORT $LN4@z900_shift

; 3801 : 
; 3802 :     /* Use rightmost six bits of operand address as shift count */
; 3803 :     n = effective_addr2 & 0x3F;

  00175	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0017a	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  0017e	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 3804 : 
; 3805 :     /* Fast path if no possible overflow */
; 3806 :     if (regs->GR_L(r3) < 0x10000 && n < 16)

  00182	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  00187	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	81 bc c1 80 02
	00 00 00 00 01
	00		 cmp	 DWORD PTR [rcx+rax*8+640], 65536 ; 00010000H
  0019a	73 73		 jae	 SHORT $LN13@z900_shift
  0019c	83 7c 24 34 10	 cmp	 DWORD PTR n$[rsp], 16
  001a1	73 6c		 jae	 SHORT $LN13@z900_shift

; 3807 :     {
; 3808 :         regs->GR_L(r1) = regs->GR_L(r3) << n;

  001a3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  001a8	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001b4	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  001bb	d3 e0		 shl	 eax, cl
  001bd	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001c2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001ca	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3809 :         regs->psw.cc = regs->GR_L(r1) ? 2 : 0;

  001d1	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001e6	74 0a		 je	 SHORT $LN22@z900_shift
  001e8	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR tv172[rsp], 2
  001f0	eb 08		 jmp	 SHORT $LN23@z900_shift
$LN22@z900_shift:
  001f2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN23@z900_shift:
  001fa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv172[rsp]
  00207	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3810 :         return;

  0020a	e9 47 01 00 00	 jmp	 $LN1@z900_shift
$LN13@z900_shift:

; 3811 :     }
; 3812 : 
; 3813 :     /* Load the numeric and sign portions from the R3 register */
; 3814 :     n1 = regs->GR_L(r3) & 0x7FFFFFFF;

  0020f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  00214	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00223	0f ba f0 1f	 btr	 eax, 31
  00227	89 44 24 30	 mov	 DWORD PTR n1$[rsp], eax

; 3815 :     n2 = regs->GR_L(r3) & 0x80000000;

  0022b	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r3$[rsp]
  00230	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0023f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00244	89 44 24 54	 mov	 DWORD PTR n2$[rsp], eax

; 3816 : 
; 3817 :     /* Shift the numeric portion left n positions */
; 3818 :     for (i = 0, j = 0; i < n; i++)

  00248	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00250	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00258	eb 0a		 jmp	 SHORT $LN7@z900_shift
$LN5@z900_shift:
  0025a	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0025e	ff c0		 inc	 eax
  00260	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_shift:
  00264	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00268	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0026c	73 23		 jae	 SHORT $LN6@z900_shift

; 3819 :     {
; 3820 :         /* Shift bits 1-31 left one bit position */
; 3821 :         n1 <<= 1;

  0026e	8b 44 24 30	 mov	 eax, DWORD PTR n1$[rsp]
  00272	d1 e0		 shl	 eax, 1
  00274	89 44 24 30	 mov	 DWORD PTR n1$[rsp], eax

; 3822 : 
; 3823 :         /* Overflow if bit shifted out is unlike the sign bit */
; 3824 :         if ((n1 & 0x80000000) != n2)

  00278	8b 44 24 30	 mov	 eax, DWORD PTR n1$[rsp]
  0027c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00281	3b 44 24 54	 cmp	 eax, DWORD PTR n2$[rsp]
  00285	74 08		 je	 SHORT $LN14@z900_shift

; 3825 :             j = 1;

  00287	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
$LN14@z900_shift:

; 3826 :     }

  0028f	eb c9		 jmp	 SHORT $LN5@z900_shift
$LN6@z900_shift:

; 3827 : 
; 3828 :     /* Load the updated value into the R1 register */
; 3829 :     regs->GR_L(r1) = (n1 & 0x7FFFFFFF) | n2;

  00291	8b 44 24 30	 mov	 eax, DWORD PTR n1$[rsp]
  00295	0f ba f0 1f	 btr	 eax, 31
  00299	0b 44 24 54	 or	 eax, DWORD PTR n2$[rsp]
  0029d	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002a2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002aa	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3830 : 
; 3831 :     /* Condition code 3 and program check if overflow occurred */
; 3832 :     if (j)

  002b1	83 7c 24 58 00	 cmp	 DWORD PTR j$[rsp], 0
  002b6	74 3c		 je	 SHORT $LN15@z900_shift

; 3833 :     {
; 3834 :         regs->psw.cc = 3;

  002b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c0	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 3835 :         if ( FOMASK(&regs->psw) )

  002c4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cc	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  002d0	83 e0 08	 and	 eax, 8
  002d3	85 c0		 test	 eax, eax
  002d5	74 1b		 je	 SHORT $LN16@z900_shift

; 3836 :             regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  002d7	ba 08 00 00 00	 mov	 edx, 8
  002dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ec	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_shift:

; 3837 :         return;

  002f2	eb 62		 jmp	 SHORT $LN1@z900_shift
$LN15@z900_shift:

; 3838 :     }
; 3839 : 
; 3840 :     /* Set the condition code */
; 3841 :     regs->psw.cc = (S32)regs->GR_L(r1) > 0 ? 2 :

  002f4	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  002f9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00309	7e 0a		 jle	 SHORT $LN26@z900_shift
  0030b	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv221[rsp], 2
  00313	eb 31		 jmp	 SHORT $LN27@z900_shift
$LN26@z900_shift:
  00315	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0031a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00322	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0032a	7d 0a		 jge	 SHORT $LN24@z900_shift
  0032c	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv220[rsp], 1
  00334	eb 08		 jmp	 SHORT $LN25@z900_shift
$LN24@z900_shift:
  00336	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv220[rsp], 0
$LN25@z900_shift:
  0033e	8b 44 24 5c	 mov	 eax, DWORD PTR tv220[rsp]
  00342	89 44 24 60	 mov	 DWORD PTR tv221[rsp], eax
$LN27@z900_shift:
  00346	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR tv221[rsp]
  00353	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN1@z900_shift:

; 3842 :                    (S32)regs->GR_L(r1) < 0 ? 1 : 0;
; 3843 : 
; 3844 : } /* end DEF_INST(shift_left_single_distinct) */

  00356	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0035a	c3		 ret	 0
z900_shift_left_single_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
r1$ = 40
effective_addr2$ = 48
b2$ = 56
tv92 = 60
tv159 = 64
r3$ = 68
n$ = 72
tv166 = 76
tv180 = 80
tv181 = 84
inst$ = 112
regs$ = 120
z900_shift_right_single_distinct PROC

; 3766 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3767 : int     r1, r3;                         /* Register numbers          */
; 3768 : int     b2;                             /* Base of effective addr    */
; 3769 : VADR    effective_addr2;                /* Effective address         */
; 3770 : U32     n;                              /* Integer work area         */
; 3771 : 
; 3772 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR r3$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 38 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN5@z900_shift
  0006a	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_shift:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN13@z900_shift
  000a2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN14@z900_shift
$LN13@z900_shift:
  000ac	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@z900_shift:
  000b4	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN6@z900_shift
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN7@z900_shift
  000e9	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@z900_shift:
$LN6@z900_shift:
  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN8@z900_shift
  00112	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
$LN4@z900_shift:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN9@z900_shift
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_shift:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_shift

; 3773 : 
; 3774 :     /* Use rightmost six bits of operand address as shift count */
; 3775 :     n = effective_addr2 & 0x3F;

  0015d	48 8b 44 24 30	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00162	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00166	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 3776 : 
; 3777 :     /* Shift signed value of the R3 register, result in R1 register */
; 3778 :     regs->GR_L(r1) = n > 30 ?

  0016a	83 7c 24 48 1e	 cmp	 DWORD PTR n$[rsp], 30
  0016f	76 30		 jbe	 SHORT $LN17@z900_shift
  00171	48 63 44 24 44	 movsxd	 rax, DWORD PTR r3$[rsp]
  00176	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017b	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00183	7d 0a		 jge	 SHORT $LN15@z900_shift
  00185	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR tv159[rsp], -1
  0018d	eb 08		 jmp	 SHORT $LN16@z900_shift
$LN15@z900_shift:
  0018f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@z900_shift:
  00197	8b 44 24 40	 mov	 eax, DWORD PTR tv159[rsp]
  0019b	89 44 24 4c	 mov	 DWORD PTR tv166[rsp], eax
  0019f	eb 1b		 jmp	 SHORT $LN18@z900_shift
$LN17@z900_shift:
  001a1	48 63 44 24 44	 movsxd	 rax, DWORD PTR r3$[rsp]
  001a6	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  001aa	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  001af	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  001b6	d3 f8		 sar	 eax, cl
  001b8	89 44 24 4c	 mov	 DWORD PTR tv166[rsp], eax
$LN18@z900_shift:
  001bc	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	8b 54 24 4c	 mov	 edx, DWORD PTR tv166[rsp]
  001ca	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3779 :                     ((S32)regs->GR_L(r3) < 0 ? -1 : 0) :
; 3780 :                     (S32)regs->GR_L(r3) >> n;
; 3781 : 
; 3782 :     /* Set the condition code */
; 3783 :     regs->psw.cc = ((S32)regs->GR_L(r1) > 0) ? 2 :

  001d1	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001e3	7e 0a		 jle	 SHORT $LN21@z900_shift
  001e5	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR tv181[rsp], 2
  001ed	eb 2e		 jmp	 SHORT $LN22@z900_shift
$LN21@z900_shift:
  001ef	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  001f4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001f9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00201	7d 0a		 jge	 SHORT $LN19@z900_shift
  00203	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  0020b	eb 08		 jmp	 SHORT $LN20@z900_shift
$LN19@z900_shift:
  0020d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN20@z900_shift:
  00215	8b 44 24 50	 mov	 eax, DWORD PTR tv180[rsp]
  00219	89 44 24 54	 mov	 DWORD PTR tv181[rsp], eax
$LN22@z900_shift:
  0021d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00222	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv181[rsp]
  00227	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3784 :                    (((S32)regs->GR_L(r1) < 0) ? 1 : 0);
; 3785 : 
; 3786 : } /* end DEF_INST(shift_right_single_distinct) */

  0022a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022e	c3		 ret	 0
z900_shift_right_single_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_or_distinct_long_register PROC

; 3747 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3748 : int     r1, r2, r3;                     /* Values of R fields        */
; 3749 : 
; 3750 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_or_di:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_or_di
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_or_di:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_or_di

; 3751 : 
; 3752 :     /* OR second and third operands and put result in first operand */
; 3753 :     regs->GR_G(r1) = regs->GR_G(r2) | regs->GR_G(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00095	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0009d	48 0b c1	 or	 rax, rcx
  000a0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000aa	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3754 : 
; 3755 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3756 :     regs->psw.cc = (regs->GR_G(r1)) ? 1 : 0;

  000b2	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  000c5	74 0a		 je	 SHORT $LN7@z900_or_di
  000c7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cf	eb 08		 jmp	 SHORT $LN8@z900_or_di
$LN7@z900_or_di:
  000d1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_or_di:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000e3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3757 : 
; 3758 : } /* end DEF_INST(or_distinct_long_register) */

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
z900_or_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_or_distinct_register PROC

; 3728 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3729 : int     r1, r2, r3;                     /* Values of R fields        */
; 3730 : 
; 3731 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_or_di:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_or_di
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_or_di:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_or_di

; 3732 : 
; 3733 :     /* OR second and third operands and put result in first operand */
; 3734 :     regs->GR_L(r1) = regs->GR_L(r2) | regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	0b c1		 or	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3735 : 
; 3736 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3737 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@z900_or_di
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@z900_or_di
$LN7@z900_or_di:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_or_di:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3738 : 
; 3739 : } /* end DEF_INST(or_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
z900_or_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_exclusive_or_distinct_long_register PROC

; 3709 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3710 : int     r1, r2, r3;                     /* Values of R fields        */
; 3711 : 
; 3712 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_exclu:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_exclu
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_exclu:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_exclu

; 3713 : 
; 3714 :     /* XOR second and third operands and put result in first operand */
; 3715 :     regs->GR_G(r1) = regs->GR_G(r2) ^ regs->GR_G(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00095	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0009d	48 33 c1	 xor	 rax, rcx
  000a0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000aa	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3716 : 
; 3717 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3718 :     regs->psw.cc = (regs->GR_G(r1)) ? 1 : 0;

  000b2	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  000c5	74 0a		 je	 SHORT $LN7@z900_exclu
  000c7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cf	eb 08		 jmp	 SHORT $LN8@z900_exclu
$LN7@z900_exclu:
  000d1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_exclu:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000e3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3719 : 
; 3720 : } /* end DEF_INST(exclusive_or_distinct_long_register) */

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
z900_exclusive_or_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_exclusive_or_distinct_register PROC

; 3690 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3691 : int     r1, r2, r3;                     /* Values of R fields        */
; 3692 : 
; 3693 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_exclu:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_exclu
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_exclu:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_exclu

; 3694 : 
; 3695 :     /* XOR second and third operands and put result in first operand */
; 3696 :     regs->GR_L(r1) = regs->GR_L(r2) ^ regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	33 c1		 xor	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3697 : 
; 3698 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3699 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@z900_exclu
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@z900_exclu
$LN7@z900_exclu:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_exclu:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3700 : 
; 3701 : } /* end DEF_INST(exclusive_or_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
z900_exclusive_or_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_and_distinct_long_register PROC

; 3671 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3672 : int     r1, r2, r3;                     /* Values of R fields        */
; 3673 : 
; 3674 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_and_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_and_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_and_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_and_d

; 3675 : 
; 3676 :     /* AND second and third operands and put result in first operand */
; 3677 :     regs->GR_G(r1) = regs->GR_G(r2) & regs->GR_G(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00095	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0009d	48 23 c1	 and	 rax, rcx
  000a0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000aa	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3678 : 
; 3679 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3680 :     regs->psw.cc = (regs->GR_G(r1)) ? 1 : 0;

  000b2	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  000c5	74 0a		 je	 SHORT $LN7@z900_and_d
  000c7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cf	eb 08		 jmp	 SHORT $LN8@z900_and_d
$LN7@z900_and_d:
  000d1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_and_d:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000e3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3681 : 
; 3682 : } /* end DEF_INST(and_distinct_long_register) */

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
z900_and_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
z900_and_distinct_register PROC

; 3652 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3653 : int     r1, r2, r3;                     /* Values of R fields        */
; 3654 : 
; 3655 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_and_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_and_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_and_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_and_d

; 3656 : 
; 3657 :     /* AND second and third operands and put result in first operand */
; 3658 :     regs->GR_L(r1) = regs->GR_L(r2) & regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	23 c1		 and	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3659 : 
; 3660 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3661 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@z900_and_d
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@z900_and_d
$LN7@z900_and_d:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@z900_and_d:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3662 : 
; 3663 : } /* end DEF_INST(and_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
z900_and_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv147 = 48
tv130 = 56
tv145 = 64
inst$ = 96
regs$ = 104
z900_add_logical_distinct_long_signed_halfword_immediate PROC

; 3633 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3634 : int     r1, r3;                         /* Values of R fields        */
; 3635 : U16     i2;                             /* 16-bit immediate operand  */
; 3636 : 
; 3637 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_l:
  0004d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_add_l
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_l:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_add_l

; 3638 : 
; 3639 :     /* Add operands and set condition code */
; 3640 :     regs->psw.cc = (S16)i2 < 0 ?

  0007c	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  00081	85 c0		 test	 eax, eax
  00083	7d 48		 jge	 SHORT $LN7@z900_add_l
  00085	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  0008a	f7 d8		 neg	 eax
  0008c	48 98		 cdqe
  0008e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00093	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00098	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0009d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000a5	48 89 54 24 38	 mov	 QWORD PTR tv130[rsp], rdx
  000aa	4c 8b c0	 mov	 r8, rax
  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000ba	48 8b 44 24 38	 mov	 rax, QWORD PTR tv130[rsp]
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 sub_logical_long
  000c7	89 44 24 30	 mov	 DWORD PTR tv147[rsp], eax
  000cb	eb 43		 jmp	 SHORT $LN8@z900_add_l
$LN7@z900_add_l:
  000cd	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000d3	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000d8	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000dd	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000e2	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000ea	48 89 54 24 40	 mov	 QWORD PTR tv145[rsp], rdx
  000ef	4c 8b c0	 mov	 r8, rax
  000f2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR tv145[rsp]
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 add_logical_long
  0010c	89 44 24 30	 mov	 DWORD PTR tv147[rsp], eax
$LN8@z900_add_l:
  00110	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00115	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv147[rsp]
  0011a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3641 :         sub_logical_long (&(regs->GR_G(r1)), regs->GR_G(r3), (S64)(-(S16)i2)) :
; 3642 :         add_logical_long (&(regs->GR_G(r1)), regs->GR_G(r3), (S64)(S16)i2);
; 3643 : 
; 3644 : } /* end DEF_INST(add_logical_distinct_long_signed_halfword_immediate) */

  0011d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00121	c3		 ret	 0
z900_add_logical_distinct_long_signed_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv146 = 48
tv129 = 56
tv144 = 64
inst$ = 96
regs$ = 104
z900_add_logical_distinct_signed_halfword_immediate PROC

; 3614 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3615 : int     r1, r3;                         /* Values of R fields        */
; 3616 : U16     i2;                             /* 16-bit immediate operand  */
; 3617 : 
; 3618 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_l:
  0004d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_add_l
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_l:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_add_l

; 3619 : 
; 3620 :     /* Add operands and set condition code */
; 3621 :     regs->psw.cc = (S16)i2 < 0 ?

  0007c	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  00081	85 c0		 test	 eax, eax
  00083	7d 45		 jge	 SHORT $LN7@z900_add_l
  00085	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  0008a	f7 d8		 neg	 eax
  0008c	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00091	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00096	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0009b	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000a3	48 89 54 24 38	 mov	 QWORD PTR tv129[rsp], rdx
  000a8	44 8b c0	 mov	 r8d, eax
  000ab	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR tv129[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	e8 00 00 00 00	 call	 sub_logical
  000c4	89 44 24 30	 mov	 DWORD PTR tv146[rsp], eax
  000c8	eb 41		 jmp	 SHORT $LN8@z900_add_l
$LN7@z900_add_l:
  000ca	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000cf	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000d4	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000d9	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000de	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000e6	48 89 54 24 40	 mov	 QWORD PTR tv144[rsp], rdx
  000eb	44 8b c0	 mov	 r8d, eax
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000fa	48 8b 44 24 40	 mov	 rax, QWORD PTR tv144[rsp]
  000ff	48 8b c8	 mov	 rcx, rax
  00102	e8 00 00 00 00	 call	 add_logical
  00107	89 44 24 30	 mov	 DWORD PTR tv146[rsp], eax
$LN8@z900_add_l:
  0010b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00110	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv146[rsp]
  00115	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3622 :         sub_logical (&(regs->GR_L(r1)), regs->GR_L(r3), (S32)(-(S16)i2)) :
; 3623 :         add_logical (&(regs->GR_L(r1)), regs->GR_L(r3), (S32)(S16)i2);
; 3624 : 
; 3625 : } /* end DEF_INST(add_logical_distinct_signed_halfword_immediate) */

  00118	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011c	c3		 ret	 0
z900_add_logical_distinct_signed_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_logical_distinct_long_register PROC

; 3596 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3597 : int     r1, r2, r3;                     /* Values of R fields        */
; 3598 : 
; 3599 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_l

; 3600 : 
; 3601 :     /* Add unsigned operands and set condition code */
; 3602 :     regs->psw.cc = add_logical_long(&(regs->GR_G(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 add_logical_long
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3603 :                                       regs->GR_G(r2),
; 3604 :                                       regs->GR_G(r3));
; 3605 : 
; 3606 : } /* end DEF_INST(add_logical_distinct_long_register) */

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
z900_add_logical_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_logical_distinct_register PROC

; 3578 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3579 : int     r1, r2, r3;                     /* Values of R fields        */
; 3580 : 
; 3581 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_l

; 3582 : 
; 3583 :     /* Add signed operands and set condition code */
; 3584 :     regs->psw.cc = add_logical (&(regs->GR_L(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3585 :                                   regs->GR_L(r2),
; 3586 :                                   regs->GR_L(r3));
; 3587 : 
; 3588 : } /* end DEF_INST(add_logical_distinct_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
z900_add_logical_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv94 = 48
inst$ = 80
regs$ = 88
z900_add_distinct_long_halfword_immediate PROC

; 3555 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3556 : int     r1, r3;                         /* Values of R fields        */
; 3557 : U16     i2;                             /* 16-bit immediate operand  */
; 3558 : 
; 3559 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_d:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_add_d
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_d:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_add_d

; 3560 : 
; 3561 :     /* Add signed operands and set condition code */
; 3562 :     regs->psw.cc = add_signed_long(&(regs->GR_G(r1)),

  0007c	48 63 44 24 28	 movsxd	 rax, DWORD PTR r3$[rsp]
  00081	48 0f bf 4c 24
	20		 movsx	 rcx, WORD PTR i2$[rsp]
  00087	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0008c	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00091	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00099	48 89 54 24 30	 mov	 QWORD PTR tv94[rsp], rdx
  0009e	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000a3	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  000ab	48 8b d1	 mov	 rdx, rcx
  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 add_signed_long
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3563 :                                      (S16)i2,
; 3564 :                                      regs->GR_G(r3));
; 3565 : 
; 3566 :     /* Program check if fixed-point overflow */
; 3567 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000cc	83 f8 03	 cmp	 eax, 3
  000cf	75 25		 jne	 SHORT $LN6@z900_add_d
  000d1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000da	83 e0 08	 and	 eax, 8
  000dd	85 c0		 test	 eax, eax
  000df	74 15		 je	 SHORT $LN6@z900_add_d

; 3568 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e1	ba 08 00 00 00	 mov	 edx, 8
  000e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_d:

; 3569 : 
; 3570 : } /* end DEF_INST(add_distinct_long_halfword_immediate) */

  000f6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fa	c3		 ret	 0
z900_add_distinct_long_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv94 = 48
inst$ = 80
regs$ = 88
z900_add_distinct_halfword_immediate PROC

; 3532 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3533 : int     r1, r3;                         /* Values of R fields        */
; 3534 : U16     i2;                             /* 16-bit immediate operand  */
; 3535 : 
; 3536 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_d:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@z900_add_d
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_add_d:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@z900_add_d

; 3537 : 
; 3538 :     /* Add signed operands and set condition code */
; 3539 :     regs->psw.cc = add_signed (&(regs->GR_L(r1)),

  0007c	48 63 44 24 28	 movsxd	 rax, DWORD PTR r3$[rsp]
  00081	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  00086	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0008b	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00090	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00098	48 89 54 24 30	 mov	 QWORD PTR tv94[rsp], rdx
  0009d	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000a2	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000aa	8b d1		 mov	 edx, ecx
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 add_signed
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3540 :                                  (S16)i2,
; 3541 :                                  regs->GR_L(r3));
; 3542 : 
; 3543 :     /* Program check if fixed-point overflow */
; 3544 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000ca	83 f8 03	 cmp	 eax, 3
  000cd	75 25		 jne	 SHORT $LN6@z900_add_d
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000d8	83 e0 08	 and	 eax, 8
  000db	85 c0		 test	 eax, eax
  000dd	74 15		 je	 SHORT $LN6@z900_add_d

; 3545 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000df	ba 08 00 00 00	 mov	 edx, 8
  000e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_d:

; 3546 : 
; 3547 : } /* end DEF_INST(add_distinct_halfword_immediate) */

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
z900_add_distinct_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_distinct_long_register PROC

; 3510 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3511 : int     r1, r2, r3;                     /* Values of R fields        */
; 3512 : 
; 3513 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_d

; 3514 : 
; 3515 :     /* Add signed operands and set condition code */
; 3516 :     regs->psw.cc = add_signed_long(&(regs->GR_G(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	4d 8b 84 c0 80
	02 00 00	 mov	 r8, QWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 94 c8 80
	02 00 00	 mov	 rdx, QWORD PTR [rax+rcx*8+640]
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 add_signed_long
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3517 :                                      regs->GR_G(r2),
; 3518 :                                      regs->GR_G(r3));
; 3519 : 
; 3520 :     /* Program check if fixed-point overflow */
; 3521 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d2	83 f8 03	 cmp	 eax, 3
  000d5	75 25		 jne	 SHORT $LN6@z900_add_d
  000d7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000e0	83 e0 08	 and	 eax, 8
  000e3	85 c0		 test	 eax, eax
  000e5	74 15		 je	 SHORT $LN6@z900_add_d

; 3522 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e7	ba 08 00 00 00	 mov	 edx, 8
  000ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_d:

; 3523 : 
; 3524 : } /* end DEF_INST(add_distinct_long_register) */

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
z900_add_distinct_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
z900_add_distinct_register PROC

; 3487 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3488 : int     r1, r2, r3;                     /* Values of R fields        */
; 3489 : 
; 3490 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_add_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_add_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_add_d

; 3491 : 
; 3492 :     /* Add signed operands and set condition code */
; 3493 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3494 :             add_signed (&(regs->GR_L(r1)),
; 3495 :                     regs->GR_L(r2),
; 3496 :                     regs->GR_L(r3));
; 3497 : 
; 3498 :     /* Program check if fixed-point overflow */
; 3499 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@z900_add_d
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@z900_add_d

; 3500 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_add_d:

; 3501 : 
; 3502 : } /* end DEF_INST(add_distinct_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
z900_add_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_store_relative_long_long PROC

; 2286 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2287 : int     r1;                             /* Register number           */
; 2288 : VADR    effective_addr2;                /* Relative operand address  */
; 2289 : 
; 2290 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_store
$LN8@z900_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_store
$LN12@z900_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_store
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_store
$LN14@z900_store:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_store:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_store:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_store
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_store:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_store

; 2291 : 
; 2292 :     /* Program check if operand not on doubleword boundary */
; 2293 :     DW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 07	 and	 rax, 7
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_store
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_store:

; 2294 : 
; 2295 :     /* Store R1 register in instruction address space */
; 2296 :     ARCH_DEP(vstore8) ( regs->GR_G(r1), effective_addr2, USE_INST_SPACE, regs );

  0015b	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00160	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00165	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0016b	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00170	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0017d	e8 00 00 00 00	 call	 z900_vstore8

; 2297 : 
; 2298 : } /* end DEF_INST(store_relative_long_long) */

  00182	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00186	c3		 ret	 0
z900_store_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_store_relative_long PROC

; 2267 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2268 : int     r1;                             /* Register number           */
; 2269 : VADR    effective_addr2;                /* Relative operand address  */
; 2270 : 
; 2271 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_store
$LN8@z900_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_store
$LN12@z900_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_store
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_store
$LN14@z900_store:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_store:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_store:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_store
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_store:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_store

; 2272 : 
; 2273 :     /* Program check if operand not on fullword boundary */
; 2274 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_store
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_store:

; 2275 : 
; 2276 :     /* Store low 4 bytes of R1 register in instruction address space */
; 2277 :     ARCH_DEP(vstore4) ( regs->GR_L(r1), effective_addr2, USE_INST_SPACE, regs );

  0015b	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00160	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00165	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0016b	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00170	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0017c	e8 00 00 00 00	 call	 z900_vstore4

; 2278 : 
; 2279 : } /* end DEF_INST(store_relative_long) */

  00181	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00185	c3		 ret	 0
z900_store_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_store_halfword_relative_long PROC

; 2251 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2252 : int     r1;                             /* Register number           */
; 2253 : VADR    effective_addr2;                /* Relative operand address  */
; 2254 : 
; 2255 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_store
$LN7@z900_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_store
$LN11@z900_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_store
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_store
$LN13@z900_store:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_store:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_store:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_store
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_store:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_store

; 2256 : 
; 2257 :     /* Store low 2 bytes of R1 register in instruction address space */
; 2258 :     ARCH_DEP(vstore2) ( regs->GR_LHL(r1), effective_addr2, USE_INST_SPACE, regs );

  00138	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0013d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00142	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00148	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0014d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	0f b7 8c c1 80
	02 00 00	 movzx	 ecx, WORD PTR [rcx+rax*8+640]
  0015a	e8 00 00 00 00	 call	 z900_vstore2

; 2259 : 
; 2260 : } /* end DEF_INST(store_halfword_relative_long) */

  0015f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00163	c3		 ret	 0
z900_store_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_or_selected_bits_long_reg PROC

; 2234 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2235 :     ARCH_DEP( rotate_then_xxx_selected_bits_long_reg )( inst, regs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2236 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_or_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_insert_selected_bits_long_reg PROC

; 2227 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2228 :     ARCH_DEP( rotate_then_xxx_selected_bits_long_reg )( inst, regs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2229 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_insert_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_exclusive_or_selected_bits_long_reg PROC

; 2241 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2242 :     ARCH_DEP( rotate_then_xxx_selected_bits_long_reg )( inst, regs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2243 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_exclusive_or_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_rotate_then_and_selected_bits_long_reg PROC

; 2220 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2221 :     ARCH_DEP( rotate_then_xxx_selected_bits_long_reg )( inst, regs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_rotate_then_xxx_selected_bits_long_reg

; 2222 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_rotate_then_and_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
m1$ = 40
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_prefetch_data_relative_long PROC

; 2032 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2033 : int     m1;                             /* Mask value                */
; 2034 : VADR    effective_addr2;                /* Effective address         */
; 2035 : 
; 2036 :     RIL_A(inst, regs, m1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_prefe
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_prefe
$LN7@z900_prefe:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_prefe:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_prefe
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_prefe
$LN11@z900_prefe:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_prefe:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_prefe
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_prefe
$LN13@z900_prefe:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_prefe:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR m1$[rsp], eax
$LN4@z900_prefe:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_prefe
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_prefe:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_prefe

; 2037 : 
; 2038 :     /* On Hercules the Prefetch Data instruction acts as a no-op */
; 2039 : 
; 2040 : } /* end DEF_INST(prefetch_data_relative_long) */

  00138	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013c	c3		 ret	 0
z900_prefetch_data_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
x2$ = 40
b2$ = 44
tv131 = 48
m1$ = 52
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_prefetch_data PROC

; 2015 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2016 : int     m1;                             /* Mask value                */
; 2017 : int     x2;                             /* Index register            */
; 2018 : int     b2;                             /* Base of effective addr    */
; 2019 : VADR    effective_addr2;                /* Effective address         */
; 2020 : 
; 2021 :     RXY(inst, regs, m1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR m1$[rsp], eax
  00055	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_prefe
  0005c	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_prefe:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_prefe
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_prefe:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_prefe
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_prefe
$LN14@z900_prefe:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_prefe:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_prefe
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_prefe
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_prefe:
$LN7@z900_prefe:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_prefe
  0013b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_prefe:
$LN4@z900_prefe:
  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_prefe
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_prefe:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_prefe

; 2022 : 
; 2023 :     /* The Prefetch Data instruction acts as a no-op */
; 2024 : 
; 2025 : } /* end DEF_INST(prefetch_data) */

  00186	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018a	c3		 ret	 0
z900_prefetch_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
r1$ = 44
effective_addr2$ = 48
x2$ = 56
tv131 = 60
n$ = 64
tv183 = 72
inst$ = 96
regs$ = 104
z900_multiply_y PROC

; 1935 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1936 : int     r1;                             /* Value of R field          */
; 1937 : int     x2;                             /* Index register            */
; 1938 : int     b2;                             /* Base of effective addr    */
; 1939 : VADR    effective_addr2;                /* Effective address         */
; 1940 : U32     n;                              /* 32-bit operand values     */
; 1941 : 
; 1942 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_multi
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_multi:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_multi
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_multi:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN15@z900_multi
  000cb	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@z900_multi
$LN15@z900_multi:
  000d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@z900_multi:
  000dd	83 7c 24 3c 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_multi
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_multi
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_multi:
$LN7@z900_multi:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
$LN4@z900_multi:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_multi
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_multi

; 1943 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 1944 : 
; 1945 :     ODD_CHECK(r1, regs);

  00199	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0019d	83 e0 01	 and	 eax, 1
  001a0	85 c0		 test	 eax, eax
  001a2	74 15		 je	 SHORT $LN11@z900_multi
  001a4	ba 06 00 00 00	 mov	 edx, 6
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_multi:

; 1946 : 
; 1947 :     /* Load second operand from operand address */
; 1948 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  001b9	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_vfetch4
  001cc	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 1949 : 
; 1950 :     /* Multiply r1+1 by n and place result in r1 and r1+1 */
; 1951 :     mul_signed (&(regs->GR_L(r1)), &(regs->GR_L(r1+1)),

  001d0	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001d4	ff c0		 inc	 eax
  001d6	48 98		 cdqe
  001d8	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001dc	ff c1		 inc	 ecx
  001de	48 63 c9	 movsxd	 rcx, ecx
  001e1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001e6	48 8d 8c ca 80
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+640]
  001ee	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001f3	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001f8	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00200	48 89 54 24 48	 mov	 QWORD PTR tv183[rsp], rdx
  00205	44 8b 4c 24 40	 mov	 r9d, DWORD PTR n$[rsp]
  0020a	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0020f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  00217	48 8b d1	 mov	 rdx, rcx
  0021a	48 8b 44 24 48	 mov	 rax, QWORD PTR tv183[rsp]
  0021f	48 8b c8	 mov	 rcx, rax
  00222	e8 00 00 00 00	 call	 mul_signed

; 1952 :                     regs->GR_L(r1+1),
; 1953 :                     n);
; 1954 : 
; 1955 : } /* end DEF_INST(multiply_y) */

  00227	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0022b	c3		 ret	 0
z900_multiply_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
inst$ = 64
regs$ = 72
z900_multiply_single_immediate_long_fullword PROC

; 1917 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1918 : int     r1;                             /* Register number           */
; 1919 : int     opcd;                           /* Opcode                    */
; 1920 : U32     i2;                             /* 32-bit operand value      */
; 1921 : 
; 1922 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_multi
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_multi:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_multi

; 1923 : 
; 1924 :     /* Multiply signed operands ignoring overflow */
; 1925 :     regs->GR_G(r1) = (S64)regs->GR_G(r1) * (S32)i2;

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i2$[rsp]
  000a3	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  000b0	48 0f af c1	 imul	 rax, rcx
  000b4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000b9	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1926 : 
; 1927 : } /* end DEF_INST(multiply_single_immediate_long_fullword) */

  000c6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ca	c3		 ret	 0
z900_multiply_single_immediate_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
inst$ = 64
regs$ = 72
z900_multiply_single_immediate_fullword PROC

; 1899 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1900 : int     r1;                             /* Register number           */
; 1901 : int     opcd;                           /* Opcode                    */
; 1902 : U32     i2;                             /* 32-bit operand value      */
; 1903 : 
; 1904 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_multi:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@z900_multi
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_multi:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@z900_multi

; 1905 : 
; 1906 :     /* Multiply signed operands ignoring overflow */
; 1907 :     regs->GR_L(r1) = (S32)regs->GR_L(r1) * (S32)i2;

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000aa	0f af 44 24 24	 imul	 eax, DWORD PTR i2$[rsp]
  000af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000b9	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1908 : 
; 1909 : } /* end DEF_INST(multiply_single_immediate_fullword) */

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
z900_multiply_single_immediate_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
x2$ = 44
tv131 = 48
r1$ = 52
n$ = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_multiply_halfword_y PROC

; 1843 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1844 : int     r1;                             /* Value of R field          */
; 1845 : int     x2;                             /* Index register            */
; 1846 : int     b2;                             /* Base of effective addr    */
; 1847 : VADR    effective_addr2;                /* Effective address         */
; 1848 : S32     n;                              /* 32-bit operand values     */
; 1849 : 
; 1850 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_multi
  0005c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_multi:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_multi
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_multi:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_multi
  000cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_multi
$LN14@z900_multi:
  000d5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_multi:
  000dd	83 7c 24 30 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_multi
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_multi
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_multi:
$LN7@z900_multi:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_multi
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_multi:
$LN4@z900_multi:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_multi
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_multi:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_multi

; 1851 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 1852 : 
; 1853 :     /* Load 2 bytes from operand address */
; 1854 :     n = (S16)ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch2
  001ac	98		 cwde
  001ad	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 1855 : 
; 1856 :     /* Multiply R1 register by n, ignore leftmost 32 bits of
; 1857 :        result, and place rightmost 32 bits in R1 register */
; 1858 :     mul_signed ((U32 *)&n, &(regs->GR_L(r1)), regs->GR_L(r1), n);

  001b1	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001b6	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001bb	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001c0	48 8d 8c ca 80
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+640]
  001c8	44 8b 4c 24 38	 mov	 r9d, DWORD PTR n$[rsp]
  001cd	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001d2	44 8b 84 c2 80
	02 00 00	 mov	 r8d, DWORD PTR [rdx+rax*8+640]
  001da	48 8b d1	 mov	 rdx, rcx
  001dd	48 8d 4c 24 38	 lea	 rcx, QWORD PTR n$[rsp]
  001e2	e8 00 00 00 00	 call	 mul_signed

; 1859 : 
; 1860 : } /* end DEF_INST(multiply_halfword_y) */

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
z900_multiply_halfword_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
effective_addr1$ = 48
n$ = 56
inst$ = 80
regs$ = 88
z900_move_long_from_halfword_immediate PROC

; 1821 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1822 : int     b1;                             /* Base of effective addr    */
; 1823 : VADR    effective_addr1;                /* Effective address         */
; 1824 : S16     i2;                             /* 16-bit immediate value    */
; 1825 : S64     n;                              /* Sign-extended value of i2 */
; 1826 : 
; 1827 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_move_
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_move_:
$LN4@z900_move_:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_move_
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_move_:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_move_

; 1828 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1829 : 
; 1830 :     /* Sign-extend 16-bit immediate value to 64 bits */
; 1831 :     n = i2;

  000e6	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000ec	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 1832 : 
; 1833 :     /* Store 8-byte value at operand address */
; 1834 :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );

  000f1	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000f6	44 8b 44 24 24	 mov	 r8d, DWORD PTR b1$[rsp]
  000fb	48 8b 54 24 30	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00105	e8 00 00 00 00	 call	 z900_vstore8

; 1835 : 
; 1836 : } /* end DEF_INST(move_long_from_halfword_immediate) */

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
z900_move_long_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
effective_addr1$ = 48
inst$ = 80
regs$ = 88
z900_move_halfword_from_halfword_immediate PROC

; 1803 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1804 : int     b1;                             /* Base of effective addr    */
; 1805 : VADR    effective_addr1;                /* Effective address         */
; 1806 : S16     i2;                             /* 16-bit immediate value    */
; 1807 : 
; 1808 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_move_
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_move_:
$LN4@z900_move_:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_move_
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_move_:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_move_

; 1809 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1810 : 
; 1811 :     /* Store 16-bit immediate value at operand address */
; 1812 :     ARCH_DEP(vstore2) ( i2, effective_addr1, b1, regs );

  000e6	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000eb	44 8b 44 24 24	 mov	 r8d, DWORD PTR b1$[rsp]
  000f0	48 8b 54 24 30	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  000f5	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  000fa	e8 00 00 00 00	 call	 z900_vstore2

; 1813 : 
; 1814 : } /* end DEF_INST(move_halfword_from_halfword_immediate) */

  000ff	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00103	c3		 ret	 0
z900_move_halfword_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
n$ = 44
effective_addr1$ = 48
inst$ = 80
regs$ = 88
z900_move_fullword_from_halfword_immediate PROC

; 1781 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1782 : int     b1;                             /* Base of effective addr    */
; 1783 : VADR    effective_addr1;                /* Effective address         */
; 1784 : S16     i2;                             /* 16-bit immediate value    */
; 1785 : S32     n;                              /* Sign-extended value of i2 */
; 1786 : 
; 1787 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_move_
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 30	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_move_:
$LN4@z900_move_:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_move_
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_move_:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_move_

; 1788 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1789 : 
; 1790 :     /* Sign-extend 16-bit immediate value to 32 bits */
; 1791 :     n = i2;

  000e6	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000eb	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1792 : 
; 1793 :     /* Store 4-byte value at operand address */
; 1794 :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );

  000ef	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000f4	44 8b 44 24 24	 mov	 r8d, DWORD PTR b1$[rsp]
  000f9	48 8b 54 24 30	 mov	 rdx, QWORD PTR effective_addr1$[rsp]
  000fe	8b 4c 24 2c	 mov	 ecx, DWORD PTR n$[rsp]
  00102	e8 00 00 00 00	 call	 z900_vstore4

; 1795 : 
; 1796 : } /* end DEF_INST(move_fullword_from_halfword_immediate) */

  00107	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010b	c3		 ret	 0
z900_move_fullword_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
n$ = 40
r1$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_relative_long_long_fullword PROC

; 1757 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1758 : int     r1;                             /* Register number           */
; 1759 : VADR    effective_addr2;                /* Relative operand address  */
; 1760 : U32     n;                              /* Relative operand value    */
; 1761 : 
; 1762 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_load_
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_load_
$LN8@z900_load_:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_load_:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_load_
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_load_:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1763 : 
; 1764 :     /* Program check if operand not on fullword boundary */
; 1765 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_load_
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 1766 : 
; 1767 :     /* Load relative operand from instruction address space */
; 1768 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1769 : 
; 1770 :     /* Sign-extend operand value and load into R1 register */
; 1771 :     regs->GR_G(r1) = (S64)(S32)n;

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  00178	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017d	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1772 : 
; 1773 : } /* end DEF_INST(load_relative_long_long_fullword) */

  0018a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018e	c3		 ret	 0
z900_load_relative_long_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
n$ = 72
inst$ = 96
regs$ = 104
z900_load_relative_long_long PROC

; 1732 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1733 : int     r1;                             /* Register number           */
; 1734 : VADR    effective_addr2;                /* Relative operand address  */
; 1735 : U64     n;                              /* Relative operand value    */
; 1736 : 
; 1737 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_load_
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_load_
$LN8@z900_load_:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_load_:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_load_
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_load_:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1738 : 
; 1739 :     /* Program check if operand not on doubleword boundary */
; 1740 :     DW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 07	 and	 rax, 7
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_load_
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 1741 : 
; 1742 :     /* Load relative operand from instruction address space */
; 1743 :     n = ARCH_DEP(vfetch8) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch8
  0016f	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1744 : 
; 1745 :     /* Load operand value into R1 register */
; 1746 :     regs->GR_G(r1) = n;

  00174	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00183	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1747 : 
; 1748 : } /* end DEF_INST(load_relative_long_long) */

  0018b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018f	c3		 ret	 0
z900_load_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_relative_long PROC

; 1706 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1707 : int     r1;                             /* Register number           */
; 1708 : VADR    effective_addr2;                /* Relative operand address  */
; 1709 : U32     n;                              /* Relative operand value    */
; 1710 : 
; 1711 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_load_
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_load_
$LN8@z900_load_:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_load_:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_load_
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_load_:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1712 : 
; 1713 :     /* Program check if operand not on fullword boundary */
; 1714 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_load_
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 1715 : 
; 1716 :     PER_ZEROADDR_XCHECK( regs, r1 );

  0015b	8b 54 24 28	 mov	 edx, DWORD PTR r1$[rsp]
  0015f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1717 : 
; 1718 :     /* Load relative operand from instruction address space */
; 1719 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  00169	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0016e	ba ff ff ff ff	 mov	 edx, -1
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00178	e8 00 00 00 00	 call	 z900_vfetch4
  0017d	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1720 : 
; 1721 :     /* Load operand value into R1 register */
; 1722 :     regs->GR_L(r1) = n;

  00181	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00186	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	8b 54 24 2c	 mov	 edx, DWORD PTR n$[rsp]
  0018f	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1723 : 
; 1724 : } /* end DEF_INST(load_relative_long) */

  00196	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019a	c3		 ret	 0
z900_load_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_logical_relative_long_long_fullword PROC

; 1682 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1683 : int     r1;                             /* Register number           */
; 1684 : VADR    effective_addr2;                /* Relative operand address  */
; 1685 : U32     n;                              /* Relative operand value    */
; 1686 : 
; 1687 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_load_
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_load_
$LN8@z900_load_:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_load_:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_load_
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_load_:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1688 : 
; 1689 :     /* Program check if operand not on fullword boundary */
; 1690 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_load_
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_load_:

; 1691 : 
; 1692 :     /* Load relative operand from instruction address space */
; 1693 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1694 : 
; 1695 :     /* Zero-extend operand value and load into R1 register */
; 1696 :     regs->GR_G(r1) = n;

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	8b 4c 24 2c	 mov	 ecx, DWORD PTR n$[rsp]
  0017c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00181	48 89 8c c2 80
	02 00 00	 mov	 QWORD PTR [rdx+rax*8+640], rcx

; 1697 : 
; 1698 : } /* end DEF_INST(load_logical_relative_long_long_fullword) */

  00189	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018d	c3		 ret	 0
z900_load_logical_relative_long_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_logical_halfword_relative_long_long PROC

; 1660 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1661 : int     r1;                             /* Register number           */
; 1662 : VADR    effective_addr2;                /* Relative operand address  */
; 1663 : U16     n;                              /* Relative operand value    */
; 1664 : 
; 1665 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_load_
$LN7@z900_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_load_
$LN11@z900_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1666 : 
; 1667 :     /* Load relative operand from instruction address space */
; 1668 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1669 : 
; 1670 :     /* Zero-extend operand value and load into R1 register */
; 1671 :     regs->GR_G(r1) = n;

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	48 89 8c c2 80
	02 00 00	 mov	 QWORD PTR [rdx+rax*8+640], rcx

; 1672 : 
; 1673 : } /* end DEF_INST(load_logical_halfword_relative_long_long) */

  00168	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016c	c3		 ret	 0
z900_load_logical_halfword_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_logical_halfword_relative_long PROC

; 1639 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1640 : int     r1;                             /* Register number           */
; 1641 : VADR    effective_addr2;                /* Relative operand address  */
; 1642 : U16     n;                              /* Relative operand value    */
; 1643 : 
; 1644 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_load_
$LN7@z900_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_load_
$LN11@z900_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1645 : 
; 1646 :     /* Load relative operand from instruction address space */
; 1647 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1648 : 
; 1649 :     /* Zero-extend operand value and load into R1 register */
; 1650 :     regs->GR_L(r1) = n;

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	89 8c c2 80 02
	00 00		 mov	 DWORD PTR [rdx+rax*8+640], ecx

; 1651 : 
; 1652 : } /* end DEF_INST(load_logical_halfword_relative_long) */

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
z900_load_logical_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_halfword_relative_long_long PROC

; 1618 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1619 : int     r1;                             /* Register number           */
; 1620 : VADR    effective_addr2;                /* Relative operand address  */
; 1621 : U16     n;                              /* Relative operand value    */
; 1622 : 
; 1623 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_load_
$LN7@z900_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_load_
$LN11@z900_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1624 : 
; 1625 :     /* Load relative operand from instruction address space */
; 1626 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1627 : 
; 1628 :     /* Sign-extend operand value and load into R1 register */
; 1629 :     regs->GR_G(r1) = (S64)(S16)n;

  00151	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR n$[rsp]
  00157	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0015c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00161	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1630 : 
; 1631 : } /* end DEF_INST(load_halfword_relative_long_long) */

  00169	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016d	c3		 ret	 0
z900_load_halfword_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
offset$1 = 48
tv128 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_halfword_relative_long PROC

; 1597 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1598 : int     r1;                             /* Register number           */
; 1599 : VADR    effective_addr2;                /* Relative operand address  */
; 1600 : U16     n;                              /* Relative operand value    */
; 1601 : 
; 1602 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_load_
$LN7@z900_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_load_
$LN11@z900_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 38	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_load_:
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_load_
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_load_:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_load_

; 1603 : 
; 1604 :     /* Load relative operand from instruction address space */
; 1605 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1606 : 
; 1607 :     /* Sign-extend operand value and load into R1 register */
; 1608 :     regs->GR_L(r1) = (S32)(S16)n;

  00151	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  00156	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1609 : 
; 1610 : } /* end DEF_INST(load_halfword_relative_long) */

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
z900_load_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
x2$ = 56
r1$ = 60
tv131 = 64
tv178 = 68
tv179 = 72
n$ = 76
inst$ = 96
regs$ = 104
z900_load_and_test_long_fullword PROC

; 1571 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1572 : int     r1;                             /* Value of R field          */
; 1573 : int     x2;                             /* Index register            */
; 1574 : int     b2;                             /* Base of effective addr    */
; 1575 : VADR    effective_addr2;                /* Effective address         */
; 1576 : U32     n;                              /* Second operand value      */
; 1577 : 
; 1578 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_load_
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_load_:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_load_
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_load_
  000cb	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:
  000d5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_load_:
  000dd	83 7c 24 40 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_load_
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_load_:
$LN7@z900_load_:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_load_
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_load_
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_

; 1579 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 1580 : 
; 1581 :     /* Load R1 register from sign-extended second operand */
; 1582 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch4
  001ac	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 1583 :     regs->GR_G(r1) = (S64)(S32)n;

  001b0	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  001b5	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  001ba	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001bf	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1584 : 
; 1585 :     /* Set condition code according to value loaded */
; 1586 :     regs->psw.cc = (S64)regs->GR_G(r1) < 0 ? 1 :

  001c7	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  001da	7d 0a		 jge	 SHORT $LN18@z900_load_
  001dc	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  001e4	eb 2f		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  001e6	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001eb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  001f9	7e 0a		 jle	 SHORT $LN16@z900_load_
  001fb	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv178[rsp], 2
  00203	eb 08		 jmp	 SHORT $LN17@z900_load_
$LN16@z900_load_:
  00205	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN17@z900_load_:
  0020d	8b 44 24 44	 mov	 eax, DWORD PTR tv178[rsp]
  00211	89 44 24 48	 mov	 DWORD PTR tv179[rsp], eax
$LN19@z900_load_:
  00215	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0021a	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv179[rsp]
  0021f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1587 :                    (S64)regs->GR_G(r1) > 0 ? 2 : 0;
; 1588 : 
; 1589 : } /* end DEF_INST(load_and_test_long_fullword) */

  00222	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00226	c3		 ret	 0
z900_load_and_test_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
tv196 = 56
effective_addr2$ = 64
inst$ = 96
regs$ = 104
z900_load_address_extended_y PROC

; 1540 : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1541 : int     r1;                             /* Value of R field          */
; 1542 : int     x2;                             /* Index register            */
; 1543 : int     b2;                             /* Base of effective addr    */
; 1544 : VADR    effective_addr2;                /* Effective address         */
; 1545 : 
; 1546 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN11@z900_load_
  0005c	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_load_:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN12@z900_load_
  00093	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_load_:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN33@z900_load_
  000cb	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN34@z900_load_
$LN33@z900_load_:
  000d5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN34@z900_load_:
  000dd	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN13@z900_load_
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN14@z900_load_
  00112	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN14@z900_load_:
$LN13@z900_load_:
  0011f	48 63 44 24 24	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN15@z900_load_
  0013b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_load_:
$LN4@z900_load_:
  00157	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN16@z900_load_
  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_load_:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 1547 : 
; 1548 :     /* Load operand address into register */
; 1549 :     SET_GR_A(r1, regs,effective_addr2);

  00186	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00191	83 e0 01	 and	 eax, 1
  00194	85 c0		 test	 eax, eax
  00196	74 19		 je	 SHORT $LN17@z900_load_
  00198	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a7	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
  001af	eb 15		 jmp	 SHORT $LN18@z900_load_
$LN17@z900_load_:
  001b1	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  001b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	8b 54 24 40	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  001bf	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx
$LN18@z900_load_:
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	75 ba		 jne	 SHORT $LN7@z900_load_

; 1550 : 
; 1551 :     /* Load corresponding value into access register */
; 1552 :     if ( PRIMARY_SPACE_MODE(&(regs->psw)) )

  001cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001d5	85 c0		 test	 eax, eax
  001d7	75 1a		 jne	 SHORT $LN19@z900_load_

; 1553 :         regs->AR(r1) = ALET_PRIMARY;

  001d9	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  001de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	c7 84 81 00 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+768], 0
  001ee	e9 89 00 00 00	 jmp	 $LN20@z900_load_
$LN19@z900_load_:

; 1554 :     else if ( SECONDARY_SPACE_MODE(&(regs->psw)) )

  001f3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001fc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00201	75 17		 jne	 SHORT $LN21@z900_load_

; 1555 :         regs->AR(r1) = ALET_SECONDARY;

  00203	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  00208	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020d	c7 84 81 00 03
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+768], 1
  00218	eb 62		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:

; 1556 :     else if ( HOME_SPACE_MODE(&(regs->psw)) )

  0021a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0021f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00223	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00228	75 17		 jne	 SHORT $LN23@z900_load_

; 1557 :         regs->AR(r1) = ALET_HOME;

  0022a	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0022f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	c7 84 81 00 03
	00 00 02 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+768], 2
  0023f	eb 3b		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:

; 1558 :     else /* ACCESS_REGISTER_MODE(&(regs->psw)) */
; 1559 :         regs->AR(r1) = (b2 == 0) ? 0 : regs->AR(b2);

  00241	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00246	75 0a		 jne	 SHORT $LN35@z900_load_
  00248	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
  00250	eb 15		 jmp	 SHORT $LN36@z900_load_
$LN35@z900_load_:
  00252	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00257	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	8b 84 81 00 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+768]
  00263	89 44 24 38	 mov	 DWORD PTR tv196[rsp], eax
$LN36@z900_load_:
  00267	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0026c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	8b 54 24 38	 mov	 edx, DWORD PTR tv196[rsp]
  00275	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN24@z900_load_:
$LN22@z900_load_:
$LN20@z900_load_:
$LN10@z900_load_:

; 1560 :     SET_AEA_AR(regs, r1);

  0027c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00281	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00285	83 f8 40	 cmp	 eax, 64			; 00000040H
  00288	75 7e		 jne	 SHORT $LN25@z900_load_
  0028a	83 7c 24 20 00	 cmp	 DWORD PTR r1$[rsp], 0
  0028f	7e 77		 jle	 SHORT $LN25@z900_load_
  00291	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  00296	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002a3	75 1b		 jne	 SHORT $LN26@z900_load_
  002a5	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  002a9	83 c0 05	 add	 eax, 5
  002ac	48 98		 cdqe
  002ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002be	eb 48		 jmp	 SHORT $LN27@z900_load_
$LN26@z900_load_:
  002c0	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  002c5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ca	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  002d2	75 1b		 jne	 SHORT $LN28@z900_load_
  002d4	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  002d8	83 c0 05	 add	 eax, 5
  002db	48 98		 cdqe
  002dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002ed	eb 19		 jmp	 SHORT $LN29@z900_load_
$LN28@z900_load_:
  002ef	8b 44 24 20	 mov	 eax, DWORD PTR r1$[rsp]
  002f3	83 c0 05	 add	 eax, 5
  002f6	48 98		 cdqe
  002f8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002fd	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN29@z900_load_:
$LN27@z900_load_:
$LN25@z900_load_:
  00308	33 c0		 xor	 eax, eax
  0030a	85 c0		 test	 eax, eax
  0030c	0f 85 6a ff ff
	ff		 jne	 $LN10@z900_load_

; 1561 : 
; 1562 : } /* end DEF_INST(load_address_extended_y) */

  00312	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00316	c3		 ret	 0
z900_load_address_extended_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
disp2$1 = 36
effective_addr2$ = 40
temp$2 = 48
ai$ = 52
li$ = 56
b2$ = 60
tv92 = 64
r3$ = 68
ti$ = 72
inst$ = 96
regs$ = 104
z900_extract_cpu_attribute PROC

; 1465 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1466 : int     r1, r3;                         /* Register numbers          */
; 1467 : int     b2;                             /* Base of effective addr    */
; 1468 : VADR    effective_addr2;                /* Effective address         */
; 1469 : int     ai, li, ti;                     /* Operand address subfields */
; 1470 : 
; 1471 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 30	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 30	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 3c	 mov	 DWORD PTR b2$[rsp], eax
  00047	8b 44 24 30	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 10	 shr	 eax, 16
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 44	 mov	 DWORD PTR r3$[rsp], eax
  00055	8b 44 24 30	 mov	 eax, DWORD PTR temp$2[rsp]
  00059	c1 e8 14	 shr	 eax, 20
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
  00063	83 7c 24 3c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 22		 je	 SHORT $LN8@z900_extra
  0006a	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_extra:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 04	 imul	 rax, rax, 4
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN22@z900_extra
  000a2	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000aa	eb 08		 jmp	 SHORT $LN23@z900_extra
$LN22@z900_extra:
  000ac	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN23@z900_extra:
  000b4	83 7c 24 40 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b9	74 3b		 je	 SHORT $LN9@z900_extra
  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 04	 imul	 rax, rax, 4
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000cd	c1 e0 0c	 shl	 eax, 12
  000d0	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000d4	0b c8		 or	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000dc	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e0	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0d		 je	 SHORT $LN10@z900_extra
  000e9	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ed	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000f2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN10@z900_extra:
$LN9@z900_extra:
  000f6	48 63 44 24 24	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  000fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00100	48 03 c8	 add	 rcx, rax
  00103	48 8b c1	 mov	 rax, rcx
  00106	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0010b	33 c0		 xor	 eax, eax
  0010d	83 f8 06	 cmp	 eax, 6
  00110	74 1c		 je	 SHORT $LN11@z900_extra
  00112	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00117	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0011e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_extra:
$LN4@z900_extra:
  0012e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00133	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00137	48 83 c0 06	 add	 rax, 6
  0013b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00144	33 c0		 xor	 eax, eax
  00146	83 f8 06	 cmp	 eax, 6
  00149	74 0c		 je	 SHORT $LN12@z900_extra
  0014b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00150	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN12@z900_extra:
  00157	33 c0		 xor	 eax, eax
  00159	85 c0		 test	 eax, eax
  0015b	75 d1		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 1472 : 
; 1473 :     TXFC_INSTR_CHECK( regs );

  0015d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00162	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00169	85 c0		 test	 eax, eax
  0016b	74 36		 je	 SHORT $LN13@z900_extra
  0016d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00172	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00178	0f ba e8 0f	 bts	 eax, 15
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00187	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195224
  0018e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00194	ba 02 00 00 00	 mov	 edx, 2
  00199	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN13@z900_extra:
  001a3	33 c0		 xor	 eax, eax
  001a5	85 c0		 test	 eax, eax
  001a7	75 b4		 jne	 SHORT $LN7@z900_extra

; 1474 : 
; 1475 :     /* Address bit 63 contains the Type Indication (TI) */
; 1476 :     ti = effective_addr2 & 0x1;

  001a9	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001ae	48 83 e0 01	 and	 rax, 1
  001b2	89 44 24 48	 mov	 DWORD PTR ti$[rsp], eax

; 1477 : 
; 1478 :     /* Address bits 60-62 contain the Level Indication (LI) */
; 1479 :     li = (effective_addr2 >> 1) & 0x7;

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001bb	48 d1 e8	 shr	 rax, 1
  001be	48 83 e0 07	 and	 rax, 7
  001c2	89 44 24 38	 mov	 DWORD PTR li$[rsp], eax

; 1480 : 
; 1481 :     /* Address bits 56-59 contain the Attribute Indication (AI) */
; 1482 :     ai = (effective_addr2 >> 4) & 0xF;

  001c6	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001cb	48 c1 e8 04	 shr	 rax, 4
  001cf	48 83 e0 0f	 and	 rax, 15
  001d3	89 44 24 34	 mov	 DWORD PTR ai$[rsp], eax

; 1483 : 
; 1484 :     //logmsg ("ECAG ai=%d li=%d ti=%d\n", ai, li, ti);
; 1485 : 
; 1486 :     /* If reserved bits 40-55 are not zero then set r1 to all ones */
; 1487 :     if ((effective_addr2 & 0xFFFF00) != 0)

  001d7	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001dc	48 25 00 ff ff
	00		 and	 rax, 16776960		; 00ffff00H
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 1b		 je	 SHORT $LN14@z900_extra

; 1488 :     {
; 1489 :         regs->GR(r1) = 0xFFFFFFFFFFFFFFFFULL;

  001e7	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	48 c7 84 c1 80
	02 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax*8+640], -1

; 1490 :         return;

  001fd	e9 b7 00 00 00	 jmp	 $LN1@z900_extra
$LN14@z900_extra:

; 1491 :     }
; 1492 : 
; 1493 :     /* If AI=0 (topology summary) is requested, set register r1 to
; 1494 :        indicate that cache level 0 is private to this CPU and that
; 1495 :        cache levels 1-7 are not implemented */
; 1496 :     if (ai == 0)

  00202	83 7c 24 34 00	 cmp	 DWORD PTR ai$[rsp], 0
  00207	75 2f		 jne	 SHORT $LN15@z900_extra

; 1497 :     {
; 1498 :         regs->GR_H(r1) = 0x04000000;

  00209	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0020e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	c7 84 c1 84 02
	00 00 00 00 00
	04		 mov	 DWORD PTR [rcx+rax*8+644], 67108864 ; 04000000H

; 1499 :         regs->GR_L(r1) = 0x00000000;

  0021e	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  00223	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00228	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1500 :         return;

  00233	e9 81 00 00 00	 jmp	 $LN1@z900_extra
$LN15@z900_extra:

; 1501 :     }
; 1502 : 
; 1503 :     /* If cache level is not 0, set register r1 to all ones which
; 1504 :        indicates that the requested cache level is not implemented */
; 1505 :     if (li > 0)

  00238	83 7c 24 38 00	 cmp	 DWORD PTR li$[rsp], 0
  0023d	7e 18		 jle	 SHORT $LN16@z900_extra

; 1506 :     {
; 1507 :         regs->GR(r1) = 0xFFFFFFFFFFFFFFFFULL;

  0023f	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  00244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	48 c7 84 c1 80
	02 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax*8+640], -1

; 1508 :         return;

  00255	eb 62		 jmp	 SHORT $LN1@z900_extra
$LN16@z900_extra:

; 1509 :     }
; 1510 : 
; 1511 :     /* If AI=1 (cache line size) is requested for cache level 0
; 1512 :        set register r1 to indicate a fictitious cache line size */
; 1513 :     if (ai == 1 && li == 0)

  00257	83 7c 24 34 01	 cmp	 DWORD PTR ai$[rsp], 1
  0025c	75 1f		 jne	 SHORT $LN17@z900_extra
  0025e	83 7c 24 38 00	 cmp	 DWORD PTR li$[rsp], 0
  00263	75 18		 jne	 SHORT $LN17@z900_extra

; 1514 :     {
; 1515 :         regs->GR(r1) = ZCACHE_LINE_SIZE;

  00265	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0026a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	48 c7 84 c1 80
	02 00 00 00 01
	00 00		 mov	 QWORD PTR [rcx+rax*8+640], 256 ; 00000100H

; 1516 :         return;

  0027b	eb 3c		 jmp	 SHORT $LN1@z900_extra
$LN17@z900_extra:

; 1517 :     }
; 1518 : 
; 1519 :     /* If AI=2 (total cache size) is requested for cache level 0
; 1520 :        set register r1 to indicate a fictitious total cache size */
; 1521 :     if (ai == 2 && li == 0)

  0027d	83 7c 24 34 02	 cmp	 DWORD PTR ai$[rsp], 2
  00282	75 1f		 jne	 SHORT $LN18@z900_extra
  00284	83 7c 24 38 00	 cmp	 DWORD PTR li$[rsp], 0
  00289	75 18		 jne	 SHORT $LN18@z900_extra

; 1522 :     {
; 1523 :         regs->GR(r1) = ZCACHE_LINE_SIZE * 2048;

  0028b	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  00290	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	48 c7 84 c1 80
	02 00 00 00 00
	08 00		 mov	 QWORD PTR [rcx+rax*8+640], 524288 ; 00080000H

; 1524 :         return;

  002a1	eb 16		 jmp	 SHORT $LN1@z900_extra
$LN18@z900_extra:

; 1525 :     }
; 1526 : 
; 1527 :     /* Set register r1 to all ones indicating that the requested
; 1528 :        attribute indication is reserved */
; 1529 :     regs->GR(r1) = 0xFFFFFFFFFFFFFFFFULL;

  002a3	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  002a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	48 c7 84 c1 80
	02 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax*8+640], -1
$LN1@z900_extra:

; 1530 : 
; 1531 : } /* end DEF_INST(extract_cpu_attribute) */

  002b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002bd	c3		 ret	 0
z900_extract_cpu_attribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
tv164 = 48
tv165 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_relative_long_long_fullword PROC

; 1438 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1439 : int     r1;                             /* Register number           */
; 1440 : VADR    effective_addr2;                /* Relative operand address  */
; 1441 : U32     n;                              /* Relative operand value    */
; 1442 : 
; 1443 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1444 : 
; 1445 :     /* Program check if operand not on fullword boundary */
; 1446 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1447 : 
; 1448 :     /* Load relative operand from instruction address space */
; 1449 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1450 : 
; 1451 :     /* Compare signed operands and set condition code */
; 1452 :     regs->psw.cc =

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR n$[rsp]
  0017d	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0018a	7d 0a		 jge	 SHORT $LN18@z900_compa
  0018c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  00194	eb 33		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00196	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019b	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR n$[rsp]
  001a0	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001a5	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  001ad	7e 0a		 jle	 SHORT $LN16@z900_compa
  001af	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv164[rsp], 2
  001b7	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001b9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN17@z900_compa:
  001c1	8b 44 24 30	 mov	 eax, DWORD PTR tv164[rsp]
  001c5	89 44 24 34	 mov	 DWORD PTR tv165[rsp], eax
$LN19@z900_compa:
  001c9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ce	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv165[rsp]
  001d3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1453 :             (S64)regs->GR_G(r1) < (S32)n ? 1 :
; 1454 :             (S64)regs->GR_G(r1) > (S32)n ? 2 : 0;
; 1455 : 
; 1456 : } /* end DEF_INST(compare_relative_long_long_fullword) */

  001d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001da	c3		 ret	 0
z900_compare_relative_long_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
tv162 = 44
tv163 = 48
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
n$ = 80
inst$ = 112
regs$ = 120
z900_compare_relative_long_long PROC

; 1411 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1412 : int     r1;                             /* Register number           */
; 1413 : VADR    effective_addr2;                /* Relative operand address  */
; 1414 : U64     n;                              /* Relative operand value    */
; 1415 : 
; 1416 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1417 : 
; 1418 :     /* Program check if operand not on doubleword boundary */
; 1419 :     DW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 07	 and	 rax, 7
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1420 : 
; 1421 :     /* Load relative operand from instruction address space */
; 1422 :     n = ARCH_DEP(vfetch8) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch8
  0016f	48 89 44 24 50	 mov	 QWORD PTR n$[rsp], rax

; 1423 : 
; 1424 :     /* Compare signed operands and set condition code */
; 1425 :     regs->psw.cc =

  00174	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  00183	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0018b	7d 0a		 jge	 SHORT $LN18@z900_compa
  0018d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00195	eb 33		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00197	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  001a6	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  001ae	7e 0a		 jle	 SHORT $LN16@z900_compa
  001b0	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  001b8	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001ba	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN17@z900_compa:
  001c2	8b 44 24 2c	 mov	 eax, DWORD PTR tv162[rsp]
  001c6	89 44 24 30	 mov	 DWORD PTR tv163[rsp], eax
$LN19@z900_compa:
  001ca	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv163[rsp]
  001d4	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1426 :             (S64)regs->GR_G(r1) < (S64)n ? 1 :
; 1427 :             (S64)regs->GR_G(r1) > (S64)n ? 2 : 0;
; 1428 : 
; 1429 : } /* end DEF_INST(compare_relative_long_long) */

  001d7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001db	c3		 ret	 0
z900_compare_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
tv162 = 48
tv163 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_relative_long PROC

; 1385 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1386 : int     r1;                             /* Register number           */
; 1387 : VADR    effective_addr2;                /* Relative operand address  */
; 1388 : U32     n;                              /* Relative operand value    */
; 1389 : 
; 1390 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1391 : 
; 1392 :     /* Program check if operand not on fullword boundary */
; 1393 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1394 : 
; 1395 :     /* Load relative operand from instruction address space */
; 1396 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1397 : 
; 1398 :     /* Compare signed operands and set condition code */
; 1399 :     regs->psw.cc =

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	8b 54 24 2c	 mov	 edx, DWORD PTR n$[rsp]
  00181	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00188	7d 0a		 jge	 SHORT $LN18@z900_compa
  0018a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00192	eb 31		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00194	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00199	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	8b 54 24 2c	 mov	 edx, DWORD PTR n$[rsp]
  001a2	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  001a9	7e 0a		 jle	 SHORT $LN16@z900_compa
  001ab	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  001b3	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001b5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN17@z900_compa:
  001bd	8b 44 24 30	 mov	 eax, DWORD PTR tv162[rsp]
  001c1	89 44 24 34	 mov	 DWORD PTR tv163[rsp], eax
$LN19@z900_compa:
  001c5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ca	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv163[rsp]
  001cf	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1400 :             (S32)regs->GR_L(r1) < (S32)n ? 1 :
; 1401 :             (S32)regs->GR_L(r1) > (S32)n ? 2 : 0;
; 1402 : 
; 1403 : } /* end DEF_INST(compare_relative_long) */

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
z900_compare_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv159 = 48
tv160 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_relative_long_long_halfword PROC

; 1362 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1363 : int     r1;                             /* Register number           */
; 1364 : VADR    effective_addr2;                /* Relative operand address  */
; 1365 : U16     n;                              /* Relative operand value    */
; 1366 : 
; 1367 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_compa
$LN13@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1368 : 
; 1369 :     /* Load relative operand from instruction address space */
; 1370 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1371 : 
; 1372 :     /* Compare signed operands and set condition code */
; 1373 :     regs->psw.cc =

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00168	73 0a		 jae	 SHORT $LN17@z900_compa
  0016a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00172	eb 33		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:
  00174	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00179	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0017e	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0018b	76 0a		 jbe	 SHORT $LN15@z900_compa
  0018d	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv159[rsp], 2
  00195	eb 08		 jmp	 SHORT $LN16@z900_compa
$LN15@z900_compa:
  00197	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@z900_compa:
  0019f	8b 44 24 30	 mov	 eax, DWORD PTR tv159[rsp]
  001a3	89 44 24 34	 mov	 DWORD PTR tv160[rsp], eax
$LN18@z900_compa:
  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv160[rsp]
  001b1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1374 :             regs->GR_G(r1) < n ? 1 :
; 1375 :             regs->GR_G(r1) > n ? 2 : 0;
; 1376 : 
; 1377 : } /* end DEF_INST(compare_logical_relative_long_long_halfword) */

  001b4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b8	c3		 ret	 0
z900_compare_logical_relative_long_long_halfword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
tv164 = 48
tv165 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_relative_long_long_fullword PROC

; 1313 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1314 : int     r1;                             /* Register number           */
; 1315 : VADR    effective_addr2;                /* Relative operand address  */
; 1316 : U32     n;                              /* Relative operand value    */
; 1317 : 
; 1318 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1319 : 
; 1320 :     /* Program check if operand not on fullword boundary */
; 1321 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1322 : 
; 1323 :     /* Load relative operand from instruction address space */
; 1324 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1325 : 
; 1326 :     /* Compare signed operands and set condition code */
; 1327 :     regs->psw.cc =

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	8b 4c 24 2c	 mov	 ecx, DWORD PTR n$[rsp]
  0017c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00181	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00189	73 0a		 jae	 SHORT $LN18@z900_compa
  0018b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  00193	eb 32		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00195	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019a	8b 4c 24 2c	 mov	 ecx, DWORD PTR n$[rsp]
  0019e	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001a3	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  001ab	76 0a		 jbe	 SHORT $LN16@z900_compa
  001ad	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv164[rsp], 2
  001b5	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001b7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN17@z900_compa:
  001bf	8b 44 24 30	 mov	 eax, DWORD PTR tv164[rsp]
  001c3	89 44 24 34	 mov	 DWORD PTR tv165[rsp], eax
$LN19@z900_compa:
  001c7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001cc	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv165[rsp]
  001d1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1328 :             regs->GR_G(r1) < n ? 1 :
; 1329 :             regs->GR_G(r1) > n ? 2 : 0;
; 1330 : 
; 1331 : } /* end DEF_INST(compare_logical_relative_long_long_fullword) */

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
z900_compare_logical_relative_long_long_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
tv162 = 44
tv163 = 48
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
n$ = 80
inst$ = 112
regs$ = 120
z900_compare_logical_relative_long_long PROC

; 1286 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1287 : int     r1;                             /* Register number           */
; 1288 : VADR    effective_addr2;                /* Relative operand address  */
; 1289 : U64     n;                              /* Relative operand value    */
; 1290 : 
; 1291 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1292 : 
; 1293 :     /* Program check if operand not on doubleword boundary */
; 1294 :     DW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 07	 and	 rax, 7
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1295 : 
; 1296 :     /* Load relative operand from instruction address space */
; 1297 :     n = ARCH_DEP(vfetch8) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch8
  0016f	48 89 44 24 50	 mov	 QWORD PTR n$[rsp], rax

; 1298 : 
; 1299 :     /* Compare signed operands and set condition code */
; 1300 :     regs->psw.cc =

  00174	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  00183	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0018b	73 0a		 jae	 SHORT $LN18@z900_compa
  0018d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00195	eb 33		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00197	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0019c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  001a6	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  001ae	76 0a		 jbe	 SHORT $LN16@z900_compa
  001b0	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  001b8	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001ba	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN17@z900_compa:
  001c2	8b 44 24 2c	 mov	 eax, DWORD PTR tv162[rsp]
  001c6	89 44 24 30	 mov	 DWORD PTR tv163[rsp], eax
$LN19@z900_compa:
  001ca	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv163[rsp]
  001d4	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1301 :             regs->GR_G(r1) < n ? 1 :
; 1302 :             regs->GR_G(r1) > n ? 2 : 0;
; 1303 : 
; 1304 : } /* end DEF_INST(compare_logical_relative_long_long) */

  001d7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001db	c3		 ret	 0
z900_compare_logical_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv159 = 48
tv160 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_relative_long_halfword PROC

; 1339 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1340 : int     r1;                             /* Register number           */
; 1341 : VADR    effective_addr2;                /* Relative operand address  */
; 1342 : U16     n;                              /* Relative operand value    */
; 1343 : 
; 1344 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_compa
$LN13@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1345 : 
; 1346 :     /* Load relative operand from instruction address space */
; 1347 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1348 : 
; 1349 :     /* Compare signed operands and set condition code */
; 1350 :     regs->psw.cc =

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00167	73 0a		 jae	 SHORT $LN17@z900_compa
  00169	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00171	eb 32		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:
  00173	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  0017d	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00189	76 0a		 jbe	 SHORT $LN15@z900_compa
  0018b	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv159[rsp], 2
  00193	eb 08		 jmp	 SHORT $LN16@z900_compa
$LN15@z900_compa:
  00195	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@z900_compa:
  0019d	8b 44 24 30	 mov	 eax, DWORD PTR tv159[rsp]
  001a1	89 44 24 34	 mov	 DWORD PTR tv160[rsp], eax
$LN18@z900_compa:
  001a5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv160[rsp]
  001af	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1351 :             regs->GR_L(r1) < n ? 1 :
; 1352 :             regs->GR_L(r1) > n ? 2 : 0;
; 1353 : 
; 1354 : } /* end DEF_INST(compare_logical_relative_long_halfword) */

  001b2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b6	c3		 ret	 0
z900_compare_logical_relative_long_halfword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
n$ = 44
tv162 = 48
tv163 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_relative_long PROC

; 1260 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1261 : int     r1;                             /* Register number           */
; 1262 : VADR    effective_addr2;                /* Relative operand address  */
; 1263 : U32     n;                              /* Relative operand value    */
; 1264 : 
; 1265 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@z900_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@z900_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@z900_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@z900_compa
$LN12@z900_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@z900_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN14@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN15@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 1266 : 
; 1267 :     /* Program check if operand not on fullword boundary */
; 1268 :     FW_CHECK(effective_addr2, regs);

  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0013d	48 83 e0 03	 and	 rax, 3
  00141	48 85 c0	 test	 rax, rax
  00144	74 15		 je	 SHORT $LN6@z900_compa
  00146	ba 06 00 00 00	 mov	 edx, 6
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_compa:

; 1269 : 
; 1270 :     /* Load relative operand from instruction address space */
; 1271 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  0015b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00160	ba ff ff ff ff	 mov	 edx, -1
  00165	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0016a	e8 00 00 00 00	 call	 z900_vfetch4
  0016f	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1272 : 
; 1273 :     /* Compare signed operands and set condition code */
; 1274 :     regs->psw.cc =

  00173	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	8b 54 24 2c	 mov	 edx, DWORD PTR n$[rsp]
  00181	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00188	73 0a		 jae	 SHORT $LN18@z900_compa
  0018a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00192	eb 31		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  00194	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00199	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	8b 54 24 2c	 mov	 edx, DWORD PTR n$[rsp]
  001a2	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  001a9	76 0a		 jbe	 SHORT $LN16@z900_compa
  001ab	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  001b3	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001b5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN17@z900_compa:
  001bd	8b 44 24 30	 mov	 eax, DWORD PTR tv162[rsp]
  001c1	89 44 24 34	 mov	 DWORD PTR tv163[rsp], eax
$LN19@z900_compa:
  001c5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ca	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv163[rsp]
  001cf	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1275 :             regs->GR_L(r1) < n ? 1 :
; 1276 :             regs->GR_L(r1) > n ? 2 : 0;
; 1277 : 
; 1278 : } /* end DEF_INST(compare_logical_relative_long) */

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
z900_compare_logical_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
tv135 = 44
tv136 = 48
effective_addr1$ = 56
n$ = 64
inst$ = 96
regs$ = 104
z900_compare_logical_immediate_long_storage PROC

; 1238 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1239 : int     b1;                             /* Base of effective addr    */
; 1240 : VADR    effective_addr1;                /* Effective address         */
; 1241 : U16     i2;                             /* 16-bit immediate value    */
; 1242 : U64     n;                              /* 64-bit storage value      */
; 1243 : 
; 1244 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 1245 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1246 : 
; 1247 :     /* Load 64-bit value from first operand address */
; 1248 :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch8
  000f9	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 1249 : 
; 1250 :     /* Compare unsigned operands and set condition code */
; 1251 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fe	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  00103	48 39 44 24 40	 cmp	 QWORD PTR n$[rsp], rax
  00108	73 0a		 jae	 SHORT $LN10@z900_compa
  0010a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00112	eb 26		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00114	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  00119	48 39 44 24 40	 cmp	 QWORD PTR n$[rsp], rax
  0011e	76 0a		 jbe	 SHORT $LN8@z900_compa
  00120	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv135[rsp], 2
  00128	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  0012a	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN9@z900_compa:
  00132	8b 44 24 2c	 mov	 eax, DWORD PTR tv135[rsp]
  00136	89 44 24 30	 mov	 DWORD PTR tv136[rsp], eax
$LN11@z900_compa:
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv136[rsp]
  00144	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1252 : 
; 1253 : } /* end DEF_INST(compare_logical_immediate_long_storage) */

  00147	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0014b	c3		 ret	 0
z900_compare_logical_immediate_long_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
i2$ = 36
b1$ = 40
temp$1 = 44
tv137 = 48
tv138 = 52
effective_addr1$ = 56
inst$ = 80
regs$ = 88
z900_compare_logical_immediate_halfword_storage PROC

; 1216 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1217 : int     b1;                             /* Base of effective addr    */
; 1218 : VADR    effective_addr1;                /* Effective address         */
; 1219 : U16     i2;                             /* 16-bit immediate value    */
; 1220 : U16     n;                              /* 16-bit storage value      */
; 1221 : 
; 1222 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 24	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 28	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 1223 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 28	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1224 : 
; 1225 :     /* Load 16-bit value from first operand address */
; 1226 :     n = ARCH_DEP(vfetch2) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 28	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch2
  000f9	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1227 : 
; 1228 :     /* Compare unsigned operands and set condition code */
; 1229 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fe	0f b7 44 24 20	 movzx	 eax, WORD PTR n$[rsp]
  00103	0f b7 4c 24 24	 movzx	 ecx, WORD PTR i2$[rsp]
  00108	3b c1		 cmp	 eax, ecx
  0010a	7d 0a		 jge	 SHORT $LN10@z900_compa
  0010c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  00114	eb 28		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00116	0f b7 44 24 20	 movzx	 eax, WORD PTR n$[rsp]
  0011b	0f b7 4c 24 24	 movzx	 ecx, WORD PTR i2$[rsp]
  00120	3b c1		 cmp	 eax, ecx
  00122	7e 0a		 jle	 SHORT $LN8@z900_compa
  00124	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv137[rsp], 2
  0012c	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  0012e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN9@z900_compa:
  00136	8b 44 24 30	 mov	 eax, DWORD PTR tv137[rsp]
  0013a	89 44 24 34	 mov	 DWORD PTR tv138[rsp], eax
$LN11@z900_compa:
  0013e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00143	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv138[rsp]
  00148	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1230 : 
; 1231 : } /* end DEF_INST(compare_logical_immediate_halfword_storage) */

  0014b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014f	c3		 ret	 0
z900_compare_logical_immediate_halfword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
n$ = 44
tv135 = 48
tv136 = 52
effective_addr1$ = 56
inst$ = 80
regs$ = 88
z900_compare_logical_immediate_fullword_storage PROC

; 1194 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1195 : int     b1;                             /* Base of effective addr    */
; 1196 : VADR    effective_addr1;                /* Effective address         */
; 1197 : U16     i2;                             /* 16-bit immediate value    */
; 1198 : U32     n;                              /* 32-bit storage value      */
; 1199 : 
; 1200 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 1201 :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 1202 : 
; 1203 :     /* Load 32-bit value from first operand address */
; 1204 :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch4
  000f9	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 1205 : 
; 1206 :     /* Compare unsigned operands and set condition code */
; 1207 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fd	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  00102	39 44 24 2c	 cmp	 DWORD PTR n$[rsp], eax
  00106	73 0a		 jae	 SHORT $LN10@z900_compa
  00108	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00110	eb 25		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00112	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  00117	39 44 24 2c	 cmp	 DWORD PTR n$[rsp], eax
  0011b	76 0a		 jbe	 SHORT $LN8@z900_compa
  0011d	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv135[rsp], 2
  00125	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00127	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN9@z900_compa:
  0012f	8b 44 24 30	 mov	 eax, DWORD PTR tv135[rsp]
  00133	89 44 24 34	 mov	 DWORD PTR tv136[rsp], eax
$LN11@z900_compa:
  00137	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv136[rsp]
  00141	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1208 : 
; 1209 : } /* end DEF_INST(compare_logical_immediate_fullword_storage) */

  00144	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00148	c3		 ret	 0
z900_compare_logical_immediate_fullword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_logical_immediate_and_trap_long PROC

; 1167 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1168 : int     r1;                             /* Register number           */
; 1169 : int     m3;                             /* Mask bits                 */
; 1170 : int     cc;                             /* Comparison result         */
; 1171 : U16     i2;                             /* 16-bit immediate value    */
; 1172 : 
; 1173 :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@z900_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@z900_compa

; 1174 : 
; 1175 :     /* Compare unsigned operands and set comparison result */
; 1176 :     cc = regs->GR_G(r1) < i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a0	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000a8	73 0a		 jae	 SHORT $LN10@z900_compa
  000aa	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b2	eb 33		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000b4	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b9	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c3	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000cb	76 0a		 jbe	 SHORT $LN8@z900_compa
  000cd	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d5	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@z900_compa:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e3	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@z900_compa:
  000e7	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000eb	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1177 :          regs->GR_G(r1) > i2 ? 2 : 0;
; 1178 : 
; 1179 :     /* Raise data exception if m3 mask bit is set */
; 1180 :     if ((0x8 >> cc) & m3)

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00103	d3 f8		 sar	 eax, cl
  00105	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00109	85 c0		 test	 eax, eax
  0010b	74 1e		 je	 SHORT $LN6@z900_compa

; 1181 :     {
; 1182 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 1183 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 1184 :     }
; 1185 : 
; 1186 : } /* end DEF_INST(compare_logical_immediate_and_trap_long) */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
z900_compare_logical_immediate_and_trap_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_logical_immediate_and_trap_fullword PROC

; 1140 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1141 : int     r1;                             /* Register number           */
; 1142 : int     m3;                             /* Mask bits                 */
; 1143 : int     cc;                             /* Comparison result         */
; 1144 : U16     i2;                             /* 16-bit immediate value    */
; 1145 : 
; 1146 :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@z900_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@z900_compa

; 1147 : 
; 1148 :     /* Compare unsigned operands and set comparison result */
; 1149 :     cc = regs->GR_L(r1) < i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a0	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000a7	73 0a		 jae	 SHORT $LN10@z900_compa
  000a9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b1	eb 32		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000b3	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000c9	76 0a		 jbe	 SHORT $LN8@z900_compa
  000cb	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d3	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@z900_compa:
  000dd	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e1	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@z900_compa:
  000e5	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e9	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1150 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1151 : 
; 1152 :     /* Raise data exception if m3 mask bit is set */
; 1153 :     if ((0x8 >> cc) & m3)

  000ed	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f1	b9 08 00 00 00	 mov	 ecx, 8
  000f6	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00101	d3 f8		 sar	 eax, cl
  00103	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00107	85 c0		 test	 eax, eax
  00109	74 1e		 je	 SHORT $LN6@z900_compa

; 1154 :     {
; 1155 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 1156 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 1157 :     }
; 1158 : 
; 1159 : } /* end DEF_INST(compare_logical_immediate_and_trap_fullword) */

  00129	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012d	c3		 ret	 0
z900_compare_logical_immediate_and_trap_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
ri4$ = 36
temp$1 = 40
r1$ = 44
tv145 = 48
tv146 = 52
m3$ = 56
cc$ = 60
tv188 = 64
inst$ = 96
regs$ = 104
z900_compare_logical_immediate_and_branch_relative_long PROC

; 1108 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1109 : int     r1;                             /* Register number           */
; 1110 : int     m3;                             /* Mask bits                 */
; 1111 : BYTE    i2;                             /* Immediate operand value   */
; 1112 : S16     ri4;                            /* 16-bit relative offset    */
; 1113 : int     cc;                             /* Comparison result         */
; 1114 : 
; 1115 :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 24	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN8@z900_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1116 : 
; 1117 :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a1	85 c0		 test	 eax, eax
  000a3	74 4c		 je	 SHORT $LN9@z900_compa
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 10		 jne	 SHORT $LN10@z900_compa
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b0	74 09		 je	 SHORT $LN10@z900_compa
  000b2	0f bf 44 24 24	 movsx	 eax, WORD PTR ri4$[rsp]
  000b7	85 c0		 test	 eax, eax
  000b9	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0e	 bts	 eax, 14
  000ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194966
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba fe ff ff ff	 mov	 edx, -2
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 9e		 jne	 SHORT $LN7@z900_compa

; 1118 : 
; 1119 :     /* Compare unsigned operands and set comparison result */
; 1120 :     cc = regs->GR_G(r1) < i2 ? 1 :

  000f7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00101	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00106	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0010e	73 0a		 jae	 SHORT $LN16@z900_compa
  00110	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  00118	eb 33		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0011a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0011f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00124	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00131	76 0a		 jbe	 SHORT $LN14@z900_compa
  00133	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv145[rsp], 2
  0013b	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0013d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN15@z900_compa:
  00145	8b 44 24 30	 mov	 eax, DWORD PTR tv145[rsp]
  00149	89 44 24 34	 mov	 DWORD PTR tv146[rsp], eax
$LN17@z900_compa:
  0014d	8b 44 24 34	 mov	 eax, DWORD PTR tv146[rsp]
  00151	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 1121 :          regs->GR_G(r1) > i2 ? 2 : 0;
; 1122 : 
; 1123 :     /* Branch to immediate offset if m3 mask bit is set */
; 1124 :     if ((0x8 >> cc) & m3)

  00155	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00159	b9 08 00 00 00	 mov	 ecx, 8
  0015e	89 4c 24 40	 mov	 DWORD PTR tv188[rsp], ecx
  00162	0f b6 c8	 movzx	 ecx, al
  00165	8b 44 24 40	 mov	 eax, DWORD PTR tv188[rsp]
  00169	d3 f8		 sar	 eax, cl
  0016b	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  0016f	85 c0		 test	 eax, eax
  00171	74 18		 je	 SHORT $LN11@z900_compa

; 1125 :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  00173	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR ri4$[rsp]
  00179	48 d1 e0	 shl	 rax, 1
  0017c	48 8b d0	 mov	 rdx, rax
  0017f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  00189	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 1126 :     else
; 1127 :     {
; 1128 :         /* Bump ip to next sequential instruction */
; 1129 :         regs->ip += 6;

  0018b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00190	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00194	48 83 c0 06	 add	 rax, 6
  00198	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 1130 :     }
; 1131 : 
; 1132 : } /* end DEF_INST( compare_logical_immediate_and_branch_relative_long ) */

  001a1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a5	c3		 ret	 0
z900_compare_logical_immediate_and_branch_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
ri4$ = 36
temp$1 = 40
r1$ = 44
tv145 = 48
tv146 = 52
m3$ = 56
cc$ = 60
tv188 = 64
inst$ = 96
regs$ = 104
z900_compare_logical_immediate_and_branch_relative PROC

; 1076 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1077 : int     r1;                             /* Register number           */
; 1078 : int     m3;                             /* Mask bits                 */
; 1079 : BYTE    i2;                             /* Immediate operand value   */
; 1080 : S16     ri4;                            /* 16-bit relative offset    */
; 1081 : int     cc;                             /* Comparison result         */
; 1082 : 
; 1083 :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 24	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN8@z900_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1084 : 
; 1085 :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a1	85 c0		 test	 eax, eax
  000a3	74 4c		 je	 SHORT $LN9@z900_compa
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 10		 jne	 SHORT $LN10@z900_compa
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b0	74 09		 je	 SHORT $LN10@z900_compa
  000b2	0f bf 44 24 24	 movsx	 eax, WORD PTR ri4$[rsp]
  000b7	85 c0		 test	 eax, eax
  000b9	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0e	 bts	 eax, 14
  000ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194943
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba fe ff ff ff	 mov	 edx, -2
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 9e		 jne	 SHORT $LN7@z900_compa

; 1086 : 
; 1087 :     /* Compare unsigned operands and set comparison result */
; 1088 :     cc = regs->GR_L(r1) < i2 ? 1 :

  000f7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00101	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00106	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0010d	73 0a		 jae	 SHORT $LN16@z900_compa
  0010f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  00117	eb 32		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00119	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0011e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00123	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00128	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0012f	76 0a		 jbe	 SHORT $LN14@z900_compa
  00131	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv145[rsp], 2
  00139	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0013b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN15@z900_compa:
  00143	8b 44 24 30	 mov	 eax, DWORD PTR tv145[rsp]
  00147	89 44 24 34	 mov	 DWORD PTR tv146[rsp], eax
$LN17@z900_compa:
  0014b	8b 44 24 34	 mov	 eax, DWORD PTR tv146[rsp]
  0014f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 1089 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1090 : 
; 1091 :     /* Branch to immediate offset if m3 mask bit is set */
; 1092 :     if ((0x8 >> cc) & m3)

  00153	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00157	b9 08 00 00 00	 mov	 ecx, 8
  0015c	89 4c 24 40	 mov	 DWORD PTR tv188[rsp], ecx
  00160	0f b6 c8	 movzx	 ecx, al
  00163	8b 44 24 40	 mov	 eax, DWORD PTR tv188[rsp]
  00167	d3 f8		 sar	 eax, cl
  00169	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  0016d	85 c0		 test	 eax, eax
  0016f	74 18		 je	 SHORT $LN11@z900_compa

; 1093 :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  00171	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR ri4$[rsp]
  00177	48 d1 e0	 shl	 rax, 1
  0017a	48 8b d0	 mov	 rdx, rax
  0017d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  00187	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 1094 :     else
; 1095 :     {
; 1096 :         /* Bump ip to next sequential instruction */
; 1097 :         regs->ip += 6;

  00189	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00192	48 83 c0 06	 add	 rax, 6
  00196	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 1098 :     }
; 1099 : 
; 1100 : } /* end DEF_INST( compare_logical_immediate_and_branch_relative ) */

  0019f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a3	c3		 ret	 0
z900_compare_logical_immediate_and_branch_relative ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
tv149 = 48
tv150 = 52
effective_addr4$ = 56
cc$ = 64
tv197 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_immediate_and_branch_long PROC

; 1043 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1044 : int     r1;                             /* Register number           */
; 1045 : int     m3;                             /* Mask bits                 */
; 1046 : int     b4;                             /* Base of effective addr    */
; 1047 : VADR    effective_addr4;                /* Effective address         */
; 1048 : int     cc;                             /* Comparison result         */
; 1049 : BYTE    i2;                             /* Immediate value           */
; 1050 : 
; 1051 :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00065	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00073	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  00078	74 3e		 je	 SHORT $LN8@z900_compa
  0007a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00091	48 03 c8	 add	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0009c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000ad	48 23 c8	 and	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN9@z900_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1052 : 
; 1053 :     TXFC_INSTR_CHECK_IP( regs );

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ea	85 c0		 test	 eax, eax
  000ec	74 36		 je	 SHORT $LN10@z900_compa
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f9	0f ba e8 0f	 bts	 eax, 15
  000fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00102	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194920
  0010f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00115	ba fe ff ff ff	 mov	 edx, -2
  0011a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 b4		 jne	 SHORT $LN7@z900_compa

; 1054 : 
; 1055 :     /* Compare unsigned operands and set comparison result */
; 1056 :     cc = regs->GR_G(r1) < i2 ? 1 :

  0012a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00134	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00139	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00141	73 0a		 jae	 SHORT $LN16@z900_compa
  00143	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  0014b	eb 33		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0014d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00152	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00157	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0015c	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00164	76 0a		 jbe	 SHORT $LN14@z900_compa
  00166	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  0016e	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00170	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN15@z900_compa:
  00178	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  0017c	89 44 24 34	 mov	 DWORD PTR tv150[rsp], eax
$LN17@z900_compa:
  00180	8b 44 24 34	 mov	 eax, DWORD PTR tv150[rsp]
  00184	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 1057 :          regs->GR_G(r1) > i2 ? 2 : 0;
; 1058 : 
; 1059 :     /* Branch to operand address if m3 mask bit is set */
; 1060 :     if ((0x8 >> cc) & m3)

  00188	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  0018c	b9 08 00 00 00	 mov	 ecx, 8
  00191	89 4c 24 44	 mov	 DWORD PTR tv197[rsp], ecx
  00195	0f b6 c8	 movzx	 ecx, al
  00198	8b 44 24 44	 mov	 eax, DWORD PTR tv197[rsp]
  0019c	d3 f8		 sar	 eax, cl
  0019e	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001a2	85 c0		 test	 eax, eax
  001a4	74 11		 je	 SHORT $LN11@z900_compa

; 1061 :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001a6	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001b5	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 1062 :     else
; 1063 :     {
; 1064 :         /* Bump ip to next sequential instruction */
; 1065 :         regs->ip += 6;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001c0	48 83 c0 06	 add	 rax, 6
  001c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 1066 :     }
; 1067 : 
; 1068 : } /* end DEF_INST(compare_logical_immediate_and_branch_long) */

  001cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d1	c3		 ret	 0
z900_compare_logical_immediate_and_branch_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
tv149 = 48
tv150 = 52
effective_addr4$ = 56
cc$ = 64
tv197 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_immediate_and_branch PROC

; 1010 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1011 : int     r1;                             /* Register number           */
; 1012 : int     m3;                             /* Mask bits                 */
; 1013 : int     b4;                             /* Base of effective addr    */
; 1014 : VADR    effective_addr4;                /* Effective address         */
; 1015 : int     cc;                             /* Comparison result         */
; 1016 : BYTE    i2;                             /* Immediate value           */
; 1017 : 
; 1018 :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00065	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00073	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  00078	74 3e		 je	 SHORT $LN8@z900_compa
  0007a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00091	48 03 c8	 add	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0009c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000ad	48 23 c8	 and	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN9@z900_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 1019 : 
; 1020 :     TXFC_INSTR_CHECK_IP( regs );

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ea	85 c0		 test	 eax, eax
  000ec	74 36		 je	 SHORT $LN10@z900_compa
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f9	0f ba e8 0f	 bts	 eax, 15
  000fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00102	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194896
  0010f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00115	ba fe ff ff ff	 mov	 edx, -2
  0011a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 b4		 jne	 SHORT $LN7@z900_compa

; 1021 : 
; 1022 :     /* Compare unsigned operands and set comparison result */
; 1023 :     cc = regs->GR_L(r1) < i2 ? 1 :

  0012a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00134	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00139	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00140	73 0a		 jae	 SHORT $LN16@z900_compa
  00142	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  0014a	eb 32		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0014c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00151	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  00156	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0015b	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00162	76 0a		 jbe	 SHORT $LN14@z900_compa
  00164	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  0016c	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0016e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN15@z900_compa:
  00176	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  0017a	89 44 24 34	 mov	 DWORD PTR tv150[rsp], eax
$LN17@z900_compa:
  0017e	8b 44 24 34	 mov	 eax, DWORD PTR tv150[rsp]
  00182	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 1024 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1025 : 
; 1026 :     /* Branch to operand address if m3 mask bit is set */
; 1027 :     if ((0x8 >> cc) & m3)

  00186	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  0018a	b9 08 00 00 00	 mov	 ecx, 8
  0018f	89 4c 24 44	 mov	 DWORD PTR tv197[rsp], ecx
  00193	0f b6 c8	 movzx	 ecx, al
  00196	8b 44 24 44	 mov	 eax, DWORD PTR tv197[rsp]
  0019a	d3 f8		 sar	 eax, cl
  0019c	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 11		 je	 SHORT $LN11@z900_compa

; 1028 :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001b3	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 1029 :     else
; 1030 :     {
; 1031 :         /* Bump ip to next sequential instruction */
; 1032 :         regs->ip += 6;

  001b5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001be	48 83 c0 06	 add	 rax, 6
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 1033 :     }
; 1034 : 
; 1035 : } /* end DEF_INST(compare_logical_immediate_and_branch) */

  001cb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cf	c3		 ret	 0
z900_compare_logical_immediate_and_branch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_logical_and_trap_register PROC

; 958  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 959  : int     r1, r2;                         /* Register numbers          */
; 960  : int     m3;                             /* Mask bits                 */
; 961  : int     cc;                             /* Comparison result         */
; 962  : 
; 963  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_compa

; 964  : 
; 965  :     /* Compare unsigned operands and set comparison result */
; 966  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0009c	73 0a		 jae	 SHORT $LN10@z900_compa
  0009e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a6	eb 3f		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000a8	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ad	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000c4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cb	76 0a		 jbe	 SHORT $LN8@z900_compa
  000cd	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d5	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@z900_compa:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e3	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@z900_compa:
  000e7	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000eb	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 967  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 968  : 
; 969  :     /* Raise data exception if m3 mask bit is set */
; 970  :     if ((0x8 >> cc) & m3)

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00103	d3 f8		 sar	 eax, cl
  00105	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00109	85 c0		 test	 eax, eax
  0010b	74 1e		 je	 SHORT $LN6@z900_compa

; 971  :     {
; 972  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 973  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 974  :     }
; 975  : 
; 976  : } /* end DEF_INST(compare_logical_and_trap_register) */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
z900_compare_logical_and_trap_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_logical_and_trap_long_register PROC

; 984  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 985  : int     r1, r2;                         /* Register numbers          */
; 986  : int     m3;                             /* Mask bits                 */
; 987  : int     cc;                             /* Comparison result         */
; 988  : 
; 989  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_compa

; 990  : 
; 991  :     /* Compare unsigned operands and set comparison result */
; 992  :     cc = regs->GR_G(r1) < regs->GR_G(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00095	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0009d	73 0a		 jae	 SHORT $LN10@z900_compa
  0009f	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a7	eb 40		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000a9	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ae	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bd	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  000c5	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000cd	76 0a		 jbe	 SHORT $LN8@z900_compa
  000cf	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d7	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@z900_compa:
  000e1	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e5	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@z900_compa:
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000ed	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 993  :          regs->GR_G(r1) > regs->GR_G(r2) ? 2 : 0;
; 994  : 
; 995  :     /* Raise data exception if m3 mask bit is set */
; 996  :     if ((0x8 >> cc) & m3)

  000f1	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f5	b9 08 00 00 00	 mov	 ecx, 8
  000fa	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fe	0f b6 c8	 movzx	 ecx, al
  00101	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00105	d3 f8		 sar	 eax, cl
  00107	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 1e		 je	 SHORT $LN6@z900_compa

; 997  :     {
; 998  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 999  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011e	ba 07 00 00 00	 mov	 edx, 7
  00123	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 1000 :     }
; 1001 : 
; 1002 : } /* end DEF_INST(compare_logical_and_trap_long_register) */

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
z900_compare_logical_and_trap_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
ri4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
tv153 = 48
tv154 = 52
m3$ = 56
cc$ = 60
tv201 = 64
inst$ = 96
regs$ = 104
z900_compare_logical_and_branch_relative_register PROC

; 896  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 897  : int     r1, r2;                         /* Register numbers          */
; 898  : int     m3;                             /* Mask bits                 */
; 899  : S16     ri4;                            /* 16-bit relative offset    */
; 900  : int     cc;                             /* Comparison result         */
; 901  : 
; 902  :     RIE_RRIM_B( inst, regs, r1, r2, ri4, m3 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR ri4$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN8@z900_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 903  : 
; 904  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a2	85 c0		 test	 eax, eax
  000a4	74 4c		 je	 SHORT $LN9@z900_compa
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 10		 jne	 SHORT $LN10@z900_compa
  000ac	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b1	74 09		 je	 SHORT $LN10@z900_compa
  000b3	0f bf 44 24 20	 movsx	 eax, WORD PTR ri4$[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c7	0f ba e8 0e	 bts	 eax, 14
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194819
  000dd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e3	ba fe ff ff ff	 mov	 edx, -2
  000e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 9e		 jne	 SHORT $LN7@z900_compa

; 905  : 
; 906  :     /* Compare unsigned operands and set comparison result */
; 907  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  000f8	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fd	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00107	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0010c	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00114	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0011b	73 0a		 jae	 SHORT $LN16@z900_compa
  0011d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00125	eb 3f		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00127	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012c	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00131	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00136	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013b	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00143	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0014a	76 0a		 jbe	 SHORT $LN14@z900_compa
  0014c	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv153[rsp], 2
  00154	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00156	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN15@z900_compa:
  0015e	8b 44 24 30	 mov	 eax, DWORD PTR tv153[rsp]
  00162	89 44 24 34	 mov	 DWORD PTR tv154[rsp], eax
$LN17@z900_compa:
  00166	8b 44 24 34	 mov	 eax, DWORD PTR tv154[rsp]
  0016a	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 908  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 909  : 
; 910  :     /* Branch to immediate offset if m3 mask bit is set */
; 911  :     if ((0x8 >> cc) & m3)

  0016e	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00172	b9 08 00 00 00	 mov	 ecx, 8
  00177	89 4c 24 40	 mov	 DWORD PTR tv201[rsp], ecx
  0017b	0f b6 c8	 movzx	 ecx, al
  0017e	8b 44 24 40	 mov	 eax, DWORD PTR tv201[rsp]
  00182	d3 f8		 sar	 eax, cl
  00184	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  00188	85 c0		 test	 eax, eax
  0018a	74 18		 je	 SHORT $LN11@z900_compa

; 912  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0018c	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR ri4$[rsp]
  00192	48 d1 e0	 shl	 rax, 1
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  001a2	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 913  :     else
; 914  :     {
; 915  :         /* Bump ip to next sequential instruction */
; 916  :         regs->ip += 6;

  001a4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001a9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001ad	48 83 c0 06	 add	 rax, 6
  001b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 917  :     }
; 918  : 
; 919  : } /* end DEF_INST(compare_logical_and_branch_relative_register) */

  001ba	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001be	c3		 ret	 0
z900_compare_logical_and_branch_relative_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
ri4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
tv153 = 48
tv154 = 52
m3$ = 56
cc$ = 60
tv201 = 64
inst$ = 96
regs$ = 104
z900_compare_logical_and_branch_relative_long_register PROC

; 927  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 928  : int     r1, r2;                         /* Register numbers          */
; 929  : int     m3;                             /* Mask bits                 */
; 930  : S16     ri4;                            /* 16-bit relative offset    */
; 931  : int     cc;                             /* Comparison result         */
; 932  : 
; 933  :     RIE_RRIM_B( inst, regs, r1, r2, ri4, m3 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR ri4$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN8@z900_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 934  : 
; 935  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a2	85 c0		 test	 eax, eax
  000a4	74 4c		 je	 SHORT $LN9@z900_compa
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 10		 jne	 SHORT $LN10@z900_compa
  000ac	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b1	74 09		 je	 SHORT $LN10@z900_compa
  000b3	0f bf 44 24 20	 movsx	 eax, WORD PTR ri4$[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c7	0f ba e8 0e	 bts	 eax, 14
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194842
  000dd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e3	ba fe ff ff ff	 mov	 edx, -2
  000e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 9e		 jne	 SHORT $LN7@z900_compa

; 936  : 
; 937  :     /* Compare unsigned operands and set comparison result */
; 938  :     cc = regs->GR_G(r1) < regs->GR_G(r2) ? 1 :

  000f8	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fd	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00107	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0010c	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00114	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0011c	73 0a		 jae	 SHORT $LN16@z900_compa
  0011e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00126	eb 40		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00128	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012d	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00132	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00137	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013c	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00144	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0014c	76 0a		 jbe	 SHORT $LN14@z900_compa
  0014e	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv153[rsp], 2
  00156	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00158	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN15@z900_compa:
  00160	8b 44 24 30	 mov	 eax, DWORD PTR tv153[rsp]
  00164	89 44 24 34	 mov	 DWORD PTR tv154[rsp], eax
$LN17@z900_compa:
  00168	8b 44 24 34	 mov	 eax, DWORD PTR tv154[rsp]
  0016c	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 939  :          regs->GR_G(r1) > regs->GR_G(r2) ? 2 : 0;
; 940  : 
; 941  :     /* Branch to immediate offset if m3 mask bit is set */
; 942  :     if ((0x8 >> cc) & m3)

  00170	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	89 4c 24 40	 mov	 DWORD PTR tv201[rsp], ecx
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 44 24 40	 mov	 eax, DWORD PTR tv201[rsp]
  00184	d3 f8		 sar	 eax, cl
  00186	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  0018a	85 c0		 test	 eax, eax
  0018c	74 18		 je	 SHORT $LN11@z900_compa

; 943  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0018e	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR ri4$[rsp]
  00194	48 d1 e0	 shl	 rax, 1
  00197	48 8b d0	 mov	 rdx, rax
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  001a4	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 944  :     else
; 945  :     {
; 946  :         /* Bump ip to next sequential instruction */
; 947  :         regs->ip += 6;

  001a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001af	48 83 c0 06	 add	 rax, 6
  001b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 948  :     }
; 949  : 
; 950  : } /* end DEF_INST(compare_logical_and_branch_relative_long_register) */

  001bc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c0	c3		 ret	 0
z900_compare_logical_and_branch_relative_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
b4$ = 36
r1$ = 40
r2$ = 44
tv160 = 48
tv161 = 52
effective_addr4$ = 56
cc$ = 64
tv213 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_and_branch_register PROC

; 832  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 833  : int     r1, r2;                         /* Register numbers          */
; 834  : int     m3;                             /* Mask bits                 */
; 835  : int     b4;                             /* Base of effective addr    */
; 836  : VADR    effective_addr4;                /* Effective address         */
; 837  : int     cc;                             /* Comparison result         */
; 838  : 
; 839  :     RRS_B(inst, regs, r1, r2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	8b c0		 mov	 eax, eax
  0004a	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 24	 mov	 DWORD PTR b4$[rsp], eax
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0006b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 14	 shr	 eax, 20
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00079	83 7c 24 24 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007e	74 3e		 je	 SHORT $LN8@z900_compa
  00080	48 63 44 24 24	 movsxd	 rax, DWORD PTR b4$[rsp]
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000b3	48 23 c8	 and	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000cb	33 c0		 xor	 eax, eax
  000cd	83 f8 06	 cmp	 eax, 6
  000d0	74 0c		 je	 SHORT $LN9@z900_compa
  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 840  : 
; 841  :     TXFC_INSTR_CHECK_IP( regs );

  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000f0	85 c0		 test	 eax, eax
  000f2	74 36		 je	 SHORT $LN10@z900_compa
  000f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0f	 bts	 eax, 15
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194772
  00115	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011b	ba fe ff ff ff	 mov	 edx, -2
  00120	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 b4		 jne	 SHORT $LN7@z900_compa

; 842  : 
; 843  :     /* Compare unsigned operands and set comparison result */
; 844  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  00130	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0013a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0013f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00144	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  0014c	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00153	73 0a		 jae	 SHORT $LN16@z900_compa
  00155	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0015d	eb 3f		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0015f	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00164	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00169	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016e	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00173	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  0017b	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00182	76 0a		 jbe	 SHORT $LN14@z900_compa
  00184	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
  0018c	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0018e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN15@z900_compa:
  00196	8b 44 24 30	 mov	 eax, DWORD PTR tv160[rsp]
  0019a	89 44 24 34	 mov	 DWORD PTR tv161[rsp], eax
$LN17@z900_compa:
  0019e	8b 44 24 34	 mov	 eax, DWORD PTR tv161[rsp]
  001a2	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 845  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 846  : 
; 847  :     /* Branch to operand address if m3 mask bit is set */
; 848  :     if ((0x8 >> cc) & m3)

  001a6	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  001aa	b9 08 00 00 00	 mov	 ecx, 8
  001af	89 4c 24 44	 mov	 DWORD PTR tv213[rsp], ecx
  001b3	0f b6 c8	 movzx	 ecx, al
  001b6	8b 44 24 44	 mov	 eax, DWORD PTR tv213[rsp]
  001ba	d3 f8		 sar	 eax, cl
  001bc	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001c0	85 c0		 test	 eax, eax
  001c2	74 11		 je	 SHORT $LN11@z900_compa

; 849  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001d3	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 850  :     else
; 851  :     {
; 852  :         /* Bump ip to next sequential instruction */
; 853  :         regs->ip += 6;

  001d5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001da	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001de	48 83 c0 06	 add	 rax, 6
  001e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 854  :     }
; 855  : 
; 856  : } /* end DEF_INST(compare_logical_and_branch_register) */

  001eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ef	c3		 ret	 0
z900_compare_logical_and_branch_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
b4$ = 36
r1$ = 40
r2$ = 44
tv160 = 48
tv161 = 52
effective_addr4$ = 56
cc$ = 64
tv213 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_logical_and_branch_long_register PROC

; 864  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 865  : int     r1, r2;                         /* Register numbers          */
; 866  : int     m3;                             /* Mask bits                 */
; 867  : int     b4;                             /* Base of effective addr    */
; 868  : VADR    effective_addr4;                /* Effective address         */
; 869  : int     cc;                             /* Comparison result         */
; 870  : 
; 871  :     RRS_B(inst, regs, r1, r2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	8b c0		 mov	 eax, eax
  0004a	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 24	 mov	 DWORD PTR b4$[rsp], eax
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0006b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 14	 shr	 eax, 20
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00079	83 7c 24 24 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007e	74 3e		 je	 SHORT $LN8@z900_compa
  00080	48 63 44 24 24	 movsxd	 rax, DWORD PTR b4$[rsp]
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000b3	48 23 c8	 and	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000cb	33 c0		 xor	 eax, eax
  000cd	83 f8 06	 cmp	 eax, 6
  000d0	74 0c		 je	 SHORT $LN9@z900_compa
  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 872  : 
; 873  :     TXFC_INSTR_CHECK_IP( regs );

  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000f0	85 c0		 test	 eax, eax
  000f2	74 36		 je	 SHORT $LN10@z900_compa
  000f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0f	 bts	 eax, 15
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194796
  00115	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011b	ba fe ff ff ff	 mov	 edx, -2
  00120	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 b4		 jne	 SHORT $LN7@z900_compa

; 874  : 
; 875  :     /* Compare unsigned operands and set comparison result */
; 876  :     cc = regs->GR_G(r1) < regs->GR_G(r2) ? 1 :

  00130	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0013a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0013f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00144	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  0014c	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00154	73 0a		 jae	 SHORT $LN16@z900_compa
  00156	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0015e	eb 40		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00160	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00165	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0016a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00174	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  0017c	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00184	76 0a		 jbe	 SHORT $LN14@z900_compa
  00186	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
  0018e	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00190	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN15@z900_compa:
  00198	8b 44 24 30	 mov	 eax, DWORD PTR tv160[rsp]
  0019c	89 44 24 34	 mov	 DWORD PTR tv161[rsp], eax
$LN17@z900_compa:
  001a0	8b 44 24 34	 mov	 eax, DWORD PTR tv161[rsp]
  001a4	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 877  :          regs->GR_G(r1) > regs->GR_G(r2) ? 2 : 0;
; 878  : 
; 879  :     /* Branch to operand address if m3 mask bit is set */
; 880  :     if ((0x8 >> cc) & m3)

  001a8	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  001ac	b9 08 00 00 00	 mov	 ecx, 8
  001b1	89 4c 24 44	 mov	 DWORD PTR tv213[rsp], ecx
  001b5	0f b6 c8	 movzx	 ecx, al
  001b8	8b 44 24 44	 mov	 eax, DWORD PTR tv213[rsp]
  001bc	d3 f8		 sar	 eax, cl
  001be	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001c2	85 c0		 test	 eax, eax
  001c4	74 11		 je	 SHORT $LN11@z900_compa

; 881  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001c6	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001d5	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 882  :     else
; 883  :     {
; 884  :         /* Bump ip to next sequential instruction */
; 885  :         regs->ip += 6;

  001d7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001e0	48 83 c0 06	 add	 rax, 6
  001e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 886  :     }
; 887  : 
; 888  : } /* end DEF_INST(compare_logical_and_branch_long_register) */

  001ed	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f1	c3		 ret	 0
z900_compare_logical_and_branch_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_immediate_and_trap_long PROC

; 805  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 806  : int     r1;                             /* Register number           */
; 807  : int     m3;                             /* Mask bits                 */
; 808  : int     cc;                             /* Comparison result         */
; 809  : U16     i2;                             /* 16-bit immediate value    */
; 810  : 
; 811  :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@z900_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@z900_compa

; 812  : 
; 813  :     /* Compare signed operands and set comparison result */
; 814  :     cc = (S64)regs->GR_G(r1) < (S64)(S16)i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	48 0f bf 4c 24
	20		 movsx	 rcx, WORD PTR i2$[rsp]
  0009c	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a1	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000a9	7d 0a		 jge	 SHORT $LN10@z900_compa
  000ab	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b3	eb 34		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000b5	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ba	48 0f bf 4c 24
	20		 movsx	 rcx, WORD PTR i2$[rsp]
  000c0	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c5	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000cd	7e 0a		 jle	 SHORT $LN8@z900_compa
  000cf	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d7	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@z900_compa:
  000e1	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e5	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@z900_compa:
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000ed	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 815  :          (S64)regs->GR_G(r1) > (S64)(S16)i2 ? 2 : 0;
; 816  : 
; 817  :     /* Raise data exception if m3 mask bit is set */
; 818  :     if ((0x8 >> cc) & m3)

  000f1	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f5	b9 08 00 00 00	 mov	 ecx, 8
  000fa	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fe	0f b6 c8	 movzx	 ecx, al
  00101	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00105	d3 f8		 sar	 eax, cl
  00107	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 1e		 je	 SHORT $LN6@z900_compa

; 819  :     {
; 820  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 821  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011e	ba 07 00 00 00	 mov	 edx, 7
  00123	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 822  :     }
; 823  : 
; 824  : } /* end DEF_INST(compare_immediate_and_trap_long) */

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
z900_compare_immediate_and_trap_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_immediate_and_trap PROC

; 778  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 779  : int     r1;                             /* Register number           */
; 780  : int     m3;                             /* Mask bits                 */
; 781  : int     cc;                             /* Comparison result         */
; 782  : U16     i2;                             /* 16-bit immediate value    */
; 783  : 
; 784  :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@z900_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@z900_compa

; 785  : 
; 786  :     /* Compare signed operands and set comparison result */
; 787  :     cc = (S32)regs->GR_L(r1) < (S32)(S16)i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a0	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000a7	7d 0a		 jge	 SHORT $LN10@z900_compa
  000a9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b1	eb 32		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000b3	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000c9	7e 0a		 jle	 SHORT $LN8@z900_compa
  000cb	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d3	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@z900_compa:
  000dd	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e1	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@z900_compa:
  000e5	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e9	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 788  :          (S32)regs->GR_L(r1) > (S32)(S16)i2 ? 2 : 0;
; 789  : 
; 790  :     /* Raise data exception if m3 mask bit is set */
; 791  :     if ((0x8 >> cc) & m3)

  000ed	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f1	b9 08 00 00 00	 mov	 ecx, 8
  000f6	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00101	d3 f8		 sar	 eax, cl
  00103	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00107	85 c0		 test	 eax, eax
  00109	74 1e		 je	 SHORT $LN6@z900_compa

; 792  :     {
; 793  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 794  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 795  :     }
; 796  : 
; 797  : } /* end DEF_INST(compare_immediate_and_trap) */

  00129	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012d	c3		 ret	 0
z900_compare_immediate_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
ri4$ = 36
temp$1 = 40
r1$ = 44
tv145 = 48
tv146 = 52
m3$ = 56
cc$ = 60
tv188 = 64
inst$ = 96
regs$ = 104
z900_compare_immediate_and_branch_relative_long PROC

; 746  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 747  : int     r1;                             /* Register numbers          */
; 748  : int     m3;                             /* Mask bits                 */
; 749  : BYTE    i2;                             /* Immediate operand value   */
; 750  : S16     ri4;                            /* 16-bit relative offset    */
; 751  : int     cc;                             /* Comparison result         */
; 752  : 
; 753  :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 24	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN8@z900_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 754  : 
; 755  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a1	85 c0		 test	 eax, eax
  000a3	74 4c		 je	 SHORT $LN9@z900_compa
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 10		 jne	 SHORT $LN10@z900_compa
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b0	74 09		 je	 SHORT $LN10@z900_compa
  000b2	0f bf 44 24 24	 movsx	 eax, WORD PTR ri4$[rsp]
  000b7	85 c0		 test	 eax, eax
  000b9	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0e	 bts	 eax, 14
  000ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194706
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba fe ff ff ff	 mov	 edx, -2
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 9e		 jne	 SHORT $LN7@z900_compa

; 756  : 
; 757  :     /* Compare signed operands and set comparison result */
; 758  :     cc = (S64)regs->GR_G(r1) < (S64)(S8)i2 ? 1 :

  000f7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fc	48 0f be 4c 24
	20		 movsx	 rcx, BYTE PTR i2$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00107	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0010f	7d 0a		 jge	 SHORT $LN16@z900_compa
  00111	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  00119	eb 34		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0011b	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00120	48 0f be 4c 24
	20		 movsx	 rcx, BYTE PTR i2$[rsp]
  00126	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0012b	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00133	7e 0a		 jle	 SHORT $LN14@z900_compa
  00135	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv145[rsp], 2
  0013d	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0013f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN15@z900_compa:
  00147	8b 44 24 30	 mov	 eax, DWORD PTR tv145[rsp]
  0014b	89 44 24 34	 mov	 DWORD PTR tv146[rsp], eax
$LN17@z900_compa:
  0014f	8b 44 24 34	 mov	 eax, DWORD PTR tv146[rsp]
  00153	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 759  :          (S64)regs->GR_G(r1) > (S64)(S8)i2 ? 2 : 0;
; 760  : 
; 761  :     /* Branch to immediate offset if m3 mask bit is set */
; 762  :     if ((0x8 >> cc) & m3)

  00157	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  0015b	b9 08 00 00 00	 mov	 ecx, 8
  00160	89 4c 24 40	 mov	 DWORD PTR tv188[rsp], ecx
  00164	0f b6 c8	 movzx	 ecx, al
  00167	8b 44 24 40	 mov	 eax, DWORD PTR tv188[rsp]
  0016b	d3 f8		 sar	 eax, cl
  0016d	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  00171	85 c0		 test	 eax, eax
  00173	74 18		 je	 SHORT $LN11@z900_compa

; 763  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  00175	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR ri4$[rsp]
  0017b	48 d1 e0	 shl	 rax, 1
  0017e	48 8b d0	 mov	 rdx, rax
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  0018b	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 764  :     else
; 765  :     {
; 766  :         /* Bump ip to next sequential instruction */
; 767  :         regs->ip += 6;

  0018d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00192	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00196	48 83 c0 06	 add	 rax, 6
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 768  :     }
; 769  : 
; 770  : } /* end DEF_INST( compare_immediate_and_branch_relative_long ) */

  001a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a7	c3		 ret	 0
z900_compare_immediate_and_branch_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
ri4$ = 36
temp$1 = 40
r1$ = 44
tv145 = 48
tv146 = 52
m3$ = 56
cc$ = 60
tv188 = 64
inst$ = 96
regs$ = 104
z900_compare_immediate_and_branch_relative PROC

; 714  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 715  : int     r1;                             /* Register numbers          */
; 716  : int     m3;                             /* Mask bits                 */
; 717  : BYTE    i2;                             /* Immediate operand value   */
; 718  : S16     ri4;                            /* 16-bit relative offset    */
; 719  : int     cc;                             /* Comparison result         */
; 720  : 
; 721  :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 24	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN8@z900_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 722  : 
; 723  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00095	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a1	85 c0		 test	 eax, eax
  000a3	74 4c		 je	 SHORT $LN9@z900_compa
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 10		 jne	 SHORT $LN10@z900_compa
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b0	74 09		 je	 SHORT $LN10@z900_compa
  000b2	0f bf 44 24 24	 movsx	 eax, WORD PTR ri4$[rsp]
  000b7	85 c0		 test	 eax, eax
  000b9	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c6	0f ba e8 0e	 bts	 eax, 14
  000ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194677
  000dc	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e2	ba fe ff ff ff	 mov	 edx, -2
  000e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f1	33 c0		 xor	 eax, eax
  000f3	85 c0		 test	 eax, eax
  000f5	75 9e		 jne	 SHORT $LN7@z900_compa

; 724  : 
; 725  :     /* Compare signed operands and set comparison result */
; 726  :     cc = (S32)regs->GR_L(r1) < (S32)(S8)i2 ? 1 :

  000f7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fc	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  00101	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00106	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0010d	7d 0a		 jge	 SHORT $LN16@z900_compa
  0010f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  00117	eb 32		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00119	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0011e	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  00123	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00128	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0012f	7e 0a		 jle	 SHORT $LN14@z900_compa
  00131	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv145[rsp], 2
  00139	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0013b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN15@z900_compa:
  00143	8b 44 24 30	 mov	 eax, DWORD PTR tv145[rsp]
  00147	89 44 24 34	 mov	 DWORD PTR tv146[rsp], eax
$LN17@z900_compa:
  0014b	8b 44 24 34	 mov	 eax, DWORD PTR tv146[rsp]
  0014f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 727  :          (S32)regs->GR_L(r1) > (S32)(S8)i2 ? 2 : 0;
; 728  : 
; 729  :     /* Branch to immediate offset if m3 mask bit is set */
; 730  :     if ((0x8 >> cc) & m3)

  00153	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00157	b9 08 00 00 00	 mov	 ecx, 8
  0015c	89 4c 24 40	 mov	 DWORD PTR tv188[rsp], ecx
  00160	0f b6 c8	 movzx	 ecx, al
  00163	8b 44 24 40	 mov	 eax, DWORD PTR tv188[rsp]
  00167	d3 f8		 sar	 eax, cl
  00169	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  0016d	85 c0		 test	 eax, eax
  0016f	74 18		 je	 SHORT $LN11@z900_compa

; 731  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  00171	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR ri4$[rsp]
  00177	48 d1 e0	 shl	 rax, 1
  0017a	48 8b d0	 mov	 rdx, rax
  0017d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  00187	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 732  :     else
; 733  :     {
; 734  :         /* Bump ip to next sequential instruction */
; 735  :         regs->ip += 6;

  00189	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00192	48 83 c0 06	 add	 rax, 6
  00196	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 736  :     }
; 737  : 
; 738  : } /* end DEF_INST( compare_immediate_and_branch_relative ) */

  0019f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a3	c3		 ret	 0
z900_compare_immediate_and_branch_relative ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
tv149 = 48
tv150 = 52
effective_addr4$ = 56
cc$ = 64
tv197 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_immediate_and_branch_long PROC

; 681  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 682  : int     r1;                             /* Register number           */
; 683  : int     m3;                             /* Mask bits                 */
; 684  : int     b4;                             /* Base of effective addr    */
; 685  : VADR    effective_addr4;                /* Effective address         */
; 686  : int     cc;                             /* Comparison result         */
; 687  : BYTE    i2;                             /* Immediate value           */
; 688  : 
; 689  :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00065	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00073	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  00078	74 3e		 je	 SHORT $LN8@z900_compa
  0007a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00091	48 03 c8	 add	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0009c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000ad	48 23 c8	 and	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN9@z900_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 690  : 
; 691  :     TXFC_INSTR_CHECK_IP( regs );

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ea	85 c0		 test	 eax, eax
  000ec	74 36		 je	 SHORT $LN10@z900_compa
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f9	0f ba e8 0f	 bts	 eax, 15
  000fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00102	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194648
  0010f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00115	ba fe ff ff ff	 mov	 edx, -2
  0011a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 b4		 jne	 SHORT $LN7@z900_compa

; 692  : 
; 693  :     /* Compare signed operands and set comparison result */
; 694  :     cc = (S64)regs->GR_G(r1) < (S64)(S8)i2 ? 1 :

  0012a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	48 0f be 4c 24
	20		 movsx	 rcx, BYTE PTR i2$[rsp]
  00135	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0013a	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00142	7d 0a		 jge	 SHORT $LN16@z900_compa
  00144	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  0014c	eb 34		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0014e	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00153	48 0f be 4c 24
	20		 movsx	 rcx, BYTE PTR i2$[rsp]
  00159	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0015e	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00166	7e 0a		 jle	 SHORT $LN14@z900_compa
  00168	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  00170	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00172	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN15@z900_compa:
  0017a	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  0017e	89 44 24 34	 mov	 DWORD PTR tv150[rsp], eax
$LN17@z900_compa:
  00182	8b 44 24 34	 mov	 eax, DWORD PTR tv150[rsp]
  00186	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 695  :          (S64)regs->GR_G(r1) > (S64)(S8)i2 ? 2 : 0;
; 696  : 
; 697  :     /* Branch to operand address if m3 mask bit is set */
; 698  :     if ((0x8 >> cc) & m3)

  0018a	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  0018e	b9 08 00 00 00	 mov	 ecx, 8
  00193	89 4c 24 44	 mov	 DWORD PTR tv197[rsp], ecx
  00197	0f b6 c8	 movzx	 ecx, al
  0019a	8b 44 24 44	 mov	 eax, DWORD PTR tv197[rsp]
  0019e	d3 f8		 sar	 eax, cl
  001a0	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001a4	85 c0		 test	 eax, eax
  001a6	74 11		 je	 SHORT $LN11@z900_compa

; 699  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001a8	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001b7	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 700  :     else
; 701  :     {
; 702  :         /* Bump ip to next sequential instruction */
; 703  :         regs->ip += 6;

  001b9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001be	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001c2	48 83 c0 06	 add	 rax, 6
  001c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 704  :     }
; 705  : 
; 706  : } /* end DEF_INST(compare_immediate_and_branch_long) */

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
z900_compare_immediate_and_branch_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
tv149 = 48
tv150 = 52
effective_addr4$ = 56
cc$ = 64
tv197 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_immediate_and_branch PROC

; 648  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 649  : int     r1;                             /* Register number           */
; 650  : int     m3;                             /* Mask bits                 */
; 651  : int     b4;                             /* Base of effective addr    */
; 652  : VADR    effective_addr4;                /* Effective address         */
; 653  : int     cc;                             /* Comparison result         */
; 654  : BYTE    i2;                             /* Immediate value           */
; 655  : 
; 656  :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  00049	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	c1 e8 10	 shr	 eax, 16
  0005e	83 e0 0f	 and	 eax, 15
  00061	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00065	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00069	c1 e8 14	 shr	 eax, 20
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00073	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  00078	74 3e		 je	 SHORT $LN8@z900_compa
  0007a	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00091	48 03 c8	 add	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0009c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000ad	48 23 c8	 and	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000c5	33 c0		 xor	 eax, eax
  000c7	83 f8 06	 cmp	 eax, 6
  000ca	74 0c		 je	 SHORT $LN9@z900_compa
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 657  : 
; 658  :     TXFC_INSTR_CHECK_IP( regs );

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000ea	85 c0		 test	 eax, eax
  000ec	74 36		 je	 SHORT $LN10@z900_compa
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f9	0f ba e8 0f	 bts	 eax, 15
  000fd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00102	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194618
  0010f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00115	ba fe ff ff ff	 mov	 edx, -2
  0011a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 b4		 jne	 SHORT $LN7@z900_compa

; 659  : 
; 660  :     /* Compare signed operands and set comparison result */
; 661  :     cc = (S32)regs->GR_L(r1) < (S32)(S8)i2 ? 1 :

  0012a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012f	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  00134	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00139	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00140	7d 0a		 jge	 SHORT $LN16@z900_compa
  00142	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  0014a	eb 32		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0014c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00151	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  00156	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0015b	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00162	7e 0a		 jle	 SHORT $LN14@z900_compa
  00164	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  0016c	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0016e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN15@z900_compa:
  00176	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  0017a	89 44 24 34	 mov	 DWORD PTR tv150[rsp], eax
$LN17@z900_compa:
  0017e	8b 44 24 34	 mov	 eax, DWORD PTR tv150[rsp]
  00182	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 662  :          (S32)regs->GR_L(r1) > (S32)(S8)i2 ? 2 : 0;
; 663  : 
; 664  :     /* Branch to operand address if m3 mask bit is set */
; 665  :     if ((0x8 >> cc) & m3)

  00186	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  0018a	b9 08 00 00 00	 mov	 ecx, 8
  0018f	89 4c 24 44	 mov	 DWORD PTR tv197[rsp], ecx
  00193	0f b6 c8	 movzx	 ecx, al
  00196	8b 44 24 44	 mov	 eax, DWORD PTR tv197[rsp]
  0019a	d3 f8		 sar	 eax, cl
  0019c	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 11		 je	 SHORT $LN11@z900_compa

; 666  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001b3	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 667  :     else
; 668  :     {
; 669  :         /* Bump ip to next sequential instruction */
; 670  :         regs->ip += 6;

  001b5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001be	48 83 c0 06	 add	 rax, 6
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 671  :     }
; 672  : 
; 673  : } /* end DEF_INST(compare_immediate_and_branch) */

  001cb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cf	c3		 ret	 0
z900_compare_immediate_and_branch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv159 = 48
tv160 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_halfword_relative_long_long PROC

; 625  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 626  : int     r1;                             /* Register number           */
; 627  : VADR    effective_addr2;                /* Relative operand address  */
; 628  : U16     n;                              /* Relative operand value    */
; 629  : 
; 630  :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_compa
$LN13@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 631  : 
; 632  :     /* Load relative operand from instruction address space */
; 633  :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 634  : 
; 635  :     /* Compare signed operands and set condition code */
; 636  :     regs->psw.cc =

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	48 0f bf 4c 24
	20		 movsx	 rcx, WORD PTR n$[rsp]
  0015c	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00161	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00169	7d 0a		 jge	 SHORT $LN17@z900_compa
  0016b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00173	eb 34		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:
  00175	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0017a	48 0f bf 4c 24
	20		 movsx	 rcx, WORD PTR n$[rsp]
  00180	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00185	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0018d	7e 0a		 jle	 SHORT $LN15@z900_compa
  0018f	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv159[rsp], 2
  00197	eb 08		 jmp	 SHORT $LN16@z900_compa
$LN15@z900_compa:
  00199	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@z900_compa:
  001a1	8b 44 24 30	 mov	 eax, DWORD PTR tv159[rsp]
  001a5	89 44 24 34	 mov	 DWORD PTR tv160[rsp], eax
$LN18@z900_compa:
  001a9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv160[rsp]
  001b3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 637  :             (S64)regs->GR_G(r1) < (S16)n ? 1 :
; 638  :             (S64)regs->GR_G(r1) > (S16)n ? 2 : 0;
; 639  : 
; 640  : } /* end DEF_INST(compare_halfword_relative_long_long) */

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	c3		 ret	 0
z900_compare_halfword_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv159 = 48
tv160 = 52
offset$1 = 56
tv128 = 64
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_compare_halfword_relative_long PROC

; 602  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 603  : int     r1;                             /* Register number           */
; 604  : VADR    effective_addr2;                /* Relative operand address  */
; 605  : U16     n;                              /* Relative operand value    */
; 606  : 
; 607  :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@z900_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@z900_compa
$LN7@z900_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@z900_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@z900_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@z900_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 42		 je	 SHORT $LN13@z900_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	48 2b c1	 sub	 rax, rcx
  00097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  000a3	48 03 c8	 add	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ba	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  000bf	eb 22		 jmp	 SHORT $LN14@z900_compa
$LN13@z900_compa:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000de	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN14@z900_compa:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000e8	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	48 6b c0 01	 imul	 rax, rax, 1
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	c1 f8 04	 sar	 eax, 4
  00102	83 e0 0f	 and	 eax, 15
  00105	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00109	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00112	48 83 c0 06	 add	 rax, 6
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0011f	33 c0		 xor	 eax, eax
  00121	83 f8 06	 cmp	 eax, 6
  00124	74 0c		 je	 SHORT $LN5@z900_compa
  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@z900_compa:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 d1		 jne	 SHORT $LN4@z900_compa

; 608  : 
; 609  :     /* Load relative operand from instruction address space */
; 610  :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013d	ba ff ff ff ff	 mov	 edx, -1
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00147	e8 00 00 00 00	 call	 z900_vfetch2
  0014c	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 611  : 
; 612  :     /* Compare signed operands and set condition code */
; 613  :     regs->psw.cc =

  00151	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	0f bf 4c 24 20	 movsx	 ecx, WORD PTR n$[rsp]
  0015b	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00160	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00167	7d 0a		 jge	 SHORT $LN17@z900_compa
  00169	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00171	eb 32		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:
  00173	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00178	0f bf 4c 24 20	 movsx	 ecx, WORD PTR n$[rsp]
  0017d	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00189	7e 0a		 jle	 SHORT $LN15@z900_compa
  0018b	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv159[rsp], 2
  00193	eb 08		 jmp	 SHORT $LN16@z900_compa
$LN15@z900_compa:
  00195	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN16@z900_compa:
  0019d	8b 44 24 30	 mov	 eax, DWORD PTR tv159[rsp]
  001a1	89 44 24 34	 mov	 DWORD PTR tv160[rsp], eax
$LN18@z900_compa:
  001a5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv160[rsp]
  001af	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 614  :             (S32)regs->GR_L(r1) < (S16)n ? 1 :
; 615  :             (S32)regs->GR_L(r1) > (S16)n ? 2 : 0;
; 616  : 
; 617  : } /* end DEF_INST(compare_halfword_relative_long) */

  001b2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b6	c3		 ret	 0
z900_compare_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
disp2$1 = 32
temp$2 = 36
b2$ = 40
effective_addr2$ = 48
x2$ = 56
tv131 = 60
r1$ = 64
tv173 = 68
tv174 = 72
n$ = 80
inst$ = 112
regs$ = 120
z900_compare_halfword_long PROC

; 576  : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 577  : int     r1;                             /* Values of R fields        */
; 578  : int     x2;                             /* Index register            */
; 579  : int     b2;                             /* Base of effective addr    */
; 580  : VADR    effective_addr2;                /* Effective address         */
; 581  : S64     n;                              /* 64-bit operand value      */
; 582  : 
; 583  :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN5@z900_compa
  0005c	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_compa:
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN6@z900_compa
  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_compa:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN14@z900_compa
  000cb	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  000d5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@z900_compa:
  000dd	83 7c 24 3c 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN7@z900_compa
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN8@z900_compa
  00112	8b 44 24 20	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 20	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@z900_compa:
$LN7@z900_compa:
  0011f	48 63 44 24 20	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN9@z900_compa
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_compa:
$LN4@z900_compa:
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN10@z900_compa
  00174	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_compa:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_compa

; 584  :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 28	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 585  : 
; 586  :     /* Load rightmost 2 bytes of comparand from operand address */
; 587  :     n = (S16)ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00199	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	8b 54 24 28	 mov	 edx, DWORD PTR b2$[rsp]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a7	e8 00 00 00 00	 call	 z900_vfetch2
  001ac	48 0f bf c0	 movsx	 rax, ax
  001b0	48 89 44 24 50	 mov	 QWORD PTR n$[rsp], rax

; 588  : 
; 589  :     /* Compare signed operands and set condition code */
; 590  :     regs->psw.cc =

  001b5	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  001c4	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  001cc	7d 0a		 jge	 SHORT $LN18@z900_compa
  001ce	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  001d6	eb 33		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  001d8	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  001dd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  001e7	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  001ef	7e 0a		 jle	 SHORT $LN16@z900_compa
  001f1	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv173[rsp], 2
  001f9	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  001fb	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN17@z900_compa:
  00203	8b 44 24 44	 mov	 eax, DWORD PTR tv173[rsp]
  00207	89 44 24 48	 mov	 DWORD PTR tv174[rsp], eax
$LN19@z900_compa:
  0020b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00210	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv174[rsp]
  00215	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 591  :             (S64)regs->GR_G(r1) < n ? 1 :
; 592  :             (S64)regs->GR_G(r1) > n ? 2 : 0;
; 593  : 
; 594  : } /* end DEF_INST(compare_halfword_long) */

  00218	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0021c	c3		 ret	 0
z900_compare_halfword_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
n$ = 44
tv135 = 48
tv136 = 52
effective_addr1$ = 56
inst$ = 80
regs$ = 88
z900_compare_halfword_immediate_storage PROC

; 553  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 554  : int     b1;                             /* Base of effective addr    */
; 555  : VADR    effective_addr1;                /* Effective address         */
; 556  : S16     i2;                             /* 16-bit immediate value    */
; 557  : S32     n;                              /* 32-bit storage value      */
; 558  : 
; 559  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 560  :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 561  : 
; 562  :     /* Load 32-bit value from first operand address */
; 563  :     n = (S32)ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch4
  000f9	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 564  : 
; 565  :     /* Compare signed operands and set condition code */
; 566  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fd	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  00102	39 44 24 2c	 cmp	 DWORD PTR n$[rsp], eax
  00106	7d 0a		 jge	 SHORT $LN10@z900_compa
  00108	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00110	eb 25		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00112	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  00117	39 44 24 2c	 cmp	 DWORD PTR n$[rsp], eax
  0011b	7e 0a		 jle	 SHORT $LN8@z900_compa
  0011d	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv135[rsp], 2
  00125	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  00127	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN9@z900_compa:
  0012f	8b 44 24 30	 mov	 eax, DWORD PTR tv135[rsp]
  00133	89 44 24 34	 mov	 DWORD PTR tv136[rsp], eax
$LN11@z900_compa:
  00137	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv136[rsp]
  00141	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 567  : 
; 568  : } /* end DEF_INST(compare_halfword_immediate_storage) */

  00144	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00148	c3		 ret	 0
z900_compare_halfword_immediate_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
b1$ = 36
temp$1 = 40
tv135 = 44
tv136 = 48
effective_addr1$ = 56
n$ = 64
inst$ = 96
regs$ = 104
z900_compare_halfword_immediate_long_storage PROC

; 531  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 532  : int     b1;                             /* Base of effective addr    */
; 533  : VADR    effective_addr1;                /* Effective address         */
; 534  : S16     i2;                             /* 16-bit immediate value    */
; 535  : S64     n;                              /* 64-bit storage value      */
; 536  : 
; 537  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 24	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 24 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 538  :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 539  : 
; 540  :     /* Load 64-bit value from first operand address */
; 541  :     n = (S64)ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 24	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch8
  000f9	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 542  : 
; 543  :     /* Compare signed operands and set condition code */
; 544  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fe	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  00104	48 39 44 24 40	 cmp	 QWORD PTR n$[rsp], rax
  00109	7d 0a		 jge	 SHORT $LN10@z900_compa
  0010b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00113	eb 27		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00115	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  0011b	48 39 44 24 40	 cmp	 QWORD PTR n$[rsp], rax
  00120	7e 0a		 jle	 SHORT $LN8@z900_compa
  00122	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv135[rsp], 2
  0012a	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  0012c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN9@z900_compa:
  00134	8b 44 24 2c	 mov	 eax, DWORD PTR tv135[rsp]
  00138	89 44 24 30	 mov	 DWORD PTR tv136[rsp], eax
$LN11@z900_compa:
  0013c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00141	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv136[rsp]
  00146	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 545  : 
; 546  : } /* end DEF_INST(compare_halfword_immediate_long_storage) */

  00149	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0014d	c3		 ret	 0
z900_compare_halfword_immediate_long_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
i2$ = 36
b1$ = 40
temp$1 = 44
tv137 = 48
tv138 = 52
effective_addr1$ = 56
inst$ = 80
regs$ = 88
z900_compare_halfword_immediate_halfword_storage PROC

; 509  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 510  : int     b1;                             /* Base of effective addr    */
; 511  : VADR    effective_addr1;                /* Effective address         */
; 512  : S16     i2;                             /* 16-bit immediate value    */
; 513  : S16     n;                              /* 16-bit storage value      */
; 514  : 
; 515  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 24	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	8b c0		 mov	 eax, eax
  00051	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00056	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 1c	 shr	 eax, 28
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 28	 mov	 DWORD PTR b1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR b1$[rsp], 0
  00069	74 3e		 je	 SHORT $LN5@z900_compa
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR b1$[rsp]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0008d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00099	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0009e	48 23 c8	 and	 rcx, rax
  000a1	48 8b c1	 mov	 rax, rcx
  000a4	48 89 44 24 38	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN5@z900_compa:
$LN4@z900_compa:
  000a9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 06	 add	 rax, 6
  000b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bf	33 c0		 xor	 eax, eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	74 0c		 je	 SHORT $LN6@z900_compa
  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_compa:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 d1		 jne	 SHORT $LN4@z900_compa

; 516  :     PER_ZEROADDR_XCHECK( regs, b1 );

  000d8	8b 54 24 28	 mov	 edx, DWORD PTR b1$[rsp]
  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 517  : 
; 518  :     /* Load 16-bit value from first operand address */
; 519  :     n = (S16)ARCH_DEP(vfetch2) ( effective_addr1, b1, regs );

  000e6	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000eb	8b 54 24 28	 mov	 edx, DWORD PTR b1$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000f4	e8 00 00 00 00	 call	 z900_vfetch2
  000f9	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 520  : 
; 521  :     /* Compare signed operands and set condition code */
; 522  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000fe	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  00103	0f bf 4c 24 24	 movsx	 ecx, WORD PTR i2$[rsp]
  00108	3b c1		 cmp	 eax, ecx
  0010a	7d 0a		 jge	 SHORT $LN10@z900_compa
  0010c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  00114	eb 28		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  00116	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  0011b	0f bf 4c 24 24	 movsx	 ecx, WORD PTR i2$[rsp]
  00120	3b c1		 cmp	 eax, ecx
  00122	7e 0a		 jle	 SHORT $LN8@z900_compa
  00124	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv137[rsp], 2
  0012c	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  0012e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN9@z900_compa:
  00136	8b 44 24 30	 mov	 eax, DWORD PTR tv137[rsp]
  0013a	89 44 24 34	 mov	 DWORD PTR tv138[rsp], eax
$LN11@z900_compa:
  0013e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00143	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv138[rsp]
  00148	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 523  : 
; 524  : } /* end DEF_INST(compare_halfword_immediate_halfword_storage) */

  0014b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014f	c3		 ret	 0
z900_compare_halfword_immediate_halfword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_and_trap_register PROC

; 457  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 458  : int     r1, r2;                         /* Register numbers          */
; 459  : int     m3;                             /* Mask bits                 */
; 460  : int     cc;                             /* Comparison result         */
; 461  : 
; 462  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_compa

; 463  : 
; 464  :     /* Compare signed operands and set comparison result */
; 465  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0009c	7d 0a		 jge	 SHORT $LN10@z900_compa
  0009e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a6	eb 3f		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000a8	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ad	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000c4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cb	7e 0a		 jle	 SHORT $LN8@z900_compa
  000cd	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d5	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@z900_compa:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e3	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@z900_compa:
  000e7	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000eb	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 466  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 467  : 
; 468  :     /* Raise data exception if m3 mask bit is set */
; 469  :     if ((0x8 >> cc) & m3)

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00103	d3 f8		 sar	 eax, cl
  00105	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00109	85 c0		 test	 eax, eax
  0010b	74 1e		 je	 SHORT $LN6@z900_compa

; 470  :     {
; 471  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 472  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 473  :     }
; 474  : 
; 475  : } /* end DEF_INST(compare_and_trap_register) */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
z900_compare_and_trap_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
z900_compare_and_trap_long_register PROC

; 483  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 484  : int     r1, r2;                         /* Register numbers          */
; 485  : int     m3;                             /* Mask bits                 */
; 486  : int     cc;                             /* Comparison result         */
; 487  : 
; 488  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@z900_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_compa

; 489  : 
; 490  :     /* Compare signed operands and set comparison result */
; 491  :     cc = (S64)regs->GR_G(r1) < (S64)regs->GR_G(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00095	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0009d	7d 0a		 jge	 SHORT $LN10@z900_compa
  0009f	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a7	eb 40		 jmp	 SHORT $LN11@z900_compa
$LN10@z900_compa:
  000a9	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ae	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bd	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  000c5	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  000cd	7e 0a		 jle	 SHORT $LN8@z900_compa
  000cf	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d7	eb 08		 jmp	 SHORT $LN9@z900_compa
$LN8@z900_compa:
  000d9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@z900_compa:
  000e1	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e5	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@z900_compa:
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000ed	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 492  :          (S64)regs->GR_G(r1) > (S64)regs->GR_G(r2) ? 2 : 0;
; 493  : 
; 494  :     /* Raise data exception if m3 mask bit is set */
; 495  :     if ((0x8 >> cc) & m3)

  000f1	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f5	b9 08 00 00 00	 mov	 ecx, 8
  000fa	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fe	0f b6 c8	 movzx	 ecx, al
  00101	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00105	d3 f8		 sar	 eax, cl
  00107	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 1e		 je	 SHORT $LN6@z900_compa

; 496  :     {
; 497  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 498  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011e	ba 07 00 00 00	 mov	 edx, 7
  00123	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_compa:

; 499  :     }
; 500  : 
; 501  : } /* end DEF_INST(compare_and_trap_long_register) */

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
z900_compare_and_trap_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
ri4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
tv153 = 48
tv154 = 52
m3$ = 56
cc$ = 60
tv201 = 64
inst$ = 96
regs$ = 104
z900_compare_and_branch_relative_long_register PROC

; 426  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 427  : int     r1, r2;                         /* Register numbers          */
; 428  : int     m3;                             /* Mask bits                 */
; 429  : S16     ri4;                            /* 16-bit relative offset    */
; 430  : int     cc;                             /* Comparison result         */
; 431  : 
; 432  :     RIE_RRIM_B( inst, regs, r1, r2, ri4, m3 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR ri4$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN8@z900_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 433  : 
; 434  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );

  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a2	85 c0		 test	 eax, eax
  000a4	74 4c		 je	 SHORT $LN9@z900_compa
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 10		 jne	 SHORT $LN10@z900_compa
  000ac	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b1	74 09		 je	 SHORT $LN10@z900_compa
  000b3	0f bf 44 24 20	 movsx	 eax, WORD PTR ri4$[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c7	0f ba e8 0e	 bts	 eax, 14
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194436
  000dd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e3	ba fe ff ff ff	 mov	 edx, -2
  000e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 9e		 jne	 SHORT $LN7@z900_compa

; 435  : 
; 436  :     /* Compare signed operands and set comparison result */
; 437  :     cc = (S64)regs->GR_G(r1) < (S64)regs->GR_G(r2) ? 1 :

  000f8	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fd	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00107	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0010c	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00114	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0011c	7d 0a		 jge	 SHORT $LN16@z900_compa
  0011e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00126	eb 40		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00128	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012d	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00132	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00137	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013c	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  00144	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  0014c	7e 0a		 jle	 SHORT $LN14@z900_compa
  0014e	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv153[rsp], 2
  00156	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00158	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN15@z900_compa:
  00160	8b 44 24 30	 mov	 eax, DWORD PTR tv153[rsp]
  00164	89 44 24 34	 mov	 DWORD PTR tv154[rsp], eax
$LN17@z900_compa:
  00168	8b 44 24 34	 mov	 eax, DWORD PTR tv154[rsp]
  0016c	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 438  :          (S64)regs->GR_G(r1) > (S64)regs->GR_G(r2) ? 2 : 0;
; 439  : 
; 440  :     /* Branch to immediate offset if m3 mask bit is set */
; 441  :     if ((0x8 >> cc) & m3)

  00170	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	89 4c 24 40	 mov	 DWORD PTR tv201[rsp], ecx
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 44 24 40	 mov	 eax, DWORD PTR tv201[rsp]
  00184	d3 f8		 sar	 eax, cl
  00186	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  0018a	85 c0		 test	 eax, eax
  0018c	74 18		 je	 SHORT $LN11@z900_compa

; 442  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0018e	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR ri4$[rsp]
  00194	48 d1 e0	 shl	 rax, 1
  00197	48 8b d0	 mov	 rdx, rax
  0019a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  001a4	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 443  :     else
; 444  :     {
; 445  :         /* Bump ip to next sequential instruction */
; 446  :         regs->ip += 6;

  001a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001af	48 83 c0 06	 add	 rax, 6
  001b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 447  :     }
; 448  : 
; 449  : } /* end DEF_INST( compare_and_branch_relative_long_register ) */

  001bc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c0	c3		 ret	 0
z900_compare_and_branch_relative_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i4$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
tv153 = 48
tv154 = 52
m3$ = 56
cc$ = 60
tv201 = 64
inst$ = 96
regs$ = 104
z900_compare_and_branch_relative_register PROC

; 395  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 396  : int     r1, r2;                         /* Register numbers          */
; 397  : int     m3;                             /* Mask bits                 */
; 398  : S16     i4;                             /* 16-bit immediate offset   */
; 399  : int     cc;                             /* Comparison result         */
; 400  : 
; 401  :     RIE_RRIM_B(inst, regs, r1, r2, i4, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i4$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN8@z900_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN8@z900_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 402  : 
; 403  :     TXFC_BRANCH_CHECK_IP( regs, m3, i4 );

  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000a2	85 c0		 test	 eax, eax
  000a4	74 4c		 je	 SHORT $LN9@z900_compa
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 10		 jne	 SHORT $LN10@z900_compa
  000ac	83 7c 24 38 00	 cmp	 DWORD PTR m3$[rsp], 0
  000b1	74 09		 je	 SHORT $LN10@z900_compa
  000b3	0f bf 44 24 20	 movsx	 eax, WORD PTR i4$[rsp]
  000b8	85 c0		 test	 eax, eax
  000ba	7d 36		 jge	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000bc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000c7	0f ba e8 0e	 bts	 eax, 14
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194409
  000dd	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000e3	ba fe ff ff ff	 mov	 edx, -2
  000e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 9e		 jne	 SHORT $LN7@z900_compa

; 404  : 
; 405  :     /* Compare signed operands and set comparison result */
; 406  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  000f8	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fd	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00107	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0010c	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00114	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0011b	7d 0a		 jge	 SHORT $LN16@z900_compa
  0011d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  00125	eb 3f		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00127	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0012c	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00131	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00136	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0013b	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00143	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0014a	7e 0a		 jle	 SHORT $LN14@z900_compa
  0014c	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv153[rsp], 2
  00154	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00156	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN15@z900_compa:
  0015e	8b 44 24 30	 mov	 eax, DWORD PTR tv153[rsp]
  00162	89 44 24 34	 mov	 DWORD PTR tv154[rsp], eax
$LN17@z900_compa:
  00166	8b 44 24 34	 mov	 eax, DWORD PTR tv154[rsp]
  0016a	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 407  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 408  : 
; 409  :     /* Branch to immediate offset if m3 mask bit is set */
; 410  :     if ((0x8 >> cc) & m3)

  0016e	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00172	b9 08 00 00 00	 mov	 ecx, 8
  00177	89 4c 24 40	 mov	 DWORD PTR tv201[rsp], ecx
  0017b	0f b6 c8	 movzx	 ecx, al
  0017e	8b 44 24 40	 mov	 eax, DWORD PTR tv201[rsp]
  00182	d3 f8		 sar	 eax, cl
  00184	23 44 24 38	 and	 eax, DWORD PTR m3$[rsp]
  00188	85 c0		 test	 eax, eax
  0018a	74 18		 je	 SHORT $LN11@z900_compa

; 411  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*i4 );

  0018c	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i4$[rsp]
  00192	48 d1 e0	 shl	 rax, 1
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	e8 00 00 00 00	 call	 z900_SuccessfulRelativeBranch
  001a2	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 412  :     else
; 413  :     {
; 414  :         /* Bump ip to next sequential instruction */
; 415  :         regs->ip += 6;

  001a4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001a9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001ad	48 83 c0 06	 add	 rax, 6
  001b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 416  :     }
; 417  : 
; 418  : } /* end DEF_INST(compare_and_branch_relative_register) */

  001ba	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001be	c3		 ret	 0
z900_compare_and_branch_relative_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
b4$ = 36
r1$ = 40
r2$ = 44
tv160 = 48
tv161 = 52
effective_addr4$ = 56
cc$ = 64
tv213 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_and_branch_long_register PROC

; 363  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 364  : int     r1, r2;                         /* Register numbers          */
; 365  : int     m3;                             /* Mask bits                 */
; 366  : int     b4;                             /* Base of effective addr    */
; 367  : VADR    effective_addr4;                /* Effective address         */
; 368  : int     cc;                             /* Comparison result         */
; 369  : 
; 370  :     RRS_B(inst, regs, r1, r2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	8b c0		 mov	 eax, eax
  0004a	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 24	 mov	 DWORD PTR b4$[rsp], eax
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0006b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 14	 shr	 eax, 20
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00079	83 7c 24 24 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007e	74 3e		 je	 SHORT $LN8@z900_compa
  00080	48 63 44 24 24	 movsxd	 rax, DWORD PTR b4$[rsp]
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000b3	48 23 c8	 and	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000cb	33 c0		 xor	 eax, eax
  000cd	83 f8 06	 cmp	 eax, 6
  000d0	74 0c		 je	 SHORT $LN9@z900_compa
  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 371  : 
; 372  :     TXFC_INSTR_CHECK_IP( regs );

  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000f0	85 c0		 test	 eax, eax
  000f2	74 36		 je	 SHORT $LN10@z900_compa
  000f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0f	 bts	 eax, 15
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194382
  00115	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011b	ba fe ff ff ff	 mov	 edx, -2
  00120	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 b4		 jne	 SHORT $LN7@z900_compa

; 373  : 
; 374  :     /* Compare signed operands and set comparison result */
; 375  :     cc = (S64)regs->GR_G(r1) < (S64)regs->GR_G(r2) ? 1 :

  00130	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0013a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0013f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00144	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  0014c	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00154	7d 0a		 jge	 SHORT $LN16@z900_compa
  00156	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0015e	eb 40		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  00160	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00165	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0016a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00174	49 8b 8c c8 80
	02 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+640]
  0017c	48 39 8c c2 80
	02 00 00	 cmp	 QWORD PTR [rdx+rax*8+640], rcx
  00184	7e 0a		 jle	 SHORT $LN14@z900_compa
  00186	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
  0018e	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  00190	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN15@z900_compa:
  00198	8b 44 24 30	 mov	 eax, DWORD PTR tv160[rsp]
  0019c	89 44 24 34	 mov	 DWORD PTR tv161[rsp], eax
$LN17@z900_compa:
  001a0	8b 44 24 34	 mov	 eax, DWORD PTR tv161[rsp]
  001a4	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 376  :          (S64)regs->GR_G(r1) > (S64)regs->GR_G(r2) ? 2 : 0;
; 377  : 
; 378  :     /* Branch to operand address if m3 mask bit is set */
; 379  :     if ((0x8 >> cc) & m3)

  001a8	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  001ac	b9 08 00 00 00	 mov	 ecx, 8
  001b1	89 4c 24 44	 mov	 DWORD PTR tv213[rsp], ecx
  001b5	0f b6 c8	 movzx	 ecx, al
  001b8	8b 44 24 44	 mov	 eax, DWORD PTR tv213[rsp]
  001bc	d3 f8		 sar	 eax, cl
  001be	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001c2	85 c0		 test	 eax, eax
  001c4	74 11		 je	 SHORT $LN11@z900_compa

; 380  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001c6	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001d5	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 381  :     else
; 382  :     {
; 383  :         /* Bump ip to next sequential instruction */
; 384  :         regs->ip += 6;

  001d7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001e0	48 83 c0 06	 add	 rax, 6
  001e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 385  :     }
; 386  : 
; 387  : } /* end DEF_INST(compare_and_branch_long_register) */

  001ed	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f1	c3		 ret	 0
z900_compare_and_branch_long_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
b4$ = 36
r1$ = 40
r2$ = 44
tv160 = 48
tv161 = 52
effective_addr4$ = 56
cc$ = 64
tv213 = 68
m3$ = 72
inst$ = 96
regs$ = 104
z900_compare_and_branch_register PROC

; 331  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 332  : int     r1, r2;                         /* Register numbers          */
; 333  : int     m3;                             /* Mask bits                 */
; 334  : int     b4;                             /* Base of effective addr    */
; 335  : VADR    effective_addr4;                /* Effective address         */
; 336  : int     cc;                             /* Comparison result         */
; 337  : 
; 338  :     RRS_B( inst, regs, r1, r2, m3, b4, effective_addr4 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	8b c0		 mov	 eax, eax
  0004a	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 24	 mov	 DWORD PTR b4$[rsp], eax
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 10	 shr	 eax, 16
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0006b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 14	 shr	 eax, 20
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00079	83 7c 24 24 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007e	74 3e		 je	 SHORT $LN8@z900_compa
  00080	48 63 44 24 24	 movsxd	 rax, DWORD PTR b4$[rsp]
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00097	48 03 c8	 add	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  000b3	48 23 c8	 and	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 89 44 24 38	 mov	 QWORD PTR effective_addr4$[rsp], rax
$LN8@z900_compa:
$LN4@z900_compa:
  000be	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c7	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000cb	33 c0		 xor	 eax, eax
  000cd	83 f8 06	 cmp	 eax, 6
  000d0	74 0c		 je	 SHORT $LN9@z900_compa
  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_compa:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 da		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 339  : 
; 340  :     TXFC_INSTR_CHECK_IP( regs );

  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000f0	85 c0		 test	 eax, eax
  000f2	74 36		 je	 SHORT $LN10@z900_compa
  000f4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000ff	0f ba e8 0f	 bts	 eax, 15
  00103	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194354
  00115	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011b	ba fe ff ff ff	 mov	 edx, -2
  00120	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 b4		 jne	 SHORT $LN7@z900_compa

; 341  : 
; 342  :     /* Compare signed operands and set comparison result */
; 343  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  00130	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0013a	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0013f	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00144	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  0014c	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00153	7d 0a		 jge	 SHORT $LN16@z900_compa
  00155	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0015d	eb 3f		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  0015f	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00164	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00169	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016e	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00173	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  0017b	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00182	7e 0a		 jle	 SHORT $LN14@z900_compa
  00184	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
  0018c	eb 08		 jmp	 SHORT $LN15@z900_compa
$LN14@z900_compa:
  0018e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN15@z900_compa:
  00196	8b 44 24 30	 mov	 eax, DWORD PTR tv160[rsp]
  0019a	89 44 24 34	 mov	 DWORD PTR tv161[rsp], eax
$LN17@z900_compa:
  0019e	8b 44 24 34	 mov	 eax, DWORD PTR tv161[rsp]
  001a2	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 344  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 345  : 
; 346  :     /* Branch to operand address if m3 mask bit is set */
; 347  :     if ((0x8 >> cc) & m3)

  001a6	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]
  001aa	b9 08 00 00 00	 mov	 ecx, 8
  001af	89 4c 24 44	 mov	 DWORD PTR tv213[rsp], ecx
  001b3	0f b6 c8	 movzx	 ecx, al
  001b6	8b 44 24 44	 mov	 eax, DWORD PTR tv213[rsp]
  001ba	d3 f8		 sar	 eax, cl
  001bc	23 44 24 48	 and	 eax, DWORD PTR m3$[rsp]
  001c0	85 c0		 test	 eax, eax
  001c2	74 11		 je	 SHORT $LN11@z900_compa

; 348  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  001c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  001c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	e8 00 00 00 00	 call	 z900_SuccessfulBranch
  001d3	eb 16		 jmp	 SHORT $LN12@z900_compa
$LN11@z900_compa:

; 349  :     else
; 350  :     {
; 351  :         /* Bump ip to next sequential instruction */
; 352  :         regs->ip += 6;

  001d5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001da	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001de	48 83 c0 06	 add	 rax, 6
  001e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN12@z900_compa:

; 353  :     }
; 354  : 
; 355  : } /* end DEF_INST(compare_and_branch_register) */

  001eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ef	c3		 ret	 0
z900_compare_and_branch_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_add_logical_with_signed_immediate_long PROC

; 295  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 296  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 297  : BYTE    i2;                             /* Immediate byte            */
; 298  : int     b1;                             /* Base of effective addr    */
; 299  : VADR    effective_addr1;                /* Effective address         */
; 300  : U64     n;                              /* 64-bit operand value      */
; 301  : int     cc;                             /* Condition Code            */
; 302  : 
; 303  :     SIY(inst, regs, i2, b1, effective_addr1);
; 304  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 305  : 
; 306  :     /* Load 64-bit operand from operand address */
; 307  :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );
; 308  : 
; 309  :     /* Add operands and set condition code */
; 310  :     cc = (S8)i2 < 0 ?
; 311  :         sub_logical_long (&n, n, (S64)(-(S8)i2)) :
; 312  :         add_logical_long (&n, n, (S64)(S8)i2);
; 313  : 
; 314  :     /* Store 64-bit value at operand address */
; 315  :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );
; 316  : 
; 317  :     /* Update Condition Code */
; 318  :     regs->psw.cc = cc;
; 319  : 
; 320  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 321  :     ARCH_DEP(perform_interlocked_long_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_perform_interlocked_long_storage_immediate

; 322  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 323  : 
; 324  : } /* end DEF_INST(add_logical_with_signed_immediate_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_add_logical_with_signed_immediate_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_add_logical_with_signed_immediate PROC

; 259  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 260  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 261  : BYTE    i2;                             /* Immediate byte            */
; 262  : int     b1;                             /* Base of effective addr    */
; 263  : VADR    effective_addr1;                /* Effective address         */
; 264  : U32     n;                              /* 32-bit operand value      */
; 265  : int     cc;                             /* Condition Code            */
; 266  : 
; 267  :     SIY(inst, regs, i2, b1, effective_addr1);
; 268  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 269  : 
; 270  :     /* Load 32-bit operand from operand address */
; 271  :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );
; 272  : 
; 273  :     /* Add operands and set condition code */
; 274  :     cc = (S8)i2 < 0 ?
; 275  :         sub_logical (&n, n, (S32)(-(S8)i2)) :
; 276  :         add_logical (&n, n, (S32)(S8)i2);
; 277  : 
; 278  :     /* Store 32-bit operand at operand address */
; 279  :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );
; 280  : 
; 281  :     /* Update Condition Code */
; 282  :     regs->psw.cc = cc;
; 283  : 
; 284  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 285  :     ARCH_DEP(perform_interlocked_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_perform_interlocked_storage_immediate

; 286  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 287  : 
; 288  : } /* end DEF_INST(add_logical_with_signed_immediate) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_add_logical_with_signed_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_add_immediate_storage PROC

; 183  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 184  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 185  : BYTE    i2;                             /* Immediate byte            */
; 186  : int     b1;                             /* Base of effective addr    */
; 187  : VADR    effective_addr1;                /* Effective address         */
; 188  : U32     n;                              /* 32-bit operand value      */
; 189  : int     cc;                             /* Condition Code            */
; 190  : 
; 191  :     SIY(inst, regs, i2, b1, effective_addr1);
; 192  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 193  : 
; 194  :     /* Load 32-bit operand from operand address */
; 195  :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );
; 196  : 
; 197  :     /* Add signed operands and set condition code */
; 198  :     cc = add_signed (&n, n, (S32)(S8)i2);
; 199  : 
; 200  :     /* Store 32-bit operand at operand address */
; 201  :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );
; 202  : 
; 203  :     /* Update Condition Code */
; 204  :     regs->psw.cc = cc;
; 205  : 
; 206  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 207  :     ARCH_DEP(perform_interlocked_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_perform_interlocked_storage_immediate

; 208  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 209  : 
; 210  :     /* Program check if fixed-point overflow */
; 211  :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@z900_add_i
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@z900_add_i

; 212  :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_add_i:

; 213  : 
; 214  : } /* end DEF_INST(add_immediate_storage) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
z900_add_immediate_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
z900_add_immediate_long_storage PROC

; 221  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 222  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 223  : BYTE    i2;                             /* Immediate byte            */
; 224  : int     b1;                             /* Base of effective addr    */
; 225  : VADR    effective_addr1;                /* Effective address         */
; 226  : U64     n;                              /* 64-bit operand value      */
; 227  : int     cc;                             /* Condition Code            */
; 228  : 
; 229  :     SIY(inst, regs, i2, b1, effective_addr1);
; 230  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 231  : 
; 232  :     /* Load 64-bit operand from operand address */
; 233  :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );
; 234  : 
; 235  :     /* Add signed operands and set condition code */
; 236  :     cc = add_signed_long (&n, n, (S64)(S8)i2);
; 237  : 
; 238  :     /* Store 64-bit value at operand address */
; 239  :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );
; 240  : 
; 241  :     /* Update Condition Code */
; 242  :     regs->psw.cc = cc;
; 243  : 
; 244  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 245  :     ARCH_DEP(perform_interlocked_long_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 z900_perform_interlocked_long_storage_immediate

; 246  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 247  : 
; 248  :     /* Program check if fixed-point overflow */
; 249  :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@z900_add_i
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@z900_add_i

; 250  :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_add_i:

; 251  : 
; 252  : } /* end DEF_INST(add_immediate_long_storage) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
z900_add_immediate_long_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 48
opcode$ = 52
disp2$1 = 56
cc$ = 60
tv168 = 64
temp$2 = 68
b2$ = 72
result$ = 80
v2$ = 88
tv92 = 96
tv171 = 100
tv174 = 104
tv177 = 108
v3$ = 112
r3$ = 120
rc$ = 124
r1$ = 128
m2$ = 136
new$ = 144
old$ = 152
inst$ = 176
regs$ = 184
s370_load_and_perform_interlocked_access_long PROC

; 2974 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2975 : int     r1, r3;                         /* Register numbers          */
; 2976 : int     b2;                             /* Base of effective addr    */
; 2977 : VADR    effective_addr2;                /* Effective address         */
; 2978 : BYTE    *m2;                            /* Mainstor address          */
; 2979 : U64     v2, v3;                         /* Operand values            */
; 2980 : U64     result;                         /* Result value              */
; 2981 : U64     old, new;                       /* Values for cmpxchg4       */
; 2982 : int     cc;                             /* Condition code            */
; 2983 : int     rc;                             /* Return code               */
; 2984 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2985 : 
; 2986 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  00011	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 44	 mov	 DWORD PTR temp$2[rsp], eax
  00029	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  00031	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00035	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003a	89 44 24 38	 mov	 DWORD PTR disp2$1[rsp], eax
  0003e	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00042	c1 e8 0c	 shr	 eax, 12
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0004c	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 10	 shr	 eax, 16
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 78	 mov	 DWORD PTR r3$[rsp], eax
  0005a	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  0005e	c1 e8 14	 shr	 eax, 20
  00061	83 e0 0f	 and	 eax, 15
  00064	89 84 24 80 00
	00 00		 mov	 DWORD PTR r1$[rsp], eax
  0006b	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00070	74 20		 je	 SHORT $LN10@s370_load_
  00072	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00077	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00086	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0008a	03 c8		 add	 ecx, eax
  0008c	8b c1		 mov	 eax, ecx
  0008e	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN10@s370_load_:
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	48 6b c0 04	 imul	 rax, rax, 4
  0009b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a7	85 c0		 test	 eax, eax
  000a9	74 0a		 je	 SHORT $LN25@s370_load_
  000ab	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b3	eb 08		 jmp	 SHORT $LN26@s370_load_
$LN25@s370_load_:
  000b5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN26@s370_load_:
  000bd	83 7c 24 60 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c2	74 3e		 je	 SHORT $LN11@s370_load_
  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	48 6b c0 04	 imul	 rax, rax, 4
  000cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d9	c1 e0 0c	 shl	 eax, 12
  000dc	8b 4c 24 38	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000e0	0b c8		 or	 ecx, eax
  000e2	8b c1		 mov	 eax, ecx
  000e4	89 44 24 38	 mov	 DWORD PTR disp2$1[rsp], eax
  000e8	8b 44 24 38	 mov	 eax, DWORD PTR disp2$1[rsp]
  000ec	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000f1	85 c0		 test	 eax, eax
  000f3	74 0d		 je	 SHORT $LN12@s370_load_
  000f5	8b 44 24 38	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f9	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000fe	89 44 24 38	 mov	 DWORD PTR disp2$1[rsp], eax
$LN12@s370_load_:
$LN11@s370_load_:
  00102	8b 44 24 38	 mov	 eax, DWORD PTR disp2$1[rsp]
  00106	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0010a	03 c8		 add	 ecx, eax
  0010c	8b c1		 mov	 eax, ecx
  0010e	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00112	33 c0		 xor	 eax, eax
  00114	83 f8 06	 cmp	 eax, 6
  00117	74 0d		 je	 SHORT $LN13@s370_load_
  00119	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0011d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00122	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN13@s370_load_:
$LN4@s370_load_:
  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00132	48 83 c0 06	 add	 rax, 6
  00136	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00142	33 c0		 xor	 eax, eax
  00144	83 f8 06	 cmp	 eax, 6
  00147	74 0f		 je	 SHORT $LN14@s370_load_
  00149	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00151	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN14@s370_load_:
  00158	33 c0		 xor	 eax, eax
  0015a	85 c0		 test	 eax, eax
  0015c	75 c8		 jne	 SHORT $LN4@s370_load_

; 2987 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 2988 : 
; 2989 :     /* Program check if operand not on doubleword boundary */
; 2990 :     DW_CHECK( effective_addr2, regs );

  0015e	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00162	83 e0 07	 and	 eax, 7
  00165	85 c0		 test	 eax, eax
  00167	74 1b		 je	 SHORT $LN15@s370_load_
  00169	ba 06 00 00 00	 mov	 edx, 6
  0016e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00176	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@s370_load_:

; 2991 : 
; 2992 :     /* Extract second byte of instruction opcode */
; 2993 :     opcode = inst[5];

  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	48 6b c0 05	 imul	 rax, rax, 5
  0018d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00195	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00199	88 44 24 34	 mov	 BYTE PTR opcode$[rsp], al

; 2994 : 
; 2995 :     /* Obtain third operand value from R3 register */
; 2996 :     v3 = regs->GR_G(r3);

  0019d	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  001a2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001b2	48 89 44 24 70	 mov	 QWORD PTR v3$[rsp], rax

; 2997 : 
; 2998 :     /* Get mainstor address of storage operand */
; 2999 :     m2 = MADDRL (effective_addr2, 8, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  001b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c3	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001c7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001cf	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d7	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  001dc	ba 08 00 00 00	 mov	 edx, 8
  001e1	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001e5	e8 00 00 00 00	 call	 s370_maddr_l
  001ea	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR m2$[rsp], rax
$LN7@s370_load_:

; 3000 : 
; 3001 :     do {
; 3002 :         /* Load storage operand value from operand address */
; 3003 :         v2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  001f2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fa	8b 54 24 48	 mov	 edx, DWORD PTR b2$[rsp]
  001fe	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00202	e8 00 00 00 00	 call	 s370_vfetch8
  00207	48 89 44 24 58	 mov	 QWORD PTR v2$[rsp], rax

; 3004 : 
; 3005 :         switch (opcode) {

  0020c	0f b6 44 24 34	 movzx	 eax, BYTE PTR opcode$[rsp]
  00211	88 44 24 40	 mov	 BYTE PTR tv168[rsp], al
  00215	80 7c 24 40 e4	 cmp	 BYTE PTR tv168[rsp], 228 ; 000000e4H
  0021a	74 2d		 je	 SHORT $LN16@s370_load_
  0021c	80 7c 24 40 e6	 cmp	 BYTE PTR tv168[rsp], 230 ; 000000e6H
  00221	74 62		 je	 SHORT $LN17@s370_load_
  00223	80 7c 24 40 e7	 cmp	 BYTE PTR tv168[rsp], 231 ; 000000e7H
  00228	0f 84 90 00 00
	00		 je	 $LN18@s370_load_
  0022e	80 7c 24 40 e8	 cmp	 BYTE PTR tv168[rsp], 232 ; 000000e8H
  00233	0f 84 be 00 00
	00		 je	 $LN19@s370_load_
  00239	80 7c 24 40 ea	 cmp	 BYTE PTR tv168[rsp], 234 ; 000000eaH
  0023e	0f 84 cd 00 00
	00		 je	 $LN20@s370_load_
  00244	e9 e2 00 00 00	 jmp	 $LN21@s370_load_
$LN16@s370_load_:

; 3006 :         case 0xE4: /* Load and And Long */
; 3007 :             /* AND operand values and set condition code */
; 3008 :             result = v2 & v3;

  00249	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  00253	48 23 c8	 and	 rcx, rax
  00256	48 8b c1	 mov	 rax, rcx
  00259	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3009 :             cc = result ? 1 : 0;

  0025e	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00264	74 0a		 je	 SHORT $LN27@s370_load_
  00266	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  0026e	eb 08		 jmp	 SHORT $LN28@s370_load_
$LN27@s370_load_:
  00270	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN28@s370_load_:
  00278	8b 44 24 64	 mov	 eax, DWORD PTR tv171[rsp]
  0027c	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 3010 :             break;

  00280	e9 b7 00 00 00	 jmp	 $LN8@s370_load_
$LN17@s370_load_:

; 3011 :         case 0xE6: /* Load and Or Long */
; 3012 :             /* OR operand values and set condition code */
; 3013 :             result = v2 | v3;

  00285	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  0028a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  0028f	48 0b c8	 or	 rcx, rax
  00292	48 8b c1	 mov	 rax, rcx
  00295	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3014 :             cc = result ? 1 : 0;

  0029a	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  002a0	74 0a		 je	 SHORT $LN29@s370_load_
  002a2	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  002aa	eb 08		 jmp	 SHORT $LN30@s370_load_
$LN29@s370_load_:
  002ac	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN30@s370_load_:
  002b4	8b 44 24 68	 mov	 eax, DWORD PTR tv174[rsp]
  002b8	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 3015 :             break;

  002bc	eb 7e		 jmp	 SHORT $LN8@s370_load_
$LN18@s370_load_:

; 3016 :         case 0xE7: /* Load and Exclusive Or Long */
; 3017 :             /* XOR operand values and set condition code */
; 3018 :             result = v2 ^ v3;

  002be	48 8b 44 24 70	 mov	 rax, QWORD PTR v3$[rsp]
  002c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  002c8	48 33 c8	 xor	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3019 :             cc = result ? 1 : 0;

  002d3	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  002d9	74 0a		 je	 SHORT $LN31@s370_load_
  002db	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN32@s370_load_
$LN31@s370_load_:
  002e5	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN32@s370_load_:
  002ed	8b 44 24 6c	 mov	 eax, DWORD PTR tv177[rsp]
  002f1	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 3020 :             break;

  002f5	eb 45		 jmp	 SHORT $LN8@s370_load_
$LN19@s370_load_:

; 3021 :         case 0xE8: /* Load and Add Long */
; 3022 :             /* Add signed operands and set condition code */
; 3023 :             cc = add_signed_long (&result, v2, v3);

  002f7	4c 8b 44 24 70	 mov	 r8, QWORD PTR v3$[rsp]
  002fc	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  00301	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00306	e8 00 00 00 00	 call	 add_signed_long
  0030b	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 3024 :             break;

  0030f	eb 2b		 jmp	 SHORT $LN8@s370_load_
$LN20@s370_load_:

; 3025 :         case 0xEA: /* Load and Add Logical Long */
; 3026 :             /* Add unsigned operands and set condition code */
; 3027 :             cc = add_logical_long (&result, v2, v3);

  00311	4c 8b 44 24 70	 mov	 r8, QWORD PTR v3$[rsp]
  00316	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  0031b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00320	e8 00 00 00 00	 call	 add_logical_long
  00325	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 3028 :             break;

  00329	eb 11		 jmp	 SHORT $LN8@s370_load_
$LN21@s370_load_:

; 3029 :         default: /* To prevent compiler warnings */
; 3030 :             result = 0;

  0032b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3031 :             cc = 0;

  00334	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@s370_load_:

; 3032 :         } /* end switch(opcode) */
; 3033 : 
; 3034 :         /* Interlocked exchange to storage location */
; 3035 :         old = CSWAP64(v2);

  0033c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v2$[rsp]
  00341	e8 00 00 00 00	 call	 _byteswap_uint64
  00346	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR old$[rsp], rax

; 3036 :         new = CSWAP64(result);

  0034e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  00353	e8 00 00 00 00	 call	 _byteswap_uint64
  00358	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR new$[rsp], rax

; 3037 : 
; 3038 :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 3039 :         OBTAIN_MAINLOCK( regs );
; 3040 :         {
; 3041 :             rc = cmpxchg8( &old, new, m2 );

  00360	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR m2$[rsp]
  00368	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR new$[rsp]
  00370	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR old$[rsp]
  00378	e8 00 00 00 00	 call	 cmpxchg8_x86
  0037d	0f b6 c0	 movzx	 eax, al
  00380	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 3042 :         }
; 3043 :         RELEASE_MAINLOCK( regs );
; 3044 : 
; 3045 :     } while (rc != 0);

  00384	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00389	0f 85 63 fe ff
	ff		 jne	 $LN7@s370_load_

; 3046 : 
; 3047 :     /* Load original storage operand value into R1 register */
; 3048 :     regs->GR_G(r1) = v2;

  0038f	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00397	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	48 8b 54 24 58	 mov	 rdx, QWORD PTR v2$[rsp]
  003a4	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3049 : 
; 3050 :     /* Set condition code in PSW */
; 3051 :     regs->psw.cc = cc;

  003ac	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b4	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR cc$[rsp]
  003b9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3052 : 
; 3053 : } /* end DEF_INST(load_and_perform_interlocked_access_long) */

  003bc	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003c3	c3		 ret	 0
s370_load_and_perform_interlocked_access_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 48
result$ = 52
opcode$ = 56
v2$ = 60
disp2$1 = 64
cc$ = 68
tv168 = 72
v3$ = 76
temp$2 = 80
b2$ = 84
tv92 = 88
tv171 = 92
tv174 = 96
tv177 = 100
r3$ = 104
new$ = 108
old$ = 112
rc$ = 116
r1$ = 120
m2$ = 128
inst$ = 160
regs$ = 168
s370_load_and_perform_interlocked_access PROC

; 2882 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2883 : int     r1, r3;                         /* Register numbers          */
; 2884 : int     b2;                             /* Base of effective addr    */
; 2885 : VADR    effective_addr2;                /* Effective address         */
; 2886 : BYTE    *m2;                            /* Mainstor address          */
; 2887 : U32     v2, v3;                         /* Operand values            */
; 2888 : U32     result;                         /* Result value              */
; 2889 : U32     old, new;                       /* Values for cmpxchg4       */
; 2890 : int     cc;                             /* Condition code            */
; 2891 : int     rc;                             /* Return code               */
; 2892 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2893 : 
; 2894 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 50	 mov	 DWORD PTR temp$2[rsp], eax
  00029	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  00031	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00035	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003a	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
  0003e	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00042	c1 e8 0c	 shr	 eax, 12
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 54	 mov	 DWORD PTR b2$[rsp], eax
  0004c	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 10	 shr	 eax, 16
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 68	 mov	 DWORD PTR r3$[rsp], eax
  0005a	8b 44 24 50	 mov	 eax, DWORD PTR temp$2[rsp]
  0005e	c1 e8 14	 shr	 eax, 20
  00061	83 e0 0f	 and	 eax, 15
  00064	89 44 24 78	 mov	 DWORD PTR r1$[rsp], eax
  00068	83 7c 24 54 00	 cmp	 DWORD PTR b2$[rsp], 0
  0006d	74 20		 je	 SHORT $LN10@s370_load_
  0006f	48 63 44 24 54	 movsxd	 rax, DWORD PTR b2$[rsp]
  00074	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00083	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN10@s370_load_:
  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	48 6b c0 04	 imul	 rax, rax, 4
  00098	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000a0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a4	85 c0		 test	 eax, eax
  000a6	74 0a		 je	 SHORT $LN25@s370_load_
  000a8	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b0	eb 08		 jmp	 SHORT $LN26@s370_load_
$LN25@s370_load_:
  000b2	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN26@s370_load_:
  000ba	83 7c 24 58 00	 cmp	 DWORD PTR tv92[rsp], 0
  000bf	74 3e		 je	 SHORT $LN11@s370_load_
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 04	 imul	 rax, rax, 4
  000ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d6	c1 e0 0c	 shl	 eax, 12
  000d9	8b 4c 24 40	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000dd	0b c8		 or	 ecx, eax
  000df	8b c1		 mov	 eax, ecx
  000e1	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
  000e5	8b 44 24 40	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e9	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000ee	85 c0		 test	 eax, eax
  000f0	74 0d		 je	 SHORT $LN12@s370_load_
  000f2	8b 44 24 40	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f6	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000fb	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
$LN12@s370_load_:
$LN11@s370_load_:
  000ff	8b 44 24 40	 mov	 eax, DWORD PTR disp2$1[rsp]
  00103	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00107	03 c8		 add	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0010f	33 c0		 xor	 eax, eax
  00111	83 f8 06	 cmp	 eax, 6
  00114	74 0d		 je	 SHORT $LN13@s370_load_
  00116	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0011a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011f	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN13@s370_load_:
$LN4@s370_load_:
  00123	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0012f	48 83 c0 06	 add	 rax, 6
  00133	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0013f	33 c0		 xor	 eax, eax
  00141	83 f8 06	 cmp	 eax, 6
  00144	74 0f		 je	 SHORT $LN14@s370_load_
  00146	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN14@s370_load_:
  00155	33 c0		 xor	 eax, eax
  00157	85 c0		 test	 eax, eax
  00159	75 c8		 jne	 SHORT $LN4@s370_load_

; 2895 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 2896 : 
; 2897 :     /* Program check if operand not on fullword boundary */
; 2898 :     FW_CHECK( effective_addr2, regs );

  0015b	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0015f	83 e0 03	 and	 eax, 3
  00162	85 c0		 test	 eax, eax
  00164	74 1b		 je	 SHORT $LN15@s370_load_
  00166	ba 06 00 00 00	 mov	 edx, 6
  0016b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@s370_load_:

; 2899 : 
; 2900 :     /* Extract second byte of instruction opcode */
; 2901 :     opcode = inst[5];

  00181	b8 01 00 00 00	 mov	 eax, 1
  00186	48 6b c0 05	 imul	 rax, rax, 5
  0018a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00192	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00196	88 44 24 38	 mov	 BYTE PTR opcode$[rsp], al

; 2902 : 
; 2903 :     /* Obtain third operand value from R3 register */
; 2904 :     v3 = regs->GR_L(r3);

  0019a	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  0019f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001ae	89 44 24 4c	 mov	 DWORD PTR v3$[rsp], eax

; 2905 : 
; 2906 :     /* Get mainstor address of storage operand */
; 2907 :     m2 = MADDRL (effective_addr2, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  001b2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001be	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  001c2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001ca	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d2	44 8b 44 24 54	 mov	 r8d, DWORD PTR b2$[rsp]
  001d7	ba 04 00 00 00	 mov	 edx, 4
  001dc	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001e0	e8 00 00 00 00	 call	 s370_maddr_l
  001e5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR m2$[rsp], rax
$LN7@s370_load_:

; 2908 : 
; 2909 :     do {
; 2910 :         /* Load storage operand value from operand address */
; 2911 :         v2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  001ed	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f5	8b 54 24 54	 mov	 edx, DWORD PTR b2$[rsp]
  001f9	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001fd	e8 00 00 00 00	 call	 s370_vfetch4
  00202	89 44 24 3c	 mov	 DWORD PTR v2$[rsp], eax

; 2912 : 
; 2913 :         switch (opcode) {

  00206	0f b6 44 24 38	 movzx	 eax, BYTE PTR opcode$[rsp]
  0020b	88 44 24 48	 mov	 BYTE PTR tv168[rsp], al
  0020f	80 7c 24 48 f4	 cmp	 BYTE PTR tv168[rsp], 244 ; 000000f4H
  00214	74 2d		 je	 SHORT $LN16@s370_load_
  00216	80 7c 24 48 f6	 cmp	 BYTE PTR tv168[rsp], 246 ; 000000f6H
  0021b	74 5c		 je	 SHORT $LN17@s370_load_
  0021d	80 7c 24 48 f7	 cmp	 BYTE PTR tv168[rsp], 247 ; 000000f7H
  00222	0f 84 84 00 00
	00		 je	 $LN18@s370_load_
  00228	80 7c 24 48 f8	 cmp	 BYTE PTR tv168[rsp], 248 ; 000000f8H
  0022d	0f 84 ac 00 00
	00		 je	 $LN19@s370_load_
  00233	80 7c 24 48 fa	 cmp	 BYTE PTR tv168[rsp], 250 ; 000000faH
  00238	0f 84 ba 00 00
	00		 je	 $LN20@s370_load_
  0023e	e9 ce 00 00 00	 jmp	 $LN21@s370_load_
$LN16@s370_load_:

; 2914 :         case 0xF4: /* Load and And */
; 2915 :             /* AND operand values and set condition code */
; 2916 :             result = v2 & v3;

  00243	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  00247	8b 4c 24 3c	 mov	 ecx, DWORD PTR v2$[rsp]
  0024b	23 c8		 and	 ecx, eax
  0024d	8b c1		 mov	 eax, ecx
  0024f	89 44 24 34	 mov	 DWORD PTR result$[rsp], eax

; 2917 :             cc = result ? 1 : 0;

  00253	83 7c 24 34 00	 cmp	 DWORD PTR result$[rsp], 0
  00258	74 0a		 je	 SHORT $LN27@s370_load_
  0025a	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  00262	eb 08		 jmp	 SHORT $LN28@s370_load_
$LN27@s370_load_:
  00264	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN28@s370_load_:
  0026c	8b 44 24 5c	 mov	 eax, DWORD PTR tv171[rsp]
  00270	89 44 24 44	 mov	 DWORD PTR cc$[rsp], eax

; 2918 :             break;

  00274	e9 a8 00 00 00	 jmp	 $LN8@s370_load_
$LN17@s370_load_:

; 2919 :         case 0xF6: /* Load and Or */
; 2920 :             /* OR operand values and set condition code */
; 2921 :             result = v2 | v3;

  00279	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  0027d	8b 4c 24 3c	 mov	 ecx, DWORD PTR v2$[rsp]
  00281	0b c8		 or	 ecx, eax
  00283	8b c1		 mov	 eax, ecx
  00285	89 44 24 34	 mov	 DWORD PTR result$[rsp], eax

; 2922 :             cc = result ? 1 : 0;

  00289	83 7c 24 34 00	 cmp	 DWORD PTR result$[rsp], 0
  0028e	74 0a		 je	 SHORT $LN29@s370_load_
  00290	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00298	eb 08		 jmp	 SHORT $LN30@s370_load_
$LN29@s370_load_:
  0029a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN30@s370_load_:
  002a2	8b 44 24 60	 mov	 eax, DWORD PTR tv174[rsp]
  002a6	89 44 24 44	 mov	 DWORD PTR cc$[rsp], eax

; 2923 :             break;

  002aa	eb 75		 jmp	 SHORT $LN8@s370_load_
$LN18@s370_load_:

; 2924 :         case 0xF7: /* Load and Exclusive Or */
; 2925 :             /* XOR operand values and set condition code */
; 2926 :             result = v2 ^ v3;

  002ac	8b 44 24 4c	 mov	 eax, DWORD PTR v3$[rsp]
  002b0	8b 4c 24 3c	 mov	 ecx, DWORD PTR v2$[rsp]
  002b4	33 c8		 xor	 ecx, eax
  002b6	8b c1		 mov	 eax, ecx
  002b8	89 44 24 34	 mov	 DWORD PTR result$[rsp], eax

; 2927 :             cc = result ? 1 : 0;

  002bc	83 7c 24 34 00	 cmp	 DWORD PTR result$[rsp], 0
  002c1	74 0a		 je	 SHORT $LN31@s370_load_
  002c3	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  002cb	eb 08		 jmp	 SHORT $LN32@s370_load_
$LN31@s370_load_:
  002cd	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN32@s370_load_:
  002d5	8b 44 24 64	 mov	 eax, DWORD PTR tv177[rsp]
  002d9	89 44 24 44	 mov	 DWORD PTR cc$[rsp], eax

; 2928 :             break;

  002dd	eb 42		 jmp	 SHORT $LN8@s370_load_
$LN19@s370_load_:

; 2929 :         case 0xF8: /* Load and Add */
; 2930 :             /* Add signed operands and set condition code */
; 2931 :             cc = add_signed (&result, v2, v3);

  002df	44 8b 44 24 4c	 mov	 r8d, DWORD PTR v3$[rsp]
  002e4	8b 54 24 3c	 mov	 edx, DWORD PTR v2$[rsp]
  002e8	48 8d 4c 24 34	 lea	 rcx, QWORD PTR result$[rsp]
  002ed	e8 00 00 00 00	 call	 add_signed
  002f2	89 44 24 44	 mov	 DWORD PTR cc$[rsp], eax

; 2932 :             break;

  002f6	eb 29		 jmp	 SHORT $LN8@s370_load_
$LN20@s370_load_:

; 2933 :         case 0xFA: /* Load and Add Logical */
; 2934 :             /* Add unsigned operands and set condition code */
; 2935 :             cc = add_logical (&result, v2, v3);

  002f8	44 8b 44 24 4c	 mov	 r8d, DWORD PTR v3$[rsp]
  002fd	8b 54 24 3c	 mov	 edx, DWORD PTR v2$[rsp]
  00301	48 8d 4c 24 34	 lea	 rcx, QWORD PTR result$[rsp]
  00306	e8 00 00 00 00	 call	 add_logical
  0030b	89 44 24 44	 mov	 DWORD PTR cc$[rsp], eax

; 2936 :             break;

  0030f	eb 10		 jmp	 SHORT $LN8@s370_load_
$LN21@s370_load_:

; 2937 :         default: /* To prevent compiler warnings */
; 2938 :             result = 0;

  00311	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2939 :             cc = 0;

  00319	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@s370_load_:

; 2940 :         } /* end switch(opcode) */
; 2941 : 
; 2942 :         /* Interlocked exchange to storage location */
; 2943 :         old = CSWAP32(v2);

  00321	8b 4c 24 3c	 mov	 ecx, DWORD PTR v2$[rsp]
  00325	e8 00 00 00 00	 call	 _byteswap_ulong
  0032a	89 44 24 70	 mov	 DWORD PTR old$[rsp], eax

; 2944 :         new = CSWAP32(result);

  0032e	8b 4c 24 34	 mov	 ecx, DWORD PTR result$[rsp]
  00332	e8 00 00 00 00	 call	 _byteswap_ulong
  00337	89 44 24 6c	 mov	 DWORD PTR new$[rsp], eax

; 2945 : 
; 2946 :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 2947 :         OBTAIN_MAINLOCK( regs );
; 2948 :         {
; 2949 :             rc = cmpxchg4( &old, new, m2 );

  0033b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR m2$[rsp]
  00343	8b 54 24 6c	 mov	 edx, DWORD PTR new$[rsp]
  00347	48 8d 4c 24 70	 lea	 rcx, QWORD PTR old$[rsp]
  0034c	e8 00 00 00 00	 call	 cmpxchg4_x86
  00351	0f b6 c0	 movzx	 eax, al
  00354	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 2950 :         }
; 2951 :         RELEASE_MAINLOCK( regs );
; 2952 : 
; 2953 :     } while (rc != 0);

  00358	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  0035d	0f 85 8a fe ff
	ff		 jne	 $LN7@s370_load_

; 2954 : 
; 2955 :     /* Load original storage operand value into R1 register */
; 2956 :     regs->GR_L(r1) = v2;

  00363	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  00368	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	8b 54 24 3c	 mov	 edx, DWORD PTR v2$[rsp]
  00374	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2957 : 
; 2958 :     /* Set condition code in PSW */
; 2959 :     regs->psw.cc = cc;

  0037b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00383	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR cc$[rsp]
  00388	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2960 : 
; 2961 : } /* end DEF_INST(load_and_perform_interlocked_access) */

  0038b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00392	c3		 ret	 0
s370_load_and_perform_interlocked_access ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
opcode$ = 32
i4$ = 33
i3$ = 34
end$ = 36
start$ = 40
mask$ = 48
r1$ = 56
i5$ = 60
resu$ = 64
temp$1 = 72
tv191 = 76
n$ = 80
rota$ = 88
r2$ = 96
tv203 = 100
t_bit$ = 104
z_bit$ = 108
tv258 = 112
tv259 = 116
tv159 = 120
tv331 = 128
tv345 = 136
p$2 = 144
inst$ = 176
regs$ = 184
s370_rotate_then_xxx_selected_bits_long_reg PROC

; 2062 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2063 : int     r1, r2;                         /* Register numbers          */
; 2064 : int     start, end;                     /* Start and end bit number  */
; 2065 : U64     mask, rota, resu;               /* 64-bit work areas         */
; 2066 : int     n;                              /* Number of bits to shift   */
; 2067 : int     t_bit = 0;                      /* Test-results indicator    */

  00011	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR t_bit$[rsp], 0

; 2068 : int     z_bit = 0;                      /* Zero-remaining indicator  */

  00019	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR z_bit$[rsp], 0

; 2069 : BYTE    i3, i4, i5;                     /* Immediate values          */
; 2070 : BYTE    opcode;                         /* 2nd byte of opcode        */
; 2071 : 
; 2072 :     RIE_RRIII( inst, regs, r1, r2, i3, i4, i5 );

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	48 6b c0 01	 imul	 rax, rax, 1
  0002a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 _byteswap_ulong
  00047	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0004b	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00054	88 44 24 3c	 mov	 BYTE PTR i5$[rsp], al
  00058	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 08	 shr	 eax, 8
  0005f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00064	88 44 24 21	 mov	 BYTE PTR i4$[rsp], al
  00068	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 10	 shr	 eax, 16
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	88 44 24 22	 mov	 BYTE PTR i3$[rsp], al
  00078	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0007c	c1 e8 18	 shr	 eax, 24
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 60	 mov	 DWORD PTR r2$[rsp], eax
  00086	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0008a	c1 e8 1c	 shr	 eax, 28
  0008d	83 e0 0f	 and	 eax, 15
  00090	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_rotat:
  00094	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a0	48 83 c0 06	 add	 rax, 6
  000a4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b0	33 c0		 xor	 eax, eax
  000b2	83 f8 06	 cmp	 eax, 6
  000b5	74 0f		 je	 SHORT $LN10@s370_rotat
  000b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_rotat:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 c8		 jne	 SHORT $LN4@s370_rotat

; 2073 : 
; 2074 :     /* Extract second byte of instruction opcode */
; 2075 :     opcode = inst[5];

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	48 6b c0 05	 imul	 rax, rax, 5
  000d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000dd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e1	88 44 24 20	 mov	 BYTE PTR opcode$[rsp], al

; 2076 : 
; 2077 :     /* Extract parameters from immediate fields */
; 2078 :     start = i3 & 0x3F;

  000e5	0f b6 44 24 22	 movzx	 eax, BYTE PTR i3$[rsp]
  000ea	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ed	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2079 :     end   = i4 & 0x3F;

  000f1	0f b6 44 24 21	 movzx	 eax, BYTE PTR i4$[rsp]
  000f6	83 e0 3f	 and	 eax, 63			; 0000003fH
  000f9	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax

; 2080 : 
; 2081 :     n = i5 & 0x3F;

  000fd	0f b6 44 24 3c	 movzx	 eax, BYTE PTR i5$[rsp]
  00102	83 e0 3f	 and	 eax, 63			; 0000003fH
  00105	89 44 24 50	 mov	 DWORD PTR n$[rsp], eax

; 2082 : 
; 2083 :     if ((opcode & 0xFC) == 0x50 /*Low*/ ) {

  00109	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  0010e	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00113	83 f8 50	 cmp	 eax, 80			; 00000050H
  00116	75 16		 jne	 SHORT $LN11@s370_rotat

; 2084 :         start |= 0x20;

  00118	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  0011c	83 c8 20	 or	 eax, 32			; 00000020H
  0011f	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2085 :         end   |= 0x20;

  00123	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  00127	83 c8 20	 or	 eax, 32			; 00000020H
  0012a	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax
$LN11@s370_rotat:

; 2086 :     }
; 2087 :     if ((opcode & 0xFC) == 0x5C /*High*/ ) {

  0012e	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00133	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00138	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0013b	75 16		 jne	 SHORT $LN12@s370_rotat

; 2088 :         start &= 0x1F;

  0013d	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  00141	83 e0 1f	 and	 eax, 31
  00144	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 2089 :         end   &= 0x1F;

  00148	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  0014c	83 e0 1f	 and	 eax, 31
  0014f	89 44 24 24	 mov	 DWORD PTR end$[rsp], eax
$LN12@s370_rotat:

; 2090 :     }
; 2091 :     if ((opcode & 0x03) == 0x01 /*Insert*/ )

  00153	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00158	83 e0 03	 and	 eax, 3
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	75 0e		 jne	 SHORT $LN13@s370_rotat

; 2092 :         z_bit = i4 >> 7;

  00160	0f b6 44 24 21	 movzx	 eax, BYTE PTR i4$[rsp]
  00165	c1 f8 07	 sar	 eax, 7
  00168	89 44 24 6c	 mov	 DWORD PTR z_bit$[rsp], eax
  0016c	eb 0c		 jmp	 SHORT $LN14@s370_rotat
$LN13@s370_rotat:

; 2093 :     else
; 2094 :         t_bit = i3 >> 7;

  0016e	0f b6 44 24 22	 movzx	 eax, BYTE PTR i3$[rsp]
  00173	c1 f8 07	 sar	 eax, 7
  00176	89 44 24 68	 mov	 DWORD PTR t_bit$[rsp], eax
$LN14@s370_rotat:

; 2095 : 
; 2096 :     /* Copy value from R2 register and rotate left n bits */
; 2097 :     rota = (regs->GR_G( r2 ) << n)

  0017a	83 7c 24 50 00	 cmp	 DWORD PTR n$[rsp], 0
  0017f	75 0b		 jne	 SHORT $LN35@s370_rotat
  00181	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv159[rsp], 0
  0018a	eb 26		 jmp	 SHORT $LN36@s370_rotat
$LN35@s370_rotat:
  0018c	48 63 44 24 60	 movsxd	 rax, DWORD PTR r2$[rsp]
  00191	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00196	2b 4c 24 50	 sub	 ecx, DWORD PTR n$[rsp]
  0019a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a2	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  001aa	48 d3 e8	 shr	 rax, cl
  001ad	48 89 44 24 78	 mov	 QWORD PTR tv159[rsp], rax
$LN36@s370_rotat:
  001b2	48 63 44 24 60	 movsxd	 rax, DWORD PTR r2$[rsp]
  001b7	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  001bb	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  001cb	48 d3 e0	 shl	 rax, cl
  001ce	48 0b 44 24 78	 or	 rax, QWORD PTR tv159[rsp]
  001d3	48 89 44 24 58	 mov	 QWORD PTR rota$[rsp], rax

; 2098 :             | ((n == 0) ? 0 : (regs->GR_G( r2 ) >> (64 - n)));
; 2099 : 
; 2100 : #if 0 // (old way; TEMPORARILY retained for reference)
; 2101 : 
; 2102 :     /* Construct mask for selected bits */
; 2103 :     {
; 2104 :         int i;
; 2105 : 
; 2106 :         for (i=0, mask=0; i < 64; i++)
; 2107 :         {
; 2108 :             mask <<= 1;
; 2109 :             if (start <= end) {
; 2110 :                 if (i >= start && i <= end) mask |= 1;
; 2111 :             } else {
; 2112 :                 if (i <= end || i >= start) mask |= 1;
; 2113 :             }
; 2114 :         }
; 2115 :     }
; 2116 : 
; 2117 : #else // (Ivan Warren performance enhancement)
; 2118 : 
; 2119 :     /* Construct mask for selected bits */
; 2120 :     if (start <= end)

  001d8	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  001dc	39 44 24 28	 cmp	 DWORD PTR start$[rsp], eax
  001e0	7f 76		 jg	 SHORT $LN15@s370_rotat

; 2121 :     {
; 2122 :         // (clear high-order bits)
; 2123 :         mask   = 0xffffffffffffffffll << start;

  001e2	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  001e6	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  001ed	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv331[rsp], rcx
  001f5	0f b6 c8	 movzx	 ecx, al
  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv331[rsp]
  00200	48 d3 e0	 shl	 rax, cl
  00203	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2124 :         mask >>=                         start;

  00208	48 63 44 24 28	 movsxd	 rax, DWORD PTR start$[rsp]
  0020d	0f b6 c8	 movzx	 ecx, al
  00210	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00215	48 d3 e8	 shr	 rax, cl
  00218	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2125 : 
; 2126 :         // (clear low-order bits)
; 2127 :         mask >>= (63 - end);

  0021d	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00222	2b 44 24 24	 sub	 eax, DWORD PTR end$[rsp]
  00226	48 98		 cdqe
  00228	0f b6 c8	 movzx	 ecx, al
  0022b	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00230	48 d3 e8	 shr	 rax, cl
  00233	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2128 :         mask <<= (63 - end);

  00238	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0023d	2b 44 24 24	 sub	 eax, DWORD PTR end$[rsp]
  00241	48 98		 cdqe
  00243	0f b6 c8	 movzx	 ecx, al
  00246	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  0024b	48 d3 e0	 shl	 rax, cl
  0024e	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2129 :     }

  00253	e9 84 00 00 00	 jmp	 $LN16@s370_rotat
$LN15@s370_rotat:

; 2130 :     else // (start > end)
; 2131 :     {
; 2132 :         // (clear high-order bits)
; 2133 :         mask   = 0xffffffffffffffffll << (end + 1);

  00258	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  0025c	ff c0		 inc	 eax
  0025e	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00265	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv345[rsp], rcx
  0026d	0f b6 c8	 movzx	 ecx, al
  00270	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv345[rsp]
  00278	48 d3 e0	 shl	 rax, cl
  0027b	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2134 :         mask >>=                         (end + 1);

  00280	8b 44 24 24	 mov	 eax, DWORD PTR end$[rsp]
  00284	ff c0		 inc	 eax
  00286	48 98		 cdqe
  00288	0f b6 c8	 movzx	 ecx, al
  0028b	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  00290	48 d3 e8	 shr	 rax, cl
  00293	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2135 : 
; 2136 :         // (clear low-order bits)
; 2137 :         mask >>= (64 - start);

  00298	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0029d	2b 44 24 28	 sub	 eax, DWORD PTR start$[rsp]
  002a1	48 98		 cdqe
  002a3	0f b6 c8	 movzx	 ecx, al
  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002ab	48 d3 e8	 shr	 rax, cl
  002ae	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2138 :         mask <<= (64 - start);

  002b3	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  002b8	2b 44 24 28	 sub	 eax, DWORD PTR start$[rsp]
  002bc	48 98		 cdqe
  002be	0f b6 c8	 movzx	 ecx, al
  002c1	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002c6	48 d3 e0	 shl	 rax, cl
  002c9	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax

; 2139 : 
; 2140 :         // (invert mask to select opposite bits)
; 2141 :         mask ^= 0xffffffffffffffffll;

  002ce	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002d3	48 83 f0 ff	 xor	 rax, -1
  002d7	48 89 44 24 30	 mov	 QWORD PTR mask$[rsp], rax
$LN16@s370_rotat:

; 2142 :     }
; 2143 : 
; 2144 : #endif
; 2145 : 
; 2146 :     /* Isolate selected bits of rotated second operand */
; 2147 :     rota &= mask;

  002dc	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$[rsp]
  002e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rota$[rsp]
  002e6	48 23 c8	 and	 rcx, rax
  002e9	48 8b c1	 mov	 rax, rcx
  002ec	48 89 44 24 58	 mov	 QWORD PTR rota$[rsp], rax

; 2148 : 
; 2149 :     /* Isolate selected bits of first operand */
; 2150 :     resu = regs->GR_G( r1 ) & mask;

  002f1	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  002f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	48 8b 54 24 30	 mov	 rdx, QWORD PTR mask$[rsp]
  00303	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0030b	48 23 c2	 and	 rax, rdx
  0030e	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2151 : 
; 2152 :     /* Perform operation on selected bits */
; 2153 :     switch (opcode)

  00313	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00318	89 44 24 4c	 mov	 DWORD PTR tv191[rsp], eax
  0031c	8b 44 24 4c	 mov	 eax, DWORD PTR tv191[rsp]
  00320	83 e8 51	 sub	 eax, 81			; 00000051H
  00323	89 44 24 4c	 mov	 DWORD PTR tv191[rsp], eax
  00327	83 7c 24 4c 0c	 cmp	 DWORD PTR tv191[rsp], 12
  0032c	77 69		 ja	 SHORT $LN24@s370_rotat
  0032e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv191[rsp]
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0033a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@s370_rotat[rcx+rax*4]
  00341	48 03 c1	 add	 rax, rcx
  00344	ff e0		 jmp	 rax
$LN17@s370_rotat:

; 2154 :     {
; 2155 :     case 0x54:  /* And */
; 2156 :         resu &= rota;

  00346	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  0034b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  00350	48 23 c8	 and	 rcx, rax
  00353	48 8b c1	 mov	 rax, rcx
  00356	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2157 :         break;

  0035b	eb 57		 jmp	 SHORT $LN5@s370_rotat
$LN18@s370_rotat:
$LN19@s370_rotat:
$LN20@s370_rotat:
$LN21@s370_rotat:

; 2158 :     case 0x51:  /* Insert Low            */
; 2159 :     case 0x55:  /* Insert                */
; 2160 :     case 0x5D:  /* Insert High           */
; 2161 :     case 0x59:  /* Insert - no CC change */
; 2162 :         resu = rota;

  0035d	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  00362	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2163 :         break;

  00367	eb 4b		 jmp	 SHORT $LN5@s370_rotat
$LN22@s370_rotat:

; 2164 :     case 0x56:  /* Or */
; 2165 :         resu |= rota;

  00369	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  0036e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  00373	48 0b c8	 or	 rcx, rax
  00376	48 8b c1	 mov	 rax, rcx
  00379	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2166 :         break;

  0037e	eb 34		 jmp	 SHORT $LN5@s370_rotat
$LN23@s370_rotat:

; 2167 :     case 0x57:  /* Exclusive Or */
; 2168 :         resu ^= rota;

  00380	48 8b 44 24 58	 mov	 rax, QWORD PTR rota$[rsp]
  00385	48 8b 4c 24 40	 mov	 rcx, QWORD PTR resu$[rsp]
  0038a	48 33 c8	 xor	 rcx, rax
  0038d	48 8b c1	 mov	 rax, rcx
  00390	48 89 44 24 40	 mov	 QWORD PTR resu$[rsp], rax

; 2169 :         break;

  00395	eb 1d		 jmp	 SHORT $LN5@s370_rotat
$LN24@s370_rotat:
$LN9@s370_rotat:

; 2170 :     default:    /* Should not EVER occur! */
; 2171 :         CRASH();

  00397	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$2[rsp], 0
  003a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$2[rsp]
  003ab	c6 00 00	 mov	 BYTE PTR [rax], 0
  003ae	33 c0		 xor	 eax, eax
  003b0	85 c0		 test	 eax, eax
  003b2	75 e3		 jne	 SHORT $LN9@s370_rotat
$LN5@s370_rotat:

; 2172 :     }
; 2173 : 
; 2174 :     /* And/Or/Xor set condition code according to result bits */
; 2175 :     if ((opcode & 0x03) != 0x01 /*Insert*/ )

  003b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  003b9	83 e0 03	 and	 eax, 3
  003bc	83 f8 01	 cmp	 eax, 1
  003bf	74 2a		 je	 SHORT $LN25@s370_rotat

; 2176 :         regs->psw.cc = (resu == 0) ? 0 : 1;

  003c1	48 83 7c 24 40
	00		 cmp	 QWORD PTR resu$[rsp], 0
  003c7	75 0a		 jne	 SHORT $LN37@s370_rotat
  003c9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
  003d1	eb 08		 jmp	 SHORT $LN38@s370_rotat
$LN37@s370_rotat:
  003d3	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv203[rsp], 1
$LN38@s370_rotat:
  003db	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv203[rsp]
  003e8	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN25@s370_rotat:

; 2177 : 
; 2178 :     /* Insert result bits into R1 register */
; 2179 :     if (t_bit == 0)

  003eb	83 7c 24 68 00	 cmp	 DWORD PTR t_bit$[rsp], 0
  003f0	0f 85 b4 00 00
	00		 jne	 $LN26@s370_rotat

; 2180 :     {
; 2181 :         if (z_bit == 0)

  003f6	83 7c 24 6c 00	 cmp	 DWORD PTR z_bit$[rsp], 0
  003fb	75 3c		 jne	 SHORT $LN27@s370_rotat

; 2182 :         {
; 2183 :             regs->GR_G( r1 ) = (regs->GR_G( r1 ) & ~mask) | resu;

  003fd	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00402	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mask$[rsp]
  00407	48 f7 d1	 not	 rcx
  0040a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00412	48 8b 84 c2 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+640]
  0041a	48 23 c1	 and	 rax, rcx
  0041d	48 0b 44 24 40	 or	 rax, QWORD PTR resu$[rsp]
  00422	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00427	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0042f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 2184 :         }

  00437	eb 71		 jmp	 SHORT $LN28@s370_rotat
$LN27@s370_rotat:

; 2185 :         else if ((opcode & 0xFC) == 0x50 /*Low*/ )

  00439	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  0043e	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00443	83 f8 50	 cmp	 eax, 80			; 00000050H
  00446	75 1a		 jne	 SHORT $LN29@s370_rotat

; 2186 :         {
; 2187 :             regs->GR_L( r1 ) = (U32) resu;

  00448	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  0044d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	8b 54 24 40	 mov	 edx, DWORD PTR resu$[rsp]
  00459	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 2188 :         }

  00460	eb 48		 jmp	 SHORT $LN30@s370_rotat
$LN29@s370_rotat:

; 2189 :         else if ((opcode & 0xFC) == 0x5C /*High*/ )

  00462	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  00467	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  0046c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0046f	75 1f		 jne	 SHORT $LN31@s370_rotat

; 2190 :         {
; 2191 :             regs->GR_H( r1 ) = (U32) (resu >> 32);

  00471	48 8b 44 24 40	 mov	 rax, QWORD PTR resu$[rsp]
  00476	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0047a	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0047f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00487	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2192 :         }

  0048e	eb 1a		 jmp	 SHORT $LN32@s370_rotat
$LN31@s370_rotat:

; 2193 :         else
; 2194 :             regs->GR_G( r1 ) = resu;

  00490	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00495	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049d	48 8b 54 24 40	 mov	 rdx, QWORD PTR resu$[rsp]
  004a2	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
$LN32@s370_rotat:
$LN30@s370_rotat:
$LN28@s370_rotat:
$LN26@s370_rotat:

; 2195 :     }
; 2196 : 
; 2197 :     /* For RISBHG, RISBLG the condition code remains unchanged.
; 2198 :        For RISBGN the condition code remains unchanged.
; 2199 :        For RISBG set condition code according to signed result.
; 2200 :     */
; 2201 :     if (opcode == 0x55) // (RISBG?)

  004aa	0f b6 44 24 20	 movzx	 eax, BYTE PTR opcode$[rsp]
  004af	83 f8 55	 cmp	 eax, 85			; 00000055H
  004b2	75 64		 jne	 SHORT $LN33@s370_rotat

; 2202 :         regs->psw.cc =

  004b4	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c1	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  004ca	7d 0a		 jge	 SHORT $LN41@s370_rotat
  004cc	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv259[rsp], 1
  004d4	eb 32		 jmp	 SHORT $LN42@s370_rotat
$LN41@s370_rotat:
  004d6	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  004db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	48 83 bc c1 80
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], 0
  004ec	7e 0a		 jle	 SHORT $LN39@s370_rotat
  004ee	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv258[rsp], 2
  004f6	eb 08		 jmp	 SHORT $LN40@s370_rotat
$LN39@s370_rotat:
  004f8	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
$LN40@s370_rotat:
  00500	8b 44 24 70	 mov	 eax, DWORD PTR tv258[rsp]
  00504	89 44 24 74	 mov	 DWORD PTR tv259[rsp], eax
$LN42@s370_rotat:
  00508	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00510	0f b6 4c 24 74	 movzx	 ecx, BYTE PTR tv259[rsp]
  00515	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN33@s370_rotat:

; 2203 :                 (((S64) regs->GR_G( r1 )) < 0) ? 1 :
; 2204 :                 (((S64) regs->GR_G( r1 )) > 0) ? 2 : 0;
; 2205 : 
; 2206 : } /* end DEF_INST( rotate_then_xxx_selected_bits_long_reg ) */

  00518	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0051f	c3		 ret	 0
$LN43@s370_rotat:
  00520	00 00 00 00	 DD	 $LN18@s370_rotat
  00524	00 00 00 00	 DD	 $LN24@s370_rotat
  00528	00 00 00 00	 DD	 $LN24@s370_rotat
  0052c	00 00 00 00	 DD	 $LN17@s370_rotat
  00530	00 00 00 00	 DD	 $LN19@s370_rotat
  00534	00 00 00 00	 DD	 $LN22@s370_rotat
  00538	00 00 00 00	 DD	 $LN23@s370_rotat
  0053c	00 00 00 00	 DD	 $LN24@s370_rotat
  00540	00 00 00 00	 DD	 $LN21@s370_rotat
  00544	00 00 00 00	 DD	 $LN24@s370_rotat
  00548	00 00 00 00	 DD	 $LN24@s370_rotat
  0054c	00 00 00 00	 DD	 $LN24@s370_rotat
  00550	00 00 00 00	 DD	 $LN20@s370_rotat
s370_rotate_then_xxx_selected_bits_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 48
effective_addr1$ = 52
opcode$ = 56
disp$1 = 60
b1$ = 64
temp$2 = 68
cc$ = 72
tv91 = 76
tv156 = 80
tv176 = 84
result$ = 88
n$ = 96
rc$ = 104
m1$ = 112
new$ = 120
old$ = 128
inst$ = 160
regs$ = 168
s370_perform_interlocked_long_storage_immediate PROC

; 113  : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 114  : BYTE    opcode;                         /* 2nd byte of opcode        */
; 115  : BYTE    i2;                             /* Immediate byte            */
; 116  : int     b1;                             /* Base of effective addr    */
; 117  : VADR    effective_addr1;                /* Effective address         */
; 118  : BYTE    *m1;                            /* Mainstor address          */
; 119  : U64     n;                              /* 64-bit operand value      */
; 120  : U64     result;                         /* Result value              */
; 121  : U64     old, new;                       /* Values for cmpxchg4       */
; 122  : int     cc;                             /* Condition code            */
; 123  : int     rc;                             /* Return code               */
; 124  : 
; 125  :     SIY(inst, regs, i2, b1, effective_addr1);

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 44	 mov	 DWORD PTR temp$2[rsp], eax
  00029	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR effective_addr1$[rsp], 0
  00031	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00035	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003a	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
  0003e	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00042	c1 e8 0c	 shr	 eax, 12
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 40	 mov	 DWORD PTR b1$[rsp], eax
  0004c	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 10	 shr	 eax, 16
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	88 44 24 30	 mov	 BYTE PTR i2$[rsp], al
  0005c	83 7c 24 40 00	 cmp	 DWORD PTR b1$[rsp], 0
  00061	74 20		 je	 SHORT $LN10@s370_perfo
  00063	48 63 44 24 40	 movsxd	 rax, DWORD PTR b1$[rsp]
  00068	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007b	03 c8		 add	 ecx, eax
  0007d	8b c1		 mov	 eax, ecx
  0007f	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN10@s370_perfo:
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	48 6b c0 04	 imul	 rax, rax, 4
  0008c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN21@s370_perfo
  0009c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN22@s370_perfo
$LN21@s370_perfo:
  000a6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN22@s370_perfo:
  000ae	83 7c 24 4c 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b3	74 3e		 je	 SHORT $LN11@s370_perfo
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ca	c1 e0 0c	 shl	 eax, 12
  000cd	8b 4c 24 3c	 mov	 ecx, DWORD PTR disp$1[rsp]
  000d1	0b c8		 or	 ecx, eax
  000d3	8b c1		 mov	 eax, ecx
  000d5	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
  000d9	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000dd	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e2	85 c0		 test	 eax, eax
  000e4	74 0d		 je	 SHORT $LN12@s370_perfo
  000e6	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000ea	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ef	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
$LN12@s370_perfo:
$LN11@s370_perfo:
  000f3	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000f7	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000fb	03 c8		 add	 ecx, eax
  000fd	8b c1		 mov	 eax, ecx
  000ff	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00103	8b 44 24 34	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00107	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0010c	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN4@s370_perfo:
  00110	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011c	48 83 c0 06	 add	 rax, 6
  00120	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012c	33 c0		 xor	 eax, eax
  0012e	83 f8 06	 cmp	 eax, 6
  00131	74 0f		 je	 SHORT $LN13@s370_perfo
  00133	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s370_perfo:
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 c8		 jne	 SHORT $LN4@s370_perfo

; 126  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 127  : 
; 128  :     /* Extract second byte of instruction opcode */
; 129  :     opcode = inst[5];

  00148	b8 01 00 00 00	 mov	 eax, 1
  0014d	48 6b c0 05	 imul	 rax, rax, 5
  00151	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00159	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015d	88 44 24 38	 mov	 BYTE PTR opcode$[rsp], al

; 130  : 
; 131  :     /* Get mainstor address of storage operand */
; 132  :     m1 = MADDRL (effective_addr1, 8, b1, regs, ACCTYPE_WRITE, regs->psw.pkey);

  00161	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0016d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00171	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00179	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00181	44 8b 44 24 40	 mov	 r8d, DWORD PTR b1$[rsp]
  00186	ba 08 00 00 00	 mov	 edx, 8
  0018b	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018f	e8 00 00 00 00	 call	 s370_maddr_l
  00194	48 89 44 24 70	 mov	 QWORD PTR m1$[rsp], rax
$LN7@s370_perfo:

; 133  : 
; 134  :     do {
; 135  :         /* Load 64-bit operand from operand address */
; 136  :         n = ARCH_DEP(vfetch8) (effective_addr1, b1, regs);

  00199	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a1	8b 54 24 40	 mov	 edx, DWORD PTR b1$[rsp]
  001a5	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a9	e8 00 00 00 00	 call	 s370_vfetch8
  001ae	48 89 44 24 60	 mov	 QWORD PTR n$[rsp], rax

; 137  : 
; 138  :         switch (opcode) {

  001b3	0f b6 44 24 38	 movzx	 eax, BYTE PTR opcode$[rsp]
  001b8	88 44 24 50	 mov	 BYTE PTR tv156[rsp], al
  001bc	80 7c 24 50 7a	 cmp	 BYTE PTR tv156[rsp], 122 ; 0000007aH
  001c1	74 09		 je	 SHORT $LN14@s370_perfo
  001c3	80 7c 24 50 7e	 cmp	 BYTE PTR tv156[rsp], 126 ; 0000007eH
  001c8	74 20		 je	 SHORT $LN15@s370_perfo
  001ca	eb 6e		 jmp	 SHORT $LN16@s370_perfo
$LN14@s370_perfo:

; 139  :         case 0x7A: /* Add Long Storage Immediate */
; 140  :             /* Add signed operands and set condition code */
; 141  :             cc = add_signed_long (&result, n, (S64)(S8)i2);

  001cc	48 0f be 44 24
	30		 movsx	 rax, BYTE PTR i2$[rsp]
  001d2	4c 8b c0	 mov	 r8, rax
  001d5	48 8b 54 24 60	 mov	 rdx, QWORD PTR n$[rsp]
  001da	48 8d 4c 24 58	 lea	 rcx, QWORD PTR result$[rsp]
  001df	e8 00 00 00 00	 call	 add_signed_long
  001e4	89 44 24 48	 mov	 DWORD PTR cc$[rsp], eax

; 142  :             break;

  001e8	eb 61		 jmp	 SHORT $LN8@s370_perfo
$LN15@s370_perfo:

; 143  :         case 0x7E: /* Add Logical Long Storage with Signed Immediate */
; 144  :             /* Add operands and set condition code */
; 145  :             cc = (S8)i2 < 0 ?

  001ea	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  001ef	85 c0		 test	 eax, eax
  001f1	7d 21		 jge	 SHORT $LN23@s370_perfo
  001f3	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  001f8	f7 d8		 neg	 eax
  001fa	48 98		 cdqe
  001fc	4c 8b c0	 mov	 r8, rax
  001ff	48 8b 54 24 60	 mov	 rdx, QWORD PTR n$[rsp]
  00204	48 8d 4c 24 58	 lea	 rcx, QWORD PTR result$[rsp]
  00209	e8 00 00 00 00	 call	 sub_logical_long
  0020e	89 44 24 54	 mov	 DWORD PTR tv176[rsp], eax
  00212	eb 1c		 jmp	 SHORT $LN24@s370_perfo
$LN23@s370_perfo:
  00214	48 0f be 44 24
	30		 movsx	 rax, BYTE PTR i2$[rsp]
  0021a	4c 8b c0	 mov	 r8, rax
  0021d	48 8b 54 24 60	 mov	 rdx, QWORD PTR n$[rsp]
  00222	48 8d 4c 24 58	 lea	 rcx, QWORD PTR result$[rsp]
  00227	e8 00 00 00 00	 call	 add_logical_long
  0022c	89 44 24 54	 mov	 DWORD PTR tv176[rsp], eax
$LN24@s370_perfo:
  00230	8b 44 24 54	 mov	 eax, DWORD PTR tv176[rsp]
  00234	89 44 24 48	 mov	 DWORD PTR cc$[rsp], eax

; 146  :                 sub_logical_long (&result, n, (S64)(-(S8)i2)) :
; 147  :                 add_logical_long (&result, n, (S64)(S8)i2);
; 148  :             break;

  00238	eb 11		 jmp	 SHORT $LN8@s370_perfo
$LN16@s370_perfo:

; 149  :         default: /* To prevent compiler warnings */
; 150  :             result = 0;

  0023a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 151  :             cc = 0;

  00243	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@s370_perfo:

; 152  :         } /* end switch(opcode) */
; 153  : 
; 154  :         /* Regular store if operand is not on a doubleword boundary */
; 155  :         if ((effective_addr1 & 0x07) != 0) {

  0024b	8b 44 24 34	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0024f	83 e0 07	 and	 eax, 7
  00252	85 c0		 test	 eax, eax
  00254	74 1d		 je	 SHORT $LN17@s370_perfo

; 156  :             ARCH_DEP(vstore8) (result, effective_addr1, b1, regs);

  00256	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0025e	44 8b 44 24 40	 mov	 r8d, DWORD PTR b1$[rsp]
  00263	8b 54 24 34	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00267	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  0026c	e8 00 00 00 00	 call	 s370_vstore8

; 157  :             break;

  00271	eb 4a		 jmp	 SHORT $LN6@s370_perfo
$LN17@s370_perfo:

; 158  :         }
; 159  : 
; 160  :         /* Interlocked exchange if operand is on doubleword boundary */
; 161  :         old = CSWAP64(n);

  00273	48 8b 4c 24 60	 mov	 rcx, QWORD PTR n$[rsp]
  00278	e8 00 00 00 00	 call	 _byteswap_uint64
  0027d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR old$[rsp], rax

; 162  :         new = CSWAP64(result);

  00285	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  0028a	e8 00 00 00 00	 call	 _byteswap_uint64
  0028f	48 89 44 24 78	 mov	 QWORD PTR new$[rsp], rax

; 163  : 
; 164  :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 165  :         OBTAIN_MAINLOCK( regs );
; 166  :         {
; 167  :             rc = cmpxchg8( &old, new, m1 );

  00294	4c 8b 44 24 70	 mov	 r8, QWORD PTR m1$[rsp]
  00299	48 8b 54 24 78	 mov	 rdx, QWORD PTR new$[rsp]
  0029e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR old$[rsp]
  002a6	e8 00 00 00 00	 call	 cmpxchg8_x86
  002ab	0f b6 c0	 movzx	 eax, al
  002ae	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 168  :         }
; 169  :         RELEASE_MAINLOCK( regs );
; 170  : 
; 171  :     } while (rc != 0);

  002b2	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  002b7	0f 85 dc fe ff
	ff		 jne	 $LN7@s370_perfo
$LN6@s370_perfo:

; 172  : 
; 173  :     /* Set condition code in PSW */
; 174  :     regs->psw.cc = cc;

  002bd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c5	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR cc$[rsp]
  002ca	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 175  : 
; 176  : } /* end DEF_INST(perform_interlocked_long_storage_immediate) */

  002cd	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002d4	c3		 ret	 0
s370_perform_interlocked_long_storage_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 48
effective_addr1$ = 52
opcode$ = 56
disp$1 = 60
b1$ = 64
result$ = 68
n$ = 72
temp$2 = 76
cc$ = 80
tv91 = 84
tv156 = 88
tv175 = 92
new$ = 96
old$ = 100
rc$ = 104
m1$ = 112
inst$ = 144
regs$ = 152
s370_perform_interlocked_storage_immediate PROC

; 40   : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 41   : BYTE    opcode;                         /* 2nd byte of opcode        */
; 42   : BYTE    i2;                             /* Immediate byte            */
; 43   : int     b1;                             /* Base of effective addr    */
; 44   : VADR    effective_addr1;                /* Effective address         */
; 45   : BYTE    *m1;                            /* Mainstor address          */
; 46   : U32     n;                              /* 32-bit operand value      */
; 47   : U32     result;                         /* Result value              */
; 48   : U32     old, new;                       /* Values for cmpxchg4       */
; 49   : int     cc;                             /* Condition code            */
; 50   : int     rc;                             /* Return code               */
; 51   : 
; 52   :     SIY(inst, regs, i2, b1, effective_addr1);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 4c	 mov	 DWORD PTR temp$2[rsp], eax
  00029	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR effective_addr1$[rsp], 0
  00031	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00035	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003a	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
  0003e	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00042	c1 e8 0c	 shr	 eax, 12
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 40	 mov	 DWORD PTR b1$[rsp], eax
  0004c	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 10	 shr	 eax, 16
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	88 44 24 30	 mov	 BYTE PTR i2$[rsp], al
  0005c	83 7c 24 40 00	 cmp	 DWORD PTR b1$[rsp], 0
  00061	74 20		 je	 SHORT $LN10@s370_perfo
  00063	48 63 44 24 40	 movsxd	 rax, DWORD PTR b1$[rsp]
  00068	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007b	03 c8		 add	 ecx, eax
  0007d	8b c1		 mov	 eax, ecx
  0007f	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN10@s370_perfo:
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	48 6b c0 04	 imul	 rax, rax, 4
  0008c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN21@s370_perfo
  0009c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN22@s370_perfo
$LN21@s370_perfo:
  000a6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN22@s370_perfo:
  000ae	83 7c 24 54 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b3	74 3e		 je	 SHORT $LN11@s370_perfo
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ca	c1 e0 0c	 shl	 eax, 12
  000cd	8b 4c 24 3c	 mov	 ecx, DWORD PTR disp$1[rsp]
  000d1	0b c8		 or	 ecx, eax
  000d3	8b c1		 mov	 eax, ecx
  000d5	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
  000d9	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000dd	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e2	85 c0		 test	 eax, eax
  000e4	74 0d		 je	 SHORT $LN12@s370_perfo
  000e6	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000ea	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ef	89 44 24 3c	 mov	 DWORD PTR disp$1[rsp], eax
$LN12@s370_perfo:
$LN11@s370_perfo:
  000f3	8b 44 24 3c	 mov	 eax, DWORD PTR disp$1[rsp]
  000f7	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000fb	03 c8		 add	 ecx, eax
  000fd	8b c1		 mov	 eax, ecx
  000ff	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00103	8b 44 24 34	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00107	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0010c	89 44 24 34	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN4@s370_perfo:
  00110	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011c	48 83 c0 06	 add	 rax, 6
  00120	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012c	33 c0		 xor	 eax, eax
  0012e	83 f8 06	 cmp	 eax, 6
  00131	74 0f		 je	 SHORT $LN13@s370_perfo
  00133	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN13@s370_perfo:
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 c8		 jne	 SHORT $LN4@s370_perfo

; 53   :     PER_ZEROADDR_XCHECK( regs, b1 );
; 54   : 
; 55   :     /* Extract second byte of instruction opcode */
; 56   :     opcode = inst[5];

  00148	b8 01 00 00 00	 mov	 eax, 1
  0014d	48 6b c0 05	 imul	 rax, rax, 5
  00151	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00159	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015d	88 44 24 38	 mov	 BYTE PTR opcode$[rsp], al

; 57   : 
; 58   :     /* Get mainstor address of storage operand */
; 59   :     m1 = MADDRL (effective_addr1, 4, b1, regs, ACCTYPE_WRITE, regs->psw.pkey);

  00161	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0016d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00171	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00179	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00181	44 8b 44 24 40	 mov	 r8d, DWORD PTR b1$[rsp]
  00186	ba 04 00 00 00	 mov	 edx, 4
  0018b	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0018f	e8 00 00 00 00	 call	 s370_maddr_l
  00194	48 89 44 24 70	 mov	 QWORD PTR m1$[rsp], rax
$LN7@s370_perfo:

; 60   : 
; 61   :     do {
; 62   :         /* Load 32-bit operand from operand address */
; 63   :         n = ARCH_DEP(vfetch4) (effective_addr1, b1, regs);

  00199	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a1	8b 54 24 40	 mov	 edx, DWORD PTR b1$[rsp]
  001a5	8b 4c 24 34	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001a9	e8 00 00 00 00	 call	 s370_vfetch4
  001ae	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 64   : 
; 65   :         switch (opcode) {

  001b2	0f b6 44 24 38	 movzx	 eax, BYTE PTR opcode$[rsp]
  001b7	88 44 24 58	 mov	 BYTE PTR tv156[rsp], al
  001bb	80 7c 24 58 6a	 cmp	 BYTE PTR tv156[rsp], 106 ; 0000006aH
  001c0	74 09		 je	 SHORT $LN14@s370_perfo
  001c2	80 7c 24 58 6e	 cmp	 BYTE PTR tv156[rsp], 110 ; 0000006eH
  001c7	74 1e		 je	 SHORT $LN15@s370_perfo
  001c9	eb 67		 jmp	 SHORT $LN16@s370_perfo
$LN14@s370_perfo:

; 66   :         case 0x6A: /* Add Storage Immediate */
; 67   :             /* Add signed operands and set condition code */
; 68   :             cc = add_signed (&result, n, (S32)(S8)i2);

  001cb	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  001d0	44 8b c0	 mov	 r8d, eax
  001d3	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  001d7	48 8d 4c 24 44	 lea	 rcx, QWORD PTR result$[rsp]
  001dc	e8 00 00 00 00	 call	 add_signed
  001e1	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 69   :             break;

  001e5	eb 5b		 jmp	 SHORT $LN8@s370_perfo
$LN15@s370_perfo:

; 70   :         case 0x6E: /* Add Logical Storage with Signed Immediate */
; 71   :             /* Add operands and set condition code */
; 72   :             cc = (S8)i2 < 0 ?

  001e7	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  001ec	85 c0		 test	 eax, eax
  001ee	7d 1e		 jge	 SHORT $LN23@s370_perfo
  001f0	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  001f5	f7 d8		 neg	 eax
  001f7	44 8b c0	 mov	 r8d, eax
  001fa	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  001fe	48 8d 4c 24 44	 lea	 rcx, QWORD PTR result$[rsp]
  00203	e8 00 00 00 00	 call	 sub_logical
  00208	89 44 24 5c	 mov	 DWORD PTR tv175[rsp], eax
  0020c	eb 1a		 jmp	 SHORT $LN24@s370_perfo
$LN23@s370_perfo:
  0020e	0f be 44 24 30	 movsx	 eax, BYTE PTR i2$[rsp]
  00213	44 8b c0	 mov	 r8d, eax
  00216	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0021a	48 8d 4c 24 44	 lea	 rcx, QWORD PTR result$[rsp]
  0021f	e8 00 00 00 00	 call	 add_logical
  00224	89 44 24 5c	 mov	 DWORD PTR tv175[rsp], eax
$LN24@s370_perfo:
  00228	8b 44 24 5c	 mov	 eax, DWORD PTR tv175[rsp]
  0022c	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 73   :                 sub_logical (&result, n, (S32)(-(S8)i2)) :
; 74   :                 add_logical (&result, n, (S32)(S8)i2);
; 75   :             break;

  00230	eb 10		 jmp	 SHORT $LN8@s370_perfo
$LN16@s370_perfo:

; 76   :         default: /* To prevent compiler warnings */
; 77   :             result = 0;

  00232	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 78   :             cc = 0;

  0023a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN8@s370_perfo:

; 79   :         } /* end switch(opcode) */
; 80   : 
; 81   :         /* Regular store if operand is not on a fullword boundary */
; 82   :         if ((effective_addr1 & 0x03) != 0) {

  00242	8b 44 24 34	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00246	83 e0 03	 and	 eax, 3
  00249	85 c0		 test	 eax, eax
  0024b	74 1c		 je	 SHORT $LN17@s370_perfo

; 83   :             ARCH_DEP(vstore4) (result, effective_addr1, b1, regs);

  0024d	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00255	44 8b 44 24 40	 mov	 r8d, DWORD PTR b1$[rsp]
  0025a	8b 54 24 34	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  0025e	8b 4c 24 44	 mov	 ecx, DWORD PTR result$[rsp]
  00262	e8 00 00 00 00	 call	 s370_vstore4

; 84   :             break;

  00267	eb 3f		 jmp	 SHORT $LN6@s370_perfo
$LN17@s370_perfo:

; 85   :         }
; 86   : 
; 87   :         /* Interlocked exchange if operand is on a fullword boundary */
; 88   :         old = CSWAP32(n);

  00269	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0026d	e8 00 00 00 00	 call	 _byteswap_ulong
  00272	89 44 24 64	 mov	 DWORD PTR old$[rsp], eax

; 89   :         new = CSWAP32(result);

  00276	8b 4c 24 44	 mov	 ecx, DWORD PTR result$[rsp]
  0027a	e8 00 00 00 00	 call	 _byteswap_ulong
  0027f	89 44 24 60	 mov	 DWORD PTR new$[rsp], eax

; 90   : 
; 91   :         /* MAINLOCK may be required if cmpxchg assists unavailable */
; 92   :         OBTAIN_MAINLOCK( regs );
; 93   :         {
; 94   :             rc = cmpxchg4( &old, new, m1 );

  00283	4c 8b 44 24 70	 mov	 r8, QWORD PTR m1$[rsp]
  00288	8b 54 24 60	 mov	 edx, DWORD PTR new$[rsp]
  0028c	48 8d 4c 24 64	 lea	 rcx, QWORD PTR old$[rsp]
  00291	e8 00 00 00 00	 call	 cmpxchg4_x86
  00296	0f b6 c0	 movzx	 eax, al
  00299	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 95   :         }
; 96   :         RELEASE_MAINLOCK( regs );
; 97   : 
; 98   :     } while (rc != 0);

  0029d	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  002a2	0f 85 f1 fe ff
	ff		 jne	 $LN7@s370_perfo
$LN6@s370_perfo:

; 99   : 
; 100  :     /* Set condition code in PSW */
; 101  :     regs->psw.cc = cc;

  002a8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b0	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR cc$[rsp]
  002b5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 102  : 
; 103  : } /* end DEF_INST(perform_interlocked_storage_immediate) */

  002b8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002bf	c3		 ret	 0
s370_perform_interlocked_storage_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8
_TEXT	SEGMENT
tv70 = 48
tv76 = 52
tv88 = 56
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch8 PROC					; COMDAT

; 711  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0001a	3d f8 07 00 00	 cmp	 eax, 2040		; 000007f8H
  0001f	77 0a		 ja	 SHORT $LN10@s370_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vfetc
$LN10@s370_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN11@s370_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	0f 84 9b 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );

  0003e	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00043	73 0a		 jae	 SHORT $LN14@s370_vfetc
  00045	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN15@s370_vfetc
$LN14@s370_vfetc:
  0004f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN15@s370_vfetc:
  00057	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  0005c	74 16		 je	 SHORT $LN16@s370_vfetc
  0005e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00062	83 c0 07	 add	 eax, 7
  00065	83 f8 50	 cmp	 eax, 80			; 00000050H
  00068	72 0a		 jb	 SHORT $LN16@s370_vfetc
  0006a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN22@s370_vfetc
$LN16@s370_vfetc:
  00074	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN22@s370_vfetc:
  0007c	83 7c 24 38 00	 cmp	 DWORD PTR tv88[rsp], 0
  00081	74 0a		 je	 SHORT $LN6@s370_vfetc
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	e8 00 00 00 00	 call	 s370_store_int_timer
$LN6@s370_vfetc:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00093	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00098	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0009c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000a0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000a8	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ad	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000b2	ba 08 00 00 00	 mov	 edx, 8
  000b7	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000bb	e8 00 00 00 00	 call	 s370_maddr_l
  000c0	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ca	e8 00 00 00 00	 call	 fetch_dw_noswap
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 _byteswap_uint64
  000d7	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  000d9	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000de	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  000e2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000e6	e8 00 00 00 00	 call	 s370_vfetch8_full
$LN1@s370_vfetc:

; 737  : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
s370_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch2 PROC					; COMDAT

; 679  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  0005c	0f 84 9a 00 00
	00		 je	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 15		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	ff c0		 inc	 eax
  00088	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008b	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00095	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00097	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  0009f	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a4	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 ac		 jne	 SHORT $LN4@s370_vfetc

; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000bf	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d5	ba 02 00 00 00	 mov	 edx, 2
  000da	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f2	0f b7 c8	 movzx	 ecx, ax
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch2_full
$LN1@s370_vfetc:

; 689  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchb
_TEXT	SEGMENT
tv68 = 48
tv78 = 52
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetchb PROC					; COMDAT

; 667  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_vfetc:

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );

  00011	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00016	73 0a		 jae	 SHORT $LN9@s370_vfetc
  00018	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN10@s370_vfetc:
  0002a	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  0002f	74 11		 je	 SHORT $LN11@s370_vfetc
  00031	83 7c 24 50 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00036	72 0a		 jb	 SHORT $LN11@s370_vfetc
  00038	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN17@s370_vfetc
$LN11@s370_vfetc:
  00042	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN17@s370_vfetc:
  0004a	83 7c 24 34 00	 cmp	 DWORD PTR tv78[rsp], 0
  0004f	74 0a		 je	 SHORT $LN5@s370_vfetc
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	e8 00 00 00 00	 call	 s370_store_int_timer
$LN5@s370_vfetc:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN4@s370_vfetc

; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00066	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00076	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00089	e8 00 00 00 00	 call	 s370_maddr_l
  0008e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00098	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0009b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009f	c3		 ret	 0
s370_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore8
_TEXT	SEGMENT
tv70 = 48
tv92 = 52
tv136 = 56
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore8 PROC					; COMDAT

; 577  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00017	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00020	3d f8 07 00 00	 cmp	 eax, 2040		; 000007f8H
  00025	77 0a		 ja	 SHORT $LN11@s370_vstor
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN12@s370_vstor:
  00039	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003e	74 4b		 je	 SHORT $LN5@s370_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00040	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00049	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0005a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0005f	ba 08 00 00 00	 mov	 edx, 8
  00064	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 s370_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00072	48 8b 4c 24 60	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  00084	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  00089	eb 18		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  0008b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00090	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00095	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR value$[rsp]
  0009e	e8 00 00 00 00	 call	 s370_vstore8_full
$LN6@s370_vstor:
$LN4@s370_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );

  000a3	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000a8	73 0a		 jae	 SHORT $LN15@s370_vstor
  000aa	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000b2	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@s370_vstor:
  000bc	83 7c 24 34 00	 cmp	 DWORD PTR tv92[rsp], 0
  000c1	74 16		 je	 SHORT $LN17@s370_vstor
  000c3	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000c7	83 c0 07	 add	 eax, 7
  000ca	83 f8 50	 cmp	 eax, 80			; 00000050H
  000cd	72 0a		 jb	 SHORT $LN17@s370_vstor
  000cf	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000d7	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  000d9	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN23@s370_vstor:
  000e1	83 7c 24 38 00	 cmp	 DWORD PTR tv136[rsp], 0
  000e6	74 0a		 je	 SHORT $LN7@s370_vstor
  000e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 ab		 jne	 SHORT $LN4@s370_vstor

; 612  : }

  000f8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fc	c3		 ret	 0
s370_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv92 = 56
tv136 = 60
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore4 PROC					; COMDAT

; 559  : {

$LN27:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN10@s370_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vstor
$LN10@s370_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN11@s370_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN14@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN15@s370_vstor
$LN14@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN15@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 14		 jne	 SHORT $LN7@s370_vstor
  00053	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0005c	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  00061	0f 87 9e 00 00
	00		 ja	 $LN5@s370_vstor
$LN7@s370_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00070	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00074	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00081	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_maddr_l
  00094	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00099	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  0009d	e8 00 00 00 00	 call	 _byteswap_ulong
  000a2	8b d0		 mov	 edx, eax
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a9	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@s370_vstor:

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );

  000ae	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b3	73 0a		 jae	 SHORT $LN18@s370_vstor
  000b5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000bd	eb 08		 jmp	 SHORT $LN19@s370_vstor
$LN18@s370_vstor:
  000bf	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN19@s370_vstor:
  000c7	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000cc	74 16		 je	 SHORT $LN20@s370_vstor
  000ce	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000d2	83 c0 03	 add	 eax, 3
  000d5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d8	72 0a		 jb	 SHORT $LN20@s370_vstor
  000da	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000e2	eb 08		 jmp	 SHORT $LN26@s370_vstor
$LN20@s370_vstor:
  000e4	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN26@s370_vstor:
  000ec	83 7c 24 3c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000f1	74 0a		 je	 SHORT $LN8@s370_vstor
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN8@s370_vstor:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 ab		 jne	 SHORT $LN4@s370_vstor

; 568  :     }

  00103	eb 17		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  00105	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0010a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00113	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  00117	e8 00 00 00 00	 call	 s370_vstore4_full
$LN6@s370_vstor:

; 571  : }

  0011c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00120	c3		 ret	 0
s370_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2
_TEXT	SEGMENT
tv73 = 48
tv91 = 52
tv135 = 56
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2 PROC					; COMDAT

; 541  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00017	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 1a		 je	 SHORT $LN9@s370_vstor
  00022	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00030	75 0a		 jne	 SHORT $LN9@s370_vstor
  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0003a	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN9@s370_vstor:
  0003c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN12@s370_vstor:
  00044	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00049	0f 84 9f 00 00
	00		 je	 $LN5@s370_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0004f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00054	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00058	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00069	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	ba 02 00 00 00	 mov	 edx, 2
  00073	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  00077	e8 00 00 00 00	 call	 s370_maddr_l
  0007c	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  00081	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00086	e8 00 00 00 00	 call	 _byteswap_ushort
  0008b	0f b7 d0	 movzx	 edx, ax
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  00093	e8 00 00 00 00	 call	 store_hw_noswap
$LN4@s370_vstor:

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );

  00098	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0009d	73 0a		 jae	 SHORT $LN15@s370_vstor
  0009f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000a7	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000a9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN16@s370_vstor:
  000b1	83 7c 24 34 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b6	74 15		 je	 SHORT $LN17@s370_vstor
  000b8	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000bc	ff c0		 inc	 eax
  000be	83 f8 50	 cmp	 eax, 80			; 00000050H
  000c1	72 0a		 jb	 SHORT $LN17@s370_vstor
  000c3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  000cd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN23@s370_vstor:
  000d5	83 7c 24 38 00	 cmp	 DWORD PTR tv135[rsp], 0
  000da	74 0a		 je	 SHORT $LN7@s370_vstor
  000dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 ac		 jne	 SHORT $LN4@s370_vstor

; 550  :     }

  000ec	eb 18		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  000ee	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  000f3	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  000fc	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00101	e8 00 00 00 00	 call	 s370_vstore2_full
$LN6@s370_vstor:

; 553  : }

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	c3		 ret	 0
s370_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstoreb
_TEXT	SEGMENT
tv76 = 48
tv86 = 52
main1$ = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s370_vstoreb PROC					; COMDAT

; 529  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l
  00043	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl
$LN4@s370_vstor:

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );

  00054	83 7c 24 58 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00059	73 0a		 jae	 SHORT $LN9@s370_vstor
  0005b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN10@s370_vstor
$LN9@s370_vstor:
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN10@s370_vstor:
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00072	74 11		 je	 SHORT $LN11@s370_vstor
  00074	83 7c 24 58 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00079	72 0a		 jb	 SHORT $LN11@s370_vstor
  0007b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00083	eb 08		 jmp	 SHORT $LN17@s370_vstor
$LN11@s370_vstor:
  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN17@s370_vstor:
  0008d	83 7c 24 34 00	 cmp	 DWORD PTR tv86[rsp], 0
  00092	74 0a		 je	 SHORT $LN5@s370_vstor
  00094	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN5@s370_vstor:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b0		 jne	 SHORT $LN4@s370_vstor

; 535  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
s370_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002e	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s370_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000b3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bf	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d3	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000e8	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f5	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  000fa	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  000ff	e8 00 00 00 00	 call	 fetch_dw_noswap
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s370_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 s370_maddr_l
  00089	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00096	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  0009b	0b c8		 or	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000a4	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
s370_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
s370_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0002f	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00034	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00052	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00056	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00066	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 s370_maddr_l
  0007d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00091	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009f	48 98		 cdqe
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000ac	03 d1		 add	 edx, ecx
  000ae	8b ca		 mov	 ecx, edx
  000b0	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000b6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ce	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d6	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000de	48 8b d0	 mov	 rdx, rax
  000e1	e8 00 00 00 00	 call	 s370_maddr_l
  000e6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f3	83 c8 06	 or	 eax, 6
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000fb	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  000fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00105	e8 00 00 00 00	 call	 _byteswap_uint64
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  00117	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0011c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00121	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00126	48 8b f1	 mov	 rsi, rcx
  00129	48 8b c8	 mov	 rcx, rax
  0012c	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  0012e	b8 08 00 00 00	 mov	 eax, 8
  00133	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00137	48 98		 cdqe
  00139	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  0013e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00143	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00148	48 8b f1	 mov	 rsi, rcx
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	f3 a4		 rep movsb

; 384  : }

  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00155	48 33 cc	 xor	 rcx, rsp
  00158	e8 00 00 00 00	 call	 __security_check_cookie
  0015d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00161	5f		 pop	 rdi
  00162	5e		 pop	 rsi
  00163	c3		 ret	 0
s370_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s370_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00021	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s370_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0009d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000a9	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ad	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000bd	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	e8 00 00 00 00	 call	 s370_maddr_l
  000cd	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	83 c8 06	 or	 eax, 6
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000e2	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000e4	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000f4	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  000f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000fe	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00103	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00108	48 8b f1	 mov	 rsi, rcx
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00119	48 98		 cdqe
  0011b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00120	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00125	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0012a	48 8b f1	 mov	 rsi, rcx
  0012d	48 8b c8	 mov	 rcx, rax
  00130	f3 a4		 rep movsb

; 350  : }

  00132	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
s370_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0003f	e8 00 00 00 00	 call	 s370_maddr_l
  00044	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  00049	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00055	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005a	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0005e	ff c0		 inc	 eax
  00060	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00065	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0006e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 01 00 00 00	 mov	 edx, 1
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 s370_maddr_l
  00090	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  0009a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009d	83 c8 06	 or	 eax, 6
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000a5	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000a7	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000ac	c1 f8 08	 sar	 eax, 8
  000af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000b4	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000b6	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000c5	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000c7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000cb	c3		 ret	 0
s370_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_signed_long
_TEXT	SEGMENT
tv74 = 0
tv75 = 4
tv76 = 8
sop2$ = 16
sop1$ = 24
sres$ = 32
result$ = 64
op1$ = 72
op2$ = 80
sub_signed_long PROC					; COMDAT

; 253  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 254  :     S64 sres, sop1, sop2;
; 255  : 
; 256  :     /* NOTE: cannot use casting here as signed fixed point overflow
; 257  :        leads to undefined behavior! (whereas unsigned doesn't)
; 258  :     */
; 259  :     *result = op1 - op2;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 2b c8	 sub	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 260  : 
; 261  :     sres = (S64) *result;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 20	 mov	 QWORD PTR sres$[rsp], rax

; 262  :     sop1 = (S64) op1;

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR op1$[rsp]
  0003d	48 89 44 24 18	 mov	 QWORD PTR sop1$[rsp], rax

; 263  :     sop2 = (S64) op2;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR sop2$[rsp], rax

; 264  : 
; 265  :     return

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 83 00 00
	00		 jne	 $LN4@sub_signed
  00056	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  0005c	7d 1c		 jge	 SHORT $LN3@sub_signed
  0005e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00068	48 8b 4c 24 10	 mov	 rcx, QWORD PTR sop2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  00078	7f 5f		 jg	 SHORT $LN4@sub_signed
$LN3@sub_signed:
  0007a	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00080	7e 1c		 jle	 SHORT $LN5@sub_signed
  00082	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0008c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR sop2$[rsp]
  00091	48 2b c8	 sub	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0009c	7c 3b		 jl	 SHORT $LN4@sub_signed
$LN5@sub_signed:
  0009e	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000a4	7d 0a		 jge	 SHORT $LN8@sub_signed
  000a6	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  000ae	eb 1f		 jmp	 SHORT $LN9@sub_signed
$LN8@sub_signed:
  000b0	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000b6	7e 09		 jle	 SHORT $LN6@sub_signed
  000b8	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv74[rsp], 2
  000bf	eb 07		 jmp	 SHORT $LN7@sub_signed
$LN6@sub_signed:
  000c1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN7@sub_signed:
  000c8	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]
  000cb	89 44 24 04	 mov	 DWORD PTR tv75[rsp], eax
$LN9@sub_signed:
  000cf	8b 44 24 04	 mov	 eax, DWORD PTR tv75[rsp]
  000d3	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  000d7	eb 08		 jmp	 SHORT $LN10@sub_signed
$LN4@sub_signed:
  000d9	c7 44 24 08 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@sub_signed:
  000e1	8b 44 24 08	 mov	 eax, DWORD PTR tv76[rsp]

; 266  :     (0
; 267  :         || (sop2 < 0 && sop1 > (LLONG_MAX + sop2))
; 268  :         || (sop2 > 0 && sop1 < (LLONG_MIN + sop2))
; 269  :     )
; 270  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 271  : }

  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
sub_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_signed_long
_TEXT	SEGMENT
tv74 = 0
tv75 = 4
tv76 = 8
sop2$ = 16
sop1$ = 24
sres$ = 32
result$ = 64
op1$ = 72
op2$ = 80
add_signed_long PROC					; COMDAT

; 228  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 229  :     S64 sres, sop1, sop2;
; 230  : 
; 231  :     /* NOTE: cannot use casting here as signed fixed point overflow
; 232  :        leads to undefined behavior! (whereas unsigned doesn't)
; 233  :     */
; 234  :     *result = op1 + op2;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 03 c8	 add	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 235  : 
; 236  :     sres = (S64) *result;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 20	 mov	 QWORD PTR sres$[rsp], rax

; 237  :     sop1 = (S64) op1;

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR op1$[rsp]
  0003d	48 89 44 24 18	 mov	 QWORD PTR sop1$[rsp], rax

; 238  :     sop2 = (S64) op2;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR sop2$[rsp], rax

; 239  : 
; 240  :     return

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 77		 jne	 SHORT $LN4@add_signed
  00052	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00058	7e 16		 jle	 SHORT $LN3@add_signed
  0005a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00064	48 2b 44 24 10	 sub	 rax, QWORD PTR sop2$[rsp]
  00069	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0006e	7f 59		 jg	 SHORT $LN4@add_signed
$LN3@add_signed:
  00070	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00076	7d 16		 jge	 SHORT $LN5@add_signed
  00078	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00082	48 2b 44 24 10	 sub	 rax, QWORD PTR sop2$[rsp]
  00087	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0008c	7c 3b		 jl	 SHORT $LN4@add_signed
$LN5@add_signed:
  0008e	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  00094	7d 0a		 jge	 SHORT $LN8@add_signed
  00096	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0009e	eb 1f		 jmp	 SHORT $LN9@add_signed
$LN8@add_signed:
  000a0	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000a6	7e 09		 jle	 SHORT $LN6@add_signed
  000a8	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv74[rsp], 2
  000af	eb 07		 jmp	 SHORT $LN7@add_signed
$LN6@add_signed:
  000b1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN7@add_signed:
  000b8	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]
  000bb	89 44 24 04	 mov	 DWORD PTR tv75[rsp], eax
$LN9@add_signed:
  000bf	8b 44 24 04	 mov	 eax, DWORD PTR tv75[rsp]
  000c3	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  000c7	eb 08		 jmp	 SHORT $LN10@add_signed
$LN4@add_signed:
  000c9	c7 44 24 08 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@add_signed:
  000d1	8b 44 24 08	 mov	 eax, DWORD PTR tv76[rsp]

; 241  :     (0
; 242  :         || (sop2 > 0 && sop1 > (LLONG_MAX - sop2))
; 243  :         || (sop2 < 0 && sop1 < (LLONG_MIN - sop2))
; 244  :     )
; 245  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 246  : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
add_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_logical_long
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
sub_logical_long PROC					; COMDAT

; 218  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 219  :     *result = op1 - op2;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 2b c8	 sub	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 220  :     return (*result == 0 ? 0 : 1) | (op1 < *result ? 0 : 2);

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 0a		 jne	 SHORT $LN3@sub_logica
  00036	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  0003e	eb 08		 jmp	 SHORT $LN4@sub_logica
$LN3@sub_logica:
  00040	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@sub_logica:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 39 44 24 28	 cmp	 QWORD PTR op1$[rsp], rax
  00055	73 09		 jae	 SHORT $LN5@sub_logica
  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
  0005e	eb 07		 jmp	 SHORT $LN6@sub_logica
$LN5@sub_logica:
  00060	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
$LN6@sub_logica:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  0006e	0b c8		 or	 ecx, eax
  00070	8b c1		 mov	 eax, ecx

; 221  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
sub_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_logical_long
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
add_logical_long PROC					; COMDAT

; 208  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 209  :     *result = op1 + op2;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 03 c8	 add	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 210  :     return (*result == 0 ? 0 : 1) | (op1 > *result ? 2 : 0);

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 0a		 jne	 SHORT $LN3@add_logica
  00036	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  0003e	eb 08		 jmp	 SHORT $LN4@add_logica
$LN3@add_logica:
  00040	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@add_logica:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 39 44 24 28	 cmp	 QWORD PTR op1$[rsp], rax
  00055	76 09		 jbe	 SHORT $LN5@add_logica
  00057	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
  0005e	eb 07		 jmp	 SHORT $LN6@add_logica
$LN5@add_logica:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@add_logica:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  0006e	0b c8		 or	 ecx, eax
  00070	8b c1		 mov	 eax, ecx

; 211  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
add_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_signed_long
_TEXT	SEGMENT
resulthi$ = 48
resultlo$ = 56
op1$ = 64
op2$ = 72
mul_signed_long PROC					; COMDAT

; 147  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 148  :     mul_unsigned_long( (U64*)resulthi, (U64*)resultlo,

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR op2$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR resultlo$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0002c	e8 00 00 00 00	 call	 mul_unsigned_long

; 149  :                        (U64) op1,      (U64) op2 );
; 150  : 
; 151  :     if (op1 < 0LL)  *resulthi  -=  op2;

  00031	48 83 7c 24 40
	00		 cmp	 QWORD PTR op1$[rsp], 0
  00037	7d 18		 jge	 SHORT $LN2@mul_signed
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR resulthi$[rsp]
  0003e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 2b c1	 sub	 rax, rcx
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN2@mul_signed:

; 152  :     if (op2 < 0LL)  *resulthi  -=  op1;

  00051	48 83 7c 24 48
	00		 cmp	 QWORD PTR op2$[rsp], 0
  00057	7d 18		 jge	 SHORT $LN3@mul_signed
  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR resulthi$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 2b c1	 sub	 rax, rcx
  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0006e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@mul_signed:

; 153  : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
mul_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_unsigned_long
_TEXT	SEGMENT
cy$ = 0
p1$ = 8
p2$ = 16
a_lo$ = 24
b_lo$ = 32
a_hi$ = 40
b_hi$ = 48
p0$ = 56
p3$ = 64
resulthi$ = 96
resultlo$ = 104
op1$ = 112
op2$ = 120
mul_unsigned_long PROC					; COMDAT

; 125  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 126  :     U64  a_lo  =  (U64)(U32)op1;

  00018	8b 44 24 70	 mov	 eax, DWORD PTR op1$[rsp]
  0001c	48 89 44 24 18	 mov	 QWORD PTR a_lo$[rsp], rax

; 127  :     U64  a_hi  =  op1 >> 32;

  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR op1$[rsp]
  00026	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0002a	48 89 44 24 28	 mov	 QWORD PTR a_hi$[rsp], rax

; 128  :     U64  b_lo  =  (U64)(U32)op2;

  0002f	8b 44 24 78	 mov	 eax, DWORD PTR op2$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR b_lo$[rsp], rax

; 129  :     U64  b_hi  =  op2 >> 32;

  00038	48 8b 44 24 78	 mov	 rax, QWORD PTR op2$[rsp]
  0003d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00041	48 89 44 24 30	 mov	 QWORD PTR b_hi$[rsp], rax

; 130  : 
; 131  :     U64  p0    =  a_lo * b_lo;

  00046	48 8b 44 24 18	 mov	 rax, QWORD PTR a_lo$[rsp]
  0004b	48 0f af 44 24
	20		 imul	 rax, QWORD PTR b_lo$[rsp]
  00051	48 89 44 24 38	 mov	 QWORD PTR p0$[rsp], rax

; 132  :     U64  p1    =  a_lo * b_hi;

  00056	48 8b 44 24 18	 mov	 rax, QWORD PTR a_lo$[rsp]
  0005b	48 0f af 44 24
	30		 imul	 rax, QWORD PTR b_hi$[rsp]
  00061	48 89 44 24 08	 mov	 QWORD PTR p1$[rsp], rax

; 133  :     U64  p2    =  a_hi * b_lo;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR a_hi$[rsp]
  0006b	48 0f af 44 24
	20		 imul	 rax, QWORD PTR b_lo$[rsp]
  00071	48 89 44 24 10	 mov	 QWORD PTR p2$[rsp], rax

; 134  :     U64  p3    =  a_hi * b_hi;

  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR a_hi$[rsp]
  0007b	48 0f af 44 24
	30		 imul	 rax, QWORD PTR b_hi$[rsp]
  00081	48 89 44 24 40	 mov	 QWORD PTR p3$[rsp], rax

; 135  : 
; 136  :     U32  cy    =  (U32)(((p0 >> 32) + (U32)p1 + (U32)p2) >> 32);

  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR p0$[rsp]
  0008b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0008f	8b 4c 24 08	 mov	 ecx, DWORD PTR p1$[rsp]
  00093	48 03 c1	 add	 rax, rcx
  00096	8b 4c 24 10	 mov	 ecx, DWORD PTR p2$[rsp]
  0009a	48 03 c1	 add	 rax, rcx
  0009d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000a1	89 04 24	 mov	 DWORD PTR cy$[rsp], eax

; 137  : 
; 138  :     *resultlo  =  p0 + (p1 << 32) + (p2 << 32);

  000a4	48 8b 44 24 08	 mov	 rax, QWORD PTR p1$[rsp]
  000a9	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p0$[rsp]
  000b2	48 03 c8	 add	 rcx, rax
  000b5	48 8b c1	 mov	 rax, rcx
  000b8	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p2$[rsp]
  000bd	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  000c1	48 03 c1	 add	 rax, rcx
  000c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR resultlo$[rsp]
  000c9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 139  :     *resulthi  =  p3 + (p1 >> 32) + (p2 >> 32) + cy;

  000cc	48 8b 44 24 08	 mov	 rax, QWORD PTR p1$[rsp]
  000d1	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p3$[rsp]
  000da	48 03 c8	 add	 rcx, rax
  000dd	48 8b c1	 mov	 rax, rcx
  000e0	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p2$[rsp]
  000e5	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  000e9	48 03 c1	 add	 rax, rcx
  000ec	8b 0c 24	 mov	 ecx, DWORD PTR cy$[rsp]
  000ef	48 03 c1	 add	 rax, rcx
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR resulthi$[rsp]
  000f7	48 89 01	 mov	 QWORD PTR [rcx], rax

; 140  : }

  000fa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fe	c3		 ret	 0
mul_unsigned_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_signed
_TEXT	SEGMENT
r$ = 0
resulthi$ = 32
resultlo$ = 40
op1$ = 48
op2$ = 56
mul_signed PROC						; COMDAT

; 114  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 115  :     S64 r = (S64)(S32)op1 * (S32)op2;

  00018	48 63 44 24 30	 movsxd	 rax, DWORD PTR op1$[rsp]
  0001d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR op2$[rsp]
  00022	48 0f af c1	 imul	 rax, rcx
  00026	48 89 04 24	 mov	 QWORD PTR r$[rsp], rax

; 116  :     *resulthi = (U32)((U64)r >> 32);

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR r$[rsp]
  0002e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR resulthi$[rsp]
  00037	89 01		 mov	 DWORD PTR [rcx], eax

; 117  :     *resultlo = (U32)((U64)r & 0xFFFFFFFF);

  00039	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003e	48 8b 0c 24	 mov	 rcx, QWORD PTR r$[rsp]
  00042	48 23 c8	 and	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR resultlo$[rsp]
  0004d	89 01		 mov	 DWORD PTR [rcx], eax

; 118  : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
mul_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_signed
_TEXT	SEGMENT
sop2$ = 0
sop1$ = 4
sres$ = 8
tv74 = 12
tv75 = 16
tv76 = 20
result$ = 48
op1$ = 56
op2$ = 64
sub_signed PROC						; COMDAT

; 90   : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 91   :     S32 sres, sop1, sop2;
; 92   : 
; 93   :     /* NOTE: cannot use casting here as signed fixed point overflow
; 94   :        leads to undefined behavior! (whereas unsigned doesn't)
; 95   :     */
; 96   :     *result = op1 - op2;

  00012	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	2b c8		 sub	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 97   : 
; 98   :     sres = (S32) *result;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	89 44 24 08	 mov	 DWORD PTR sres$[rsp], eax

; 99   :     sop1 = (S32) op1;

  00030	8b 44 24 38	 mov	 eax, DWORD PTR op1$[rsp]
  00034	89 44 24 04	 mov	 DWORD PTR sop1$[rsp], eax

; 100  :     sop2 = (S32) op2;

  00038	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  0003c	89 04 24	 mov	 DWORD PTR sop2$[rsp], eax

; 101  : 
; 102  :     return

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 64		 jne	 SHORT $LN4@sub_signed
  00045	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  00049	7d 0e		 jge	 SHORT $LN3@sub_signed
  0004b	8b 04 24	 mov	 eax, DWORD PTR sop2$[rsp]
  0004e	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
  00053	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  00057	7f 50		 jg	 SHORT $LN4@sub_signed
$LN3@sub_signed:
  00059	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  0005d	7e 0e		 jle	 SHORT $LN5@sub_signed
  0005f	8b 04 24	 mov	 eax, DWORD PTR sop2$[rsp]
  00062	2d 00 00 00 80	 sub	 eax, -2147483648	; ffffffff80000000H
  00067	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  0006b	7c 3c		 jl	 SHORT $LN4@sub_signed
$LN5@sub_signed:
  0006d	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00072	7d 0a		 jge	 SHORT $LN8@sub_signed
  00074	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007c	eb 21		 jmp	 SHORT $LN9@sub_signed
$LN8@sub_signed:
  0007e	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00083	7e 0a		 jle	 SHORT $LN6@sub_signed
  00085	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0008d	eb 08		 jmp	 SHORT $LN7@sub_signed
$LN6@sub_signed:
  0008f	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN7@sub_signed:
  00097	8b 44 24 0c	 mov	 eax, DWORD PTR tv74[rsp]
  0009b	89 44 24 10	 mov	 DWORD PTR tv75[rsp], eax
$LN9@sub_signed:
  0009f	8b 44 24 10	 mov	 eax, DWORD PTR tv75[rsp]
  000a3	89 44 24 14	 mov	 DWORD PTR tv76[rsp], eax
  000a7	eb 08		 jmp	 SHORT $LN10@sub_signed
$LN4@sub_signed:
  000a9	c7 44 24 14 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@sub_signed:
  000b1	8b 44 24 14	 mov	 eax, DWORD PTR tv76[rsp]

; 103  :     (0
; 104  :         || (sop2 < 0 && sop1 > (INT_MAX + sop2))
; 105  :         || (sop2 > 0 && sop1 < (INT_MIN + sop2))
; 106  :     )
; 107  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 108  : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
sub_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_signed
_TEXT	SEGMENT
sop2$ = 0
sop1$ = 4
sres$ = 8
tv74 = 12
tv75 = 16
tv76 = 20
result$ = 48
op1$ = 56
op2$ = 64
add_signed PROC						; COMDAT

; 65   : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 66   :     S32 sres, sop1, sop2;
; 67   : 
; 68   :     /* NOTE: cannot use casting here as signed fixed point overflow
; 69   :        leads to undefined behavior! (whereas unsigned doesn't)
; 70   :     */
; 71   :     *result = op1 + op2;

  00012	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	03 c8		 add	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 72   : 
; 73   :     sres = (S32) *result;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	89 44 24 08	 mov	 DWORD PTR sres$[rsp], eax

; 74   :     sop1 = (S32) op1;

  00030	8b 44 24 38	 mov	 eax, DWORD PTR op1$[rsp]
  00034	89 44 24 04	 mov	 DWORD PTR sop1$[rsp], eax

; 75   :     sop2 = (S32) op2;

  00038	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  0003c	89 04 24	 mov	 DWORD PTR sop2$[rsp], eax

; 76   : 
; 77   :     return

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 64		 jne	 SHORT $LN4@add_signed
  00045	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  00049	7e 0e		 jle	 SHORT $LN3@add_signed
  0004b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00050	2b 04 24	 sub	 eax, DWORD PTR sop2$[rsp]
  00053	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  00057	7f 50		 jg	 SHORT $LN4@add_signed
$LN3@add_signed:
  00059	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  0005d	7d 0e		 jge	 SHORT $LN5@add_signed
  0005f	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00064	2b 04 24	 sub	 eax, DWORD PTR sop2$[rsp]
  00067	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  0006b	7c 3c		 jl	 SHORT $LN4@add_signed
$LN5@add_signed:
  0006d	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00072	7d 0a		 jge	 SHORT $LN8@add_signed
  00074	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007c	eb 21		 jmp	 SHORT $LN9@add_signed
$LN8@add_signed:
  0007e	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00083	7e 0a		 jle	 SHORT $LN6@add_signed
  00085	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0008d	eb 08		 jmp	 SHORT $LN7@add_signed
$LN6@add_signed:
  0008f	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN7@add_signed:
  00097	8b 44 24 0c	 mov	 eax, DWORD PTR tv74[rsp]
  0009b	89 44 24 10	 mov	 DWORD PTR tv75[rsp], eax
$LN9@add_signed:
  0009f	8b 44 24 10	 mov	 eax, DWORD PTR tv75[rsp]
  000a3	89 44 24 14	 mov	 DWORD PTR tv76[rsp], eax
  000a7	eb 08		 jmp	 SHORT $LN10@add_signed
$LN4@add_signed:
  000a9	c7 44 24 14 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@add_signed:
  000b1	8b 44 24 14	 mov	 eax, DWORD PTR tv76[rsp]

; 78   :     (0
; 79   :         || (sop2 > 0 && sop1 > (INT_MAX - sop2))
; 80   :         || (sop2 < 0 && sop1 < (INT_MIN - sop2))
; 81   :     )
; 82   :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 83   : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
add_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_logical
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
sub_logical PROC					; COMDAT

; 55   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 56   :     *result = op1 - op2;

  00012	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 28	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	2b c8		 sub	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 57   :     return (*result == 0 ? 0 : 1) | (op1 < *result ? 0 : 2);

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002d	75 0a		 jne	 SHORT $LN3@sub_logica
  0002f	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  00037	eb 08		 jmp	 SHORT $LN4@sub_logica
$LN3@sub_logica:
  00039	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@sub_logica:
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	39 44 24 28	 cmp	 DWORD PTR op1$[rsp], eax
  0004c	73 09		 jae	 SHORT $LN5@sub_logica
  0004e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
  00055	eb 07		 jmp	 SHORT $LN6@sub_logica
$LN5@sub_logica:
  00057	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
$LN6@sub_logica:
  0005e	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  00065	0b c8		 or	 ecx, eax
  00067	8b c1		 mov	 eax, ecx

; 58   : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
sub_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_logical
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
add_logical PROC					; COMDAT

; 45   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 46   :     *result = op1 + op2;

  00012	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 28	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	03 c8		 add	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 47   :     return (*result == 0 ? 0 : 1) | (op1 > *result ? 2 : 0);

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002d	75 0a		 jne	 SHORT $LN3@add_logica
  0002f	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  00037	eb 08		 jmp	 SHORT $LN4@add_logica
$LN3@add_logica:
  00039	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@add_logica:
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	39 44 24 28	 cmp	 DWORD PTR op1$[rsp], eax
  0004c	76 09		 jbe	 SHORT $LN5@add_logica
  0004e	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
  00055	eb 07		 jmp	 SHORT $LN6@add_logica
$LN5@add_logica:
  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@add_logica:
  0005e	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  00065	0b c8		 or	 ecx, eax
  00067	8b c1		 mov	 eax, ecx

; 48   : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
add_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT cmpxchg4_x86
_TEXT	SEGMENT
tv69 = 0
tv71 = 4
tmp$ = 8
old$ = 32
unew$ = 40
ptr$ = 48
cmpxchg4_x86 PROC					; COMDAT

; 104  :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 105  :         // returns 0 == success, 1 otherwise
; 106  :         U32 tmp = *old;

  00012	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
  00019	89 44 24 08	 mov	 DWORD PTR tmp$[rsp], eax

; 107  :         *old = _InterlockedCompareExchange( ptr, unew, *old );

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR unew$[rsp]
  00021	89 44 24 04	 mov	 DWORD PTR tv71[rsp], eax
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0002a	48 8b 54 24 20	 mov	 rdx, QWORD PTR old$[rsp]
  0002f	8b 02		 mov	 eax, DWORD PTR [rdx]
  00031	8b 54 24 04	 mov	 edx, DWORD PTR tv71[rsp]
  00035	f0 0f b1 11	 lock cmpxchg DWORD PTR [rcx], edx
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old$[rsp]
  0003e	89 01		 mov	 DWORD PTR [rcx], eax

; 108  :         return ((tmp == *old) ? 0 : 1);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	39 44 24 08	 cmp	 DWORD PTR tmp$[rsp], eax
  0004b	75 09		 jne	 SHORT $LN3@cmpxchg4_x
  0004d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
  00054	eb 07		 jmp	 SHORT $LN4@cmpxchg4_x
$LN3@cmpxchg4_x:
  00056	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
$LN4@cmpxchg4_x:
  0005d	0f b6 04 24	 movzx	 eax, BYTE PTR tv69[rsp]

; 109  :     }

  00061	48 83 c4 18	 add	 rsp, 24
  00065	c3		 ret	 0
cmpxchg4_x86 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT cmpxchg8_x86
_TEXT	SEGMENT
tv69 = 0
tv71 = 8
tmp$ = 16
old$ = 48
unew$ = 56
ptr$ = 64
cmpxchg8_x86 PROC					; COMDAT

; 97   :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 98   :         // returns 0 == success, 1 otherwise
; 99   :         U64 tmp = *old;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR old$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 10	 mov	 QWORD PTR tmp$[rsp], rax

; 100  :         *old = _InterlockedCompareExchange64( ptr, unew, *old );

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR unew$[rsp]
  00025	48 89 44 24 08	 mov	 QWORD PTR tv71[rsp], rax
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$[rsp]
  0002f	48 8b 54 24 30	 mov	 rdx, QWORD PTR old$[rsp]
  00034	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00037	48 8b 54 24 08	 mov	 rdx, QWORD PTR tv71[rsp]
  0003c	f0 48 0f b1 11	 lock cmpxchg QWORD PTR [rcx], rdx
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old$[rsp]
  00046	48 89 01	 mov	 QWORD PTR [rcx], rax

; 101  :         return ((tmp == *old) ? 0 : 1);

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR old$[rsp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 39 44 24 10	 cmp	 QWORD PTR tmp$[rsp], rax
  00056	75 09		 jne	 SHORT $LN3@cmpxchg8_x
  00058	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
  0005f	eb 07		 jmp	 SHORT $LN4@cmpxchg8_x
$LN3@cmpxchg8_x:
  00061	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
$LN4@cmpxchg8_x:
  00068	0f b6 04 24	 movzx	 eax, BYTE PTR tv69[rsp]

; 102  :     }

  0006c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00070	c3		 ret	 0
cmpxchg8_x86 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
m3$ = 32
temp$1 = 36
i$ = 40
tv129 = 44
result$ = 48
r2$ = 56
r1$ = 60
n$ = 64
mask$ = 72
inst$ = 96
regs$ = 104
s370_population_count PROC

; 3977 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3978 : BYTE    m3;                             /* Optional m3 mask field    */
; 3979 : int     r1, r2;                         /* Values of R fields        */
; 3980 : int     i;                              /* Loop counter              */
; 3981 : U64     n;                              /* Contents of R2 register   */
; 3982 : U64     result = 0;                     /* Result counter            */

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3983 : U64     mask = 0x0101010101010101ULL;   /* Bit mask                  */

  00017	48 b8 01 01 01
	01 01 01 01 01	 mov	 rax, 72340172838076673	; 0101010101010101H
  00021	48 89 44 24 48	 mov	 QWORD PTR mask$[rsp], rax

; 3984 : 
; 3985 :     RRF_M( inst, regs, r1, r2, m3 );

  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	88 44 24 20	 mov	 BYTE PTR m3$[rsp], al
$LN4@s370_popul:
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 04	 add	 rax, 4
  0006f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 0c		 je	 SHORT $LN8@s370_popul
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_popul:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@s370_popul

; 3986 : 
; 3987 :     /* Load the value to be counted from the R2 register */
; 3988 :     n = regs->GR_G(r2);

  00091	48 63 44 24 38	 movsxd	 rax, DWORD PTR r2$[rsp]
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a3	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 3989 : 
; 3990 : #if defined( FEATURE_061_MISC_INSTR_EXT_FACILITY_3 )
; 3991 : 
; 3992 :     if (FACILITY_ENABLED( 061_MISC_INSTR_EXT_3, regs ) && (m3 & 0x08))
; 3993 :     {
; 3994 :         /* The following algorithm works best when most bits are 0
; 3995 :            and works the same for all data sizes, using 3 arithmetic
; 3996 :            operations and 1 comparison/branch per "1" bit.
; 3997 :         */
; 3998 :         for (; n; result++)
; 3999 :             n &= n - 1;
; 4000 : 
; 4001 :         /* Load the result into the R1 register */
; 4002 :         regs->GR_G(r1) = result;
; 4003 : 
; 4004 :         /* Set condition code 0 if result is zero, or 1 if non-zero */
; 4005 :         regs->psw.cc = (result == 0) ? 0 : 1;
; 4006 :         return;
; 4007 :     }
; 4008 : 
; 4009 : #endif /* defined( FEATURE_061_MISC_INSTR_EXT_FACILITY_3 ) */
; 4010 : 
; 4011 :     /* Count the number of 1 bits in each byte */
; 4012 :     for (i=0; i < 8; i++)

  000a8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b0	eb 0a		 jmp	 SHORT $LN7@s370_popul
$LN5@s370_popul:
  000b2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000b6	ff c0		 inc	 eax
  000b8	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_popul:
  000bc	83 7c 24 28 08	 cmp	 DWORD PTR i$[rsp], 8
  000c1	7d 2f		 jge	 SHORT $LN6@s370_popul

; 4013 :     {
; 4014 :         result += n & mask;

  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR mask$[rsp]
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  000cd	48 23 c8	 and	 rcx, rax
  000d0	48 8b c1	 mov	 rax, rcx
  000d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000d8	48 03 c8	 add	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4015 :         n >>= 1;

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  000e8	48 d1 e8	 shr	 rax, 1
  000eb	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 4016 :     }

  000f0	eb c0		 jmp	 SHORT $LN5@s370_popul
$LN6@s370_popul:

; 4017 : 
; 4018 :     /* Load the result into the R1 register */
; 4019 :     regs->GR_G(r1) = result;

  000f2	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	48 8b 54 24 30	 mov	 rdx, QWORD PTR result$[rsp]
  00101	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4020 : 
; 4021 :     /* Set condition code 0 if result is zero, or 1 if non-zero */
; 4022 :     regs->psw.cc = (result == 0) ? 0 : 1;

  00109	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  0010f	75 0a		 jne	 SHORT $LN10@s370_popul
  00111	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  00119	eb 08		 jmp	 SHORT $LN11@s370_popul
$LN10@s370_popul:
  0011b	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
$LN11@s370_popul:
  00123	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv129[rsp]
  0012d	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4023 : 
; 4024 : } /* end DEF_INST(population_count) */

  00130	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00134	c3		 ret	 0
s370_population_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
tv92 = 48
tv194 = 52
m3$ = 56
r1$ = 60
inst$ = 80
regs$ = 88
s370_store_on_condition PROC

; 3356 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3357 : int     r1;                             /* Value of R field          */
; 3358 : int     m3;                             /* Value of M field          */
; 3359 : int     b2;                             /* Base of effective addr    */
; 3360 : VADR    effective_addr2;                /* Effective address         */
; 3361 : 
; 3362 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN5@s370_store
  00069	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_store:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN14@s370_store
  0009c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000a6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@s370_store:
  000ae	83 7c 24 30 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN6@s370_store
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN7@s370_store
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@s370_store:
$LN6@s370_store:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN8@s370_store
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_store:
$LN4@s370_store:
  00114	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN9@s370_store
  00131	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_store:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_store

; 3363 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 3364 : 
; 3365 :     /* Test M3 mask bit corresponding to condition code */
; 3366 :     if (m3 & (0x08 >> regs->psw.cc))

  00143	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00148	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	89 4c 24 34	 mov	 DWORD PTR tv194[rsp], ecx
  00155	0f b6 c8	 movzx	 ecx, al
  00158	8b 44 24 34	 mov	 eax, DWORD PTR tv194[rsp]
  0015c	d3 f8		 sar	 eax, cl
  0015e	8b 4c 24 38	 mov	 ecx, DWORD PTR m3$[rsp]
  00162	23 c8		 and	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	85 c0		 test	 eax, eax
  00168	74 24		 je	 SHORT $LN10@s370_store

; 3367 :     {
; 3368 :         /* Store R1 register bits 32-63 at operand address */
; 3369 :         ARCH_DEP(vstore4) ( regs->GR_L(r1), effective_addr2, b2, regs );

  0016a	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016f	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  00174	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00179	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00189	e8 00 00 00 00	 call	 s370_vstore4
$LN10@s370_store:

; 3370 :     }
; 3371 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 3372 :     else
; 3373 :         /* TXF requires storage reference regardless of cc */
; 3374 :         MADDRL( effective_addr2, 4, b2, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );
; 3375 : #endif
; 3376 : }

  0018e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00192	c3		 ret	 0
s370_store_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
tv92 = 48
tv196 = 52
m3$ = 56
r1$ = 60
data$ = 64
inst$ = 96
regs$ = 104
s370_load_on_condition PROC

; 3302 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3303 : int     r1;                             /* Value of R field          */
; 3304 : int     m3;                             /* Value of M field          */
; 3305 : int     b2;                             /* Base of effective addr    */
; 3306 : VADR    effective_addr2;                /* Effective address         */
; 3307 : U32     data;
; 3308 : 
; 3309 :     RSY(inst, regs, r1, m3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN5@s370_load_
  00069	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN14@s370_load_
  0009c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000a6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@s370_load_:
  000ae	83 7c 24 30 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN6@s370_load_
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN7@s370_load_
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@s370_load_:
$LN6@s370_load_:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_load_:
$LN4@s370_load_:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN9@s370_load_
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_load_:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_load_

; 3310 :     PER_ZEROADDR_XCHECK( regs, b2 );
; 3311 : 
; 3312 :     /* TXF requires storage reference regardless of cc */
; 3313 :     data = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00143	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00148	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  0014c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00150	e8 00 00 00 00	 call	 s370_vfetch4
  00155	89 44 24 40	 mov	 DWORD PTR data$[rsp], eax

; 3314 : 
; 3315 :     /* Test M3 mask bit corresponding to condition code */
; 3316 :     if (m3 & (0x08 >> regs->psw.cc))

  00159	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00162	b9 08 00 00 00	 mov	 ecx, 8
  00167	89 4c 24 34	 mov	 DWORD PTR tv196[rsp], ecx
  0016b	0f b6 c8	 movzx	 ecx, al
  0016e	8b 44 24 34	 mov	 eax, DWORD PTR tv196[rsp]
  00172	d3 f8		 sar	 eax, cl
  00174	8b 4c 24 38	 mov	 ecx, DWORD PTR m3$[rsp]
  00178	23 c8		 and	 ecx, eax
  0017a	8b c1		 mov	 eax, ecx
  0017c	85 c0		 test	 eax, eax
  0017e	74 15		 je	 SHORT $LN10@s370_load_

; 3317 :     {
; 3318 :         /* Load R1 register bits 32-63 from second operand */
; 3319 :         regs->GR_L(r1) = data;

  00180	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00185	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	8b 54 24 40	 mov	 edx, DWORD PTR data$[rsp]
  0018e	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx
$LN10@s370_load_:

; 3320 :     }
; 3321 : }

  00195	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00199	c3		 ret	 0
s370_load_on_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
tv145 = 36
m3$ = 40
r2$ = 44
r1$ = 48
inst$ = 80
regs$ = 88
s370_load_on_condition_register PROC

; 3260 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3261 : int     r1, r2;                         /* Values of R fields        */
; 3262 : int     m3;                             /* Value of M field          */
; 3263 : 
; 3264 :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_load_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_load_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_load_

; 3265 : 
; 3266 :     /* Test M3 mask bit corresponding to condition code */
; 3267 :     if (m3 & (0x08 >> regs->psw.cc))

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00082	b9 08 00 00 00	 mov	 ecx, 8
  00087	89 4c 24 24	 mov	 DWORD PTR tv145[rsp], ecx
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	8b 44 24 24	 mov	 eax, DWORD PTR tv145[rsp]
  00092	d3 f8		 sar	 eax, cl
  00094	8b 4c 24 28	 mov	 ecx, DWORD PTR m3$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	85 c0		 test	 eax, eax
  0009e	74 23		 je	 SHORT $LN6@s370_load_

; 3268 :     {
; 3269 :         /* Copy R2 register bits 32-63 to R1 register */
; 3270 :         regs->GR_L(r1) = regs->GR_L(r2);

  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  000a5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000aa	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b4	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  000bc	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN6@s370_load_:

; 3271 :     }
; 3272 : 
; 3273 : } /* end DEF_INST(load_on_condition_register) */

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s370_load_on_condition_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr1$ = 32
effective_addr2$ = 36
temp$1 = 40
b1$ = 44
b2$ = 48
r3$ = 52
tv170 = 56
v1$ = 64
v2$ = 72
w1$ = 80
w2$ = 88
inst$ = 112
regs$ = 120
s370_load_pair_disjoint_long PROC

; 3218 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3219 : int     r3;                             /* Register number           */
; 3220 : int     b1, b2;                         /* Base register numbers     */
; 3221 : VADR    effective_addr1,
; 3222 :         effective_addr2;                /* Effective addresses       */
; 3223 : U64     v1, v2;                         /* Operand values            */
; 3224 : U64     w1, w2;                         /* Refetched values          */
; 3225 : 
; 3226 :     SSF(inst, regs, b1, effective_addr1, b2, effective_addr2, r3);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 01	 imul	 rax, rax, 1
  00033	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00038	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003c	c1 f8 04	 sar	 eax, 4
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 0c	 shr	 eax, 12
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 10	 shr	 eax, 16
  00068	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006d	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00071	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00075	c1 e8 1c	 shr	 eax, 28
  00078	83 e0 0f	 and	 eax, 15
  0007b	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  0007f	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00084	74 2a		 je	 SHORT $LN5@s370_load_
  00086	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0008b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00097	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0009b	03 c8		 add	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000a3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000a7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ac	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_load_:
  000b0	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b5	74 2a		 je	 SHORT $LN6@s370_load_
  000b7	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c8	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000cc	03 c8		 add	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000d4	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000d8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000dd	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
$LN4@s370_load_:
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ea	48 83 c0 06	 add	 rax, 6
  000ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f7	33 c0		 xor	 eax, eax
  000f9	83 f8 06	 cmp	 eax, 6
  000fc	74 0c		 je	 SHORT $LN7@s370_load_
  000fe	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00103	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_load_:
  0010a	33 c0		 xor	 eax, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 d1		 jne	 SHORT $LN4@s370_load_

; 3227 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 3228 : 
; 3229 :     TXFC_INSTR_CHECK( regs );
; 3230 :     ODD_CHECK(r3, regs);

  00110	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	74 15		 je	 SHORT $LN8@s370_load_
  0011b	ba 06 00 00 00	 mov	 edx, 6
  00120	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3231 : 
; 3232 :     /* Fetch the values of the storage operands */
; 3233 :     v1 = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  00130	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00135	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  00139	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0013d	e8 00 00 00 00	 call	 s370_vfetch8
  00142	48 89 44 24 40	 mov	 QWORD PTR v1$[rsp], rax

; 3234 :     v2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00147	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  00150	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00154	e8 00 00 00 00	 call	 s370_vfetch8
  00159	48 89 44 24 48	 mov	 QWORD PTR v2$[rsp], rax

; 3235 : 
; 3236 :     /* Fetch operands again to check for alteration by another CPU */
; 3237 :     w1 = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  0015e	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00163	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  00167	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_vfetch8
  00170	48 89 44 24 50	 mov	 QWORD PTR w1$[rsp], rax

; 3238 :     w2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00175	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  0017e	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00182	e8 00 00 00 00	 call	 s370_vfetch8
  00187	48 89 44 24 58	 mov	 QWORD PTR w2$[rsp], rax

; 3239 : 
; 3240 :     /* Load R3 register from first storage operand */
; 3241 :     regs->GR_G(r3) = v1;

  0018c	48 63 44 24 34	 movsxd	 rax, DWORD PTR r3$[rsp]
  00191	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	48 8b 54 24 40	 mov	 rdx, QWORD PTR v1$[rsp]
  0019b	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3242 : 
; 3243 :     /* Load R3+1 register from second storage operand */
; 3244 :     regs->GR_G(r3+1) = v2;

  001a3	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  001a7	ff c0		 inc	 eax
  001a9	48 98		 cdqe
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 54 24 48	 mov	 rdx, QWORD PTR v2$[rsp]
  001b5	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3245 : 
; 3246 :     /* Set condition code 0 if operands unaltered, or 3 if altered */
; 3247 :     regs->psw.cc = (v1 == w1 && v2 == w2) ? 0 : 3;

  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR w1$[rsp]
  001c2	48 39 44 24 40	 cmp	 QWORD PTR v1$[rsp], rax
  001c7	75 16		 jne	 SHORT $LN10@s370_load_
  001c9	48 8b 44 24 58	 mov	 rax, QWORD PTR w2$[rsp]
  001ce	48 39 44 24 48	 cmp	 QWORD PTR v2$[rsp], rax
  001d3	75 0a		 jne	 SHORT $LN10@s370_load_
  001d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
  001dd	eb 08		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:
  001df	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv170[rsp], 3
$LN11@s370_load_:
  001e7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv170[rsp]
  001f1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3248 : 
; 3249 : } /* end DEF_INST(load_pair_disjoint_long) */

  001f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001f8	c3		 ret	 0
s370_load_pair_disjoint_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_or_long PROC

; 3169 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3170 :     TXFC_INSTR_CHECK( regs );
; 3171 : 
; 3172 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access_long

; 3173 : } /* end DEF_INST(load_and_or_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_or_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_exclusive_or_long PROC

; 3147 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3148 :     TXFC_INSTR_CHECK( regs );
; 3149 : 
; 3150 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access_long

; 3151 : } /* end DEF_INST(load_and_exclusive_or_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_exclusive_or_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_and_long PROC

; 3125 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3126 :     TXFC_INSTR_CHECK( regs );
; 3127 : 
; 3128 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access_long

; 3129 : } /* end DEF_INST(load_and_and_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_and_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_add_logical_long PROC

; 3103 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3104 :     TXFC_INSTR_CHECK( regs );
; 3105 : 
; 3106 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access_long

; 3107 : } /* end DEF_INST(load_and_add_logical_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_add_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_add_long PROC

; 3076 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3077 :     TXFC_INSTR_CHECK( regs );
; 3078 : 
; 3079 :     ARCH_DEP(load_and_perform_interlocked_access_long) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access_long

; 3080 : 
; 3081 :     /* Program check if fixed-point overflow */
; 3082 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@s370_load_
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@s370_load_

; 3083 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s370_load_:

; 3084 : 
; 3085 : } /* end DEF_INST(load_and_add_long) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
s370_load_and_add_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr1$ = 32
effective_addr2$ = 36
temp$1 = 40
b1$ = 44
b2$ = 48
r3$ = 52
v1$ = 56
v2$ = 60
tv170 = 64
w1$ = 68
w2$ = 72
inst$ = 96
regs$ = 104
s370_load_pair_disjoint PROC

; 3180 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3181 : int     r3;                             /* Register number           */
; 3182 : int     b1, b2;                         /* Base register numbers     */
; 3183 : VADR    effective_addr1,
; 3184 :         effective_addr2;                /* Effective addresses       */
; 3185 : U32     v1, v2;                         /* Operand values            */
; 3186 : U32     w1, w2;                         /* Refetched values          */
; 3187 : 
; 3188 :     SSF(inst, regs, b1, effective_addr1, b2, effective_addr2, r3);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 01	 imul	 rax, rax, 1
  00033	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00038	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003c	c1 f8 04	 sar	 eax, 4
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 0c	 shr	 eax, 12
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00061	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 10	 shr	 eax, 16
  00068	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006d	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00071	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00075	c1 e8 1c	 shr	 eax, 28
  00078	83 e0 0f	 and	 eax, 15
  0007b	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  0007f	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00084	74 2a		 je	 SHORT $LN5@s370_load_
  00086	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0008b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00097	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0009b	03 c8		 add	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000a3	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000a7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000ac	89 44 24 20	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_load_:
  000b0	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b5	74 2a		 je	 SHORT $LN6@s370_load_
  000b7	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c8	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000cc	03 c8		 add	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000d4	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000d8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000dd	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
$LN4@s370_load_:
  000e1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ea	48 83 c0 06	 add	 rax, 6
  000ee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f7	33 c0		 xor	 eax, eax
  000f9	83 f8 06	 cmp	 eax, 6
  000fc	74 0c		 je	 SHORT $LN7@s370_load_
  000fe	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00103	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_load_:
  0010a	33 c0		 xor	 eax, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 d1		 jne	 SHORT $LN4@s370_load_

; 3189 :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 3190 : 
; 3191 :     TXFC_INSTR_CHECK( regs );
; 3192 :     ODD_CHECK(r3, regs);

  00110	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	74 15		 je	 SHORT $LN8@s370_load_
  0011b	ba 06 00 00 00	 mov	 edx, 6
  00120	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 3193 : 
; 3194 :     /* Fetch the values of the storage operands */
; 3195 :     v1 = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  00130	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00135	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  00139	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0013d	e8 00 00 00 00	 call	 s370_vfetch4
  00142	89 44 24 38	 mov	 DWORD PTR v1$[rsp], eax

; 3196 :     v2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00146	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0014b	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  0014f	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00153	e8 00 00 00 00	 call	 s370_vfetch4
  00158	89 44 24 3c	 mov	 DWORD PTR v2$[rsp], eax

; 3197 : 
; 3198 :     /* Fetch operands again to check for alteration by another CPU */
; 3199 :     w1 = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  0015c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00161	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  00165	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00169	e8 00 00 00 00	 call	 s370_vfetch4
  0016e	89 44 24 44	 mov	 DWORD PTR w1$[rsp], eax

; 3200 :     w2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00172	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00177	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  0017b	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0017f	e8 00 00 00 00	 call	 s370_vfetch4
  00184	89 44 24 48	 mov	 DWORD PTR w2$[rsp], eax

; 3201 : 
; 3202 :     /* Load R3 register from first storage operand */
; 3203 :     regs->GR_L(r3) = v1;

  00188	48 63 44 24 34	 movsxd	 rax, DWORD PTR r3$[rsp]
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	8b 54 24 38	 mov	 edx, DWORD PTR v1$[rsp]
  00196	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3204 : 
; 3205 :     /* Load R3+1 register from second storage operand */
; 3206 :     regs->GR_L(r3+1) = v2;

  0019d	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  001a1	ff c0		 inc	 eax
  001a3	48 98		 cdqe
  001a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	8b 54 24 3c	 mov	 edx, DWORD PTR v2$[rsp]
  001ae	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3207 : 
; 3208 :     /* Set condition code 0 if operands unaltered, or 3 if altered */
; 3209 :     regs->psw.cc = (v1 == w1 && v2 == w2) ? 0 : 3;

  001b5	8b 44 24 44	 mov	 eax, DWORD PTR w1$[rsp]
  001b9	39 44 24 38	 cmp	 DWORD PTR v1$[rsp], eax
  001bd	75 14		 jne	 SHORT $LN10@s370_load_
  001bf	8b 44 24 48	 mov	 eax, DWORD PTR w2$[rsp]
  001c3	39 44 24 3c	 cmp	 DWORD PTR v2$[rsp], eax
  001c7	75 0a		 jne	 SHORT $LN10@s370_load_
  001c9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
  001d1	eb 08		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:
  001d3	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv170[rsp], 3
$LN11@s370_load_:
  001db	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001e0	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv170[rsp]
  001e5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3210 : 
; 3211 : } /* end DEF_INST(load_pair_disjoint) */

  001e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ec	c3		 ret	 0
s370_load_pair_disjoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_or PROC

; 3158 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3159 :     TXFC_INSTR_CHECK( regs );
; 3160 : 
; 3161 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access

; 3162 : } /* end DEF_INST(load_and_or) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_or ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_exclusive_or PROC

; 3136 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3137 :     TXFC_INSTR_CHECK( regs );
; 3138 : 
; 3139 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access

; 3140 : } /* end DEF_INST(load_and_exclusive_or) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_exclusive_or ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_and PROC

; 3114 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3115 :     TXFC_INSTR_CHECK( regs );
; 3116 : 
; 3117 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access

; 3118 : } /* end DEF_INST(load_and_and) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_and ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_add_logical PROC

; 3092 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3093 :     TXFC_INSTR_CHECK( regs );
; 3094 : 
; 3095 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access

; 3096 : } /* end DEF_INST(load_and_add_logical) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_load_and_add_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_load_and_add PROC

; 3060 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3061 :     TXFC_INSTR_CHECK( regs );
; 3062 : 
; 3063 :     ARCH_DEP(load_and_perform_interlocked_access) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_load_and_perform_interlocked_access

; 3064 : 
; 3065 :     /* Program check if fixed-point overflow */
; 3066 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@s370_load_
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@s370_load_

; 3067 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s370_load_:

; 3068 : 
; 3069 : } /* end DEF_INST(load_and_add) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
s370_load_and_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_logical_high_high_low_register PROC

; 2854 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2855 : int     r1, r2, r3;                     /* Values of R fields        */
; 2856 : 
; 2857 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 2858 : 
; 2859 :     /* Subtract unsigned operands and set condition code */
; 2860 :     regs->psw.cc = sub_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2861 :                                   regs->GR_H(r2),
; 2862 :                                   regs->GR_L(r3));
; 2863 : 
; 2864 : } /* end DEF_INST(subtract_logical_high_high_low_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_subtract_logical_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_logical_high_high_high_register PROC

; 2837 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2838 : int     r1, r2, r3;                     /* Values of R fields        */
; 2839 : 
; 2840 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 2841 : 
; 2842 :     /* Subtract unsigned operands and set condition code */
; 2843 :     regs->psw.cc = sub_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2844 :                                   regs->GR_H(r2),
; 2845 :                                   regs->GR_H(r3));
; 2846 : 
; 2847 : } /* end DEF_INST(subtract_logical_high_high_high_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_subtract_logical_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_high_high_low_register PROC

; 2816 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2817 : int     r1, r2, r3;                     /* Values of R fields        */
; 2818 : 
; 2819 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 2820 : 
; 2821 :     /* Subtract signed operands and set condition code */
; 2822 :     regs->psw.cc = sub_signed (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2823 :                                  regs->GR_H(r2),
; 2824 :                                  regs->GR_L(r3));
; 2825 : 
; 2826 :     /* Program check if fixed-point overflow */
; 2827 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_subtr

; 2828 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_subtr:

; 2829 : 
; 2830 : } /* end DEF_INST(subtract_high_high_low_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_subtract_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_high_high_high_register PROC

; 2795 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2796 : int     r1, r2, r3;                     /* Values of R fields        */
; 2797 : 
; 2798 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 2799 : 
; 2800 :     /* Subtract signed operands and set condition code */
; 2801 :     regs->psw.cc = sub_signed (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2802 :                                  regs->GR_H(r2),
; 2803 :                                  regs->GR_H(r3));
; 2804 : 
; 2805 :     /* Program check if fixed-point overflow */
; 2806 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_subtr

; 2807 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_subtr:

; 2808 : 
; 2809 : } /* end DEF_INST(subtract_high_high_high_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_subtract_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_store_halfword_high PROC

; 2776 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2777 : int     r1;                             /* Value of R field          */
; 2778 : int     x2;                             /* Index register            */
; 2779 : int     b2;                             /* Base of effective addr    */
; 2780 : VADR    effective_addr2;                /* Effective address         */
; 2781 : 
; 2782 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_store
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_store:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_store
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_store:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_store
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_store:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_store
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_store
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_store:
$LN7@s370_store:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_store
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_store:
$LN4@s370_store:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_store
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_store:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_store

; 2783 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2784 : 
; 2785 :     /* Store bits 16-31 of R1 register at operand address */
; 2786 :     ARCH_DEP(vstore2) ( regs->GR_HHL(r1), effective_addr2, b2, regs );

  00167	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  00171	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00176	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	0f b7 8c c1 84
	02 00 00	 movzx	 ecx, WORD PTR [rcx+rax*8+644]
  00187	e8 00 00 00 00	 call	 s370_vstore2

; 2787 : 
; 2788 : } /* end DEF_INST(store_halfword_high) */

  0018c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00190	c3		 ret	 0
s370_store_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_store_fullword_high PROC

; 2757 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2758 : int     r1;                             /* Values of R fields        */
; 2759 : int     x2;                             /* Index register            */
; 2760 : int     b2;                             /* Base of effective addr    */
; 2761 : VADR    effective_addr2;                /* Effective address         */
; 2762 : 
; 2763 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_store
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_store:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_store
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_store:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_store
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_store:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_store
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_store
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_store:
$LN7@s370_store:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_store
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_store:
$LN4@s370_store:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_store
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_store:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_store

; 2764 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2765 : 
; 2766 :     /* Store bits 0-31 of R1 register at operand address */
; 2767 :     ARCH_DEP(vstore4) ( regs->GR_H(r1), effective_addr2, b2, regs );

  00167	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  00171	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00176	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 8c c1 84 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+644]
  00186	e8 00 00 00 00	 call	 s370_vstore4

; 2768 : 
; 2769 : } /* end DEF_INST(store_fullword_high) */

  0018b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018f	c3		 ret	 0
s370_store_fullword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_store_character_high PROC

; 2738 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2739 : int     r1;                             /* Value of R field          */
; 2740 : int     x2;                             /* Index register            */
; 2741 : int     b2;                             /* Base of effective addr    */
; 2742 : VADR    effective_addr2;                /* Effective address         */
; 2743 : 
; 2744 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_store
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_store:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_store
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_store:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_store
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_store:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_store
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_store
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_store:
$LN7@s370_store:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_store
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_store:
$LN4@s370_store:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_store
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_store:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_store

; 2745 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2746 : 
; 2747 :     /* Store bits 24-31 of R1 register at operand address */
; 2748 :     ARCH_DEP(vstoreb) ( regs->GR_HHLCL(r1), effective_addr2, b2, regs );

  00167	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  00171	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b2$[rsp]
  00176	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	0f b6 8c c1 84
	02 00 00	 movzx	 ecx, BYTE PTR [rcx+rax*8+644]
  00187	e8 00 00 00 00	 call	 s370_vstoreb

; 2749 : 
; 2750 : } /* end DEF_INST(store_character_high) */

  0018c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00190	c3		 ret	 0
s370_store_character_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_rotate_then_insert_selected_bits_low_long_reg PROC

; 2729 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2730 :     ARCH_DEP(rotate_then_xxx_selected_bits_long_reg) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_rotate_then_xxx_selected_bits_long_reg

; 2731 : } /* end DEF_INST(rotate_then_insert_selected_bits_low_long_reg) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_rotate_then_insert_selected_bits_low_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_rotate_then_insert_selected_bits_high_long_reg PROC

; 2720 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2721 :     ARCH_DEP(rotate_then_xxx_selected_bits_long_reg) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_rotate_then_xxx_selected_bits_long_reg

; 2722 : } /* end DEF_INST(rotate_then_insert_selected_bits_high_long_reg) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_rotate_then_insert_selected_bits_high_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_load_logical_halfword_high PROC

; 2701 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2702 : int     r1;                             /* Value of R field          */
; 2703 : int     x2;                             /* Index register            */
; 2704 : int     b2;                             /* Base of effective addr    */
; 2705 : VADR    effective_addr2;                /* Effective address         */
; 2706 : 
; 2707 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_load_
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_load_
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_load_
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_load_:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_load_
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_load_:
$LN7@s370_load_:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_load_
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_load_:
$LN4@s370_load_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_load_
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_load_:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_load_

; 2708 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2709 : 
; 2710 :     /* Load halfword into R1 register bits 16-31 and clear bits 0-15 */
; 2711 :     regs->GR_H(r1) = ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch2
  00179	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	0f b7 c0	 movzx	 eax, ax
  00181	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2712 : 
; 2713 : } /* end DEF_INST(load_logical_halfword_high) */

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
s370_load_logical_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_load_logical_character_high PROC

; 2682 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2683 : int     r1;                             /* Value of R field          */
; 2684 : int     x2;                             /* Index register            */
; 2685 : int     b2;                             /* Base of effective addr    */
; 2686 : VADR    effective_addr2;                /* Effective address         */
; 2687 : 
; 2688 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_load_
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_load_
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_load_
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_load_:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_load_
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_load_:
$LN7@s370_load_:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_load_
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_load_:
$LN4@s370_load_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_load_
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_load_:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_load_

; 2689 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2690 : 
; 2691 :     /* Load byte into R1 register bits 24-31 and clear bits 0-23 */
; 2692 :     regs->GR_H(r1) = ARCH_DEP(vfetchb) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetchb
  00179	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	0f b6 c0	 movzx	 eax, al
  00181	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2693 : 
; 2694 : } /* end DEF_INST(load_logical_character_high) */

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
s370_load_logical_character_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_load_halfword_high PROC

; 2663 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2664 : int     r1;                             /* Value of R field          */
; 2665 : int     x2;                             /* Index register            */
; 2666 : int     b2;                             /* Base of effective addr    */
; 2667 : VADR    effective_addr2;                /* Effective address         */
; 2668 : 
; 2669 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_load_
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_load_
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_load_
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_load_:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_load_
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_load_:
$LN7@s370_load_:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_load_
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_load_:
$LN4@s370_load_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_load_
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_load_:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_load_

; 2670 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2671 : 
; 2672 :     /* Load sign-extended halfword from operand address */
; 2673 :     regs->GR_H(r1) = (S16)ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch2
  00179	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	98		 cwde
  0017f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00184	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2674 : 
; 2675 : } /* end DEF_INST(load_halfword_high) */

  0018b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018f	c3		 ret	 0
s370_load_halfword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_load_fullword_high PROC

; 2644 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2645 : int     r1;                             /* Value of R field          */
; 2646 : int     x2;                             /* Index register            */
; 2647 : int     b2;                             /* Base of effective addr    */
; 2648 : VADR    effective_addr2;                /* Effective address         */
; 2649 : 
; 2650 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_load_
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_load_
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_load_
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_load_:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_load_
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_load_:
$LN7@s370_load_:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_load_
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_load_:
$LN4@s370_load_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_load_
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_load_:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_load_

; 2651 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2652 : 
; 2653 :     /* Load R1 register bits 0-31 from second operand */
; 2654 :     regs->GR_H(r1) = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch4
  00179	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2655 : 
; 2656 : } /* end DEF_INST(load_fullword_high) */

  0018a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018e	c3		 ret	 0
s370_load_fullword_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
inst$ = 80
regs$ = 88
s370_load_byte_high PROC

; 2625 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2626 : int     r1;                             /* Value of R field          */
; 2627 : int     x2;                             /* Index register            */
; 2628 : int     b2;                             /* Base of effective addr    */
; 2629 : VADR    effective_addr2;                /* Effective address         */
; 2630 : 
; 2631 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_load_
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_load_
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_load_:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_load_
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_load_:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_load_
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_load_
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_load_:
$LN7@s370_load_:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_load_
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_load_:
$LN4@s370_load_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_load_
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_load_:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_load_

; 2632 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2633 : 
; 2634 :     /* Load sign-extended byte from operand address */
; 2635 :     regs->GR_H(r1) = (S8)ARCH_DEP(vfetchb) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetchb
  00179	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	0f be c0	 movsx	 eax, al
  00181	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 2636 : 
; 2637 : } /* end DEF_INST(load_byte_high) */

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
s370_load_byte_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv130 = 40
tv131 = 44
opcd$ = 48
inst$ = 80
regs$ = 88
s370_compare_logical_high_immediate PROC

; 2607 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2608 : int     r1;                             /* Register number           */
; 2609 : int     opcd;                           /* Opcode                    */
; 2610 : U32     i2;                             /* 32-bit operand value      */
; 2611 : 
; 2612 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 30	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_compa
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_compa

; 2613 : 
; 2614 :     /* Compare unsigned operands and set condition code */
; 2615 :     regs->psw.cc = regs->GR_H(r1) < i2 ? 1 :

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000a7	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000ae	73 0a		 jae	 SHORT $LN9@s370_compa
  000b0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b8	eb 31		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000c8	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000cf	76 0a		 jbe	 SHORT $LN7@s370_compa
  000d1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d9	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN8@s370_compa:
  000e3	8b 44 24 28	 mov	 eax, DWORD PTR tv130[rsp]
  000e7	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN10@s370_compa:
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv131[rsp]
  000f5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2616 :                    regs->GR_H(r1) > i2 ? 2 : 0;
; 2617 : 
; 2618 : } /* end DEF_INST(compare_logical_high_immediate) */

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
s370_compare_logical_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
n$ = 60
tv167 = 64
tv168 = 68
inst$ = 96
regs$ = 104
s370_compare_logical_high_fullword PROC

; 2583 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2584 : int     r1;                             /* Values of R fields        */
; 2585 : int     x2;                             /* Index register            */
; 2586 : int     b2;                             /* Base of effective addr    */
; 2587 : VADR    effective_addr2;                /* Effective address         */
; 2588 : U32     n;                              /* 32-bit operand values     */
; 2589 : 
; 2590 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_compa
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_compa
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_compa
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_compa:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_compa
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_compa
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_compa:
$LN7@s370_compa:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_compa
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_compa:
$LN4@s370_compa:
  00138	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_compa
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_compa:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_compa

; 2591 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2592 : 
; 2593 :     /* Load second operand from operand address */
; 2594 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch4
  00179	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 2595 : 
; 2596 :     /* Compare unsigned operands and set condition code */
; 2597 :     regs->psw.cc = regs->GR_H(r1) < n ? 1 :

  0017d	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	8b 54 24 3c	 mov	 edx, DWORD PTR n$[rsp]
  0018b	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  00192	73 0a		 jae	 SHORT $LN18@s370_compa
  00194	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0019c	eb 31		 jmp	 SHORT $LN19@s370_compa
$LN18@s370_compa:
  0019e	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	8b 54 24 3c	 mov	 edx, DWORD PTR n$[rsp]
  001ac	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001b3	76 0a		 jbe	 SHORT $LN16@s370_compa
  001b5	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv167[rsp], 2
  001bd	eb 08		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  001bf	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN17@s370_compa:
  001c7	8b 44 24 40	 mov	 eax, DWORD PTR tv167[rsp]
  001cb	89 44 24 44	 mov	 DWORD PTR tv168[rsp], eax
$LN19@s370_compa:
  001cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d4	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR tv168[rsp]
  001d9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2598 :                    regs->GR_H(r1) > n ? 2 : 0;
; 2599 : 
; 2600 : } /* end DEF_INST(compare_logical_high_fullword) */

  001dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e0	c3		 ret	 0
s370_compare_logical_high_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
s370_compare_logical_high_low_register PROC

; 2567 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2568 : int     r1, r2;                         /* Values of R fields        */
; 2569 : 
; 2570 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@s370_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@s370_compa

; 2571 : 
; 2572 :     /* Compare unsigned operands and set condition code */
; 2573 :     regs->psw.cc = regs->GR_H(r1) < regs->GR_L(r2) ? 1 :

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	73 0a		 jae	 SHORT $LN9@s370_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	76 0a		 jbe	 SHORT $LN7@s370_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@s370_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@s370_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2574 :                    regs->GR_H(r1) > regs->GR_L(r2) ? 2 : 0;
; 2575 : 
; 2576 : } /* end DEF_INST(compare_logical_high_low_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
s370_compare_logical_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
s370_compare_logical_high_high_register PROC

; 2551 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2552 : int     r1, r2;                         /* Values of R fields        */
; 2553 : 
; 2554 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@s370_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@s370_compa

; 2555 : 
; 2556 :     /* Compare unsigned operands and set condition code */
; 2557 :     regs->psw.cc = regs->GR_H(r1) < regs->GR_H(r2) ? 1 :

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	73 0a		 jae	 SHORT $LN9@s370_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	76 0a		 jbe	 SHORT $LN7@s370_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@s370_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@s370_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2558 :                    regs->GR_H(r1) > regs->GR_H(r2) ? 2 : 0;
; 2559 : 
; 2560 : } /* end DEF_INST(compare_logical_high_high_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
s370_compare_logical_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv130 = 40
tv131 = 44
opcd$ = 48
inst$ = 80
regs$ = 88
s370_compare_high_immediate PROC

; 2533 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2534 : int     r1;                             /* Register number           */
; 2535 : int     opcd;                           /* Opcode                    */
; 2536 : U32     i2;                             /* 32-bit operand value      */
; 2537 : 
; 2538 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 30	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_compa
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_compa

; 2539 : 
; 2540 :     /* Compare signed operands and set condition code */
; 2541 :     regs->psw.cc = (S32)regs->GR_H(r1) < (S32)i2 ? 1 :

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000a7	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000ae	7d 0a		 jge	 SHORT $LN9@s370_compa
  000b0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b8	eb 31		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	8b 54 24 24	 mov	 edx, DWORD PTR i2$[rsp]
  000c8	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  000cf	7e 0a		 jle	 SHORT $LN7@s370_compa
  000d1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d9	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN8@s370_compa:
  000e3	8b 44 24 28	 mov	 eax, DWORD PTR tv130[rsp]
  000e7	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN10@s370_compa:
  000eb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f0	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR tv131[rsp]
  000f5	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2542 :                    (S32)regs->GR_H(r1) > (S32)i2 ? 2 : 0;
; 2543 : 
; 2544 : } /* end DEF_INST(compare_high_immediate) */

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
s370_compare_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
n$ = 60
tv167 = 64
tv168 = 68
inst$ = 96
regs$ = 104
s370_compare_high_fullword PROC

; 2508 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2509 : int     r1;                             /* Values of R fields        */
; 2510 : int     x2;                             /* Index register            */
; 2511 : int     b2;                             /* Base of effective addr    */
; 2512 : VADR    effective_addr2;                /* Effective address         */
; 2513 : U32     n;                              /* 32-bit operand values     */
; 2514 : 
; 2515 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_compa
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_compa:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_compa
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_compa:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_compa
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_compa:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_compa
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_compa
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_compa:
$LN7@s370_compa:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_compa
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_compa:
$LN4@s370_compa:
  00138	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_compa
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_compa:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_compa

; 2516 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 2517 : 
; 2518 :     /* Load second operand from operand address */
; 2519 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch4
  00179	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 2520 : 
; 2521 :     /* Compare signed operands and set condition code */
; 2522 :     regs->psw.cc =

  0017d	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	8b 54 24 3c	 mov	 edx, DWORD PTR n$[rsp]
  0018b	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  00192	7d 0a		 jge	 SHORT $LN18@s370_compa
  00194	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0019c	eb 31		 jmp	 SHORT $LN19@s370_compa
$LN18@s370_compa:
  0019e	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	8b 54 24 3c	 mov	 edx, DWORD PTR n$[rsp]
  001ac	39 94 c1 84 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+644], edx
  001b3	7e 0a		 jle	 SHORT $LN16@s370_compa
  001b5	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR tv167[rsp], 2
  001bd	eb 08		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  001bf	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN17@s370_compa:
  001c7	8b 44 24 40	 mov	 eax, DWORD PTR tv167[rsp]
  001cb	89 44 24 44	 mov	 DWORD PTR tv168[rsp], eax
$LN19@s370_compa:
  001cf	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d4	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR tv168[rsp]
  001d9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2523 :             (S32)regs->GR_H(r1) < (S32)n ? 1 :
; 2524 :             (S32)regs->GR_H(r1) > (S32)n ? 2 : 0;
; 2525 : 
; 2526 : } /* DEF_INST(compare_high_fullword) */

  001dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e0	c3		 ret	 0
s370_compare_high_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
s370_compare_high_low_register PROC

; 2491 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2492 : int     r1, r2;                         /* Values of R fields        */
; 2493 : 
; 2494 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@s370_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@s370_compa

; 2495 : 
; 2496 :     /* Compare signed operands and set condition code */
; 2497 :     regs->psw.cc =

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	7d 0a		 jge	 SHORT $LN9@s370_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	7e 0a		 jle	 SHORT $LN7@s370_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@s370_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@s370_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2498 :                 (S32)regs->GR_H(r1) < (S32)regs->GR_L(r2) ? 1 :
; 2499 :                 (S32)regs->GR_H(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 2500 : 
; 2501 : } /* DEF_INST(compare_high_low_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
s370_compare_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i$1 = 0
r1$ = 4
r2$ = 8
tv131 = 12
tv132 = 16
inst$ = 48
regs$ = 56
s370_compare_high_high_register PROC

; 2474 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2475 : int     r1, r2;                         /* Values of R fields        */
; 2476 : 
; 2477 :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
  00023	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00026	83 e0 0f	 and	 eax, 15
  00029	89 44 24 08	 mov	 DWORD PTR r2$[rsp], eax
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00030	c1 f8 04	 sar	 eax, 4
  00033	83 e0 0f	 and	 eax, 15
  00036	89 44 24 04	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00043	48 83 c0 04	 add	 rax, 4
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00050	33 c0		 xor	 eax, eax
  00052	83 f8 04	 cmp	 eax, 4
  00055	74 0c		 je	 SHORT $LN5@s370_compa
  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 d1		 jne	 SHORT $LN4@s370_compa

; 2478 : 
; 2479 :     /* Compare signed operands and set condition code */
; 2480 :     regs->psw.cc =

  00069	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006e	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00073	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  0007d	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  00085	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  0008c	7d 0a		 jge	 SHORT $LN9@s370_compa
  0008e	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  00096	eb 3f		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  00098	48 63 44 24 04	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009d	48 63 4c 24 08	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	4c 8b 44 24 38	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	41 8b 8c c8 84
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+644]
  000b4	39 8c c2 84 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+644], ecx
  000bb	7e 0a		 jle	 SHORT $LN7@s370_compa
  000bd	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000c5	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  000c7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN8@s370_compa:
  000cf	8b 44 24 0c	 mov	 eax, DWORD PTR tv131[rsp]
  000d3	89 44 24 10	 mov	 DWORD PTR tv132[rsp], eax
$LN10@s370_compa:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR tv132[rsp]
  000e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2481 :                 (S32)regs->GR_H(r1) < (S32)regs->GR_H(r2) ? 1 :
; 2482 :                 (S32)regs->GR_H(r1) > (S32)regs->GR_H(r2) ? 2 : 0;
; 2483 : 
; 2484 : } /* DEF_INST(compare_high_high_register) */

  000e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e8	c3		 ret	 0
s370_compare_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
xop$ = 32
r1$ = 36
tv95 = 40
ri2$ = 44
inst$ = 64
regs$ = 72
s370_branch_relative_on_count_high PROC

; 2449 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2450 : int     r1;                             /* Register number           */
; 2451 : U8      xop;                            /* Extended opcode           */
; 2452 : S32     ri2;                            /* 32-bit relative operand   */
; 2453 : 
; 2454 :     RIL_B( inst, regs, r1, xop, ri2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR ri2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	88 44 24 20	 mov	 BYTE PTR xop$[rsp], al
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_branc:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00073	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 06	 cmp	 eax, 6
  0007c	74 0c		 je	 SHORT $LN5@s370_branc
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00083	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_branc:
  0008a	33 c0		 xor	 eax, eax
  0008c	85 c0		 test	 eax, eax
  0008e	75 da		 jne	 SHORT $LN4@s370_branc

; 2455 : 
; 2456 :     TXFC_INSTR_CHECK_IP( regs );
; 2457 : 
; 2458 :     /* Subtract 1 from the R1 operand and branch if non-zero */
; 2459 :     if (--(regs->GR_H( r1 )))

  00090	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  00095	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 c1 84 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+644]
  000a1	ff c8		 dec	 eax
  000a3	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
  000a7	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	8b 54 24 28	 mov	 edx, DWORD PTR tv95[rsp]
  000b5	89 94 c1 84 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+644], edx
  000bc	83 7c 24 28 00	 cmp	 DWORD PTR tv95[rsp], 0
  000c1	74 17		 je	 SHORT $LN6@s370_branc

; 2460 :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri2 );

  000c3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR ri2$[rsp]
  000c8	48 d1 e0	 shl	 rax, 1
  000cb	48 8b d0	 mov	 rdx, rax
  000ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	e8 00 00 00 00	 call	 s370_SuccessfulRelativeBranch
  000d8	eb 16		 jmp	 SHORT $LN7@s370_branc
$LN6@s370_branc:

; 2461 :     else
; 2462 :     {
; 2463 :         /* Bump ip to next sequential instruction */
; 2464 :         regs->ip += 6;

  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e3	48 83 c0 06	 add	 rax, 6
  000e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@s370_branc:

; 2465 :     }
; 2466 : 
; 2467 : } /* end DEF_INST( branch_relative_on_count_high ) */

  000f0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f4	c3		 ret	 0
s370_branch_relative_on_count_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
tv131 = 48
inst$ = 80
regs$ = 88
s370_add_logical_with_signed_immediate_high_n PROC

; 2428 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2429 : int     r1;                             /* Register number           */
; 2430 : int     opcd;                           /* Opcode                    */
; 2431 : U32     i2;                             /* 32-bit operand value      */
; 2432 : 
; 2433 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_l:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_add_l
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_add_l:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_add_l

; 2434 : 
; 2435 :     /* Add operands without setting condition code */
; 2436 :     if ((S32)i2 < 0) {

  00099	83 7c 24 24 00	 cmp	 DWORD PTR i2$[rsp], 0
  0009e	7d 40		 jge	 SHORT $LN6@s370_add_l

; 2437 :         sub_logical (&(regs->GR_H(r1)), regs->GR_H(r1), -(S32)i2);

  000a0	8b 44 24 24	 mov	 eax, DWORD PTR i2$[rsp]
  000a4	f7 d8		 neg	 eax
  000a6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ab	48 63 54 24 20	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000b0	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b5	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  000bd	48 89 54 24 30	 mov	 QWORD PTR tv131[rsp], rdx
  000c2	44 8b c0	 mov	 r8d, eax
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR tv131[rsp]
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 sub_logical

; 2438 :     } else {

  000de	eb 2d		 jmp	 SHORT $LN7@s370_add_l
$LN6@s370_add_l:

; 2439 :         add_logical (&(regs->GR_H(r1)), regs->GR_H(r1), i2);

  000e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000e5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ea	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000ef	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000f7	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  000fc	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00101	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  00108	e8 00 00 00 00	 call	 add_logical
$LN7@s370_add_l:

; 2440 :     }
; 2441 : 
; 2442 : } /* end DEF_INST(add_logical_with_signed_immediate_high_n) */

  0010d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00111	c3		 ret	 0
s370_add_logical_with_signed_immediate_high_n ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
tv148 = 40
opcd$ = 44
tv132 = 48
inst$ = 80
regs$ = 88
s370_add_logical_with_signed_immediate_high PROC

; 2409 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2410 : int     r1;                             /* Register number           */
; 2411 : int     opcd;                           /* Opcode                    */
; 2412 : U32     i2;                             /* 32-bit operand value      */
; 2413 : 
; 2414 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 2c	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_l:
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_add_l
  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_add_l:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_add_l

; 2415 : 
; 2416 :     /* Add operands and set condition code */
; 2417 :     regs->psw.cc = (S32)i2 < 0 ?

  00099	83 7c 24 24 00	 cmp	 DWORD PTR i2$[rsp], 0
  0009e	7d 44		 jge	 SHORT $LN7@s370_add_l
  000a0	8b 44 24 24	 mov	 eax, DWORD PTR i2$[rsp]
  000a4	f7 d8		 neg	 eax
  000a6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ab	48 63 54 24 20	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000b0	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000b5	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  000bd	48 89 54 24 30	 mov	 QWORD PTR tv132[rsp], rdx
  000c2	44 8b c0	 mov	 r8d, eax
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR tv132[rsp]
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 sub_logical
  000de	89 44 24 28	 mov	 DWORD PTR tv148[rsp], eax
  000e2	eb 31		 jmp	 SHORT $LN8@s370_add_l
$LN7@s370_add_l:
  000e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  000e9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000ee	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000f3	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000fb	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  00100	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00105	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  0010c	e8 00 00 00 00	 call	 add_logical
  00111	89 44 24 28	 mov	 DWORD PTR tv148[rsp], eax
$LN8@s370_add_l:
  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv148[rsp]
  0011f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2418 :         sub_logical (&(regs->GR_H(r1)), regs->GR_H(r1), -(S32)i2) :
; 2419 :         add_logical (&(regs->GR_H(r1)), regs->GR_H(r1), i2);
; 2420 : 
; 2421 : } /* end DEF_INST(add_logical_with_signed_immediate_high) */

  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
s370_add_logical_with_signed_immediate_high ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_logical_high_high_low_register PROC

; 2392 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2393 : int     r1, r2, r3;                     /* Values of R fields        */
; 2394 : 
; 2395 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_l

; 2396 : 
; 2397 :     /* Add signed operands and set condition code */
; 2398 :     regs->psw.cc = add_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2399 :                                   regs->GR_H(r2),
; 2400 :                                   regs->GR_L(r3));
; 2401 : 
; 2402 : } /* end DEF_INST(add_logical_high_high_low_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_add_logical_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_logical_high_high_high_register PROC

; 2375 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2376 : int     r1, r2, r3;                     /* Values of R fields        */
; 2377 : 
; 2378 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_l

; 2379 : 
; 2380 :     /* Add signed operands and set condition code */
; 2381 :     regs->psw.cc = add_logical (&(regs->GR_H(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2382 :                                   regs->GR_H(r2),
; 2383 :                                   regs->GR_H(r3));
; 2384 : 
; 2385 : } /* end DEF_INST(add_logical_high_high_high_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_add_logical_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
inst$ = 64
regs$ = 72
s370_add_high_immediate PROC

; 2352 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2353 : int     r1;                             /* Register number           */
; 2354 : int     opcd;                           /* Opcode                    */
; 2355 : U32     i2;                             /* 32-bit operand value      */
; 2356 : 
; 2357 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_h:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_add_h
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_add_h:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_add_h

; 2358 : 
; 2359 :     /* Add signed operands and set condition code */
; 2360 :     regs->psw.cc = add_signed (&(regs->GR_H(r1)),

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	48 8d 8c ca 84
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+644]
  000b0	44 8b 44 24 24	 mov	 r8d, DWORD PTR i2$[rsp]
  000b5	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000ba	8b 94 c2 84 02
	00 00		 mov	 edx, DWORD PTR [rdx+rax*8+644]
  000c1	e8 00 00 00 00	 call	 add_signed
  000c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2361 :                                 regs->GR_H(r1),
; 2362 :                                 (S32)i2);
; 2363 : 
; 2364 :     /* Program check if fixed-point overflow */
; 2365 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d7	83 f8 03	 cmp	 eax, 3
  000da	75 25		 jne	 SHORT $LN6@s370_add_h
  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000e5	83 e0 08	 and	 eax, 8
  000e8	85 c0		 test	 eax, eax
  000ea	74 15		 je	 SHORT $LN6@s370_add_h

; 2366 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000ec	ba 08 00 00 00	 mov	 edx, 8
  000f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_h:

; 2367 : 
; 2368 : } /* end DEF_INST(add_high_immediate) */

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	c3		 ret	 0
s370_add_high_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_high_high_low_register PROC

; 2331 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2332 : int     r1, r2, r3;                     /* Values of R fields        */
; 2333 : 
; 2334 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_h:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_h
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_h:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_h

; 2335 : 
; 2336 :     /* Add signed operands and set condition code */
; 2337 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2338 :             add_signed (&(regs->GR_H(r1)),
; 2339 :                     regs->GR_H(r2),
; 2340 :                     regs->GR_L(r3));
; 2341 : 
; 2342 :     /* Program check if fixed-point overflow */
; 2343 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_add_h
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_add_h

; 2344 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_h:

; 2345 : 
; 2346 : } /* end DEF_INST(add_high_high_low_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_add_high_high_low_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_high_high_high_register PROC

; 2309 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2310 : int     r1, r2, r3;                     /* Values of R fields        */
; 2311 : 
; 2312 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_h:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_h
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_h:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_h

; 2313 : 
; 2314 :     /* Add signed operands and set condition code */
; 2315 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 84
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+644]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 84
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+644]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 84 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+644]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2316 :             add_signed (&(regs->GR_H(r1)),
; 2317 :                     regs->GR_H(r2),
; 2318 :                     regs->GR_H(r3));
; 2319 : 
; 2320 :     /* Program check if fixed-point overflow */
; 2321 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_add_h
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_add_h

; 2322 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_h:

; 2323 : 
; 2324 : } /* end DEF_INST(add_high_high_high_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_add_high_high_high_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_logical_distinct_register PROC

; 3938 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3939 : int     r1, r2, r3;                     /* Values of R fields        */
; 3940 : 
; 3941 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 3942 : 
; 3943 :     /* Subtract unsigned operands and set condition code */
; 3944 :     regs->psw.cc = sub_logical (&(regs->GR_L(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3945 :                                   regs->GR_L(r2),
; 3946 :                                   regs->GR_L(r3));
; 3947 : 
; 3948 : } /* end DEF_INST(subtract_logical_distinct_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_subtract_logical_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_subtract_distinct_register PROC

; 3893 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3894 : int     r1, r2, r3;                     /* Values of R fields        */
; 3895 : 
; 3896 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_subtr
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_subtr

; 3897 : 
; 3898 :     /* Subtract signed operands and set condition code */
; 3899 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 sub_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3900 :             sub_signed (&(regs->GR_L(r1)),
; 3901 :                     regs->GR_L(r2),
; 3902 :                     regs->GR_L(r3));
; 3903 : 
; 3904 :     /* Program check if fixed-point overflow */
; 3905 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_subtr
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_subtr

; 3906 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_subtr:

; 3907 : 
; 3908 : } /* end DEF_INST(subtract_distinct_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_subtract_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
tv92 = 48
n$ = 52
tv156 = 56
r3$ = 60
r1$ = 64
inst$ = 96
regs$ = 104
s370_shift_left_single_logical_distinct PROC

; 3872 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3873 : int     r1, r3;                         /* Register numbers          */
; 3874 : int     b2;                             /* Base of effective addr    */
; 3875 : VADR    effective_addr2;                /* Effective address         */
; 3876 : U32     n;                              /* Integer work area         */
; 3877 : 
; 3878 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r3$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN5@s370_shift
  00069	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN13@s370_shift
  0009c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN14@s370_shift
$LN13@s370_shift:
  000a6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@s370_shift:
  000ae	83 7c 24 30 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN6@s370_shift
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN7@s370_shift
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@s370_shift:
$LN6@s370_shift:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN8@s370_shift
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_shift:
$LN4@s370_shift:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN9@s370_shift
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_shift:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_shift

; 3879 : 
; 3880 :     /* Use rightmost six bits of operand address as shift count */
; 3881 :     n = effective_addr2 & 0x3F;

  00143	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00147	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014a	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 3882 : 
; 3883 :     /* Shift the R3 register and place the result in the R1 register */
; 3884 :     regs->GR_L(r1) = n > 31 ? 0 : regs->GR_L(r3) << n;

  0014e	83 7c 24 34 1f	 cmp	 DWORD PTR n$[rsp], 31
  00153	76 0a		 jbe	 SHORT $LN15@s370_shift
  00155	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0015d	eb 1b		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:
  0015f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r3$[rsp]
  00164	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00168	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016d	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00174	d3 e0		 shl	 eax, cl
  00176	89 44 24 38	 mov	 DWORD PTR tv156[rsp], eax
$LN16@s370_shift:
  0017a	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0017f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	8b 54 24 38	 mov	 edx, DWORD PTR tv156[rsp]
  00188	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3885 : 
; 3886 : } /* end DEF_INST(shift_left_single_logical_distinct) */

  0018f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00193	c3		 ret	 0
s370_shift_left_single_logical_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
tv92 = 48
n$ = 52
tv156 = 56
r3$ = 60
r1$ = 64
inst$ = 96
regs$ = 104
s370_shift_right_single_logical_distinct PROC

; 3851 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3852 : int     r1, r3;                         /* Register numbers          */
; 3853 : int     b2;                             /* Base of effective addr    */
; 3854 : VADR    effective_addr2;                /* Effective address         */
; 3855 : U32     n;                              /* Integer work area         */
; 3856 : 
; 3857 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r3$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN5@s370_shift
  00069	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN13@s370_shift
  0009c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN14@s370_shift
$LN13@s370_shift:
  000a6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@s370_shift:
  000ae	83 7c 24 30 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN6@s370_shift
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN7@s370_shift
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@s370_shift:
$LN6@s370_shift:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN8@s370_shift
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_shift:
$LN4@s370_shift:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN9@s370_shift
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_shift:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_shift

; 3858 : 
; 3859 :     /* Use rightmost six bits of operand address as shift count */
; 3860 :     n = effective_addr2 & 0x3F;

  00143	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00147	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014a	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 3861 : 
; 3862 :     /* Shift the R3 register and place the result in the R1 register */
; 3863 :     regs->GR_L(r1) = n > 31 ? 0 : regs->GR_L(r3) >> n;

  0014e	83 7c 24 34 1f	 cmp	 DWORD PTR n$[rsp], 31
  00153	76 0a		 jbe	 SHORT $LN15@s370_shift
  00155	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  0015d	eb 1b		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:
  0015f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r3$[rsp]
  00164	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  00168	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0016d	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00174	d3 e8		 shr	 eax, cl
  00176	89 44 24 38	 mov	 DWORD PTR tv156[rsp], eax
$LN16@s370_shift:
  0017a	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  0017f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	8b 54 24 38	 mov	 edx, DWORD PTR tv156[rsp]
  00188	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3864 : 
; 3865 : } /* end DEF_INST(shift_right_single_logical_distinct) */

  0018f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00193	c3		 ret	 0
s370_shift_right_single_logical_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
r1$ = 40
temp$2 = 44
r3$ = 48
n1$ = 52
n$ = 56
i$ = 60
b2$ = 64
tv92 = 68
tv169 = 72
n2$ = 76
j$ = 80
tv217 = 84
tv218 = 88
inst$ = 112
regs$ = 120
s370_shift_left_single_distinct PROC

; 3793 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3794 : int     r1, r3;                         /* Register numbers          */
; 3795 : int     b2;                             /* Base of effective addr    */
; 3796 : VADR    effective_addr2;                /* Effective address         */
; 3797 : U32     n, n1, n2;                      /* 32-bit operand values     */
; 3798 : U32     i, j;                           /* Integer work areas        */
; 3799 : 
; 3800 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 2c	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 2c	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 2c	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00054	8b 44 24 2c	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN8@s370_shift
  00069	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_shift:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN20@s370_shift
  0009c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN21@s370_shift
$LN20@s370_shift:
  000a6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN21@s370_shift:
  000ae	83 7c 24 44 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN9@s370_shift
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN10@s370_shift
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN10@s370_shift:
$LN9@s370_shift:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN11@s370_shift
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s370_shift:
$LN4@s370_shift:
  00114	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN12@s370_shift
  00131	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN12@s370_shift:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_shift

; 3801 : 
; 3802 :     /* Use rightmost six bits of operand address as shift count */
; 3803 :     n = effective_addr2 & 0x3F;

  00143	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00147	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014a	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 3804 : 
; 3805 :     /* Fast path if no possible overflow */
; 3806 :     if (regs->GR_L(r3) < 0x10000 && n < 16)

  0014e	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  00153	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	81 bc c1 80 02
	00 00 00 00 01
	00		 cmp	 DWORD PTR [rcx+rax*8+640], 65536 ; 00010000H
  00163	73 67		 jae	 SHORT $LN13@s370_shift
  00165	83 7c 24 38 10	 cmp	 DWORD PTR n$[rsp], 16
  0016a	73 60		 jae	 SHORT $LN13@s370_shift

; 3807 :     {
; 3808 :         regs->GR_L(r1) = regs->GR_L(r3) << n;

  0016c	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  00171	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00175	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0017a	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  00181	d3 e0		 shl	 eax, cl
  00183	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00188	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3809 :         regs->psw.cc = regs->GR_L(r1) ? 2 : 0;

  00194	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00199	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001a6	74 0a		 je	 SHORT $LN22@s370_shift
  001a8	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv169[rsp], 2
  001b0	eb 08		 jmp	 SHORT $LN23@s370_shift
$LN22@s370_shift:
  001b2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN23@s370_shift:
  001ba	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv169[rsp]
  001c4	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3810 :         return;

  001c7	e9 29 01 00 00	 jmp	 $LN1@s370_shift
$LN13@s370_shift:

; 3811 :     }
; 3812 : 
; 3813 :     /* Load the numeric and sign portions from the R3 register */
; 3814 :     n1 = regs->GR_L(r3) & 0x7FFFFFFF;

  001cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  001d1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001dd	0f ba f0 1f	 btr	 eax, 31
  001e1	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 3815 :     n2 = regs->GR_L(r3) & 0x80000000;

  001e5	48 63 44 24 30	 movsxd	 rax, DWORD PTR r3$[rsp]
  001ea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001f6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001fb	89 44 24 4c	 mov	 DWORD PTR n2$[rsp], eax

; 3816 : 
; 3817 :     /* Shift the numeric portion left n positions */
; 3818 :     for (i = 0, j = 0; i < n; i++)

  001ff	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00207	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0020f	eb 0a		 jmp	 SHORT $LN7@s370_shift
$LN5@s370_shift:
  00211	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  00215	ff c0		 inc	 eax
  00217	89 44 24 3c	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_shift:
  0021b	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  0021f	39 44 24 3c	 cmp	 DWORD PTR i$[rsp], eax
  00223	73 23		 jae	 SHORT $LN6@s370_shift

; 3819 :     {
; 3820 :         /* Shift bits 1-31 left one bit position */
; 3821 :         n1 <<= 1;

  00225	8b 44 24 34	 mov	 eax, DWORD PTR n1$[rsp]
  00229	d1 e0		 shl	 eax, 1
  0022b	89 44 24 34	 mov	 DWORD PTR n1$[rsp], eax

; 3822 : 
; 3823 :         /* Overflow if bit shifted out is unlike the sign bit */
; 3824 :         if ((n1 & 0x80000000) != n2)

  0022f	8b 44 24 34	 mov	 eax, DWORD PTR n1$[rsp]
  00233	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00238	3b 44 24 4c	 cmp	 eax, DWORD PTR n2$[rsp]
  0023c	74 08		 je	 SHORT $LN14@s370_shift

; 3825 :             j = 1;

  0023e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
$LN14@s370_shift:

; 3826 :     }

  00246	eb c9		 jmp	 SHORT $LN5@s370_shift
$LN6@s370_shift:

; 3827 : 
; 3828 :     /* Load the updated value into the R1 register */
; 3829 :     regs->GR_L(r1) = (n1 & 0x7FFFFFFF) | n2;

  00248	8b 44 24 34	 mov	 eax, DWORD PTR n1$[rsp]
  0024c	0f ba f0 1f	 btr	 eax, 31
  00250	0b 44 24 4c	 or	 eax, DWORD PTR n2$[rsp]
  00254	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00259	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0025e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3830 : 
; 3831 :     /* Condition code 3 and program check if overflow occurred */
; 3832 :     if (j)

  00265	83 7c 24 50 00	 cmp	 DWORD PTR j$[rsp], 0
  0026a	74 30		 je	 SHORT $LN15@s370_shift

; 3833 :     {
; 3834 :         regs->psw.cc = 3;

  0026c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00271	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 3835 :         if ( FOMASK(&regs->psw) )

  00275	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0027a	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  0027e	83 e0 08	 and	 eax, 8
  00281	85 c0		 test	 eax, eax
  00283	74 15		 je	 SHORT $LN16@s370_shift

; 3836 :             regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  00285	ba 08 00 00 00	 mov	 edx, 8
  0028a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00294	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s370_shift:

; 3837 :         return;

  0029a	eb 59		 jmp	 SHORT $LN1@s370_shift
$LN15@s370_shift:

; 3838 :     }
; 3839 : 
; 3840 :     /* Set the condition code */
; 3841 :     regs->psw.cc = (S32)regs->GR_L(r1) > 0 ? 2 :

  0029c	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  002a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a6	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  002ae	7e 0a		 jle	 SHORT $LN26@s370_shift
  002b0	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv218[rsp], 2
  002b8	eb 2e		 jmp	 SHORT $LN27@s370_shift
$LN26@s370_shift:
  002ba	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  002bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  002cc	7d 0a		 jge	 SHORT $LN24@s370_shift
  002ce	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv217[rsp], 1
  002d6	eb 08		 jmp	 SHORT $LN25@s370_shift
$LN24@s370_shift:
  002d8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN25@s370_shift:
  002e0	8b 44 24 54	 mov	 eax, DWORD PTR tv217[rsp]
  002e4	89 44 24 58	 mov	 DWORD PTR tv218[rsp], eax
$LN27@s370_shift:
  002e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002ed	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv218[rsp]
  002f2	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN1@s370_shift:

; 3842 :                    (S32)regs->GR_L(r1) < 0 ? 1 : 0;
; 3843 : 
; 3844 : } /* end DEF_INST(shift_left_single_distinct) */

  002f5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002f9	c3		 ret	 0
s370_shift_left_single_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
r1$ = 44
b2$ = 48
tv92 = 52
tv156 = 56
r3$ = 60
n$ = 64
tv163 = 68
tv177 = 72
tv178 = 76
inst$ = 96
regs$ = 104
s370_shift_right_single_distinct PROC

; 3766 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3767 : int     r1, r3;                         /* Register numbers          */
; 3768 : int     b2;                             /* Base of effective addr    */
; 3769 : VADR    effective_addr2;                /* Effective address         */
; 3770 : U32     n;                              /* Integer work area         */
; 3771 : 
; 3772 :     RSY(inst, regs, r1, r3, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 0c	 shr	 eax, 12
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r3$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  00058	c1 e8 14	 shr	 eax, 20
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00062	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  00067	74 1d		 je	 SHORT $LN5@s370_shift
  00069	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007e	03 c8		 add	 ecx, eax
  00080	8b c1		 mov	 eax, ecx
  00082	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 04	 imul	 rax, rax, 4
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN13@s370_shift
  0009c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN14@s370_shift
$LN13@s370_shift:
  000a6	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN14@s370_shift:
  000ae	83 7c 24 34 00	 cmp	 DWORD PTR tv92[rsp], 0
  000b3	74 3b		 je	 SHORT $LN6@s370_shift
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	c1 e0 0c	 shl	 eax, 12
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000ce	0b c8		 or	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000d6	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000da	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN7@s370_shift
  000e3	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000e7	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  000ec	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN7@s370_shift:
$LN6@s370_shift:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00100	33 c0		 xor	 eax, eax
  00102	83 f8 06	 cmp	 eax, 6
  00105	74 0d		 je	 SHORT $LN8@s370_shift
  00107	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0010b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00110	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN8@s370_shift:
$LN4@s370_shift:
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011d	48 83 c0 06	 add	 rax, 6
  00121	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 06	 cmp	 eax, 6
  0012f	74 0c		 je	 SHORT $LN9@s370_shift
  00131	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00136	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@s370_shift:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 d1		 jne	 SHORT $LN4@s370_shift

; 3773 : 
; 3774 :     /* Use rightmost six bits of operand address as shift count */
; 3775 :     n = effective_addr2 & 0x3F;

  00143	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00147	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014a	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 3776 : 
; 3777 :     /* Shift signed value of the R3 register, result in R1 register */
; 3778 :     regs->GR_L(r1) = n > 30 ?

  0014e	83 7c 24 40 1e	 cmp	 DWORD PTR n$[rsp], 30
  00153	76 30		 jbe	 SHORT $LN17@s370_shift
  00155	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r3$[rsp]
  0015a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00167	7d 0a		 jge	 SHORT $LN15@s370_shift
  00169	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR tv156[rsp], -1
  00171	eb 08		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:
  00173	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN16@s370_shift:
  0017b	8b 44 24 38	 mov	 eax, DWORD PTR tv156[rsp]
  0017f	89 44 24 44	 mov	 DWORD PTR tv163[rsp], eax
  00183	eb 1b		 jmp	 SHORT $LN18@s370_shift
$LN17@s370_shift:
  00185	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r3$[rsp]
  0018a	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  0018e	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00193	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0019a	d3 f8		 sar	 eax, cl
  0019c	89 44 24 44	 mov	 DWORD PTR tv163[rsp], eax
$LN18@s370_shift:
  001a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	8b 54 24 44	 mov	 edx, DWORD PTR tv163[rsp]
  001ae	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3779 :                     ((S32)regs->GR_L(r3) < 0 ? -1 : 0) :
; 3780 :                     (S32)regs->GR_L(r3) >> n;
; 3781 : 
; 3782 :     /* Set the condition code */
; 3783 :     regs->psw.cc = ((S32)regs->GR_L(r1) > 0) ? 2 :

  001b5	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001c7	7e 0a		 jle	 SHORT $LN21@s370_shift
  001c9	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv178[rsp], 2
  001d1	eb 2e		 jmp	 SHORT $LN22@s370_shift
$LN21@s370_shift:
  001d3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  001e5	7d 0a		 jge	 SHORT $LN19@s370_shift
  001e7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN20@s370_shift
$LN19@s370_shift:
  001f1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN20@s370_shift:
  001f9	8b 44 24 48	 mov	 eax, DWORD PTR tv177[rsp]
  001fd	89 44 24 4c	 mov	 DWORD PTR tv178[rsp], eax
$LN22@s370_shift:
  00201	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00206	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv178[rsp]
  0020b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3784 :                    (((S32)regs->GR_L(r1) < 0) ? 1 : 0);
; 3785 : 
; 3786 : } /* end DEF_INST(shift_right_single_distinct) */

  0020e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00212	c3		 ret	 0
s370_shift_right_single_distinct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
s370_or_distinct_register PROC

; 3728 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3729 : int     r1, r2, r3;                     /* Values of R fields        */
; 3730 : 
; 3731 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_or_di:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_or_di
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_or_di:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_or_di

; 3732 : 
; 3733 :     /* OR second and third operands and put result in first operand */
; 3734 :     regs->GR_L(r1) = regs->GR_L(r2) | regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	0b c1		 or	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3735 : 
; 3736 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3737 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@s370_or_di
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@s370_or_di
$LN7@s370_or_di:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@s370_or_di:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3738 : 
; 3739 : } /* end DEF_INST(or_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
s370_or_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
s370_exclusive_or_distinct_register PROC

; 3690 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3691 : int     r1, r2, r3;                     /* Values of R fields        */
; 3692 : 
; 3693 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_exclu:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_exclu
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_exclu:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_exclu

; 3694 : 
; 3695 :     /* XOR second and third operands and put result in first operand */
; 3696 :     regs->GR_L(r1) = regs->GR_L(r2) ^ regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	33 c1		 xor	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3697 : 
; 3698 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3699 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@s370_exclu
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@s370_exclu
$LN7@s370_exclu:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@s370_exclu:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3700 : 
; 3701 : } /* end DEF_INST(exclusive_or_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
s370_exclusive_or_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
tv134 = 40
r2$ = 44
r3$ = 48
inst$ = 80
regs$ = 88
s370_and_distinct_register PROC

; 3652 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3653 : int     r1, r2, r3;                     /* Values of R fields        */
; 3654 : 
; 3655 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_and_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_and_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_and_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_and_d

; 3656 : 
; 3657 :     /* AND second and third operands and put result in first operand */
; 3658 :     regs->GR_L(r1) = regs->GR_L(r2) & regs->GR_L(r3);

  00079	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  0009c	23 c1		 and	 eax, ecx
  0009e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3659 : 
; 3660 :     /* Set condition code 1 if result is non-zero, otherwise 0 */
; 3661 :     regs->psw.cc = (regs->GR_L(r1)) ? 1 : 0;

  000af	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c1	74 0a		 je	 SHORT $LN7@s370_and_d
  000c3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN8@s370_and_d
$LN7@s370_and_d:
  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN8@s370_and_d:
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv134[rsp]
  000df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3662 : 
; 3663 : } /* end DEF_INST(and_distinct_register) */

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
s370_and_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv146 = 48
tv129 = 56
tv144 = 64
inst$ = 96
regs$ = 104
s370_add_logical_distinct_signed_halfword_immediate PROC

; 3614 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3615 : int     r1, r3;                         /* Values of R fields        */
; 3616 : U16     i2;                             /* 16-bit immediate operand  */
; 3617 : 
; 3618 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_l:
  0004d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@s370_add_l
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_add_l:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@s370_add_l

; 3619 : 
; 3620 :     /* Add operands and set condition code */
; 3621 :     regs->psw.cc = (S16)i2 < 0 ?

  0007c	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  00081	85 c0		 test	 eax, eax
  00083	7d 45		 jge	 SHORT $LN7@s370_add_l
  00085	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  0008a	f7 d8		 neg	 eax
  0008c	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00091	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00096	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0009b	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000a3	48 89 54 24 38	 mov	 QWORD PTR tv129[rsp], rdx
  000a8	44 8b c0	 mov	 r8d, eax
  000ab	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR tv129[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	e8 00 00 00 00	 call	 sub_logical
  000c4	89 44 24 30	 mov	 DWORD PTR tv146[rsp], eax
  000c8	eb 41		 jmp	 SHORT $LN8@s370_add_l
$LN7@s370_add_l:
  000ca	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000cf	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000d4	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000d9	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000de	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  000e6	48 89 54 24 40	 mov	 QWORD PTR tv144[rsp], rdx
  000eb	44 8b c0	 mov	 r8d, eax
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000fa	48 8b 44 24 40	 mov	 rax, QWORD PTR tv144[rsp]
  000ff	48 8b c8	 mov	 rcx, rax
  00102	e8 00 00 00 00	 call	 add_logical
  00107	89 44 24 30	 mov	 DWORD PTR tv146[rsp], eax
$LN8@s370_add_l:
  0010b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00110	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv146[rsp]
  00115	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3622 :         sub_logical (&(regs->GR_L(r1)), regs->GR_L(r3), (S32)(-(S16)i2)) :
; 3623 :         add_logical (&(regs->GR_L(r1)), regs->GR_L(r3), (S32)(S16)i2);
; 3624 : 
; 3625 : } /* end DEF_INST(add_logical_distinct_signed_halfword_immediate) */

  00118	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011c	c3		 ret	 0
s370_add_logical_distinct_signed_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_logical_distinct_register PROC

; 3578 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3579 : int     r1, r2, r3;                     /* Values of R fields        */
; 3580 : 
; 3581 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_l:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_l
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_l:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_l

; 3582 : 
; 3583 :     /* Add signed operands and set condition code */
; 3584 :     regs->psw.cc = add_logical (&(regs->GR_L(r1)),

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_logical
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3585 :                                   regs->GR_L(r2),
; 3586 :                                   regs->GR_L(r3));
; 3587 : 
; 3588 : } /* end DEF_INST(add_logical_distinct_register) */

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
s370_add_logical_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r3$ = 40
r1$ = 44
tv94 = 48
inst$ = 80
regs$ = 88
s370_add_distinct_halfword_immediate PROC

; 3532 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3533 : int     r1, r3;                         /* Values of R fields        */
; 3534 : U16     i2;                             /* 16-bit immediate operand  */
; 3535 : 
; 3536 :     RIE(inst, regs, r1, r3, i2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00031	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00035	c1 e8 10	 shr	 eax, 16
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 28	 mov	 DWORD PTR r3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 14	 shr	 eax, 20
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_d:
  0004d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 83 c0 06	 add	 rax, 6
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00063	33 c0		 xor	 eax, eax
  00065	83 f8 06	 cmp	 eax, 6
  00068	74 0c		 je	 SHORT $LN5@s370_add_d
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_add_d:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d1		 jne	 SHORT $LN4@s370_add_d

; 3537 : 
; 3538 :     /* Add signed operands and set condition code */
; 3539 :     regs->psw.cc = add_signed (&(regs->GR_L(r1)),

  0007c	48 63 44 24 28	 movsxd	 rax, DWORD PTR r3$[rsp]
  00081	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  00086	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0008b	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00090	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00098	48 89 54 24 30	 mov	 QWORD PTR tv94[rsp], rdx
  0009d	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000a2	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000aa	8b d1		 mov	 edx, ecx
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 add_signed
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3540 :                                  (S16)i2,
; 3541 :                                  regs->GR_L(r3));
; 3542 : 
; 3543 :     /* Program check if fixed-point overflow */
; 3544 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000ca	83 f8 03	 cmp	 eax, 3
  000cd	75 25		 jne	 SHORT $LN6@s370_add_d
  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000d8	83 e0 08	 and	 eax, 8
  000db	85 c0		 test	 eax, eax
  000dd	74 15		 je	 SHORT $LN6@s370_add_d

; 3545 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000df	ba 08 00 00 00	 mov	 edx, 8
  000e4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_d:

; 3546 : 
; 3547 : } /* end DEF_INST(add_distinct_halfword_immediate) */

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
s370_add_distinct_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r3$ = 36
r2$ = 40
r1$ = 44
tv129 = 48
inst$ = 80
regs$ = 88
s370_add_distinct_register PROC

; 3487 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3488 : int     r1, r2, r3;                     /* Values of R fields        */
; 3489 : 
; 3490 :     RRR(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 24	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_d:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_add_d
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_d:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_add_d

; 3491 : 
; 3492 :     /* Add signed operands and set condition code */
; 3493 :     regs->psw.cc =

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r3$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  00095	48 89 54 24 30	 mov	 QWORD PTR tv129[rsp], rdx
  0009a	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  000a7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	8b 94 c8 80 02
	00 00		 mov	 edx, DWORD PTR [rax+rcx*8+640]
  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv129[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 add_signed
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 3494 :             add_signed (&(regs->GR_L(r1)),
; 3495 :                     regs->GR_L(r2),
; 3496 :                     regs->GR_L(r3));
; 3497 : 
; 3498 :     /* Program check if fixed-point overflow */
; 3499 :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  000d1	83 f8 03	 cmp	 eax, 3
  000d4	75 25		 jne	 SHORT $LN6@s370_add_d
  000d6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000db	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  000df	83 e0 08	 and	 eax, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 15		 je	 SHORT $LN6@s370_add_d

; 3500 :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  000e6	ba 08 00 00 00	 mov	 edx, 8
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_d:

; 3501 : 
; 3502 : } /* end DEF_INST(add_distinct_register) */

  000fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ff	c3		 ret	 0
s370_add_distinct_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
r1$ = 44
offset$1 = 48
tv130 = 56
inst$ = 80
regs$ = 88
s370_store_relative_long_long PROC

; 2286 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2287 : int     r1;                             /* Register number           */
; 2288 : VADR    effective_addr2;                /* Relative operand address  */
; 2289 : 
; 2290 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@s370_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@s370_store
$LN8@s370_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@s370_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@s370_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@s370_store
$LN12@s370_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@s370_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN14@s370_store
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
$LN15@s370_store:
  000dd	8b 44 24 38	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_store:
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_store
  0011e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_store:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_store

; 2291 : 
; 2292 :     /* Program check if operand not on doubleword boundary */
; 2293 :     DW_CHECK(effective_addr2, regs);

  00130	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00134	83 e0 07	 and	 eax, 7
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN6@s370_store
  0013b	ba 06 00 00 00	 mov	 edx, 6
  00140	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_store:

; 2294 : 
; 2295 :     /* Store R1 register in instruction address space */
; 2296 :     ARCH_DEP(vstore8) ( regs->GR_G(r1), effective_addr2, USE_INST_SPACE, regs );

  00150	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00155	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  0015a	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00160	8b 54 24 28	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00171	e8 00 00 00 00	 call	 s370_vstore8

; 2297 : 
; 2298 : } /* end DEF_INST(store_relative_long_long) */

  00176	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017a	c3		 ret	 0
s370_store_relative_long_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
r1$ = 44
offset$1 = 48
tv130 = 56
inst$ = 80
regs$ = 88
s370_store_relative_long PROC

; 2267 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2268 : int     r1;                             /* Register number           */
; 2269 : VADR    effective_addr2;                /* Relative operand address  */
; 2270 : 
; 2271 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@s370_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@s370_store
$LN8@s370_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@s370_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@s370_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@s370_store
$LN12@s370_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@s370_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN14@s370_store
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN15@s370_store
$LN14@s370_store:
  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
$LN15@s370_store:
  000dd	8b 44 24 38	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_store:
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_store
  0011e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_store:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_store

; 2272 : 
; 2273 :     /* Program check if operand not on fullword boundary */
; 2274 :     FW_CHECK(effective_addr2, regs);

  00130	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00134	83 e0 03	 and	 eax, 3
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN6@s370_store
  0013b	ba 06 00 00 00	 mov	 edx, 6
  00140	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_store:

; 2275 : 
; 2276 :     /* Store low 4 bytes of R1 register in instruction address space */
; 2277 :     ARCH_DEP(vstore4) ( regs->GR_L(r1), effective_addr2, USE_INST_SPACE, regs );

  00150	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00155	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  0015a	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00160	8b 54 24 28	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00170	e8 00 00 00 00	 call	 s370_vstore4

; 2278 : 
; 2279 : } /* end DEF_INST(store_relative_long) */

  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
s370_store_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
r1$ = 40
effective_addr2$ = 44
offset$1 = 48
tv130 = 56
inst$ = 80
regs$ = 88
s370_store_halfword_relative_long PROC

; 2251 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2252 : int     r1;                             /* Register number           */
; 2253 : VADR    effective_addr2;                /* Relative operand address  */
; 2254 : 
; 2255 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_store
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_store
$LN7@s370_store:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_store:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_store
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_store
$LN11@s370_store:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_store:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_store
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_store
$LN13@s370_store:
  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_store:
  000dd	8b 44 24 38	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 2c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_store:
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_store
  0011e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_store:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_store

; 2256 : 
; 2257 :     /* Store low 2 bytes of R1 register in instruction address space */
; 2258 :     ARCH_DEP(vstore2) ( regs->GR_LHL(r1), effective_addr2, USE_INST_SPACE, regs );

  00130	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  0013a	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00140	8b 54 24 2c	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00144	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	0f b7 8c c1 80
	02 00 00	 movzx	 ecx, WORD PTR [rcx+rax*8+640]
  00151	e8 00 00 00 00	 call	 s370_vstore2

; 2259 : 
; 2260 : } /* end DEF_INST(store_halfword_relative_long) */

  00156	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015a	c3		 ret	 0
s370_store_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
m1$ = 44
offset$1 = 48
tv130 = 56
inst$ = 80
regs$ = 88
s370_prefetch_data_relative_long PROC

; 2032 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2033 : int     m1;                             /* Mask value                */
; 2034 : VADR    effective_addr2;                /* Effective address         */
; 2035 : 
; 2036 :     RIL_A(inst, regs, m1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 30	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_prefe
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_prefe
$LN7@s370_prefe:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_prefe:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_prefe
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_prefe
$LN11@s370_prefe:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_prefe:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_prefe
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_prefe
$LN13@s370_prefe:
  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 30	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_prefe:
  000dd	8b 44 24 38	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR m1$[rsp], eax
$LN4@s370_prefe:
  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_prefe
  0011e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_prefe:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_prefe

; 2037 : 
; 2038 :     /* On Hercules the Prefetch Data instruction acts as a no-op */
; 2039 : 
; 2040 : } /* end DEF_INST(prefetch_data_relative_long) */

  00130	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00134	c3		 ret	 0
s370_prefetch_data_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
x2$ = 44
b2$ = 48
tv131 = 52
m1$ = 56
inst$ = 80
regs$ = 88
s370_prefetch_data PROC

; 2015 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2016 : int     m1;                             /* Mask value                */
; 2017 : int     x2;                             /* Index register            */
; 2018 : int     b2;                             /* Base of effective addr    */
; 2019 : VADR    effective_addr2;                /* Effective address         */
; 2020 : 
; 2021 :     RXY(inst, regs, m1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR m1$[rsp], eax
  00054	83 7c 24 2c 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_prefe
  0005b	48 63 44 24 2c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_prefe:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_prefe
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_prefe:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_prefe
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_prefe
$LN14@s370_prefe:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_prefe:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_prefe
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_prefe
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_prefe:
$LN7@s370_prefe:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_prefe
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_prefe:
$LN4@s370_prefe:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_prefe
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_prefe:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_prefe

; 2022 : 
; 2023 :     /* The Prefetch Data instruction acts as a no-op */
; 2024 : 
; 2025 : } /* end DEF_INST(prefetch_data) */

  00167	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016b	c3		 ret	 0
s370_prefetch_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
r1$ = 44
b2$ = 48
x2$ = 52
tv131 = 56
n$ = 60
tv178 = 64
inst$ = 96
regs$ = 104
s370_multiply_y PROC

; 1935 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1936 : int     r1;                             /* Value of R field          */
; 1937 : int     x2;                             /* Index register            */
; 1938 : int     b2;                             /* Base of effective addr    */
; 1939 : VADR    effective_addr2;                /* Effective address         */
; 1940 : U32     n;                              /* 32-bit operand values     */
; 1941 : 
; 1942 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 34 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_multi
  0005b	48 63 44 24 34	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_multi
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN15@s370_multi
  000c0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN16@s370_multi
$LN15@s370_multi:
  000ca	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_multi:
  000d2	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_multi
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_multi
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_multi:
$LN7@s370_multi:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_multi
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
$LN4@s370_multi:
  00138	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_multi
  00155	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_multi

; 1943 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1944 : 
; 1945 :     ODD_CHECK(r1, regs);

  00167	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0016b	83 e0 01	 and	 eax, 1
  0016e	85 c0		 test	 eax, eax
  00170	74 15		 je	 SHORT $LN11@s370_multi
  00172	ba 06 00 00 00	 mov	 edx, 6
  00177	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00181	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_multi:

; 1946 : 
; 1947 :     /* Load second operand from operand address */
; 1948 :     n = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00187	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0018c	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  00190	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00194	e8 00 00 00 00	 call	 s370_vfetch4
  00199	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 1949 : 
; 1950 :     /* Multiply r1+1 by n and place result in r1 and r1+1 */
; 1951 :     mul_signed (&(regs->GR_L(r1)), &(regs->GR_L(r1+1)),

  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001a1	ff c0		 inc	 eax
  001a3	48 98		 cdqe
  001a5	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001a9	ff c1		 inc	 ecx
  001ab	48 63 c9	 movsxd	 rcx, ecx
  001ae	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001b3	48 8d 8c ca 80
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+640]
  001bb	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR r1$[rsp]
  001c0	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001c5	49 8d 94 d0 80
	02 00 00	 lea	 rdx, QWORD PTR [r8+rdx*8+640]
  001cd	48 89 54 24 40	 mov	 QWORD PTR tv178[rsp], rdx
  001d2	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR n$[rsp]
  001d7	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  001dc	45 8b 84 c0 80
	02 00 00	 mov	 r8d, DWORD PTR [r8+rax*8+640]
  001e4	48 8b d1	 mov	 rdx, rcx
  001e7	48 8b 44 24 40	 mov	 rax, QWORD PTR tv178[rsp]
  001ec	48 8b c8	 mov	 rcx, rax
  001ef	e8 00 00 00 00	 call	 mul_signed

; 1952 :                     regs->GR_L(r1+1),
; 1953 :                     n);
; 1954 : 
; 1955 : } /* end DEF_INST(multiply_y) */

  001f4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f8	c3		 ret	 0
s370_multiply_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
r1$ = 32
i2$ = 36
opcd$ = 40
inst$ = 64
regs$ = 72
s370_multiply_single_immediate_fullword PROC

; 1899 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1900 : int     r1;                             /* Register number           */
; 1901 : int     opcd;                           /* Opcode                    */
; 1902 : U32     i2;                             /* 32-bit operand value      */
; 1903 : 
; 1904 :     RIL(inst, regs, r1, opcd, i2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00043	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00047	83 e0 0f	 and	 eax, 15
  0004a	89 44 24 28	 mov	 DWORD PTR opcd$[rsp], eax
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 6b c0 01	 imul	 rax, rax, 1
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	c1 f8 04	 sar	 eax, 4
  00063	83 e0 0f	 and	 eax, 15
  00066	89 44 24 20	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_multi:
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00073	48 83 c0 06	 add	 rax, 6
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00080	33 c0		 xor	 eax, eax
  00082	83 f8 06	 cmp	 eax, 6
  00085	74 0c		 je	 SHORT $LN5@s370_multi
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_multi:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	75 d1		 jne	 SHORT $LN4@s370_multi

; 1905 : 
; 1906 :     /* Multiply signed operands ignoring overflow */
; 1907 :     regs->GR_L(r1) = (S32)regs->GR_L(r1) * (S32)i2;

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000aa	0f af 44 24 24	 imul	 eax, DWORD PTR i2$[rsp]
  000af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR r1$[rsp]
  000b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  000b9	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1908 : 
; 1909 : } /* end DEF_INST(multiply_single_immediate_fullword) */

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
s370_multiply_single_immediate_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr2$ = 32
disp2$1 = 36
temp$2 = 40
b2$ = 44
x2$ = 48
tv131 = 52
r1$ = 56
n$ = 60
inst$ = 80
regs$ = 88
s370_multiply_halfword_y PROC

; 1843 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1844 : int     r1;                             /* Value of R field          */
; 1845 : int     x2;                             /* Index register            */
; 1846 : int     b2;                             /* Base of effective addr    */
; 1847 : VADR    effective_addr2;                /* Effective address         */
; 1848 : S32     n;                              /* 32-bit operand values     */
; 1849 : 
; 1850 :     RXY(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$2[rsp], eax
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR effective_addr2$[rsp], 0
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0003c	c1 e8 10	 shr	 eax, 16
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0004a	c1 e8 14	 shr	 eax, 20
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00059	74 1d		 je	 SHORT $LN5@s370_multi
  0005b	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006c	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00070	03 c8		 add	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_multi:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR temp$2[rsp]
  0007c	c1 e8 0c	 shr	 eax, 12
  0007f	83 e0 0f	 and	 eax, 15
  00082	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00086	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0008b	74 1d		 je	 SHORT $LN6@s370_multi
  0008d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00092	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a2	03 c8		 add	 ecx, eax
  000a4	8b c1		 mov	 eax, ecx
  000a6	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_multi:
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 04	 imul	 rax, rax, 4
  000b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN14@s370_multi
  000c0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN15@s370_multi
$LN14@s370_multi:
  000ca	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@s370_multi:
  000d2	83 7c 24 34 00	 cmp	 DWORD PTR tv131[rsp], 0
  000d7	74 3b		 je	 SHORT $LN7@s370_multi
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	48 6b c0 04	 imul	 rax, rax, 4
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000eb	c1 e0 0c	 shl	 eax, 12
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000f2	0b c8		 or	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
  000fa	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  000fe	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00103	85 c0		 test	 eax, eax
  00105	74 0d		 je	 SHORT $LN8@s370_multi
  00107	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  0010b	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  00110	89 44 24 24	 mov	 DWORD PTR disp2$1[rsp], eax
$LN8@s370_multi:
$LN7@s370_multi:
  00114	8b 44 24 24	 mov	 eax, DWORD PTR disp2$1[rsp]
  00118	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0011c	03 c8		 add	 ecx, eax
  0011e	8b c1		 mov	 eax, ecx
  00120	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0d		 je	 SHORT $LN9@s370_multi
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0012f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00134	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_multi:
$LN4@s370_multi:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 83 c0 06	 add	 rax, 6
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0014e	33 c0		 xor	 eax, eax
  00150	83 f8 06	 cmp	 eax, 6
  00153	74 0c		 je	 SHORT $LN10@s370_multi
  00155	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_multi:
  00161	33 c0		 xor	 eax, eax
  00163	85 c0		 test	 eax, eax
  00165	75 d1		 jne	 SHORT $LN4@s370_multi

; 1851 :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );
; 1852 : 
; 1853 :     /* Load 2 bytes from operand address */
; 1854 :     n = (S16)ARCH_DEP(vfetch2) ( effective_addr2, b2, regs );

  00167	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0016c	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00170	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00174	e8 00 00 00 00	 call	 s370_vfetch2
  00179	98		 cwde
  0017a	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 1855 : 
; 1856 :     /* Multiply R1 register by n, ignore leftmost 32 bits of
; 1857 :        result, and place rightmost 32 bits in R1 register */
; 1858 :     mul_signed ((U32 *)&n, &(regs->GR_L(r1)), regs->GR_L(r1), n);

  0017e	48 63 44 24 38	 movsxd	 rax, DWORD PTR r1$[rsp]
  00183	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00188	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	48 8d 8c ca 80
	02 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+640]
  00195	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR n$[rsp]
  0019a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0019f	44 8b 84 c2 80
	02 00 00	 mov	 r8d, DWORD PTR [rdx+rax*8+640]
  001a7	48 8b d1	 mov	 rdx, rcx
  001aa	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR n$[rsp]
  001af	e8 00 00 00 00	 call	 mul_signed

; 1859 : 
; 1860 : } /* end DEF_INST(multiply_halfword_y) */

  001b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b8	c3		 ret	 0
s370_multiply_halfword_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
n$ = 48
inst$ = 80
regs$ = 88
s370_move_long_from_halfword_immediate PROC

; 1821 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1822 : int     b1;                             /* Base of effective addr    */
; 1823 : VADR    effective_addr1;                /* Effective address         */
; 1824 : S16     i2;                             /* 16-bit immediate value    */
; 1825 : S64     n;                              /* Sign-extended value of i2 */
; 1826 : 
; 1827 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_move_
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_move_:
$LN4@s370_move_:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_move_
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_move_:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_move_

; 1828 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1829 : 
; 1830 :     /* Sign-extend 16-bit immediate value to 64 bits */
; 1831 :     n = i2;

  000c1	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000c7	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 1832 : 
; 1833 :     /* Store 8-byte value at operand address */
; 1834 :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );

  000cc	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b1$[rsp]
  000d6	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  000da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000df	e8 00 00 00 00	 call	 s370_vstore8

; 1835 : 
; 1836 : } /* end DEF_INST(move_long_from_halfword_immediate) */

  000e4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e8	c3		 ret	 0
s370_move_long_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
inst$ = 64
regs$ = 72
s370_move_halfword_from_halfword_immediate PROC

; 1803 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1804 : int     b1;                             /* Base of effective addr    */
; 1805 : VADR    effective_addr1;                /* Effective address         */
; 1806 : S16     i2;                             /* 16-bit immediate value    */
; 1807 : 
; 1808 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_move_
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_move_:
$LN4@s370_move_:
  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_move_
  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_move_:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_move_

; 1809 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1810 : 
; 1811 :     /* Store 16-bit immediate value at operand address */
; 1812 :     ARCH_DEP(vstore2) ( i2, effective_addr1, b1, regs );

  000c1	4c 8b 4c 24 48	 mov	 r9, QWORD PTR regs$[rsp]
  000c6	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b1$[rsp]
  000cb	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  000cf	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  000d4	e8 00 00 00 00	 call	 s370_vstore2

; 1813 : 
; 1814 : } /* end DEF_INST(move_halfword_from_halfword_immediate) */

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	c3		 ret	 0
s370_move_halfword_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
n$ = 48
inst$ = 80
regs$ = 88
s370_move_fullword_from_halfword_immediate PROC

; 1781 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1782 : int     b1;                             /* Base of effective addr    */
; 1783 : VADR    effective_addr1;                /* Effective address         */
; 1784 : S16     i2;                             /* 16-bit immediate value    */
; 1785 : S32     n;                              /* Sign-extended value of i2 */
; 1786 : 
; 1787 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_move_
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_move_:
$LN4@s370_move_:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_move_
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_move_:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_move_

; 1788 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1789 : 
; 1790 :     /* Sign-extend 16-bit immediate value to 32 bits */
; 1791 :     n = i2;

  000c1	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000c6	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 1792 : 
; 1793 :     /* Store 4-byte value at operand address */
; 1794 :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );

  000ca	4c 8b 4c 24 58	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 2c	 mov	 r8d, DWORD PTR b1$[rsp]
  000d4	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  000d8	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  000dc	e8 00 00 00 00	 call	 s370_vstore4

; 1795 : 
; 1796 : } /* end DEF_INST(move_fullword_from_halfword_immediate) */

  000e1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e5	c3		 ret	 0
s370_move_fullword_from_halfword_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
r1$ = 44
n$ = 48
offset$1 = 56
tv130 = 64
inst$ = 96
regs$ = 104
s370_load_relative_long PROC

; 1706 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1707 : int     r1;                             /* Register number           */
; 1708 : VADR    effective_addr2;                /* Relative operand address  */
; 1709 : U32     n;                              /* Relative operand value    */
; 1710 : 
; 1711 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@s370_load_
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@s370_load_
$LN8@s370_load_:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@s370_load_:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@s370_load_
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@s370_load_
$LN12@s370_load_:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@s370_load_:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN14@s370_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
$LN15@s370_load_:
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_load_
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_load_:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_load_

; 1712 : 
; 1713 :     /* Program check if operand not on fullword boundary */
; 1714 :     FW_CHECK(effective_addr2, regs);

  00130	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00134	83 e0 03	 and	 eax, 3
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN6@s370_load_
  0013b	ba 06 00 00 00	 mov	 edx, 6
  00140	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 1715 : 
; 1716 :     PER_ZEROADDR_XCHECK( regs, r1 );
; 1717 : 
; 1718 :     /* Load relative operand from instruction address space */
; 1719 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  00150	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00155	ba ff ff ff ff	 mov	 edx, -1
  0015a	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0015e	e8 00 00 00 00	 call	 s370_vfetch4
  00163	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 1720 : 
; 1721 :     /* Load operand value into R1 register */
; 1722 :     regs->GR_L(r1) = n;

  00167	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  00175	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1723 : 
; 1724 : } /* end DEF_INST(load_relative_long) */

  0017c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00180	c3		 ret	 0
s370_load_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
effective_addr2$ = 44
r1$ = 48
offset$1 = 56
tv130 = 64
inst$ = 96
regs$ = 104
s370_load_logical_halfword_relative_long PROC

; 1639 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1640 : int     r1;                             /* Register number           */
; 1641 : VADR    effective_addr2;                /* Relative operand address  */
; 1642 : U16     n;                              /* Relative operand value    */
; 1643 : 
; 1644 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_load_
$LN7@s370_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_load_
$LN11@s370_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_load_:
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 2c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_load_
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_load_:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_load_

; 1645 : 
; 1646 :     /* Load relative operand from instruction address space */
; 1647 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00130	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00135	ba ff ff ff ff	 mov	 edx, -1
  0013a	8b 4c 24 2c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_vfetch2
  00143	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1648 : 
; 1649 :     /* Zero-extend operand value and load into R1 register */
; 1650 :     regs->GR_L(r1) = n;

  00148	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  0014d	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  00152	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	89 8c c2 80 02
	00 00		 mov	 DWORD PTR [rdx+rax*8+640], ecx

; 1651 : 
; 1652 : } /* end DEF_INST(load_logical_halfword_relative_long) */

  0015e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00162	c3		 ret	 0
s370_load_logical_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
effective_addr2$ = 44
r1$ = 48
offset$1 = 56
tv130 = 64
inst$ = 96
regs$ = 104
s370_load_halfword_relative_long PROC

; 1597 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1598 : int     r1;                             /* Register number           */
; 1599 : VADR    effective_addr2;                /* Relative operand address  */
; 1600 : U16     n;                              /* Relative operand value    */
; 1601 : 
; 1602 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 38	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_load_
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_load_
$LN7@s370_load_:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_load_:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_load_
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_load_
$LN11@s370_load_:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_load_:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_load_
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 38	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_load_:
  000dd	8b 44 24 40	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 2c	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_load_
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_load_:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_load_

; 1603 : 
; 1604 :     /* Load relative operand from instruction address space */
; 1605 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00130	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00135	ba ff ff ff ff	 mov	 edx, -1
  0013a	8b 4c 24 2c	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_vfetch2
  00143	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1606 : 
; 1607 :     /* Sign-extend operand value and load into R1 register */
; 1608 :     regs->GR_L(r1) = (S32)(S16)n;

  00148	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  0014d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00152	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1609 : 
; 1610 : } /* end DEF_INST(load_halfword_relative_long) */

  0015e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00162	c3		 ret	 0
s370_load_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
r1$ = 44
n$ = 48
tv165 = 52
tv166 = 56
offset$1 = 64
tv130 = 72
inst$ = 96
regs$ = 104
s370_compare_relative_long PROC

; 1385 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1386 : int     r1;                             /* Register number           */
; 1387 : VADR    effective_addr2;                /* Relative operand address  */
; 1388 : U32     n;                              /* Relative operand value    */
; 1389 : 
; 1390 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 40	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@s370_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@s370_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@s370_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@s370_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN14@s370_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 40	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
$LN15@s370_compa:
  000dd	8b 44 24 48	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_compa
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_compa

; 1391 : 
; 1392 :     /* Program check if operand not on fullword boundary */
; 1393 :     FW_CHECK(effective_addr2, regs);

  00130	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00134	83 e0 03	 and	 eax, 3
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN6@s370_compa
  0013b	ba 06 00 00 00	 mov	 edx, 6
  00140	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 1394 : 
; 1395 :     /* Load relative operand from instruction address space */
; 1396 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  00150	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00155	ba ff ff ff ff	 mov	 edx, -1
  0015a	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0015e	e8 00 00 00 00	 call	 s370_vfetch4
  00163	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 1397 : 
; 1398 :     /* Compare signed operands and set condition code */
; 1399 :     regs->psw.cc =

  00167	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  00175	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0017c	7d 0a		 jge	 SHORT $LN18@s370_compa
  0017e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00186	eb 31		 jmp	 SHORT $LN19@s370_compa
$LN18@s370_compa:
  00188	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  00196	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0019d	7e 0a		 jle	 SHORT $LN16@s370_compa
  0019f	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv165[rsp], 2
  001a7	eb 08		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  001a9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN17@s370_compa:
  001b1	8b 44 24 34	 mov	 eax, DWORD PTR tv165[rsp]
  001b5	89 44 24 38	 mov	 DWORD PTR tv166[rsp], eax
$LN19@s370_compa:
  001b9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv166[rsp]
  001c3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1400 :             (S32)regs->GR_L(r1) < (S32)n ? 1 :
; 1401 :             (S32)regs->GR_L(r1) > (S32)n ? 2 : 0;
; 1402 : 
; 1403 : } /* end DEF_INST(compare_relative_long) */

  001c6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ca	c3		 ret	 0
s370_compare_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv162 = 48
tv163 = 52
effective_addr2$ = 56
offset$1 = 64
tv130 = 72
inst$ = 96
regs$ = 104
s370_compare_logical_relative_long_halfword PROC

; 1339 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1340 : int     r1;                             /* Register number           */
; 1341 : VADR    effective_addr2;                /* Relative operand address  */
; 1342 : U16     n;                              /* Relative operand value    */
; 1343 : 
; 1344 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 40	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_compa
$LN13@s370_compa:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 40	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_compa:
  000dd	8b 44 24 48	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 38	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_compa
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_compa

; 1345 : 
; 1346 :     /* Load relative operand from instruction address space */
; 1347 :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00130	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00135	ba ff ff ff ff	 mov	 edx, -1
  0013a	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_vfetch2
  00143	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1348 : 
; 1349 :     /* Compare signed operands and set condition code */
; 1350 :     regs->psw.cc =

  00148	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0014d	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  00152	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0015e	73 0a		 jae	 SHORT $LN17@s370_compa
  00160	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00168	eb 32		 jmp	 SHORT $LN18@s370_compa
$LN17@s370_compa:
  0016a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016f	0f b7 4c 24 20	 movzx	 ecx, WORD PTR n$[rsp]
  00174	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00179	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00180	76 0a		 jbe	 SHORT $LN15@s370_compa
  00182	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  0018a	eb 08		 jmp	 SHORT $LN16@s370_compa
$LN15@s370_compa:
  0018c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN16@s370_compa:
  00194	8b 44 24 30	 mov	 eax, DWORD PTR tv162[rsp]
  00198	89 44 24 34	 mov	 DWORD PTR tv163[rsp], eax
$LN18@s370_compa:
  0019c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv163[rsp]
  001a6	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1351 :             regs->GR_L(r1) < n ? 1 :
; 1352 :             regs->GR_L(r1) > n ? 2 : 0;
; 1353 : 
; 1354 : } /* end DEF_INST(compare_logical_relative_long_halfword) */

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	c3		 ret	 0
s370_compare_logical_relative_long_halfword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
tv75 = 32
tv82 = 36
effective_addr2$ = 40
r1$ = 44
n$ = 48
tv165 = 52
tv166 = 56
offset$1 = 64
tv130 = 72
inst$ = 96
regs$ = 104
s370_compare_logical_relative_long PROC

; 1260 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1261 : int     r1;                             /* Register number           */
; 1262 : VADR    effective_addr2;                /* Relative operand address  */
; 1263 : U32     n;                              /* Relative operand value    */
; 1264 : 
; 1265 :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 40	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN8@s370_compa
  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00057	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@s370_compa:
  0005f	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN12@s370_compa
  00066	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN13@s370_compa:
  00078	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN14@s370_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 40	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
$LN15@s370_compa:
  000dd	8b 44 24 48	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_compa
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_compa

; 1266 : 
; 1267 :     /* Program check if operand not on fullword boundary */
; 1268 :     FW_CHECK(effective_addr2, regs);

  00130	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00134	83 e0 03	 and	 eax, 3
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN6@s370_compa
  0013b	ba 06 00 00 00	 mov	 edx, 6
  00140	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 1269 : 
; 1270 :     /* Load relative operand from instruction address space */
; 1271 :     n = ARCH_DEP(vfetch4) ( effective_addr2, USE_INST_SPACE, regs );

  00150	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00155	ba ff ff ff ff	 mov	 edx, -1
  0015a	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0015e	e8 00 00 00 00	 call	 s370_vfetch4
  00163	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 1272 : 
; 1273 :     /* Compare signed operands and set condition code */
; 1274 :     regs->psw.cc =

  00167	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  00175	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0017c	73 0a		 jae	 SHORT $LN18@s370_compa
  0017e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00186	eb 31		 jmp	 SHORT $LN19@s370_compa
$LN18@s370_compa:
  00188	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0018d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  00196	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0019d	76 0a		 jbe	 SHORT $LN16@s370_compa
  0019f	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv165[rsp], 2
  001a7	eb 08		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  001a9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN17@s370_compa:
  001b1	8b 44 24 34	 mov	 eax, DWORD PTR tv165[rsp]
  001b5	89 44 24 38	 mov	 DWORD PTR tv166[rsp], eax
$LN19@s370_compa:
  001b9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv166[rsp]
  001c3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1275 :             regs->GR_L(r1) < n ? 1 :
; 1276 :             regs->GR_L(r1) > n ? 2 : 0;
; 1277 : 
; 1278 : } /* end DEF_INST(compare_logical_relative_long) */

  001c6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ca	c3		 ret	 0
s370_compare_logical_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
tv131 = 48
tv132 = 52
n$ = 56
inst$ = 80
regs$ = 88
s370_compare_logical_immediate_long_storage PROC

; 1238 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1239 : int     b1;                             /* Base of effective addr    */
; 1240 : VADR    effective_addr1;                /* Effective address         */
; 1241 : U16     i2;                             /* 16-bit immediate value    */
; 1242 : U64     n;                              /* 64-bit storage value      */
; 1243 : 
; 1244 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 1245 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1246 : 
; 1247 :     /* Load 64-bit value from first operand address */
; 1248 :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch8
  000d3	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 1249 : 
; 1250 :     /* Compare unsigned operands and set condition code */
; 1251 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d8	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  000dd	48 39 44 24 38	 cmp	 QWORD PTR n$[rsp], rax
  000e2	73 0a		 jae	 SHORT $LN10@s370_compa
  000e4	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  000ec	eb 26		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000ee	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  000f3	48 39 44 24 38	 cmp	 QWORD PTR n$[rsp], rax
  000f8	76 0a		 jbe	 SHORT $LN8@s370_compa
  000fa	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  00102	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00104	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN9@s370_compa:
  0010c	8b 44 24 30	 mov	 eax, DWORD PTR tv131[rsp]
  00110	89 44 24 34	 mov	 DWORD PTR tv132[rsp], eax
$LN11@s370_compa:
  00114	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00119	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv132[rsp]
  0011e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1252 : 
; 1253 : } /* end DEF_INST(compare_logical_immediate_long_storage) */

  00121	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00125	c3		 ret	 0
s370_compare_logical_immediate_long_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
i2$ = 36
effective_addr1$ = 40
temp$1 = 44
b1$ = 48
tv133 = 52
tv134 = 56
inst$ = 80
regs$ = 88
s370_compare_logical_immediate_halfword_storage PROC

; 1216 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1217 : int     b1;                             /* Base of effective addr    */
; 1218 : VADR    effective_addr1;                /* Effective address         */
; 1219 : U16     i2;                             /* 16-bit immediate value    */
; 1220 : U16     n;                              /* 16-bit storage value      */
; 1221 : 
; 1222 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 24	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 30 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 30	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 1223 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1224 : 
; 1225 :     /* Load 16-bit value from first operand address */
; 1226 :     n = ARCH_DEP(vfetch2) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 30	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch2
  000d3	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 1227 : 
; 1228 :     /* Compare unsigned operands and set condition code */
; 1229 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d8	0f b7 44 24 20	 movzx	 eax, WORD PTR n$[rsp]
  000dd	0f b7 4c 24 24	 movzx	 ecx, WORD PTR i2$[rsp]
  000e2	3b c1		 cmp	 eax, ecx
  000e4	7d 0a		 jge	 SHORT $LN10@s370_compa
  000e6	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000ee	eb 28		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000f0	0f b7 44 24 20	 movzx	 eax, WORD PTR n$[rsp]
  000f5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR i2$[rsp]
  000fa	3b c1		 cmp	 eax, ecx
  000fc	7e 0a		 jle	 SHORT $LN8@s370_compa
  000fe	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  00106	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00108	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@s370_compa:
  00110	8b 44 24 34	 mov	 eax, DWORD PTR tv133[rsp]
  00114	89 44 24 38	 mov	 DWORD PTR tv134[rsp], eax
$LN11@s370_compa:
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv134[rsp]
  00122	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1230 : 
; 1231 : } /* end DEF_INST(compare_logical_immediate_halfword_storage) */

  00125	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00129	c3		 ret	 0
s370_compare_logical_immediate_halfword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
n$ = 48
tv131 = 52
tv132 = 56
inst$ = 80
regs$ = 88
s370_compare_logical_immediate_fullword_storage PROC

; 1194 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1195 : int     b1;                             /* Base of effective addr    */
; 1196 : VADR    effective_addr1;                /* Effective address         */
; 1197 : U16     i2;                             /* 16-bit immediate value    */
; 1198 : U32     n;                              /* 32-bit storage value      */
; 1199 : 
; 1200 :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 1201 :     PER_ZEROADDR_XCHECK( regs, b1 );
; 1202 : 
; 1203 :     /* Load 32-bit value from first operand address */
; 1204 :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch4
  000d3	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 1205 : 
; 1206 :     /* Compare unsigned operands and set condition code */
; 1207 :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d7	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  000dc	39 44 24 30	 cmp	 DWORD PTR n$[rsp], eax
  000e0	73 0a		 jae	 SHORT $LN10@s370_compa
  000e2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  000ea	eb 25		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000ec	0f b7 44 24 20	 movzx	 eax, WORD PTR i2$[rsp]
  000f1	39 44 24 30	 cmp	 DWORD PTR n$[rsp], eax
  000f5	76 0a		 jbe	 SHORT $LN8@s370_compa
  000f7	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000ff	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00101	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN9@s370_compa:
  00109	8b 44 24 34	 mov	 eax, DWORD PTR tv131[rsp]
  0010d	89 44 24 38	 mov	 DWORD PTR tv132[rsp], eax
$LN11@s370_compa:
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv132[rsp]
  0011b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 1208 : 
; 1209 : } /* end DEF_INST(compare_logical_immediate_fullword_storage) */

  0011e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00122	c3		 ret	 0
s370_compare_logical_immediate_fullword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
s370_compare_logical_immediate_and_trap_fullword PROC

; 1140 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1141 : int     r1;                             /* Register number           */
; 1142 : int     m3;                             /* Mask bits                 */
; 1143 : int     cc;                             /* Comparison result         */
; 1144 : U16     i2;                             /* 16-bit immediate value    */
; 1145 : 
; 1146 :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@s370_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@s370_compa

; 1147 : 
; 1148 :     /* Compare unsigned operands and set comparison result */
; 1149 :     cc = regs->GR_L(r1) < i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a0	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000a7	73 0a		 jae	 SHORT $LN10@s370_compa
  000a9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b1	eb 32		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000b3	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	0f b7 4c 24 20	 movzx	 ecx, WORD PTR i2$[rsp]
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000c9	76 0a		 jbe	 SHORT $LN8@s370_compa
  000cb	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d3	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  000d5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@s370_compa:
  000dd	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e1	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@s370_compa:
  000e5	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e9	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 1150 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1151 : 
; 1152 :     /* Raise data exception if m3 mask bit is set */
; 1153 :     if ((0x8 >> cc) & m3)

  000ed	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f1	b9 08 00 00 00	 mov	 ecx, 8
  000f6	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00101	d3 f8		 sar	 eax, cl
  00103	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00107	85 c0		 test	 eax, eax
  00109	74 1e		 je	 SHORT $LN6@s370_compa

; 1154 :     {
; 1155 :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 1156 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_compa:

; 1157 :     }
; 1158 : 
; 1159 : } /* end DEF_INST(compare_logical_immediate_and_trap_fullword) */

  00129	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012d	c3		 ret	 0
s370_compare_logical_immediate_and_trap_fullword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
ri4$ = 40
r1$ = 44
tv130 = 48
tv131 = 52
cc$ = 56
tv167 = 60
m3$ = 64
inst$ = 96
regs$ = 104
s370_compare_logical_immediate_and_branch_relative PROC

; 1076 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1077 : int     r1;                             /* Register number           */
; 1078 : int     m3;                             /* Mask bits                 */
; 1079 : BYTE    i2;                             /* Immediate operand value   */
; 1080 : S16     ri4;                            /* 16-bit relative offset    */
; 1081 : int     cc;                             /* Comparison result         */
; 1082 : 
; 1083 :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 28	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN5@s370_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@s370_compa

; 1084 : 
; 1085 :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );
; 1086 : 
; 1087 :     /* Compare unsigned operands and set comparison result */
; 1088 :     cc = regs->GR_L(r1) < i2 ? 1 :

  00095	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  0009f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000a4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000ab	73 0a		 jae	 SHORT $LN11@s370_compa
  000ad	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b5	eb 32		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  000b7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  000c1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cd	76 0a		 jbe	 SHORT $LN9@s370_compa
  000cf	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d7	eb 08		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000d9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN10@s370_compa:
  000e1	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e5	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN12@s370_compa:
  000e9	8b 44 24 34	 mov	 eax, DWORD PTR tv131[rsp]
  000ed	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 1089 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1090 : 
; 1091 :     /* Branch to immediate offset if m3 mask bit is set */
; 1092 :     if ((0x8 >> cc) & m3)

  000f1	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  000f5	b9 08 00 00 00	 mov	 ecx, 8
  000fa	89 4c 24 3c	 mov	 DWORD PTR tv167[rsp], ecx
  000fe	0f b6 c8	 movzx	 ecx, al
  00101	8b 44 24 3c	 mov	 eax, DWORD PTR tv167[rsp]
  00105	d3 f8		 sar	 eax, cl
  00107	23 44 24 40	 and	 eax, DWORD PTR m3$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 18		 je	 SHORT $LN6@s370_compa

; 1093 :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0010f	48 0f bf 44 24
	28		 movsx	 rax, WORD PTR ri4$[rsp]
  00115	48 d1 e0	 shl	 rax, 1
  00118	48 8b d0	 mov	 rdx, rax
  0011b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	e8 00 00 00 00	 call	 s370_SuccessfulRelativeBranch
  00125	eb 16		 jmp	 SHORT $LN7@s370_compa
$LN6@s370_compa:

; 1094 :     else
; 1095 :     {
; 1096 :         /* Bump ip to next sequential instruction */
; 1097 :         regs->ip += 6;

  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00130	48 83 c0 06	 add	 rax, 6
  00134	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@s370_compa:

; 1098 :     }
; 1099 : 
; 1100 : } /* end DEF_INST( compare_logical_immediate_and_branch_relative ) */

  0013d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00141	c3		 ret	 0
s370_compare_logical_immediate_and_branch_relative ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr4$ = 36
temp$1 = 40
b4$ = 44
r1$ = 48
tv136 = 52
tv137 = 56
cc$ = 60
tv177 = 64
m3$ = 68
inst$ = 96
regs$ = 104
s370_compare_logical_immediate_and_branch PROC

; 1010 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1011 : int     r1;                             /* Register number           */
; 1012 : int     m3;                             /* Mask bits                 */
; 1013 : int     b4;                             /* Base of effective addr    */
; 1014 : VADR    effective_addr4;                /* Effective address         */
; 1015 : int     cc;                             /* Comparison result         */
; 1016 : BYTE    i2;                             /* Immediate value           */
; 1017 : 
; 1018 :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 0c	 shr	 eax, 12
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR b4$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 10	 shr	 eax, 16
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  00062	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 14	 shr	 eax, 20
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00070	83 7c 24 2c 00	 cmp	 DWORD PTR b4$[rsp], 0
  00075	74 2a		 je	 SHORT $LN5@s370_compa
  00077	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00088	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  0008c	03 c8		 add	 ecx, eax
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
  00094	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00098	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0009d	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000aa	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 06	 cmp	 eax, 6
  000b3	74 0c		 je	 SHORT $LN6@s370_compa
  000b5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 da		 jne	 SHORT $LN4@s370_compa

; 1019 : 
; 1020 :     TXFC_INSTR_CHECK_IP( regs );
; 1021 : 
; 1022 :     /* Compare unsigned operands and set comparison result */
; 1023 :     cc = regs->GR_L(r1) < i2 ? 1 :

  000c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  000cc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  000d1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000d6	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000dd	73 0a		 jae	 SHORT $LN12@s370_compa
  000df	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000e7	eb 32		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  000e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ee	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR i2$[rsp]
  000f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000f8	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000ff	76 0a		 jbe	 SHORT $LN10@s370_compa
  00101	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv136[rsp], 2
  00109	eb 08		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  0010b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN11@s370_compa:
  00113	8b 44 24 34	 mov	 eax, DWORD PTR tv136[rsp]
  00117	89 44 24 38	 mov	 DWORD PTR tv137[rsp], eax
$LN13@s370_compa:
  0011b	8b 44 24 38	 mov	 eax, DWORD PTR tv137[rsp]
  0011f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 1024 :          regs->GR_L(r1) > i2 ? 2 : 0;
; 1025 : 
; 1026 :     /* Branch to operand address if m3 mask bit is set */
; 1027 :     if ((0x8 >> cc) & m3)

  00123	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00127	b9 08 00 00 00	 mov	 ecx, 8
  0012c	89 4c 24 40	 mov	 DWORD PTR tv177[rsp], ecx
  00130	0f b6 c8	 movzx	 ecx, al
  00133	8b 44 24 40	 mov	 eax, DWORD PTR tv177[rsp]
  00137	d3 f8		 sar	 eax, cl
  00139	23 44 24 44	 and	 eax, DWORD PTR m3$[rsp]
  0013d	85 c0		 test	 eax, eax
  0013f	74 10		 je	 SHORT $LN7@s370_compa

; 1028 :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  00141	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  00145	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	e8 00 00 00 00	 call	 s370_SuccessfulBranch
  0014f	eb 16		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:

; 1029 :     else
; 1030 :     {
; 1031 :         /* Bump ip to next sequential instruction */
; 1032 :         regs->ip += 6;

  00151	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00156	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015a	48 83 c0 06	 add	 rax, 6
  0015e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@s370_compa:

; 1033 :     }
; 1034 : 
; 1035 : } /* end DEF_INST(compare_logical_immediate_and_branch) */

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
s370_compare_logical_immediate_and_branch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
s370_compare_logical_and_trap_register PROC

; 958  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 959  : int     r1, r2;                         /* Register numbers          */
; 960  : int     m3;                             /* Mask bits                 */
; 961  : int     cc;                             /* Comparison result         */
; 962  : 
; 963  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_compa

; 964  : 
; 965  :     /* Compare unsigned operands and set comparison result */
; 966  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0009c	73 0a		 jae	 SHORT $LN10@s370_compa
  0009e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a6	eb 3f		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000a8	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ad	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000c4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cb	76 0a		 jbe	 SHORT $LN8@s370_compa
  000cd	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d5	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@s370_compa:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e3	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@s370_compa:
  000e7	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000eb	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 967  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 968  : 
; 969  :     /* Raise data exception if m3 mask bit is set */
; 970  :     if ((0x8 >> cc) & m3)

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00103	d3 f8		 sar	 eax, cl
  00105	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00109	85 c0		 test	 eax, eax
  0010b	74 1e		 je	 SHORT $LN6@s370_compa

; 971  :     {
; 972  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 973  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_compa:

; 974  :     }
; 975  : 
; 976  : } /* end DEF_INST(compare_logical_and_trap_register) */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
s370_compare_logical_and_trap_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
ri4$ = 36
r1$ = 40
r2$ = 44
tv138 = 48
tv139 = 52
cc$ = 56
tv180 = 60
m3$ = 64
inst$ = 96
regs$ = 104
s370_compare_logical_and_branch_relative_register PROC

; 896  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 897  : int     r1, r2;                         /* Register numbers          */
; 898  : int     m3;                             /* Mask bits                 */
; 899  : S16     ri4;                            /* 16-bit relative offset    */
; 900  : int     cc;                             /* Comparison result         */
; 901  : 
; 902  :     RIE_RRIM_B( inst, regs, r1, r2, ri4, m3 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 24	 mov	 WORD PTR ri4$[rsp], ax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN5@s370_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@s370_compa

; 903  : 
; 904  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );
; 905  : 
; 906  :     /* Compare unsigned operands and set comparison result */
; 907  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  00096	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009b	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a0	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000aa	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000b9	73 0a		 jae	 SHORT $LN11@s370_compa
  000bb	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  000c3	eb 3f		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  000c5	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ca	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000cf	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000d4	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000d9	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000e1	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000e8	76 0a		 jbe	 SHORT $LN9@s370_compa
  000ea	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv138[rsp], 2
  000f2	eb 08		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000f4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@s370_compa:
  000fc	8b 44 24 30	 mov	 eax, DWORD PTR tv138[rsp]
  00100	89 44 24 34	 mov	 DWORD PTR tv139[rsp], eax
$LN12@s370_compa:
  00104	8b 44 24 34	 mov	 eax, DWORD PTR tv139[rsp]
  00108	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 908  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 909  : 
; 910  :     /* Branch to immediate offset if m3 mask bit is set */
; 911  :     if ((0x8 >> cc) & m3)

  0010c	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  00110	b9 08 00 00 00	 mov	 ecx, 8
  00115	89 4c 24 3c	 mov	 DWORD PTR tv180[rsp], ecx
  00119	0f b6 c8	 movzx	 ecx, al
  0011c	8b 44 24 3c	 mov	 eax, DWORD PTR tv180[rsp]
  00120	d3 f8		 sar	 eax, cl
  00122	23 44 24 40	 and	 eax, DWORD PTR m3$[rsp]
  00126	85 c0		 test	 eax, eax
  00128	74 18		 je	 SHORT $LN6@s370_compa

; 912  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0012a	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR ri4$[rsp]
  00130	48 d1 e0	 shl	 rax, 1
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_SuccessfulRelativeBranch
  00140	eb 16		 jmp	 SHORT $LN7@s370_compa
$LN6@s370_compa:

; 913  :     else
; 914  :     {
; 915  :         /* Bump ip to next sequential instruction */
; 916  :         regs->ip += 6;

  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014b	48 83 c0 06	 add	 rax, 6
  0014f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@s370_compa:

; 917  :     }
; 918  : 
; 919  : } /* end DEF_INST(compare_logical_and_branch_relative_register) */

  00158	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015c	c3		 ret	 0
s370_compare_logical_and_branch_relative_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr4$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
r2$ = 48
tv147 = 52
tv148 = 56
cc$ = 60
tv193 = 64
m3$ = 68
inst$ = 96
regs$ = 104
s370_compare_logical_and_branch_register PROC

; 832  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 833  : int     r1, r2;                         /* Register numbers          */
; 834  : int     m3;                             /* Mask bits                 */
; 835  : int     b4;                             /* Base of effective addr    */
; 836  : VADR    effective_addr4;                /* Effective address         */
; 837  : int     cc;                             /* Comparison result         */
; 838  : 
; 839  :     RRS_B(inst, regs, r1, r2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
  0004c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	c1 e8 0c	 shr	 eax, 12
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  0005a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005e	c1 e8 10	 shr	 eax, 16
  00061	83 e0 0f	 and	 eax, 15
  00064	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00068	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 14	 shr	 eax, 20
  0006f	83 e0 0f	 and	 eax, 15
  00072	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00076	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007b	74 2a		 je	 SHORT $LN5@s370_compa
  0007d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  00082	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
  0009a	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0009e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  000a7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000b4	33 c0		 xor	 eax, eax
  000b6	83 f8 06	 cmp	 eax, 6
  000b9	74 0c		 je	 SHORT $LN6@s370_compa
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 da		 jne	 SHORT $LN4@s370_compa

; 840  : 
; 841  :     TXFC_INSTR_CHECK_IP( regs );
; 842  : 
; 843  :     /* Compare unsigned operands and set comparison result */
; 844  :     cc = regs->GR_L(r1) < regs->GR_L(r2) ? 1 :

  000cd	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000d7	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000dc	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000e1	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000e9	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000f0	73 0a		 jae	 SHORT $LN12@s370_compa
  000f2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  000fa	eb 3f		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  000fc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00101	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00106	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0010b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00110	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00118	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0011f	76 0a		 jbe	 SHORT $LN10@s370_compa
  00121	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv147[rsp], 2
  00129	eb 08		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  0012b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN11@s370_compa:
  00133	8b 44 24 34	 mov	 eax, DWORD PTR tv147[rsp]
  00137	89 44 24 38	 mov	 DWORD PTR tv148[rsp], eax
$LN13@s370_compa:
  0013b	8b 44 24 38	 mov	 eax, DWORD PTR tv148[rsp]
  0013f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 845  :          regs->GR_L(r1) > regs->GR_L(r2) ? 2 : 0;
; 846  : 
; 847  :     /* Branch to operand address if m3 mask bit is set */
; 848  :     if ((0x8 >> cc) & m3)

  00143	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00147	b9 08 00 00 00	 mov	 ecx, 8
  0014c	89 4c 24 40	 mov	 DWORD PTR tv193[rsp], ecx
  00150	0f b6 c8	 movzx	 ecx, al
  00153	8b 44 24 40	 mov	 eax, DWORD PTR tv193[rsp]
  00157	d3 f8		 sar	 eax, cl
  00159	23 44 24 44	 and	 eax, DWORD PTR m3$[rsp]
  0015d	85 c0		 test	 eax, eax
  0015f	74 10		 je	 SHORT $LN7@s370_compa

; 849  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  00161	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  00165	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_SuccessfulBranch
  0016f	eb 16		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:

; 850  :     else
; 851  :     {
; 852  :         /* Bump ip to next sequential instruction */
; 853  :         regs->ip += 6;

  00171	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00176	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0017a	48 83 c0 06	 add	 rax, 6
  0017e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@s370_compa:

; 854  :     }
; 855  : 
; 856  : } /* end DEF_INST(compare_logical_and_branch_register) */

  00187	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018b	c3		 ret	 0
s370_compare_logical_and_branch_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
r1$ = 40
tv129 = 44
tv130 = 48
cc$ = 52
tv162 = 56
m3$ = 60
inst$ = 80
regs$ = 88
s370_compare_immediate_and_trap PROC

; 778  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 779  : int     r1;                             /* Register number           */
; 780  : int     m3;                             /* Mask bits                 */
; 781  : int     cc;                             /* Comparison result         */
; 782  : U16     i2;                             /* 16-bit immediate value    */
; 783  : 
; 784  :     RIE_RIM(inst, regs, r1, i2, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 1c	 shr	 eax, 28
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00062	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006b	48 83 c0 06	 add	 rax, 6
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00078	33 c0		 xor	 eax, eax
  0007a	83 f8 06	 cmp	 eax, 6
  0007d	74 0c		 je	 SHORT $LN5@s370_compa
  0007f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00084	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d1		 jne	 SHORT $LN4@s370_compa

; 785  : 
; 786  :     /* Compare signed operands and set comparison result */
; 787  :     cc = (S32)regs->GR_L(r1) < (S32)(S16)i2 ? 1 :

  00091	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000a0	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000a7	7d 0a		 jge	 SHORT $LN10@s370_compa
  000a9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  000b1	eb 32		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000b3	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	0f bf 4c 24 20	 movsx	 ecx, WORD PTR i2$[rsp]
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000c9	7e 0a		 jle	 SHORT $LN8@s370_compa
  000cb	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv129[rsp], 2
  000d3	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  000d5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@s370_compa:
  000dd	8b 44 24 2c	 mov	 eax, DWORD PTR tv129[rsp]
  000e1	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN11@s370_compa:
  000e5	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e9	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 788  :          (S32)regs->GR_L(r1) > (S32)(S16)i2 ? 2 : 0;
; 789  : 
; 790  :     /* Raise data exception if m3 mask bit is set */
; 791  :     if ((0x8 >> cc) & m3)

  000ed	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f1	b9 08 00 00 00	 mov	 ecx, 8
  000f6	89 4c 24 38	 mov	 DWORD PTR tv162[rsp], ecx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  00101	d3 f8		 sar	 eax, cl
  00103	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00107	85 c0		 test	 eax, eax
  00109	74 1e		 je	 SHORT $LN6@s370_compa

; 792  :     {
; 793  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 794  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_compa:

; 795  :     }
; 796  : 
; 797  : } /* end DEF_INST(compare_immediate_and_trap) */

  00129	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012d	c3		 ret	 0
s370_compare_immediate_and_trap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
temp$1 = 36
ri4$ = 40
r1$ = 44
tv130 = 48
tv131 = 52
cc$ = 56
tv167 = 60
m3$ = 64
inst$ = 96
regs$ = 104
s370_compare_immediate_and_branch_relative PROC

; 714  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 715  : int     r1;                             /* Register numbers          */
; 716  : int     m3;                             /* Mask bits                 */
; 717  : BYTE    i2;                             /* Immediate operand value   */
; 718  : S16     ri4;                            /* 16-bit relative offset    */
; 719  : int     cc;                             /* Comparison result         */
; 720  : 
; 721  :     RIE_RMII_B( inst, regs, r1, i2, m3, ri4 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00042	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 08	 shr	 eax, 8
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	66 89 44 24 28	 mov	 WORD PTR ri4$[rsp], ax
  00053	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 18	 shr	 eax, 24
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00061	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00065	c1 e8 1c	 shr	 eax, 28
  00068	83 e0 0f	 and	 eax, 15
  0006b	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00078	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007c	33 c0		 xor	 eax, eax
  0007e	83 f8 06	 cmp	 eax, 6
  00081	74 0c		 je	 SHORT $LN5@s370_compa
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 da		 jne	 SHORT $LN4@s370_compa

; 722  : 
; 723  :     TXFC_BRANCH_CHECK_IP( regs, m3, ri4 );
; 724  : 
; 725  :     /* Compare signed operands and set comparison result */
; 726  :     cc = (S32)regs->GR_L(r1) < (S32)(S8)i2 ? 1 :

  00095	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009a	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  0009f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000a4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000ab	7d 0a		 jge	 SHORT $LN11@s370_compa
  000ad	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000b5	eb 32		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  000b7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000bc	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  000c1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cd	7e 0a		 jle	 SHORT $LN9@s370_compa
  000cf	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv130[rsp], 2
  000d7	eb 08		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000d9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN10@s370_compa:
  000e1	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  000e5	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN12@s370_compa:
  000e9	8b 44 24 34	 mov	 eax, DWORD PTR tv131[rsp]
  000ed	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 727  :          (S32)regs->GR_L(r1) > (S32)(S8)i2 ? 2 : 0;
; 728  : 
; 729  :     /* Branch to immediate offset if m3 mask bit is set */
; 730  :     if ((0x8 >> cc) & m3)

  000f1	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  000f5	b9 08 00 00 00	 mov	 ecx, 8
  000fa	89 4c 24 3c	 mov	 DWORD PTR tv167[rsp], ecx
  000fe	0f b6 c8	 movzx	 ecx, al
  00101	8b 44 24 3c	 mov	 eax, DWORD PTR tv167[rsp]
  00105	d3 f8		 sar	 eax, cl
  00107	23 44 24 40	 and	 eax, DWORD PTR m3$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 18		 je	 SHORT $LN6@s370_compa

; 731  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*ri4 );

  0010f	48 0f bf 44 24
	28		 movsx	 rax, WORD PTR ri4$[rsp]
  00115	48 d1 e0	 shl	 rax, 1
  00118	48 8b d0	 mov	 rdx, rax
  0011b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	e8 00 00 00 00	 call	 s370_SuccessfulRelativeBranch
  00125	eb 16		 jmp	 SHORT $LN7@s370_compa
$LN6@s370_compa:

; 732  :     else
; 733  :     {
; 734  :         /* Bump ip to next sequential instruction */
; 735  :         regs->ip += 6;

  00127	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00130	48 83 c0 06	 add	 rax, 6
  00134	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@s370_compa:

; 736  :     }
; 737  : 
; 738  : } /* end DEF_INST( compare_immediate_and_branch_relative ) */

  0013d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00141	c3		 ret	 0
s370_compare_immediate_and_branch_relative ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr4$ = 36
temp$1 = 40
b4$ = 44
r1$ = 48
tv136 = 52
tv137 = 56
cc$ = 60
tv177 = 64
m3$ = 68
inst$ = 96
regs$ = 104
s370_compare_immediate_and_branch PROC

; 648  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 649  : int     r1;                             /* Register number           */
; 650  : int     m3;                             /* Mask bits                 */
; 651  : int     b4;                             /* Base of effective addr    */
; 652  : VADR    effective_addr4;                /* Effective address         */
; 653  : int     cc;                             /* Comparison result         */
; 654  : BYTE    i2;                             /* Immediate value           */
; 655  : 
; 656  :     RIS_B(inst, regs, r1, i2, m3, b4, effective_addr4);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 44 24 20	 mov	 BYTE PTR i2$[rsp], al
  00039	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 0c	 shr	 eax, 12
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR b4$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 10	 shr	 eax, 16
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  00062	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 14	 shr	 eax, 20
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00070	83 7c 24 2c 00	 cmp	 DWORD PTR b4$[rsp], 0
  00075	74 2a		 je	 SHORT $LN5@s370_compa
  00077	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b4$[rsp]
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00088	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  0008c	03 c8		 add	 ecx, eax
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
  00094	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00098	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0009d	89 44 24 24	 mov	 DWORD PTR effective_addr4$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000aa	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 06	 cmp	 eax, 6
  000b3	74 0c		 je	 SHORT $LN6@s370_compa
  000b5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 da		 jne	 SHORT $LN4@s370_compa

; 657  : 
; 658  :     TXFC_INSTR_CHECK_IP( regs );
; 659  : 
; 660  :     /* Compare signed operands and set comparison result */
; 661  :     cc = (S32)regs->GR_L(r1) < (S32)(S8)i2 ? 1 :

  000c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  000cc	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  000d1	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000d6	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000dd	7d 0a		 jge	 SHORT $LN12@s370_compa
  000df	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000e7	eb 32		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  000e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ee	0f be 4c 24 20	 movsx	 ecx, BYTE PTR i2$[rsp]
  000f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000f8	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000ff	7e 0a		 jle	 SHORT $LN10@s370_compa
  00101	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv136[rsp], 2
  00109	eb 08		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  0010b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN11@s370_compa:
  00113	8b 44 24 34	 mov	 eax, DWORD PTR tv136[rsp]
  00117	89 44 24 38	 mov	 DWORD PTR tv137[rsp], eax
$LN13@s370_compa:
  0011b	8b 44 24 38	 mov	 eax, DWORD PTR tv137[rsp]
  0011f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 662  :          (S32)regs->GR_L(r1) > (S32)(S8)i2 ? 2 : 0;
; 663  : 
; 664  :     /* Branch to operand address if m3 mask bit is set */
; 665  :     if ((0x8 >> cc) & m3)

  00123	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00127	b9 08 00 00 00	 mov	 ecx, 8
  0012c	89 4c 24 40	 mov	 DWORD PTR tv177[rsp], ecx
  00130	0f b6 c8	 movzx	 ecx, al
  00133	8b 44 24 40	 mov	 eax, DWORD PTR tv177[rsp]
  00137	d3 f8		 sar	 eax, cl
  00139	23 44 24 44	 and	 eax, DWORD PTR m3$[rsp]
  0013d	85 c0		 test	 eax, eax
  0013f	74 10		 je	 SHORT $LN7@s370_compa

; 666  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  00141	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  00145	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	e8 00 00 00 00	 call	 s370_SuccessfulBranch
  0014f	eb 16		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:

; 667  :     else
; 668  :     {
; 669  :         /* Bump ip to next sequential instruction */
; 670  :         regs->ip += 6;

  00151	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00156	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015a	48 83 c0 06	 add	 rax, 6
  0015e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@s370_compa:

; 671  :     }
; 672  : 
; 673  : } /* end DEF_INST(compare_immediate_and_branch) */

  00167	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016b	c3		 ret	 0
s370_compare_immediate_and_branch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
tv75 = 36
tv82 = 40
r1$ = 44
tv162 = 48
tv163 = 52
effective_addr2$ = 56
offset$1 = 64
tv130 = 72
inst$ = 96
regs$ = 104
s370_compare_halfword_relative_long PROC

; 602  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 603  : int     r1;                             /* Register number           */
; 604  : VADR    effective_addr2;                /* Relative operand address  */
; 605  : U16     n;                              /* Relative operand value    */
; 606  : 
; 607  :     RIL_A(inst, regs, r1, effective_addr2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	48 98		 cdqe
  00033	48 d1 e0	 shl	 rax, 1
  00036	48 89 44 24 40	 mov	 QWORD PTR offset$1[rsp], rax
  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN7@s370_compa
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN8@s370_compa:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00064	74 0a		 je	 SHORT $LN11@s370_compa
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN12@s370_compa:
  00078	83 7c 24 28 00	 cmp	 DWORD PTR tv82[rsp], 0
  0007d	74 43		 je	 SHORT $LN13@s370_compa
  0007f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00084	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00094	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0009b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0009f	48 2b ca	 sub	 rcx, rdx
  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR offset$1[rsp]
  000a7	48 03 d0	 add	 rdx, rax
  000aa	48 8b c2	 mov	 rax, rdx
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000b9	8b c0		 mov	 eax, eax
  000bb	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 1b		 jmp	 SHORT $LN14@s370_compa
$LN13@s370_compa:
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  000cd	48 03 44 24 40	 add	 rax, QWORD PTR offset$1[rsp]
  000d2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000d8	48 89 44 24 48	 mov	 QWORD PTR tv130[rsp], rax
$LN14@s370_compa:
  000dd	8b 44 24 48	 mov	 eax, DWORD PTR tv130[rsp]
  000e1	89 44 24 38	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  000f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f7	c1 f8 04	 sar	 eax, 4
  000fa	83 e0 0f	 and	 eax, 15
  000fd	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010a	48 83 c0 06	 add	 rax, 6
  0010e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0c		 je	 SHORT $LN5@s370_compa
  0011e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00123	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 d1		 jne	 SHORT $LN4@s370_compa

; 608  : 
; 609  :     /* Load relative operand from instruction address space */
; 610  :     n = ARCH_DEP(vfetch2) ( effective_addr2, USE_INST_SPACE, regs );

  00130	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00135	ba ff ff ff ff	 mov	 edx, -1
  0013a	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_vfetch2
  00143	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 611  : 
; 612  :     /* Compare signed operands and set condition code */
; 613  :     regs->psw.cc =

  00148	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0014d	0f bf 4c 24 20	 movsx	 ecx, WORD PTR n$[rsp]
  00152	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0015e	7d 0a		 jge	 SHORT $LN17@s370_compa
  00160	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00168	eb 32		 jmp	 SHORT $LN18@s370_compa
$LN17@s370_compa:
  0016a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0016f	0f bf 4c 24 20	 movsx	 ecx, WORD PTR n$[rsp]
  00174	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00179	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  00180	7e 0a		 jle	 SHORT $LN15@s370_compa
  00182	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv162[rsp], 2
  0018a	eb 08		 jmp	 SHORT $LN16@s370_compa
$LN15@s370_compa:
  0018c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN16@s370_compa:
  00194	8b 44 24 30	 mov	 eax, DWORD PTR tv162[rsp]
  00198	89 44 24 34	 mov	 DWORD PTR tv163[rsp], eax
$LN18@s370_compa:
  0019c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv163[rsp]
  001a6	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 614  :             (S32)regs->GR_L(r1) < (S16)n ? 1 :
; 615  :             (S32)regs->GR_L(r1) > (S16)n ? 2 : 0;
; 616  : 
; 617  : } /* end DEF_INST(compare_halfword_relative_long) */

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	c3		 ret	 0
s370_compare_halfword_relative_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
n$ = 48
tv131 = 52
tv132 = 56
inst$ = 80
regs$ = 88
s370_compare_halfword_immediate_storage PROC

; 553  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 554  : int     b1;                             /* Base of effective addr    */
; 555  : VADR    effective_addr1;                /* Effective address         */
; 556  : S16     i2;                             /* 16-bit immediate value    */
; 557  : S32     n;                              /* 32-bit storage value      */
; 558  : 
; 559  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 560  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 561  : 
; 562  :     /* Load 32-bit value from first operand address */
; 563  :     n = (S32)ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch4
  000d3	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 564  : 
; 565  :     /* Compare signed operands and set condition code */
; 566  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d7	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000dc	39 44 24 30	 cmp	 DWORD PTR n$[rsp], eax
  000e0	7d 0a		 jge	 SHORT $LN10@s370_compa
  000e2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  000ea	eb 25		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000ec	0f bf 44 24 20	 movsx	 eax, WORD PTR i2$[rsp]
  000f1	39 44 24 30	 cmp	 DWORD PTR n$[rsp], eax
  000f5	7e 0a		 jle	 SHORT $LN8@s370_compa
  000f7	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000ff	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00101	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN9@s370_compa:
  00109	8b 44 24 34	 mov	 eax, DWORD PTR tv131[rsp]
  0010d	89 44 24 38	 mov	 DWORD PTR tv132[rsp], eax
$LN11@s370_compa:
  00111	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00116	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv132[rsp]
  0011b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 567  : 
; 568  : } /* end DEF_INST(compare_halfword_immediate_storage) */

  0011e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00122	c3		 ret	 0
s370_compare_halfword_immediate_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
i2$ = 32
effective_addr1$ = 36
temp$1 = 40
b1$ = 44
tv131 = 48
tv132 = 52
n$ = 56
inst$ = 80
regs$ = 88
s370_compare_halfword_immediate_long_storage PROC

; 531  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 532  : int     b1;                             /* Base of effective addr    */
; 533  : VADR    effective_addr1;                /* Effective address         */
; 534  : S16     i2;                             /* 16-bit immediate value    */
; 535  : S64     n;                              /* 64-bit storage value      */
; 536  : 
; 537  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 20	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 24	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 538  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 539  : 
; 540  :     /* Load 64-bit value from first operand address */
; 541  :     n = (S64)ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 2c	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch8
  000d3	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 542  : 
; 543  :     /* Compare signed operands and set condition code */
; 544  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d8	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000de	48 39 44 24 38	 cmp	 QWORD PTR n$[rsp], rax
  000e3	7d 0a		 jge	 SHORT $LN10@s370_compa
  000e5	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  000ed	eb 27		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000ef	48 0f bf 44 24
	20		 movsx	 rax, WORD PTR i2$[rsp]
  000f5	48 39 44 24 38	 cmp	 QWORD PTR n$[rsp], rax
  000fa	7e 0a		 jle	 SHORT $LN8@s370_compa
  000fc	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  00104	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00106	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN9@s370_compa:
  0010e	8b 44 24 30	 mov	 eax, DWORD PTR tv131[rsp]
  00112	89 44 24 34	 mov	 DWORD PTR tv132[rsp], eax
$LN11@s370_compa:
  00116	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv132[rsp]
  00120	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 545  : 
; 546  : } /* end DEF_INST(compare_halfword_immediate_long_storage) */

  00123	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00127	c3		 ret	 0
s370_compare_halfword_immediate_long_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
n$ = 32
i2$ = 36
effective_addr1$ = 40
temp$1 = 44
b1$ = 48
tv133 = 52
tv134 = 56
inst$ = 80
regs$ = 88
s370_compare_halfword_immediate_halfword_storage PROC

; 509  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 510  : int     b1;                             /* Base of effective addr    */
; 511  : VADR    effective_addr1;                /* Effective address         */
; 512  : S16     i2;                             /* 16-bit immediate value    */
; 513  : S16     n;                              /* 16-bit storage value      */
; 514  : 
; 515  :     SIL(inst, regs, i2, b1, effective_addr1);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	66 89 44 24 24	 mov	 WORD PTR i2$[rsp], ax
  00043	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004f	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00053	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00057	c1 e8 1c	 shr	 eax, 28
  0005a	83 e0 0f	 and	 eax, 15
  0005d	89 44 24 30	 mov	 DWORD PTR b1$[rsp], eax
  00061	83 7c 24 30 00	 cmp	 DWORD PTR b1$[rsp], 0
  00066	74 2a		 je	 SHORT $LN5@s370_compa
  00068	48 63 44 24 30	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007d	03 c8		 add	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00085	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00089	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0008e	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  00092	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 06	 add	 rax, 6
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 06	 cmp	 eax, 6
  000ad	74 0c		 je	 SHORT $LN6@s370_compa
  000af	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 d1		 jne	 SHORT $LN4@s370_compa

; 516  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 517  : 
; 518  :     /* Load 16-bit value from first operand address */
; 519  :     n = (S16)ARCH_DEP(vfetch2) ( effective_addr1, b1, regs );

  000c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000c6	8b 54 24 30	 mov	 edx, DWORD PTR b1$[rsp]
  000ca	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000ce	e8 00 00 00 00	 call	 s370_vfetch2
  000d3	66 89 44 24 20	 mov	 WORD PTR n$[rsp], ax

; 520  : 
; 521  :     /* Compare signed operands and set condition code */
; 522  :     regs->psw.cc = n < i2 ? 1 : n > i2 ? 2 : 0;

  000d8	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  000dd	0f bf 4c 24 24	 movsx	 ecx, WORD PTR i2$[rsp]
  000e2	3b c1		 cmp	 eax, ecx
  000e4	7d 0a		 jge	 SHORT $LN10@s370_compa
  000e6	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000ee	eb 28		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000f0	0f bf 44 24 20	 movsx	 eax, WORD PTR n$[rsp]
  000f5	0f bf 4c 24 24	 movsx	 ecx, WORD PTR i2$[rsp]
  000fa	3b c1		 cmp	 eax, ecx
  000fc	7e 0a		 jle	 SHORT $LN8@s370_compa
  000fe	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  00106	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  00108	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@s370_compa:
  00110	8b 44 24 34	 mov	 eax, DWORD PTR tv133[rsp]
  00114	89 44 24 38	 mov	 DWORD PTR tv134[rsp], eax
$LN11@s370_compa:
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv134[rsp]
  00122	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 523  : 
; 524  : } /* end DEF_INST(compare_halfword_immediate_halfword_storage) */

  00125	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00129	c3		 ret	 0
s370_compare_halfword_immediate_halfword_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
tv133 = 44
tv134 = 48
cc$ = 52
tv167 = 56
m3$ = 60
inst$ = 80
regs$ = 88
s370_compare_and_trap_register PROC

; 457  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 458  : int     r1, r2;                         /* Register numbers          */
; 459  : int     m3;                             /* Mask bits                 */
; 460  : int     cc;                             /* Comparison result         */
; 461  : 
; 462  :     RRF_M(inst, regs, r1, r2, m3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_compa:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_compa
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_compa

; 463  : 
; 464  :     /* Compare signed operands and set comparison result */
; 465  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0008d	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00095	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0009c	7d 0a		 jge	 SHORT $LN10@s370_compa
  0009e	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000a6	eb 3f		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  000a8	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ad	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000b2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  000bc	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000c4	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000cb	7e 0a		 jle	 SHORT $LN8@s370_compa
  000cd	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv133[rsp], 2
  000d5	eb 08		 jmp	 SHORT $LN9@s370_compa
$LN8@s370_compa:
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN9@s370_compa:
  000df	8b 44 24 2c	 mov	 eax, DWORD PTR tv133[rsp]
  000e3	89 44 24 30	 mov	 DWORD PTR tv134[rsp], eax
$LN11@s370_compa:
  000e7	8b 44 24 30	 mov	 eax, DWORD PTR tv134[rsp]
  000eb	89 44 24 34	 mov	 DWORD PTR cc$[rsp], eax

; 466  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 467  : 
; 468  :     /* Raise data exception if m3 mask bit is set */
; 469  :     if ((0x8 >> cc) & m3)

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR cc$[rsp]
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	89 4c 24 38	 mov	 DWORD PTR tv167[rsp], ecx
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00103	d3 f8		 sar	 eax, cl
  00105	23 44 24 3c	 and	 eax, DWORD PTR m3$[rsp]
  00109	85 c0		 test	 eax, eax
  0010b	74 1e		 je	 SHORT $LN6@s370_compa

; 470  :     {
; 471  :         regs->dxc = DXC_COMPARE_AND_TRAP;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00112	c7 80 08 07 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+1800], 255 ; 000000ffH

; 472  :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0011c	ba 07 00 00 00	 mov	 edx, 7
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 s370_program_interrupt
$LN6@s370_compa:

; 473  :     }
; 474  : 
; 475  : } /* end DEF_INST(compare_and_trap_register) */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
s370_compare_and_trap_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
temp$1 = 32
i4$ = 36
r1$ = 40
r2$ = 44
tv138 = 48
tv139 = 52
cc$ = 56
tv180 = 60
m3$ = 64
inst$ = 96
regs$ = 104
s370_compare_and_branch_relative_register PROC

; 395  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 396  : int     r1, r2;                         /* Register numbers          */
; 397  : int     m3;                             /* Mask bits                 */
; 398  : S16     i4;                             /* 16-bit immediate offset   */
; 399  : int     cc;                             /* Comparison result         */
; 400  : 
; 401  :     RIE_RRIM_B(inst, regs, r1, r2, i4, m3);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 01	 imul	 rax, rax, 1
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	48 03 c8	 add	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	c1 e8 04	 shr	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00047	c1 e8 08	 shr	 eax, 8
  0004a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004f	66 89 44 24 24	 mov	 WORD PTR i4$[rsp], ax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 18	 shr	 eax, 24
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 1c	 shr	 eax, 28
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00075	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00079	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  0007d	33 c0		 xor	 eax, eax
  0007f	83 f8 06	 cmp	 eax, 6
  00082	74 0c		 je	 SHORT $LN5@s370_compa
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00089	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN5@s370_compa:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	75 da		 jne	 SHORT $LN4@s370_compa

; 402  : 
; 403  :     TXFC_BRANCH_CHECK_IP( regs, m3, i4 );
; 404  : 
; 405  :     /* Compare signed operands and set comparison result */
; 406  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  00096	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  0009b	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000a0	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000aa	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000b2	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000b9	7d 0a		 jge	 SHORT $LN11@s370_compa
  000bb	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  000c3	eb 3f		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  000c5	48 63 44 24 28	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ca	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000cf	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000d4	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000d9	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000e1	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000e8	7e 0a		 jle	 SHORT $LN9@s370_compa
  000ea	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv138[rsp], 2
  000f2	eb 08		 jmp	 SHORT $LN10@s370_compa
$LN9@s370_compa:
  000f4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@s370_compa:
  000fc	8b 44 24 30	 mov	 eax, DWORD PTR tv138[rsp]
  00100	89 44 24 34	 mov	 DWORD PTR tv139[rsp], eax
$LN12@s370_compa:
  00104	8b 44 24 34	 mov	 eax, DWORD PTR tv139[rsp]
  00108	89 44 24 38	 mov	 DWORD PTR cc$[rsp], eax

; 407  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 408  : 
; 409  :     /* Branch to immediate offset if m3 mask bit is set */
; 410  :     if ((0x8 >> cc) & m3)

  0010c	8b 44 24 38	 mov	 eax, DWORD PTR cc$[rsp]
  00110	b9 08 00 00 00	 mov	 ecx, 8
  00115	89 4c 24 3c	 mov	 DWORD PTR tv180[rsp], ecx
  00119	0f b6 c8	 movzx	 ecx, al
  0011c	8b 44 24 3c	 mov	 eax, DWORD PTR tv180[rsp]
  00120	d3 f8		 sar	 eax, cl
  00122	23 44 24 40	 and	 eax, DWORD PTR m3$[rsp]
  00126	85 c0		 test	 eax, eax
  00128	74 18		 je	 SHORT $LN6@s370_compa

; 411  :         SUCCESSFUL_RELATIVE_BRANCH( regs, 2LL*i4 );

  0012a	48 0f bf 44 24
	24		 movsx	 rax, WORD PTR i4$[rsp]
  00130	48 d1 e0	 shl	 rax, 1
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	e8 00 00 00 00	 call	 s370_SuccessfulRelativeBranch
  00140	eb 16		 jmp	 SHORT $LN7@s370_compa
$LN6@s370_compa:

; 412  :     else
; 413  :     {
; 414  :         /* Bump ip to next sequential instruction */
; 415  :         regs->ip += 6;

  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00147	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014b	48 83 c0 06	 add	 rax, 6
  0014f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@s370_compa:

; 416  :     }
; 417  : 
; 418  : } /* end DEF_INST(compare_and_branch_relative_register) */

  00158	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015c	c3		 ret	 0
s370_compare_and_branch_relative_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
effective_addr4$ = 32
temp$1 = 36
b4$ = 40
r1$ = 44
r2$ = 48
tv147 = 52
tv148 = 56
cc$ = 60
tv193 = 64
m3$ = 68
inst$ = 96
regs$ = 104
s370_compare_and_branch_register PROC

; 331  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 332  : int     r1, r2;                         /* Register numbers          */
; 333  : int     m3;                             /* Mask bits                 */
; 334  : int     b4;                             /* Base of effective addr    */
; 335  : VADR    effective_addr4;                /* Effective address         */
; 336  : int     cc;                             /* Comparison result         */
; 337  : 
; 338  :     RRS_B( inst, regs, r1, r2, m3, b4, effective_addr4 );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 04	 imul	 rax, rax, 4
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	c1 f8 04	 sar	 eax, 4
  00038	83 e0 0f	 and	 eax, 15
  0003b	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00048	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
  0004c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	c1 e8 0c	 shr	 eax, 12
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 28	 mov	 DWORD PTR b4$[rsp], eax
  0005a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005e	c1 e8 10	 shr	 eax, 16
  00061	83 e0 0f	 and	 eax, 15
  00064	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00068	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0006c	c1 e8 14	 shr	 eax, 20
  0006f	83 e0 0f	 and	 eax, 15
  00072	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00076	83 7c 24 28 00	 cmp	 DWORD PTR b4$[rsp], 0
  0007b	74 2a		 je	 SHORT $LN5@s370_compa
  0007d	48 63 44 24 28	 movsxd	 rax, DWORD PTR b4$[rsp]
  00082	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  00092	03 c8		 add	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
  0009a	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0009e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr4$[rsp], eax
$LN5@s370_compa:
$LN4@s370_compa:
  000a7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  000b4	33 c0		 xor	 eax, eax
  000b6	83 f8 06	 cmp	 eax, 6
  000b9	74 0c		 je	 SHORT $LN6@s370_compa
  000bb	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@s370_compa:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 da		 jne	 SHORT $LN4@s370_compa

; 339  : 
; 340  :     TXFC_INSTR_CHECK_IP( regs );
; 341  : 
; 342  :     /* Compare signed operands and set comparison result */
; 343  :     cc = (S32)regs->GR_L(r1) < (S32)regs->GR_L(r2) ? 1 :

  000cd	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r2$[rsp]
  000d7	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000dc	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  000e1	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  000e9	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  000f0	7d 0a		 jge	 SHORT $LN12@s370_compa
  000f2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
  000fa	eb 3f		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  000fc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00101	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00106	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0010b	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00110	41 8b 8c c8 80
	02 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+640]
  00118	39 8c c2 80 02
	00 00		 cmp	 DWORD PTR [rdx+rax*8+640], ecx
  0011f	7e 0a		 jle	 SHORT $LN10@s370_compa
  00121	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv147[rsp], 2
  00129	eb 08		 jmp	 SHORT $LN11@s370_compa
$LN10@s370_compa:
  0012b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN11@s370_compa:
  00133	8b 44 24 34	 mov	 eax, DWORD PTR tv147[rsp]
  00137	89 44 24 38	 mov	 DWORD PTR tv148[rsp], eax
$LN13@s370_compa:
  0013b	8b 44 24 38	 mov	 eax, DWORD PTR tv148[rsp]
  0013f	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 344  :          (S32)regs->GR_L(r1) > (S32)regs->GR_L(r2) ? 2 : 0;
; 345  : 
; 346  :     /* Branch to operand address if m3 mask bit is set */
; 347  :     if ((0x8 >> cc) & m3)

  00143	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]
  00147	b9 08 00 00 00	 mov	 ecx, 8
  0014c	89 4c 24 40	 mov	 DWORD PTR tv193[rsp], ecx
  00150	0f b6 c8	 movzx	 ecx, al
  00153	8b 44 24 40	 mov	 eax, DWORD PTR tv193[rsp]
  00157	d3 f8		 sar	 eax, cl
  00159	23 44 24 44	 and	 eax, DWORD PTR m3$[rsp]
  0015d	85 c0		 test	 eax, eax
  0015f	74 10		 je	 SHORT $LN7@s370_compa

; 348  :         SUCCESSFUL_BRANCH( regs, effective_addr4 );

  00161	8b 54 24 20	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  00165	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_SuccessfulBranch
  0016f	eb 16		 jmp	 SHORT $LN8@s370_compa
$LN7@s370_compa:

; 349  :     else
; 350  :     {
; 351  :         /* Bump ip to next sequential instruction */
; 352  :         regs->ip += 6;

  00171	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00176	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0017a	48 83 c0 06	 add	 rax, 6
  0017e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@s370_compa:

; 353  :     }
; 354  : 
; 355  : } /* end DEF_INST(compare_and_branch_register) */

  00187	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018b	c3		 ret	 0
s370_compare_and_branch_register ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_add_logical_with_signed_immediate_long PROC

; 295  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 296  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 297  : BYTE    i2;                             /* Immediate byte            */
; 298  : int     b1;                             /* Base of effective addr    */
; 299  : VADR    effective_addr1;                /* Effective address         */
; 300  : U64     n;                              /* 64-bit operand value      */
; 301  : int     cc;                             /* Condition Code            */
; 302  : 
; 303  :     SIY(inst, regs, i2, b1, effective_addr1);
; 304  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 305  : 
; 306  :     /* Load 64-bit operand from operand address */
; 307  :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );
; 308  : 
; 309  :     /* Add operands and set condition code */
; 310  :     cc = (S8)i2 < 0 ?
; 311  :         sub_logical_long (&n, n, (S64)(-(S8)i2)) :
; 312  :         add_logical_long (&n, n, (S64)(S8)i2);
; 313  : 
; 314  :     /* Store 64-bit value at operand address */
; 315  :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );
; 316  : 
; 317  :     /* Update Condition Code */
; 318  :     regs->psw.cc = cc;
; 319  : 
; 320  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 321  :     ARCH_DEP(perform_interlocked_long_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_perform_interlocked_long_storage_immediate

; 322  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 323  : 
; 324  : } /* end DEF_INST(add_logical_with_signed_immediate_long) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_add_logical_with_signed_immediate_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_add_logical_with_signed_immediate PROC

; 259  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 260  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 261  : BYTE    i2;                             /* Immediate byte            */
; 262  : int     b1;                             /* Base of effective addr    */
; 263  : VADR    effective_addr1;                /* Effective address         */
; 264  : U32     n;                              /* 32-bit operand value      */
; 265  : int     cc;                             /* Condition Code            */
; 266  : 
; 267  :     SIY(inst, regs, i2, b1, effective_addr1);
; 268  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 269  : 
; 270  :     /* Load 32-bit operand from operand address */
; 271  :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );
; 272  : 
; 273  :     /* Add operands and set condition code */
; 274  :     cc = (S8)i2 < 0 ?
; 275  :         sub_logical (&n, n, (S32)(-(S8)i2)) :
; 276  :         add_logical (&n, n, (S32)(S8)i2);
; 277  : 
; 278  :     /* Store 32-bit operand at operand address */
; 279  :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );
; 280  : 
; 281  :     /* Update Condition Code */
; 282  :     regs->psw.cc = cc;
; 283  : 
; 284  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 285  :     ARCH_DEP(perform_interlocked_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_perform_interlocked_storage_immediate

; 286  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 287  : 
; 288  : } /* end DEF_INST(add_logical_with_signed_immediate) */

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_add_logical_with_signed_immediate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_add_immediate_storage PROC

; 183  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 184  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 185  : BYTE    i2;                             /* Immediate byte            */
; 186  : int     b1;                             /* Base of effective addr    */
; 187  : VADR    effective_addr1;                /* Effective address         */
; 188  : U32     n;                              /* 32-bit operand value      */
; 189  : int     cc;                             /* Condition Code            */
; 190  : 
; 191  :     SIY(inst, regs, i2, b1, effective_addr1);
; 192  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 193  : 
; 194  :     /* Load 32-bit operand from operand address */
; 195  :     n = ARCH_DEP(vfetch4) ( effective_addr1, b1, regs );
; 196  : 
; 197  :     /* Add signed operands and set condition code */
; 198  :     cc = add_signed (&n, n, (S32)(S8)i2);
; 199  : 
; 200  :     /* Store 32-bit operand at operand address */
; 201  :     ARCH_DEP(vstore4) ( n, effective_addr1, b1, regs );
; 202  : 
; 203  :     /* Update Condition Code */
; 204  :     regs->psw.cc = cc;
; 205  : 
; 206  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 207  :     ARCH_DEP(perform_interlocked_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_perform_interlocked_storage_immediate

; 208  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 209  : 
; 210  :     /* Program check if fixed-point overflow */
; 211  :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@s370_add_i
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@s370_add_i

; 212  :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s370_add_i:

; 213  : 
; 214  : } /* end DEF_INST(add_immediate_storage) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
s370_add_immediate_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\general3.c
_TEXT	SEGMENT
inst$ = 48
regs$ = 56
s370_add_immediate_long_storage PROC

; 221  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 222  : #if !defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )
; 223  : BYTE    i2;                             /* Immediate byte            */
; 224  : int     b1;                             /* Base of effective addr    */
; 225  : VADR    effective_addr1;                /* Effective address         */
; 226  : U64     n;                              /* 64-bit operand value      */
; 227  : int     cc;                             /* Condition Code            */
; 228  : 
; 229  :     SIY(inst, regs, i2, b1, effective_addr1);
; 230  :     PER_ZEROADDR_XCHECK( regs, b1 );
; 231  : 
; 232  :     /* Load 64-bit operand from operand address */
; 233  :     n = ARCH_DEP(vfetch8) ( effective_addr1, b1, regs );
; 234  : 
; 235  :     /* Add signed operands and set condition code */
; 236  :     cc = add_signed_long (&n, n, (S64)(S8)i2);
; 237  : 
; 238  :     /* Store 64-bit value at operand address */
; 239  :     ARCH_DEP(vstore8) ( n, effective_addr1, b1, regs );
; 240  : 
; 241  :     /* Update Condition Code */
; 242  :     regs->psw.cc = cc;
; 243  : 
; 244  : #else /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 ) */
; 245  :     ARCH_DEP(perform_interlocked_long_storage_immediate) (inst, regs);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 s370_perform_interlocked_long_storage_immediate

; 246  : #endif /* defined( FEATURE_045_INTERLOCKED_ACCESS_FACILITY_1 )*/
; 247  : 
; 248  :     /* Program check if fixed-point overflow */
; 249  :     if ( regs->psw.cc == 3 && FOMASK(&regs->psw) )

  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00022	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00026	83 f8 03	 cmp	 eax, 3
  00029	75 25		 jne	 SHORT $LN2@s370_add_i
  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 40 7d	 movzx	 eax, BYTE PTR [rax+125]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	74 15		 je	 SHORT $LN2@s370_add_i

; 250  :         regs->program_interrupt (regs, PGM_FIXED_POINT_OVERFLOW_EXCEPTION);

  0003b	ba 08 00 00 00	 mov	 edx, 8
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s370_add_i:

; 251  : 
; 252  : } /* end DEF_INST(add_immediate_long_storage) */

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
s370_add_immediate_long_storage ENDP
_TEXT	ENDS
END
