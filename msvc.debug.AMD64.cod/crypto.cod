; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	renew_wrapping_keys
PUBLIC	hopen_CSRNG
PUBLIC	hclose_CSRNG
PUBLIC	hget_random_bytes
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	BCryptOpenAlgorithmProvider:PROC
EXTRN	BCryptCloseAlgorithmProvider:PROC
EXTRN	BCryptGenRandom:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_NtStatusToLastError:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	get_lparname:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+169
	DD	imagerel $unwind$host_tod
$pdata$renew_wrapping_keys DD imagerel $LN57
	DD	imagerel $LN57+1210
	DD	imagerel $unwind$renew_wrapping_keys
$pdata$hopen_CSRNG DD imagerel $LN6
	DD	imagerel $LN6+240
	DD	imagerel $unwind$hopen_CSRNG
$pdata$hclose_CSRNG DD imagerel $LN6
	DD	imagerel $LN6+226
	DD	imagerel $unwind$hclose_CSRNG
$pdata$hget_random_bytes DD imagerel $LN6
	DD	imagerel $LN6+265
	DD	imagerel $unwind$hget_random_bytes
$pdata$default_hopen_CSRNG DD imagerel default_hopen_CSRNG
	DD	imagerel default_hopen_CSRNG+228
	DD	imagerel $unwind$default_hopen_CSRNG
$pdata$default_hclose_CSRNG DD imagerel default_hclose_CSRNG
	DD	imagerel default_hclose_CSRNG+162
	DD	imagerel $unwind$default_hclose_CSRNG
$pdata$default_hget_random_bytes DD imagerel default_hget_random_bytes
	DD	imagerel default_hget_random_bytes+328
	DD	imagerel $unwind$default_hget_random_bytes
pdata	ENDS
_DATA	SEGMENT
$SG188883 DB	'W', 00H
	ORG $+14
$SG188884 DB	'HHC01495%s Crypto: **WARNING** Default insecure ''rand()'
	DB	''' API being used', 0aH, 00H
	ORG $+3
$SG188954 DB	'E', 00H
	ORG $+2
$SG188885 DB	'default_hopen_CSRNG', 00H
$SG188965 DB	'W', 00H
	ORG $+2
$SG188886 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188896 DB	'default_hclose_CSRNG', 00H
	ORG $+3
$SG188897 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188898 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188900 DB	'default_hclose_CSRNG', 00H
	ORG $+3
$SG188901 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188927 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188902 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188926 DB	'default_hget_random_bytes', 00H
	ORG $+6
$SG188931 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188928 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188930 DB	'default_hget_random_bytes', 00H
	ORG $+6
$SG188937 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188932 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188936 DB	'default_hget_random_bytes', 00H
	ORG $+6
$SG188941 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188938 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188940 DB	'default_hget_random_bytes', 00H
	ORG $+6
$SG188951 DB	'R', 00H, 'N', 00H, 'G', 00H, 00H, 00H
$SG188942 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG188950 DB	'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H
	DB	'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'P', 00H, 'r', 00H, 'i'
	DB	00H, 'm', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'v', 00H, 'e', 00H
	DB	' ', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG188980 DB	'E', 00H
	ORG $+2
$SG188953 DB	'BCryptOpenAlgorithmProvider()', 00H
	ORG $+2
$SG188955 DB	'HHC01494%s Crypto: ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG188956 DB	'hopen_CSRNG', 00H
	ORG $+4
$SG188957 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188964 DB	'BCryptCloseAlgorithmProvider()', 00H
	ORG $+1
$SG188966 DB	'HHC01494%s Crypto: ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG188967 DB	'hclose_CSRNG', 00H
	ORG $+3
$SG188968 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG188979 DB	'BCryptGenRandom()', 00H
	ORG $+6
$SG188981 DB	'HHC01494%s Crypto: ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG188982 DB	'hget_random_bytes', 00H
	ORG $+6
$SG188983 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
$SG189033 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189034 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189035 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189037 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189038 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189039 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189042 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189043 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189044 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189046 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189047 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189048 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189051 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189052 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189053 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189055 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189056 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189057 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189060 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189061 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189062 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189064 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189065 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189066 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189069 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189070 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189071 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189073 DB	'renew_wrapping_keys', 00H
	ORG $+4
$SG189074 DB	'C:\papa\MyGit\hyperion-zvector\crypto.c', 00H
	ORG $+8
$SG189075 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:renew_wrapping_keys
	DD	010H
	DD	04a7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	097H
voltbl	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$renew_wrapping_keys DD 021519H
	DD	07002d206H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$hopen_CSRNG DD 010401H
	DD	0e204H
$unwind$hclose_CSRNG DD 010401H
	DD	0c204H
$unwind$hget_random_bytes DD 010e01H
	DD	0c20eH
$unwind$default_hopen_CSRNG DD 010401H
	DD	0a204H
$unwind$default_hclose_CSRNG DD 010401H
	DD	04204H
$unwind$default_hget_random_bytes DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
tv134 = 32
buf$ = 64
amt$ = 72
default_hget_random_bytes PROC

; 102  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@default_hg:

; 103  :     ASSERT( sysblk.use_def_crypt );

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	0f b6 80 98 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3736]
  0001c	85 c0		 test	 eax, eax
  0001e	75 5c		 jne	 SHORT $LN16@default_hg
$LN7@default_hg:
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188926
  00027	41 b8 67 00 00
	00		 mov	 r8d, 103		; 00000067H
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188927
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188928
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 20		 je	 SHORT $LN17@default_hg
  0004b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188930
  00052	41 b8 67 00 00
	00		 mov	 r8d, 103		; 00000067H
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188931
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188932
  00066	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@default_hg:
  0006b	33 c0		 xor	 eax, eax
  0006d	85 c0		 test	 eax, eax
  0006f	75 af		 jne	 SHORT $LN7@default_hg
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00077	85 c0		 test	 eax, eax
  00079	74 01		 je	 SHORT $LN18@default_hg
  0007b	cc		 int	 3
$LN18@default_hg:
$LN16@default_hg:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 8c		 jne	 SHORT $LN4@default_hg

; 104  :     if (!sysblk.wkrandhand)

  00082	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00089	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  00091	75 6e		 jne	 SHORT $LN19@default_hg
$LN10@default_hg:

; 105  :         VERIFY( default_hopen_CSRNG() );

  00093	e8 00 00 00 00	 call	 default_hopen_CSRNG
  00098	0f b6 c0	 movzx	 eax, al
  0009b	85 c0		 test	 eax, eax
  0009d	75 5c		 jne	 SHORT $LN20@default_hg
$LN13@default_hg:
  0009f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188936
  000a6	41 b8 69 00 00
	00		 mov	 r8d, 105		; 00000069H
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188937
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188938
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c6	85 c0		 test	 eax, eax
  000c8	74 20		 je	 SHORT $LN21@default_hg
  000ca	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188940
  000d1	41 b8 69 00 00
	00		 mov	 r8d, 105		; 00000069H
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188941
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188942
  000e5	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@default_hg:
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 af		 jne	 SHORT $LN13@default_hg
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f6	85 c0		 test	 eax, eax
  000f8	74 01		 je	 SHORT $LN22@default_hg
  000fa	cc		 int	 3
$LN22@default_hg:
$LN20@default_hg:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 92		 jne	 SHORT $LN10@default_hg
$LN19@default_hg:
$LN14@default_hg:

; 106  :     while (amt--)

  00101	48 8b 44 24 48	 mov	 rax, QWORD PTR amt$[rsp]
  00106	48 89 44 24 20	 mov	 QWORD PTR tv134[rsp], rax
  0010b	48 8b 44 24 48	 mov	 rax, QWORD PTR amt$[rsp]
  00110	48 ff c8	 dec	 rax
  00113	48 89 44 24 48	 mov	 QWORD PTR amt$[rsp], rax
  00118	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv134[rsp], 0
  0011e	74 21		 je	 SHORT $LN15@default_hg

; 107  :         *buf++ = (rand() & 0xFF);

  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00126	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00130	88 01		 mov	 BYTE PTR [rcx], al
  00132	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  00137	48 ff c0	 inc	 rax
  0013a	48 89 44 24 40	 mov	 QWORD PTR buf$[rsp], rax
  0013f	eb c0		 jmp	 SHORT $LN14@default_hg
$LN15@default_hg:

; 108  :     return true;

  00141	b0 01		 mov	 al, 1

; 109  : }

  00143	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00147	c3		 ret	 0
default_hget_random_bytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
default_hclose_CSRNG PROC

; 95   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@default_hc:

; 96   :     ASSERT( sysblk.use_def_crypt );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	0f b6 80 98 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3736]
  00012	85 c0		 test	 eax, eax
  00014	75 5c		 jne	 SHORT $LN8@default_hc
$LN7@default_hc:
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188896
  0001d	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188897
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188898
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 20		 je	 SHORT $LN9@default_hc
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG188900
  00048	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188901
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188902
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@default_hc:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 af		 jne	 SHORT $LN7@default_hc
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0006d	85 c0		 test	 eax, eax
  0006f	74 01		 je	 SHORT $LN10@default_hc
  00071	cc		 int	 3
$LN10@default_hc:
$LN8@default_hc:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 8c		 jne	 SHORT $LN4@default_hc

; 97   :     if (sysblk.wkrandhand)

  00078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007f	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  00087	74 12		 je	 SHORT $LN11@default_hc

; 98   :         sysblk.wkrandhand = 0;

  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00090	48 c7 80 20 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3616], 0
$LN11@default_hc:

; 99   :     return true;

  0009b	b0 01		 mov	 al, 1

; 100  : }

  0009d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a1	c3		 ret	 0
default_hclose_CSRNG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
i$1 = 64
tv82 = 68
randval$2 = 72
default_hopen_CSRNG PROC

; 76   : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 77   :     sysblk.use_def_crypt = true;        /* Default algorithm in use  */

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	c6 80 98 0e 00
	00 01		 mov	 BYTE PTR [rax+3736], 1

; 78   : 
; 79   :     if (!sysblk.wkrandhand)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00019	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  00021	0f 85 b6 00 00
	00		 jne	 $LN5@default_ho

; 80   :     {
; 81   :         int i, randval;
; 82   :         // "Crypto: **WARNING** Default insecure 'rand()' API being used"
; 83   :         WRMSG( HHC01495, "W" );

  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188883
  00039	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188884
  00045	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188885
  0005c	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188886
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 84   :         srand( (unsigned) time(0) );

  0006e	33 c9		 xor	 ecx, ecx
  00070	e8 00 00 00 00	 call	 time
  00075	8b c8		 mov	 ecx, eax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 85   :         for (i=0; i < 256; i++)

  0007d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00085	eb 0a		 jmp	 SHORT $LN4@default_ho
$LN2@default_ho:
  00087	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0008b	ff c0		 inc	 eax
  0008d	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN4@default_ho:
  00091	81 7c 24 40 00
	01 00 00	 cmp	 DWORD PTR i$1[rsp], 256	; 00000100H
  00099	7d 30		 jge	 SHORT $LN3@default_ho

; 86   :         {
; 87   :             randval = (int) rand() * (int) (host_tod() & 0xFFFFFFFF);

  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000a1	89 44 24 44	 mov	 DWORD PTR tv82[rsp], eax
  000a5	e8 00 00 00 00	 call	 host_tod
  000aa	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  000af	48 23 c1	 and	 rax, rcx
  000b2	8b 4c 24 44	 mov	 ecx, DWORD PTR tv82[rsp]
  000b6	0f af c8	 imul	 ecx, eax
  000b9	8b c1		 mov	 eax, ecx
  000bb	89 44 24 48	 mov	 DWORD PTR randval$2[rsp], eax

; 88   :             srand( (unsigned) randval );

  000bf	8b 4c 24 48	 mov	 ecx, DWORD PTR randval$2[rsp]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 89   :         }

  000c9	eb bc		 jmp	 SHORT $LN2@default_ho
$LN3@default_ho:

; 90   :         sysblk.wkrandhand = (HRANDHAND) DUMMY_CYRPTO_HANDLE;

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d2	48 c7 80 20 0e
	00 00 c7 d5 d9
	7f		 mov	 QWORD PTR [rax+3616], 2144982471 ; 7fd9d5c7H
$LN5@default_ho:

; 91   :     }
; 92   :     return true;

  000dd	b0 01		 mov	 al, 1

; 93   : }

  000df	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e3	c3		 ret	 0
default_hopen_CSRNG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
ntStatus$1 = 80
tv83 = 88
buf$ = 112
amt$ = 120
hget_random_bytes PROC

; 287  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 288  :     if (sysblk.use_def_crypt)

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	0f b6 80 98 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3736]
  0001c	85 c0		 test	 eax, eax
  0001e	74 14		 je	 SHORT $LN2@hget_rando

; 289  :         return default_hget_random_bytes( buf, amt );

  00020	48 8b 54 24 78	 mov	 rdx, QWORD PTR amt$[rsp]
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf$[rsp]
  0002a	e8 00 00 00 00	 call	 default_hget_random_bytes
  0002f	e9 d0 00 00 00	 jmp	 $LN1@hget_rando
$LN2@hget_rando:

; 290  : 
; 291  :     if (1
; 292  :         && !sysblk.wkrandhand
; 293  :         && !hopen_CSRNG()

  00034	33 c0		 xor	 eax, eax
  00036	83 f8 01	 cmp	 eax, 1
  00039	74 24		 je	 SHORT $LN3@hget_rando
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00042	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  0004a	75 13		 jne	 SHORT $LN3@hget_rando
  0004c	e8 00 00 00 00	 call	 hopen_CSRNG
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	75 07		 jne	 SHORT $LN3@hget_rando

; 294  :     )
; 295  :         return false;

  00058	32 c0		 xor	 al, al
  0005a	e9 a5 00 00 00	 jmp	 $LN1@hget_rando
$LN3@hget_rando:

; 296  : 
; 297  : #if defined( USE_ARC4RANDOM )
; 298  : 
; 299  :     {
; 300  :         arc4random_buf( buf, amt );
; 301  :     }
; 302  : 
; 303  : #elif defined( USE_SYS_GETRANDOM )
; 304  : 
; 305  :     {
; 306  :         size_t   chunk, offset = 0;
; 307  :         ssize_t  rc;
; 308  : 
; 309  :         while (amt > 0)
; 310  :         {
; 311  :             chunk = (amt <= MAX_CSRNG_BYTES) ? amt : MAX_CSRNG_BYTES;
; 312  : 
; 313  :             do rc = syscall( SYS_getrandom, buf + offset, chunk, 0 );
; 314  :             while (rc < 0 && errno == EINTR);
; 315  : 
; 316  :             if (rc < 0)
; 317  :             {
; 318  :                 // "Crypto: '%s' failed: %s"
; 319  :                 WRMSG( HHC01494, "E", "syscall()", strerror( errno ));
; 320  :                 return false;
; 321  :             }
; 322  : 
; 323  :             offset  +=  rc;
; 324  :             amt     -=  rc;
; 325  :         }
; 326  :     }
; 327  : 
; 328  : #elif defined( USE_DEV_URANDOM )
; 329  : 
; 330  :     {
; 331  :         size_t   chunk, offset = 0;
; 332  :         ssize_t  rc;
; 333  : 
; 334  :         /* Loop while bytes remain to be gotten... */
; 335  :         while (amt > 0)
; 336  :         {
; 337  :             chunk = (amt <= MAX_CSRNG_BYTES) ? amt : MAX_CSRNG_BYTES;
; 338  : 
; 339  :             do rc = read( sysblk.wkrandhand, buf + offset, chunk );
; 340  :             while (rc < 0 && (errno == EAGAIN || errno == EINTR));
; 341  : 
; 342  :             if (rc < 0)
; 343  :             {
; 344  :                 // "Crypto: '%s' failed: %s"
; 345  :                 WRMSG( HHC01494, "E", "read()", strerror( errno ));
; 346  :                 return false;
; 347  :             }
; 348  : 
; 349  :             offset  +=  rc;
; 350  :             amt     -=  rc;
; 351  :         }
; 352  :     }
; 353  : 
; 354  : #else // defined( _WIN32 )
; 355  : 
; 356  :     {
; 357  :         NTSTATUS ntStatus = BCryptGenRandom( sysblk.wkrandhand, buf, amt, 0 );

  0005f	45 33 c9	 xor	 r9d, r9d
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR amt$[rsp]
  00067	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf$[rsp]
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00073	48 8b 88 20 0e
	00 00		 mov	 rcx, QWORD PTR [rax+3616]
  0007a	e8 00 00 00 00	 call	 BCryptGenRandom
  0007f	89 44 24 50	 mov	 DWORD PTR ntStatus$1[rsp], eax

; 358  : 
; 359  :         if (!NT_SUCCESS( ntStatus ))

  00083	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$1[rsp], 0
  00088	7d 78		 jge	 SHORT $LN4@hget_rando

; 360  :         {
; 361  :             // "Crypto: '%s' failed: %s"
; 362  :             WRMSG( HHC01494, "E", "BCryptGenRandom()",

  0008a	8b 4c 24 50	 mov	 ecx, DWORD PTR ntStatus$1[rsp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_NtStatusToLastError
  00094	8b c8		 mov	 ecx, eax
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009c	48 89 44 24 58	 mov	 QWORD PTR tv83[rsp], rax
  000a1	b9 01 00 00 00	 mov	 ecx, 1
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv83[rsp]
  000b1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188979
  000bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188980
  000c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188981
  000d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000df	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188982
  000ec	ba 6b 01 00 00	 mov	 edx, 363		; 0000016bH
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188983
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 363  :                 strerror( w32_NtStatusToLastError( ntStatus )));
; 364  :             return false;

  000fe	32 c0		 xor	 al, al
  00100	eb 02		 jmp	 SHORT $LN1@hget_rando
$LN4@hget_rando:

; 365  :         }
; 366  :     }
; 367  : 
; 368  : #endif
; 369  : 
; 370  :     return true;

  00102	b0 01		 mov	 al, 1
$LN1@hget_rando:

; 371  : }

  00104	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00108	c3		 ret	 0
hget_random_bytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
ntStatus$1 = 80
tv75 = 88
hclose_CSRNG PROC

; 242  : {

$LN6:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 243  :     if (sysblk.use_def_crypt)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	0f b6 80 98 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3736]
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN2@hclose_CSR

; 244  :         return default_hclose_CSRNG();

  00016	e8 00 00 00 00	 call	 default_hclose_CSRNG
  0001b	e9 bd 00 00 00	 jmp	 $LN1@hclose_CSR
$LN2@hclose_CSR:

; 245  : 
; 246  :     if (sysblk.wkrandhand)

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  0002f	0f 84 a6 00 00
	00		 je	 $LN3@hclose_CSR

; 247  :     {
; 248  : #if defined( USE_DEV_URANDOM )
; 249  : 
; 250  :         int rc, fd = sysblk.wkrandhand;
; 251  : 
; 252  :         do rc = close( fd );
; 253  :         while (rc < 0 && errno == EINTR);
; 254  : 
; 255  :         if (rc < 0)
; 256  :         {
; 257  :             // "Crypto: '%s' failed: %s"
; 258  :             WRMSG( HHC01494, "W", "close()", strerror( errno ));
; 259  :         }
; 260  : 
; 261  : #elif defined( _WIN32 )
; 262  : 
; 263  :         NTSTATUS  ntStatus  = BCryptCloseAlgorithmProvider

  00035	33 d2		 xor	 edx, edx
  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003e	48 8b 88 20 0e
	00 00		 mov	 rcx, QWORD PTR [rax+3616]
  00045	e8 00 00 00 00	 call	 BCryptCloseAlgorithmProvider
  0004a	89 44 24 50	 mov	 DWORD PTR ntStatus$1[rsp], eax

; 264  :         (
; 265  :             sysblk.wkrandhand,
; 266  :             0  // (no flags)
; 267  :         );
; 268  : 
; 269  :         if (!NT_SUCCESS( ntStatus ))

  0004e	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$1[rsp], 0
  00053	7d 74		 jge	 SHORT $LN4@hclose_CSR

; 270  :         {
; 271  :             // "Crypto: '%s' failed: %s"
; 272  :             WRMSG( HHC01494, "W", "BCryptCloseAlgorithmProvider()",

  00055	8b 4c 24 50	 mov	 ecx, DWORD PTR ntStatus$1[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_NtStatusToLastError
  0005f	8b c8		 mov	 ecx, eax
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00067	48 89 44 24 58	 mov	 QWORD PTR tv75[rsp], rax
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv75[rsp]
  0007c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188964
  00088	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188965
  00094	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188966
  000a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188967
  000b7	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188968
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@hclose_CSR:

; 273  :                 strerror( w32_NtStatusToLastError( ntStatus )));
; 274  :         }
; 275  : #endif
; 276  : 
; 277  :         sysblk.wkrandhand = 0;      // (always!)

  000c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d0	48 c7 80 20 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3616], 0
$LN3@hclose_CSR:

; 278  :     }
; 279  : 
; 280  :     return true;

  000db	b0 01		 mov	 al, 1
$LN1@hclose_CSR:

; 281  : }

  000dd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e1	c3		 ret	 0
hclose_CSRNG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
ntStatus$1 = 80
tv76 = 88
hBCryptAlgHandle$2 = 96
hopen_CSRNG PROC

; 115  : {

$LN6:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 116  :     if (sysblk.use_def_crypt)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	0f b6 80 98 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3736]
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN2@hopen_CSRN

; 117  :         return default_hopen_CSRNG();

  00016	e8 00 00 00 00	 call	 default_hopen_CSRNG
  0001b	e9 cb 00 00 00	 jmp	 $LN1@hopen_CSRN
$LN2@hopen_CSRN:

; 118  : 
; 119  :     if (!sysblk.wkrandhand)

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	48 83 b8 20 0e
	00 00 00	 cmp	 QWORD PTR [rax+3616], 0
  0002f	0f 85 b4 00 00
	00		 jne	 $LN3@hopen_CSRN

; 120  :     {
; 121  : #if !defined( NEED_CSRNG_INIT )
; 122  : 
; 123  :         sysblk.wkrandhand = DUMMY_CYRPTO_HANDLE;
; 124  : 
; 125  : #elif defined( USE_RAND_API )
; 126  : 
; 127  :         return default_hopen_CSRNG();
; 128  : 
; 129  : #elif defined( USE_DEV_URANDOM )
; 130  : 
; 131  :         int fd, ioctl_code, entropy, rc;
; 132  : 
; 133  :         /* PROGRAMMING NOTE: we purposely use "dev/urandom" and NOT
; 134  :            "/dev/random" in order to to prevent us from blocking while
; 135  :            we wait for entropy, and doing so is *NOT* any less secure
; 136  :            than always using "/dev/random"! (for our purposes)
; 137  : 
; 138  :            Ref:   "Myths about /dev/urandom"
; 139  :                    https://www.2uo.de/myths-about-urandom/
; 140  :         */
; 141  :         do fd = open( "/dev/urandom", O_RDONLY );
; 142  :         while (fd < 0 && errno == EINTR);
; 143  : 
; 144  :         if (fd < 0)
; 145  :         {
; 146  :             // "Crypto: '%s' failed: %s"
; 147  :             WRMSG( HHC01494, "E", "open()", strerror( errno ));
; 148  :             return default_hopen_CSRNG();
; 149  :         }
; 150  : 
; 151  :         ioctl_code = RNDGETENTCNT;  /* Try this one first */
; 152  :         if ((rc = ioctl( fd, ioctl_code, &entropy )) < 0)
; 153  :         {
; 154  :             if (ENOTTY != errno)
; 155  :             {
; 156  :                 // "Crypto: '%s' failed: %s"
; 157  :                 WRMSG( HHC01494, "E", "ioctl()", strerror( errno ));
; 158  :                 close( fd );
; 159  :                 return default_hopen_CSRNG();
; 160  :             }
; 161  : 
; 162  :             // "Crypto: '%s' failed: %s"
; 163  :             WRMSG( HHC01494, "W", "ioctl( RNDGETENTCNT )", "Trying RNDGETENTCNT_ALT..." );
; 164  : 
; 165  :             ioctl_code = RNDGETENTCNT_ALT;  /* Try this one next */
; 166  :             if ((rc = ioctl( fd, ioctl_code, &entropy )) < 0)
; 167  :             {
; 168  :                 // "Crypto: '%s' failed: %s"
; 169  :                 WRMSG( HHC01494, "E", "ioctl()", strerror( errno ));
; 170  :                 close( fd );
; 171  :                 return default_hopen_CSRNG();
; 172  :             }
; 173  :         }
; 174  : 
; 175  :         /* Wait for minimum required entropy */
; 176  :         while (entropy < MIN_ENTROPY_BITS)
; 177  :         {
; 178  :             /* Use poll(), just like libsodium, since
; 179  :                we do not want to read from the device.
; 180  :             */
; 181  :             struct pollfd pfd;
; 182  : 
; 183  :             pfd.fd      = fd;
; 184  :             pfd.events  = POLLIN;
; 185  : 
; 186  :             /* Wait one millisecond and try again
; 187  :                until we get all the entropy we need.
; 188  :             */
; 189  :             do rc = poll( &pfd, 1, 1 );
; 190  :             while (rc < 0 && (EINTR == errno || EAGAIN == errno));
; 191  : 
; 192  :             if (rc < 0)
; 193  :             {
; 194  :                 // "Crypto: '%s' failed: %s"
; 195  :                 WRMSG( HHC01494, "E", "poll()", strerror( errno ));
; 196  :                 close( fd );
; 197  :                 return default_hopen_CSRNG();
; 198  :             }
; 199  : 
; 200  :             if ((rc = ioctl( fd, ioctl_code, &entropy )) < 0)
; 201  :             {
; 202  :                 // "Crypto: '%s' failed: %s"
; 203  :                 WRMSG( HHC01494, "E", "ioctl()", strerror( errno ));
; 204  :                 close( fd );
; 205  :                 return default_hopen_CSRNG();
; 206  :             }
; 207  :         }
; 208  : 
; 209  :         sysblk.wkrandhand = fd;
; 210  : 
; 211  : #else // defined( _WIN32 )
; 212  : 
; 213  :         BCRYPT_ALG_HANDLE  hBCryptAlgHandle;
; 214  : 
; 215  :         NTSTATUS  ntStatus  = BCryptOpenAlgorithmProvider

  00035	45 33 c9	 xor	 r9d, r9d
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188950
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188951
  00046	48 8d 4c 24 60	 lea	 rcx, QWORD PTR hBCryptAlgHandle$2[rsp]
  0004b	e8 00 00 00 00	 call	 BCryptOpenAlgorithmProvider
  00050	89 44 24 50	 mov	 DWORD PTR ntStatus$1[rsp], eax

; 216  :         (
; 217  :             &hBCryptAlgHandle,
; 218  :             BCRYPT_RNG_ALGORITHM,
; 219  :             MS_PRIMITIVE_PROVIDER,
; 220  :             0  // (no flags)
; 221  :         );
; 222  : 
; 223  :         if (!NT_SUCCESS( ntStatus ))

  00054	83 7c 24 50 00	 cmp	 DWORD PTR ntStatus$1[rsp], 0
  00059	7d 7b		 jge	 SHORT $LN4@hopen_CSRN

; 224  :         {
; 225  :             // "Crypto: '%s' failed: %s"
; 226  :             WRMSG( HHC01494, "E", "BCryptOpenAlgorithmProvider()",

  0005b	8b 4c 24 50	 mov	 ecx, DWORD PTR ntStatus$1[rsp]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_NtStatusToLastError
  00065	8b c8		 mov	 ecx, eax
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0006d	48 89 44 24 58	 mov	 QWORD PTR tv76[rsp], rax
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv76[rsp]
  00082	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188953
  0008e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188954
  0009a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188955
  000a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188956
  000bd	ba e3 00 00 00	 mov	 edx, 227		; 000000e3H
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188957
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 227  :                 strerror( w32_NtStatusToLastError( ntStatus )));
; 228  :             return default_hopen_CSRNG();

  000cf	e8 00 00 00 00	 call	 default_hopen_CSRNG
  000d4	eb 15		 jmp	 SHORT $LN1@hopen_CSRN
$LN4@hopen_CSRN:

; 229  :         }
; 230  : 
; 231  :         sysblk.wkrandhand = hBCryptAlgHandle;

  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hBCryptAlgHandle$2[rsp]
  000e2	48 89 88 20 0e
	00 00		 mov	 QWORD PTR [rax+3616], rcx
$LN3@hopen_CSRN:

; 232  : #endif
; 233  :     }
; 234  : 
; 235  :     return true;

  000e9	b0 01		 mov	 al, 1
$LN1@hopen_CSRN:

; 236  : }

  000eb	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000ef	c3		 ret	 0
hopen_CSRNG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\crypto.c
_TEXT	SEGMENT
lparnum1$ = 32
i$ = 40
idx$ = 48
cpuid$ = 56
lparname$ = 64
randbytes$ = 72
__$ArrayPad$ = 104
renew_wrapping_keys PROC

; 383  : {

$LN57:
  00000	40 57		 push	 rdi
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 384  :     U64     cpuid;
; 385  :     BYTE    lparname[8];
; 386  :     BYTE    randbytes[32];
; 387  :     size_t  i, idx = 0;

  00015	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR idx$[rsp], 0

; 388  :     BYTE    lparnum1;
; 389  : 
; 390  :     CASSERT( sizeof( sysblk.wkvpaes_reg ) >= sizeof( cpuid ) + sizeof( lparname ) + 1, crypto_c );
; 391  :     CASSERT( sizeof( sysblk.wkvpdea_reg ) >= sizeof( cpuid ) + sizeof( lparname ) + 1, crypto_c );
; 392  : 
; 393  :     /* Gather needed data */
; 394  : 
; 395  :     cpuid = sysblk.cpuid;

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0002c	48 89 44 24 38	 mov	 QWORD PTR cpuid$[rsp], rax

; 396  :     lparnum1 = sysblk.lparnum & 0xff;

  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00038	0f b7 80 f0 00
	00 00		 movzx	 eax, WORD PTR [rax+240]
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	88 44 24 20	 mov	 BYTE PTR lparnum1$[rsp], al

; 397  :     get_lparname( lparname );

  00048	48 8d 4c 24 40	 lea	 rcx, QWORD PTR lparname$[rsp]
  0004d	e8 00 00 00 00	 call	 get_lparname
$LN4@renew_wrap:

; 398  : 
; 399  :     VERIFY( hopen_CSRNG() );

  00052	e8 00 00 00 00	 call	 hopen_CSRNG
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	75 5c		 jne	 SHORT $LN41@renew_wrap
$LN7@renew_wrap:
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189033
  00065	41 b8 8f 01 00
	00		 mov	 r8d, 399		; 0000018fH
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189034
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189035
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00085	85 c0		 test	 eax, eax
  00087	74 20		 je	 SHORT $LN42@renew_wrap
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189037
  00090	41 b8 8f 01 00
	00		 mov	 r8d, 399		; 0000018fH
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189038
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189039
  000a4	e8 00 00 00 00	 call	 DebuggerTrace
$LN42@renew_wrap:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 af		 jne	 SHORT $LN7@renew_wrap
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b5	85 c0		 test	 eax, eax
  000b7	74 01		 je	 SHORT $LN43@renew_wrap
  000b9	cc		 int	 3
$LN43@renew_wrap:
$LN41@renew_wrap:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 92		 jne	 SHORT $LN4@renew_wrap
$LN10@renew_wrap:

; 400  :     {
; 401  :         VERIFY( hget_random_bytes( sysblk.wkaes_reg, sizeof( sysblk.wkaes_reg )));

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c7	48 05 28 0e 00
	00		 add	 rax, 3624		; 00000e28H
  000cd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 hget_random_bytes
  000da	0f b6 c0	 movzx	 eax, al
  000dd	85 c0		 test	 eax, eax
  000df	75 5c		 jne	 SHORT $LN44@renew_wrap
$LN13@renew_wrap:
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189042
  000e8	41 b8 91 01 00
	00		 mov	 r8d, 401		; 00000191H
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189043
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189044
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00108	85 c0		 test	 eax, eax
  0010a	74 20		 je	 SHORT $LN45@renew_wrap
  0010c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189046
  00113	41 b8 91 01 00
	00		 mov	 r8d, 401		; 00000191H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189047
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189048
  00127	e8 00 00 00 00	 call	 DebuggerTrace
$LN45@renew_wrap:
  0012c	33 c0		 xor	 eax, eax
  0012e	85 c0		 test	 eax, eax
  00130	75 af		 jne	 SHORT $LN13@renew_wrap
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00138	85 c0		 test	 eax, eax
  0013a	74 01		 je	 SHORT $LN46@renew_wrap
  0013c	cc		 int	 3
$LN46@renew_wrap:
$LN44@renew_wrap:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	0f 85 79 ff ff
	ff		 jne	 $LN10@renew_wrap
$LN16@renew_wrap:

; 402  :         VERIFY( hget_random_bytes( sysblk.wkdea_reg, sizeof( sysblk.wkdea_reg )));

  00147	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014e	48 05 48 0e 00
	00		 add	 rax, 3656		; 00000e48H
  00154	ba 18 00 00 00	 mov	 edx, 24
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 hget_random_bytes
  00161	0f b6 c0	 movzx	 eax, al
  00164	85 c0		 test	 eax, eax
  00166	75 5c		 jne	 SHORT $LN47@renew_wrap
$LN19@renew_wrap:
  00168	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189051
  0016f	41 b8 92 01 00
	00		 mov	 r8d, 402		; 00000192H
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189052
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189053
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0018f	85 c0		 test	 eax, eax
  00191	74 20		 je	 SHORT $LN48@renew_wrap
  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189055
  0019a	41 b8 92 01 00
	00		 mov	 r8d, 402		; 00000192H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189056
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189057
  001ae	e8 00 00 00 00	 call	 DebuggerTrace
$LN48@renew_wrap:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	75 af		 jne	 SHORT $LN19@renew_wrap
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001bf	85 c0		 test	 eax, eax
  001c1	74 01		 je	 SHORT $LN49@renew_wrap
  001c3	cc		 int	 3
$LN49@renew_wrap:
$LN47@renew_wrap:
  001c4	33 c0		 xor	 eax, eax
  001c6	85 c0		 test	 eax, eax
  001c8	0f 85 79 ff ff
	ff		 jne	 $LN16@renew_wrap
$LN22@renew_wrap:

; 403  :         VERIFY( hget_random_bytes( randbytes,        sizeof( randbytes        )));

  001ce	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR randbytes$[rsp]
  001d8	e8 00 00 00 00	 call	 hget_random_bytes
  001dd	0f b6 c0	 movzx	 eax, al
  001e0	85 c0		 test	 eax, eax
  001e2	75 5c		 jne	 SHORT $LN50@renew_wrap
$LN25@renew_wrap:
  001e4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189060
  001eb	41 b8 93 01 00
	00		 mov	 r8d, 403		; 00000193H
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189061
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189062
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0020b	85 c0		 test	 eax, eax
  0020d	74 20		 je	 SHORT $LN51@renew_wrap
  0020f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189064
  00216	41 b8 93 01 00
	00		 mov	 r8d, 403		; 00000193H
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189065
  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189066
  0022a	e8 00 00 00 00	 call	 DebuggerTrace
$LN51@renew_wrap:
  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	75 af		 jne	 SHORT $LN25@renew_wrap
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0023b	85 c0		 test	 eax, eax
  0023d	74 01		 je	 SHORT $LN52@renew_wrap
  0023f	cc		 int	 3
$LN52@renew_wrap:
$LN50@renew_wrap:
  00240	33 c0		 xor	 eax, eax
  00242	85 c0		 test	 eax, eax
  00244	75 88		 jne	 SHORT $LN22@renew_wrap
$LN28@renew_wrap:

; 404  :     }
; 405  :     VERIFY( hclose_CSRNG() );

  00246	e8 00 00 00 00	 call	 hclose_CSRNG
  0024b	0f b6 c0	 movzx	 eax, al
  0024e	85 c0		 test	 eax, eax
  00250	75 5c		 jne	 SHORT $LN53@renew_wrap
$LN31@renew_wrap:
  00252	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189069
  00259	41 b8 95 01 00
	00		 mov	 r8d, 405		; 00000195H
  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189070
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189071
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00279	85 c0		 test	 eax, eax
  0027b	74 20		 je	 SHORT $LN54@renew_wrap
  0027d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189073
  00284	41 b8 95 01 00
	00		 mov	 r8d, 405		; 00000195H
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189074
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189075
  00298	e8 00 00 00 00	 call	 DebuggerTrace
$LN54@renew_wrap:
  0029d	33 c0		 xor	 eax, eax
  0029f	85 c0		 test	 eax, eax
  002a1	75 af		 jne	 SHORT $LN31@renew_wrap
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a9	85 c0		 test	 eax, eax
  002ab	74 01		 je	 SHORT $LN55@renew_wrap
  002ad	cc		 int	 3
$LN55@renew_wrap:
$LN53@renew_wrap:
  002ae	33 c0		 xor	 eax, eax
  002b0	85 c0		 test	 eax, eax
  002b2	75 92		 jne	 SHORT $LN28@renew_wrap

; 406  : 
; 407  :     /*
; 408  :     **  We set the verification pattern to:
; 409  :     **
; 410  :     **    CPUID         (8 bytes)
; 411  :     **    LPAR Name     (8 bytes)
; 412  :     **    LPAR Number   (1 byte)   (low order)
; 413  :     **    Random bytes  (n bytes)  (remainder)
; 414  :     */
; 415  : 
; 416  :     memset( sysblk.wkvpaes_reg, 0, sizeof( sysblk.wkvpaes_reg ));

  002b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002bb	48 05 60 0e 00
	00		 add	 rax, 3680		; 00000e60H
  002c1	48 8b f8	 mov	 rdi, rax
  002c4	33 c0		 xor	 eax, eax
  002c6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002cb	f3 aa		 rep stosb

; 417  :     memset( sysblk.wkvpdea_reg, 0, sizeof( sysblk.wkvpdea_reg ));

  002cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d4	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  002da	48 8b f8	 mov	 rdi, rax
  002dd	33 c0		 xor	 eax, eax
  002df	b9 18 00 00 00	 mov	 ecx, 24
  002e4	f3 aa		 rep stosb

; 418  : 
; 419  :     /* CPUID */
; 420  : 
; 421  :     idx += sizeof( cpuid );  /* (since it's processed right to left) */

  002e6	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  002eb	48 83 c0 08	 add	 rax, 8
  002ef	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 422  : 
; 423  :     for (i=0; i < sizeof( cpuid ); i++)

  002f4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  002fd	eb 0d		 jmp	 SHORT $LN34@renew_wrap
$LN32@renew_wrap:
  002ff	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00304	48 ff c0	 inc	 rax
  00307	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN34@renew_wrap:
  0030c	48 83 7c 24 28
	08		 cmp	 QWORD PTR i$[rsp], 8
  00312	73 5c		 jae	 SHORT $LN33@renew_wrap

; 424  :     {
; 425  :         sysblk.wkvpaes_reg[ idx - 1 - i ] = cpuid & 0xff;

  00314	48 8b 44 24 38	 mov	 rax, QWORD PTR cpuid$[rsp]
  00319	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0031f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  00324	48 ff c9	 dec	 rcx
  00327	48 2b 4c 24 28	 sub	 rcx, QWORD PTR i$[rsp]
  0032c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00333	88 84 0a 60 0e
	00 00		 mov	 BYTE PTR [rdx+rcx+3680], al

; 426  :         sysblk.wkvpdea_reg[ idx - 1 - i ] = cpuid & 0xff;

  0033a	48 8b 44 24 38	 mov	 rax, QWORD PTR cpuid$[rsp]
  0033f	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00345	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  0034a	48 ff c9	 dec	 rcx
  0034d	48 2b 4c 24 28	 sub	 rcx, QWORD PTR i$[rsp]
  00352	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00359	88 84 0a 80 0e
	00 00		 mov	 BYTE PTR [rdx+rcx+3712], al

; 427  :         cpuid >>= 8;

  00360	48 8b 44 24 38	 mov	 rax, QWORD PTR cpuid$[rsp]
  00365	48 c1 e8 08	 shr	 rax, 8
  00369	48 89 44 24 38	 mov	 QWORD PTR cpuid$[rsp], rax

; 428  :     }

  0036e	eb 8f		 jmp	 SHORT $LN32@renew_wrap
$LN33@renew_wrap:

; 429  : 
; 430  :     /* LPAR Name */
; 431  : 
; 432  :     memcpy( &sysblk.wkvpaes_reg[ idx ], lparname, sizeof( lparname ));

  00370	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  00375	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0037c	48 03 c8	 add	 rcx, rax
  0037f	48 8b c1	 mov	 rax, rcx
  00382	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lparname$[rsp]
  00387	48 89 88 60 0e
	00 00		 mov	 QWORD PTR [rax+3680], rcx

; 433  :     memcpy( &sysblk.wkvpdea_reg[ idx ], lparname, sizeof( lparname ));

  0038e	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  00393	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0039a	48 03 c8	 add	 rcx, rax
  0039d	48 8b c1	 mov	 rax, rcx
  003a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lparname$[rsp]
  003a5	48 89 88 80 0e
	00 00		 mov	 QWORD PTR [rax+3712], rcx

; 434  : 
; 435  :     idx += sizeof( lparname );  /* (next field starts past this one) */

  003ac	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  003b1	48 83 c0 08	 add	 rax, 8
  003b5	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 436  : 
; 437  :     /* LPAR Number */
; 438  : 
; 439  :     sysblk.wkvpaes_reg[ idx ] = lparnum1;

  003ba	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  003bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003c6	48 03 c8	 add	 rcx, rax
  003c9	48 8b c1	 mov	 rax, rcx
  003cc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR lparnum1$[rsp]
  003d1	88 88 60 0e 00
	00		 mov	 BYTE PTR [rax+3680], cl

; 440  :     sysblk.wkvpdea_reg[ idx ] = lparnum1;

  003d7	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  003dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003e3	48 03 c8	 add	 rcx, rax
  003e6	48 8b c1	 mov	 rax, rcx
  003e9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR lparnum1$[rsp]
  003ee	88 88 80 0e 00
	00		 mov	 BYTE PTR [rax+3712], cl

; 441  : 
; 442  :     idx += 1;

  003f4	48 8b 44 24 30	 mov	 rax, QWORD PTR idx$[rsp]
  003f9	48 ff c0	 inc	 rax
  003fc	48 89 44 24 30	 mov	 QWORD PTR idx$[rsp], rax

; 443  : 
; 444  :     /* Random bytes (if there's room) */
; 445  : 
; 446  :     for (i=0; i < sizeof( sysblk.wkvpaes_reg ) - idx; i++)

  00401	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0040a	eb 0d		 jmp	 SHORT $LN37@renew_wrap
$LN35@renew_wrap:
  0040c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00411	48 ff c0	 inc	 rax
  00414	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN37@renew_wrap:
  00419	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0041e	48 2b 44 24 30	 sub	 rax, QWORD PTR idx$[rsp]
  00423	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00428	73 2a		 jae	 SHORT $LN36@renew_wrap

; 447  :                           sysblk.wkvpaes_reg[    idx + i ] = randbytes[i];

  0042a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0042f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  00434	48 03 c8	 add	 rcx, rax
  00437	48 8b c1	 mov	 rax, rcx
  0043a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00441	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00446	0f b6 54 14 48	 movzx	 edx, BYTE PTR randbytes$[rsp+rdx]
  0044b	88 94 01 60 0e
	00 00		 mov	 BYTE PTR [rcx+rax+3680], dl
  00452	eb b8		 jmp	 SHORT $LN35@renew_wrap
$LN36@renew_wrap:

; 448  : 
; 449  :     for (i=0; i < sizeof( sysblk.wkvpdea_reg ) - idx; i++)

  00454	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0045d	eb 0d		 jmp	 SHORT $LN40@renew_wrap
$LN38@renew_wrap:
  0045f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00464	48 ff c0	 inc	 rax
  00467	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN40@renew_wrap:
  0046c	b8 18 00 00 00	 mov	 eax, 24
  00471	48 2b 44 24 30	 sub	 rax, QWORD PTR idx$[rsp]
  00476	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0047b	73 2a		 jae	 SHORT $LN39@renew_wrap

; 450  :                           sysblk.wkvpdea_reg[    idx + i ] = randbytes[i];

  0047d	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00482	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idx$[rsp]
  00487	48 03 c8	 add	 rcx, rax
  0048a	48 8b c1	 mov	 rax, rcx
  0048d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00494	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00499	0f b6 54 14 48	 movzx	 edx, BYTE PTR randbytes$[rsp+rdx]
  0049e	88 94 01 80 0e
	00 00		 mov	 BYTE PTR [rcx+rax+3712], dl
  004a5	eb b8		 jmp	 SHORT $LN38@renew_wrap
$LN39@renew_wrap:

; 451  : 
; 452  :     /* Display wrapping keys if debugging... */
; 453  : 
; 454  : #if defined( WRAPPINGKEYS_DEBUG )  // (see beginning of source module)
; 455  : 
; 456  :     {
; 457  :         char  buf[128] = {0};
; 458  : 
; 459  : #define DBG_WRMSG_CRYPT_REG( dbg_msg, wk_reg )                                                      \
; 460  :                                                                                                     \
; 461  :         do                                                                                          \
; 462  :         {                                                                                           \
; 463  :             STRLCPY( buf, dbg_msg );                                                                \
; 464  :                                                                                                     \
; 465  :             for (i=0; i < sizeof( sysblk.wk_reg ); i++) snprintf( buf   + strlen( buf ),            \
; 466  :                                                           sizeof( buf ) - strlen( buf ), "%02X",    \
; 467  :                                   sysblk.wk_reg[i] );                                               \
; 468  :                                                                                                     \
; 469  :             WRMSG( HHC90190, "D", buf );                                                            \
; 470  :         }                                                                                           \
; 471  :         while (0)
; 472  : 
; 473  :         DBG_WRMSG_CRYPT_REG( "AES wrapping key:    ",   wkaes_reg );
; 474  :         DBG_WRMSG_CRYPT_REG( "AES wrapping key vp: ", wkvpaes_reg );
; 475  :         DBG_WRMSG_CRYPT_REG( "DEA wrapping key:    ",   wkdea_reg );
; 476  :         DBG_WRMSG_CRYPT_REG( "DEA wrapping key vp: ", wkvpdea_reg );
; 477  :     }
; 478  : 
; 479  : #endif // defined( WRAPPINGKEYS_DEBUG )
; 480  : }

  004a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004ac	48 33 cc	 xor	 rcx, rsp
  004af	e8 00 00 00 00	 call	 __security_check_cookie
  004b4	48 83 c4 70	 add	 rsp, 112		; 00000070H
  004b8	5f		 pop	 rdi
  004b9	c3		 ret	 0
renew_wrapping_keys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  00020	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00037	33 d2		 xor	 edx, edx
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003e	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00043	48 f7 f1	 div	 rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  00050	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00055	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005e	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00078	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a8	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
