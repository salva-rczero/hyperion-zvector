; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s390_trap_x
PUBLIC	s390_form_stack_entry
PUBLIC	s390_locate_stack_entry
PUBLIC	s390_stack_modify
PUBLIC	s390_stack_extract
PUBLIC	s390_unstack_registers
PUBLIC	s390_program_return_unstack
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_fetch_main_absolute
PUBLIC	s390_fetch_fullword_absolute
PUBLIC	s390_maddr_l
PUBLIC	z900_trap_x
PUBLIC	z900_form_stack_entry
PUBLIC	z900_locate_stack_entry
PUBLIC	z900_stack_modify
PUBLIC	z900_stack_extract
PUBLIC	z900_unstack_registers
PUBLIC	z900_program_return_unstack
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_fetch_main_absolute
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_fetch_fullword_absolute
PUBLIC	z900_maddr_l
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	s390_load_psw:PROC
EXTRN	s390_store_psw:PROC
EXTRN	z900_load_psw:PROC
EXTRN	z900_store_psw:PROC
EXTRN	s390_trace_br:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s390_invalidate_tlb:PROC
EXTRN	z900_Set_BEAR_Reg:PROC
EXTRN	z900_trace_br:PROC
EXTRN	z900_invalidate_tlb:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$s390_trap_x DD imagerel $LN126
	DD	imagerel $LN126+3818
	DD	imagerel $unwind$s390_trap_x
$pdata$s390_form_stack_entry DD imagerel $LN23
	DD	imagerel $LN23+1985
	DD	imagerel $unwind$s390_form_stack_entry
$pdata$s390_locate_stack_entry DD imagerel $LN12
	DD	imagerel $LN12+586
	DD	imagerel $unwind$s390_locate_stack_entry
$pdata$s390_stack_modify DD imagerel $LN3
	DD	imagerel $LN3+162
	DD	imagerel $unwind$s390_stack_modify
$pdata$s390_stack_extract DD imagerel $LN3
	DD	imagerel $LN3+213
	DD	imagerel $unwind$s390_stack_extract
$pdata$s390_unstack_registers DD imagerel $LN39
	DD	imagerel $LN39+914
	DD	imagerel $unwind$s390_unstack_registers
$pdata$s390_program_return_unstack DD imagerel $LN31
	DD	imagerel $LN31+1486
	DD	imagerel $unwind$s390_program_return_unstack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_main_absolute DD imagerel $LN9
	DD	imagerel $LN9+284
	DD	imagerel $unwind$s390_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s390_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$s390_abs_stack_addr DD imagerel s390_abs_stack_addr
	DD	imagerel s390_abs_stack_addr+73
	DD	imagerel $unwind$s390_abs_stack_addr
$pdata$s390_abs_trap_addr DD imagerel s390_abs_trap_addr
	DD	imagerel s390_abs_trap_addr+81
	DD	imagerel $unwind$s390_abs_trap_addr
$pdata$z900_trap_x DD imagerel $LN141
	DD	imagerel $LN141+4417
	DD	imagerel $unwind$z900_trap_x
$pdata$z900_form_stack_entry DD imagerel $LN31
	DD	imagerel $LN31+2773
	DD	imagerel $unwind$z900_form_stack_entry
$pdata$z900_locate_stack_entry DD imagerel $LN12
	DD	imagerel $LN12+557
	DD	imagerel $unwind$z900_locate_stack_entry
$pdata$z900_stack_modify DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$z900_stack_modify
$pdata$z900_stack_extract DD imagerel $LN9
	DD	imagerel $LN9+790
	DD	imagerel $unwind$z900_stack_extract
$pdata$z900_unstack_registers DD imagerel $LN42
	DD	imagerel $LN42+1156
	DD	imagerel $unwind$z900_unstack_registers
$pdata$z900_program_return_unstack DD imagerel $LN34
	DD	imagerel $LN34+1900
	DD	imagerel $unwind$z900_program_return_unstack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$z900_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$z900_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$z900_abs_stack_addr DD imagerel z900_abs_stack_addr
	DD	imagerel z900_abs_stack_addr+75
	DD	imagerel $unwind$z900_abs_stack_addr
$pdata$z900_abs_trap_addr DD imagerel z900_abs_trap_addr
	DD	imagerel z900_abs_trap_addr+83
	DD	imagerel $unwind$z900_abs_trap_addr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_main_absolute DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_program_return_unstack
	DD	020H
	DD	0754H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_form_stack_entry
	DD	025H
	DD	0abcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_trap_x
	DD	020H
	DD	01128H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_program_return_unstack
	DD	020H
	DD	05b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_form_stack_entry
	DD	024H
	DD	07a8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_trap_x
	DD	020H
	DD	0ed1H
voltbl	ENDS
xdata	SEGMENT
$unwind$s390_trap_x DD 032819H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s390_form_stack_entry DD 032c19H
	DD	012011aH
	DD	07013H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s390_locate_stack_entry DD 011201H
	DD	06212H
$unwind$s390_stack_modify DD 011601H
	DD	06216H
$unwind$s390_stack_extract DD 011601H
	DD	06216H
$unwind$s390_unstack_registers DD 011601H
	DD	0a216H
$unwind$s390_program_return_unstack DD 022819H
	DD	0150116H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_abs_stack_addr DD 011201H
	DD	06212H
$unwind$s390_abs_trap_addr DD 011201H
	DD	06212H
$unwind$z900_trap_x DD 032819H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$z900_form_stack_entry DD 032d19H
	DD	012011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$z900_locate_stack_entry DD 011201H
	DD	08212H
$unwind$z900_stack_modify DD 011701H
	DD	06217H
$unwind$z900_stack_extract DD 011701H
	DD	08217H
$unwind$z900_unstack_registers DD 011701H
	DD	0c217H
$unwind$z900_program_return_unstack DD 022819H
	DD	0170116H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_abs_stack_addr DD 011301H
	DD	06213H
$unwind$z900_abs_trap_addr DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
vaddr$ = 64
regs$ = 72
acctype$ = 80
z900_abs_trap_addr PROC

; 127  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 128  :     return MADDR(vaddr, USE_HOME_SPACE, regs, acctype, regs->psw.pkey) - regs->mainstor;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00018	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00020	8b 44 24 50	 mov	 eax, DWORD PTR acctype$[rsp]
  00024	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00028	4c 8b 4c 24 48	 mov	 r9, QWORD PTR regs$[rsp]
  0002d	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vaddr$[rsp]
  0003d	e8 00 00 00 00	 call	 z900_maddr_l
  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]

; 129  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
z900_abs_trap_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
vaddr$ = 64
regs$ = 72
acctype$ = 80
z900_abs_stack_addr PROC

; 121  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 122  :     return MADDR(vaddr, USE_HOME_SPACE, regs, acctype, 0) - regs->mainstor;

  00013	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00018	8b 44 24 50	 mov	 eax, DWORD PTR acctype$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8b 4c 24 48	 mov	 r9, QWORD PTR regs$[rsp]
  00025	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  0002b	ba 01 00 00 00	 mov	 edx, 1
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00035	e8 00 00 00 00	 call	 z900_maddr_l
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]

; 123  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
z900_abs_stack_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
z900_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
z900_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6b		 je	 SHORT $LN5@z900_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 56		 jne	 SHORT $LN5@z900_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00081	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00088	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_fetch:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00097	b2 04		 mov	 dl, 4
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009e	e8 00 00 00 00	 call	 z900_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000af	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b8	c3		 ret	 0
z900_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
lsea$ = 48
abs$ = 56
pkm$ = 64
sasn$ = 68
eax$ = 72
pasn$ = 76
tv170 = 80
tv270 = 84
tv300 = 88
tv318 = 92
tv337 = 96
tv342 = 100
permode$ = 104
lsep$ = 112
tv282 = 120
tv312 = 128
lsed$ = 136
newpsw$ = 144
__$ArrayPad$ = 160
regs$ = 192
lsedap$ = 200
rc$ = 208
z900_program_return_unstack PROC

; 1247 : {

$LN34:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1248 : QWORD   newpsw;                         /* New PSW                   */
; 1249 : LSED    lsed;                           /* Linkage stack entry desc. */
; 1250 : VADR    lsea;                           /* Linkage stack entry addr  */
; 1251 : RADR    abs;                            /* Absolute address          */
; 1252 : int     permode;                        /* 1=PER mode is set in PSW  */
; 1253 : U16     pkm;                            /* PSW key mask              */
; 1254 : U16     sasn;                           /* Secondary ASN             */
; 1255 : U16     eax;                            /* Extended AX               */
; 1256 : U16     pasn;                           /* Primary ASN               */
; 1257 : VADR    lsep;                           /* Virtual addr of entry desc.
; 1258 :                                            of previous stack entry   */
; 1259 : 
; 1260 :     /* Find the virtual address of the entry descriptor
; 1261 :        of the current state entry in the linkage stack */
; 1262 :     lsea = ARCH_DEP(locate_stack_entry) (1, &lsed, regs);

  00028	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00030	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR lsed$[rsp]
  00038	b9 01 00 00 00	 mov	 ecx, 1
  0003d	e8 00 00 00 00	 call	 z900_locate_stack_entry
  00042	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1263 : 
; 1264 :     /* [5.12.4.3] Restore information from stack entry */
; 1265 : 
; 1266 :     /* Load registers 2-14 from the stack entry */
; 1267 :     ARCH_DEP(unstack_registers) (1, lsea, 2, 14, regs);

  00047	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00054	41 b9 0e 00 00
	00		 mov	 r9d, 14
  0005a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00060	48 8b 54 24 30	 mov	 rdx, QWORD PTR lsea$[rsp]
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	e8 00 00 00 00	 call	 z900_unstack_registers

; 1268 : 
; 1269 :     /* Point back to the entry descriptor of previous stack entry */
; 1270 :     lsep = lsea - LSSE_SIZE;

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00074	48 2d 28 01 00
	00		 sub	 rax, 296		; 00000128H
  0007a	48 89 44 24 70	 mov	 QWORD PTR lsep$[rsp], rax

; 1271 :     LSEA_WRAP(lsep);
; 1272 : 
; 1273 :     /* Point back to byte 128 of the current state entry */
; 1274 :     lsea -= LSSE_SIZE - sizeof(LSED);

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00084	48 2d 20 01 00
	00		 sub	 rax, 288		; 00000120H
  0008a	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1275 :     lsea += 128;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00094	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0009a	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1276 :     LSEA_WRAP(lsea);
; 1277 : 
; 1278 :     /* Translate virtual address to absolute address */
; 1279 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0009f	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lsea$[rsp]
  000b2	e8 00 00 00 00	 call	 z900_abs_stack_addr
  000b7	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1280 : 
; 1281 :     /* For a call state entry, replace the PKM, SASN, EAX, and PASN */
; 1282 :     if ((lsed.uet & LSED_UET_ET) == LSED_UET_PC)

  000bc	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR lsed$[rsp]
  000c4	83 e0 7f	 and	 eax, 127		; 0000007fH
  000c7	83 f8 0d	 cmp	 eax, 13
  000ca	0f 85 2b 01 00
	00		 jne	 $LN8@z900_progr

; 1283 :     {
; 1284 :         /* Fetch the PKM from bytes 128-129 of the stack entry */
; 1285 :         FETCH_HW(pkm,regs->mainstor + abs);

  000d0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000df	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  000e4	48 8b c8	 mov	 rcx, rax
  000e7	e8 00 00 00 00	 call	 fetch_hw_noswap
  000ec	0f b7 c8	 movzx	 ecx, ax
  000ef	e8 00 00 00 00	 call	 _byteswap_ushort
  000f4	66 89 44 24 40	 mov	 WORD PTR pkm$[rsp], ax

; 1286 : 
; 1287 :         /* Fetch the SASN from bytes 130-131 of the stack entry */
; 1288 :         FETCH_HW(sasn,regs->mainstor + abs + 2);

  000f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00108	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  0010d	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00112	48 8b c8	 mov	 rcx, rax
  00115	e8 00 00 00 00	 call	 fetch_hw_noswap
  0011a	0f b7 c8	 movzx	 ecx, ax
  0011d	e8 00 00 00 00	 call	 _byteswap_ushort
  00122	66 89 44 24 44	 mov	 WORD PTR sasn$[rsp], ax

; 1289 : 
; 1290 :         /* Fetch the EAX from bytes 132-133 of the stack entry */
; 1291 :         FETCH_HW(eax,regs->mainstor + abs + 4);

  00127	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00136	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  0013b	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 fetch_hw_noswap
  00148	0f b7 c8	 movzx	 ecx, ax
  0014b	e8 00 00 00 00	 call	 _byteswap_ushort
  00150	66 89 44 24 48	 mov	 WORD PTR eax$[rsp], ax

; 1292 : 
; 1293 :         /* Fetch the PASN from bytes 134-135 of the stack entry */
; 1294 :         FETCH_HW(pasn,regs->mainstor + abs + 6);

  00155	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00164	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00169	48 8d 44 08 06	 lea	 rax, QWORD PTR [rax+rcx+6]
  0016e	48 8b c8	 mov	 rcx, rax
  00171	e8 00 00 00 00	 call	 fetch_hw_noswap
  00176	0f b7 c8	 movzx	 ecx, ax
  00179	e8 00 00 00 00	 call	 _byteswap_ushort
  0017e	66 89 44 24 4c	 mov	 WORD PTR pasn$[rsp], ax

; 1295 : 
; 1296 :       #ifdef STACK_DEBUG
; 1297 :         logmsg (_("stack: PKM=%2.2X%2.2X SASN=%2.2X%2.2X "
; 1298 :                 "EAX=%2.2X%2.2X PASN=%2.2X%2.2X \n"
; 1299 :                 "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1300 :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 1301 :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1302 :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1303 :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1304 :                 lsea, abs);
; 1305 :       #endif /*STACK_DEBUG*/
; 1306 : 
; 1307 :         /* Load PKM into CR3 bits 0-15 (32-47) */
; 1308 :         regs->CR_LHH(3) = pkm;

  00183	b8 08 00 00 00	 mov	 eax, 8
  00188	48 6b c0 04	 imul	 rax, rax, 4
  0018c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	0f b7 54 24 40	 movzx	 edx, WORD PTR pkm$[rsp]
  00199	66 89 94 01 02
	06 00 00	 mov	 WORD PTR [rcx+rax+1538], dx

; 1309 : 
; 1310 :         /* Load SASN into CR3 bits 16-31 (48-63) */
; 1311 :         regs->CR_LHL(3) = sasn;

  001a1	b8 08 00 00 00	 mov	 eax, 8
  001a6	48 6b c0 04	 imul	 rax, rax, 4
  001aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	0f b7 54 24 44	 movzx	 edx, WORD PTR sasn$[rsp]
  001b7	66 89 94 01 00
	06 00 00	 mov	 WORD PTR [rcx+rax+1536], dx

; 1312 : 
; 1313 :         /* Load EAX into CR8 bits 0-15 (32-47) */
; 1314 :         regs->CR_LHH(8) = eax;

  001bf	b8 08 00 00 00	 mov	 eax, 8
  001c4	48 6b c0 09	 imul	 rax, rax, 9
  001c8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	0f b7 54 24 48	 movzx	 edx, WORD PTR eax$[rsp]
  001d5	66 89 94 01 02
	06 00 00	 mov	 WORD PTR [rcx+rax+1538], dx

; 1315 : 
; 1316 :         /* Load PASN into CR4 bits 16-31 (48-63) */
; 1317 :         regs->CR_LHL(4) = pasn;

  001dd	b8 08 00 00 00	 mov	 eax, 8
  001e2	48 6b c0 05	 imul	 rax, rax, 5
  001e6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	0f b7 54 24 4c	 movzx	 edx, WORD PTR pasn$[rsp]
  001f3	66 89 94 01 00
	06 00 00	 mov	 WORD PTR [rcx+rax+1536], dx
$LN8@z900_progr:

; 1318 : 
; 1319 :     } /* end if(LSED_UET_PC) */
; 1320 : 
; 1321 :     /* Update virtual and absolute addresses to point to byte 136 */
; 1322 :     lsea += 8;

  001fb	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00200	48 83 c0 08	 add	 rax, 8
  00204	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1323 :     LSEA_WRAP(lsea);
; 1324 :     abs += 8;

  00209	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  0020e	48 83 c0 08	 add	 rax, 8
  00212	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1325 : 
; 1326 :     /* Recalculate absolute address if page boundary crossed */
; 1327 :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00217	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  0021c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00222	48 85 c0	 test	 rax, rax
  00225	75 1d		 jne	 SHORT $LN9@z900_progr

; 1328 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00227	41 b8 04 00 00
	00		 mov	 r8d, 4
  0022d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00235	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lsea$[rsp]
  0023a	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0023f	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax
$LN9@z900_progr:

; 1329 : 
; 1330 :     /* Save the PER mode bit from the current PSW */
; 1331 :     permode = (regs->psw.sysmask & PSW_PERMODE) ? 1 : 0;

  00244	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00250	83 e0 40	 and	 eax, 64			; 00000040H
  00253	85 c0		 test	 eax, eax
  00255	74 0a		 je	 SHORT $LN18@z900_progr
  00257	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  0025f	eb 08		 jmp	 SHORT $LN19@z900_progr
$LN18@z900_progr:
  00261	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN19@z900_progr:
  00269	8b 44 24 50	 mov	 eax, DWORD PTR tv170[rsp]
  0026d	89 44 24 68	 mov	 DWORD PTR permode$[rsp], eax

; 1332 : 
; 1333 :   #ifdef STACK_DEBUG
; 1334 :     logmsg (_("stack: PSW=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1335 :             "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1336 :             regs->mainstor[abs], regs->mainstor[abs+1],
; 1337 :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1338 :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1339 :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1340 :             lsea, abs);
; 1341 :   #endif /*STACK_DEBUG*/
; 1342 : 
; 1343 :     /* Copy PSW bits 0-63 from bytes 136-143 of the stack entry */
; 1344 :     memcpy (newpsw, regs->mainstor + abs, 8);

  00271	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00279	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00280	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00285	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00289	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR newpsw$[rsp], rax

; 1345 : 
; 1346 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1347 :     /* For ESAME, advance to byte 168 of the stack entry */
; 1348 :     lsea += 32;

  00291	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00296	48 83 c0 20	 add	 rax, 32			; 00000020H
  0029a	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1349 :     LSEA_WRAP(lsea);
; 1350 :     abs += 32;

  0029f	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  002a4	48 83 c0 20	 add	 rax, 32			; 00000020H
  002a8	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1351 : 
; 1352 :     /* Recalculate absolute address if page boundary crossed */
; 1353 :     if ((lsea & PAGEFRAME_BYTEMASK) < 32)

  002ad	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  002b2	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  002b8	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  002bc	73 1d		 jae	 SHORT $LN10@z900_progr

; 1354 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  002be	41 b8 04 00 00
	00		 mov	 r8d, 4
  002c4	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lsea$[rsp]
  002d1	e8 00 00 00 00	 call	 z900_abs_stack_addr
  002d6	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax
$LN10@z900_progr:

; 1355 : 
; 1356 :     /* Copy ESAME PSW bits 64-127 from bytes 168-175 */
; 1357 :     memcpy (newpsw + 8, regs->mainstor + abs, 8);

  002db	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  002ef	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  002f3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR newpsw$[rsp+8], rax

; 1358 : 
; 1359 :     /* Update virtual and absolute addresses to point to byte 176 */
; 1360 :     lsea += 8;

  002fb	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  00300	48 83 c0 08	 add	 rax, 8
  00304	48 89 44 24 30	 mov	 QWORD PTR lsea$[rsp], rax

; 1361 :     LSEA_WRAP(lsea);
; 1362 :     abs += 8;

  00309	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  0030e	48 83 c0 08	 add	 rax, 8
  00312	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1363 : 
; 1364 :     /* Recalculate absolute address if page boundary crossed */
; 1365 :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00317	48 8b 44 24 30	 mov	 rax, QWORD PTR lsea$[rsp]
  0031c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00322	48 85 c0	 test	 rax, rax
  00325	75 1d		 jne	 SHORT $LN11@z900_progr

; 1366 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00327	41 b8 04 00 00
	00		 mov	 r8d, 4
  0032d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00335	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lsea$[rsp]
  0033a	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0033f	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax
$LN11@z900_progr:

; 1367 : 
; 1368 :     /* For a call state entry only, if ASN-and-LX-reuse is installed and
; 1369 :        active, load the SASTEIN (high word of CR3) from bytes 176-179,
; 1370 :        and load the PASTEIN (high word of CR4) from bytes 180-183 */
; 1371 :     if ((lsed.uet & LSED_UET_ET) == LSED_UET_PC
; 1372 :         && ASN_AND_LX_REUSE_ENABLED(regs))

  00344	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR lsed$[rsp]
  0034c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0034f	83 f8 0d	 cmp	 eax, 13
  00352	0f 85 c0 00 00
	00		 jne	 $LN12@z900_progr
  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00371	83 e0 02	 and	 eax, 2
  00374	85 c0		 test	 eax, eax
  00376	0f 84 9c 00 00
	00		 je	 $LN12@z900_progr
  0037c	b8 08 00 00 00	 mov	 eax, 8
  00381	48 6b c0 01	 imul	 rax, rax, 1
  00385	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00394	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00399	85 c0		 test	 eax, eax
  0039b	74 7b		 je	 SHORT $LN12@z900_progr

; 1373 :     {
; 1374 :         FETCH_FW(regs->CR_H(3), regs->mainstor + abs);

  0039d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a5	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  003ac	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  003b1	48 8b c8	 mov	 rcx, rax
  003b4	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b9	8b c8		 mov	 ecx, eax
  003bb	e8 00 00 00 00	 call	 _byteswap_ulong
  003c0	b9 08 00 00 00	 mov	 ecx, 8
  003c5	48 6b c9 04	 imul	 rcx, rcx, 4
  003c9	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003d1	89 84 0a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1540], eax

; 1375 :         FETCH_FW(regs->CR_H(4), regs->mainstor + abs + 4);

  003d8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  003e7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  003ec	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  003f1	48 8b c8	 mov	 rcx, rax
  003f4	e8 00 00 00 00	 call	 fetch_fw_noswap
  003f9	8b c8		 mov	 ecx, eax
  003fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00400	b9 08 00 00 00	 mov	 ecx, 8
  00405	48 6b c9 05	 imul	 rcx, rcx, 5
  00409	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00411	89 84 0a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1540], eax
$LN12@z900_progr:

; 1376 : 
; 1377 :       #ifdef STACK_DEBUG
; 1378 :         logmsg (_("stack: SASTEIN=%2.2X%2.2X%2.2X%2.2X "
; 1379 :                 "PASTEIN=%2.2X%2.2X%2.2X%2.2X \n"
; 1380 :                 "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1381 :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 1382 :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1383 :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1384 :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1385 :                 lsea, abs);
; 1386 :       #endif /*STACK_DEBUG*/
; 1387 : 
; 1388 :     } /* end if(LSED_UET_PC && ASN_AND_LX_REUSE_ENABLED) */
; 1389 : 
; 1390 : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1391 : 
; 1392 :     /* [5.12.4.4] Pass back the absolute address of the entry
; 1393 :        descriptor of the preceding linkage stack entry.  The
; 1394 :        next entry size field of this entry will be cleared on
; 1395 :        successful completion of the PR instruction */
; 1396 :     *lsedap = ARCH_DEP(abs_stack_addr) (lsep, regs, ACCTYPE_WRITE);

  00418	41 b8 02 00 00
	00		 mov	 r8d, 2
  0041e	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00426	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lsep$[rsp]
  0042b	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00430	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR lsedap$[rsp]
  00438	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1397 : 
; 1398 :     /* [5.12.4.5] Update CR15 to point to the previous entry */
; 1399 :     regs->CR(15) = lsep & CR15_LSEA;

  0043b	48 8b 44 24 70	 mov	 rax, QWORD PTR lsep$[rsp]
  00440	48 83 e0 f8	 and	 rax, -8
  00444	b9 08 00 00 00	 mov	 ecx, 8
  00449	48 6b c9 10	 imul	 rcx, rcx, 16
  0044d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00455	48 89 84 0a 00
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1536], rax

; 1400 : 
; 1401 :     /* Load new PSW using the bytes extracted from the stack entry */
; 1402 :     /* The rc will be checked by calling routine for PIC 06        */
; 1403 :     *rc = ARCH_DEP(load_psw) (regs, newpsw);

  0045d	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR newpsw$[rsp]
  00465	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046d	e8 00 00 00 00	 call	 z900_load_psw
  00472	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR rc$[rsp]
  0047a	89 01		 mov	 DWORD PTR [rcx], eax

; 1404 : 
; 1405 :     /* Restore the PER mode bit from the current PSW */
; 1406 :     if (permode)

  0047c	83 7c 24 68 00	 cmp	 DWORD PTR permode$[rsp], 0
  00481	74 1c		 je	 SHORT $LN13@z900_progr

; 1407 :         regs->psw.sysmask |= PSW_PERMODE;

  00483	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0048f	83 c8 40	 or	 eax, 64			; 00000040H
  00492	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049a	88 41 78	 mov	 BYTE PTR [rcx+120], al
  0049d	eb 1a		 jmp	 SHORT $LN14@z900_progr
$LN13@z900_progr:

; 1408 :     else
; 1409 :         regs->psw.sysmask &= ~PSW_PERMODE;

  0049f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a7	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004ab	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  004ae	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b6	88 41 78	 mov	 BYTE PTR [rcx+120], al
$LN14@z900_progr:
$LN4@z900_progr:

; 1410 : 
; 1411 :     /* restore PER masks which could have been wiped out by load_psw */
; 1412 :     SET_IC_MASK(regs);

  004b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c1	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004c5	83 e0 02	 and	 eax, 2
  004c8	85 c0		 test	 eax, eax
  004ca	74 0a		 je	 SHORT $LN20@z900_progr
  004cc	c7 44 24 54 00
	00 00 40	 mov	 DWORD PTR tv270[rsp], 1073741824 ; 40000000H
  004d4	eb 08		 jmp	 SHORT $LN21@z900_progr
$LN20@z900_progr:
  004d6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv270[rsp], 0
$LN21@z900_progr:
  004de	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e6	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  004ea	83 e0 04	 and	 eax, 4
  004ed	85 c0		 test	 eax, eax
  004ef	74 26		 je	 SHORT $LN22@z900_progr
  004f1	b8 08 00 00 00	 mov	 eax, 8
  004f6	48 6b c0 0f	 imul	 rax, rax, 15
  004fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00502	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0050a	48 25 00 00 00
	1f		 and	 rax, 520093696		; 1f000000H
  00510	48 89 44 24 78	 mov	 QWORD PTR tv282[rsp], rax
  00515	eb 09		 jmp	 SHORT $LN23@z900_progr
$LN22@z900_progr:
  00517	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv282[rsp], 0
$LN23@z900_progr:
  00520	33 c0		 xor	 eax, eax
  00522	85 c0		 test	 eax, eax
  00524	75 4e		 jne	 SHORT $LN24@z900_progr
  00526	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00532	83 e0 40	 and	 eax, 64			; 00000040H
  00535	85 c0		 test	 eax, eax
  00537	75 3b		 jne	 SHORT $LN24@z900_progr
  00539	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00541	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00547	d1 e8		 shr	 eax, 1
  00549	83 e0 01	 and	 eax, 1
  0054c	85 c0		 test	 eax, eax
  0054e	74 1a		 je	 SHORT $LN25@z900_progr
  00550	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00558	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0055f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00563	83 e0 01	 and	 eax, 1
  00566	85 c0		 test	 eax, eax
  00568	75 0a		 jne	 SHORT $LN24@z900_progr
$LN25@z900_progr:
  0056a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv300[rsp], 0
  00572	eb 14		 jmp	 SHORT $LN26@z900_progr
$LN24@z900_progr:
  00574	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057c	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0057f	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00584	89 44 24 58	 mov	 DWORD PTR tv300[rsp], eax
$LN26@z900_progr:
  00588	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00590	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00594	83 e0 01	 and	 eax, 1
  00597	85 c0		 test	 eax, eax
  00599	74 29		 je	 SHORT $LN27@z900_progr
  0059b	b8 08 00 00 00	 mov	 eax, 8
  005a0	48 6b c0 01	 imul	 rax, rax, 1
  005a4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ac	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  005b4	48 25 f0 fe 00
	00		 and	 rax, 65264		; 0000fef0H
  005ba	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
  005c2	eb 0c		 jmp	 SHORT $LN28@z900_progr
$LN27@z900_progr:
  005c4	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv312[rsp], 0
$LN28@z900_progr:
  005d0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d8	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005dc	83 e0 02	 and	 eax, 2
  005df	85 c0		 test	 eax, eax
  005e1	74 0a		 je	 SHORT $LN29@z900_progr
  005e3	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv318[rsp], 1
  005eb	eb 08		 jmp	 SHORT $LN30@z900_progr
$LN29@z900_progr:
  005ed	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
$LN30@z900_progr:
  005f5	8b 44 24 54	 mov	 eax, DWORD PTR tv270[rsp]
  005f9	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  005fe	8b c0		 mov	 eax, eax
  00600	48 0b 44 24 78	 or	 rax, QWORD PTR tv282[rsp]
  00605	8b 4c 24 58	 mov	 ecx, DWORD PTR tv300[rsp]
  00609	48 0b c1	 or	 rax, rcx
  0060c	48 0b 84 24 80
	00 00 00	 or	 rax, QWORD PTR tv312[rsp]
  00614	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv318[rsp]
  00618	48 0b c1	 or	 rax, rcx
  0061b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00623	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00626	33 c0		 xor	 eax, eax
  00628	85 c0		 test	 eax, eax
  0062a	75 4e		 jne	 SHORT $LN31@z900_progr
  0062c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00634	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00638	83 e0 40	 and	 eax, 64			; 00000040H
  0063b	85 c0		 test	 eax, eax
  0063d	75 3b		 jne	 SHORT $LN31@z900_progr
  0063f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00647	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0064d	d1 e8		 shr	 eax, 1
  0064f	83 e0 01	 and	 eax, 1
  00652	85 c0		 test	 eax, eax
  00654	74 1a		 je	 SHORT $LN32@z900_progr
  00656	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00665	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00669	83 e0 01	 and	 eax, 1
  0066c	85 c0		 test	 eax, eax
  0066e	75 0a		 jne	 SHORT $LN31@z900_progr
$LN32@z900_progr:
  00670	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv337[rsp], 0
  00678	eb 08		 jmp	 SHORT $LN33@z900_progr
$LN31@z900_progr:
  0067a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv337[rsp], 1
$LN33@z900_progr:
  00682	8b 44 24 60	 mov	 eax, DWORD PTR tv337[rsp]
  00686	83 e0 01	 and	 eax, 1
  00689	c1 e0 02	 shl	 eax, 2
  0068c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00694	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0069a	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0069d	0b c8		 or	 ecx, eax
  0069f	89 4c 24 64	 mov	 DWORD PTR tv342[rsp], ecx
  006a3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ab	8b 4c 24 64	 mov	 ecx, DWORD PTR tv342[rsp]
  006af	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  006b5	8b 44 24 64	 mov	 eax, DWORD PTR tv342[rsp]
  006b9	c1 e8 02	 shr	 eax, 2
  006bc	83 e0 01	 and	 eax, 1
  006bf	85 c0		 test	 eax, eax
  006c1	74 7c		 je	 SHORT $LN15@z900_progr
$LN7@z900_progr:
  006c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006cb	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  006d3	74 64		 je	 SHORT $LN16@z900_progr
  006d5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006dd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e5	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006ec	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006f0	48 2b c1	 sub	 rax, rcx
  006f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fb	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00702	48 03 c8	 add	 rcx, rax
  00705	48 8b c1	 mov	 rax, rcx
  00708	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00710	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00717	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071f	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00726	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN16@z900_progr:
  00739	33 c0		 xor	 eax, eax
  0073b	85 c0		 test	 eax, eax
  0073d	75 84		 jne	 SHORT $LN7@z900_progr
$LN15@z900_progr:
  0073f	33 c0		 xor	 eax, eax
  00741	85 c0		 test	 eax, eax
  00743	0f 85 70 fd ff
	ff		 jne	 $LN4@z900_progr

; 1413 : 
; 1414 : #ifdef STACK_DEBUG
; 1415 :     LOGMSG( "stack: CR15=" F_CREG "\n", regs->CR( 15 ));
; 1416 : #endif /*STACK_DEBUG*/
; 1417 : 
; 1418 :     /* Return the entry type of the unstacked state entry */
; 1419 :     return (lsed.uet & LSED_UET_ET);

  00749	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR lsed$[rsp]
  00751	83 e0 7f	 and	 eax, 127		; 0000007fH

; 1420 : 
; 1421 : } /* end function ARCH_DEP(program_return_unstack) */

  00754	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0075c	48 33 cc	 xor	 rcx, rsp
  0075f	e8 00 00 00 00	 call	 __security_check_cookie
  00764	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0076b	c3		 ret	 0
z900_program_return_unstack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
i$ = 32
abs$ = 40
tv67 = 48
tv73 = 52
tv90 = 56
tv167 = 60
abs2$ = 64
firstbyte$ = 72
lastbyte$ = 80
gtype$ = 112
lsea$ = 120
r1$ = 128
r2$ = 136
regs$ = 144
z900_unstack_registers PROC

; 1103 : {

$LN42:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1104 : RADR    abs, abs2 = 0;                  /* Absolute address          */

  00017	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR abs2$[rsp], 0
$LN4@z900_unsta:

; 1105 : VADR    firstbyte,                      /* First byte to be fetched  */
; 1106 :         lastbyte;                       /* Last byte to be fetched   */
; 1107 : int     i;                              /* Array subscript           */
; 1108 : 
; 1109 :     UNREFERENCED(gtype);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN4@z900_unsta

; 1110 : 
; 1111 :     /* Point back to byte 0 of the state entry */
; 1112 :     lsea -= LSSE_SIZE - sizeof(LSED);

  00026	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  0002b	48 2d 20 01 00
	00		 sub	 rax, 288		; 00000120H
  00031	48 89 44 24 78	 mov	 QWORD PTR lsea$[rsp], rax

; 1113 :     LSEA_WRAP(lsea);
; 1114 : 
; 1115 :     /* Determine first and last byte to fetch from the state entry */
; 1116 :     firstbyte = lsea + ((r1 > r2) ? 0 : r1) * LSSE_REGSIZE;

  00036	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0003d	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00044	7e 0a		 jle	 SHORT $LN34@z900_unsta
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
  0004e	eb 0b		 jmp	 SHORT $LN35@z900_unsta
$LN34@z900_unsta:
  00050	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00057	89 44 24 30	 mov	 DWORD PTR tv67[rsp], eax
$LN35@z900_unsta:
  0005b	8b 44 24 30	 mov	 eax, DWORD PTR tv67[rsp]
  0005f	c1 e0 03	 shl	 eax, 3
  00062	48 98		 cdqe
  00064	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lsea$[rsp]
  00069	48 03 c8	 add	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 89 44 24 48	 mov	 QWORD PTR firstbyte$[rsp], rax

; 1117 :     lastbyte = lsea + (LSSE_SIZE - 69) + (((r1 > r2) ? 15 : r2) * 4);

  00074	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0007b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00082	7e 0a		 jle	 SHORT $LN36@z900_unsta
  00084	c7 44 24 34 0f
	00 00 00	 mov	 DWORD PTR tv73[rsp], 15
  0008c	eb 0b		 jmp	 SHORT $LN37@z900_unsta
$LN36@z900_unsta:
  0008e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00095	89 44 24 34	 mov	 DWORD PTR tv73[rsp], eax
$LN37@z900_unsta:
  00099	8b 44 24 34	 mov	 eax, DWORD PTR tv73[rsp]
  0009d	c1 e0 02	 shl	 eax, 2
  000a0	48 98		 cdqe
  000a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lsea$[rsp]
  000a7	48 8d 84 01 e3
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+227]
  000af	48 89 44 24 50	 mov	 QWORD PTR lastbyte$[rsp], rax

; 1118 : 
; 1119 :     lsea = firstbyte;

  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR firstbyte$[rsp]
  000b9	48 89 44 24 78	 mov	 QWORD PTR lsea$[rsp], rax

; 1120 : 
; 1121 :     /* Obtain absolute address of the state entry */
; 1122 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  000be	41 b8 04 00 00
	00		 mov	 r8d, 4
  000c4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000cc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lsea$[rsp]
  000d1	e8 00 00 00 00	 call	 z900_abs_stack_addr
  000d6	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1123 : 
; 1124 :     /* If the state entry crosses a page boundary, obtain the
; 1125 :        absolute address of the second page of the stack entry */
; 1126 :     if( (firstbyte & PAGEFRAME_PAGEMASK)
; 1127 :                                 != (lastbyte & PAGEFRAME_PAGEMASK))

  000db	48 8b 44 24 48	 mov	 rax, QWORD PTR firstbyte$[rsp]
  000e0	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lastbyte$[rsp]
  000eb	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  000f2	48 3b c1	 cmp	 rax, rcx
  000f5	74 26		 je	 SHORT $LN14@z900_unsta

; 1128 :         abs2 = ARCH_DEP(abs_stack_addr)

  000f7	48 8b 44 24 50	 mov	 rax, QWORD PTR lastbyte$[rsp]
  000fc	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00102	41 b8 04 00 00
	00		 mov	 r8d, 4
  00108	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00118	48 89 44 24 40	 mov	 QWORD PTR abs2$[rsp], rax
$LN14@z900_unsta:

; 1129 :                  (lastbyte & PAGEFRAME_PAGEMASK, regs, ACCTYPE_READ);
; 1130 : 
; 1131 :   #ifdef STACK_DEBUG
; 1132 :     LOGMSG( "stack: Unstacking registers %d-%d from " F_VADR "\n",
; 1133 :             r1, r2, lsea );
; 1134 :   #endif /*STACK_DEBUG*/
; 1135 : 
; 1136 :     /* Load general registers from bytes 0-63 (for ESA/390), or
; 1137 :        bytes 0-127 (for ESAME) of the state entry */
; 1138 :     for (i = ((r1 > r2) ? 0 : r1); i <= 15; i++)

  0011d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00124	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0012b	7e 0a		 jle	 SHORT $LN38@z900_unsta
  0012d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
  00135	eb 0b		 jmp	 SHORT $LN39@z900_unsta
$LN38@z900_unsta:
  00137	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0013e	89 44 24 38	 mov	 DWORD PTR tv90[rsp], eax
$LN39@z900_unsta:
  00142	8b 44 24 38	 mov	 eax, DWORD PTR tv90[rsp]
  00146	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0014a	eb 0a		 jmp	 SHORT $LN7@z900_unsta
$LN5@z900_unsta:
  0014c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_unsta:
  00156	83 7c 24 20 0f	 cmp	 DWORD PTR i$[rsp], 15
  0015b	0f 8f 11 01 00
	00		 jg	 $LN6@z900_unsta

; 1139 :     {
; 1140 :         /* Load the general register from the stack entry */
; 1141 :         if ((r1 <= r2 && i >= r1 && i <= r2)
; 1142 :             || (r1 > r2 && (i >= r1 || i <= r2)))

  00161	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00168	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0016f	7f 1a		 jg	 SHORT $LN17@z900_unsta
  00171	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00178	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0017c	7c 0d		 jl	 SHORT $LN17@z900_unsta
  0017e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00185	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00189	7e 2e		 jle	 SHORT $LN16@z900_unsta
$LN17@z900_unsta:
  0018b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00192	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00199	0f 8e 98 00 00
	00		 jle	 $LN15@z900_unsta
  0019f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  001a6	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001aa	7d 0d		 jge	 SHORT $LN18@z900_unsta
  001ac	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001b3	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001b7	7f 7e		 jg	 SHORT $LN15@z900_unsta
$LN18@z900_unsta:
$LN16@z900_unsta:

; 1143 :         {
; 1144 :     #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1145 :             if (gtype)

  001b9	83 7c 24 70 00	 cmp	 DWORD PTR gtype$[rsp], 0
  001be	74 3b		 je	 SHORT $LN19@z900_unsta

; 1146 :             {
; 1147 :                 /* For ESAME PR and EREGG instructions,
; 1148 :                    load all 64 bits of the register */
; 1149 :                 FETCH_DW(regs->GR_G(i), regs->mainstor + abs);

  001c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001cf	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  001d4	48 8b c8	 mov	 rcx, rax
  001d7	e8 00 00 00 00	 call	 fetch_dw_noswap
  001dc	48 8b c8	 mov	 rcx, rax
  001df	e8 00 00 00 00	 call	 _byteswap_uint64
  001e4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001e9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f1	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1150 :             } else {

  001f9	eb 3c		 jmp	 SHORT $LN20@z900_unsta
$LN19@z900_unsta:

; 1151 :                 /* For ESAME EREG instruction, load bits 32-63 of
; 1152 :                    the register, and leave bits 0-31 unchanged */
; 1153 :                 FETCH_FW(regs->GR_L(i), regs->mainstor + abs + 4);

  001fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0020a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abs$[rsp]
  0020f	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00214	48 8b c8	 mov	 rcx, rax
  00217	e8 00 00 00 00	 call	 fetch_fw_noswap
  0021c	8b c8		 mov	 ecx, eax
  0021e	e8 00 00 00 00	 call	 _byteswap_ulong
  00223	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00228	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00230	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN20@z900_unsta:
$LN15@z900_unsta:

; 1154 :             }
; 1155 : 
; 1156 :           #ifdef STACK_DEBUG
; 1157 :             logmsg (_("stack: GPR%d=" F_GREG " loaded from V:" F_VADR
; 1158 :                     " A:" F_RADR "\n"), i, regs->GR(i), lsea, abs);
; 1159 :           #endif /*STACK_DEBUG*/
; 1160 :     #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1161 :             /* For ESA/390, load a 32-bit general register */
; 1162 :             FETCH_FW(regs->GR_L(i), regs->mainstor + abs);
; 1163 : 
; 1164 :           #ifdef STACK_DEBUG
; 1165 :             logmsg (_("stack: GPR%d=" F_GREG " loaded from V:" F_VADR
; 1166 :                     " A:" F_RADR "\n"), i, regs->GR(i), lsea, abs);
; 1167 :           #endif /*STACK_DEBUG*/
; 1168 :     #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1169 :         }
; 1170 : 
; 1171 :         /* Update the virtual and absolute addresses */
; 1172 :         lsea += LSSE_REGSIZE;

  00237	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  0023c	48 83 c0 08	 add	 rax, 8
  00240	48 89 44 24 78	 mov	 QWORD PTR lsea$[rsp], rax

; 1173 :         LSEA_WRAP(lsea);
; 1174 :         abs += LSSE_REGSIZE;

  00245	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  0024a	48 83 c0 08	 add	 rax, 8
  0024e	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1175 : 
; 1176 :         /* Recalculate absolute address if page boundary crossed */
; 1177 :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00253	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  00258	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0025e	48 85 c0	 test	 rax, rax
  00261	75 0a		 jne	 SHORT $LN21@z900_unsta

; 1178 :             abs = abs2;

  00263	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  00268	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN21@z900_unsta:

; 1179 : 
; 1180 :     } /* end for(i) */

  0026d	e9 da fe ff ff	 jmp	 $LN5@z900_unsta
$LN6@z900_unsta:

; 1181 : 
; 1182 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1183 :     /* For ESAME, skip the next 96 bytes of the state entry */
; 1184 :     lsea += 96; abs += 96;

  00272	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  00277	48 83 c0 60	 add	 rax, 96			; 00000060H
  0027b	48 89 44 24 78	 mov	 QWORD PTR lsea$[rsp], rax
  00280	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00285	48 83 c0 60	 add	 rax, 96			; 00000060H
  00289	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1185 : 
; 1186 :     /* Recalculate absolute address if page boundary crossed */
; 1187 :     if ((lsea & PAGEFRAME_BYTEMASK) < 96)

  0028e	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  00293	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00299	48 83 f8 60	 cmp	 rax, 96			; 00000060H
  0029d	73 1b		 jae	 SHORT $LN22@z900_unsta

; 1188 :         abs = abs2 | (lsea & PAGEFRAME_BYTEMASK);

  0029f	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  002a4	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  002aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs2$[rsp]
  002af	48 0b c8	 or	 rcx, rax
  002b2	48 8b c1	 mov	 rax, rcx
  002b5	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN22@z900_unsta:

; 1189 : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1190 : 
; 1191 :     /* Load access registers from bytes 64-127 (for ESA/390), or
; 1192 :        bytes 224-280 (for ESAME) of the state entry */
; 1193 :     for (i = 0; i <= ((r1 > r2) ? 15 : r2); i++)

  002ba	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002c2	eb 0a		 jmp	 SHORT $LN10@z900_unsta
$LN8@z900_unsta:
  002c4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002c8	ff c0		 inc	 eax
  002ca	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_unsta:
  002ce	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002d5	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002dc	7e 0a		 jle	 SHORT $LN40@z900_unsta
  002de	c7 44 24 3c 0f
	00 00 00	 mov	 DWORD PTR tv167[rsp], 15
  002e6	eb 0b		 jmp	 SHORT $LN41@z900_unsta
$LN40@z900_unsta:
  002e8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002ef	89 44 24 3c	 mov	 DWORD PTR tv167[rsp], eax
$LN41@z900_unsta:
  002f3	8b 44 24 3c	 mov	 eax, DWORD PTR tv167[rsp]
  002f7	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  002fb	0f 8f 7e 01 00
	00		 jg	 $LN9@z900_unsta

; 1194 :     {
; 1195 :         /* Load the access register from the stack entry */
; 1196 :         if ((r1 <= r2 && i >= r1 && i <= r2)
; 1197 :             || (r1 > r2 && (i >= r1 || i <= r2)))

  00301	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00308	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0030f	7f 1a		 jg	 SHORT $LN25@z900_unsta
  00311	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00318	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0031c	7c 0d		 jl	 SHORT $LN25@z900_unsta
  0031e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00325	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00329	7e 32		 jle	 SHORT $LN24@z900_unsta
$LN25@z900_unsta:
  0032b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00332	39 84 24 80 00
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00339	0f 8e 05 01 00
	00		 jle	 $LN23@z900_unsta
  0033f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00346	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0034a	7d 11		 jge	 SHORT $LN26@z900_unsta
  0034c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00353	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00357	0f 8f e7 00 00
	00		 jg	 $LN23@z900_unsta
$LN26@z900_unsta:
$LN24@z900_unsta:

; 1198 :         {
; 1199 :             FETCH_FW(regs->AR(i),regs->mainstor + abs);

  0035d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00365	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0036c	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  00371	48 8b c8	 mov	 rcx, rax
  00374	e8 00 00 00 00	 call	 fetch_fw_noswap
  00379	8b c8		 mov	 ecx, eax
  0037b	e8 00 00 00 00	 call	 _byteswap_ulong
  00380	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00385	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0038d	89 84 8a 00 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+768], eax
$LN13@z900_unsta:

; 1200 :             SET_AEA_AR(regs, i);

  00394	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  003a0	83 f8 40	 cmp	 eax, 64			; 00000040H
  003a3	0f 85 91 00 00
	00		 jne	 $LN27@z900_unsta
  003a9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003ae	0f 8e 86 00 00
	00		 jle	 $LN27@z900_unsta
  003b4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003b9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  003c9	75 1e		 jne	 SHORT $LN28@z900_unsta
  003cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003cf	83 c0 05	 add	 eax, 5
  003d2	48 98		 cdqe
  003d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003dc	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  003e7	eb 51		 jmp	 SHORT $LN29@z900_unsta
$LN28@z900_unsta:
  003e9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f6	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  003fe	75 1e		 jne	 SHORT $LN30@z900_unsta
  00400	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00404	83 c0 05	 add	 eax, 5
  00407	48 98		 cdqe
  00409	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00411	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0041c	eb 1c		 jmp	 SHORT $LN31@z900_unsta
$LN30@z900_unsta:
  0041e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00422	83 c0 05	 add	 eax, 5
  00425	48 98		 cdqe
  00427	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042f	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN31@z900_unsta:
$LN29@z900_unsta:
$LN27@z900_unsta:
  0043a	33 c0		 xor	 eax, eax
  0043c	85 c0		 test	 eax, eax
  0043e	0f 85 50 ff ff
	ff		 jne	 $LN13@z900_unsta
$LN23@z900_unsta:

; 1201 : 
; 1202 :           #ifdef STACK_DEBUG
; 1203 :             logmsg (_("stack: AR%d=" F_AREG " loaded from V:" F_VADR
; 1204 :                     " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 1205 :           #endif /*STACK_DEBUG*/
; 1206 :         }
; 1207 : 
; 1208 :         /* Update the virtual and absolute addresses */
; 1209 :         lsea += 4;

  00444	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  00449	48 83 c0 04	 add	 rax, 4
  0044d	48 89 44 24 78	 mov	 QWORD PTR lsea$[rsp], rax

; 1210 :         LSEA_WRAP(lsea);
; 1211 :         abs += 4;

  00452	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00457	48 83 c0 04	 add	 rax, 4
  0045b	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1212 : 
; 1213 :         /* Recalculate absolute address if page boundary crossed */
; 1214 :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00460	48 8b 44 24 78	 mov	 rax, QWORD PTR lsea$[rsp]
  00465	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0046b	48 85 c0	 test	 rax, rax
  0046e	75 0a		 jne	 SHORT $LN32@z900_unsta

; 1215 :             abs = abs2;

  00470	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  00475	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN32@z900_unsta:

; 1216 : 
; 1217 :     } /* end for(i) */

  0047a	e9 45 fe ff ff	 jmp	 $LN8@z900_unsta
$LN9@z900_unsta:

; 1218 : 
; 1219 : } /* end function ARCH_DEP(unstack_registers) */

  0047f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00483	c3		 ret	 0
z900_unstack_registers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
abs$ = 32
psw1$1 = 40
psw2$2 = 48
lsea$ = 80
r1$ = 88
code$ = 96
regs$ = 104
z900_stack_extract PROC

; 991  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 992  : RADR    abs;                            /* Absolute address          */
; 993  : 
; 994  :     /* Point back to byte 128 of the state entry */
; 995  :     lsea -= LSSE_SIZE - sizeof(LSED);

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  0001c	48 2d 20 01 00
	00		 sub	 rax, 288		; 00000120H
  00022	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 996  :     lsea += 128;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  0002c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00032	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 997  : 
; 998  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 999  :     /* For codes 1 and 4, extract bytes 136-143 and 168-175 */
; 1000 :     if (code == 1 || code == 4)

  00037	83 7c 24 60 01	 cmp	 DWORD PTR code$[rsp], 1
  0003c	74 0b		 je	 SHORT $LN3@z900_stack
  0003e	83 7c 24 60 04	 cmp	 DWORD PTR code$[rsp], 4
  00043	0f 85 87 01 00
	00		 jne	 $LN2@z900_stack
$LN3@z900_stack:

; 1001 :     {
; 1002 :         U64 psw1, psw2;
; 1003 : 
; 1004 :         /* Point to byte 136 of the state entry */
; 1005 :         lsea += 8;

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  0004e	48 83 c0 08	 add	 rax, 8
  00052	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 1006 :         LSEA_WRAP(lsea);
; 1007 : 
; 1008 :         /* Load bits 0-63 of ESAME PSW from bytes 136-143 */
; 1009 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00057	41 b8 04 00 00
	00		 mov	 r8d, 4
  0005d	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lsea$[rsp]
  00067	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0006c	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 1010 :         FETCH_DW(psw1, regs->mainstor + abs);

  00071	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00076	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0007d	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 fetch_dw_noswap
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 _byteswap_uint64
  00092	48 89 44 24 28	 mov	 QWORD PTR psw1$1[rsp], rax

; 1011 : 
; 1012 :         /* Point to byte 168 of the state entry */
; 1013 :         lsea += 32;

  00097	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  0009c	48 83 c0 20	 add	 rax, 32			; 00000020H
  000a0	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 1014 :         abs += 32;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  000aa	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ae	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 1015 : 
; 1016 :         /* Recalculate absolute address if page boundary crossed */
; 1017 :         if ((lsea & PAGEFRAME_BYTEMASK) < 32)

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  000b8	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000be	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  000c2	73 1a		 jae	 SHORT $LN4@z900_stack

; 1018 :             abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  000c4	41 b8 04 00 00
	00		 mov	 r8d, 4
  000ca	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lsea$[rsp]
  000d4	e8 00 00 00 00	 call	 z900_abs_stack_addr
  000d9	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN4@z900_stack:

; 1019 : 
; 1020 :         /* Load bits 64-127 of ESAME PSW from bytes 168-175 */
; 1021 :         FETCH_DW(psw2, regs->mainstor + abs);

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000ea	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 fetch_dw_noswap
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 _byteswap_uint64
  000ff	48 89 44 24 30	 mov	 QWORD PTR psw2$2[rsp], rax

; 1022 : 
; 1023 :         /* For code 4, return ESAME PSW in general register pair */
; 1024 :         if (code == 4)

  00104	83 7c 24 60 04	 cmp	 DWORD PTR code$[rsp], 4
  00109	75 36		 jne	 SHORT $LN5@z900_stack

; 1025 :         {
; 1026 :             regs->GR_G(r1) = psw1;

  0010b	48 63 44 24 58	 movsxd	 rax, DWORD PTR r1$[rsp]
  00110	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	48 8b 54 24 28	 mov	 rdx, QWORD PTR psw1$1[rsp]
  0011a	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1027 :             regs->GR_G(r1+1) = psw2;

  00122	8b 44 24 58	 mov	 eax, DWORD PTR r1$[rsp]
  00126	ff c0		 inc	 eax
  00128	48 98		 cdqe
  0012a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	48 8b 54 24 30	 mov	 rdx, QWORD PTR psw2$2[rsp]
  00134	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1028 :             return;

  0013c	e9 d0 01 00 00	 jmp	 $LN1@z900_stack
$LN5@z900_stack:

; 1029 :         }
; 1030 : 
; 1031 :         /* For code 1, convert ESAME PSW to ESA/390 format */
; 1032 :         regs->GR_L(r1) = (psw1 >> 32) | 0x00080000;

  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR psw1$1[rsp]
  00146	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0014a	48 0f ba e8 13	 bts	 rax, 19
  0014f	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00154	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00159	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1033 :         regs->GR_L(r1+1) = (psw1 & 0x80000000)

  00160	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00165	48 8b 4c 24 28	 mov	 rcx, QWORD PTR psw1$1[rsp]
  0016a	48 23 c8	 and	 rcx, rax
  0016d	48 8b c1	 mov	 rax, rcx
  00170	48 8b 4c 24 30	 mov	 rcx, QWORD PTR psw2$2[rsp]
  00175	48 81 e1 ff ff
	ff 7f		 and	 rcx, 2147483647		; 7fffffffH
  0017c	48 0b c1	 or	 rax, rcx
  0017f	8b 4c 24 58	 mov	 ecx, DWORD PTR r1$[rsp]
  00183	ff c1		 inc	 ecx
  00185	48 63 c9	 movsxd	 rcx, ecx
  00188	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1034 :                             | (psw2 & 0x7FFFFFFF);
; 1035 : 
; 1036 :         /* Set low-order bit of R1+1 if IA exceeds 31-bit address */
; 1037 :         if (psw2 > 0x7FFFFFFF)

  00194	48 81 7c 24 30
	ff ff ff 7f	 cmp	 QWORD PTR psw2$2[rsp], 2147483647 ; 7fffffffH
  0019d	76 2c		 jbe	 SHORT $LN6@z900_stack

; 1038 :             regs->GR_L(r1+1) |= 0x01;

  0019f	8b 44 24 58	 mov	 eax, DWORD PTR r1$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	48 98		 cdqe
  001a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001b3	83 c8 01	 or	 eax, 1
  001b6	8b 4c 24 58	 mov	 ecx, DWORD PTR r1$[rsp]
  001ba	ff c1		 inc	 ecx
  001bc	48 63 c9	 movsxd	 rcx, ecx
  001bf	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001c4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN6@z900_stack:

; 1039 : 
; 1040 :         return;

  001cb	e9 41 01 00 00	 jmp	 $LN1@z900_stack
$LN2@z900_stack:

; 1041 : 
; 1042 :     } /* if(code==1||code==4) */
; 1043 :   #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1044 : 
; 1045 :   #if defined(FEATURE_006_ASN_LX_REUSE_FACILITY)
; 1046 :     /* For code 5, extract bytes 176-183 */
; 1047 :     if (code == 5)

  001d0	83 7c 24 60 05	 cmp	 DWORD PTR code$[rsp], 5
  001d5	0f 85 98 00 00
	00		 jne	 $LN7@z900_stack

; 1048 :     {
; 1049 :         /* Point to byte 176 of the state entry */
; 1050 :         lsea += 48;

  001db	48 8b 44 24 50	 mov	 rax, QWORD PTR lsea$[rsp]
  001e0	48 83 c0 30	 add	 rax, 48			; 00000030H
  001e4	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 1051 :         LSEA_WRAP(lsea);
; 1052 : 
; 1053 :         /* Load the SASTEIN, PASTEIN from bytes 176-179, 180-183*/
; 1054 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  001e9	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ef	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lsea$[rsp]
  001f9	e8 00 00 00 00	 call	 z900_abs_stack_addr
  001fe	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 1055 :         FETCH_FW(regs->GR_H(r1), regs->mainstor + abs);

  00203	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00208	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0020f	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  00214	48 8b c8	 mov	 rcx, rax
  00217	e8 00 00 00 00	 call	 fetch_fw_noswap
  0021c	8b c8		 mov	 ecx, eax
  0021e	e8 00 00 00 00	 call	 _byteswap_ulong
  00223	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00228	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0022d	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 1056 :         FETCH_FW(regs->GR_H(r1+1), regs->mainstor + abs + 4);

  00234	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00239	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00245	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  0024a	48 8b c8	 mov	 rcx, rax
  0024d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00252	8b c8		 mov	 ecx, eax
  00254	e8 00 00 00 00	 call	 _byteswap_ulong
  00259	8b 4c 24 58	 mov	 ecx, DWORD PTR r1$[rsp]
  0025d	ff c1		 inc	 ecx
  0025f	48 63 c9	 movsxd	 rcx, ecx
  00262	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00267	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 1057 : 
; 1058 :         return;

  0026e	e9 9e 00 00 00	 jmp	 $LN1@z900_stack
$LN7@z900_stack:

; 1059 : 
; 1060 :     } /* if(code==5) */
; 1061 :   #endif /*defined(FEATURE_006_ASN_LX_REUSE_FACILITY)*/
; 1062 : 
; 1063 :     /* For codes 0,2,3 in ESAME, and codes 0,1,2,3 in ESA/390 */
; 1064 :     /* Point to byte 128, 136, 144, or 152 depending on the code */
; 1065 :     lsea += code * 8;

  00273	8b 44 24 60	 mov	 eax, DWORD PTR code$[rsp]
  00277	c1 e0 03	 shl	 eax, 3
  0027a	48 98		 cdqe
  0027c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lsea$[rsp]
  00281	48 03 c8	 add	 rcx, rax
  00284	48 8b c1	 mov	 rax, rcx
  00287	48 89 44 24 50	 mov	 QWORD PTR lsea$[rsp], rax

; 1066 :     LSEA_WRAP(lsea);
; 1067 : 
; 1068 :     /* Load the general register pair from the state entry */
; 1069 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0028c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00292	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00297	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lsea$[rsp]
  0029c	e8 00 00 00 00	 call	 z900_abs_stack_addr
  002a1	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 1070 :     FETCH_FW(regs->GR_L(r1), regs->mainstor + abs);

  002a6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002ab	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002b2	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  002b7	48 8b c8	 mov	 rcx, rax
  002ba	e8 00 00 00 00	 call	 fetch_fw_noswap
  002bf	8b c8		 mov	 ecx, eax
  002c1	e8 00 00 00 00	 call	 _byteswap_ulong
  002c6	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002cb	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  002d0	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1071 :     FETCH_FW(regs->GR_L(r1+1), regs->mainstor + abs + 4);

  002d7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  002e8	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  002ed	48 8b c8	 mov	 rcx, rax
  002f0	e8 00 00 00 00	 call	 fetch_fw_noswap
  002f5	8b c8		 mov	 ecx, eax
  002f7	e8 00 00 00 00	 call	 _byteswap_ulong
  002fc	8b 4c 24 58	 mov	 ecx, DWORD PTR r1$[rsp]
  00300	ff c1		 inc	 ecx
  00302	48 63 c9	 movsxd	 rcx, ecx
  00305	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  0030a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN1@z900_stack:

; 1072 : 
; 1073 : } /* end function ARCH_DEP(stack_extract) */

  00311	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00315	c3		 ret	 0
z900_stack_extract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
abs$ = 32
lsea$ = 64
m1$ = 72
m2$ = 80
regs$ = 88
z900_stack_modify PROC

; 941  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 942  : RADR    abs;                            /* Absolute address          */
; 943  : 
; 944  :     /* Point back to byte 152 of the state entry */
; 945  :     lsea -= LSSE_SIZE - sizeof(LSED);

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR lsea$[rsp]
  0001c	48 2d 20 01 00
	00		 sub	 rax, 288		; 00000120H
  00022	48 89 44 24 40	 mov	 QWORD PTR lsea$[rsp], rax

; 946  :     lsea += 152;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lsea$[rsp]
  0002c	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00032	48 89 44 24 40	 mov	 QWORD PTR lsea$[rsp], rax

; 947  :     LSEA_WRAP(lsea);
; 948  : 
; 949  :     /* Store the modify values into the state entry */
; 950  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  00037	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lsea$[rsp]
  00047	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0004c	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 951  :     STORE_FW(regs->mainstor + abs, m1);

  00051	8b 4c 24 48	 mov	 ecx, DWORD PTR m1$[rsp]
  00055	e8 00 00 00 00	 call	 _byteswap_ulong
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00066	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  0006b	8b d0		 mov	 edx, eax
  0006d	e8 00 00 00 00	 call	 store_fw_noswap

; 952  :     STORE_FW(regs->mainstor + abs + 4, m2);

  00072	8b 4c 24 50	 mov	 ecx, DWORD PTR m2$[rsp]
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00087	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  0008c	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00091	8b d0		 mov	 edx, eax
  00093	e8 00 00 00 00	 call	 store_fw_noswap

; 953  : 
; 954  : } /* end function ARCH_DEP(stack_modify) */

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
z900_stack_modify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
lsea$ = 32
abs$ = 40
bsea$ = 48
prinst$ = 80
lsedptr$ = 88
regs$ = 96
z900_locate_stack_entry PROC

; 827  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 828  : VADR    lsea;                           /* Linkage stack entry addr  */
; 829  : RADR    abs;                            /* Absolute address          */
; 830  : VADR    bsea;                           /* Backward stack entry addr */
; 831  : 
; 832  :     /* [5.12.4] Special operation exception if ASF is not enabled,
; 833  :        or if DAT is off, or if in secondary-space mode */
; 834  :     if (!ASF_ENABLED(regs)
; 835  :         || REAL_MODE(&regs->psw)
; 836  :         || SECONDARY_SPACE_MODE(&regs->psw))

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 20		 jne	 SHORT $LN3@z900_locat
  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00021	83 e0 04	 and	 eax, 4
  00024	85 c0		 test	 eax, eax
  00026	74 10		 je	 SHORT $LN3@z900_locat
  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00031	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00036	75 0f		 jne	 SHORT $LN2@z900_locat
$LN3@z900_locat:

; 837  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  00038	ba 13 00 00 00	 mov	 edx, 19
  0003d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	e8 00 00 00 00	 call	 z900_program_interrupt
$LN2@z900_locat:

; 838  : 
; 839  :     /* Special operation exception if home space mode PR instruction */
; 840  :     if (prinst && HOME_SPACE_MODE(&regs->psw))

  00047	83 7c 24 50 00	 cmp	 DWORD PTR prinst$[rsp], 0
  0004c	74 1f		 je	 SHORT $LN4@z900_locat
  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00053	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00057	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0005c	75 0f		 jne	 SHORT $LN4@z900_locat

; 841  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0005e	ba 13 00 00 00	 mov	 edx, 19
  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	e8 00 00 00 00	 call	 z900_program_interrupt
$LN4@z900_locat:

; 842  : 
; 843  :     /* [5.12.4.1] Locate current entry and process header entry */
; 844  : 
; 845  :     /* Obtain the virtual address of the current entry from CR15 */
; 846  :     lsea = regs->CR(15) & CR15_LSEA;

  0006d	b8 08 00 00 00	 mov	 eax, 8
  00072	48 6b c0 10	 imul	 rax, rax, 16
  00076	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00083	48 83 e0 f8	 and	 rax, -8
  00087	48 89 44 24 20	 mov	 QWORD PTR lsea$[rsp], rax

; 847  : 
; 848  :     /* Fetch the entry descriptor of the current entry */
; 849  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0008c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00092	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lsea$[rsp]
  0009c	e8 00 00 00 00	 call	 z900_abs_stack_addr
  000a1	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 850  :     memcpy (lsedptr, regs->mainstor+abs, sizeof(LSED));

  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lsedptr$[rsp]
  000b7	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  000bc	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  000c0	48 89 01	 mov	 QWORD PTR [rcx], rax

; 851  : 
; 852  : #ifdef STACK_DEBUG
; 853  :     LOGMSG( "stack: Stack entry located at " F_VADR "\n", lsea );
; 854  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 855  :             lsedptr->uet, lsedptr->si, lsedptr->rfs[0],
; 856  :             lsedptr->rfs[1], lsedptr->nes[0], lsedptr->nes[1] );
; 857  : #endif /*STACK_DEBUG*/
; 858  : 
; 859  :     /* Check for a header entry */
; 860  :     if ((lsedptr->uet & LSED_UET_ET) == LSED_UET_HDR)

  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  000c8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000cb	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ce	83 f8 09	 cmp	 eax, 9
  000d1	0f 85 f6 00 00
	00		 jne	 $LN5@z900_locat

; 861  :     {
; 862  :         /* For PR instruction only, generate stack operation exception
; 863  :            if the unstack suppression bit in the header entry is set */
; 864  :         if (prinst && (lsedptr->uet & LSED_UET_U))

  000d7	83 7c 24 50 00	 cmp	 DWORD PTR prinst$[rsp], 0
  000dc	74 20		 je	 SHORT $LN6@z900_locat
  000de	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  000e3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000eb	85 c0		 test	 eax, eax
  000ed	74 0f		 je	 SHORT $LN6@z900_locat

; 865  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_OPERATION_EXCEPTION);

  000ef	ba 34 00 00 00	 mov	 edx, 52			; 00000034H
  000f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	e8 00 00 00 00	 call	 z900_program_interrupt
$LN6@z900_locat:

; 866  : 
; 867  :         /* Calculate the virtual address of the header entry,
; 868  :            which is 8 bytes before the entry descriptor */
; 869  :         lsea -= 8;

  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR lsea$[rsp]
  00103	48 83 e8 08	 sub	 rax, 8
  00107	48 89 44 24 20	 mov	 QWORD PTR lsea$[rsp], rax

; 870  :         LSEA_WRAP(lsea);
; 871  : 
; 872  :         /* Fetch the backward stack entry address from the header */
; 873  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0010c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00112	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lsea$[rsp]
  0011c	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00121	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 874  :         FETCH_BSEA(bsea,regs->mainstor + abs);

  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00132	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  00137	48 8b c8	 mov	 rcx, rax
  0013a	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013f	48 8b c8	 mov	 rcx, rax
  00142	e8 00 00 00 00	 call	 _byteswap_uint64
  00147	48 89 44 24 30	 mov	 QWORD PTR bsea$[rsp], rax

; 875  : 
; 876  : #ifdef STACK_DEBUG
; 877  :         LOGMSG( "stack: Stack entry located at " F_VADR "\n", bsea );
; 878  : #endif /*STACK_DEBUG*/
; 879  : 
; 880  :         /* Stack empty exception if backward address is not valid */
; 881  :         if ((bsea & LSHE_BVALID) == 0)

  0014c	48 8b 44 24 30	 mov	 rax, QWORD PTR bsea$[rsp]
  00151	48 83 e0 01	 and	 rax, 1
  00155	48 85 c0	 test	 rax, rax
  00158	75 0f		 jne	 SHORT $LN7@z900_locat

; 882  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_EMPTY_EXCEPTION);

  0015a	ba 31 00 00 00	 mov	 edx, 49			; 00000031H
  0015f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_locat:

; 883  : 
; 884  :         /* Extract the virtual address of the entry descriptor
; 885  :            of the last entry in the previous section */
; 886  :         lsea = bsea & LSHE_BSEA;

  00169	48 8b 44 24 30	 mov	 rax, QWORD PTR bsea$[rsp]
  0016e	48 83 e0 f8	 and	 rax, -8
  00172	48 89 44 24 20	 mov	 QWORD PTR lsea$[rsp], rax

; 887  : 
; 888  :         /* Fetch the entry descriptor of the designated entry */
; 889  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00177	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017d	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lsea$[rsp]
  00187	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0018c	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 890  :         memcpy (lsedptr, regs->mainstor+abs, sizeof(LSED));

  00191	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00196	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0019d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lsedptr$[rsp]
  001a2	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  001a7	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  001ab	48 89 01	 mov	 QWORD PTR [rcx], rax

; 891  : 
; 892  : #ifdef STACK_DEBUG
; 893  :         logmsg (_("stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X "
; 894  :                 "nes=%2.2X%2.2X\n"),
; 895  :                 lsedptr->uet, lsedptr->si, lsedptr->rfs[0],
; 896  :                 lsedptr->rfs[1], lsedptr->nes[0], lsedptr->nes[1]);
; 897  : #endif /*STACK_DEBUG*/
; 898  : 
; 899  :         /* Stack specification exception if this is also a header */
; 900  :         if ((lsedptr->uet & LSED_UET_ET) == LSED_UET_HDR)

  001ae	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  001b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b6	83 e0 7f	 and	 eax, 127		; 0000007fH
  001b9	83 f8 09	 cmp	 eax, 9
  001bc	75 0f		 jne	 SHORT $LN8@z900_locat

; 901  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  001be	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  001c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001c8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN8@z900_locat:
$LN5@z900_locat:

; 902  : 
; 903  :     } /* end if(LSED_UET_HDR) */
; 904  : 
; 905  :     /* [5.12.4.2] Check for a state entry */
; 906  : 
; 907  :     /* Stack type exception if this is not a state entry */
; 908  :     if ((lsedptr->uet & LSED_UET_ET) != LSED_UET_BAKR
; 909  :         && (lsedptr->uet & LSED_UET_ET) != LSED_UET_PC)

  001cd	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  001d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d5	83 e0 7f	 and	 eax, 127		; 0000007fH
  001d8	83 f8 0c	 cmp	 eax, 12
  001db	74 1f		 je	 SHORT $LN9@z900_locat
  001dd	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  001e2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e5	83 e0 7f	 and	 eax, 127		; 0000007fH
  001e8	83 f8 0d	 cmp	 eax, 13
  001eb	74 0f		 je	 SHORT $LN9@z900_locat

; 910  :         ARCH_DEP(program_interrupt) (regs, PGM_STACK_TYPE_EXCEPTION);

  001ed	ba 33 00 00 00	 mov	 edx, 51			; 00000033H
  001f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001f7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN9@z900_locat:

; 911  : 
; 912  :     /* [5.12.4.3] For PR instruction only, stack operation exception
; 913  :        if the unstack suppression bit in the state entry is set */
; 914  :     if (prinst && (lsedptr->uet & LSED_UET_U))

  001fc	83 7c 24 50 00	 cmp	 DWORD PTR prinst$[rsp], 0
  00201	74 20		 je	 SHORT $LN10@z900_locat
  00203	48 8b 44 24 58	 mov	 rax, QWORD PTR lsedptr$[rsp]
  00208	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00210	85 c0		 test	 eax, eax
  00212	74 0f		 je	 SHORT $LN10@z900_locat

; 915  :         ARCH_DEP(program_interrupt) (regs, PGM_STACK_OPERATION_EXCEPTION);

  00214	ba 34 00 00 00	 mov	 edx, 52			; 00000034H
  00219	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_locat:

; 916  : 
; 917  :     /* Return the virtual address of the entry descriptor */
; 918  :     return lsea;

  00223	48 8b 44 24 20	 mov	 rax, QWORD PTR lsea$[rsp]

; 919  : 
; 920  : } /* end function ARCH_DEP(locate_stack_entry) */

  00228	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0022c	c3		 ret	 0
z900_locate_stack_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
abs$ = 32
lsea$ = 40
rfs$ = 48
i$ = 52
abs2$ = 56
fsha$ = 64
absold$ = 72
bsea$ = 80
absea$ = 88
lseaold$ = 96
lsed$ = 104
lsed2$ = 112
currpsw$ = 120
__$ArrayPad$ = 136
etype$ = 160
retna$ = 168
calla$ = 176
csi$ = 184
pcnum$ = 192
regs$ = 200
z900_form_stack_entry PROC

; 379  : {

$LN31:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	57		 push	 rdi
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 380  : QWORD   currpsw;                        /* Current PSW               */
; 381  : VADR    lsea;                           /* Linkage stack entry addr  */
; 382  : VADR    lseaold;                        /* Linkage stack old addr    */
; 383  : RADR    abs, abs2 = 0;                  /* Absolute addr new entry   */

  0002d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR abs2$[rsp], 0

; 384  : RADR    absold;                         /* Absolute addr old entry   */
; 385  : LSED    lsed;                           /* Linkage stack entry desc. */
; 386  : LSED    lsed2;                          /* New entry descriptor      */
; 387  : U16     rfs;                            /* Remaining free space      */
; 388  : VADR    fsha;                           /* Forward section hdr addr  */
; 389  : VADR    bsea = 0;                       /* Backward stack entry addr */

  00036	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR bsea$[rsp], 0

; 390  : RADR    absea = 0;                      /* Absolute address of bsea  */

  0003f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR absea$[rsp], 0

; 391  : int     i;                              /* Array subscript           */
; 392  : 
; 393  :     /* [5.12.3.1] Locate space for a new linkage stack entry */
; 394  : 
; 395  :     /* Obtain the virtual address of the current entry from CR15 */
; 396  :     lsea = regs->CR(15) & CR15_LSEA;

  00048	b8 08 00 00 00	 mov	 eax, 8
  0004d	48 6b c0 10	 imul	 rax, rax, 16
  00051	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00061	48 83 e0 f8	 and	 rax, -8
  00065	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 397  : 
; 398  :     /* Fetch the entry descriptor of the current entry */
; 399  :     absold = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0006a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00070	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  0007d	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00082	48 89 44 24 48	 mov	 QWORD PTR absold$[rsp], rax

; 400  :     memcpy (&lsed, regs->mainstor+absold, sizeof(LSED));

  00087	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00096	48 8b 4c 24 48	 mov	 rcx, QWORD PTR absold$[rsp]
  0009b	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0009f	48 89 44 24 68	 mov	 QWORD PTR lsed$[rsp], rax

; 401  :     lseaold = lsea;

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  000a9	48 89 44 24 60	 mov	 QWORD PTR lseaold$[rsp], rax

; 402  : 
; 403  : #ifdef STACK_DEBUG
; 404  :     LOGMSG( "stack: Current stack entry at " F_VADR "\n", lsea );
; 405  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 406  :             lsed.uet, lsed.si, lsed.rfs[0],
; 407  :             lsed.rfs[1], lsed.nes[0], lsed.nes[1] );
; 408  : #endif /*STACK_DEBUG*/
; 409  : 
; 410  :     /* Check whether the current linkage stack section has enough
; 411  :        remaining free space to contain the new stack entry */
; 412  :     FETCH_HW(rfs,lsed.rfs);

  000ae	48 8d 4c 24 6a	 lea	 rcx, QWORD PTR lsed$[rsp+2]
  000b3	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b8	0f b7 c8	 movzx	 ecx, ax
  000bb	e8 00 00 00 00	 call	 _byteswap_ushort
  000c0	66 89 44 24 30	 mov	 WORD PTR rfs$[rsp], ax

; 413  :     if (rfs < LSSE_SIZE)

  000c5	0f b7 44 24 30	 movzx	 eax, WORD PTR rfs$[rsp]
  000ca	3d 28 01 00 00	 cmp	 eax, 296		; 00000128H
  000cf	0f 8d 7a 01 00
	00		 jge	 $LN8@z900_form_

; 414  :     {
; 415  :         /* Program check if remaining free space not a multiple of 8 */
; 416  :         if ((rfs & 0x07) != 0)

  000d5	0f b7 44 24 30	 movzx	 eax, WORD PTR rfs$[rsp]
  000da	83 e0 07	 and	 eax, 7
  000dd	85 c0		 test	 eax, eax
  000df	74 12		 je	 SHORT $LN9@z900_form_

; 417  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  000e1	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  000e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	e8 00 00 00 00	 call	 z900_program_interrupt
$LN9@z900_form_:

; 418  : 
; 419  :         /* Not enough space, so fetch the forward section header addr
; 420  :            from the trailer entry of current linkage stack section */
; 421  :         lsea += sizeof(LSED) + rfs;

  000f3	0f b7 44 24 30	 movzx	 eax, WORD PTR rfs$[rsp]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  000fd	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00102	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 422  :         LSEA_WRAP(lsea);
; 423  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00107	41 b8 04 00 00
	00		 mov	 r8d, 4
  0010d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00115	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_abs_stack_addr
  0011f	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 424  :         FETCH_FSHA(fsha, regs->mainstor + abs);

  00124	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00133	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  00138	48 8b c8	 mov	 rcx, rax
  0013b	e8 00 00 00 00	 call	 fetch_dw_noswap
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 _byteswap_uint64
  00148	48 89 44 24 40	 mov	 QWORD PTR fsha$[rsp], rax

; 425  : 
; 426  : #ifdef STACK_DEBUG
; 427  :         LOGMSG( "stack: Forward section header addr " F_VADR "\n", fsha );
; 428  : #endif /*STACK_DEBUG*/
; 429  : 
; 430  :         /* Stack full exception if forward address is not valid */
; 431  :         if ((fsha & LSTE_FVALID) == 0)

  0014d	48 8b 44 24 40	 mov	 rax, QWORD PTR fsha$[rsp]
  00152	48 83 e0 01	 and	 rax, 1
  00156	48 85 c0	 test	 rax, rax
  00159	75 12		 jne	 SHORT $LN10@z900_form_

; 432  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_FULL_EXCEPTION);

  0015b	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00160	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_form_:

; 433  : 
; 434  :         /* Extract the forward section header address, which points to
; 435  :            the entry descriptor (words 2-3) of next section's header */
; 436  :         fsha &= LSTE_FSHA;

  0016d	48 8b 44 24 40	 mov	 rax, QWORD PTR fsha$[rsp]
  00172	48 83 e0 f8	 and	 rax, -8
  00176	48 89 44 24 40	 mov	 QWORD PTR fsha$[rsp], rax

; 437  : 
; 438  :         /* Fetch the entry descriptor of the next section's header */
; 439  :         absold = ARCH_DEP(abs_stack_addr) (fsha, regs, ACCTYPE_READ);

  0017b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00181	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00189	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fsha$[rsp]
  0018e	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00193	48 89 44 24 48	 mov	 QWORD PTR absold$[rsp], rax

; 440  :         memcpy (&lsed, regs->mainstor+absold, sizeof(LSED));

  00198	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR absold$[rsp]
  001ac	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  001b0	48 89 44 24 68	 mov	 QWORD PTR lsed$[rsp], rax

; 441  :         lseaold = fsha;

  001b5	48 8b 44 24 40	 mov	 rax, QWORD PTR fsha$[rsp]
  001ba	48 89 44 24 60	 mov	 QWORD PTR lseaold$[rsp], rax

; 442  : 
; 443  : #ifdef STACK_DEBUG
; 444  :         logmsg (_("stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X "
; 445  :                 "nes=%2.2X%2.2X\n"),
; 446  :                 lsed.uet, lsed.si, lsed.rfs[0],
; 447  :                 lsed.rfs[1], lsed.nes[0], lsed.nes[1]);
; 448  : #endif /*STACK_DEBUG*/
; 449  : 
; 450  :         /* Program check if the next linkage stack section does not
; 451  :            have enough free space to contain the new stack entry */
; 452  :         FETCH_HW(rfs,lsed.rfs);

  001bf	48 8d 4c 24 6a	 lea	 rcx, QWORD PTR lsed$[rsp+2]
  001c4	e8 00 00 00 00	 call	 fetch_hw_noswap
  001c9	0f b7 c8	 movzx	 ecx, ax
  001cc	e8 00 00 00 00	 call	 _byteswap_ushort
  001d1	66 89 44 24 30	 mov	 WORD PTR rfs$[rsp], ax

; 453  :         if (rfs < LSSE_SIZE)

  001d6	0f b7 44 24 30	 movzx	 eax, WORD PTR rfs$[rsp]
  001db	3d 28 01 00 00	 cmp	 eax, 296		; 00000128H
  001e0	7d 12		 jge	 SHORT $LN11@z900_form_

; 454  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  001e2	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  001e7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_form_:

; 455  : 
; 456  :         /* Calculate the virtual address of the new section's header
; 457  :            entry, which is 8 bytes before the entry descriptor */
; 458  :         lsea = fsha - 8;

  001f4	48 8b 44 24 40	 mov	 rax, QWORD PTR fsha$[rsp]
  001f9	48 83 e8 08	 sub	 rax, 8
  001fd	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 459  :         LSEA_WRAP(lsea);
; 460  : 
; 461  :         /* Form the backward stack entry address */
; 462  :         bsea = LSHE_BVALID | (regs->CR(15) & CR15_LSEA);

  00202	b8 08 00 00 00	 mov	 eax, 8
  00207	48 6b c0 10	 imul	 rax, rax, 16
  0020b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0021b	48 83 e0 f8	 and	 rax, -8
  0021f	48 83 c8 01	 or	 rax, 1
  00223	48 89 44 24 50	 mov	 QWORD PTR bsea$[rsp], rax

; 463  :         absea = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  00228	41 b8 02 00 00
	00		 mov	 r8d, 2
  0022e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00236	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  0023b	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00240	48 89 44 24 58	 mov	 QWORD PTR absea$[rsp], rax

; 464  : 
; 465  :         /* Use the virtual address of the entry descriptor of the
; 466  :            new section's header entry as the current entry address */
; 467  :         lsea = fsha;

  00245	48 8b 44 24 40	 mov	 rax, QWORD PTR fsha$[rsp]
  0024a	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax
$LN8@z900_form_:

; 468  : 
; 469  :     } /* end if(rfs<LSSE_SIZE) */
; 470  : 
; 471  :     /* [5.12.3.2] Form the new stack entry */
; 472  : 
; 473  :     /* Calculate the virtual address of the new stack entry */
; 474  :     lsea += sizeof(LSED);

  0024f	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00254	48 83 c0 08	 add	 rax, 8
  00258	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 475  :     LSEA_WRAP(lsea);
; 476  : 
; 477  :     /* Obtain absolute address of the new stack entry */
; 478  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  0025d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00263	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  00270	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00275	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 479  : 
; 480  :     /* If new stack entry will cross a page boundary, obtain the
; 481  :        absolute address of the second page of the stack entry */
; 482  :     if(((lsea + (LSSE_SIZE - 1)) & PAGEFRAME_PAGEMASK)
; 483  :                                 != (lsea & PAGEFRAME_PAGEMASK))

  0027a	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  0027f	48 05 27 01 00
	00		 add	 rax, 295		; 00000127H
  00285	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0028b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lsea$[rsp]
  00290	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00297	48 3b c1	 cmp	 rax, rcx
  0029a	74 2c		 je	 SHORT $LN12@z900_form_

; 484  :         abs2 = ARCH_DEP(abs_stack_addr)

  0029c	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  002a1	48 05 27 01 00
	00		 add	 rax, 295		; 00000127H
  002a7	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002ad	41 b8 02 00 00
	00		 mov	 r8d, 2
  002b3	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002bb	48 8b c8	 mov	 rcx, rax
  002be	e8 00 00 00 00	 call	 z900_abs_stack_addr
  002c3	48 89 44 24 38	 mov	 QWORD PTR abs2$[rsp], rax
$LN12@z900_form_:

; 485  :                         ((lsea + (LSSE_SIZE - 1)) & PAGEFRAME_PAGEMASK,
; 486  :                         regs, ACCTYPE_WRITE);
; 487  : 
; 488  : #ifdef STACK_DEBUG
; 489  :     LOGMSG( "stack: New stack entry at " F_VADR "\n", lsea );
; 490  : #endif /*STACK_DEBUG*/
; 491  : 
; 492  :     /* If a new section then place updated backward stack
; 493  :        entry address in the new section's header entry */
; 494  :     if(bsea)

  002c8	48 83 7c 24 50
	00		 cmp	 QWORD PTR bsea$[rsp], 0
  002ce	74 26		 je	 SHORT $LN13@z900_form_

; 495  :         STORE_BSEA(regs->mainstor + absea, bsea);

  002d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bsea$[rsp]
  002d5	e8 00 00 00 00	 call	 _byteswap_uint64
  002da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  002e9	48 03 4c 24 58	 add	 rcx, QWORD PTR absea$[rsp]
  002ee	48 8b d0	 mov	 rdx, rax
  002f1	e8 00 00 00 00	 call	 store_dw_noswap
$LN13@z900_form_:

; 496  : 
; 497  :     /* Store general registers 0-15 in bytes 0-63 (ESA/390)
; 498  :        or bytes 0-127 (ESAME) of the new state entry */
; 499  :     for (i = 0; i < 16; i++)

  002f6	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002fe	eb 0a		 jmp	 SHORT $LN4@z900_form_
$LN2@z900_form_:
  00300	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00304	ff c0		 inc	 eax
  00306	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_form_:
  0030a	83 7c 24 34 10	 cmp	 DWORD PTR i$[rsp], 16
  0030f	7d 6e		 jge	 SHORT $LN3@z900_form_

; 500  :     {
; 501  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 502  :         /* Store the 64-bit general register in the stack entry */
; 503  :         STORE_DW(regs->mainstor + abs, regs->GR_G(i));

  00311	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  00316	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00326	e8 00 00 00 00	 call	 _byteswap_uint64
  0032b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00333	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0033a	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  0033f	48 8b d0	 mov	 rdx, rax
  00342	e8 00 00 00 00	 call	 store_dw_noswap

; 504  : 
; 505  :       #ifdef STACK_DEBUG
; 506  :         logmsg (_("stack: GPR%d=" F_GREG " stored at V:" F_VADR
; 507  :                 " A:" F_RADR "\n"), i, regs->GR_G(i), lsea, abs);
; 508  :       #endif /*STACK_DEBUG*/
; 509  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 510  :         /* Store the 32-bit general register in the stack entry */
; 511  :         STORE_FW(regs->mainstor + abs, regs->GR_L(i));
; 512  : 
; 513  :       #ifdef STACK_DEBUG
; 514  :         logmsg (_("stack: GPR%d=" F_GREG " stored at V:" F_VADR
; 515  :                 " A:" F_RADR "\n"), i, regs->GR_L(i), lsea, abs);
; 516  :       #endif /*STACK_DEBUG*/
; 517  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 518  : 
; 519  :         /* Update the virtual and absolute addresses */
; 520  :         lsea += LSSE_REGSIZE;

  00347	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  0034c	48 83 c0 08	 add	 rax, 8
  00350	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 521  :         LSEA_WRAP(lsea);
; 522  :         abs += LSSE_REGSIZE;

  00355	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0035a	48 83 c0 08	 add	 rax, 8
  0035e	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 523  : 
; 524  :         /* Recalculate absolute address if page boundary crossed */
; 525  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00363	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00368	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0036e	48 85 c0	 test	 rax, rax
  00371	75 0a		 jne	 SHORT $LN14@z900_form_

; 526  :             abs = abs2;

  00373	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  00378	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN14@z900_form_:

; 527  : 
; 528  :     } /* end for(i) */

  0037d	eb 81		 jmp	 SHORT $LN2@z900_form_
$LN3@z900_form_:

; 529  : 
; 530  : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 531  :     /* For ESA/390, store access registers 0-15 in bytes 64-127 */
; 532  :     for (i = 0; i < 16; i++)
; 533  :     {
; 534  :         /* Store the access register in the stack entry */
; 535  :         STORE_FW(regs->mainstor + abs, regs->AR(i));
; 536  : 
; 537  :       #ifdef STACK_DEBUG
; 538  :         logmsg (_("stack: AR%d=" F_AREG " stored at V:" F_VADR
; 539  :                 " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 540  :       #endif /*STACK_DEBUG*/
; 541  : 
; 542  :         /* Update the virtual and absolute addresses */
; 543  :         lsea += 4;
; 544  :         LSEA_WRAP(lsea);
; 545  :         abs += 4;
; 546  : 
; 547  :         /* Recalculate absolute address if page boundary crossed */
; 548  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)
; 549  :             abs = abs2;
; 550  : 
; 551  :     } /* end for(i) */
; 552  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 553  : 
; 554  :     /* Store the PKM, SASN, EAX, and PASN in bytes 128-135 */
; 555  :     STORE_FW(regs->mainstor + abs, regs->CR_L(3));

  0037f	b8 08 00 00 00	 mov	 eax, 8
  00384	48 6b c0 04	 imul	 rax, rax, 4
  00388	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	8b 8c 01 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1536]
  00397	e8 00 00 00 00	 call	 _byteswap_ulong
  0039c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a4	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  003ab	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  003b0	8b d0		 mov	 edx, eax
  003b2	e8 00 00 00 00	 call	 store_fw_noswap

; 556  :     STORE_HW(regs->mainstor + abs + 4, regs->CR_LHH(8));

  003b7	b8 08 00 00 00	 mov	 eax, 8
  003bc	48 6b c0 09	 imul	 rax, rax, 9
  003c0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c8	0f b7 8c 01 02
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1538]
  003d0	e8 00 00 00 00	 call	 _byteswap_ushort
  003d5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003dd	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  003e4	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  003e9	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  003ee	0f b7 d0	 movzx	 edx, ax
  003f1	e8 00 00 00 00	 call	 store_hw_noswap

; 557  :     STORE_HW(regs->mainstor + abs + 6, regs->CR_LHL(4));

  003f6	b8 08 00 00 00	 mov	 eax, 8
  003fb	48 6b c0 05	 imul	 rax, rax, 5
  003ff	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00407	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  0040f	e8 00 00 00 00	 call	 _byteswap_ushort
  00414	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00423	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00428	48 8d 4c 11 06	 lea	 rcx, QWORD PTR [rcx+rdx+6]
  0042d	0f b7 d0	 movzx	 edx, ax
  00430	e8 00 00 00 00	 call	 store_hw_noswap

; 558  : 
; 559  :   #ifdef STACK_DEBUG
; 560  :     logmsg (_("stack: PKM=%2.2X%2.2X SASN=%2.2X%2.2X "
; 561  :             "EAX=%2.2X%2.2X PASN=%2.2X%2.2X \n"
; 562  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 563  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 564  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 565  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 566  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 567  :             lsea, abs);
; 568  :   #endif /*STACK_DEBUG*/
; 569  : 
; 570  :     /* Update virtual and absolute addresses to point to byte 136 */
; 571  :     lsea += 8;

  00435	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  0043a	48 83 c0 08	 add	 rax, 8
  0043e	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 572  :     LSEA_WRAP(lsea);
; 573  :     abs += 8;

  00443	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00448	48 83 c0 08	 add	 rax, 8
  0044c	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 574  : 
; 575  :     /* Recalculate absolute address if page boundary crossed */
; 576  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00451	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00456	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0045c	48 85 c0	 test	 rax, rax
  0045f	75 0a		 jne	 SHORT $LN15@z900_form_

; 577  :         abs = abs2;

  00461	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  00466	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN15@z900_form_:

; 578  : 
; 579  :     /* Store bits 0-63 of the current PSW in bytes 136-143 */
; 580  :     ARCH_DEP(store_psw) (regs, currpsw);

  0046b	48 8d 54 24 78	 lea	 rdx, QWORD PTR currpsw$[rsp]
  00470	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00478	e8 00 00 00 00	 call	 z900_store_psw

; 581  :     memcpy (regs->mainstor + abs, currpsw, 8);

  0047d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00485	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0048c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00491	48 8b 54 24 78	 mov	 rdx, QWORD PTR currpsw$[rsp]
  00496	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 582  : 
; 583  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 584  :     /* For ESAME, use the addressing mode bits from the return
; 585  :        address to set bits 31 and 32 of bytes 136-143 */
; 586  :     if (retna & 0x01)

  0049a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR retna$[rsp]
  004a2	48 83 e0 01	 and	 rax, 1
  004a6	48 85 c0	 test	 rax, rax
  004a9	0f 84 82 00 00
	00		 je	 $LN16@z900_form_

; 587  :     {
; 588  :         /* For a 64-bit return address, set bits 31 and 32 */
; 589  :         regs->mainstor[abs+3] |= 0x01;

  004af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  004be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  004c3	0f b6 44 08 03	 movzx	 eax, BYTE PTR [rax+rcx+3]
  004c8	83 c8 01	 or	 eax, 1
  004cb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d3	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  004da	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  004df	88 44 11 03	 mov	 BYTE PTR [rcx+rdx+3], al

; 590  :         regs->mainstor[abs+4] |= 0x80;

  004e3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004eb	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  004f2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  004f7	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  004fc	0f ba e8 07	 bts	 eax, 7
  00500	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00508	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0050f	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00514	88 44 11 04	 mov	 BYTE PTR [rcx+rdx+4], al

; 591  :         retna &= 0xFFFFFFFFFFFFFFFEULL;

  00518	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR retna$[rsp]
  00520	48 83 e0 fe	 and	 rax, -2
  00524	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR retna$[rsp], rax

; 592  :     }

  0052c	e9 22 01 00 00	 jmp	 $LN17@z900_form_
$LN16@z900_form_:

; 593  :     else if (retna & 0x80000000)

  00531	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00536	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR retna$[rsp]
  0053e	48 23 c8	 and	 rcx, rax
  00541	48 8b c1	 mov	 rax, rcx
  00544	48 85 c0	 test	 rax, rax
  00547	0f 84 86 00 00
	00		 je	 $LN18@z900_form_

; 594  :     {
; 595  :         /* For a 31-bit return address, clear bit 31 and set bit 32 */
; 596  :         regs->mainstor[abs+3] &= 0xFE;

  0054d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00555	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0055c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00561	0f b6 44 08 03	 movzx	 eax, BYTE PTR [rax+rcx+3]
  00566	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0056b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00573	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0057a	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  0057f	88 44 11 03	 mov	 BYTE PTR [rcx+rdx+3], al

; 597  :         regs->mainstor[abs+4] |= 0x80;

  00583	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00592	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00597	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  0059c	0f ba e8 07	 bts	 eax, 7
  005a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a8	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  005af	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  005b4	88 44 11 04	 mov	 BYTE PTR [rcx+rdx+4], al

; 598  :         retna &= 0x7FFFFFFF;

  005b8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR retna$[rsp]
  005c0	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  005c6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR retna$[rsp], rax

; 599  :     }

  005ce	e9 80 00 00 00	 jmp	 $LN19@z900_form_
$LN18@z900_form_:

; 600  :     else
; 601  :     {
; 602  :         /* For a 24-bit return address, clear bits 31 and 32 */
; 603  :         regs->mainstor[abs+3] &= 0xFE;

  005d3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005db	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  005e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  005e7	0f b6 44 08 03	 movzx	 eax, BYTE PTR [rax+rcx+3]
  005ec	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  005f1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f9	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00600	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00605	88 44 11 03	 mov	 BYTE PTR [rcx+rdx+3], al

; 604  :         regs->mainstor[abs+4] &= 0x7F;

  00609	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00611	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00618	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  0061d	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  00622	83 e0 7f	 and	 eax, 127		; 0000007fH
  00625	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062d	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00634	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00639	88 44 11 04	 mov	 BYTE PTR [rcx+rdx+4], al

; 605  :         retna &= 0x00FFFFFF;

  0063d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR retna$[rsp]
  00645	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0064b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR retna$[rsp], rax
$LN19@z900_form_:
$LN17@z900_form_:

; 606  :     }
; 607  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 608  :     /* For ESA/390, replace bytes 140-143 by the return address,
; 609  :        with the high-order bit indicating the addressing mode */
; 610  :     STORE_FW(regs->mainstor + abs + 4, retna);
; 611  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 612  : 
; 613  :   #ifdef STACK_DEBUG
; 614  :     logmsg (_("stack: PSW=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 615  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 616  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 617  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 618  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 619  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 620  :             lsea, abs);
; 621  :   #endif /*STACK_DEBUG*/
; 622  : 
; 623  :     /* Update virtual and absolute addresses to point to byte 144 */
; 624  :     lsea += 8;

  00653	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00658	48 83 c0 08	 add	 rax, 8
  0065c	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 625  :     LSEA_WRAP(lsea);
; 626  :     abs += 8;

  00661	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00666	48 83 c0 08	 add	 rax, 8
  0066a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 627  : 
; 628  :     /* Recalculate absolute address if page boundary crossed */
; 629  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  0066f	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00674	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0067a	48 85 c0	 test	 rax, rax
  0067d	75 0a		 jne	 SHORT $LN20@z900_form_

; 630  :         abs = abs2;

  0067f	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  00684	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN20@z900_form_:

; 631  : 
; 632  :     /* Store bytes 144-151 according to PC or BAKR */
; 633  :     if (etype == LSED_UET_PC)

  00689	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR etype$[rsp]
  00691	83 f8 0d	 cmp	 eax, 13
  00694	75 55		 jne	 SHORT $LN21@z900_form_

; 634  :     {
; 635  :       #if defined(FEATURE_CALLED_SPACE_IDENTIFICATION)
; 636  :         /* Store the called-space identification in bytes 144-147 */
; 637  :         STORE_FW(regs->mainstor + abs, csi);

  00696	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR csi$[rsp]
  0069d	e8 00 00 00 00	 call	 _byteswap_ulong
  006a2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006aa	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  006b1	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  006b6	8b d0		 mov	 edx, eax
  006b8	e8 00 00 00 00	 call	 store_fw_noswap

; 638  :       #endif /*defined(FEATURE_CALLED_SPACE_IDENTIFICATION)*/
; 639  : 
; 640  :         /* Store the PC number in bytes 148-151 */
; 641  :         STORE_FW(regs->mainstor + abs + 4, pcnum);

  006bd	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR pcnum$[rsp]
  006c4	e8 00 00 00 00	 call	 _byteswap_ulong
  006c9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d1	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  006d8	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  006dd	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  006e2	8b d0		 mov	 edx, eax
  006e4	e8 00 00 00 00	 call	 store_fw_noswap

; 642  :     }

  006e9	eb 29		 jmp	 SHORT $LN22@z900_form_
$LN21@z900_form_:

; 643  :     else
; 644  :     {
; 645  :       #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 646  :         /* Store the called address and amode in bytes 144-151 */
; 647  :         STORE_DW(regs->mainstor + abs, calla);

  006eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR calla$[rsp]
  006f3	e8 00 00 00 00	 call	 _byteswap_uint64
  006f8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00700	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00707	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  0070c	48 8b d0	 mov	 rdx, rax
  0070f	e8 00 00 00 00	 call	 store_dw_noswap
$LN22@z900_form_:

; 648  :       #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 649  :         /* Store the called address and amode in bytes 148-151 */
; 650  :         STORE_FW(regs->mainstor + abs + 4, calla);
; 651  :       #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 652  :     }
; 653  : 
; 654  :     /* Update virtual and absolute addresses to point to byte 152 */
; 655  :     lsea += 8;

  00714	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00719	48 83 c0 08	 add	 rax, 8
  0071d	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 656  :     LSEA_WRAP(lsea);
; 657  :     abs += 8;

  00722	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00727	48 83 c0 08	 add	 rax, 8
  0072b	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 658  : 
; 659  :     /* Recalculate absolute address if page boundary crossed */
; 660  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00730	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00735	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0073b	48 85 c0	 test	 rax, rax
  0073e	75 0a		 jne	 SHORT $LN23@z900_form_

; 661  :         abs = abs2;

  00740	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  00745	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN23@z900_form_:

; 662  : 
; 663  :     /* Store zeroes in bytes 152-159 */
; 664  :     memset (regs->mainstor+abs, 0, 8);

  0074a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00752	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00759	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  0075e	48 8b f8	 mov	 rdi, rax
  00761	33 c0		 xor	 eax, eax
  00763	b9 08 00 00 00	 mov	 ecx, 8
  00768	f3 aa		 rep stosb

; 665  : 
; 666  :     /* Update virtual and absolute addresses to point to byte 160 */
; 667  :     lsea += 8;

  0076a	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  0076f	48 83 c0 08	 add	 rax, 8
  00773	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 668  :     LSEA_WRAP(lsea);
; 669  :     abs += 8;

  00778	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0077d	48 83 c0 08	 add	 rax, 8
  00781	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 670  : 
; 671  :     /* Recalculate absolute address if page boundary crossed */
; 672  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00786	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  0078b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00791	48 85 c0	 test	 rax, rax
  00794	75 0a		 jne	 SHORT $LN24@z900_form_

; 673  :         abs = abs2;

  00796	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  0079b	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN24@z900_form_:

; 674  : 
; 675  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 676  :     /* For ESAME, store zeroes in bytes 160-167 */
; 677  :     memset (regs->mainstor+abs, 0, 8);

  007a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  007af	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  007b4	48 8b f8	 mov	 rdi, rax
  007b7	33 c0		 xor	 eax, eax
  007b9	b9 08 00 00 00	 mov	 ecx, 8
  007be	f3 aa		 rep stosb

; 678  : 
; 679  :     /* Update virtual and absolute addresses to point to byte 168 */
; 680  :     lsea += 8;

  007c0	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  007c5	48 83 c0 08	 add	 rax, 8
  007c9	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 681  :     LSEA_WRAP(lsea);
; 682  :     abs += 8;

  007ce	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  007d3	48 83 c0 08	 add	 rax, 8
  007d7	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 683  : 
; 684  :     /* Recalculate absolute address if page boundary crossed */
; 685  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  007dc	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  007e1	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  007e7	48 85 c0	 test	 rax, rax
  007ea	75 0a		 jne	 SHORT $LN25@z900_form_

; 686  :         abs = abs2;

  007ec	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  007f1	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN25@z900_form_:

; 687  : 
; 688  :     /* For ESAME, store the return address in bytes 168-175 */
; 689  :     STORE_DW (regs->mainstor + abs, retna);

  007f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR retna$[rsp]
  007fe	e8 00 00 00 00	 call	 _byteswap_uint64
  00803	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080b	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00812	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  00817	48 8b d0	 mov	 rdx, rax
  0081a	e8 00 00 00 00	 call	 store_dw_noswap

; 690  : 
; 691  :   #ifdef STACK_DEBUG
; 692  :     logmsg (_("stack: PSW2=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 693  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 694  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 695  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 696  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 697  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 698  :             lsea, abs);
; 699  :   #endif /*STACK_DEBUG*/
; 700  : 
; 701  :     /* Update virtual and absolute addresses to point to byte 176 */
; 702  :     lsea += 8;

  0081f	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00824	48 83 c0 08	 add	 rax, 8
  00828	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 703  :     LSEA_WRAP(lsea);
; 704  :     abs += 8;

  0082d	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00832	48 83 c0 08	 add	 rax, 8
  00836	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 705  : 
; 706  :     /* Recalculate absolute address if page boundary crossed */
; 707  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  0083b	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00840	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00846	48 85 c0	 test	 rax, rax
  00849	75 0a		 jne	 SHORT $LN26@z900_form_

; 708  :         abs = abs2;

  0084b	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  00850	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN26@z900_form_:

; 709  : 
; 710  :     /* If ASN-and-LX-reuse is installed and active, store
; 711  :        the SASTEIN (CR3 bits 0-31) in bytes 176-179, and
; 712  :        store the PASTEIN (CR4 bits 0-31) in bytes 180-183 */
; 713  :     if (ASN_AND_LX_REUSE_ENABLED(regs))

  00855	b8 01 00 00 00	 mov	 eax, 1
  0085a	48 6b c0 00	 imul	 rax, rax, 0
  0085e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00866	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0086e	83 e0 02	 and	 eax, 2
  00871	85 c0		 test	 eax, eax
  00873	0f 84 96 00 00
	00		 je	 $LN27@z900_form_
  00879	b8 08 00 00 00	 mov	 eax, 8
  0087e	48 6b c0 01	 imul	 rax, rax, 1
  00882	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00891	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00896	85 c0		 test	 eax, eax
  00898	74 75		 je	 SHORT $LN27@z900_form_

; 714  :     {
; 715  :         STORE_FW(regs->mainstor + abs, regs->CR_H(3));

  0089a	b8 08 00 00 00	 mov	 eax, 8
  0089f	48 6b c0 04	 imul	 rax, rax, 4
  008a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ab	8b 8c 01 04 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1540]
  008b2	e8 00 00 00 00	 call	 _byteswap_ulong
  008b7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008bf	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  008c6	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  008cb	8b d0		 mov	 edx, eax
  008cd	e8 00 00 00 00	 call	 store_fw_noswap

; 716  :         STORE_FW(regs->mainstor + abs + 4, regs->CR_H(4));

  008d2	b8 08 00 00 00	 mov	 eax, 8
  008d7	48 6b c0 05	 imul	 rax, rax, 5
  008db	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e3	8b 8c 01 04 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1540]
  008ea	e8 00 00 00 00	 call	 _byteswap_ulong
  008ef	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f7	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  008fe	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00903	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00908	8b d0		 mov	 edx, eax
  0090a	e8 00 00 00 00	 call	 store_fw_noswap
$LN27@z900_form_:

; 717  : 
; 718  :       #ifdef STACK_DEBUG
; 719  :         logmsg (_("stack: SASTEIN=%2.2X%2.2X%2.2X%2.2X "
; 720  :                 "PASTEIN=%2.2X%2.2X%2.2X%2.2X \n"
; 721  :                 "stored at V:" F_VADR " A:" F_RADR "\n"),
; 722  :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 723  :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 724  :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 725  :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 726  :                 lsea, abs);
; 727  :       #endif /*STACK_DEBUG*/
; 728  : 
; 729  :     } /* end if(ASN_AND_LX_REUSE_ENABLED) */
; 730  : 
; 731  :     /* Skip bytes 176-223 of the new stack entry */
; 732  :     lsea += 48;

  0090f	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00914	48 83 c0 30	 add	 rax, 48			; 00000030H
  00918	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 733  :     LSEA_WRAP(lsea);
; 734  :     abs += 48;

  0091d	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00922	48 83 c0 30	 add	 rax, 48			; 00000030H
  00926	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 735  : 
; 736  :     /* Recalculate absolute address if page boundary crossed */
; 737  :     if ((lsea & PAGEFRAME_BYTEMASK) < 48)

  0092b	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00930	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00936	48 83 f8 30	 cmp	 rax, 48			; 00000030H
  0093a	73 1b		 jae	 SHORT $LN28@z900_form_

; 738  :         abs = abs2 | (lsea & PAGEFRAME_BYTEMASK);

  0093c	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00941	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00947	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs2$[rsp]
  0094c	48 0b c8	 or	 rcx, rax
  0094f	48 8b c1	 mov	 rax, rcx
  00952	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN28@z900_form_:

; 739  : 
; 740  :     /* For ESAME, store access registers 0-15 in bytes 224-287 */
; 741  :     for (i = 0; i < 16; i++)

  00957	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0095f	eb 0a		 jmp	 SHORT $LN7@z900_form_
$LN5@z900_form_:
  00961	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00965	ff c0		 inc	 eax
  00967	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_form_:
  0096b	83 7c 24 34 10	 cmp	 DWORD PTR i$[rsp], 16
  00970	7d 6c		 jge	 SHORT $LN6@z900_form_

; 742  :     {
; 743  :         /* Store the access register in the stack entry */
; 744  :         STORE_FW(regs->mainstor + abs, regs->AR(i));

  00972	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  00977	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0097f	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  00986	e8 00 00 00 00	 call	 _byteswap_ulong
  0098b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00993	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0099a	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  0099f	8b d0		 mov	 edx, eax
  009a1	e8 00 00 00 00	 call	 store_fw_noswap

; 745  : 
; 746  :       #ifdef STACK_DEBUG
; 747  :         logmsg (_("stack: AR%d=" F_AREG " stored at V:" F_VADR
; 748  :                 " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 749  :       #endif /*STACK_DEBUG*/
; 750  : 
; 751  :         /* Update the virtual and absolute addresses */
; 752  :         lsea += 4;

  009a6	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  009ab	48 83 c0 04	 add	 rax, 4
  009af	48 89 44 24 28	 mov	 QWORD PTR lsea$[rsp], rax

; 753  :         LSEA_WRAP(lsea);
; 754  :         abs += 4;

  009b4	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  009b9	48 83 c0 04	 add	 rax, 4
  009bd	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 755  : 
; 756  :         /* Recalculate absolute address if page boundary crossed */
; 757  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  009c2	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  009c7	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  009cd	48 85 c0	 test	 rax, rax
  009d0	75 0a		 jne	 SHORT $LN29@z900_form_

; 758  :             abs = abs2;

  009d2	48 8b 44 24 38	 mov	 rax, QWORD PTR abs2$[rsp]
  009d7	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax
$LN29@z900_form_:

; 759  : 
; 760  :     } /* end for(i) */

  009dc	eb 83		 jmp	 SHORT $LN5@z900_form_
$LN6@z900_form_:

; 761  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 762  : 
; 763  :     /* Build the new linkage stack entry descriptor */
; 764  :     memset (&lsed2, 0, sizeof(LSED));

  009de	48 8d 44 24 70	 lea	 rax, QWORD PTR lsed2$[rsp]
  009e3	48 8b f8	 mov	 rdi, rax
  009e6	33 c0		 xor	 eax, eax
  009e8	b9 08 00 00 00	 mov	 ecx, 8
  009ed	f3 aa		 rep stosb

; 765  :     lsed2.uet = etype & LSED_UET_ET;

  009ef	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR etype$[rsp]
  009f7	83 e0 7f	 and	 eax, 127		; 0000007fH
  009fa	88 44 24 70	 mov	 BYTE PTR lsed2$[rsp], al

; 766  :     lsed2.si = lsed.si;

  009fe	0f b6 44 24 69	 movzx	 eax, BYTE PTR lsed$[rsp+1]
  00a03	88 44 24 71	 mov	 BYTE PTR lsed2$[rsp+1], al

; 767  :     rfs -= LSSE_SIZE;

  00a07	0f b7 44 24 30	 movzx	 eax, WORD PTR rfs$[rsp]
  00a0c	2d 28 01 00 00	 sub	 eax, 296		; 00000128H
  00a11	66 89 44 24 30	 mov	 WORD PTR rfs$[rsp], ax

; 768  :     STORE_HW(lsed2.rfs,rfs);

  00a16	0f b7 4c 24 30	 movzx	 ecx, WORD PTR rfs$[rsp]
  00a1b	e8 00 00 00 00	 call	 _byteswap_ushort
  00a20	0f b7 d0	 movzx	 edx, ax
  00a23	48 8d 4c 24 72	 lea	 rcx, QWORD PTR lsed2$[rsp+2]
  00a28	e8 00 00 00 00	 call	 store_hw_noswap

; 769  : 
; 770  :     /* Store the linkage stack entry descriptor in the last eight
; 771  :        bytes of the new state entry (bytes 160-167 for ESA/390,
; 772  :        or bytes 288-295 for ESAME) */
; 773  :     memcpy (regs->mainstor+abs, &lsed2, sizeof(LSED));

  00a2d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a35	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a3c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00a41	48 8b 54 24 70	 mov	 rdx, QWORD PTR lsed2$[rsp]
  00a46	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 774  : 
; 775  : #ifdef STACK_DEBUG
; 776  :     LOGMSG( "stack: New stack entry at " F_VADR "\n", lsea );
; 777  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 778  :             lsed2.uet, lsed2.si, lsed2.rfs[0],
; 779  :             lsed2.rfs[1], lsed2.nes[0], lsed2.nes[1] );
; 780  : #endif /*STACK_DEBUG*/
; 781  : 
; 782  :     /* [5.12.3.3] Update the current entry */
; 783  :     STORE_HW(lsed.nes, LSSE_SIZE);

  00a4a	66 b9 28 01	 mov	 cx, 296			; 00000128H
  00a4e	e8 00 00 00 00	 call	 _byteswap_ushort
  00a53	0f b7 d0	 movzx	 edx, ax
  00a56	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR lsed$[rsp+4]
  00a5b	e8 00 00 00 00	 call	 store_hw_noswap

; 784  :     absold = ARCH_DEP(abs_stack_addr) (lseaold, regs, ACCTYPE_WRITE);

  00a60	41 b8 02 00 00
	00		 mov	 r8d, 2
  00a66	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a6e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lseaold$[rsp]
  00a73	e8 00 00 00 00	 call	 z900_abs_stack_addr
  00a78	48 89 44 24 48	 mov	 QWORD PTR absold$[rsp], rax

; 785  :     memcpy (regs->mainstor+absold, &lsed, sizeof(LSED));

  00a7d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a85	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00a8c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR absold$[rsp]
  00a91	48 8b 54 24 68	 mov	 rdx, QWORD PTR lsed$[rsp]
  00a96	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 786  : 
; 787  : #ifdef STACK_DEBUG
; 788  :     LOGMSG( "stack: Previous stack entry updated at A:" F_RADR "\n",
; 789  :             absold );
; 790  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 791  :             lsed.uet, lsed.si, lsed.rfs[0],
; 792  :             lsed.rfs[1], lsed.nes[0], lsed.nes[1] );
; 793  : #endif /*STACK_DEBUG*/
; 794  : 
; 795  :     /* [5.12.3.4] Update control register 15 */
; 796  :     regs->CR(15) = lsea & CR15_LSEA;

  00a9a	48 8b 44 24 28	 mov	 rax, QWORD PTR lsea$[rsp]
  00a9f	48 83 e0 f8	 and	 rax, -8
  00aa3	b9 08 00 00 00	 mov	 ecx, 8
  00aa8	48 6b c9 10	 imul	 rcx, rcx, 16
  00aac	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ab4	48 89 84 0a 00
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1536], rax

; 797  : 
; 798  : #ifdef STACK_DEBUG
; 799  :     LOGMSG( "stack: CR15=" F_CREG "\n", regs->CR( 15 ));
; 800  : #endif /*STACK_DEBUG*/
; 801  : 
; 802  : } /* end function ARCH_DEP(form_stack_entry) */

  00abc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ac4	48 33 cc	 xor	 rcx, rsp
  00ac7	e8 00 00 00 00	 call	 __security_check_cookie
  00acc	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00ad3	5f		 pop	 rdi
  00ad4	c3		 ret	 0
z900_form_stack_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
i$1 = 32
tsaa1$ = 40
i$ = 48
trap_ia$ = 52
oldmode$2 = 56
tcba$ = 60
tsao$ = 64
trap_flags$ = 68
tcba0$ = 72
tsaa2$ = 80
duct11$ = 88
tv577 = 92
atcba$ = 96
tv180 = 104
tv236 = 108
tv256 = 112
tv312 = 116
tv311 = 120
tv313 = 124
tv323 = 128
tv330 = 132
tv337 = 136
tv339 = 140
tv349 = 144
tv551 = 148
tv571 = 152
tv556 = 156
tv687 = 160
inst_cr$3 = 164
ducto$ = 168
lastbyte$ = 176
trap_psw$ = 184
__$ArrayPad$ = 200
trap_is_trap4$ = 224
regs$ = 232
trap_operand$ = 240
z900_trap_x PROC

; 140  : {

$LN141:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 141  : RADR ducto;
; 142  : U32  duct11;
; 143  : U32  tcba;
; 144  : RADR atcba;
; 145  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 146  : U32  tcba0;
; 147  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 148  : U32  tsao;
; 149  : RADR tsaa1,
; 150  :      tsaa2;
; 151  : VADR lastbyte;
; 152  : U32  trap_ia;
; 153  : U32  trap_flags;
; 154  : QWORD trap_psw;
; 155  : int  i;
; 156  : 
; 157  :     if(SIE_STATE_BIT_ON(regs, MX, XC))

  00028	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00030	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00036	d1 e8		 shr	 eax, 1
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 2c		 je	 SHORT $LN49@z900_trap_
  0003f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00047	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0004e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	74 12		 je	 SHORT $LN49@z900_trap_

; 158  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  00059	ba 13 00 00 00	 mov	 edx, 19
  0005e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	e8 00 00 00 00	 call	 z900_program_interrupt
$LN49@z900_trap_:

; 159  : 
; 160  :     if (   REAL_MODE(&regs->psw)
; 161  :       || !(PRIMARY_SPACE_MODE(&regs->psw)

  0006b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00077	83 e0 04	 and	 eax, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 21		 je	 SHORT $LN51@z900_trap_
  0007e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00086	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0008a	85 c0		 test	 eax, eax
  0008c	74 23		 je	 SHORT $LN50@z900_trap_
  0008e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0009a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0009d	74 12		 je	 SHORT $LN50@z900_trap_
$LN51@z900_trap_:

; 162  :       ||   ACCESS_REGISTER_MODE(&regs->psw)) )
; 163  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0009f	ba 13 00 00 00	 mov	 edx, 19
  000a4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 z900_program_interrupt
$LN50@z900_trap_:

; 164  : 
; 165  :     /* Obtain the DUCT origin from control register 2 */
; 166  :     ducto = regs->CR(2) & CR2_DUCTO;

  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	48 6b c0 03	 imul	 rax, rax, 3
  000ba	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ca	48 25 c0 ff ff
	7f		 and	 rax, 2147483584		; 7fffffc0H
  000d0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ducto$[rsp], rax

; 167  : 
; 168  :     /* Program check if DUCT origin address is invalid */
; 169  :     if (ducto > regs->mainlim)

  000d8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  000e7	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR ducto$[rsp], rax
  000ef	76 12		 jbe	 SHORT $LN52@z900_trap_

; 170  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  000f1	ba 05 00 00 00	 mov	 edx, 5
  000f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 z900_program_interrupt
$LN52@z900_trap_:

; 171  : 
; 172  :     /* Fetch DUCT bytes 44-47 */
; 173  :     duct11 = ARCH_DEP(fetch_fullword_absolute) (ducto + 44, regs);

  00103	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ducto$[rsp]
  0010b	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0010f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 z900_fetch_fullword_absolute
  0011f	89 44 24 58	 mov	 DWORD PTR duct11$[rsp], eax

; 174  : 
; 175  :     if(!(duct11 & DUCT11_TE))

  00123	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00127	83 e0 01	 and	 eax, 1
  0012a	85 c0		 test	 eax, eax
  0012c	75 12		 jne	 SHORT $LN53@z900_trap_

; 176  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0012e	ba 13 00 00 00	 mov	 edx, 19
  00133	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN53@z900_trap_:

; 177  : 
; 178  :     /* Isolate the Trap Control Block Address */
; 179  :     tcba = duct11 & DUCT11_TCBA;

  00140	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00144	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00149	89 44 24 3c	 mov	 DWORD PTR tcba$[rsp], eax

; 180  : 
; 181  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 182  :     /* Fetch word 0 of the TCB */
; 183  :     atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);

  0014d	8b 44 24 3c	 mov	 eax, DWORD PTR tcba$[rsp]
  00151	41 b8 04 00 00
	00		 mov	 r8d, 4
  00157	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0015f	8b c8		 mov	 ecx, eax
  00161	e8 00 00 00 00	 call	 z900_abs_trap_addr
  00166	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax

; 184  :     FETCH_FW(tcba0, regs->mainstor + atcba);

  0016b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0017a	48 03 44 24 60	 add	 rax, QWORD PTR atcba$[rsp]
  0017f	48 8b c8	 mov	 rcx, rax
  00182	e8 00 00 00 00	 call	 fetch_fw_noswap
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 _byteswap_ulong
  0018e	89 44 24 48	 mov	 DWORD PTR tcba0$[rsp], eax

; 185  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 186  : 
; 187  :     /* Advance to offset +12 */
; 188  :     tcba += 12;

  00192	8b 44 24 3c	 mov	 eax, DWORD PTR tcba$[rsp]
  00196	83 c0 0c	 add	 eax, 12
  00199	89 44 24 3c	 mov	 DWORD PTR tcba$[rsp], eax

; 189  :     atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);

  0019d	8b 44 24 3c	 mov	 eax, DWORD PTR tcba$[rsp]
  001a1	41 b8 04 00 00
	00		 mov	 r8d, 4
  001a7	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001af	8b c8		 mov	 ecx, eax
  001b1	e8 00 00 00 00	 call	 z900_abs_trap_addr
  001b6	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax

; 190  : 
; 191  :     /* Fetch word 3 of the TCB */
; 192  :     FETCH_FW(tsao, regs->mainstor + atcba);

  001bb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001ca	48 03 44 24 60	 add	 rax, QWORD PTR atcba$[rsp]
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	e8 00 00 00 00	 call	 fetch_fw_noswap
  001d7	8b c8		 mov	 ecx, eax
  001d9	e8 00 00 00 00	 call	 _byteswap_ulong
  001de	89 44 24 40	 mov	 DWORD PTR tsao$[rsp], eax

; 193  :     tsao &= 0x7FFFFFF8;

  001e2	8b 44 24 40	 mov	 eax, DWORD PTR tsao$[rsp]
  001e6	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  001eb	89 44 24 40	 mov	 DWORD PTR tsao$[rsp], eax

; 194  : 
; 195  :     /* Advance to offset +20 */
; 196  :     tcba += 8; atcba += 8;

  001ef	8b 44 24 3c	 mov	 eax, DWORD PTR tcba$[rsp]
  001f3	83 c0 08	 add	 eax, 8
  001f6	89 44 24 3c	 mov	 DWORD PTR tcba$[rsp], eax
  001fa	48 8b 44 24 60	 mov	 rax, QWORD PTR atcba$[rsp]
  001ff	48 83 c0 08	 add	 rax, 8
  00203	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax

; 197  :     if((atcba & PAGEFRAME_BYTEMASK) < 8)

  00208	48 8b 44 24 60	 mov	 rax, QWORD PTR atcba$[rsp]
  0020d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00213	48 83 f8 08	 cmp	 rax, 8
  00217	73 1e		 jae	 SHORT $LN54@z900_trap_

; 198  :         atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);

  00219	8b 44 24 3c	 mov	 eax, DWORD PTR tcba$[rsp]
  0021d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00223	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0022b	8b c8		 mov	 ecx, eax
  0022d	e8 00 00 00 00	 call	 z900_abs_trap_addr
  00232	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax
$LN54@z900_trap_:

; 199  : 
; 200  :     /* Fetch word 5 of the TCB */
; 201  :     FETCH_FW(trap_ia, regs->mainstor + atcba);

  00237	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00246	48 03 44 24 60	 add	 rax, QWORD PTR atcba$[rsp]
  0024b	48 8b c8	 mov	 rcx, rax
  0024e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00253	8b c8		 mov	 ecx, eax
  00255	e8 00 00 00 00	 call	 _byteswap_ulong
  0025a	89 44 24 34	 mov	 DWORD PTR trap_ia$[rsp], eax

; 202  :     trap_ia &= 0x7FFFFFFF;

  0025e	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  00262	0f ba f0 1f	 btr	 eax, 31
  00266	89 44 24 34	 mov	 DWORD PTR trap_ia$[rsp], eax

; 203  : 
; 204  :     /* Calculate last byte stored */
; 205  :     lastbyte = tsao + 95

  0026a	8b 44 24 48	 mov	 eax, DWORD PTR tcba0$[rsp]
  0026e	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00273	85 c0		 test	 eax, eax
  00275	74 0a		 je	 SHORT $LN97@z900_trap_
  00277	c7 44 24 68 40
	00 00 00	 mov	 DWORD PTR tv180[rsp], 64 ; 00000040H
  0027f	eb 08		 jmp	 SHORT $LN98@z900_trap_
$LN97@z900_trap_:
  00281	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN98@z900_trap_:
  00289	8b 44 24 40	 mov	 eax, DWORD PTR tsao$[rsp]
  0028d	8b 4c 24 68	 mov	 ecx, DWORD PTR tv180[rsp]
  00291	8d 44 08 5f	 lea	 eax, DWORD PTR [rax+rcx+95]
  00295	8b c0		 mov	 eax, eax
  00297	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR lastbyte$[rsp], rax

; 206  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 207  :                          + ((tcba0 & TCB0_R) ? 64 : 0)
; 208  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 209  :                                                        ;
; 210  : 
; 211  :     /* Use abs_trap_addr as it conforms to trap save area access */
; 212  :     tsaa1 = tsaa2 = ARCH_DEP(abs_trap_addr) (tsao, regs, ACCTYPE_WRITE);

  0029f	8b 44 24 40	 mov	 eax, DWORD PTR tsao$[rsp]
  002a3	41 b8 02 00 00
	00		 mov	 r8d, 2
  002a9	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002b1	8b c8		 mov	 ecx, eax
  002b3	e8 00 00 00 00	 call	 z900_abs_trap_addr
  002b8	48 89 44 24 50	 mov	 QWORD PTR tsaa2$[rsp], rax
  002bd	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  002c2	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 213  :     if((tsaa1 & PAGEFRAME_PAGEMASK) != (lastbyte & PAGEFRAME_PAGEMASK))

  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  002cc	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR lastbyte$[rsp]
  002da	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  002e1	48 3b c1	 cmp	 rax, rcx
  002e4	74 30		 je	 SHORT $LN55@z900_trap_

; 214  :     {
; 215  :         tsao = lastbyte & PAGEFRAME_PAGEMASK;

  002e6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR lastbyte$[rsp]
  002ee	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002f4	89 44 24 40	 mov	 DWORD PTR tsao$[rsp], eax

; 216  :         tsaa2 = ARCH_DEP(abs_trap_addr) (tsao, regs, ACCTYPE_WRITE);

  002f8	8b 44 24 40	 mov	 eax, DWORD PTR tsao$[rsp]
  002fc	41 b8 02 00 00
	00		 mov	 r8d, 2
  00302	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0030a	8b c8		 mov	 ecx, eax
  0030c	e8 00 00 00 00	 call	 z900_abs_trap_addr
  00311	48 89 44 24 50	 mov	 QWORD PTR tsaa2$[rsp], rax
$LN55@z900_trap_:

; 217  :     }
; 218  :     ARCH_DEP( or_storage_key )( tsaa1, STORKEY_CHANGE );

  00316	b2 02		 mov	 dl, 2
  00318	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsaa1$[rsp]
  0031d	e8 00 00 00 00	 call	 z900_or_storage_key

; 219  :     if (tsaa1 != tsaa2)

  00322	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  00327	48 39 44 24 28	 cmp	 QWORD PTR tsaa1$[rsp], rax
  0032c	74 0c		 je	 SHORT $LN56@z900_trap_

; 220  :         ARCH_DEP( or_storage_key )( tsaa2, STORKEY_CHANGE );

  0032e	b2 02		 mov	 dl, 2
  00330	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tsaa2$[rsp]
  00335	e8 00 00 00 00	 call	 z900_or_storage_key
$LN56@z900_trap_:

; 221  : 
; 222  : 
; 223  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 224  :     /* Special operation exception if P == 0 and EA == 1 */
; 225  :     if(!(tcba0 & TCB0_P) && regs->psw.amode64)

  0033a	8b 44 24 48	 mov	 eax, DWORD PTR tcba0$[rsp]
  0033e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00343	85 c0		 test	 eax, eax
  00345	75 27		 jne	 SHORT $LN57@z900_trap_
  00347	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00355	83 e0 01	 and	 eax, 1
  00358	85 c0		 test	 eax, eax
  0035a	74 12		 je	 SHORT $LN57@z900_trap_

; 226  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0035c	ba 13 00 00 00	 mov	 edx, 19
  00361	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	e8 00 00 00 00	 call	 z900_program_interrupt
$LN57@z900_trap_:

; 227  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 228  : 
; 229  :   #ifdef FEATURE_TRACING
; 230  :     if (regs->CR(12) & CR12_BRTRACE)

  0036e	b8 08 00 00 00	 mov	 eax, 8
  00373	48 6b c0 0d	 imul	 rax, rax, 13
  00377	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  00389	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00391	48 23 c2	 and	 rax, rdx
  00394	48 85 c0	 test	 rax, rax
  00397	74 31		 je	 SHORT $LN58@z900_trap_

; 231  :         regs->CR(12) = ARCH_DEP(trace_br) (1, trap_ia, regs);

  00399	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  0039d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a5	8b d0		 mov	 edx, eax
  003a7	b9 01 00 00 00	 mov	 ecx, 1
  003ac	e8 00 00 00 00	 call	 z900_trace_br
  003b1	b9 08 00 00 00	 mov	 ecx, 8
  003b6	48 6b c9 0d	 imul	 rcx, rcx, 13
  003ba	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003c2	48 89 84 0a 00
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1536], rax
$LN58@z900_trap_:
$LN4@z900_trap_:

; 232  :   #endif /*FEATURE_TRACING*/
; 233  : 
; 234  :     PER_SB(regs, trap_ia);

  003ca	33 c0		 xor	 eax, eax
  003cc	83 f8 01	 cmp	 eax, 1
  003cf	0f 84 fa 01 00
	00		 je	 $LN59@z900_trap_
  003d5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003dd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003e3	c1 e8 02	 shr	 eax, 2
  003e6	83 e0 01	 and	 eax, 1
  003e9	85 c0		 test	 eax, eax
  003eb	74 0a		 je	 SHORT $LN101@z900_trap_
  003ed	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv236[rsp], 1
  003f5	eb 08		 jmp	 SHORT $LN102@z900_trap_
$LN101@z900_trap_:
  003f7	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN102@z900_trap_:
  003ff	83 7c 24 6c 00	 cmp	 DWORD PTR tv236[rsp], 0
  00404	74 1e		 je	 SHORT $LN103@z900_trap_
  00406	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00411	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00416	85 c0		 test	 eax, eax
  00418	74 0a		 je	 SHORT $LN103@z900_trap_
  0041a	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv256[rsp], 1
  00422	eb 08		 jmp	 SHORT $LN109@z900_trap_
$LN103@z900_trap_:
  00424	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv256[rsp], 0
$LN109@z900_trap_:
  0042c	83 7c 24 70 00	 cmp	 DWORD PTR tv256[rsp], 0
  00431	0f 84 98 01 00
	00		 je	 $LN59@z900_trap_
  00437	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  0043c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00444	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00449	0f b6 c0	 movzx	 eax, al
  0044c	85 c0		 test	 eax, eax
  0044e	0f 85 7b 01 00
	00		 jne	 $LN59@z900_trap_
  00454	33 c0		 xor	 eax, eax
  00456	85 c0		 test	 eax, eax
  00458	0f 85 51 01 00
	00		 jne	 $LN60@z900_trap_
  0045e	b8 08 00 00 00	 mov	 eax, 8
  00463	48 6b c0 0a	 imul	 rax, rax, 10
  00467	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00477	48 25 00 00 80
	00		 and	 rax, 8388608		; 00800000H
  0047d	48 85 c0	 test	 rax, rax
  00480	0f 84 29 01 00
	00		 je	 $LN60@z900_trap_
  00486	b8 08 00 00 00	 mov	 eax, 8
  0048b	48 6b c0 0c	 imul	 rax, rax, 12
  0048f	b9 08 00 00 00	 mov	 ecx, 8
  00494	48 6b c9 0b	 imul	 rcx, rcx, 11
  00498	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a0	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004a8	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  004b0	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  004b8	72 78		 jb	 SHORT $LN114@z900_trap_
  004ba	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  004be	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004cd	b9 08 00 00 00	 mov	 ecx, 8
  004d2	48 6b c9 0b	 imul	 rcx, rcx, 11
  004d6	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004de	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  004e6	72 38		 jb	 SHORT $LN110@z900_trap_
  004e8	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  004ec	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004fb	b9 08 00 00 00	 mov	 ecx, 8
  00500	48 6b c9 0c	 imul	 rcx, rcx, 12
  00504	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0050c	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00514	77 0a		 ja	 SHORT $LN110@z900_trap_
  00516	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv312[rsp], 1
  0051e	eb 08		 jmp	 SHORT $LN113@z900_trap_
$LN110@z900_trap_:
  00520	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv312[rsp], 0
$LN113@z900_trap_:
  00528	8b 44 24 74	 mov	 eax, DWORD PTR tv312[rsp]
  0052c	89 44 24 7c	 mov	 DWORD PTR tv313[rsp], eax
  00530	eb 76		 jmp	 SHORT $LN115@z900_trap_
$LN114@z900_trap_:
  00532	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  00536	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00545	b9 08 00 00 00	 mov	 ecx, 8
  0054a	48 6b c9 0b	 imul	 rcx, rcx, 11
  0054e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00556	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  0055e	73 38		 jae	 SHORT $LN111@z900_trap_
  00560	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  00564	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00573	b9 08 00 00 00	 mov	 ecx, 8
  00578	48 6b c9 0c	 imul	 rcx, rcx, 12
  0057c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00584	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  0058c	76 0a		 jbe	 SHORT $LN111@z900_trap_
  0058e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv311[rsp], 0
  00596	eb 08		 jmp	 SHORT $LN112@z900_trap_
$LN111@z900_trap_:
  00598	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv311[rsp], 1
$LN112@z900_trap_:
  005a0	8b 44 24 78	 mov	 eax, DWORD PTR tv311[rsp]
  005a4	89 44 24 7c	 mov	 DWORD PTR tv313[rsp], eax
$LN115@z900_trap_:
  005a8	83 7c 24 7c 00	 cmp	 DWORD PTR tv313[rsp], 0
  005ad	74 20		 je	 SHORT $LN59@z900_trap_
$LN60@z900_trap_:
$LN7@z900_trap_:
  005af	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  005ba	0f ba e8 17	 bts	 eax, 23
  005be	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  005c9	33 c0		 xor	 eax, eax
  005cb	85 c0		 test	 eax, eax
  005cd	75 e0		 jne	 SHORT $LN7@z900_trap_
$LN59@z900_trap_:
  005cf	33 c0		 xor	 eax, eax
  005d1	85 c0		 test	 eax, eax
  005d3	0f 85 f1 fd ff
	ff		 jne	 $LN4@z900_trap_

; 235  : 
; 236  :     trap_flags = REAL_ILC(regs) << 16;

  005d9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005e7	83 e0 01	 and	 eax, 1
  005ea	85 c0		 test	 eax, eax
  005ec	75 0d		 jne	 SHORT $LN116@z900_trap_
  005ee	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv323[rsp], 1
  005f9	eb 0b		 jmp	 SHORT $LN117@z900_trap_
$LN116@z900_trap_:
  005fb	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv323[rsp], 0
$LN117@z900_trap_:
  00606	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv323[rsp], 0
  0060e	74 0d		 je	 SHORT $LN120@z900_trap_
  00610	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv330[rsp], 1
  0061b	eb 0b		 jmp	 SHORT $LN121@z900_trap_
$LN120@z900_trap_:
  0061d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv330[rsp], 0
$LN121@z900_trap_:
  00628	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv330[rsp], 0
  00630	74 18		 je	 SHORT $LN124@z900_trap_
  00632	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063a	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00641	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
  00648	eb 3d		 jmp	 SHORT $LN125@z900_trap_
$LN124@z900_trap_:
  0064a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00652	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00658	d1 e8		 shr	 eax, 1
  0065a	83 e0 01	 and	 eax, 1
  0065d	85 c0		 test	 eax, eax
  0065f	74 0d		 je	 SHORT $LN122@z900_trap_
  00661	c7 84 24 88 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv337[rsp], 6
  0066c	eb 0b		 jmp	 SHORT $LN123@z900_trap_
$LN122@z900_trap_:
  0066e	c7 84 24 88 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv337[rsp], 4
$LN123@z900_trap_:
  00679	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv337[rsp]
  00680	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
$LN125@z900_trap_:
  00687	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv339[rsp]
  0068e	c1 e0 10	 shl	 eax, 16
  00691	89 44 24 44	 mov	 DWORD PTR trap_flags$[rsp], eax

; 237  : 
; 238  :     if(unlikely(regs->execflag))

  00695	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006a3	83 e0 01	 and	 eax, 1
  006a6	85 c0		 test	 eax, eax
  006a8	74 0d		 je	 SHORT $LN128@z900_trap_
  006aa	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv349[rsp], 1
  006b5	eb 0b		 jmp	 SHORT $LN129@z900_trap_
$LN128@z900_trap_:
  006b7	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv349[rsp], 0
$LN129@z900_trap_:
  006c2	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv349[rsp], 0
  006ca	74 0c		 je	 SHORT $LN61@z900_trap_

; 239  :         trap_flags |= TRAP0_EXECUTE;

  006cc	8b 44 24 44	 mov	 eax, DWORD PTR trap_flags$[rsp]
  006d0	0f ba e8 1f	 bts	 eax, 31
  006d4	89 44 24 44	 mov	 DWORD PTR trap_flags$[rsp], eax
$LN61@z900_trap_:

; 240  : 
; 241  :     if(trap_is_trap4)

  006d8	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR trap_is_trap4$[rsp], 0
  006e0	74 0c		 je	 SHORT $LN62@z900_trap_

; 242  :         trap_flags |= TRAP0_TRAP4;

  006e2	8b 44 24 44	 mov	 eax, DWORD PTR trap_flags$[rsp]
  006e6	0f ba e8 1e	 bts	 eax, 30
  006ea	89 44 24 44	 mov	 DWORD PTR trap_flags$[rsp], eax
$LN62@z900_trap_:

; 243  : 
; 244  :     /* Trap flags at offset +0 */
; 245  :     STORE_FW(regs->mainstor + tsaa1, trap_flags);

  006ee	8b 4c 24 44	 mov	 ecx, DWORD PTR trap_flags$[rsp]
  006f2	e8 00 00 00 00	 call	 _byteswap_ulong
  006f7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ff	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00706	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  0070b	8b d0		 mov	 edx, eax
  0070d	e8 00 00 00 00	 call	 store_fw_noswap

; 246  :     /* Reserved zero's stored at offset +4 */
; 247  :     STORE_FW(regs->mainstor + tsaa1 + 4, 0);

  00712	33 c9		 xor	 ecx, ecx
  00714	e8 00 00 00 00	 call	 _byteswap_ulong
  00719	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00721	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00728	48 8b 54 24 28	 mov	 rdx, QWORD PTR tsaa1$[rsp]
  0072d	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00732	8b d0		 mov	 edx, eax
  00734	e8 00 00 00 00	 call	 store_fw_noswap

; 248  : 
; 249  :     tsaa1 += 8;

  00739	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0073e	48 83 c0 08	 add	 rax, 8
  00742	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 250  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  00747	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0074c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00752	48 85 c0	 test	 rax, rax
  00755	75 0a		 jne	 SHORT $LN63@z900_trap_

; 251  :         tsaa1 = tsaa2;

  00757	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0075c	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN63@z900_trap_:

; 252  : 
; 253  :     /* Bits 33-63 of Second-Op address of TRAP4 at offset +8 */
; 254  :     STORE_FW(regs->mainstor + tsaa1, trap_operand);

  00761	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR trap_operand$[rsp]
  00768	e8 00 00 00 00	 call	 _byteswap_ulong
  0076d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00775	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0077c	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  00781	8b d0		 mov	 edx, eax
  00783	e8 00 00 00 00	 call	 store_fw_noswap

; 255  :     /* Access register 15 at offset +12 */
; 256  :     STORE_FW(regs->mainstor + tsaa1 + 4, regs->AR(15));

  00788	b8 04 00 00 00	 mov	 eax, 4
  0078d	48 6b c0 0f	 imul	 rax, rax, 15
  00791	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00799	8b 8c 01 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+768]
  007a0	e8 00 00 00 00	 call	 _byteswap_ulong
  007a5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ad	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  007b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR tsaa1$[rsp]
  007b9	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  007be	8b d0		 mov	 edx, eax
  007c0	e8 00 00 00 00	 call	 store_fw_noswap

; 257  : 
; 258  :     tsaa1 += 8;

  007c5	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  007ca	48 83 c0 08	 add	 rax, 8
  007ce	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 259  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  007d3	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  007d8	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  007de	48 85 c0	 test	 rax, rax
  007e1	75 0a		 jne	 SHORT $LN64@z900_trap_

; 260  :         tsaa1 = tsaa2;

  007e3	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  007e8	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN64@z900_trap_:

; 261  : 
; 262  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 263  :     /* If the P bit is one then store the PSW in esame format */
; 264  :     if(tcba0 & TCB0_P)

  007ed	8b 44 24 48	 mov	 eax, DWORD PTR tcba0$[rsp]
  007f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  007f6	85 c0		 test	 eax, eax
  007f8	74 17		 je	 SHORT $LN65@z900_trap_

; 265  :         ARCH_DEP(store_psw) (regs, trap_psw);

  007fa	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR trap_psw$[rsp]
  00802	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080a	e8 00 00 00 00	 call	 z900_store_psw
  0080f	eb 39		 jmp	 SHORT $LN66@z900_trap_
$LN65@z900_trap_:

; 266  :     else
; 267  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 268  :     {
; 269  :         s390_store_psw(regs, trap_psw);

  00811	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR trap_psw$[rsp]
  00819	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00821	e8 00 00 00 00	 call	 s390_store_psw

; 270  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 271  :         /* Set the notesame mode bit for a esa/390 psw */
; 272  :         trap_psw[1] |= 0x08;

  00826	b8 01 00 00 00	 mov	 eax, 1
  0082b	48 6b c0 01	 imul	 rax, rax, 1
  0082f	0f b6 84 04 b8
	00 00 00	 movzx	 eax, BYTE PTR trap_psw$[rsp+rax]
  00837	83 c8 08	 or	 eax, 8
  0083a	b9 01 00 00 00	 mov	 ecx, 1
  0083f	48 6b c9 01	 imul	 rcx, rcx, 1
  00843	88 84 0c b8 00
	00 00		 mov	 BYTE PTR trap_psw$[rsp+rcx], al
$LN66@z900_trap_:

; 273  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 274  :     }
; 275  : 
; 276  :     /* bits 0-63 of PSW at offset +16 */
; 277  :     memcpy(regs->mainstor + tsaa1, trap_psw, 8);

  0084a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00852	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00859	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsaa1$[rsp]
  0085e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR trap_psw$[rsp]
  00866	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 278  :     tsaa1 += 8;

  0086a	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0086f	48 83 c0 08	 add	 rax, 8
  00873	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 279  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  00878	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0087d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00883	48 85 c0	 test	 rax, rax
  00886	75 0a		 jne	 SHORT $LN67@z900_trap_

; 280  :     {
; 281  :         tsaa1 = tsaa2;

  00888	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0088d	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN67@z900_trap_:

; 282  :     }
; 283  : 
; 284  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 285  :     /* If the P bit is one then store the PSW in esame format */
; 286  :     /* bits 64-127 of PSW at offset +24 */
; 287  :     if(tcba0 & TCB0_P)

  00892	8b 44 24 48	 mov	 eax, DWORD PTR tcba0$[rsp]
  00896	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0089b	85 c0		 test	 eax, eax
  0089d	74 22		 je	 SHORT $LN68@z900_trap_

; 288  :     {
; 289  :         memcpy(regs->mainstor + tsaa1, trap_psw + 8, 8);

  0089f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  008ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsaa1$[rsp]
  008b3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR trap_psw$[rsp+8]
  008bb	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 290  :     }

  008bf	eb 20		 jmp	 SHORT $LN69@z900_trap_
$LN68@z900_trap_:

; 291  :     else
; 292  :     {
; 293  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 294  :         memset(regs->mainstor + tsaa1, 0, 8);

  008c1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c9	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  008d0	48 03 44 24 28	 add	 rax, QWORD PTR tsaa1$[rsp]
  008d5	48 8b f8	 mov	 rdi, rax
  008d8	33 c0		 xor	 eax, eax
  008da	b9 08 00 00 00	 mov	 ecx, 8
  008df	f3 aa		 rep stosb
$LN69@z900_trap_:

; 295  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 296  :     }
; 297  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 298  :     tsaa1 += 8;

  008e1	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  008e6	48 83 c0 08	 add	 rax, 8
  008ea	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 299  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  008ef	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  008f4	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  008fa	48 85 c0	 test	 rax, rax
  008fd	75 0a		 jne	 SHORT $LN70@z900_trap_

; 300  :         tsaa1 = tsaa2;

  008ff	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  00904	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN70@z900_trap_:

; 301  : 
; 302  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 303  :     /* General registers at offset +32 */
; 304  :     if(tcba0 & TCB0_R)

  00909	8b 44 24 48	 mov	 eax, DWORD PTR tcba0$[rsp]
  0090d	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00912	85 c0		 test	 eax, eax
  00914	74 7d		 je	 SHORT $LN71@z900_trap_

; 305  :         for(i = 0; i < 16; i++)

  00916	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0091e	eb 0a		 jmp	 SHORT $LN10@z900_trap_
$LN8@z900_trap_:
  00920	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00924	ff c0		 inc	 eax
  00926	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_trap_:
  0092a	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  0092f	7d 60		 jge	 SHORT $LN9@z900_trap_

; 306  :         {
; 307  :             STORE_DW(regs->mainstor + tsaa1, regs->GR_G(i));

  00931	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00936	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093e	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00946	e8 00 00 00 00	 call	 _byteswap_uint64
  0094b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00953	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0095a	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  0095f	48 8b d0	 mov	 rdx, rax
  00962	e8 00 00 00 00	 call	 store_dw_noswap

; 308  :             tsaa1 += 8;

  00967	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0096c	48 83 c0 08	 add	 rax, 8
  00970	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 309  :             if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  00975	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0097a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00980	48 85 c0	 test	 rax, rax
  00983	75 0a		 jne	 SHORT $LN73@z900_trap_

; 310  :                 tsaa1 = tsaa2;

  00985	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0098a	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN73@z900_trap_:

; 311  :         }

  0098f	eb 8f		 jmp	 SHORT $LN8@z900_trap_
$LN9@z900_trap_:
  00991	eb 79		 jmp	 SHORT $LN72@z900_trap_
$LN71@z900_trap_:

; 312  :     else
; 313  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 314  :         for(i = 0; i < 16; i++)

  00993	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0099b	eb 0a		 jmp	 SHORT $LN13@z900_trap_
$LN11@z900_trap_:
  0099d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  009a1	ff c0		 inc	 eax
  009a3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_trap_:
  009a7	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  009ac	7d 5e		 jge	 SHORT $LN12@z900_trap_

; 315  :         {
; 316  :             STORE_FW(regs->mainstor + tsaa1, regs->GR_L(i));

  009ae	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  009b3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009bb	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  009c2	e8 00 00 00 00	 call	 _byteswap_ulong
  009c7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009cf	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  009d6	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  009db	8b d0		 mov	 edx, eax
  009dd	e8 00 00 00 00	 call	 store_fw_noswap

; 317  :             tsaa1 += 4;

  009e2	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  009e7	48 83 c0 04	 add	 rax, 4
  009eb	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 318  :             if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  009f0	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  009f5	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  009fb	48 85 c0	 test	 rax, rax
  009fe	75 0a		 jne	 SHORT $LN74@z900_trap_

; 319  :                 tsaa1 = tsaa2;

  00a00	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  00a05	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN74@z900_trap_:

; 320  :         }

  00a0a	eb 91		 jmp	 SHORT $LN11@z900_trap_
$LN12@z900_trap_:
$LN72@z900_trap_:

; 321  : 
; 322  :     /* Load the Trap Control Block Address in gr15 */
; 323  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 324  :     if(regs->psw.amode64)

  00a0c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a14	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a1a	83 e0 01	 and	 eax, 1
  00a1d	85 c0		 test	 eax, eax
  00a1f	74 26		 je	 SHORT $LN75@z900_trap_

; 325  :         regs->GR(15) = duct11 & DUCT11_TCBA & 0x00000000FFFFFFFF;

  00a21	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00a25	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00a2a	b9 08 00 00 00	 mov	 ecx, 8
  00a2f	48 6b c9 0f	 imul	 rcx, rcx, 15
  00a33	8b c0		 mov	 eax, eax
  00a35	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a3d	48 89 84 0a 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx+640], rax
  00a45	eb 21		 jmp	 SHORT $LN76@z900_trap_
$LN75@z900_trap_:

; 326  :     else
; 327  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 328  :         regs->GR_L(15) = duct11 & DUCT11_TCBA;

  00a47	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00a4b	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00a50	b9 08 00 00 00	 mov	 ecx, 8
  00a55	48 6b c9 0f	 imul	 rcx, rcx, 15
  00a59	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a61	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN76@z900_trap_:
$LN16@z900_trap_:

; 329  : 
; 330  :     /* Ensure psw.IA is set */
; 331  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  00a68	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a70	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00a78	74 51		 je	 SHORT $LN77@z900_trap_
  00a7a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a82	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00a91	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00a95	48 2b c1	 sub	 rax, rcx
  00a98	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa0	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00aa7	48 03 c8	 add	 rcx, rax
  00aaa	48 8b c1	 mov	 rax, rcx
  00aad	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ab5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00abc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac4	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN77@z900_trap_:
  00acb	33 c0		 xor	 eax, eax
  00acd	85 c0		 test	 eax, eax
  00acf	75 97		 jne	 SHORT $LN16@z900_trap_

; 332  : 
; 333  :     /* Set the Breaking Event Address Register */
; 334  :     if (trap_is_trap4)

  00ad1	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR trap_is_trap4$[rsp], 0
  00ad9	74 31		 je	 SHORT $LN78@z900_trap_

; 335  :     {
; 336  :         SET_BEAR_REG( regs, regs->ip - 4 );

  00adb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00ae7	48 83 e8 04	 sub	 rax, 4
  00aeb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00af3	48 81 c1 18 02
	00 00		 add	 rcx, 536		; 00000218H
  00afa	4c 8b c0	 mov	 r8, rax
  00afd	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b05	e8 00 00 00 00	 call	 z900_Set_BEAR_Reg

; 337  :     }

  00b0a	eb 2f		 jmp	 SHORT $LN79@z900_trap_
$LN78@z900_trap_:

; 338  :     else
; 339  :     {
; 340  :         SET_BEAR_REG( regs, regs->ip - 2 );

  00b0c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b14	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00b18	48 83 e8 02	 sub	 rax, 2
  00b1c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b24	48 81 c1 18 02
	00 00		 add	 rcx, 536		; 00000218H
  00b2b	4c 8b c0	 mov	 r8, rax
  00b2e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b36	e8 00 00 00 00	 call	 z900_Set_BEAR_Reg
$LN79@z900_trap_:

; 341  :     }
; 342  : 
; 343  :     regs->psw.amode = 1;

  00b3b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b43	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b49	83 c8 02	 or	 eax, 2
  00b4c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b54	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 344  :     regs->psw.AMASK = AMASK31;

  00b5a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b62	48 c7 80 90 00
	00 00 ff ff ff
	7f		 mov	 QWORD PTR [rax+144], 2147483647 ; 7fffffffH
$LN19@z900_trap_:

; 345  :     SET_PSW_IA_AND_MAYBE_IP(regs, trap_ia);

  00b6d	8b 44 24 34	 mov	 eax, DWORD PTR trap_ia$[rsp]
  00b71	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b79	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00b80	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b88	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00b8f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b97	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00b9f	74 71		 je	 SHORT $LN80@z900_trap_
  00ba1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba9	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00bb0	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00bb6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bbe	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  00bc5	75 38		 jne	 SHORT $LN81@z900_trap_
  00bc7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bcf	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00bd6	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00bdc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00be4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00beb	48 0b c8	 or	 rcx, rax
  00bee	48 8b c1	 mov	 rax, rcx
  00bf1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00bfd	eb 13		 jmp	 SHORT $LN82@z900_trap_
$LN81@z900_trap_:
  00bff	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c07	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN82@z900_trap_:
$LN80@z900_trap_:
  00c12	33 c0		 xor	 eax, eax
  00c14	85 c0		 test	 eax, eax
  00c16	0f 85 51 ff ff
	ff		 jne	 $LN19@z900_trap_

; 346  :     /* set PSW to primary space */
; 347  :     regs->psw.asc = 0;

  00c1c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c24	c6 40 7b 00	 mov	 BYTE PTR [rax+123], 0
$LN22@z900_trap_:

; 348  :     SET_AEA_MODE(regs);

  00c28	b8 04 00 00 00	 mov	 eax, 4
  00c2d	48 6b c0 04	 imul	 rax, rax, 4
  00c31	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c39	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00c40	89 84 24 a4 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  00c47	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c4f	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00c56	88 44 24 38	 mov	 BYTE PTR oldmode$2[rsp], al
  00c5a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c62	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00c66	83 e0 04	 and	 eax, 4
  00c69	85 c0		 test	 eax, eax
  00c6b	75 6c		 jne	 SHORT $LN132@z900_trap_
  00c6d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c75	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00c7b	d1 e8		 shr	 eax, 1
  00c7d	83 e0 01	 and	 eax, 1
  00c80	85 c0		 test	 eax, eax
  00c82	74 3a		 je	 SHORT $LN130@z900_trap_
  00c84	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c8c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00c93	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00c97	83 e0 01	 and	 eax, 1
  00c9a	85 c0		 test	 eax, eax
  00c9c	74 20		 je	 SHORT $LN130@z900_trap_
  00c9e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca6	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00caa	83 e0 40	 and	 eax, 64			; 00000040H
  00cad	85 c0		 test	 eax, eax
  00caf	74 0d		 je	 SHORT $LN130@z900_trap_
  00cb1	c7 84 24 94 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv551[rsp], 2
  00cbc	eb 0b		 jmp	 SHORT $LN131@z900_trap_
$LN130@z900_trap_:
  00cbe	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv551[rsp], 0
$LN131@z900_trap_:
  00cc9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv551[rsp]
  00cd0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv556[rsp], eax
  00cd7	eb 18		 jmp	 SHORT $LN133@z900_trap_
$LN132@z900_trap_:
  00cd9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ce1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00ce5	c1 f8 06	 sar	 eax, 6
  00ce8	ff c0		 inc	 eax
  00cea	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv556[rsp], eax
$LN133@z900_trap_:
  00cf1	33 c0		 xor	 eax, eax
  00cf3	85 c0		 test	 eax, eax
  00cf5	75 51		 jne	 SHORT $LN134@z900_trap_
  00cf7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cff	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00d03	83 e0 40	 and	 eax, 64			; 00000040H
  00d06	85 c0		 test	 eax, eax
  00d08	75 3e		 jne	 SHORT $LN134@z900_trap_
  00d0a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d12	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d18	d1 e8		 shr	 eax, 1
  00d1a	83 e0 01	 and	 eax, 1
  00d1d	85 c0		 test	 eax, eax
  00d1f	74 1a		 je	 SHORT $LN135@z900_trap_
  00d21	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d29	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d30	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00d34	83 e0 01	 and	 eax, 1
  00d37	85 c0		 test	 eax, eax
  00d39	75 0d		 jne	 SHORT $LN134@z900_trap_
$LN135@z900_trap_:
  00d3b	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv571[rsp], 0
  00d46	eb 0b		 jmp	 SHORT $LN136@z900_trap_
$LN134@z900_trap_:
  00d48	c7 84 24 98 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv571[rsp], 64 ; 00000040H
$LN136@z900_trap_:
  00d53	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv571[rsp]
  00d5a	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv556[rsp]
  00d61	0b c8		 or	 ecx, eax
  00d63	8b c1		 mov	 eax, ecx
  00d65	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d6d	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00d73	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d7b	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00d82	83 e0 0f	 and	 eax, 15
  00d85	89 44 24 5c	 mov	 DWORD PTR tv577[rsp], eax
  00d89	83 7c 24 5c 01	 cmp	 DWORD PTR tv577[rsp], 1
  00d8e	74 22		 je	 SHORT $LN83@z900_trap_
  00d90	83 7c 24 5c 02	 cmp	 DWORD PTR tv577[rsp], 2
  00d95	74 59		 je	 SHORT $LN84@z900_trap_
  00d97	83 7c 24 5c 03	 cmp	 DWORD PTR tv577[rsp], 3
  00d9c	0f 84 11 01 00
	00		 je	 $LN88@z900_trap_
  00da2	83 7c 24 5c 04	 cmp	 DWORD PTR tv577[rsp], 4
  00da7	0f 84 5d 01 00
	00		 je	 $LN89@z900_trap_
  00dad	e9 93 01 00 00	 jmp	 $LN90@z900_trap_
$LN83@z900_trap_:
  00db2	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00dba	eb 0a		 jmp	 SHORT $LN27@z900_trap_
$LN25@z900_trap_:
  00dbc	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00dc0	ff c0		 inc	 eax
  00dc2	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN27@z900_trap_:
  00dc6	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00dcb	7d 1e		 jge	 SHORT $LN26@z900_trap_
  00dcd	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00dd1	83 c0 05	 add	 eax, 5
  00dd4	48 98		 cdqe
  00dd6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dde	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00de9	eb d1		 jmp	 SHORT $LN25@z900_trap_
$LN26@z900_trap_:
  00deb	e9 8e 01 00 00	 jmp	 $LN23@z900_trap_
$LN84@z900_trap_:
  00df0	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00df8	eb 0a		 jmp	 SHORT $LN30@z900_trap_
$LN28@z900_trap_:
  00dfa	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00dfe	ff c0		 inc	 eax
  00e00	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN30@z900_trap_:
  00e04	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00e09	7d 1e		 jge	 SHORT $LN29@z900_trap_
  00e0b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00e0f	83 c0 05	 add	 eax, 5
  00e12	48 98		 cdqe
  00e14	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e1c	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00e27	eb d1		 jmp	 SHORT $LN28@z900_trap_
$LN29@z900_trap_:
  00e29	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00e31	eb 0a		 jmp	 SHORT $LN33@z900_trap_
$LN31@z900_trap_:
  00e33	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00e37	ff c0		 inc	 eax
  00e39	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN33@z900_trap_:
  00e3d	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00e42	7d 6a		 jge	 SHORT $LN32@z900_trap_
  00e44	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00e49	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e51	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00e59	75 1e		 jne	 SHORT $LN85@z900_trap_
  00e5b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00e5f	83 c0 05	 add	 eax, 5
  00e62	48 98		 cdqe
  00e64	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e6c	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00e77	eb 33		 jmp	 SHORT $LN86@z900_trap_
$LN85@z900_trap_:
  00e79	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00e7e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e86	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00e8e	74 1c		 je	 SHORT $LN87@z900_trap_
  00e90	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00e94	83 c0 05	 add	 eax, 5
  00e97	48 98		 cdqe
  00e99	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ea1	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN87@z900_trap_:
$LN86@z900_trap_:
  00eac	eb 85		 jmp	 SHORT $LN31@z900_trap_
$LN32@z900_trap_:
  00eae	e9 cb 00 00 00	 jmp	 $LN23@z900_trap_
$LN88@z900_trap_:
  00eb3	b8 04 00 00 00	 mov	 eax, 4
  00eb8	48 6b c0 04	 imul	 rax, rax, 4
  00ebc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec4	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00ecf	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00ed7	eb 0a		 jmp	 SHORT $LN36@z900_trap_
$LN34@z900_trap_:
  00ed9	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00edd	ff c0		 inc	 eax
  00edf	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN36@z900_trap_:
  00ee3	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00ee8	7d 1e		 jge	 SHORT $LN35@z900_trap_
  00eea	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00eee	83 c0 05	 add	 eax, 5
  00ef1	48 98		 cdqe
  00ef3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00efb	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00f06	eb d1		 jmp	 SHORT $LN34@z900_trap_
$LN35@z900_trap_:
  00f08	eb 74		 jmp	 SHORT $LN23@z900_trap_
$LN89@z900_trap_:
  00f0a	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00f12	eb 0a		 jmp	 SHORT $LN39@z900_trap_
$LN37@z900_trap_:
  00f14	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00f18	ff c0		 inc	 eax
  00f1a	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN39@z900_trap_:
  00f1e	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00f23	7d 1e		 jge	 SHORT $LN38@z900_trap_
  00f25	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00f29	83 c0 05	 add	 eax, 5
  00f2c	48 98		 cdqe
  00f2e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f36	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  00f41	eb d1		 jmp	 SHORT $LN37@z900_trap_
$LN38@z900_trap_:
  00f43	eb 39		 jmp	 SHORT $LN23@z900_trap_
$LN90@z900_trap_:
  00f45	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00f4d	eb 0a		 jmp	 SHORT $LN42@z900_trap_
$LN40@z900_trap_:
  00f4f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00f53	ff c0		 inc	 eax
  00f55	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN42@z900_trap_:
  00f59	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00f5e	7d 1e		 jge	 SHORT $LN41@z900_trap_
  00f60	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00f64	83 c0 05	 add	 eax, 5
  00f67	48 98		 cdqe
  00f69	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f71	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  00f7c	eb d1		 jmp	 SHORT $LN40@z900_trap_
$LN41@z900_trap_:
$LN23@z900_trap_:
  00f7e	b8 04 00 00 00	 mov	 eax, 4
  00f83	48 6b c0 04	 imul	 rax, rax, 4
  00f87	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f8f	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00f96	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00f9d	74 7c		 je	 SHORT $LN91@z900_trap_
$LN45@z900_trap_:
  00f9f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fa7	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00faf	74 64		 je	 SHORT $LN92@z900_trap_
  00fb1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fc1	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00fc8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00fcc	48 2b c1	 sub	 rax, rcx
  00fcf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd7	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00fde	48 03 c8	 add	 rcx, rax
  00fe1	48 8b c1	 mov	 rax, rcx
  00fe4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fec	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00ff3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ffb	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  01002	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0100a	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN92@z900_trap_:
  01015	33 c0		 xor	 eax, eax
  01017	85 c0		 test	 eax, eax
  01019	75 84		 jne	 SHORT $LN45@z900_trap_
$LN91@z900_trap_:
  0101b	0f b6 44 24 38	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  01020	83 e0 40	 and	 eax, 64			; 00000040H
  01023	85 c0		 test	 eax, eax
  01025	0f 85 f3 00 00
	00		 jne	 $LN93@z900_trap_
  0102b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01033	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0103a	83 e0 40	 and	 eax, 64			; 00000040H
  0103d	85 c0		 test	 eax, eax
  0103f	0f 84 d9 00 00
	00		 je	 $LN93@z900_trap_
$LN48@z900_trap_:
  01045	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0104d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  01055	74 64		 je	 SHORT $LN94@z900_trap_
  01057	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0105f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01067	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0106e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01072	48 2b c1	 sub	 rax, rcx
  01075	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0107d	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01084	48 03 c8	 add	 rcx, rax
  01087	48 8b c1	 mov	 rax, rcx
  0108a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01092	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01099	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010a1	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  010a8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010b0	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN94@z900_trap_:
  010bb	33 c0		 xor	 eax, eax
  010bd	85 c0		 test	 eax, eax
  010bf	75 84		 jne	 SHORT $LN48@z900_trap_
  010c1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  010cf	c1 e8 02	 shr	 eax, 2
  010d2	83 e0 01	 and	 eax, 1
  010d5	85 c0		 test	 eax, eax
  010d7	74 0d		 je	 SHORT $LN139@z900_trap_
  010d9	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv687[rsp], 1
  010e4	eb 0b		 jmp	 SHORT $LN140@z900_trap_
$LN139@z900_trap_:
  010e6	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv687[rsp], 0
$LN140@z900_trap_:
  010f1	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv687[rsp], 0
  010f9	74 23		 je	 SHORT $LN95@z900_trap_
  010fb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01103	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01106	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0110b	85 c0		 test	 eax, eax
  0110d	74 0f		 je	 SHORT $LN95@z900_trap_
  0110f	b2 fc		 mov	 dl, 252			; 000000fcH
  01111	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01119	e8 00 00 00 00	 call	 z900_invalidate_tlb
$LN95@z900_trap_:
$LN93@z900_trap_:
  0111e	33 c0		 xor	 eax, eax
  01120	85 c0		 test	 eax, eax
  01122	0f 85 00 fb ff
	ff		 jne	 $LN22@z900_trap_

; 349  : 
; 350  : } /* end function ARCH_DEP(trap_x) */

  01128	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01130	48 33 cc	 xor	 rcx, rsp
  01133	e8 00 00 00 00	 call	 __security_check_cookie
  01138	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0113f	5f		 pop	 rdi
  01140	c3		 ret	 0
z900_trap_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
vaddr$ = 64
regs$ = 72
acctype$ = 80
s390_abs_trap_addr PROC

; 127  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 128  :     return MADDR(vaddr, USE_HOME_SPACE, regs, acctype, regs->psw.pkey) - regs->mainstor;

  00012	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	8b 44 24 50	 mov	 eax, DWORD PTR acctype$[rsp]
  00023	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00027	4c 8b 4c 24 48	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00032	ba 01 00 00 00	 mov	 edx, 1
  00037	8b 4c 24 40	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0003b	e8 00 00 00 00	 call	 s390_maddr_l
  00040	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]

; 129  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
s390_abs_trap_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
vaddr$ = 64
regs$ = 72
acctype$ = 80
s390_abs_stack_addr PROC

; 121  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 122  :     return MADDR(vaddr, USE_HOME_SPACE, regs, acctype, 0) - regs->mainstor;

  00012	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00017	8b 44 24 50	 mov	 eax, DWORD PTR acctype$[rsp]
  0001b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001f	4c 8b 4c 24 48	 mov	 r9, QWORD PTR regs$[rsp]
  00024	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  0002a	ba 01 00 00 00	 mov	 edx, 1
  0002f	8b 4c 24 40	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00033	e8 00 00 00 00	 call	 s390_maddr_l
  00038	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]

; 123  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
s390_abs_stack_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s390_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_main_absolute
_TEXT	SEGMENT
tv128 = 48
addr$ = 80
regs$ = 88
s390_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 ca 00 00
	00		 je	 $LN5@s390_fetch
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	0f 85 b1 00 00
	00		 jne	 $LN5@s390_fetch
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0004b	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0004f	75 44		 jne	 SHORT $LN7@s390_fetch
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00056	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0005d	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  00062	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0006b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00070	41 b9 04 00 00
	00		 mov	 r9d, 4
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00082	ba fd ff ff ff	 mov	 edx, -3
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0008e	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00093	eb 43		 jmp	 SHORT $LN8@s390_fetch
$LN7@s390_fetch:
  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a1	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  000a6	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b4	41 b9 04 00 00
	00		 mov	 r9d, 4
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d3	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_fetch:
  000d8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e4	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000eb	48 89 44 24 50	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_fetch:
  000f0	33 c0		 xor	 eax, eax
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  000fa	b2 04		 mov	 dl, 4
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00101	e8 00 00 00 00	 call	 s390_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00112	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
s390_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
lsea$ = 48
lsep$ = 52
abs$ = 56
pkm$ = 64
sasn$ = 68
eax$ = 72
pasn$ = 76
tv175 = 80
tv213 = 84
tv224 = 88
tv242 = 92
tv253 = 96
tv259 = 100
tv276 = 104
tv281 = 108
permode$ = 112
lsed$ = 120
newpsw$ = 128
__$ArrayPad$ = 144
regs$ = 176
lsedap$ = 184
rc$ = 192
s390_program_return_unstack PROC

; 1247 : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1248 : QWORD   newpsw;                         /* New PSW                   */
; 1249 : LSED    lsed;                           /* Linkage stack entry desc. */
; 1250 : VADR    lsea;                           /* Linkage stack entry addr  */
; 1251 : RADR    abs;                            /* Absolute address          */
; 1252 : int     permode;                        /* 1=PER mode is set in PSW  */
; 1253 : U16     pkm;                            /* PSW key mask              */
; 1254 : U16     sasn;                           /* Secondary ASN             */
; 1255 : U16     eax;                            /* Extended AX               */
; 1256 : U16     pasn;                           /* Primary ASN               */
; 1257 : VADR    lsep;                           /* Virtual addr of entry desc.
; 1258 :                                            of previous stack entry   */
; 1259 : 
; 1260 :     /* Find the virtual address of the entry descriptor
; 1261 :        of the current state entry in the linkage stack */
; 1262 :     lsea = ARCH_DEP(locate_stack_entry) (1, &lsed, regs);

  00028	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00030	48 8d 54 24 78	 lea	 rdx, QWORD PTR lsed$[rsp]
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	e8 00 00 00 00	 call	 s390_locate_stack_entry
  0003f	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1263 : 
; 1264 :     /* [5.12.4.3] Restore information from stack entry */
; 1265 : 
; 1266 :     /* Load registers 2-14 from the stack entry */
; 1267 :     ARCH_DEP(unstack_registers) (1, lsea, 2, 14, regs);

  00043	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00050	41 b9 0e 00 00
	00		 mov	 r9d, 14
  00056	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005c	8b 54 24 30	 mov	 edx, DWORD PTR lsea$[rsp]
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	e8 00 00 00 00	 call	 s390_unstack_registers

; 1268 : 
; 1269 :     /* Point back to the entry descriptor of previous stack entry */
; 1270 :     lsep = lsea - LSSE_SIZE;

  0006a	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  0006e	2d a8 00 00 00	 sub	 eax, 168		; 000000a8H
  00073	89 44 24 34	 mov	 DWORD PTR lsep$[rsp], eax

; 1271 :     LSEA_WRAP(lsep);

  00077	8b 44 24 34	 mov	 eax, DWORD PTR lsep$[rsp]
  0007b	0f ba f0 1f	 btr	 eax, 31
  0007f	89 44 24 34	 mov	 DWORD PTR lsep$[rsp], eax

; 1272 : 
; 1273 :     /* Point back to byte 128 of the current state entry */
; 1274 :     lsea -= LSSE_SIZE - sizeof(LSED);

  00083	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  00087	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  0008d	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1275 :     lsea += 128;

  00091	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  00095	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0009a	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1276 :     LSEA_WRAP(lsea);

  0009e	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  000a2	0f ba f0 1f	 btr	 eax, 31
  000a6	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1277 : 
; 1278 :     /* Translate virtual address to absolute address */
; 1279 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  000aa	41 b8 04 00 00
	00		 mov	 r8d, 4
  000b0	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	8b 4c 24 30	 mov	 ecx, DWORD PTR lsea$[rsp]
  000bc	e8 00 00 00 00	 call	 s390_abs_stack_addr
  000c1	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1280 : 
; 1281 :     /* For a call state entry, replace the PKM, SASN, EAX, and PASN */
; 1282 :     if ((lsed.uet & LSED_UET_ET) == LSED_UET_PC)

  000c6	0f b6 44 24 78	 movzx	 eax, BYTE PTR lsed$[rsp]
  000cb	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ce	83 f8 05	 cmp	 eax, 5
  000d1	0f 85 2b 01 00
	00		 jne	 $LN8@s390_progr

; 1283 :     {
; 1284 :         /* Fetch the PKM from bytes 128-129 of the stack entry */
; 1285 :         FETCH_HW(pkm,regs->mainstor + abs);

  000d7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000e6	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f3	0f b7 c8	 movzx	 ecx, ax
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	66 89 44 24 40	 mov	 WORD PTR pkm$[rsp], ax

; 1286 : 
; 1287 :         /* Fetch the SASN from bytes 130-131 of the stack entry */
; 1288 :         FETCH_HW(sasn,regs->mainstor + abs + 2);

  00100	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00108	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0010f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00114	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00121	0f b7 c8	 movzx	 ecx, ax
  00124	e8 00 00 00 00	 call	 _byteswap_ushort
  00129	66 89 44 24 44	 mov	 WORD PTR sasn$[rsp], ax

; 1289 : 
; 1290 :         /* Fetch the EAX from bytes 132-133 of the stack entry */
; 1291 :         FETCH_HW(eax,regs->mainstor + abs + 4);

  0012e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0013d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00142	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00147	48 8b c8	 mov	 rcx, rax
  0014a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0014f	0f b7 c8	 movzx	 ecx, ax
  00152	e8 00 00 00 00	 call	 _byteswap_ushort
  00157	66 89 44 24 48	 mov	 WORD PTR eax$[rsp], ax

; 1292 : 
; 1293 :         /* Fetch the PASN from bytes 134-135 of the stack entry */
; 1294 :         FETCH_HW(pasn,regs->mainstor + abs + 6);

  0015c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00164	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0016b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00170	48 8d 44 08 06	 lea	 rax, QWORD PTR [rax+rcx+6]
  00175	48 8b c8	 mov	 rcx, rax
  00178	e8 00 00 00 00	 call	 fetch_hw_noswap
  0017d	0f b7 c8	 movzx	 ecx, ax
  00180	e8 00 00 00 00	 call	 _byteswap_ushort
  00185	66 89 44 24 4c	 mov	 WORD PTR pasn$[rsp], ax

; 1295 : 
; 1296 :       #ifdef STACK_DEBUG
; 1297 :         logmsg (_("stack: PKM=%2.2X%2.2X SASN=%2.2X%2.2X "
; 1298 :                 "EAX=%2.2X%2.2X PASN=%2.2X%2.2X \n"
; 1299 :                 "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1300 :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 1301 :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1302 :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1303 :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1304 :                 lsea, abs);
; 1305 :       #endif /*STACK_DEBUG*/
; 1306 : 
; 1307 :         /* Load PKM into CR3 bits 0-15 (32-47) */
; 1308 :         regs->CR_LHH(3) = pkm;

  0018a	b8 08 00 00 00	 mov	 eax, 8
  0018f	48 6b c0 04	 imul	 rax, rax, 4
  00193	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	0f b7 54 24 40	 movzx	 edx, WORD PTR pkm$[rsp]
  001a0	66 89 94 01 02
	06 00 00	 mov	 WORD PTR [rcx+rax+1538], dx

; 1309 : 
; 1310 :         /* Load SASN into CR3 bits 16-31 (48-63) */
; 1311 :         regs->CR_LHL(3) = sasn;

  001a8	b8 08 00 00 00	 mov	 eax, 8
  001ad	48 6b c0 04	 imul	 rax, rax, 4
  001b1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	0f b7 54 24 44	 movzx	 edx, WORD PTR sasn$[rsp]
  001be	66 89 94 01 00
	06 00 00	 mov	 WORD PTR [rcx+rax+1536], dx

; 1312 : 
; 1313 :         /* Load EAX into CR8 bits 0-15 (32-47) */
; 1314 :         regs->CR_LHH(8) = eax;

  001c6	b8 08 00 00 00	 mov	 eax, 8
  001cb	48 6b c0 09	 imul	 rax, rax, 9
  001cf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	0f b7 54 24 48	 movzx	 edx, WORD PTR eax$[rsp]
  001dc	66 89 94 01 02
	06 00 00	 mov	 WORD PTR [rcx+rax+1538], dx

; 1315 : 
; 1316 :         /* Load PASN into CR4 bits 16-31 (48-63) */
; 1317 :         regs->CR_LHL(4) = pasn;

  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 05	 imul	 rax, rax, 5
  001ed	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f5	0f b7 54 24 4c	 movzx	 edx, WORD PTR pasn$[rsp]
  001fa	66 89 94 01 00
	06 00 00	 mov	 WORD PTR [rcx+rax+1536], dx
$LN8@s390_progr:

; 1318 : 
; 1319 :     } /* end if(LSED_UET_PC) */
; 1320 : 
; 1321 :     /* Update virtual and absolute addresses to point to byte 136 */
; 1322 :     lsea += 8;

  00202	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  00206	83 c0 08	 add	 eax, 8
  00209	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1323 :     LSEA_WRAP(lsea);

  0020d	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  00211	0f ba f0 1f	 btr	 eax, 31
  00215	89 44 24 30	 mov	 DWORD PTR lsea$[rsp], eax

; 1324 :     abs += 8;

  00219	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  0021e	48 83 c0 08	 add	 rax, 8
  00222	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 1325 : 
; 1326 :     /* Recalculate absolute address if page boundary crossed */
; 1327 :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00227	8b 44 24 30	 mov	 eax, DWORD PTR lsea$[rsp]
  0022b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00230	85 c0		 test	 eax, eax
  00232	75 1c		 jne	 SHORT $LN9@s390_progr

; 1328 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00234	41 b8 04 00 00
	00		 mov	 r8d, 4
  0023a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00242	8b 4c 24 30	 mov	 ecx, DWORD PTR lsea$[rsp]
  00246	e8 00 00 00 00	 call	 s390_abs_stack_addr
  0024b	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax
$LN9@s390_progr:

; 1329 : 
; 1330 :     /* Save the PER mode bit from the current PSW */
; 1331 :     permode = (regs->psw.sysmask & PSW_PERMODE) ? 1 : 0;

  00250	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00258	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0025c	83 e0 40	 and	 eax, 64			; 00000040H
  0025f	85 c0		 test	 eax, eax
  00261	74 0a		 je	 SHORT $LN15@s390_progr
  00263	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  0026b	eb 08		 jmp	 SHORT $LN16@s390_progr
$LN15@s390_progr:
  0026d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN16@s390_progr:
  00275	8b 44 24 50	 mov	 eax, DWORD PTR tv175[rsp]
  00279	89 44 24 70	 mov	 DWORD PTR permode$[rsp], eax

; 1332 : 
; 1333 :   #ifdef STACK_DEBUG
; 1334 :     logmsg (_("stack: PSW=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 1335 :             "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1336 :             regs->mainstor[abs], regs->mainstor[abs+1],
; 1337 :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1338 :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1339 :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1340 :             lsea, abs);
; 1341 :   #endif /*STACK_DEBUG*/
; 1342 : 
; 1343 :     /* Copy PSW bits 0-63 from bytes 136-143 of the stack entry */
; 1344 :     memcpy (newpsw, regs->mainstor + abs, 8);

  0027d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00285	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0028c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  00291	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00295	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR newpsw$[rsp], rax

; 1345 : 
; 1346 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1347 :     /* For ESAME, advance to byte 168 of the stack entry */
; 1348 :     lsea += 32;
; 1349 :     LSEA_WRAP(lsea);
; 1350 :     abs += 32;
; 1351 : 
; 1352 :     /* Recalculate absolute address if page boundary crossed */
; 1353 :     if ((lsea & PAGEFRAME_BYTEMASK) < 32)
; 1354 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);
; 1355 : 
; 1356 :     /* Copy ESAME PSW bits 64-127 from bytes 168-175 */
; 1357 :     memcpy (newpsw + 8, regs->mainstor + abs, 8);
; 1358 : 
; 1359 :     /* Update virtual and absolute addresses to point to byte 176 */
; 1360 :     lsea += 8;
; 1361 :     LSEA_WRAP(lsea);
; 1362 :     abs += 8;
; 1363 : 
; 1364 :     /* Recalculate absolute address if page boundary crossed */
; 1365 :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)
; 1366 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);
; 1367 : 
; 1368 :     /* For a call state entry only, if ASN-and-LX-reuse is installed and
; 1369 :        active, load the SASTEIN (high word of CR3) from bytes 176-179,
; 1370 :        and load the PASTEIN (high word of CR4) from bytes 180-183 */
; 1371 :     if ((lsed.uet & LSED_UET_ET) == LSED_UET_PC
; 1372 :         && ASN_AND_LX_REUSE_ENABLED(regs))
; 1373 :     {
; 1374 :         FETCH_FW(regs->CR_H(3), regs->mainstor + abs);
; 1375 :         FETCH_FW(regs->CR_H(4), regs->mainstor + abs + 4);
; 1376 : 
; 1377 :       #ifdef STACK_DEBUG
; 1378 :         logmsg (_("stack: SASTEIN=%2.2X%2.2X%2.2X%2.2X "
; 1379 :                 "PASTEIN=%2.2X%2.2X%2.2X%2.2X \n"
; 1380 :                 "loaded from V:" F_VADR " A:" F_RADR "\n"),
; 1381 :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 1382 :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 1383 :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 1384 :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 1385 :                 lsea, abs);
; 1386 :       #endif /*STACK_DEBUG*/
; 1387 : 
; 1388 :     } /* end if(LSED_UET_PC && ASN_AND_LX_REUSE_ENABLED) */
; 1389 : 
; 1390 : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1391 : 
; 1392 :     /* [5.12.4.4] Pass back the absolute address of the entry
; 1393 :        descriptor of the preceding linkage stack entry.  The
; 1394 :        next entry size field of this entry will be cleared on
; 1395 :        successful completion of the PR instruction */
; 1396 :     *lsedap = ARCH_DEP(abs_stack_addr) (lsep, regs, ACCTYPE_WRITE);

  0029d	41 b8 02 00 00
	00		 mov	 r8d, 2
  002a3	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ab	8b 4c 24 34	 mov	 ecx, DWORD PTR lsep$[rsp]
  002af	e8 00 00 00 00	 call	 s390_abs_stack_addr
  002b4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR lsedap$[rsp]
  002bc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1397 : 
; 1398 :     /* [5.12.4.5] Update CR15 to point to the previous entry */
; 1399 :     regs->CR(15) = lsep & CR15_LSEA;

  002bf	8b 44 24 34	 mov	 eax, DWORD PTR lsep$[rsp]
  002c3	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  002c8	b9 08 00 00 00	 mov	 ecx, 8
  002cd	48 6b c9 10	 imul	 rcx, rcx, 16
  002d1	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d9	89 84 0a 00 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1536], eax

; 1400 : 
; 1401 :     /* Load new PSW using the bytes extracted from the stack entry */
; 1402 :     /* The rc will be checked by calling routine for PIC 06        */
; 1403 :     *rc = ARCH_DEP(load_psw) (regs, newpsw);

  002e0	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR newpsw$[rsp]
  002e8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	e8 00 00 00 00	 call	 s390_load_psw
  002f5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR rc$[rsp]
  002fd	89 01		 mov	 DWORD PTR [rcx], eax

; 1404 : 
; 1405 :     /* Restore the PER mode bit from the current PSW */
; 1406 :     if (permode)

  002ff	83 7c 24 70 00	 cmp	 DWORD PTR permode$[rsp], 0
  00304	74 1c		 je	 SHORT $LN10@s390_progr

; 1407 :         regs->psw.sysmask |= PSW_PERMODE;

  00306	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00312	83 c8 40	 or	 eax, 64			; 00000040H
  00315	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031d	88 41 78	 mov	 BYTE PTR [rcx+120], al
  00320	eb 1a		 jmp	 SHORT $LN11@s390_progr
$LN10@s390_progr:

; 1408 :     else
; 1409 :         regs->psw.sysmask &= ~PSW_PERMODE;

  00322	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0032e	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00331	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	88 41 78	 mov	 BYTE PTR [rcx+120], al
$LN11@s390_progr:
$LN4@s390_progr:

; 1410 : 
; 1411 :     /* restore PER masks which could have been wiped out by load_psw */
; 1412 :     SET_IC_MASK(regs);

  0033c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00344	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00348	83 e0 02	 and	 eax, 2
  0034b	85 c0		 test	 eax, eax
  0034d	74 0a		 je	 SHORT $LN17@s390_progr
  0034f	c7 44 24 54 00
	00 00 40	 mov	 DWORD PTR tv213[rsp], 1073741824 ; 40000000H
  00357	eb 08		 jmp	 SHORT $LN18@s390_progr
$LN17@s390_progr:
  00359	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
$LN18@s390_progr:
  00361	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0036d	83 e0 04	 and	 eax, 4
  00370	85 c0		 test	 eax, eax
  00372	74 23		 je	 SHORT $LN19@s390_progr
  00374	b8 08 00 00 00	 mov	 eax, 8
  00379	48 6b c0 0f	 imul	 rax, rax, 15
  0037d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00385	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0038c	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00391	89 44 24 58	 mov	 DWORD PTR tv224[rsp], eax
  00395	eb 08		 jmp	 SHORT $LN20@s390_progr
$LN19@s390_progr:
  00397	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv224[rsp], 0
$LN20@s390_progr:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	75 4e		 jne	 SHORT $LN21@s390_progr
  003a5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ad	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  003b1	83 e0 40	 and	 eax, 64			; 00000040H
  003b4	85 c0		 test	 eax, eax
  003b6	75 3b		 jne	 SHORT $LN21@s390_progr
  003b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003c6	d1 e8		 shr	 eax, 1
  003c8	83 e0 01	 and	 eax, 1
  003cb	85 c0		 test	 eax, eax
  003cd	74 1a		 je	 SHORT $LN22@s390_progr
  003cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003de	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  003e2	83 e0 01	 and	 eax, 1
  003e5	85 c0		 test	 eax, eax
  003e7	75 0a		 jne	 SHORT $LN21@s390_progr
$LN22@s390_progr:
  003e9	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv242[rsp], 0
  003f1	eb 14		 jmp	 SHORT $LN23@s390_progr
$LN21@s390_progr:
  003f3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fb	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  003fe	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00403	89 44 24 5c	 mov	 DWORD PTR tv242[rsp], eax
$LN23@s390_progr:
  00407	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00413	83 e0 01	 and	 eax, 1
  00416	85 c0		 test	 eax, eax
  00418	74 23		 je	 SHORT $LN24@s390_progr
  0041a	b8 08 00 00 00	 mov	 eax, 8
  0041f	48 6b c0 01	 imul	 rax, rax, 1
  00423	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042b	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00432	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  00437	89 44 24 60	 mov	 DWORD PTR tv253[rsp], eax
  0043b	eb 08		 jmp	 SHORT $LN25@s390_progr
$LN24@s390_progr:
  0043d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN25@s390_progr:
  00445	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00451	83 e0 02	 and	 eax, 2
  00454	85 c0		 test	 eax, eax
  00456	74 0a		 je	 SHORT $LN26@s390_progr
  00458	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv259[rsp], 1
  00460	eb 08		 jmp	 SHORT $LN27@s390_progr
$LN26@s390_progr:
  00462	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv259[rsp], 0
$LN27@s390_progr:
  0046a	8b 44 24 54	 mov	 eax, DWORD PTR tv213[rsp]
  0046e	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  00473	0b 44 24 58	 or	 eax, DWORD PTR tv224[rsp]
  00477	0b 44 24 5c	 or	 eax, DWORD PTR tv242[rsp]
  0047b	0b 44 24 60	 or	 eax, DWORD PTR tv253[rsp]
  0047f	0b 44 24 64	 or	 eax, DWORD PTR tv259[rsp]
  00483	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048b	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0048e	33 c0		 xor	 eax, eax
  00490	85 c0		 test	 eax, eax
  00492	75 4e		 jne	 SHORT $LN28@s390_progr
  00494	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0049c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004a0	83 e0 40	 and	 eax, 64			; 00000040H
  004a3	85 c0		 test	 eax, eax
  004a5	75 3b		 jne	 SHORT $LN28@s390_progr
  004a7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004af	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004b5	d1 e8		 shr	 eax, 1
  004b7	83 e0 01	 and	 eax, 1
  004ba	85 c0		 test	 eax, eax
  004bc	74 1a		 je	 SHORT $LN29@s390_progr
  004be	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004cd	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  004d1	83 e0 01	 and	 eax, 1
  004d4	85 c0		 test	 eax, eax
  004d6	75 0a		 jne	 SHORT $LN28@s390_progr
$LN29@s390_progr:
  004d8	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv276[rsp], 0
  004e0	eb 08		 jmp	 SHORT $LN30@s390_progr
$LN28@s390_progr:
  004e2	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
$LN30@s390_progr:
  004ea	8b 44 24 68	 mov	 eax, DWORD PTR tv276[rsp]
  004ee	83 e0 01	 and	 eax, 1
  004f1	c1 e0 02	 shl	 eax, 2
  004f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004fc	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00502	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00505	0b c8		 or	 ecx, eax
  00507	89 4c 24 6c	 mov	 DWORD PTR tv281[rsp], ecx
  0050b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00513	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv281[rsp]
  00517	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  0051d	8b 44 24 6c	 mov	 eax, DWORD PTR tv281[rsp]
  00521	c1 e8 02	 shr	 eax, 2
  00524	83 e0 01	 and	 eax, 1
  00527	85 c0		 test	 eax, eax
  00529	74 79		 je	 SHORT $LN12@s390_progr
$LN7@s390_progr:
  0052b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00533	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0053b	74 61		 je	 SHORT $LN13@s390_progr
  0053d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00545	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0054b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00553	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0055b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00562	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00566	48 2b ca	 sub	 rcx, rdx
  00569	48 03 c1	 add	 rax, rcx
  0056c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00574	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0057a	48 23 c1	 and	 rax, rcx
  0057d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00585	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0058b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00593	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN13@s390_progr:
  0059e	33 c0		 xor	 eax, eax
  005a0	85 c0		 test	 eax, eax
  005a2	75 87		 jne	 SHORT $LN7@s390_progr
$LN12@s390_progr:
  005a4	33 c0		 xor	 eax, eax
  005a6	85 c0		 test	 eax, eax
  005a8	0f 85 8e fd ff
	ff		 jne	 $LN4@s390_progr

; 1413 : 
; 1414 : #ifdef STACK_DEBUG
; 1415 :     LOGMSG( "stack: CR15=" F_CREG "\n", regs->CR( 15 ));
; 1416 : #endif /*STACK_DEBUG*/
; 1417 : 
; 1418 :     /* Return the entry type of the unstacked state entry */
; 1419 :     return (lsed.uet & LSED_UET_ET);

  005ae	0f b6 44 24 78	 movzx	 eax, BYTE PTR lsed$[rsp]
  005b3	83 e0 7f	 and	 eax, 127		; 0000007fH

; 1420 : 
; 1421 : } /* end function ARCH_DEP(program_return_unstack) */

  005b6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005be	48 33 cc	 xor	 rcx, rsp
  005c1	e8 00 00 00 00	 call	 __security_check_cookie
  005c6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005cd	c3		 ret	 0
s390_program_return_unstack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
i$ = 32
abs$ = 40
tv70 = 48
tv75 = 52
firstbyte$ = 56
lastbyte$ = 60
tv91 = 64
tv150 = 68
abs2$ = 72
gtype$ = 96
lsea$ = 104
r1$ = 112
r2$ = 120
regs$ = 128
s390_unstack_registers PROC

; 1103 : {

$LN39:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1104 : RADR    abs, abs2 = 0;                  /* Absolute address          */

  00016	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR abs2$[rsp], 0
$LN4@s390_unsta:

; 1105 : VADR    firstbyte,                      /* First byte to be fetched  */
; 1106 :         lastbyte;                       /* Last byte to be fetched   */
; 1107 : int     i;                              /* Array subscript           */
; 1108 : 
; 1109 :     UNREFERENCED(gtype);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN4@s390_unsta

; 1110 : 
; 1111 :     /* Point back to byte 0 of the state entry */
; 1112 :     lsea -= LSSE_SIZE - sizeof(LSED);

  00025	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  00029	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  0002f	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1113 :     LSEA_WRAP(lsea);

  00033	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  00037	0f ba f0 1f	 btr	 eax, 31
  0003b	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1114 : 
; 1115 :     /* Determine first and last byte to fetch from the state entry */
; 1116 :     firstbyte = lsea + ((r1 > r2) ? 0 : r1) * LSSE_REGSIZE;

  0003f	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00043	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00047	7e 0a		 jle	 SHORT $LN31@s390_unsta
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00051	eb 08		 jmp	 SHORT $LN32@s390_unsta
$LN31@s390_unsta:
  00053	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  00057	89 44 24 30	 mov	 DWORD PTR tv70[rsp], eax
$LN32@s390_unsta:
  0005b	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  0005f	8b 4c 24 30	 mov	 ecx, DWORD PTR tv70[rsp]
  00063	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  00066	89 44 24 38	 mov	 DWORD PTR firstbyte$[rsp], eax

; 1117 :     lastbyte = lsea + (LSSE_SIZE - 69) + (((r1 > r2) ? 15 : r2) * 4);

  0006a	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  0006e	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00072	7e 0a		 jle	 SHORT $LN33@s390_unsta
  00074	c7 44 24 34 0f
	00 00 00	 mov	 DWORD PTR tv75[rsp], 15
  0007c	eb 08		 jmp	 SHORT $LN34@s390_unsta
$LN33@s390_unsta:
  0007e	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00082	89 44 24 34	 mov	 DWORD PTR tv75[rsp], eax
$LN34@s390_unsta:
  00086	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  0008a	8b 4c 24 34	 mov	 ecx, DWORD PTR tv75[rsp]
  0008e	8d 44 88 63	 lea	 eax, DWORD PTR [rax+rcx*4+99]
  00092	89 44 24 3c	 mov	 DWORD PTR lastbyte$[rsp], eax

; 1118 : 
; 1119 :     lsea = firstbyte;

  00096	8b 44 24 38	 mov	 eax, DWORD PTR firstbyte$[rsp]
  0009a	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1120 : 
; 1121 :     /* Obtain absolute address of the state entry */
; 1122 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0009e	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ac	8b 4c 24 68	 mov	 ecx, DWORD PTR lsea$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_abs_stack_addr
  000b5	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1123 : 
; 1124 :     /* If the state entry crosses a page boundary, obtain the
; 1125 :        absolute address of the second page of the stack entry */
; 1126 :     if( (firstbyte & PAGEFRAME_PAGEMASK)
; 1127 :                                 != (lastbyte & PAGEFRAME_PAGEMASK))

  000ba	8b 44 24 38	 mov	 eax, DWORD PTR firstbyte$[rsp]
  000be	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  000c3	8b 4c 24 3c	 mov	 ecx, DWORD PTR lastbyte$[rsp]
  000c7	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  000cd	3b c1		 cmp	 eax, ecx
  000cf	74 23		 je	 SHORT $LN14@s390_unsta

; 1128 :         abs2 = ARCH_DEP(abs_stack_addr)

  000d1	8b 44 24 3c	 mov	 eax, DWORD PTR lastbyte$[rsp]
  000d5	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  000da	41 b8 04 00 00
	00		 mov	 r8d, 4
  000e0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000e8	8b c8		 mov	 ecx, eax
  000ea	e8 00 00 00 00	 call	 s390_abs_stack_addr
  000ef	48 89 44 24 48	 mov	 QWORD PTR abs2$[rsp], rax
$LN14@s390_unsta:

; 1129 :                  (lastbyte & PAGEFRAME_PAGEMASK, regs, ACCTYPE_READ);
; 1130 : 
; 1131 :   #ifdef STACK_DEBUG
; 1132 :     LOGMSG( "stack: Unstacking registers %d-%d from " F_VADR "\n",
; 1133 :             r1, r2, lsea );
; 1134 :   #endif /*STACK_DEBUG*/
; 1135 : 
; 1136 :     /* Load general registers from bytes 0-63 (for ESA/390), or
; 1137 :        bytes 0-127 (for ESAME) of the state entry */
; 1138 :     for (i = ((r1 > r2) ? 0 : r1); i <= 15; i++)

  000f4	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  000f8	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  000fc	7e 0a		 jle	 SHORT $LN35@s390_unsta
  000fe	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  00106	eb 08		 jmp	 SHORT $LN36@s390_unsta
$LN35@s390_unsta:
  00108	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0010c	89 44 24 40	 mov	 DWORD PTR tv91[rsp], eax
$LN36@s390_unsta:
  00110	8b 44 24 40	 mov	 eax, DWORD PTR tv91[rsp]
  00114	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00118	eb 0a		 jmp	 SHORT $LN7@s390_unsta
$LN5@s390_unsta:
  0011a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0011e	ff c0		 inc	 eax
  00120	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_unsta:
  00124	83 7c 24 20 0f	 cmp	 DWORD PTR i$[rsp], 15
  00129	0f 8f b4 00 00
	00		 jg	 $LN6@s390_unsta

; 1139 :     {
; 1140 :         /* Load the general register from the stack entry */
; 1141 :         if ((r1 <= r2 && i >= r1 && i <= r2)
; 1142 :             || (r1 > r2 && (i >= r1 || i <= r2)))

  0012f	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00133	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00137	7f 14		 jg	 SHORT $LN17@s390_unsta
  00139	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0013d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00141	7c 0a		 jl	 SHORT $LN17@s390_unsta
  00143	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00147	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0014b	7e 1e		 jle	 SHORT $LN16@s390_unsta
$LN17@s390_unsta:
  0014d	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00151	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00155	7e 4b		 jle	 SHORT $LN15@s390_unsta
  00157	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0015b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0015f	7d 0a		 jge	 SHORT $LN18@s390_unsta
  00161	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00165	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00169	7f 37		 jg	 SHORT $LN15@s390_unsta
$LN18@s390_unsta:
$LN16@s390_unsta:

; 1143 :         {
; 1144 :     #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1145 :             if (gtype)
; 1146 :             {
; 1147 :                 /* For ESAME PR and EREGG instructions,
; 1148 :                    load all 64 bits of the register */
; 1149 :                 FETCH_DW(regs->GR_G(i), regs->mainstor + abs);
; 1150 :             } else {
; 1151 :                 /* For ESAME EREG instruction, load bits 32-63 of
; 1152 :                    the register, and leave bits 0-31 unchanged */
; 1153 :                 FETCH_FW(regs->GR_L(i), regs->mainstor + abs + 4);
; 1154 :             }
; 1155 : 
; 1156 :           #ifdef STACK_DEBUG
; 1157 :             logmsg (_("stack: GPR%d=" F_GREG " loaded from V:" F_VADR
; 1158 :                     " A:" F_RADR "\n"), i, regs->GR(i), lsea, abs);
; 1159 :           #endif /*STACK_DEBUG*/
; 1160 :     #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1161 :             /* For ESA/390, load a 32-bit general register */
; 1162 :             FETCH_FW(regs->GR_L(i), regs->mainstor + abs);

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0017a	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  0017f	48 8b c8	 mov	 rcx, rax
  00182	e8 00 00 00 00	 call	 fetch_fw_noswap
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 _byteswap_ulong
  0018e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00193	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019b	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN15@s390_unsta:

; 1163 : 
; 1164 :           #ifdef STACK_DEBUG
; 1165 :             logmsg (_("stack: GPR%d=" F_GREG " loaded from V:" F_VADR
; 1166 :                     " A:" F_RADR "\n"), i, regs->GR(i), lsea, abs);
; 1167 :           #endif /*STACK_DEBUG*/
; 1168 :     #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1169 :         }
; 1170 : 
; 1171 :         /* Update the virtual and absolute addresses */
; 1172 :         lsea += LSSE_REGSIZE;

  001a2	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  001a6	83 c0 04	 add	 eax, 4
  001a9	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1173 :         LSEA_WRAP(lsea);

  001ad	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  001b1	0f ba f0 1f	 btr	 eax, 31
  001b5	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1174 :         abs += LSSE_REGSIZE;

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  001be	48 83 c0 04	 add	 rax, 4
  001c2	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1175 : 
; 1176 :         /* Recalculate absolute address if page boundary crossed */
; 1177 :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  001c7	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  001cb	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001d0	85 c0		 test	 eax, eax
  001d2	75 0a		 jne	 SHORT $LN19@s390_unsta

; 1178 :             abs = abs2;

  001d4	48 8b 44 24 48	 mov	 rax, QWORD PTR abs2$[rsp]
  001d9	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN19@s390_unsta:

; 1179 : 
; 1180 :     } /* end for(i) */

  001de	e9 37 ff ff ff	 jmp	 $LN5@s390_unsta
$LN6@s390_unsta:

; 1181 : 
; 1182 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1183 :     /* For ESAME, skip the next 96 bytes of the state entry */
; 1184 :     lsea += 96; abs += 96;
; 1185 : 
; 1186 :     /* Recalculate absolute address if page boundary crossed */
; 1187 :     if ((lsea & PAGEFRAME_BYTEMASK) < 96)
; 1188 :         abs = abs2 | (lsea & PAGEFRAME_BYTEMASK);
; 1189 : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1190 : 
; 1191 :     /* Load access registers from bytes 64-127 (for ESA/390), or
; 1192 :        bytes 224-280 (for ESAME) of the state entry */
; 1193 :     for (i = 0; i <= ((r1 > r2) ? 15 : r2); i++)

  001e3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001eb	eb 0a		 jmp	 SHORT $LN10@s390_unsta
$LN8@s390_unsta:
  001ed	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001f1	ff c0		 inc	 eax
  001f3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_unsta:
  001f7	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  001fb	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  001ff	7e 0a		 jle	 SHORT $LN37@s390_unsta
  00201	c7 44 24 44 0f
	00 00 00	 mov	 DWORD PTR tv150[rsp], 15
  00209	eb 08		 jmp	 SHORT $LN38@s390_unsta
$LN37@s390_unsta:
  0020b	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  0020f	89 44 24 44	 mov	 DWORD PTR tv150[rsp], eax
$LN38@s390_unsta:
  00213	8b 44 24 44	 mov	 eax, DWORD PTR tv150[rsp]
  00217	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0021b	0f 8f 6c 01 00
	00		 jg	 $LN9@s390_unsta

; 1194 :     {
; 1195 :         /* Load the access register from the stack entry */
; 1196 :         if ((r1 <= r2 && i >= r1 && i <= r2)
; 1197 :             || (r1 > r2 && (i >= r1 || i <= r2)))

  00221	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00225	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00229	7f 14		 jg	 SHORT $LN22@s390_unsta
  0022b	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0022f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00233	7c 0a		 jl	 SHORT $LN22@s390_unsta
  00235	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00239	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0023d	7e 26		 jle	 SHORT $LN21@s390_unsta
$LN22@s390_unsta:
  0023f	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  00243	39 44 24 70	 cmp	 DWORD PTR r1$[rsp], eax
  00247	0f 8e ff 00 00
	00		 jle	 $LN20@s390_unsta
  0024d	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  00251	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00255	7d 0e		 jge	 SHORT $LN23@s390_unsta
  00257	8b 44 24 78	 mov	 eax, DWORD PTR r2$[rsp]
  0025b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0025f	0f 8f e7 00 00
	00		 jg	 $LN20@s390_unsta
$LN23@s390_unsta:
$LN21@s390_unsta:

; 1198 :         {
; 1199 :             FETCH_FW(regs->AR(i),regs->mainstor + abs);

  00265	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00274	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  00279	48 8b c8	 mov	 rcx, rax
  0027c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00281	8b c8		 mov	 ecx, eax
  00283	e8 00 00 00 00	 call	 _byteswap_ulong
  00288	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0028d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00295	89 84 8a 00 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+768], eax
$LN13@s390_unsta:

; 1200 :             SET_AEA_AR(regs, i);

  0029c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002a8	83 f8 40	 cmp	 eax, 64			; 00000040H
  002ab	0f 85 91 00 00
	00		 jne	 $LN24@s390_unsta
  002b1	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002b6	0f 8e 86 00 00
	00		 jle	 $LN24@s390_unsta
  002bc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002c1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002d1	75 1e		 jne	 SHORT $LN25@s390_unsta
  002d3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002d7	83 c0 05	 add	 eax, 5
  002da	48 98		 cdqe
  002dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002ef	eb 51		 jmp	 SHORT $LN26@s390_unsta
$LN25@s390_unsta:
  002f1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00306	75 1e		 jne	 SHORT $LN27@s390_unsta
  00308	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0030c	83 c0 05	 add	 eax, 5
  0030f	48 98		 cdqe
  00311	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00324	eb 1c		 jmp	 SHORT $LN28@s390_unsta
$LN27@s390_unsta:
  00326	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0032a	83 c0 05	 add	 eax, 5
  0032d	48 98		 cdqe
  0032f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00337	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN28@s390_unsta:
$LN26@s390_unsta:
$LN24@s390_unsta:
  00342	33 c0		 xor	 eax, eax
  00344	85 c0		 test	 eax, eax
  00346	0f 85 50 ff ff
	ff		 jne	 $LN13@s390_unsta
$LN20@s390_unsta:

; 1201 : 
; 1202 :           #ifdef STACK_DEBUG
; 1203 :             logmsg (_("stack: AR%d=" F_AREG " loaded from V:" F_VADR
; 1204 :                     " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 1205 :           #endif /*STACK_DEBUG*/
; 1206 :         }
; 1207 : 
; 1208 :         /* Update the virtual and absolute addresses */
; 1209 :         lsea += 4;

  0034c	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  00350	83 c0 04	 add	 eax, 4
  00353	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1210 :         LSEA_WRAP(lsea);

  00357	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  0035b	0f ba f0 1f	 btr	 eax, 31
  0035f	89 44 24 68	 mov	 DWORD PTR lsea$[rsp], eax

; 1211 :         abs += 4;

  00363	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00368	48 83 c0 04	 add	 rax, 4
  0036c	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 1212 : 
; 1213 :         /* Recalculate absolute address if page boundary crossed */
; 1214 :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00371	8b 44 24 68	 mov	 eax, DWORD PTR lsea$[rsp]
  00375	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0037a	85 c0		 test	 eax, eax
  0037c	75 0a		 jne	 SHORT $LN29@s390_unsta

; 1215 :             abs = abs2;

  0037e	48 8b 44 24 48	 mov	 rax, QWORD PTR abs2$[rsp]
  00383	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN29@s390_unsta:

; 1216 : 
; 1217 :     } /* end for(i) */

  00388	e9 60 fe ff ff	 jmp	 $LN8@s390_unsta
$LN9@s390_unsta:

; 1218 : 
; 1219 : } /* end function ARCH_DEP(unstack_registers) */

  0038d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00391	c3		 ret	 0
s390_unstack_registers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
abs$ = 32
lsea$ = 64
r1$ = 72
code$ = 80
regs$ = 88
s390_stack_extract PROC

; 991  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 992  : RADR    abs;                            /* Absolute address          */
; 993  : 
; 994  :     /* Point back to byte 128 of the state entry */
; 995  :     lsea -= LSSE_SIZE - sizeof(LSED);

  00016	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  0001a	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  00020	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 996  :     lsea += 128;

  00024	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  00028	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0002d	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 997  : 
; 998  :   #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 999  :     /* For codes 1 and 4, extract bytes 136-143 and 168-175 */
; 1000 :     if (code == 1 || code == 4)
; 1001 :     {
; 1002 :         U64 psw1, psw2;
; 1003 : 
; 1004 :         /* Point to byte 136 of the state entry */
; 1005 :         lsea += 8;
; 1006 :         LSEA_WRAP(lsea);
; 1007 : 
; 1008 :         /* Load bits 0-63 of ESAME PSW from bytes 136-143 */
; 1009 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);
; 1010 :         FETCH_DW(psw1, regs->mainstor + abs);
; 1011 : 
; 1012 :         /* Point to byte 168 of the state entry */
; 1013 :         lsea += 32;
; 1014 :         abs += 32;
; 1015 : 
; 1016 :         /* Recalculate absolute address if page boundary crossed */
; 1017 :         if ((lsea & PAGEFRAME_BYTEMASK) < 32)
; 1018 :             abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);
; 1019 : 
; 1020 :         /* Load bits 64-127 of ESAME PSW from bytes 168-175 */
; 1021 :         FETCH_DW(psw2, regs->mainstor + abs);
; 1022 : 
; 1023 :         /* For code 4, return ESAME PSW in general register pair */
; 1024 :         if (code == 4)
; 1025 :         {
; 1026 :             regs->GR_G(r1) = psw1;
; 1027 :             regs->GR_G(r1+1) = psw2;
; 1028 :             return;
; 1029 :         }
; 1030 : 
; 1031 :         /* For code 1, convert ESAME PSW to ESA/390 format */
; 1032 :         regs->GR_L(r1) = (psw1 >> 32) | 0x00080000;
; 1033 :         regs->GR_L(r1+1) = (psw1 & 0x80000000)
; 1034 :                             | (psw2 & 0x7FFFFFFF);
; 1035 : 
; 1036 :         /* Set low-order bit of R1+1 if IA exceeds 31-bit address */
; 1037 :         if (psw2 > 0x7FFFFFFF)
; 1038 :             regs->GR_L(r1+1) |= 0x01;
; 1039 : 
; 1040 :         return;
; 1041 : 
; 1042 :     } /* if(code==1||code==4) */
; 1043 :   #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 1044 : 
; 1045 :   #if defined(FEATURE_006_ASN_LX_REUSE_FACILITY)
; 1046 :     /* For code 5, extract bytes 176-183 */
; 1047 :     if (code == 5)
; 1048 :     {
; 1049 :         /* Point to byte 176 of the state entry */
; 1050 :         lsea += 48;
; 1051 :         LSEA_WRAP(lsea);
; 1052 : 
; 1053 :         /* Load the SASTEIN, PASTEIN from bytes 176-179, 180-183*/
; 1054 :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);
; 1055 :         FETCH_FW(regs->GR_H(r1), regs->mainstor + abs);
; 1056 :         FETCH_FW(regs->GR_H(r1+1), regs->mainstor + abs + 4);
; 1057 : 
; 1058 :         return;
; 1059 : 
; 1060 :     } /* if(code==5) */
; 1061 :   #endif /*defined(FEATURE_006_ASN_LX_REUSE_FACILITY)*/
; 1062 : 
; 1063 :     /* For codes 0,2,3 in ESAME, and codes 0,1,2,3 in ESA/390 */
; 1064 :     /* Point to byte 128, 136, 144, or 152 depending on the code */
; 1065 :     lsea += code * 8;

  00031	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR code$[rsp]
  00039	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0003c	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 1066 :     LSEA_WRAP(lsea);

  00040	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  00044	0f ba f0 1f	 btr	 eax, 31
  00048	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 1067 : 
; 1068 :     /* Load the general register pair from the state entry */
; 1069 :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0004c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00052	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00057	8b 4c 24 40	 mov	 ecx, DWORD PTR lsea$[rsp]
  0005b	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00060	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 1070 :     FETCH_FW(regs->GR_L(r1), regs->mainstor + abs);

  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00071	48 03 44 24 20	 add	 rax, QWORD PTR abs$[rsp]
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 fetch_fw_noswap
  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 _byteswap_ulong
  00085	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0008a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0008f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1071 :     FETCH_FW(regs->GR_L(r1+1), regs->mainstor + abs + 4);

  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  000a7	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 fetch_fw_noswap
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 _byteswap_ulong
  000bb	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  000bf	ff c1		 inc	 ecx
  000c1	48 63 c9	 movsxd	 rcx, ecx
  000c4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000c9	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1072 : 
; 1073 : } /* end function ARCH_DEP(stack_extract) */

  000d0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d4	c3		 ret	 0
s390_stack_extract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
abs$ = 32
lsea$ = 64
m1$ = 72
m2$ = 80
regs$ = 88
s390_stack_modify PROC

; 941  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 942  : RADR    abs;                            /* Absolute address          */
; 943  : 
; 944  :     /* Point back to byte 152 of the state entry */
; 945  :     lsea -= LSSE_SIZE - sizeof(LSED);

  00016	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  0001a	48 2d a0 00 00
	00		 sub	 rax, 160		; 000000a0H
  00020	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 946  :     lsea += 152;

  00024	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  00028	05 98 00 00 00	 add	 eax, 152		; 00000098H
  0002d	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 947  :     LSEA_WRAP(lsea);

  00031	8b 44 24 40	 mov	 eax, DWORD PTR lsea$[rsp]
  00035	0f ba f0 1f	 btr	 eax, 31
  00039	89 44 24 40	 mov	 DWORD PTR lsea$[rsp], eax

; 948  : 
; 949  :     /* Store the modify values into the state entry */
; 950  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  0003d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00043	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00048	8b 4c 24 40	 mov	 ecx, DWORD PTR lsea$[rsp]
  0004c	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00051	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 951  :     STORE_FW(regs->mainstor + abs, m1);

  00056	8b 4c 24 48	 mov	 ecx, DWORD PTR m1$[rsp]
  0005a	e8 00 00 00 00	 call	 _byteswap_ulong
  0005f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0006b	48 03 4c 24 20	 add	 rcx, QWORD PTR abs$[rsp]
  00070	8b d0		 mov	 edx, eax
  00072	e8 00 00 00 00	 call	 store_fw_noswap

; 952  :     STORE_FW(regs->mainstor + abs + 4, m2);

  00077	8b 4c 24 50	 mov	 ecx, DWORD PTR m2$[rsp]
  0007b	e8 00 00 00 00	 call	 _byteswap_ulong
  00080	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0008c	48 8b 54 24 20	 mov	 rdx, QWORD PTR abs$[rsp]
  00091	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00096	8b d0		 mov	 edx, eax
  00098	e8 00 00 00 00	 call	 store_fw_noswap

; 953  : 
; 954  : } /* end function ARCH_DEP(stack_modify) */

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
s390_stack_modify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
lsea$ = 32
bsea$ = 36
abs$ = 40
prinst$ = 64
lsedptr$ = 72
regs$ = 80
s390_locate_stack_entry PROC

; 827  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 828  : VADR    lsea;                           /* Linkage stack entry addr  */
; 829  : RADR    abs;                            /* Absolute address          */
; 830  : VADR    bsea;                           /* Backward stack entry addr */
; 831  : 
; 832  :     /* [5.12.4] Special operation exception if ASF is not enabled,
; 833  :        or if DAT is off, or if in secondary-space mode */
; 834  :     if (!ASF_ENABLED(regs)
; 835  :         || REAL_MODE(&regs->psw)
; 836  :         || SECONDARY_SPACE_MODE(&regs->psw))

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	48 6b c0 01	 imul	 rax, rax, 1
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00020	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00027	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002c	85 c0		 test	 eax, eax
  0002e	74 20		 je	 SHORT $LN3@s390_locat
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00035	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00039	83 e0 04	 and	 eax, 4
  0003c	85 c0		 test	 eax, eax
  0003e	74 10		 je	 SHORT $LN3@s390_locat
  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00049	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0004e	75 0f		 jne	 SHORT $LN2@s390_locat
$LN3@s390_locat:

; 837  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  00050	ba 13 00 00 00	 mov	 edx, 19
  00055	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	e8 00 00 00 00	 call	 s390_program_interrupt
$LN2@s390_locat:

; 838  : 
; 839  :     /* Special operation exception if home space mode PR instruction */
; 840  :     if (prinst && HOME_SPACE_MODE(&regs->psw))

  0005f	83 7c 24 40 00	 cmp	 DWORD PTR prinst$[rsp], 0
  00064	74 1f		 je	 SHORT $LN4@s390_locat
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0006f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00074	75 0f		 jne	 SHORT $LN4@s390_locat

; 841  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  00076	ba 13 00 00 00	 mov	 edx, 19
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	e8 00 00 00 00	 call	 s390_program_interrupt
$LN4@s390_locat:

; 842  : 
; 843  :     /* [5.12.4.1] Locate current entry and process header entry */
; 844  : 
; 845  :     /* Obtain the virtual address of the current entry from CR15 */
; 846  :     lsea = regs->CR(15) & CR15_LSEA;

  00085	b8 08 00 00 00	 mov	 eax, 8
  0008a	48 6b c0 10	 imul	 rax, rax, 16
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0009a	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  0009f	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 847  : 
; 848  :     /* Fetch the entry descriptor of the current entry */
; 849  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  000a3	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  000ae	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  000b2	e8 00 00 00 00	 call	 s390_abs_stack_addr
  000b7	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 850  :     memcpy (lsedptr, regs->mainstor+abs, sizeof(LSED));

  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lsedptr$[rsp]
  000cd	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  000d2	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  000d6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 851  : 
; 852  : #ifdef STACK_DEBUG
; 853  :     LOGMSG( "stack: Stack entry located at " F_VADR "\n", lsea );
; 854  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 855  :             lsedptr->uet, lsedptr->si, lsedptr->rfs[0],
; 856  :             lsedptr->rfs[1], lsedptr->nes[0], lsedptr->nes[1] );
; 857  : #endif /*STACK_DEBUG*/
; 858  : 
; 859  :     /* Check for a header entry */
; 860  :     if ((lsedptr->uet & LSED_UET_ET) == LSED_UET_HDR)

  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  000de	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e1	83 e0 7f	 and	 eax, 127		; 0000007fH
  000e4	83 f8 01	 cmp	 eax, 1
  000e7	0f 85 fe 00 00
	00		 jne	 $LN5@s390_locat

; 861  :     {
; 862  :         /* For PR instruction only, generate stack operation exception
; 863  :            if the unstack suppression bit in the header entry is set */
; 864  :         if (prinst && (lsedptr->uet & LSED_UET_U))

  000ed	83 7c 24 40 00	 cmp	 DWORD PTR prinst$[rsp], 0
  000f2	74 20		 je	 SHORT $LN6@s390_locat
  000f4	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  000f9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00101	85 c0		 test	 eax, eax
  00103	74 0f		 je	 SHORT $LN6@s390_locat

; 865  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_OPERATION_EXCEPTION);

  00105	ba 34 00 00 00	 mov	 edx, 52			; 00000034H
  0010a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN6@s390_locat:

; 866  : 
; 867  :         /* Calculate the virtual address of the header entry,
; 868  :            which is 8 bytes before the entry descriptor */
; 869  :         lsea -= 8;

  00114	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00118	83 e8 08	 sub	 eax, 8
  0011b	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 870  :         LSEA_WRAP(lsea);

  0011f	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00123	0f ba f0 1f	 btr	 eax, 31
  00127	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 871  : 
; 872  :         /* Fetch the backward stack entry address from the header */
; 873  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0012b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00131	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00136	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  0013a	e8 00 00 00 00	 call	 s390_abs_stack_addr
  0013f	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 874  :         FETCH_BSEA(bsea,regs->mainstor + abs);

  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00150	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abs$[rsp]
  00155	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00162	8b c8		 mov	 ecx, eax
  00164	e8 00 00 00 00	 call	 _byteswap_ulong
  00169	89 44 24 24	 mov	 DWORD PTR bsea$[rsp], eax

; 875  : 
; 876  : #ifdef STACK_DEBUG
; 877  :         LOGMSG( "stack: Stack entry located at " F_VADR "\n", bsea );
; 878  : #endif /*STACK_DEBUG*/
; 879  : 
; 880  :         /* Stack empty exception if backward address is not valid */
; 881  :         if ((bsea & LSHE_BVALID) == 0)

  0016d	8b 44 24 24	 mov	 eax, DWORD PTR bsea$[rsp]
  00171	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00176	85 c0		 test	 eax, eax
  00178	75 0f		 jne	 SHORT $LN7@s390_locat

; 882  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_EMPTY_EXCEPTION);

  0017a	ba 31 00 00 00	 mov	 edx, 49			; 00000031H
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_locat:

; 883  : 
; 884  :         /* Extract the virtual address of the entry descriptor
; 885  :            of the last entry in the previous section */
; 886  :         lsea = bsea & LSHE_BSEA;

  00189	8b 44 24 24	 mov	 eax, DWORD PTR bsea$[rsp]
  0018d	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00192	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 887  : 
; 888  :         /* Fetch the entry descriptor of the designated entry */
; 889  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00196	41 b8 04 00 00
	00		 mov	 r8d, 4
  0019c	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  001a1	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  001a5	e8 00 00 00 00	 call	 s390_abs_stack_addr
  001aa	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 890  :         memcpy (lsedptr, regs->mainstor+abs, sizeof(LSED));

  001af	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001b4	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001bb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lsedptr$[rsp]
  001c0	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  001c5	48 8b 04 10	 mov	 rax, QWORD PTR [rax+rdx]
  001c9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 891  : 
; 892  : #ifdef STACK_DEBUG
; 893  :         logmsg (_("stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X "
; 894  :                 "nes=%2.2X%2.2X\n"),
; 895  :                 lsedptr->uet, lsedptr->si, lsedptr->rfs[0],
; 896  :                 lsedptr->rfs[1], lsedptr->nes[0], lsedptr->nes[1]);
; 897  : #endif /*STACK_DEBUG*/
; 898  : 
; 899  :         /* Stack specification exception if this is also a header */
; 900  :         if ((lsedptr->uet & LSED_UET_ET) == LSED_UET_HDR)

  001cc	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  001d1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d4	83 e0 7f	 and	 eax, 127		; 0000007fH
  001d7	83 f8 01	 cmp	 eax, 1
  001da	75 0f		 jne	 SHORT $LN8@s390_locat

; 901  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  001dc	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  001e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	e8 00 00 00 00	 call	 s390_program_interrupt
$LN8@s390_locat:
$LN5@s390_locat:

; 902  : 
; 903  :     } /* end if(LSED_UET_HDR) */
; 904  : 
; 905  :     /* [5.12.4.2] Check for a state entry */
; 906  : 
; 907  :     /* Stack type exception if this is not a state entry */
; 908  :     if ((lsedptr->uet & LSED_UET_ET) != LSED_UET_BAKR
; 909  :         && (lsedptr->uet & LSED_UET_ET) != LSED_UET_PC)

  001eb	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  001f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  001f6	83 f8 04	 cmp	 eax, 4
  001f9	74 1f		 je	 SHORT $LN9@s390_locat
  001fb	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  00200	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00203	83 e0 7f	 and	 eax, 127		; 0000007fH
  00206	83 f8 05	 cmp	 eax, 5
  00209	74 0f		 je	 SHORT $LN9@s390_locat

; 910  :         ARCH_DEP(program_interrupt) (regs, PGM_STACK_TYPE_EXCEPTION);

  0020b	ba 33 00 00 00	 mov	 edx, 51			; 00000033H
  00210	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	e8 00 00 00 00	 call	 s390_program_interrupt
$LN9@s390_locat:

; 911  : 
; 912  :     /* [5.12.4.3] For PR instruction only, stack operation exception
; 913  :        if the unstack suppression bit in the state entry is set */
; 914  :     if (prinst && (lsedptr->uet & LSED_UET_U))

  0021a	83 7c 24 40 00	 cmp	 DWORD PTR prinst$[rsp], 0
  0021f	74 20		 je	 SHORT $LN10@s390_locat
  00221	48 8b 44 24 48	 mov	 rax, QWORD PTR lsedptr$[rsp]
  00226	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00229	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0022e	85 c0		 test	 eax, eax
  00230	74 0f		 je	 SHORT $LN10@s390_locat

; 915  :         ARCH_DEP(program_interrupt) (regs, PGM_STACK_OPERATION_EXCEPTION);

  00232	ba 34 00 00 00	 mov	 edx, 52			; 00000034H
  00237	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	e8 00 00 00 00	 call	 s390_program_interrupt
$LN10@s390_locat:

; 916  : 
; 917  :     /* Return the virtual address of the entry descriptor */
; 918  :     return lsea;

  00241	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]

; 919  : 
; 920  : } /* end function ARCH_DEP(locate_stack_entry) */

  00245	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00249	c3		 ret	 0
s390_locate_stack_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
lsea$ = 32
rfs$ = 36
abs$ = 40
i$ = 48
fsha$ = 52
bsea$ = 56
abs2$ = 64
lseaold$ = 72
absold$ = 80
absea$ = 88
lsed$ = 96
lsed2$ = 104
currpsw$ = 112
__$ArrayPad$ = 128
etype$ = 160
retna$ = 168
calla$ = 176
csi$ = 184
pcnum$ = 192
regs$ = 200
s390_form_stack_entry PROC

; 379  : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	57		 push	 rdi
  00013	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 380  : QWORD   currpsw;                        /* Current PSW               */
; 381  : VADR    lsea;                           /* Linkage stack entry addr  */
; 382  : VADR    lseaold;                        /* Linkage stack old addr    */
; 383  : RADR    abs, abs2 = 0;                  /* Absolute addr new entry   */

  0002c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR abs2$[rsp], 0

; 384  : RADR    absold;                         /* Absolute addr old entry   */
; 385  : LSED    lsed;                           /* Linkage stack entry desc. */
; 386  : LSED    lsed2;                          /* New entry descriptor      */
; 387  : U16     rfs;                            /* Remaining free space      */
; 388  : VADR    fsha;                           /* Forward section hdr addr  */
; 389  : VADR    bsea = 0;                       /* Backward stack entry addr */

  00035	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR bsea$[rsp], 0

; 390  : RADR    absea = 0;                      /* Absolute address of bsea  */

  0003d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR absea$[rsp], 0

; 391  : int     i;                              /* Array subscript           */
; 392  : 
; 393  :     /* [5.12.3.1] Locate space for a new linkage stack entry */
; 394  : 
; 395  :     /* Obtain the virtual address of the current entry from CR15 */
; 396  :     lsea = regs->CR(15) & CR15_LSEA;

  00046	b8 08 00 00 00	 mov	 eax, 8
  0004b	48 6b c0 10	 imul	 rax, rax, 16
  0004f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0005e	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00063	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 397  : 
; 398  :     /* Fetch the entry descriptor of the current entry */
; 399  :     absold = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  00067	41 b8 04 00 00
	00		 mov	 r8d, 4
  0006d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00075	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  00079	e8 00 00 00 00	 call	 s390_abs_stack_addr
  0007e	48 89 44 24 50	 mov	 QWORD PTR absold$[rsp], rax

; 400  :     memcpy (&lsed, regs->mainstor+absold, sizeof(LSED));

  00083	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR absold$[rsp]
  00097	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0009b	48 89 44 24 60	 mov	 QWORD PTR lsed$[rsp], rax

; 401  :     lseaold = lsea;

  000a0	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  000a4	89 44 24 48	 mov	 DWORD PTR lseaold$[rsp], eax

; 402  : 
; 403  : #ifdef STACK_DEBUG
; 404  :     LOGMSG( "stack: Current stack entry at " F_VADR "\n", lsea );
; 405  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 406  :             lsed.uet, lsed.si, lsed.rfs[0],
; 407  :             lsed.rfs[1], lsed.nes[0], lsed.nes[1] );
; 408  : #endif /*STACK_DEBUG*/
; 409  : 
; 410  :     /* Check whether the current linkage stack section has enough
; 411  :        remaining free space to contain the new stack entry */
; 412  :     FETCH_HW(rfs,lsed.rfs);

  000a8	48 8d 4c 24 62	 lea	 rcx, QWORD PTR lsed$[rsp+2]
  000ad	e8 00 00 00 00	 call	 fetch_hw_noswap
  000b2	0f b7 c8	 movzx	 ecx, ax
  000b5	e8 00 00 00 00	 call	 _byteswap_ushort
  000ba	66 89 44 24 24	 mov	 WORD PTR rfs$[rsp], ax

; 413  :     if (rfs < LSSE_SIZE)

  000bf	0f b7 44 24 24	 movzx	 eax, WORD PTR rfs$[rsp]
  000c4	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  000c9	0f 8d 86 01 00
	00		 jge	 $LN8@s390_form_

; 414  :     {
; 415  :         /* Program check if remaining free space not a multiple of 8 */
; 416  :         if ((rfs & 0x07) != 0)

  000cf	0f b7 44 24 24	 movzx	 eax, WORD PTR rfs$[rsp]
  000d4	83 e0 07	 and	 eax, 7
  000d7	85 c0		 test	 eax, eax
  000d9	74 12		 je	 SHORT $LN9@s390_form_

; 417  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  000db	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  000e0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	e8 00 00 00 00	 call	 s390_program_interrupt
$LN9@s390_form_:

; 418  : 
; 419  :         /* Not enough space, so fetch the forward section header addr
; 420  :            from the trailer entry of current linkage stack section */
; 421  :         lsea += sizeof(LSED) + rfs;

  000ed	0f b7 44 24 24	 movzx	 eax, WORD PTR rfs$[rsp]
  000f2	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  000f6	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000fb	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 422  :         LSEA_WRAP(lsea);

  000ff	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00103	0f ba f0 1f	 btr	 eax, 31
  00107	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 423  :         abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_READ);

  0010b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00111	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00119	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  0011d	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00122	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 424  :         FETCH_FSHA(fsha, regs->mainstor + abs);

  00127	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00136	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abs$[rsp]
  0013b	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 fetch_fw_noswap
  00148	8b c8		 mov	 ecx, eax
  0014a	e8 00 00 00 00	 call	 _byteswap_ulong
  0014f	89 44 24 34	 mov	 DWORD PTR fsha$[rsp], eax

; 425  : 
; 426  : #ifdef STACK_DEBUG
; 427  :         LOGMSG( "stack: Forward section header addr " F_VADR "\n", fsha );
; 428  : #endif /*STACK_DEBUG*/
; 429  : 
; 430  :         /* Stack full exception if forward address is not valid */
; 431  :         if ((fsha & LSTE_FVALID) == 0)

  00153	8b 44 24 34	 mov	 eax, DWORD PTR fsha$[rsp]
  00157	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0015c	85 c0		 test	 eax, eax
  0015e	75 12		 jne	 SHORT $LN10@s390_form_

; 432  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_FULL_EXCEPTION);

  00160	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00165	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	e8 00 00 00 00	 call	 s390_program_interrupt
$LN10@s390_form_:

; 433  : 
; 434  :         /* Extract the forward section header address, which points to
; 435  :            the entry descriptor (words 2-3) of next section's header */
; 436  :         fsha &= LSTE_FSHA;

  00172	8b 44 24 34	 mov	 eax, DWORD PTR fsha$[rsp]
  00176	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  0017b	89 44 24 34	 mov	 DWORD PTR fsha$[rsp], eax

; 437  : 
; 438  :         /* Fetch the entry descriptor of the next section's header */
; 439  :         absold = ARCH_DEP(abs_stack_addr) (fsha, regs, ACCTYPE_READ);

  0017f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00185	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	8b 4c 24 34	 mov	 ecx, DWORD PTR fsha$[rsp]
  00191	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00196	48 89 44 24 50	 mov	 QWORD PTR absold$[rsp], rax

; 440  :         memcpy (&lsed, regs->mainstor+absold, sizeof(LSED));

  0019b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR absold$[rsp]
  001af	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  001b3	48 89 44 24 60	 mov	 QWORD PTR lsed$[rsp], rax

; 441  :         lseaold = fsha;

  001b8	8b 44 24 34	 mov	 eax, DWORD PTR fsha$[rsp]
  001bc	89 44 24 48	 mov	 DWORD PTR lseaold$[rsp], eax

; 442  : 
; 443  : #ifdef STACK_DEBUG
; 444  :         logmsg (_("stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X "
; 445  :                 "nes=%2.2X%2.2X\n"),
; 446  :                 lsed.uet, lsed.si, lsed.rfs[0],
; 447  :                 lsed.rfs[1], lsed.nes[0], lsed.nes[1]);
; 448  : #endif /*STACK_DEBUG*/
; 449  : 
; 450  :         /* Program check if the next linkage stack section does not
; 451  :            have enough free space to contain the new stack entry */
; 452  :         FETCH_HW(rfs,lsed.rfs);

  001c0	48 8d 4c 24 62	 lea	 rcx, QWORD PTR lsed$[rsp+2]
  001c5	e8 00 00 00 00	 call	 fetch_hw_noswap
  001ca	0f b7 c8	 movzx	 ecx, ax
  001cd	e8 00 00 00 00	 call	 _byteswap_ushort
  001d2	66 89 44 24 24	 mov	 WORD PTR rfs$[rsp], ax

; 453  :         if (rfs < LSSE_SIZE)

  001d7	0f b7 44 24 24	 movzx	 eax, WORD PTR rfs$[rsp]
  001dc	3d a8 00 00 00	 cmp	 eax, 168		; 000000a8H
  001e1	7d 12		 jge	 SHORT $LN11@s390_form_

; 454  :             ARCH_DEP(program_interrupt) (regs, PGM_STACK_SPECIFICATION_EXCEPTION);

  001e3	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  001e8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	e8 00 00 00 00	 call	 s390_program_interrupt
$LN11@s390_form_:

; 455  : 
; 456  :         /* Calculate the virtual address of the new section's header
; 457  :            entry, which is 8 bytes before the entry descriptor */
; 458  :         lsea = fsha - 8;

  001f5	8b 44 24 34	 mov	 eax, DWORD PTR fsha$[rsp]
  001f9	83 e8 08	 sub	 eax, 8
  001fc	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 459  :         LSEA_WRAP(lsea);

  00200	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00204	0f ba f0 1f	 btr	 eax, 31
  00208	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 460  : 
; 461  :         /* Form the backward stack entry address */
; 462  :         bsea = LSHE_BVALID | (regs->CR(15) & CR15_LSEA);

  0020c	b8 08 00 00 00	 mov	 eax, 8
  00211	48 6b c0 10	 imul	 rax, rax, 16
  00215	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00224	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00229	0f ba e8 1f	 bts	 eax, 31
  0022d	89 44 24 38	 mov	 DWORD PTR bsea$[rsp], eax

; 463  :         absea = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  00231	41 b8 02 00 00
	00		 mov	 r8d, 2
  00237	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023f	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  00243	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00248	48 89 44 24 58	 mov	 QWORD PTR absea$[rsp], rax

; 464  : 
; 465  :         /* Use the virtual address of the entry descriptor of the
; 466  :            new section's header entry as the current entry address */
; 467  :         lsea = fsha;

  0024d	8b 44 24 34	 mov	 eax, DWORD PTR fsha$[rsp]
  00251	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax
$LN8@s390_form_:

; 468  : 
; 469  :     } /* end if(rfs<LSSE_SIZE) */
; 470  : 
; 471  :     /* [5.12.3.2] Form the new stack entry */
; 472  : 
; 473  :     /* Calculate the virtual address of the new stack entry */
; 474  :     lsea += sizeof(LSED);

  00255	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00259	48 83 c0 08	 add	 rax, 8
  0025d	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 475  :     LSEA_WRAP(lsea);

  00261	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00265	0f ba f0 1f	 btr	 eax, 31
  00269	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 476  : 
; 477  :     /* Obtain absolute address of the new stack entry */
; 478  :     abs = ARCH_DEP(abs_stack_addr) (lsea, regs, ACCTYPE_WRITE);

  0026d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00273	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0027b	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  0027f	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00284	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 479  : 
; 480  :     /* If new stack entry will cross a page boundary, obtain the
; 481  :        absolute address of the second page of the stack entry */
; 482  :     if(((lsea + (LSSE_SIZE - 1)) & PAGEFRAME_PAGEMASK)
; 483  :                                 != (lsea & PAGEFRAME_PAGEMASK))

  00289	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0028d	05 a7 00 00 00	 add	 eax, 167		; 000000a7H
  00292	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00297	8b 4c 24 20	 mov	 ecx, DWORD PTR lsea$[rsp]
  0029b	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  002a1	3b c1		 cmp	 eax, ecx
  002a3	74 28		 je	 SHORT $LN12@s390_form_

; 484  :         abs2 = ARCH_DEP(abs_stack_addr)

  002a5	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  002a9	05 a7 00 00 00	 add	 eax, 167		; 000000a7H
  002ae	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  002b3	41 b8 02 00 00
	00		 mov	 r8d, 2
  002b9	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002c1	8b c8		 mov	 ecx, eax
  002c3	e8 00 00 00 00	 call	 s390_abs_stack_addr
  002c8	48 89 44 24 40	 mov	 QWORD PTR abs2$[rsp], rax
$LN12@s390_form_:

; 485  :                         ((lsea + (LSSE_SIZE - 1)) & PAGEFRAME_PAGEMASK,
; 486  :                         regs, ACCTYPE_WRITE);
; 487  : 
; 488  : #ifdef STACK_DEBUG
; 489  :     LOGMSG( "stack: New stack entry at " F_VADR "\n", lsea );
; 490  : #endif /*STACK_DEBUG*/
; 491  : 
; 492  :     /* If a new section then place updated backward stack
; 493  :        entry address in the new section's header entry */
; 494  :     if(bsea)

  002cd	83 7c 24 38 00	 cmp	 DWORD PTR bsea$[rsp], 0
  002d2	74 29		 je	 SHORT $LN13@s390_form_

; 495  :         STORE_BSEA(regs->mainstor + absea, bsea);

  002d4	8b 4c 24 38	 mov	 ecx, DWORD PTR bsea$[rsp]
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e5	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  002ec	48 8b 54 24 58	 mov	 rdx, QWORD PTR absea$[rsp]
  002f1	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  002f6	8b d0		 mov	 edx, eax
  002f8	e8 00 00 00 00	 call	 store_fw_noswap
$LN13@s390_form_:

; 496  : 
; 497  :     /* Store general registers 0-15 in bytes 0-63 (ESA/390)
; 498  :        or bytes 0-127 (ESAME) of the new state entry */
; 499  :     for (i = 0; i < 16; i++)

  002fd	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00305	eb 0a		 jmp	 SHORT $LN4@s390_form_
$LN2@s390_form_:
  00307	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0030b	ff c0		 inc	 eax
  0030d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_form_:
  00311	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00316	7d 75		 jge	 SHORT $LN3@s390_form_

; 500  :     {
; 501  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 502  :         /* Store the 64-bit general register in the stack entry */
; 503  :         STORE_DW(regs->mainstor + abs, regs->GR_G(i));
; 504  : 
; 505  :       #ifdef STACK_DEBUG
; 506  :         logmsg (_("stack: GPR%d=" F_GREG " stored at V:" F_VADR
; 507  :                 " A:" F_RADR "\n"), i, regs->GR_G(i), lsea, abs);
; 508  :       #endif /*STACK_DEBUG*/
; 509  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 510  :         /* Store the 32-bit general register in the stack entry */
; 511  :         STORE_FW(regs->mainstor + abs, regs->GR_L(i));

  00318	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0031d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00325	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0032c	e8 00 00 00 00	 call	 _byteswap_ulong
  00331	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00340	48 03 4c 24 28	 add	 rcx, QWORD PTR abs$[rsp]
  00345	8b d0		 mov	 edx, eax
  00347	e8 00 00 00 00	 call	 store_fw_noswap

; 512  : 
; 513  :       #ifdef STACK_DEBUG
; 514  :         logmsg (_("stack: GPR%d=" F_GREG " stored at V:" F_VADR
; 515  :                 " A:" F_RADR "\n"), i, regs->GR_L(i), lsea, abs);
; 516  :       #endif /*STACK_DEBUG*/
; 517  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 518  : 
; 519  :         /* Update the virtual and absolute addresses */
; 520  :         lsea += LSSE_REGSIZE;

  0034c	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00350	83 c0 04	 add	 eax, 4
  00353	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 521  :         LSEA_WRAP(lsea);

  00357	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0035b	0f ba f0 1f	 btr	 eax, 31
  0035f	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 522  :         abs += LSSE_REGSIZE;

  00363	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00368	48 83 c0 04	 add	 rax, 4
  0036c	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 523  : 
; 524  :         /* Recalculate absolute address if page boundary crossed */
; 525  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00371	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00375	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0037a	85 c0		 test	 eax, eax
  0037c	75 0a		 jne	 SHORT $LN14@s390_form_

; 526  :             abs = abs2;

  0037e	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  00383	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN14@s390_form_:

; 527  : 
; 528  :     } /* end for(i) */

  00388	e9 7a ff ff ff	 jmp	 $LN2@s390_form_
$LN3@s390_form_:

; 529  : 
; 530  : #if !defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 531  :     /* For ESA/390, store access registers 0-15 in bytes 64-127 */
; 532  :     for (i = 0; i < 16; i++)

  0038d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00395	eb 0a		 jmp	 SHORT $LN7@s390_form_
$LN5@s390_form_:
  00397	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0039b	ff c0		 inc	 eax
  0039d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_form_:
  003a1	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  003a6	7d 75		 jge	 SHORT $LN6@s390_form_

; 533  :     {
; 534  :         /* Store the access register in the stack entry */
; 535  :         STORE_FW(regs->mainstor + abs, regs->AR(i));

  003a8	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b5	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  003bc	e8 00 00 00 00	 call	 _byteswap_ulong
  003c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  003d0	48 03 4c 24 28	 add	 rcx, QWORD PTR abs$[rsp]
  003d5	8b d0		 mov	 edx, eax
  003d7	e8 00 00 00 00	 call	 store_fw_noswap

; 536  : 
; 537  :       #ifdef STACK_DEBUG
; 538  :         logmsg (_("stack: AR%d=" F_AREG " stored at V:" F_VADR
; 539  :                 " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 540  :       #endif /*STACK_DEBUG*/
; 541  : 
; 542  :         /* Update the virtual and absolute addresses */
; 543  :         lsea += 4;

  003dc	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  003e0	83 c0 04	 add	 eax, 4
  003e3	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 544  :         LSEA_WRAP(lsea);

  003e7	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  003eb	0f ba f0 1f	 btr	 eax, 31
  003ef	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 545  :         abs += 4;

  003f3	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  003f8	48 83 c0 04	 add	 rax, 4
  003fc	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 546  : 
; 547  :         /* Recalculate absolute address if page boundary crossed */
; 548  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00401	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00405	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0040a	85 c0		 test	 eax, eax
  0040c	75 0a		 jne	 SHORT $LN15@s390_form_

; 549  :             abs = abs2;

  0040e	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  00413	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN15@s390_form_:

; 550  : 
; 551  :     } /* end for(i) */

  00418	e9 7a ff ff ff	 jmp	 $LN5@s390_form_
$LN6@s390_form_:

; 552  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 553  : 
; 554  :     /* Store the PKM, SASN, EAX, and PASN in bytes 128-135 */
; 555  :     STORE_FW(regs->mainstor + abs, regs->CR_L(3));

  0041d	b8 08 00 00 00	 mov	 eax, 8
  00422	48 6b c0 04	 imul	 rax, rax, 4
  00426	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042e	8b 8c 01 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1536]
  00435	e8 00 00 00 00	 call	 _byteswap_ulong
  0043a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00442	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00449	48 03 4c 24 28	 add	 rcx, QWORD PTR abs$[rsp]
  0044e	8b d0		 mov	 edx, eax
  00450	e8 00 00 00 00	 call	 store_fw_noswap

; 556  :     STORE_HW(regs->mainstor + abs + 4, regs->CR_LHH(8));

  00455	b8 08 00 00 00	 mov	 eax, 8
  0045a	48 6b c0 09	 imul	 rax, rax, 9
  0045e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00466	0f b7 8c 01 02
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1538]
  0046e	e8 00 00 00 00	 call	 _byteswap_ushort
  00473	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047b	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00482	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  00487	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  0048c	0f b7 d0	 movzx	 edx, ax
  0048f	e8 00 00 00 00	 call	 store_hw_noswap

; 557  :     STORE_HW(regs->mainstor + abs + 6, regs->CR_LHL(4));

  00494	b8 08 00 00 00	 mov	 eax, 8
  00499	48 6b c0 05	 imul	 rax, rax, 5
  0049d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a5	0f b7 8c 01 00
	06 00 00	 movzx	 ecx, WORD PTR [rcx+rax+1536]
  004ad	e8 00 00 00 00	 call	 _byteswap_ushort
  004b2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ba	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  004c1	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  004c6	48 8d 4c 11 06	 lea	 rcx, QWORD PTR [rcx+rdx+6]
  004cb	0f b7 d0	 movzx	 edx, ax
  004ce	e8 00 00 00 00	 call	 store_hw_noswap

; 558  : 
; 559  :   #ifdef STACK_DEBUG
; 560  :     logmsg (_("stack: PKM=%2.2X%2.2X SASN=%2.2X%2.2X "
; 561  :             "EAX=%2.2X%2.2X PASN=%2.2X%2.2X \n"
; 562  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 563  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 564  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 565  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 566  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 567  :             lsea, abs);
; 568  :   #endif /*STACK_DEBUG*/
; 569  : 
; 570  :     /* Update virtual and absolute addresses to point to byte 136 */
; 571  :     lsea += 8;

  004d3	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  004d7	83 c0 08	 add	 eax, 8
  004da	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 572  :     LSEA_WRAP(lsea);

  004de	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  004e2	0f ba f0 1f	 btr	 eax, 31
  004e6	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 573  :     abs += 8;

  004ea	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  004ef	48 83 c0 08	 add	 rax, 8
  004f3	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 574  : 
; 575  :     /* Recalculate absolute address if page boundary crossed */
; 576  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  004f8	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  004fc	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00501	85 c0		 test	 eax, eax
  00503	75 0a		 jne	 SHORT $LN16@s390_form_

; 577  :         abs = abs2;

  00505	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  0050a	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN16@s390_form_:

; 578  : 
; 579  :     /* Store bits 0-63 of the current PSW in bytes 136-143 */
; 580  :     ARCH_DEP(store_psw) (regs, currpsw);

  0050f	48 8d 54 24 70	 lea	 rdx, QWORD PTR currpsw$[rsp]
  00514	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051c	e8 00 00 00 00	 call	 s390_store_psw

; 581  :     memcpy (regs->mainstor + abs, currpsw, 8);

  00521	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00529	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00530	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abs$[rsp]
  00535	48 8b 54 24 70	 mov	 rdx, QWORD PTR currpsw$[rsp]
  0053a	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 582  : 
; 583  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 584  :     /* For ESAME, use the addressing mode bits from the return
; 585  :        address to set bits 31 and 32 of bytes 136-143 */
; 586  :     if (retna & 0x01)
; 587  :     {
; 588  :         /* For a 64-bit return address, set bits 31 and 32 */
; 589  :         regs->mainstor[abs+3] |= 0x01;
; 590  :         regs->mainstor[abs+4] |= 0x80;
; 591  :         retna &= 0xFFFFFFFFFFFFFFFEULL;
; 592  :     }
; 593  :     else if (retna & 0x80000000)
; 594  :     {
; 595  :         /* For a 31-bit return address, clear bit 31 and set bit 32 */
; 596  :         regs->mainstor[abs+3] &= 0xFE;
; 597  :         regs->mainstor[abs+4] |= 0x80;
; 598  :         retna &= 0x7FFFFFFF;
; 599  :     }
; 600  :     else
; 601  :     {
; 602  :         /* For a 24-bit return address, clear bits 31 and 32 */
; 603  :         regs->mainstor[abs+3] &= 0xFE;
; 604  :         regs->mainstor[abs+4] &= 0x7F;
; 605  :         retna &= 0x00FFFFFF;
; 606  :     }
; 607  : #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 608  :     /* For ESA/390, replace bytes 140-143 by the return address,
; 609  :        with the high-order bit indicating the addressing mode */
; 610  :     STORE_FW(regs->mainstor + abs + 4, retna);

  0053e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR retna$[rsp]
  00545	e8 00 00 00 00	 call	 _byteswap_ulong
  0054a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00552	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00559	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  0055e	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00563	8b d0		 mov	 edx, eax
  00565	e8 00 00 00 00	 call	 store_fw_noswap

; 611  : #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 612  : 
; 613  :   #ifdef STACK_DEBUG
; 614  :     logmsg (_("stack: PSW=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 615  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 616  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 617  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 618  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 619  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 620  :             lsea, abs);
; 621  :   #endif /*STACK_DEBUG*/
; 622  : 
; 623  :     /* Update virtual and absolute addresses to point to byte 144 */
; 624  :     lsea += 8;

  0056a	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0056e	83 c0 08	 add	 eax, 8
  00571	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 625  :     LSEA_WRAP(lsea);

  00575	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00579	0f ba f0 1f	 btr	 eax, 31
  0057d	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 626  :     abs += 8;

  00581	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00586	48 83 c0 08	 add	 rax, 8
  0058a	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 627  : 
; 628  :     /* Recalculate absolute address if page boundary crossed */
; 629  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  0058f	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00593	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00598	85 c0		 test	 eax, eax
  0059a	75 0a		 jne	 SHORT $LN17@s390_form_

; 630  :         abs = abs2;

  0059c	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  005a1	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN17@s390_form_:

; 631  : 
; 632  :     /* Store bytes 144-151 according to PC or BAKR */
; 633  :     if (etype == LSED_UET_PC)

  005a6	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR etype$[rsp]
  005ae	83 f8 05	 cmp	 eax, 5
  005b1	75 55		 jne	 SHORT $LN18@s390_form_

; 634  :     {
; 635  :       #if defined(FEATURE_CALLED_SPACE_IDENTIFICATION)
; 636  :         /* Store the called-space identification in bytes 144-147 */
; 637  :         STORE_FW(regs->mainstor + abs, csi);

  005b3	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR csi$[rsp]
  005ba	e8 00 00 00 00	 call	 _byteswap_ulong
  005bf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c7	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  005ce	48 03 4c 24 28	 add	 rcx, QWORD PTR abs$[rsp]
  005d3	8b d0		 mov	 edx, eax
  005d5	e8 00 00 00 00	 call	 store_fw_noswap

; 638  :       #endif /*defined(FEATURE_CALLED_SPACE_IDENTIFICATION)*/
; 639  : 
; 640  :         /* Store the PC number in bytes 148-151 */
; 641  :         STORE_FW(regs->mainstor + abs + 4, pcnum);

  005da	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR pcnum$[rsp]
  005e1	e8 00 00 00 00	 call	 _byteswap_ulong
  005e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ee	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  005f5	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  005fa	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  005ff	8b d0		 mov	 edx, eax
  00601	e8 00 00 00 00	 call	 store_fw_noswap

; 642  :     }

  00606	eb 2c		 jmp	 SHORT $LN19@s390_form_
$LN18@s390_form_:

; 643  :     else
; 644  :     {
; 645  :       #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 646  :         /* Store the called address and amode in bytes 144-151 */
; 647  :         STORE_DW(regs->mainstor + abs, calla);
; 648  :       #else /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 649  :         /* Store the called address and amode in bytes 148-151 */
; 650  :         STORE_FW(regs->mainstor + abs + 4, calla);

  00608	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR calla$[rsp]
  0060f	e8 00 00 00 00	 call	 _byteswap_ulong
  00614	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061c	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00623	48 8b 54 24 28	 mov	 rdx, QWORD PTR abs$[rsp]
  00628	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  0062d	8b d0		 mov	 edx, eax
  0062f	e8 00 00 00 00	 call	 store_fw_noswap
$LN19@s390_form_:

; 651  :       #endif /*!defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 652  :     }
; 653  : 
; 654  :     /* Update virtual and absolute addresses to point to byte 152 */
; 655  :     lsea += 8;

  00634	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00638	83 c0 08	 add	 eax, 8
  0063b	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 656  :     LSEA_WRAP(lsea);

  0063f	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00643	0f ba f0 1f	 btr	 eax, 31
  00647	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 657  :     abs += 8;

  0064b	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00650	48 83 c0 08	 add	 rax, 8
  00654	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 658  : 
; 659  :     /* Recalculate absolute address if page boundary crossed */
; 660  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  00659	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0065d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00662	85 c0		 test	 eax, eax
  00664	75 0a		 jne	 SHORT $LN20@s390_form_

; 661  :         abs = abs2;

  00666	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  0066b	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN20@s390_form_:

; 662  : 
; 663  :     /* Store zeroes in bytes 152-159 */
; 664  :     memset (regs->mainstor+abs, 0, 8);

  00670	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00678	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0067f	48 03 44 24 28	 add	 rax, QWORD PTR abs$[rsp]
  00684	48 8b f8	 mov	 rdi, rax
  00687	33 c0		 xor	 eax, eax
  00689	b9 08 00 00 00	 mov	 ecx, 8
  0068e	f3 aa		 rep stosb

; 665  : 
; 666  :     /* Update virtual and absolute addresses to point to byte 160 */
; 667  :     lsea += 8;

  00690	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  00694	83 c0 08	 add	 eax, 8
  00697	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 668  :     LSEA_WRAP(lsea);

  0069b	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0069f	0f ba f0 1f	 btr	 eax, 31
  006a3	89 44 24 20	 mov	 DWORD PTR lsea$[rsp], eax

; 669  :     abs += 8;

  006a7	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  006ac	48 83 c0 08	 add	 rax, 8
  006b0	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax

; 670  : 
; 671  :     /* Recalculate absolute address if page boundary crossed */
; 672  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)

  006b5	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  006b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  006be	85 c0		 test	 eax, eax
  006c0	75 0a		 jne	 SHORT $LN21@s390_form_

; 673  :         abs = abs2;

  006c2	48 8b 44 24 40	 mov	 rax, QWORD PTR abs2$[rsp]
  006c7	48 89 44 24 28	 mov	 QWORD PTR abs$[rsp], rax
$LN21@s390_form_:

; 674  : 
; 675  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 676  :     /* For ESAME, store zeroes in bytes 160-167 */
; 677  :     memset (regs->mainstor+abs, 0, 8);
; 678  : 
; 679  :     /* Update virtual and absolute addresses to point to byte 168 */
; 680  :     lsea += 8;
; 681  :     LSEA_WRAP(lsea);
; 682  :     abs += 8;
; 683  : 
; 684  :     /* Recalculate absolute address if page boundary crossed */
; 685  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)
; 686  :         abs = abs2;
; 687  : 
; 688  :     /* For ESAME, store the return address in bytes 168-175 */
; 689  :     STORE_DW (regs->mainstor + abs, retna);
; 690  : 
; 691  :   #ifdef STACK_DEBUG
; 692  :     logmsg (_("stack: PSW2=%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 693  :             "stored at V:" F_VADR " A:" F_RADR "\n"),
; 694  :             regs->mainstor[abs], regs->mainstor[abs+1],
; 695  :             regs->mainstor[abs+2], regs->mainstor[abs+3],
; 696  :             regs->mainstor[abs+4], regs->mainstor[abs+5],
; 697  :             regs->mainstor[abs+6], regs->mainstor[abs+7],
; 698  :             lsea, abs);
; 699  :   #endif /*STACK_DEBUG*/
; 700  : 
; 701  :     /* Update virtual and absolute addresses to point to byte 176 */
; 702  :     lsea += 8;
; 703  :     LSEA_WRAP(lsea);
; 704  :     abs += 8;
; 705  : 
; 706  :     /* Recalculate absolute address if page boundary crossed */
; 707  :     if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)
; 708  :         abs = abs2;
; 709  : 
; 710  :     /* If ASN-and-LX-reuse is installed and active, store
; 711  :        the SASTEIN (CR3 bits 0-31) in bytes 176-179, and
; 712  :        store the PASTEIN (CR4 bits 0-31) in bytes 180-183 */
; 713  :     if (ASN_AND_LX_REUSE_ENABLED(regs))
; 714  :     {
; 715  :         STORE_FW(regs->mainstor + abs, regs->CR_H(3));
; 716  :         STORE_FW(regs->mainstor + abs + 4, regs->CR_H(4));
; 717  : 
; 718  :       #ifdef STACK_DEBUG
; 719  :         logmsg (_("stack: SASTEIN=%2.2X%2.2X%2.2X%2.2X "
; 720  :                 "PASTEIN=%2.2X%2.2X%2.2X%2.2X \n"
; 721  :                 "stored at V:" F_VADR " A:" F_RADR "\n"),
; 722  :                 regs->mainstor[abs], regs->mainstor[abs+1],
; 723  :                 regs->mainstor[abs+2], regs->mainstor[abs+3],
; 724  :                 regs->mainstor[abs+4], regs->mainstor[abs+5],
; 725  :                 regs->mainstor[abs+6], regs->mainstor[abs+7],
; 726  :                 lsea, abs);
; 727  :       #endif /*STACK_DEBUG*/
; 728  : 
; 729  :     } /* end if(ASN_AND_LX_REUSE_ENABLED) */
; 730  : 
; 731  :     /* Skip bytes 176-223 of the new stack entry */
; 732  :     lsea += 48;
; 733  :     LSEA_WRAP(lsea);
; 734  :     abs += 48;
; 735  : 
; 736  :     /* Recalculate absolute address if page boundary crossed */
; 737  :     if ((lsea & PAGEFRAME_BYTEMASK) < 48)
; 738  :         abs = abs2 | (lsea & PAGEFRAME_BYTEMASK);
; 739  : 
; 740  :     /* For ESAME, store access registers 0-15 in bytes 224-287 */
; 741  :     for (i = 0; i < 16; i++)
; 742  :     {
; 743  :         /* Store the access register in the stack entry */
; 744  :         STORE_FW(regs->mainstor + abs, regs->AR(i));
; 745  : 
; 746  :       #ifdef STACK_DEBUG
; 747  :         logmsg (_("stack: AR%d=" F_AREG " stored at V:" F_VADR
; 748  :                 " A:" F_RADR "\n"), i, regs->AR(i), lsea, abs);
; 749  :       #endif /*STACK_DEBUG*/
; 750  : 
; 751  :         /* Update the virtual and absolute addresses */
; 752  :         lsea += 4;
; 753  :         LSEA_WRAP(lsea);
; 754  :         abs += 4;
; 755  : 
; 756  :         /* Recalculate absolute address if page boundary crossed */
; 757  :         if ((lsea & PAGEFRAME_BYTEMASK) == 0x000)
; 758  :             abs = abs2;
; 759  : 
; 760  :     } /* end for(i) */
; 761  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 762  : 
; 763  :     /* Build the new linkage stack entry descriptor */
; 764  :     memset (&lsed2, 0, sizeof(LSED));

  006cc	48 8d 44 24 68	 lea	 rax, QWORD PTR lsed2$[rsp]
  006d1	48 8b f8	 mov	 rdi, rax
  006d4	33 c0		 xor	 eax, eax
  006d6	b9 08 00 00 00	 mov	 ecx, 8
  006db	f3 aa		 rep stosb

; 765  :     lsed2.uet = etype & LSED_UET_ET;

  006dd	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR etype$[rsp]
  006e5	83 e0 7f	 and	 eax, 127		; 0000007fH
  006e8	88 44 24 68	 mov	 BYTE PTR lsed2$[rsp], al

; 766  :     lsed2.si = lsed.si;

  006ec	0f b6 44 24 61	 movzx	 eax, BYTE PTR lsed$[rsp+1]
  006f1	88 44 24 69	 mov	 BYTE PTR lsed2$[rsp+1], al

; 767  :     rfs -= LSSE_SIZE;

  006f5	0f b7 44 24 24	 movzx	 eax, WORD PTR rfs$[rsp]
  006fa	2d a8 00 00 00	 sub	 eax, 168		; 000000a8H
  006ff	66 89 44 24 24	 mov	 WORD PTR rfs$[rsp], ax

; 768  :     STORE_HW(lsed2.rfs,rfs);

  00704	0f b7 4c 24 24	 movzx	 ecx, WORD PTR rfs$[rsp]
  00709	e8 00 00 00 00	 call	 _byteswap_ushort
  0070e	0f b7 d0	 movzx	 edx, ax
  00711	48 8d 4c 24 6a	 lea	 rcx, QWORD PTR lsed2$[rsp+2]
  00716	e8 00 00 00 00	 call	 store_hw_noswap

; 769  : 
; 770  :     /* Store the linkage stack entry descriptor in the last eight
; 771  :        bytes of the new state entry (bytes 160-167 for ESA/390,
; 772  :        or bytes 288-295 for ESAME) */
; 773  :     memcpy (regs->mainstor+abs, &lsed2, sizeof(LSED));

  0071b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00723	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0072a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abs$[rsp]
  0072f	48 8b 54 24 68	 mov	 rdx, QWORD PTR lsed2$[rsp]
  00734	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 774  : 
; 775  : #ifdef STACK_DEBUG
; 776  :     LOGMSG( "stack: New stack entry at " F_VADR "\n", lsea );
; 777  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 778  :             lsed2.uet, lsed2.si, lsed2.rfs[0],
; 779  :             lsed2.rfs[1], lsed2.nes[0], lsed2.nes[1] );
; 780  : #endif /*STACK_DEBUG*/
; 781  : 
; 782  :     /* [5.12.3.3] Update the current entry */
; 783  :     STORE_HW(lsed.nes, LSSE_SIZE);

  00738	66 b9 a8 00	 mov	 cx, 168			; 000000a8H
  0073c	e8 00 00 00 00	 call	 _byteswap_ushort
  00741	0f b7 d0	 movzx	 edx, ax
  00744	48 8d 4c 24 64	 lea	 rcx, QWORD PTR lsed$[rsp+4]
  00749	e8 00 00 00 00	 call	 store_hw_noswap

; 784  :     absold = ARCH_DEP(abs_stack_addr) (lseaold, regs, ACCTYPE_WRITE);

  0074e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00754	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0075c	8b 4c 24 48	 mov	 ecx, DWORD PTR lseaold$[rsp]
  00760	e8 00 00 00 00	 call	 s390_abs_stack_addr
  00765	48 89 44 24 50	 mov	 QWORD PTR absold$[rsp], rax

; 785  :     memcpy (regs->mainstor+absold, &lsed, sizeof(LSED));

  0076a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00772	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00779	48 8b 4c 24 50	 mov	 rcx, QWORD PTR absold$[rsp]
  0077e	48 8b 54 24 60	 mov	 rdx, QWORD PTR lsed$[rsp]
  00783	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 786  : 
; 787  : #ifdef STACK_DEBUG
; 788  :     LOGMSG( "stack: Previous stack entry updated at A:" F_RADR "\n",
; 789  :             absold );
; 790  :     LOGMSG( "stack: et=%2.2X si=%2.2X rfs=%2.2X%2.2X nes=%2.2X%2.2X\n",
; 791  :             lsed.uet, lsed.si, lsed.rfs[0],
; 792  :             lsed.rfs[1], lsed.nes[0], lsed.nes[1] );
; 793  : #endif /*STACK_DEBUG*/
; 794  : 
; 795  :     /* [5.12.3.4] Update control register 15 */
; 796  :     regs->CR(15) = lsea & CR15_LSEA;

  00787	8b 44 24 20	 mov	 eax, DWORD PTR lsea$[rsp]
  0078b	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00790	b9 08 00 00 00	 mov	 ecx, 8
  00795	48 6b c9 10	 imul	 rcx, rcx, 16
  00799	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007a1	89 84 0a 00 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1536], eax

; 797  : 
; 798  : #ifdef STACK_DEBUG
; 799  :     LOGMSG( "stack: CR15=" F_CREG "\n", regs->CR( 15 ));
; 800  : #endif /*STACK_DEBUG*/
; 801  : 
; 802  : } /* end function ARCH_DEP(form_stack_entry) */

  007a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007b0	48 33 cc	 xor	 rcx, rsp
  007b3	e8 00 00 00 00	 call	 __security_check_cookie
  007b8	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  007bf	5f		 pop	 rdi
  007c0	c3		 ret	 0
s390_form_stack_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\stack.c
_TEXT	SEGMENT
i$1 = 32
tsaa1$ = 40
trap_ia$ = 48
oldmode$2 = 52
tcba$ = 56
tsao$ = 60
trap_flags$ = 64
i$ = 68
tv489 = 72
tsaa2$ = 80
duct11$ = 88
atcba$ = 96
lastbyte$ = 104
tv209 = 108
tv229 = 112
tv283 = 116
tv282 = 120
tv284 = 124
tv294 = 128
tv301 = 132
tv308 = 136
tv310 = 140
tv320 = 144
tv463 = 148
tv483 = 152
tv468 = 156
tv605 = 160
inst_cr$3 = 164
ducto$ = 168
trap_psw$ = 176
__$ArrayPad$ = 192
trap_is_trap4$ = 224
regs$ = 232
trap_operand$ = 240
s390_trap_x PROC

; 140  : {

$LN126:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 141  : RADR ducto;
; 142  : U32  duct11;
; 143  : U32  tcba;
; 144  : RADR atcba;
; 145  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 146  : U32  tcba0;
; 147  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 148  : U32  tsao;
; 149  : RADR tsaa1,
; 150  :      tsaa2;
; 151  : VADR lastbyte;
; 152  : U32  trap_ia;
; 153  : U32  trap_flags;
; 154  : QWORD trap_psw;
; 155  : int  i;
; 156  : 
; 157  :     if(SIE_STATE_BIT_ON(regs, MX, XC))

  00028	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00030	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00036	d1 e8		 shr	 eax, 1
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 2c		 je	 SHORT $LN46@s390_trap_
  0003f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00047	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0004e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	74 12		 je	 SHORT $LN46@s390_trap_

; 158  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  00059	ba 13 00 00 00	 mov	 edx, 19
  0005e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	e8 00 00 00 00	 call	 s390_program_interrupt
$LN46@s390_trap_:

; 159  : 
; 160  :     if (   REAL_MODE(&regs->psw)
; 161  :       || !(PRIMARY_SPACE_MODE(&regs->psw)

  0006b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00077	83 e0 04	 and	 eax, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 21		 je	 SHORT $LN48@s390_trap_
  0007e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00086	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0008a	85 c0		 test	 eax, eax
  0008c	74 23		 je	 SHORT $LN47@s390_trap_
  0008e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0009a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0009d	74 12		 je	 SHORT $LN47@s390_trap_
$LN48@s390_trap_:

; 162  :       ||   ACCESS_REGISTER_MODE(&regs->psw)) )
; 163  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0009f	ba 13 00 00 00	 mov	 edx, 19
  000a4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s390_program_interrupt
$LN47@s390_trap_:

; 164  : 
; 165  :     /* Obtain the DUCT origin from control register 2 */
; 166  :     ducto = regs->CR(2) & CR2_DUCTO;

  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	48 6b c0 03	 imul	 rax, rax, 3
  000ba	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c9	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  000ce	8b c0		 mov	 eax, eax
  000d0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ducto$[rsp], rax

; 167  : 
; 168  :     /* Program check if DUCT origin address is invalid */
; 169  :     if (ducto > regs->mainlim)

  000d8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  000e7	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR ducto$[rsp], rax
  000ef	76 12		 jbe	 SHORT $LN49@s390_trap_

; 170  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  000f1	ba 05 00 00 00	 mov	 edx, 5
  000f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	e8 00 00 00 00	 call	 s390_program_interrupt
$LN49@s390_trap_:

; 171  : 
; 172  :     /* Fetch DUCT bytes 44-47 */
; 173  :     duct11 = ARCH_DEP(fetch_fullword_absolute) (ducto + 44, regs);

  00103	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ducto$[rsp]
  0010b	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  0010f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  0011f	89 44 24 58	 mov	 DWORD PTR duct11$[rsp], eax

; 174  : 
; 175  :     if(!(duct11 & DUCT11_TE))

  00123	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00127	83 e0 01	 and	 eax, 1
  0012a	85 c0		 test	 eax, eax
  0012c	75 12		 jne	 SHORT $LN50@s390_trap_

; 176  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  0012e	ba 13 00 00 00	 mov	 edx, 19
  00133	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	e8 00 00 00 00	 call	 s390_program_interrupt
$LN50@s390_trap_:

; 177  : 
; 178  :     /* Isolate the Trap Control Block Address */
; 179  :     tcba = duct11 & DUCT11_TCBA;

  00140	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00144	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  00149	89 44 24 38	 mov	 DWORD PTR tcba$[rsp], eax

; 180  : 
; 181  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 182  :     /* Fetch word 0 of the TCB */
; 183  :     atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);
; 184  :     FETCH_FW(tcba0, regs->mainstor + atcba);
; 185  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 186  : 
; 187  :     /* Advance to offset +12 */
; 188  :     tcba += 12;

  0014d	8b 44 24 38	 mov	 eax, DWORD PTR tcba$[rsp]
  00151	83 c0 0c	 add	 eax, 12
  00154	89 44 24 38	 mov	 DWORD PTR tcba$[rsp], eax

; 189  :     atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);

  00158	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	8b 4c 24 38	 mov	 ecx, DWORD PTR tcba$[rsp]
  0016a	e8 00 00 00 00	 call	 s390_abs_trap_addr
  0016f	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax

; 190  : 
; 191  :     /* Fetch word 3 of the TCB */
; 192  :     FETCH_FW(tsao, regs->mainstor + atcba);

  00174	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00183	48 03 44 24 60	 add	 rax, QWORD PTR atcba$[rsp]
  00188	48 8b c8	 mov	 rcx, rax
  0018b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00190	8b c8		 mov	 ecx, eax
  00192	e8 00 00 00 00	 call	 _byteswap_ulong
  00197	89 44 24 3c	 mov	 DWORD PTR tsao$[rsp], eax

; 193  :     tsao &= 0x7FFFFFF8;

  0019b	8b 44 24 3c	 mov	 eax, DWORD PTR tsao$[rsp]
  0019f	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  001a4	89 44 24 3c	 mov	 DWORD PTR tsao$[rsp], eax

; 194  : 
; 195  :     /* Advance to offset +20 */
; 196  :     tcba += 8; atcba += 8;

  001a8	8b 44 24 38	 mov	 eax, DWORD PTR tcba$[rsp]
  001ac	83 c0 08	 add	 eax, 8
  001af	89 44 24 38	 mov	 DWORD PTR tcba$[rsp], eax
  001b3	48 8b 44 24 60	 mov	 rax, QWORD PTR atcba$[rsp]
  001b8	48 83 c0 08	 add	 rax, 8
  001bc	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax

; 197  :     if((atcba & PAGEFRAME_BYTEMASK) < 8)

  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR atcba$[rsp]
  001c6	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  001cc	48 83 f8 08	 cmp	 rax, 8
  001d0	73 1c		 jae	 SHORT $LN51@s390_trap_

; 198  :         atcba = ARCH_DEP(abs_trap_addr) (tcba, regs, ACCTYPE_READ);

  001d2	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d8	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e0	8b 4c 24 38	 mov	 ecx, DWORD PTR tcba$[rsp]
  001e4	e8 00 00 00 00	 call	 s390_abs_trap_addr
  001e9	48 89 44 24 60	 mov	 QWORD PTR atcba$[rsp], rax
$LN51@s390_trap_:

; 199  : 
; 200  :     /* Fetch word 5 of the TCB */
; 201  :     FETCH_FW(trap_ia, regs->mainstor + atcba);

  001ee	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001fd	48 03 44 24 60	 add	 rax, QWORD PTR atcba$[rsp]
  00202	48 8b c8	 mov	 rcx, rax
  00205	e8 00 00 00 00	 call	 fetch_fw_noswap
  0020a	8b c8		 mov	 ecx, eax
  0020c	e8 00 00 00 00	 call	 _byteswap_ulong
  00211	89 44 24 30	 mov	 DWORD PTR trap_ia$[rsp], eax

; 202  :     trap_ia &= 0x7FFFFFFF;

  00215	8b 44 24 30	 mov	 eax, DWORD PTR trap_ia$[rsp]
  00219	0f ba f0 1f	 btr	 eax, 31
  0021d	89 44 24 30	 mov	 DWORD PTR trap_ia$[rsp], eax

; 203  : 
; 204  :     /* Calculate last byte stored */
; 205  :     lastbyte = tsao + 95

  00221	8b 44 24 3c	 mov	 eax, DWORD PTR tsao$[rsp]
  00225	83 c0 5f	 add	 eax, 95			; 0000005fH
  00228	89 44 24 68	 mov	 DWORD PTR lastbyte$[rsp], eax

; 206  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 207  :                          + ((tcba0 & TCB0_R) ? 64 : 0)
; 208  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 209  :                                                        ;
; 210  : 
; 211  :     /* Use abs_trap_addr as it conforms to trap save area access */
; 212  :     tsaa1 = tsaa2 = ARCH_DEP(abs_trap_addr) (tsao, regs, ACCTYPE_WRITE);

  0022c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00232	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023a	8b 4c 24 3c	 mov	 ecx, DWORD PTR tsao$[rsp]
  0023e	e8 00 00 00 00	 call	 s390_abs_trap_addr
  00243	48 89 44 24 50	 mov	 QWORD PTR tsaa2$[rsp], rax
  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0024d	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 213  :     if((tsaa1 & PAGEFRAME_PAGEMASK) != (lastbyte & PAGEFRAME_PAGEMASK))

  00252	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00257	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  0025d	8b 4c 24 68	 mov	 ecx, DWORD PTR lastbyte$[rsp]
  00261	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00267	8b c9		 mov	 ecx, ecx
  00269	48 3b c1	 cmp	 rax, rcx
  0026c	74 29		 je	 SHORT $LN52@s390_trap_

; 214  :     {
; 215  :         tsao = lastbyte & PAGEFRAME_PAGEMASK;

  0026e	8b 44 24 68	 mov	 eax, DWORD PTR lastbyte$[rsp]
  00272	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00277	89 44 24 3c	 mov	 DWORD PTR tsao$[rsp], eax

; 216  :         tsaa2 = ARCH_DEP(abs_trap_addr) (tsao, regs, ACCTYPE_WRITE);

  0027b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00281	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00289	8b 4c 24 3c	 mov	 ecx, DWORD PTR tsao$[rsp]
  0028d	e8 00 00 00 00	 call	 s390_abs_trap_addr
  00292	48 89 44 24 50	 mov	 QWORD PTR tsaa2$[rsp], rax
$LN52@s390_trap_:

; 217  :     }
; 218  :     ARCH_DEP( or_storage_key )( tsaa1, STORKEY_CHANGE );

  00297	b2 02		 mov	 dl, 2
  00299	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsaa1$[rsp]
  0029e	e8 00 00 00 00	 call	 s390_or_storage_key

; 219  :     if (tsaa1 != tsaa2)

  002a3	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  002a8	48 39 44 24 28	 cmp	 QWORD PTR tsaa1$[rsp], rax
  002ad	74 0c		 je	 SHORT $LN53@s390_trap_

; 220  :         ARCH_DEP( or_storage_key )( tsaa2, STORKEY_CHANGE );

  002af	b2 02		 mov	 dl, 2
  002b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tsaa2$[rsp]
  002b6	e8 00 00 00 00	 call	 s390_or_storage_key
$LN53@s390_trap_:

; 221  : 
; 222  : 
; 223  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 224  :     /* Special operation exception if P == 0 and EA == 1 */
; 225  :     if(!(tcba0 & TCB0_P) && regs->psw.amode64)
; 226  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);
; 227  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 228  : 
; 229  :   #ifdef FEATURE_TRACING
; 230  :     if (regs->CR(12) & CR12_BRTRACE)

  002bb	b8 08 00 00 00	 mov	 eax, 8
  002c0	48 6b c0 0d	 imul	 rax, rax, 13
  002c4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002d3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d8	85 c0		 test	 eax, eax
  002da	74 2e		 je	 SHORT $LN54@s390_trap_

; 231  :         regs->CR(12) = ARCH_DEP(trace_br) (1, trap_ia, regs);

  002dc	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e4	8b 54 24 30	 mov	 edx, DWORD PTR trap_ia$[rsp]
  002e8	b9 01 00 00 00	 mov	 ecx, 1
  002ed	e8 00 00 00 00	 call	 s390_trace_br
  002f2	b9 08 00 00 00	 mov	 ecx, 8
  002f7	48 6b c9 0d	 imul	 rcx, rcx, 13
  002fb	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00303	89 84 0a 00 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1536], eax
$LN54@s390_trap_:
$LN4@s390_trap_:

; 232  :   #endif /*FEATURE_TRACING*/
; 233  : 
; 234  :     PER_SB(regs, trap_ia);

  0030a	33 c0		 xor	 eax, eax
  0030c	83 f8 01	 cmp	 eax, 1
  0030f	0f 84 14 02 00
	00		 je	 $LN55@s390_trap_
  00315	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00323	c1 e8 02	 shr	 eax, 2
  00326	83 e0 01	 and	 eax, 1
  00329	85 c0		 test	 eax, eax
  0032b	74 0a		 je	 SHORT $LN86@s390_trap_
  0032d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  00335	eb 08		 jmp	 SHORT $LN87@s390_trap_
$LN86@s390_trap_:
  00337	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN87@s390_trap_:
  0033f	83 7c 24 6c 00	 cmp	 DWORD PTR tv209[rsp], 0
  00344	74 1e		 je	 SHORT $LN88@s390_trap_
  00346	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00351	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00356	85 c0		 test	 eax, eax
  00358	74 0a		 je	 SHORT $LN88@s390_trap_
  0035a	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  00362	eb 08		 jmp	 SHORT $LN94@s390_trap_
$LN88@s390_trap_:
  00364	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv229[rsp], 0
$LN94@s390_trap_:
  0036c	83 7c 24 70 00	 cmp	 DWORD PTR tv229[rsp], 0
  00371	0f 84 b2 01 00
	00		 je	 $LN55@s390_trap_
  00377	33 c0		 xor	 eax, eax
  00379	83 f8 01	 cmp	 eax, 1
  0037c	0f 84 a7 01 00
	00		 je	 $LN55@s390_trap_
  00382	33 c0		 xor	 eax, eax
  00384	85 c0		 test	 eax, eax
  00386	0f 85 7d 01 00
	00		 jne	 $LN56@s390_trap_
  0038c	b8 08 00 00 00	 mov	 eax, 8
  00391	48 6b c0 0a	 imul	 rax, rax, 10
  00395	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003a4	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  003a9	85 c0		 test	 eax, eax
  003ab	0f 84 58 01 00
	00		 je	 $LN56@s390_trap_
  003b1	b8 08 00 00 00	 mov	 eax, 8
  003b6	48 6b c0 0c	 imul	 rax, rax, 12
  003ba	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003c9	0f ba f0 1f	 btr	 eax, 31
  003cd	b9 08 00 00 00	 mov	 ecx, 8
  003d2	48 6b c9 0b	 imul	 rcx, rcx, 11
  003d6	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003de	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  003e5	0f ba f1 1f	 btr	 ecx, 31
  003e9	3b c1		 cmp	 eax, ecx
  003eb	0f 82 8b 00 00
	00		 jb	 $LN99@s390_trap_
  003f1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f9	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003ff	8b 4c 24 30	 mov	 ecx, DWORD PTR trap_ia$[rsp]
  00403	23 c8		 and	 ecx, eax
  00405	8b c1		 mov	 eax, ecx
  00407	b9 08 00 00 00	 mov	 ecx, 8
  0040c	48 6b c9 0b	 imul	 rcx, rcx, 11
  00410	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00418	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0041f	0f ba f1 1f	 btr	 ecx, 31
  00423	3b c1		 cmp	 eax, ecx
  00425	72 40		 jb	 SHORT $LN95@s390_trap_
  00427	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00435	8b 4c 24 30	 mov	 ecx, DWORD PTR trap_ia$[rsp]
  00439	23 c8		 and	 ecx, eax
  0043b	8b c1		 mov	 eax, ecx
  0043d	b9 08 00 00 00	 mov	 ecx, 8
  00442	48 6b c9 0c	 imul	 rcx, rcx, 12
  00446	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0044e	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00455	0f ba f1 1f	 btr	 ecx, 31
  00459	3b c1		 cmp	 eax, ecx
  0045b	77 0a		 ja	 SHORT $LN95@s390_trap_
  0045d	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv283[rsp], 1
  00465	eb 08		 jmp	 SHORT $LN98@s390_trap_
$LN95@s390_trap_:
  00467	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv283[rsp], 0
$LN98@s390_trap_:
  0046f	8b 44 24 74	 mov	 eax, DWORD PTR tv283[rsp]
  00473	89 44 24 7c	 mov	 DWORD PTR tv284[rsp], eax
  00477	e9 86 00 00 00	 jmp	 $LN100@s390_trap_
$LN99@s390_trap_:
  0047c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00484	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0048a	8b 4c 24 30	 mov	 ecx, DWORD PTR trap_ia$[rsp]
  0048e	23 c8		 and	 ecx, eax
  00490	8b c1		 mov	 eax, ecx
  00492	b9 08 00 00 00	 mov	 ecx, 8
  00497	48 6b c9 0b	 imul	 rcx, rcx, 11
  0049b	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a3	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  004aa	0f ba f1 1f	 btr	 ecx, 31
  004ae	3b c1		 cmp	 eax, ecx
  004b0	73 40		 jae	 SHORT $LN96@s390_trap_
  004b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ba	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  004c0	8b 4c 24 30	 mov	 ecx, DWORD PTR trap_ia$[rsp]
  004c4	23 c8		 and	 ecx, eax
  004c6	8b c1		 mov	 eax, ecx
  004c8	b9 08 00 00 00	 mov	 ecx, 8
  004cd	48 6b c9 0c	 imul	 rcx, rcx, 12
  004d1	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004d9	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  004e0	0f ba f1 1f	 btr	 ecx, 31
  004e4	3b c1		 cmp	 eax, ecx
  004e6	76 0a		 jbe	 SHORT $LN96@s390_trap_
  004e8	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv282[rsp], 0
  004f0	eb 08		 jmp	 SHORT $LN97@s390_trap_
$LN96@s390_trap_:
  004f2	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv282[rsp], 1
$LN97@s390_trap_:
  004fa	8b 44 24 78	 mov	 eax, DWORD PTR tv282[rsp]
  004fe	89 44 24 7c	 mov	 DWORD PTR tv284[rsp], eax
$LN100@s390_trap_:
  00502	83 7c 24 7c 00	 cmp	 DWORD PTR tv284[rsp], 0
  00507	74 20		 je	 SHORT $LN55@s390_trap_
$LN56@s390_trap_:
$LN7@s390_trap_:
  00509	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00511	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00514	0f ba e8 17	 bts	 eax, 23
  00518	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00523	33 c0		 xor	 eax, eax
  00525	85 c0		 test	 eax, eax
  00527	75 e0		 jne	 SHORT $LN7@s390_trap_
$LN55@s390_trap_:
  00529	33 c0		 xor	 eax, eax
  0052b	85 c0		 test	 eax, eax
  0052d	0f 85 d7 fd ff
	ff		 jne	 $LN4@s390_trap_

; 235  : 
; 236  :     trap_flags = REAL_ILC(regs) << 16;

  00533	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00541	83 e0 01	 and	 eax, 1
  00544	85 c0		 test	 eax, eax
  00546	75 0d		 jne	 SHORT $LN101@s390_trap_
  00548	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv294[rsp], 1
  00553	eb 0b		 jmp	 SHORT $LN102@s390_trap_
$LN101@s390_trap_:
  00555	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
$LN102@s390_trap_:
  00560	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv294[rsp], 0
  00568	74 0d		 je	 SHORT $LN105@s390_trap_
  0056a	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv301[rsp], 1
  00575	eb 0b		 jmp	 SHORT $LN106@s390_trap_
$LN105@s390_trap_:
  00577	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv301[rsp], 0
$LN106@s390_trap_:
  00582	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv301[rsp], 0
  0058a	74 18		 je	 SHORT $LN109@s390_trap_
  0058c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00594	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  0059b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
  005a2	eb 3d		 jmp	 SHORT $LN110@s390_trap_
$LN109@s390_trap_:
  005a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ac	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005b2	d1 e8		 shr	 eax, 1
  005b4	83 e0 01	 and	 eax, 1
  005b7	85 c0		 test	 eax, eax
  005b9	74 0d		 je	 SHORT $LN107@s390_trap_
  005bb	c7 84 24 88 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv308[rsp], 6
  005c6	eb 0b		 jmp	 SHORT $LN108@s390_trap_
$LN107@s390_trap_:
  005c8	c7 84 24 88 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv308[rsp], 4
$LN108@s390_trap_:
  005d3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv308[rsp]
  005da	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
$LN110@s390_trap_:
  005e1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  005e8	c1 e0 10	 shl	 eax, 16
  005eb	89 44 24 40	 mov	 DWORD PTR trap_flags$[rsp], eax

; 237  : 
; 238  :     if(unlikely(regs->execflag))

  005ef	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005fd	83 e0 01	 and	 eax, 1
  00600	85 c0		 test	 eax, eax
  00602	74 0d		 je	 SHORT $LN113@s390_trap_
  00604	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv320[rsp], 1
  0060f	eb 0b		 jmp	 SHORT $LN114@s390_trap_
$LN113@s390_trap_:
  00611	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv320[rsp], 0
$LN114@s390_trap_:
  0061c	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv320[rsp], 0
  00624	74 0c		 je	 SHORT $LN57@s390_trap_

; 239  :         trap_flags |= TRAP0_EXECUTE;

  00626	8b 44 24 40	 mov	 eax, DWORD PTR trap_flags$[rsp]
  0062a	0f ba e8 1f	 bts	 eax, 31
  0062e	89 44 24 40	 mov	 DWORD PTR trap_flags$[rsp], eax
$LN57@s390_trap_:

; 240  : 
; 241  :     if(trap_is_trap4)

  00632	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR trap_is_trap4$[rsp], 0
  0063a	74 0c		 je	 SHORT $LN58@s390_trap_

; 242  :         trap_flags |= TRAP0_TRAP4;

  0063c	8b 44 24 40	 mov	 eax, DWORD PTR trap_flags$[rsp]
  00640	0f ba e8 1e	 bts	 eax, 30
  00644	89 44 24 40	 mov	 DWORD PTR trap_flags$[rsp], eax
$LN58@s390_trap_:

; 243  : 
; 244  :     /* Trap flags at offset +0 */
; 245  :     STORE_FW(regs->mainstor + tsaa1, trap_flags);

  00648	8b 4c 24 40	 mov	 ecx, DWORD PTR trap_flags$[rsp]
  0064c	e8 00 00 00 00	 call	 _byteswap_ulong
  00651	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00659	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00660	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  00665	8b d0		 mov	 edx, eax
  00667	e8 00 00 00 00	 call	 store_fw_noswap

; 246  :     /* Reserved zero's stored at offset +4 */
; 247  :     STORE_FW(regs->mainstor + tsaa1 + 4, 0);

  0066c	33 c9		 xor	 ecx, ecx
  0066e	e8 00 00 00 00	 call	 _byteswap_ulong
  00673	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067b	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00682	48 8b 54 24 28	 mov	 rdx, QWORD PTR tsaa1$[rsp]
  00687	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  0068c	8b d0		 mov	 edx, eax
  0068e	e8 00 00 00 00	 call	 store_fw_noswap

; 248  : 
; 249  :     tsaa1 += 8;

  00693	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00698	48 83 c0 08	 add	 rax, 8
  0069c	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 250  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  006a1	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  006a6	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  006ac	48 85 c0	 test	 rax, rax
  006af	75 0a		 jne	 SHORT $LN59@s390_trap_

; 251  :         tsaa1 = tsaa2;

  006b1	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  006b6	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN59@s390_trap_:

; 252  : 
; 253  :     /* Bits 33-63 of Second-Op address of TRAP4 at offset +8 */
; 254  :     STORE_FW(regs->mainstor + tsaa1, trap_operand);

  006bb	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR trap_operand$[rsp]
  006c2	e8 00 00 00 00	 call	 _byteswap_ulong
  006c7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cf	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  006d6	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  006db	8b d0		 mov	 edx, eax
  006dd	e8 00 00 00 00	 call	 store_fw_noswap

; 255  :     /* Access register 15 at offset +12 */
; 256  :     STORE_FW(regs->mainstor + tsaa1 + 4, regs->AR(15));

  006e2	b8 04 00 00 00	 mov	 eax, 4
  006e7	48 6b c0 0f	 imul	 rax, rax, 15
  006eb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f3	8b 8c 01 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+768]
  006fa	e8 00 00 00 00	 call	 _byteswap_ulong
  006ff	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00707	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0070e	48 8b 54 24 28	 mov	 rdx, QWORD PTR tsaa1$[rsp]
  00713	48 8d 4c 11 04	 lea	 rcx, QWORD PTR [rcx+rdx+4]
  00718	8b d0		 mov	 edx, eax
  0071a	e8 00 00 00 00	 call	 store_fw_noswap

; 257  : 
; 258  :     tsaa1 += 8;

  0071f	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00724	48 83 c0 08	 add	 rax, 8
  00728	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 259  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  0072d	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00732	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00738	48 85 c0	 test	 rax, rax
  0073b	75 0a		 jne	 SHORT $LN60@s390_trap_

; 260  :         tsaa1 = tsaa2;

  0073d	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  00742	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN60@s390_trap_:

; 261  : 
; 262  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 263  :     /* If the P bit is one then store the PSW in esame format */
; 264  :     if(tcba0 & TCB0_P)
; 265  :         ARCH_DEP(store_psw) (regs, trap_psw);
; 266  :     else
; 267  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 268  :     {
; 269  :         s390_store_psw(regs, trap_psw);

  00747	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR trap_psw$[rsp]
  0074f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00757	e8 00 00 00 00	 call	 s390_store_psw

; 270  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 271  :         /* Set the notesame mode bit for a esa/390 psw */
; 272  :         trap_psw[1] |= 0x08;
; 273  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 274  :     }
; 275  : 
; 276  :     /* bits 0-63 of PSW at offset +16 */
; 277  :     memcpy(regs->mainstor + tsaa1, trap_psw, 8);

  0075c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00764	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0076b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tsaa1$[rsp]
  00770	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR trap_psw$[rsp]
  00778	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 278  :     tsaa1 += 8;

  0077c	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00781	48 83 c0 08	 add	 rax, 8
  00785	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 279  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  0078a	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0078f	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00795	48 85 c0	 test	 rax, rax
  00798	75 0a		 jne	 SHORT $LN61@s390_trap_

; 280  :     {
; 281  :         tsaa1 = tsaa2;

  0079a	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0079f	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN61@s390_trap_:

; 282  :     }
; 283  : 
; 284  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 285  :     /* If the P bit is one then store the PSW in esame format */
; 286  :     /* bits 64-127 of PSW at offset +24 */
; 287  :     if(tcba0 & TCB0_P)
; 288  :     {
; 289  :         memcpy(regs->mainstor + tsaa1, trap_psw + 8, 8);
; 290  :     }
; 291  :     else
; 292  :     {
; 293  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 294  :         memset(regs->mainstor + tsaa1, 0, 8);

  007a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ac	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  007b3	48 03 44 24 28	 add	 rax, QWORD PTR tsaa1$[rsp]
  007b8	48 8b f8	 mov	 rdi, rax
  007bb	33 c0		 xor	 eax, eax
  007bd	b9 08 00 00 00	 mov	 ecx, 8
  007c2	f3 aa		 rep stosb

; 295  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 296  :     }
; 297  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 298  :     tsaa1 += 8;

  007c4	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  007c9	48 83 c0 08	 add	 rax, 8
  007cd	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 299  :     if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  007d2	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  007d7	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  007dd	48 85 c0	 test	 rax, rax
  007e0	75 0a		 jne	 SHORT $LN62@s390_trap_

; 300  :         tsaa1 = tsaa2;

  007e2	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  007e7	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN62@s390_trap_:

; 301  : 
; 302  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 303  :     /* General registers at offset +32 */
; 304  :     if(tcba0 & TCB0_R)
; 305  :         for(i = 0; i < 16; i++)
; 306  :         {
; 307  :             STORE_DW(regs->mainstor + tsaa1, regs->GR_G(i));
; 308  :             tsaa1 += 8;
; 309  :             if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)
; 310  :                 tsaa1 = tsaa2;
; 311  :         }
; 312  :     else
; 313  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 314  :         for(i = 0; i < 16; i++)

  007ec	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007f4	eb 0a		 jmp	 SHORT $LN10@s390_trap_
$LN8@s390_trap_:
  007f6	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  007fa	ff c0		 inc	 eax
  007fc	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_trap_:
  00800	83 7c 24 44 10	 cmp	 DWORD PTR i$[rsp], 16
  00805	7d 5e		 jge	 SHORT $LN9@s390_trap_

; 315  :         {
; 316  :             STORE_FW(regs->mainstor + tsaa1, regs->GR_L(i));

  00807	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0080c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00814	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0081b	e8 00 00 00 00	 call	 _byteswap_ulong
  00820	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00828	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0082f	48 03 4c 24 28	 add	 rcx, QWORD PTR tsaa1$[rsp]
  00834	8b d0		 mov	 edx, eax
  00836	e8 00 00 00 00	 call	 store_fw_noswap

; 317  :             tsaa1 += 4;

  0083b	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  00840	48 83 c0 04	 add	 rax, 4
  00844	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax

; 318  :             if((tsaa1 & PAGEFRAME_BYTEMASK) == 0)

  00849	48 8b 44 24 28	 mov	 rax, QWORD PTR tsaa1$[rsp]
  0084e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00854	48 85 c0	 test	 rax, rax
  00857	75 0a		 jne	 SHORT $LN63@s390_trap_

; 319  :                 tsaa1 = tsaa2;

  00859	48 8b 44 24 50	 mov	 rax, QWORD PTR tsaa2$[rsp]
  0085e	48 89 44 24 28	 mov	 QWORD PTR tsaa1$[rsp], rax
$LN63@s390_trap_:

; 320  :         }

  00863	eb 91		 jmp	 SHORT $LN8@s390_trap_
$LN9@s390_trap_:

; 321  : 
; 322  :     /* Load the Trap Control Block Address in gr15 */
; 323  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 324  :     if(regs->psw.amode64)
; 325  :         regs->GR(15) = duct11 & DUCT11_TCBA & 0x00000000FFFFFFFF;
; 326  :     else
; 327  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)*/
; 328  :         regs->GR_L(15) = duct11 & DUCT11_TCBA;

  00865	8b 44 24 58	 mov	 eax, DWORD PTR duct11$[rsp]
  00869	25 f8 ff ff 7f	 and	 eax, 2147483640		; 7ffffff8H
  0086e	b9 08 00 00 00	 mov	 ecx, 8
  00873	48 6b c9 0f	 imul	 rcx, rcx, 15
  00877	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0087f	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN13@s390_trap_:

; 329  : 
; 330  :     /* Ensure psw.IA is set */
; 331  :     MAYBE_SET_PSW_IA_FROM_IP(regs);

  00886	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0088e	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00896	74 4e		 je	 SHORT $LN64@s390_trap_
  00898	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  008a6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ae	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008b6	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  008bd	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  008c1	48 2b ca	 sub	 rcx, rdx
  008c4	48 03 c1	 add	 rax, rcx
  008c7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cf	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  008d5	48 23 c1	 and	 rax, rcx
  008d8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e0	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN64@s390_trap_:
  008e6	33 c0		 xor	 eax, eax
  008e8	85 c0		 test	 eax, eax
  008ea	75 9a		 jne	 SHORT $LN13@s390_trap_

; 332  : 
; 333  :     /* Set the Breaking Event Address Register */
; 334  :     if (trap_is_trap4)
; 335  :     {
; 336  :         SET_BEAR_REG( regs, regs->ip - 4 );
; 337  :     }
; 338  :     else
; 339  :     {
; 340  :         SET_BEAR_REG( regs, regs->ip - 2 );
; 341  :     }
; 342  : 
; 343  :     regs->psw.amode = 1;

  008ec	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008fa	83 c8 02	 or	 eax, 2
  008fd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00905	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 344  :     regs->psw.AMASK = AMASK31;

  0090b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00913	c7 80 90 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR [rax+144], 2147483647 ; 7fffffffH
$LN16@s390_trap_:

; 345  :     SET_PSW_IA_AND_MAYBE_IP(regs, trap_ia);

  0091d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00925	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0092b	8b 4c 24 30	 mov	 ecx, DWORD PTR trap_ia$[rsp]
  0092f	23 c8		 and	 ecx, eax
  00931	8b c1		 mov	 eax, ecx
  00933	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093b	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00941	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00949	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00951	74 6e		 je	 SHORT $LN67@s390_trap_
  00953	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00961	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  00966	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096e	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  00974	75 38		 jne	 SHORT $LN68@s390_trap_
  00976	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0097e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00984	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00989	8b c0		 mov	 eax, eax
  0098b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00993	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0099a	48 0b c8	 or	 rcx, rax
  0099d	48 8b c1	 mov	 rax, rcx
  009a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a8	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  009ac	eb 13		 jmp	 SHORT $LN69@s390_trap_
$LN68@s390_trap_:
  009ae	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b6	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN69@s390_trap_:
$LN67@s390_trap_:
  009c1	33 c0		 xor	 eax, eax
  009c3	85 c0		 test	 eax, eax
  009c5	0f 85 52 ff ff
	ff		 jne	 $LN16@s390_trap_

; 346  :     /* set PSW to primary space */
; 347  :     regs->psw.asc = 0;

  009cb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	c6 40 7b 00	 mov	 BYTE PTR [rax+123], 0
$LN19@s390_trap_:

; 348  :     SET_AEA_MODE(regs);

  009d7	b8 04 00 00 00	 mov	 eax, 4
  009dc	48 6b c0 04	 imul	 rax, rax, 4
  009e0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e8	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  009ef	89 84 24 a4 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  009f6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009fe	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00a05	88 44 24 34	 mov	 BYTE PTR oldmode$2[rsp], al
  00a09	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a11	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00a15	83 e0 04	 and	 eax, 4
  00a18	85 c0		 test	 eax, eax
  00a1a	75 6c		 jne	 SHORT $LN117@s390_trap_
  00a1c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a24	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a2a	d1 e8		 shr	 eax, 1
  00a2c	83 e0 01	 and	 eax, 1
  00a2f	85 c0		 test	 eax, eax
  00a31	74 3a		 je	 SHORT $LN115@s390_trap_
  00a33	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a3b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a42	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00a46	83 e0 01	 and	 eax, 1
  00a49	85 c0		 test	 eax, eax
  00a4b	74 20		 je	 SHORT $LN115@s390_trap_
  00a4d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a55	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00a59	83 e0 40	 and	 eax, 64			; 00000040H
  00a5c	85 c0		 test	 eax, eax
  00a5e	74 0d		 je	 SHORT $LN115@s390_trap_
  00a60	c7 84 24 94 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv463[rsp], 2
  00a6b	eb 0b		 jmp	 SHORT $LN116@s390_trap_
$LN115@s390_trap_:
  00a6d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv463[rsp], 0
$LN116@s390_trap_:
  00a78	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv463[rsp]
  00a7f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
  00a86	eb 18		 jmp	 SHORT $LN118@s390_trap_
$LN117@s390_trap_:
  00a88	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a90	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00a94	c1 f8 06	 sar	 eax, 6
  00a97	ff c0		 inc	 eax
  00a99	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
$LN118@s390_trap_:
  00aa0	33 c0		 xor	 eax, eax
  00aa2	85 c0		 test	 eax, eax
  00aa4	75 51		 jne	 SHORT $LN119@s390_trap_
  00aa6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aae	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00ab2	83 e0 40	 and	 eax, 64			; 00000040H
  00ab5	85 c0		 test	 eax, eax
  00ab7	75 3e		 jne	 SHORT $LN119@s390_trap_
  00ab9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00ac7	d1 e8		 shr	 eax, 1
  00ac9	83 e0 01	 and	 eax, 1
  00acc	85 c0		 test	 eax, eax
  00ace	74 1a		 je	 SHORT $LN120@s390_trap_
  00ad0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00adf	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00ae3	83 e0 01	 and	 eax, 1
  00ae6	85 c0		 test	 eax, eax
  00ae8	75 0d		 jne	 SHORT $LN119@s390_trap_
$LN120@s390_trap_:
  00aea	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv483[rsp], 0
  00af5	eb 0b		 jmp	 SHORT $LN121@s390_trap_
$LN119@s390_trap_:
  00af7	c7 84 24 98 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv483[rsp], 64 ; 00000040H
$LN121@s390_trap_:
  00b02	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv483[rsp]
  00b09	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv468[rsp]
  00b10	0b c8		 or	 ecx, eax
  00b12	8b c1		 mov	 eax, ecx
  00b14	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b1c	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00b22	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b2a	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00b31	83 e0 0f	 and	 eax, 15
  00b34	89 44 24 48	 mov	 DWORD PTR tv489[rsp], eax
  00b38	83 7c 24 48 01	 cmp	 DWORD PTR tv489[rsp], 1
  00b3d	74 22		 je	 SHORT $LN70@s390_trap_
  00b3f	83 7c 24 48 02	 cmp	 DWORD PTR tv489[rsp], 2
  00b44	74 59		 je	 SHORT $LN71@s390_trap_
  00b46	83 7c 24 48 03	 cmp	 DWORD PTR tv489[rsp], 3
  00b4b	0f 84 11 01 00
	00		 je	 $LN75@s390_trap_
  00b51	83 7c 24 48 04	 cmp	 DWORD PTR tv489[rsp], 4
  00b56	0f 84 5d 01 00
	00		 je	 $LN76@s390_trap_
  00b5c	e9 93 01 00 00	 jmp	 $LN77@s390_trap_
$LN70@s390_trap_:
  00b61	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00b69	eb 0a		 jmp	 SHORT $LN24@s390_trap_
$LN22@s390_trap_:
  00b6b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00b6f	ff c0		 inc	 eax
  00b71	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN24@s390_trap_:
  00b75	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00b7a	7d 1e		 jge	 SHORT $LN23@s390_trap_
  00b7c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00b80	83 c0 05	 add	 eax, 5
  00b83	48 98		 cdqe
  00b85	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b8d	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00b98	eb d1		 jmp	 SHORT $LN22@s390_trap_
$LN23@s390_trap_:
  00b9a	e9 8e 01 00 00	 jmp	 $LN20@s390_trap_
$LN71@s390_trap_:
  00b9f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00ba7	eb 0a		 jmp	 SHORT $LN27@s390_trap_
$LN25@s390_trap_:
  00ba9	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00bad	ff c0		 inc	 eax
  00baf	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN27@s390_trap_:
  00bb3	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00bb8	7d 1e		 jge	 SHORT $LN26@s390_trap_
  00bba	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00bbe	83 c0 05	 add	 eax, 5
  00bc1	48 98		 cdqe
  00bc3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bcb	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00bd6	eb d1		 jmp	 SHORT $LN25@s390_trap_
$LN26@s390_trap_:
  00bd8	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00be0	eb 0a		 jmp	 SHORT $LN30@s390_trap_
$LN28@s390_trap_:
  00be2	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00be6	ff c0		 inc	 eax
  00be8	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN30@s390_trap_:
  00bec	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00bf1	7d 6a		 jge	 SHORT $LN29@s390_trap_
  00bf3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00bf8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c00	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00c08	75 1e		 jne	 SHORT $LN72@s390_trap_
  00c0a	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00c0e	83 c0 05	 add	 eax, 5
  00c11	48 98		 cdqe
  00c13	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c1b	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00c26	eb 33		 jmp	 SHORT $LN73@s390_trap_
$LN72@s390_trap_:
  00c28	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00c2d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c35	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00c3d	74 1c		 je	 SHORT $LN74@s390_trap_
  00c3f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00c43	83 c0 05	 add	 eax, 5
  00c46	48 98		 cdqe
  00c48	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c50	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN74@s390_trap_:
$LN73@s390_trap_:
  00c5b	eb 85		 jmp	 SHORT $LN28@s390_trap_
$LN29@s390_trap_:
  00c5d	e9 cb 00 00 00	 jmp	 $LN20@s390_trap_
$LN75@s390_trap_:
  00c62	b8 04 00 00 00	 mov	 eax, 4
  00c67	48 6b c0 04	 imul	 rax, rax, 4
  00c6b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c73	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00c7e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00c86	eb 0a		 jmp	 SHORT $LN33@s390_trap_
$LN31@s390_trap_:
  00c88	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00c8c	ff c0		 inc	 eax
  00c8e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN33@s390_trap_:
  00c92	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00c97	7d 1e		 jge	 SHORT $LN32@s390_trap_
  00c99	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00c9d	83 c0 05	 add	 eax, 5
  00ca0	48 98		 cdqe
  00ca2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00caa	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00cb5	eb d1		 jmp	 SHORT $LN31@s390_trap_
$LN32@s390_trap_:
  00cb7	eb 74		 jmp	 SHORT $LN20@s390_trap_
$LN76@s390_trap_:
  00cb9	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00cc1	eb 0a		 jmp	 SHORT $LN36@s390_trap_
$LN34@s390_trap_:
  00cc3	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00cc7	ff c0		 inc	 eax
  00cc9	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN36@s390_trap_:
  00ccd	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00cd2	7d 1e		 jge	 SHORT $LN35@s390_trap_
  00cd4	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00cd8	83 c0 05	 add	 eax, 5
  00cdb	48 98		 cdqe
  00cdd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce5	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  00cf0	eb d1		 jmp	 SHORT $LN34@s390_trap_
$LN35@s390_trap_:
  00cf2	eb 39		 jmp	 SHORT $LN20@s390_trap_
$LN77@s390_trap_:
  00cf4	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00cfc	eb 0a		 jmp	 SHORT $LN39@s390_trap_
$LN37@s390_trap_:
  00cfe	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00d02	ff c0		 inc	 eax
  00d04	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN39@s390_trap_:
  00d08	83 7c 24 20 10	 cmp	 DWORD PTR i$1[rsp], 16
  00d0d	7d 1e		 jge	 SHORT $LN38@s390_trap_
  00d0f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00d13	83 c0 05	 add	 eax, 5
  00d16	48 98		 cdqe
  00d18	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d20	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  00d2b	eb d1		 jmp	 SHORT $LN37@s390_trap_
$LN38@s390_trap_:
$LN20@s390_trap_:
  00d2d	b8 04 00 00 00	 mov	 eax, 4
  00d32	48 6b c0 04	 imul	 rax, rax, 4
  00d36	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d3e	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00d45	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00d4c	74 79		 je	 SHORT $LN78@s390_trap_
$LN42@s390_trap_:
  00d4e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d56	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00d5e	74 61		 je	 SHORT $LN79@s390_trap_
  00d60	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d68	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00d6e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d76	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d7e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00d85	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00d89	48 2b ca	 sub	 rcx, rdx
  00d8c	48 03 c1	 add	 rax, rcx
  00d8f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d97	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00d9d	48 23 c1	 and	 rax, rcx
  00da0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00da8	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00dae	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00db6	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN79@s390_trap_:
  00dc1	33 c0		 xor	 eax, eax
  00dc3	85 c0		 test	 eax, eax
  00dc5	75 87		 jne	 SHORT $LN42@s390_trap_
$LN78@s390_trap_:
  00dc7	0f b6 44 24 34	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00dcc	83 e0 40	 and	 eax, 64			; 00000040H
  00dcf	85 c0		 test	 eax, eax
  00dd1	0f 85 f0 00 00
	00		 jne	 $LN80@s390_trap_
  00dd7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ddf	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00de6	83 e0 40	 and	 eax, 64			; 00000040H
  00de9	85 c0		 test	 eax, eax
  00deb	0f 84 d6 00 00
	00		 je	 $LN80@s390_trap_
$LN45@s390_trap_:
  00df1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df9	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00e01	74 61		 je	 SHORT $LN81@s390_trap_
  00e03	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e0b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00e11	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e19	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e21	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00e28	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00e2c	48 2b ca	 sub	 rcx, rdx
  00e2f	48 03 c1	 add	 rax, rcx
  00e32	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e3a	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00e40	48 23 c1	 and	 rax, rcx
  00e43	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e4b	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00e51	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e59	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN81@s390_trap_:
  00e64	33 c0		 xor	 eax, eax
  00e66	85 c0		 test	 eax, eax
  00e68	75 87		 jne	 SHORT $LN45@s390_trap_
  00e6a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e72	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00e78	c1 e8 02	 shr	 eax, 2
  00e7b	83 e0 01	 and	 eax, 1
  00e7e	85 c0		 test	 eax, eax
  00e80	74 0d		 je	 SHORT $LN124@s390_trap_
  00e82	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv605[rsp], 1
  00e8d	eb 0b		 jmp	 SHORT $LN125@s390_trap_
$LN124@s390_trap_:
  00e8f	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv605[rsp], 0
$LN125@s390_trap_:
  00e9a	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv605[rsp], 0
  00ea2	74 23		 je	 SHORT $LN82@s390_trap_
  00ea4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00eac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00eaf	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00eb4	85 c0		 test	 eax, eax
  00eb6	74 0f		 je	 SHORT $LN82@s390_trap_
  00eb8	b2 fc		 mov	 dl, 252			; 000000fcH
  00eba	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec2	e8 00 00 00 00	 call	 s390_invalidate_tlb
$LN82@s390_trap_:
$LN80@s390_trap_:
  00ec7	33 c0		 xor	 eax, eax
  00ec9	85 c0		 test	 eax, eax
  00ecb	0f 85 06 fb ff
	ff		 jne	 $LN19@s390_trap_

; 349  : 
; 350  : } /* end function ARCH_DEP(trap_x) */

  00ed1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ed9	48 33 cc	 xor	 rcx, rsp
  00edc	e8 00 00 00 00	 call	 __security_check_cookie
  00ee1	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00ee8	5f		 pop	 rdi
  00ee9	c3		 ret	 0
s390_trap_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
