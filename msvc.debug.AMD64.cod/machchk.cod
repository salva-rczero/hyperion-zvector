; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	s370_present_mck_interrupt
PUBLIC	machine_check_crwpend
PUBLIC	build_attach_chrpt
PUBLIC	build_detach_chrpt
PUBLIC	build_chp_reset_chrpt
PUBLIC	queue_channel_report
PUBLIC	get_next_channel_report_word
PUBLIC	s390_present_mck_interrupt
PUBLIC	z900_present_mck_interrupt
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_try_obtain_lock:PROC
EXTRN	__imp_hthread_have_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$s370_present_mck_interrupt DD imagerel $LN23
	DD	imagerel $LN23+252
	DD	imagerel $unwind$s370_present_mck_interrupt
$pdata$machine_check_crwpend DD imagerel $LN15
	DD	imagerel $LN15+391
	DD	imagerel $unwind$machine_check_crwpend
$pdata$build_attach_chrpt DD imagerel $LN19
	DD	imagerel $LN19+438
	DD	imagerel $unwind$build_attach_chrpt
$pdata$build_detach_chrpt DD imagerel $LN19
	DD	imagerel $LN19+438
	DD	imagerel $unwind$build_detach_chrpt
$pdata$build_chp_reset_chrpt DD imagerel $LN17
	DD	imagerel $LN17+310
	DD	imagerel $unwind$build_chp_reset_chrpt
$pdata$queue_channel_report DD imagerel $LN7
	DD	imagerel $LN7+492
	DD	imagerel $unwind$queue_channel_report
$pdata$get_next_channel_report_word DD imagerel $LN36
	DD	imagerel $LN36+601
	DD	imagerel $unwind$get_next_channel_report_word
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$s390_present_mck_interrupt DD imagerel $LN33
	DD	imagerel $LN33+550
	DD	imagerel $unwind$s390_present_mck_interrupt
$pdata$z900_present_mck_interrupt DD imagerel $LN33
	DD	imagerel $LN33+550
	DD	imagerel $unwind$z900_present_mck_interrupt
pdata	ENDS
_DATA	SEGMENT
$SG168137 DB	'build_chp_reset_chrpt', 00H
	ORG $+2
$SG168138 DB	'machchk.c', 00H
	ORG $+14
$SG168139 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168141 DB	'build_chp_reset_chrpt', 00H
	ORG $+2
$SG168142 DB	'machchk.c', 00H
	ORG $+6
$SG168143 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168162 DB	'machchk.c:77', 00H
	ORG $+3
$SG168164 DB	'machchk.c:83', 00H
	ORG $+3
$SG168167 DB	'build_attach_chrpt', 00H
	ORG $+5
$SG168168 DB	'machchk.c', 00H
	ORG $+6
$SG168169 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168171 DB	'build_attach_chrpt', 00H
	ORG $+5
$SG168172 DB	'machchk.c', 00H
	ORG $+6
$SG168173 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168192 DB	'machchk.c:121', 00H
	ORG $+2
$SG168194 DB	'machchk.c:127', 00H
	ORG $+2
$SG168197 DB	'build_detach_chrpt', 00H
	ORG $+5
$SG168198 DB	'machchk.c', 00H
	ORG $+6
$SG168199 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168201 DB	'build_detach_chrpt', 00H
	ORG $+5
$SG168202 DB	'machchk.c', 00H
	ORG $+6
$SG168203 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168216 DB	'machchk.c:157', 00H
	ORG $+2
$SG168220 DB	'machchk.c:170', 00H
	ORG $+2
$SG168222 DB	'machchk.c:189', 00H
	ORG $+2
$SG168242 DB	'machchk.c:206', 00H
	ORG $+2
$SG168247 DB	'machchk.c:208', 00H
	ORG $+2
$SG168249 DB	'machchk.c:210', 00H
	ORG $+2
$SG168275 DB	'machchk.c:223', 00H
	ORG $+2
$SG168277 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168278 DB	'machchk.c', 00H
	ORG $+14
$SG168279 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168281 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168282 DB	'machchk.c', 00H
	ORG $+14
$SG168283 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168286 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168287 DB	'machchk.c', 00H
	ORG $+14
$SG168288 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168290 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168291 DB	'machchk.c', 00H
	ORG $+14
$SG168292 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168298 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168299 DB	'machchk.c', 00H
	ORG $+14
$SG168300 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168302 DB	'get_next_channel_report_word', 00H
	ORG $+3
$SG168303 DB	'machchk.c', 00H
	ORG $+14
$SG168304 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168306 DB	'machchk.c:239', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_chp_reset_chrpt
	DD	01bH
	DD	0124H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_detach_chrpt
	DD	013H
	DD	01a4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_attach_chrpt
	DD	013H
	DD	01a4H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$s370_present_mck_interrupt DD 011801H
	DD	02218H
$unwind$machine_check_crwpend DD 010401H
	DD	06204H
$unwind$build_attach_chrpt DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$build_detach_chrpt DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$build_chp_reset_chrpt DD 012019H
	DD	0c211H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$queue_channel_report DD 030f01H
	DD	0700b620fH
	DD	0600aH
$unwind$get_next_channel_report_word DD 010901H
	DD	06209H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s390_present_mck_interrupt DD 011801H
	DD	04218H
$unwind$z900_present_mck_interrupt DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
i$1 = 0
i$2 = 4
rc$ = 8
mask$3 = 16
mask$4 = 24
regs$ = 48
mcic$ = 56
xdmg$ = 64
fsta$ = 72
z900_present_mck_interrupt PROC

; 264  : {

$LN33:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 265  : int rc = 0;

  00018	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@z900_prese:

; 266  : 
; 267  :     UNREFERENCED_370(regs);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN4@z900_prese
$LN7@z900_prese:

; 268  :     UNREFERENCED_370(mcic);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN7@z900_prese
$LN10@z900_prese:

; 269  :     UNREFERENCED_370(xdmg);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN10@z900_prese
$LN13@z900_prese:

; 270  :     UNREFERENCED_370(fsta);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN13@z900_prese

; 271  : 
; 272  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 273  :     /* If there is a crw pending and we are enabled for the channel
; 274  :        report interrupt subclass then process the interrupt */
; 275  :     if( OPEN_IC_CHANRPT(regs) )

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00045	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00048	23 c1		 and	 eax, ecx
  0004a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0004f	85 c0		 test	 eax, eax
  00051	0f 84 ec 00 00
	00		 je	 $LN26@z900_prese

; 276  :     {
; 277  :         *mcic =  MCIC_CP |

  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR mcic$[rsp]
  0005c	48 b9 00 00 3b
	40 1d 0f 40 00	 mov	 rcx, 18031016815558656	; 00400f1d403b0000H
  00066	48 89 08	 mov	 QWORD PTR [rax], rcx

; 278  :                MCIC_WP |
; 279  :                MCIC_MS |
; 280  :                MCIC_PM |
; 281  :                MCIC_IA |
; 282  : #ifdef FEATURE_HEXADECIMAL_FLOATING_POINT
; 283  :                MCIC_FP |
; 284  : #endif /*FEATURE_HEXADECIMAL_FLOATING_POINT*/
; 285  :                MCIC_GR |
; 286  :                MCIC_CR |
; 287  :                MCIC_ST |
; 288  : #ifdef FEATURE_ACCESS_REGISTERS
; 289  :                MCIC_AR |
; 290  : #endif /*FEATURE_ACCESS_REGISTERS*/
; 291  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)
; 292  :                MCIC_PR |
; 293  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)*/
; 294  : #if defined(FEATURE_BINARY_FLOATING_POINT)
; 295  :                MCIC_XF |
; 296  : #endif /*defined(FEATURE_BINARY_FLOATING_POINT)*/
; 297  :                MCIC_AP |
; 298  :                MCIC_CT |
; 299  :                MCIC_CC ;
; 300  :         *xdmg = 0;

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR xdmg$[rsp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 301  :         *fsta = 0;

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR fsta$[rsp]
  00079	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN16@z900_prese:

; 302  :         OFF_IC_CHANRPT;

  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0008d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00092	85 c0		 test	 eax, eax
  00094	0f 84 97 00 00
	00		 je	 $LN27@z900_prese
  0009a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a1	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000a7	0f ba f0 1c	 btr	 eax, 28
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bf	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000c6	48 89 44 24 10	 mov	 QWORD PTR mask$3[rsp], rax
  000cb	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  000d2	eb 08		 jmp	 SHORT $LN19@z900_prese
$LN17@z900_prese:
  000d4	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  000d7	ff c0		 inc	 eax
  000d9	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN19@z900_prese:
  000dc	48 83 7c 24 10
	00		 cmp	 QWORD PTR mask$3[rsp], 0
  000e2	74 4d		 je	 SHORT $LN18@z900_prese
  000e4	48 8b 44 24 10	 mov	 rax, QWORD PTR mask$3[rsp]
  000e9	48 83 e0 01	 and	 rax, 1
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 30		 je	 SHORT $LN28@z900_prese
  000f2	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000fd	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00105	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00108	0f ba f0 1c	 btr	 eax, 28
  0010c	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00110	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00117	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0011f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN28@z900_prese:
  00122	48 8b 44 24 10	 mov	 rax, QWORD PTR mask$3[rsp]
  00127	48 d1 e8	 shr	 rax, 1
  0012a	48 89 44 24 10	 mov	 QWORD PTR mask$3[rsp], rax
  0012f	eb a3		 jmp	 SHORT $LN17@z900_prese
$LN18@z900_prese:
$LN27@z900_prese:
  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	0f 85 45 ff ff
	ff		 jne	 $LN16@z900_prese

; 303  :         rc = 1;

  0013b	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN26@z900_prese:

; 304  :     }
; 305  : 
; 306  :     if(!IS_IC_CHANRPT)

  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00150	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00155	85 c0		 test	 eax, eax
  00157	0f 85 c0 00 00
	00		 jne	 $LN29@z900_prese
$LN22@z900_prese:

; 307  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 308  :         OFF_IC_CHANRPT;

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00164	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0016a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0016f	85 c0		 test	 eax, eax
  00171	0f 84 9c 00 00
	00		 je	 $LN30@z900_prese
  00177	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017e	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00184	0f ba f0 1c	 btr	 eax, 28
  00188	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0018f	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019c	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  001a3	48 89 44 24 18	 mov	 QWORD PTR mask$4[rsp], rax
  001a8	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  001b0	eb 0a		 jmp	 SHORT $LN25@z900_prese
$LN23@z900_prese:
  001b2	8b 44 24 04	 mov	 eax, DWORD PTR i$2[rsp]
  001b6	ff c0		 inc	 eax
  001b8	89 44 24 04	 mov	 DWORD PTR i$2[rsp], eax
$LN25@z900_prese:
  001bc	48 83 7c 24 18
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  001c2	74 4f		 je	 SHORT $LN24@z900_prese
  001c4	48 8b 44 24 18	 mov	 rax, QWORD PTR mask$4[rsp]
  001c9	48 83 e0 01	 and	 rax, 1
  001cd	48 85 c0	 test	 rax, rax
  001d0	74 32		 je	 SHORT $LN31@z900_prese
  001d2	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$2[rsp]
  001d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001de	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001e6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001e9	0f ba f0 1c	 btr	 eax, 28
  001ed	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$2[rsp]
  001f2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001f9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00201	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN31@z900_prese:
  00204	48 8b 44 24 18	 mov	 rax, QWORD PTR mask$4[rsp]
  00209	48 d1 e8	 shr	 rax, 1
  0020c	48 89 44 24 18	 mov	 QWORD PTR mask$4[rsp], rax
  00211	eb 9f		 jmp	 SHORT $LN23@z900_prese
$LN24@z900_prese:
$LN30@z900_prese:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 40 ff ff
	ff		 jne	 $LN22@z900_prese
$LN29@z900_prese:

; 309  : 
; 310  :     return rc;

  0021d	8b 44 24 08	 mov	 eax, DWORD PTR rc$[rsp]

; 311  : } /* end function present_mck_interrupt */

  00221	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00225	c3		 ret	 0
z900_present_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
i$1 = 0
i$2 = 4
rc$ = 8
mask$3 = 16
mask$4 = 24
regs$ = 48
mcic$ = 56
xdmg$ = 64
fsta$ = 72
s390_present_mck_interrupt PROC

; 264  : {

$LN33:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 265  : int rc = 0;

  00018	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@s390_prese:

; 266  : 
; 267  :     UNREFERENCED_370(regs);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN4@s390_prese
$LN7@s390_prese:

; 268  :     UNREFERENCED_370(mcic);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN7@s390_prese
$LN10@s390_prese:

; 269  :     UNREFERENCED_370(xdmg);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN10@s390_prese
$LN13@s390_prese:

; 270  :     UNREFERENCED_370(fsta);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN13@s390_prese

; 271  : 
; 272  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 273  :     /* If there is a crw pending and we are enabled for the channel
; 274  :        report interrupt subclass then process the interrupt */
; 275  :     if( OPEN_IC_CHANRPT(regs) )

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00045	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00048	23 c1		 and	 eax, ecx
  0004a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0004f	85 c0		 test	 eax, eax
  00051	0f 84 ec 00 00
	00		 je	 $LN26@s390_prese

; 276  :     {
; 277  :         *mcic =  MCIC_CP |

  00057	48 8b 44 24 38	 mov	 rax, QWORD PTR mcic$[rsp]
  0005c	48 b9 00 00 1b
	40 1d 0f 40 00	 mov	 rcx, 18031016813461504	; 00400f1d401b0000H
  00066	48 89 08	 mov	 QWORD PTR [rax], rcx

; 278  :                MCIC_WP |
; 279  :                MCIC_MS |
; 280  :                MCIC_PM |
; 281  :                MCIC_IA |
; 282  : #ifdef FEATURE_HEXADECIMAL_FLOATING_POINT
; 283  :                MCIC_FP |
; 284  : #endif /*FEATURE_HEXADECIMAL_FLOATING_POINT*/
; 285  :                MCIC_GR |
; 286  :                MCIC_CR |
; 287  :                MCIC_ST |
; 288  : #ifdef FEATURE_ACCESS_REGISTERS
; 289  :                MCIC_AR |
; 290  : #endif /*FEATURE_ACCESS_REGISTERS*/
; 291  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)
; 292  :                MCIC_PR |
; 293  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)*/
; 294  : #if defined(FEATURE_BINARY_FLOATING_POINT)
; 295  :                MCIC_XF |
; 296  : #endif /*defined(FEATURE_BINARY_FLOATING_POINT)*/
; 297  :                MCIC_AP |
; 298  :                MCIC_CT |
; 299  :                MCIC_CC ;
; 300  :         *xdmg = 0;

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR xdmg$[rsp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 301  :         *fsta = 0;

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR fsta$[rsp]
  00079	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN16@s390_prese:

; 302  :         OFF_IC_CHANRPT;

  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0008d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00092	85 c0		 test	 eax, eax
  00094	0f 84 97 00 00
	00		 je	 $LN27@s390_prese
  0009a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a1	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000a7	0f ba f0 1c	 btr	 eax, 28
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bf	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000c6	48 89 44 24 10	 mov	 QWORD PTR mask$3[rsp], rax
  000cb	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  000d2	eb 08		 jmp	 SHORT $LN19@s390_prese
$LN17@s390_prese:
  000d4	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  000d7	ff c0		 inc	 eax
  000d9	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN19@s390_prese:
  000dc	48 83 7c 24 10
	00		 cmp	 QWORD PTR mask$3[rsp], 0
  000e2	74 4d		 je	 SHORT $LN18@s390_prese
  000e4	48 8b 44 24 10	 mov	 rax, QWORD PTR mask$3[rsp]
  000e9	48 83 e0 01	 and	 rax, 1
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 30		 je	 SHORT $LN28@s390_prese
  000f2	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000fd	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00105	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00108	0f ba f0 1c	 btr	 eax, 28
  0010c	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00110	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00117	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0011f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN28@s390_prese:
  00122	48 8b 44 24 10	 mov	 rax, QWORD PTR mask$3[rsp]
  00127	48 d1 e8	 shr	 rax, 1
  0012a	48 89 44 24 10	 mov	 QWORD PTR mask$3[rsp], rax
  0012f	eb a3		 jmp	 SHORT $LN17@s390_prese
$LN18@s390_prese:
$LN27@s390_prese:
  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	0f 85 45 ff ff
	ff		 jne	 $LN16@s390_prese

; 303  :         rc = 1;

  0013b	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN26@s390_prese:

; 304  :     }
; 305  : 
; 306  :     if(!IS_IC_CHANRPT)

  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00150	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00155	85 c0		 test	 eax, eax
  00157	0f 85 c0 00 00
	00		 jne	 $LN29@s390_prese
$LN22@s390_prese:

; 307  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 308  :         OFF_IC_CHANRPT;

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00164	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0016a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0016f	85 c0		 test	 eax, eax
  00171	0f 84 9c 00 00
	00		 je	 $LN30@s390_prese
  00177	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017e	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00184	0f ba f0 1c	 btr	 eax, 28
  00188	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0018f	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019c	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  001a3	48 89 44 24 18	 mov	 QWORD PTR mask$4[rsp], rax
  001a8	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  001b0	eb 0a		 jmp	 SHORT $LN25@s390_prese
$LN23@s390_prese:
  001b2	8b 44 24 04	 mov	 eax, DWORD PTR i$2[rsp]
  001b6	ff c0		 inc	 eax
  001b8	89 44 24 04	 mov	 DWORD PTR i$2[rsp], eax
$LN25@s390_prese:
  001bc	48 83 7c 24 18
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  001c2	74 4f		 je	 SHORT $LN24@s390_prese
  001c4	48 8b 44 24 18	 mov	 rax, QWORD PTR mask$4[rsp]
  001c9	48 83 e0 01	 and	 rax, 1
  001cd	48 85 c0	 test	 rax, rax
  001d0	74 32		 je	 SHORT $LN31@s390_prese
  001d2	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$2[rsp]
  001d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001de	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001e6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001e9	0f ba f0 1c	 btr	 eax, 28
  001ed	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$2[rsp]
  001f2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001f9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00201	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN31@s390_prese:
  00204	48 8b 44 24 18	 mov	 rax, QWORD PTR mask$4[rsp]
  00209	48 d1 e8	 shr	 rax, 1
  0020c	48 89 44 24 18	 mov	 QWORD PTR mask$4[rsp], rax
  00211	eb 9f		 jmp	 SHORT $LN23@s390_prese
$LN24@s390_prese:
$LN30@s390_prese:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 40 ff ff
	ff		 jne	 $LN22@s390_prese
$LN29@s390_prese:

; 309  : 
; 310  :     return rc;

  0021d	8b 44 24 08	 mov	 eax, DWORD PTR rc$[rsp]

; 311  : } /* end function present_mck_interrupt */

  00221	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00225	c3		 ret	 0
s390_present_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
crw$ = 32
regs$ = 64
get_next_channel_report_word PROC

; 219  : {

$LN36:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 220  : U32 crw = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR crw$[rsp], 0
$LN4@get_next_c:

; 221  : 
; 222  :     UNREFERENCED(regs);

  00011	33 c0		 xor	 eax, eax
  00013	85 c0		 test	 eax, eax
  00015	75 fa		 jne	 SHORT $LN4@get_next_c

; 223  :     OBTAIN_CRWLOCK();

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168275
  0002b	48 8b c8	 mov	 rcx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN7@get_next_c:

; 224  :     ASSERT( sysblk.crwindex <= sysblk.crwcount );

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	8b 89 1c 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4636]
  00048	39 88 20 12 00
	00		 cmp	 DWORD PTR [rax+4640], ecx
  0004e	76 5c		 jbe	 SHORT $LN23@get_next_c
$LN10@get_next_c:
  00050	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168277
  00057	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168278
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168279
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00077	85 c0		 test	 eax, eax
  00079	74 20		 je	 SHORT $LN24@get_next_c
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168281
  00082	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168282
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168283
  00096	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@get_next_c:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 af		 jne	 SHORT $LN10@get_next_c
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a7	85 c0		 test	 eax, eax
  000a9	74 01		 je	 SHORT $LN25@get_next_c
  000ab	cc		 int	 3
$LN25@get_next_c:
$LN23@get_next_c:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 82		 jne	 SHORT $LN7@get_next_c
$LN13@get_next_c:

; 225  :     ASSERT( sysblk.crwcount <= sysblk.crwalloc );

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c0	8b 89 18 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4632]
  000c6	39 88 1c 12 00
	00		 cmp	 DWORD PTR [rax+4636], ecx
  000cc	76 5c		 jbe	 SHORT $LN26@get_next_c
$LN16@get_next_c:
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168286
  000d5	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168287
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168288
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f5	85 c0		 test	 eax, eax
  000f7	74 20		 je	 SHORT $LN27@get_next_c
  000f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168290
  00100	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168291
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168292
  00114	e8 00 00 00 00	 call	 DebuggerTrace
$LN27@get_next_c:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 af		 jne	 SHORT $LN16@get_next_c
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00125	85 c0		 test	 eax, eax
  00127	74 01		 je	 SHORT $LN28@get_next_c
  00129	cc		 int	 3
$LN28@get_next_c:
$LN26@get_next_c:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 82		 jne	 SHORT $LN13@get_next_c

; 226  :     if (sysblk.crwcount)

  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	83 b8 1c 12 00
	00 00		 cmp	 DWORD PTR [rax+4636], 0
  0013e	0f 84 ef 00 00
	00		 je	 $LN29@get_next_c

; 227  :     {
; 228  :         if (sysblk.crwindex < sysblk.crwcount)

  00144	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00152	8b 89 1c 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4636]
  00158	39 88 20 12 00
	00		 cmp	 DWORD PTR [rax+4640], ecx
  0015e	0f 83 ad 00 00
	00		 jae	 $LN30@get_next_c
$LN19@get_next_c:

; 229  :         {
; 230  :             VERIFY((crw = *(sysblk.crwarray + sysblk.crwindex)) != 0);

  00164	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0016b	8b 80 20 12 00
	00		 mov	 eax, DWORD PTR [rax+4640]
  00171	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00178	48 8b 89 10 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4624]
  0017f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00182	89 44 24 20	 mov	 DWORD PTR crw$[rsp], eax
  00186	83 7c 24 20 00	 cmp	 DWORD PTR crw$[rsp], 0
  0018b	75 5c		 jne	 SHORT $LN32@get_next_c
$LN22@get_next_c:
  0018d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168298
  00194	41 b8 e6 00 00
	00		 mov	 r8d, 230		; 000000e6H
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168299
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168300
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001b4	85 c0		 test	 eax, eax
  001b6	74 20		 je	 SHORT $LN33@get_next_c
  001b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168302
  001bf	41 b8 e6 00 00
	00		 mov	 r8d, 230		; 000000e6H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168303
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168304
  001d3	e8 00 00 00 00	 call	 DebuggerTrace
$LN33@get_next_c:
  001d8	33 c0		 xor	 eax, eax
  001da	85 c0		 test	 eax, eax
  001dc	75 af		 jne	 SHORT $LN22@get_next_c
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001e4	85 c0		 test	 eax, eax
  001e6	74 01		 je	 SHORT $LN34@get_next_c
  001e8	cc		 int	 3
$LN34@get_next_c:
$LN32@get_next_c:
  001e9	33 c0		 xor	 eax, eax
  001eb	85 c0		 test	 eax, eax
  001ed	0f 85 71 ff ff
	ff		 jne	 $LN19@get_next_c

; 231  :             sysblk.crwindex++; // (for next time)

  001f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001fa	8b 80 20 12 00
	00		 mov	 eax, DWORD PTR [rax+4640]
  00200	ff c0		 inc	 eax
  00202	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00209	89 81 20 12 00
	00		 mov	 DWORD PTR [rcx+4640], eax

; 232  :         }

  0020f	eb 22		 jmp	 SHORT $LN31@get_next_c
$LN30@get_next_c:

; 233  :         else // (sysblk.crwindex >= sysblk.crwcount)
; 234  :         {
; 235  :             sysblk.crwindex = 0;

  00211	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00218	c7 80 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4640], 0

; 236  :             sysblk.crwcount = 0;

  00222	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00229	c7 80 1c 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4636], 0
$LN31@get_next_c:
$LN29@get_next_c:

; 237  :         }
; 238  :     }
; 239  :     RELEASE_CRWLOCK();

  00233	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0023a	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168306
  00247	48 8b c8	 mov	 rcx, rax
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 240  :     return crw;

  00250	8b 44 24 20	 mov	 eax, DWORD PTR crw$[rsp]

; 241  : 
; 242  : } /* end function get_next_channel_report_word */

  00254	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00258	c3		 ret	 0
get_next_channel_report_word ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
newalloc$1 = 32
newarray$2 = 40
crwarray$ = 80
crwcount$ = 88
queue_channel_report PROC

; 156  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 157  :     OBTAIN_CRWLOCK();

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168216
  00023	48 8b c8	 mov	 rcx, rax
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 158  : 
; 159  :     if ((sysblk.crwcount + crwcount) > sysblk.crwalloc)

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00033	8b 80 1c 12 00
	00		 mov	 eax, DWORD PTR [rax+4636]
  00039	03 44 24 58	 add	 eax, DWORD PTR crwcount$[rsp]
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00044	3b 81 18 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4632]
  0004a	0f 86 1f 01 00
	00		 jbe	 $LN2@queue_chan

; 160  :     {
; 161  :         /* Allocate larger queue */
; 162  :         U32   newalloc  = sysblk.crwalloc + crwcount;

  00050	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00057	8b 80 18 12 00
	00		 mov	 eax, DWORD PTR [rax+4632]
  0005d	03 44 24 58	 add	 eax, DWORD PTR crwcount$[rsp]
  00061	89 44 24 20	 mov	 DWORD PTR newalloc$1[rsp], eax

; 163  :         U32*  newarray  = malloc( newalloc * sizeof(U32));

  00065	8b 44 24 20	 mov	 eax, DWORD PTR newalloc$1[rsp]
  00069	48 c1 e0 02	 shl	 rax, 2
  0006d	48 8b c8	 mov	 rcx, rax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00076	48 89 44 24 28	 mov	 QWORD PTR newarray$2[rsp], rax

; 164  : 
; 165  :         if (!newarray)

  0007b	48 83 7c 24 28
	00		 cmp	 QWORD PTR newarray$2[rsp], 0
  00081	75 7a		 jne	 SHORT $LN3@queue_chan

; 166  :         {
; 167  :             /* Set overflow in last CRW */
; 168  :             if (sysblk.crwarray)

  00083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008a	48 83 b8 10 12
	00 00 00	 cmp	 QWORD PTR [rax+4624], 0
  00092	74 42		 je	 SHORT $LN4@queue_chan

; 169  :                 *(sysblk.crwarray + sysblk.crwcount - 1) |= CRW_OFLOW;

  00094	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009b	8b 80 1c 12 00
	00		 mov	 eax, DWORD PTR [rax+4636]
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a8	48 8b 89 10 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4624]
  000af	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  000b3	0f ba e8 1d	 bts	 eax, 29
  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000be	8b 89 1c 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4636]
  000c4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000cb	48 8b 92 10 12
	00 00		 mov	 rdx, QWORD PTR [rdx+4624]
  000d2	89 44 8a fc	 mov	 DWORD PTR [rdx+rcx*4-4], eax
$LN4@queue_chan:

; 170  :             RELEASE_CRWLOCK();

  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000dd	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168220
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 171  :             return -1;

  000f3	b8 ff ff ff ff	 mov	 eax, -1
  000f8	e9 e8 00 00 00	 jmp	 $LN1@queue_chan
$LN3@queue_chan:

; 172  :         }
; 173  : 
; 174  :         /* Copy existing queue to new queue */
; 175  :         if (sysblk.crwarray)

  000fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00104	48 83 b8 10 12
	00 00 00	 cmp	 QWORD PTR [rax+4624], 0
  0010c	74 3d		 je	 SHORT $LN5@queue_chan

; 176  :         {
; 177  :             memcpy( newarray, sysblk.crwarray, sysblk.crwcount * sizeof(U32));

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00115	8b 80 1c 12 00
	00		 mov	 eax, DWORD PTR [rax+4636]
  0011b	48 c1 e0 02	 shl	 rax, 2
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00126	48 8b 7c 24 28	 mov	 rdi, QWORD PTR newarray$2[rsp]
  0012b	48 8b b1 10 12
	00 00		 mov	 rsi, QWORD PTR [rcx+4624]
  00132	48 8b c8	 mov	 rcx, rax
  00135	f3 a4		 rep movsb

; 178  :             free( sysblk.crwarray );

  00137	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013e	48 8b 88 10 12
	00 00		 mov	 rcx, QWORD PTR [rax+4624]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@queue_chan:

; 179  :         }
; 180  : 
; 181  :         /* Start using new queue */
; 182  :         sysblk.crwarray = newarray;

  0014b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newarray$2[rsp]
  00157	48 89 88 10 12
	00 00		 mov	 QWORD PTR [rax+4624], rcx

; 183  :         sysblk.crwalloc = newalloc;

  0015e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00165	8b 4c 24 20	 mov	 ecx, DWORD PTR newalloc$1[rsp]
  00169	89 88 18 12 00
	00		 mov	 DWORD PTR [rax+4632], ecx
$LN2@queue_chan:

; 184  :     }
; 185  : 
; 186  :     /* Add the new CRWs to the queue */
; 187  :     memcpy( sysblk.crwarray + sysblk.crwcount, crwarray, crwcount * sizeof(U32));

  0016f	8b 44 24 58	 mov	 eax, DWORD PTR crwcount$[rsp]
  00173	48 c1 e0 02	 shl	 rax, 2
  00177	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017e	8b 89 1c 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4636]
  00184	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0018b	48 8b 92 10 12
	00 00		 mov	 rdx, QWORD PTR [rdx+4624]
  00192	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00196	48 8b f9	 mov	 rdi, rcx
  00199	48 8b 74 24 50	 mov	 rsi, QWORD PTR crwarray$[rsp]
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	f3 a4		 rep movsb

; 188  :     sysblk.crwcount += crwcount;

  001a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001aa	8b 80 1c 12 00
	00		 mov	 eax, DWORD PTR [rax+4636]
  001b0	03 44 24 58	 add	 eax, DWORD PTR crwcount$[rsp]
  001b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001bb	89 81 1c 12 00
	00		 mov	 DWORD PTR [rcx+4636], eax

; 189  :     RELEASE_CRWLOCK();

  001c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c8	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168222
  001d5	48 8b c8	 mov	 rcx, rax
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 190  : 
; 191  :     /* Signal waiting CPUs that a Channel Report is pending */
; 192  :     machine_check_crwpend();

  001de	e8 00 00 00 00	 call	 machine_check_crwpend

; 193  :     return 0;

  001e3	33 c0		 xor	 eax, eax
$LN1@queue_chan:

; 194  : 
; 195  : } /* end function queue_channel_report */

  001e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001e9	5f		 pop	 rdi
  001ea	5e		 pop	 rsi
  001eb	c3		 ret	 0
queue_channel_report ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
crwcount$ = 32
tv77 = 36
crw_erc$ = 40
crwarray$ = 48
__$ArrayPad$ = 80
chpid$ = 112
solicited$ = 120
found$ = 128
build_chp_reset_chrpt PROC

; 39   : {

$LN17:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000d	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 40   : U32 crw_erc, crwarray[8], crwcount=0;

  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR crwcount$[rsp], 0

; 41   : 
; 42   :     /* Just return if shutting down */
; 43   :     if (sysblk.shutdown)

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00035	c1 e8 0b	 shr	 eax, 11
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 05		 je	 SHORT $LN8@build_chp_

; 44   :         return;

  0003f	e9 e0 00 00 00	 jmp	 $LN1@build_chp_
$LN8@build_chp_:

; 45   : 
; 46   :     chpid = ((U32)chpid) & CRW_RSID_MASK;

  00044	0f b6 44 24 70	 movzx	 eax, BYTE PTR chpid$[rsp]
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	88 44 24 70	 mov	 BYTE PTR chpid$[rsp], al

; 47   : 
; 48   :     /* If a subchannel was found on this path and was reset. Ref:
; 49   :        SA22-7832 "Channel-Path-Reset-Function-Completion Signaling   */
; 50   :     if (found)

  00052	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR found$[rsp], 0
  0005a	74 0a		 je	 SHORT $LN9@build_chp_

; 51   :         crw_erc = CRW_ERC_INIT;         /* Init'ed, parms unchanged  */

  0005c	c7 44 24 28 00
	00 02 00	 mov	 DWORD PTR crw_erc$[rsp], 131072 ; 00020000H
  00064	eb 08		 jmp	 SHORT $LN10@build_chp_
$LN9@build_chp_:

; 52   :     else
; 53   :         crw_erc = CRW_ERC_RESET;        /* Error, parms initialized  */

  00066	c7 44 24 28 00
	00 07 00	 mov	 DWORD PTR crw_erc$[rsp], 458752 ; 00070000H
$LN10@build_chp_:

; 54   : 
; 55   :     /* Build the Channel Path Reset Channel Report */
; 56   :     crwarray[crwcount++] = (solicited ? CRW_SOL : 0) |

  0006e	83 7c 24 78 00	 cmp	 DWORD PTR solicited$[rsp], 0
  00073	74 0a		 je	 SHORT $LN15@build_chp_
  00075	c7 44 24 24 00
	00 00 40	 mov	 DWORD PTR tv77[rsp], 1073741824 ; 40000000H
  0007d	eb 08		 jmp	 SHORT $LN16@build_chp_
$LN15@build_chp_:
  0007f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN16@build_chp_:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR tv77[rsp]
  0008b	0f ba e8 1a	 bts	 eax, 26
  0008f	0f ba e8 17	 bts	 eax, 23
  00093	0b 44 24 28	 or	 eax, DWORD PTR crw_erc$[rsp]
  00097	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR chpid$[rsp]
  0009c	0b c1		 or	 eax, ecx
  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR crwcount$[rsp]
  000a2	89 44 8c 30	 mov	 DWORD PTR crwarray$[rsp+rcx*4], eax
  000a6	8b 44 24 20	 mov	 eax, DWORD PTR crwcount$[rsp]
  000aa	ff c0		 inc	 eax
  000ac	89 44 24 20	 mov	 DWORD PTR crwcount$[rsp], eax
$LN4@build_chp_:

; 57   :         CRW_RSC_CHPID | CRW_AR | crw_erc | chpid;
; 58   : 
; 59   :     /* Queue the Channel Report */
; 60   :     VERIFY( queue_channel_report( crwarray, crwcount ) == 0 );

  000b0	8b 54 24 20	 mov	 edx, DWORD PTR crwcount$[rsp]
  000b4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR crwarray$[rsp]
  000b9	e8 00 00 00 00	 call	 queue_channel_report
  000be	85 c0		 test	 eax, eax
  000c0	74 5c		 je	 SHORT $LN11@build_chp_
$LN7@build_chp_:
  000c2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168137
  000c9	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168138
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168139
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000e9	85 c0		 test	 eax, eax
  000eb	74 20		 je	 SHORT $LN12@build_chp_
  000ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168141
  000f4	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168142
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168143
  00108	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@build_chp_:
  0010d	33 c0		 xor	 eax, eax
  0010f	85 c0		 test	 eax, eax
  00111	75 af		 jne	 SHORT $LN7@build_chp_
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00119	85 c0		 test	 eax, eax
  0011b	74 01		 je	 SHORT $LN13@build_chp_
  0011d	cc		 int	 3
$LN13@build_chp_:
$LN11@build_chp_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 8c		 jne	 SHORT $LN4@build_chp_
$LN1@build_chp_:

; 61   : }

  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00129	48 33 cc	 xor	 rcx, rsp
  0012c	e8 00 00 00 00	 call	 __security_check_cookie
  00131	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00135	c3		 ret	 0
build_chp_reset_chrpt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
crwcount$ = 32
tv73 = 36
tv91 = 40
devlock_obtained$ = 44
subchan$ = 48
ssid$ = 52
crwarray$ = 56
__$ArrayPad$ = 88
dev$ = 112
build_detach_chrpt PROC

; 112  : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 113  : U32 ssid, subchan, crwarray[8], crwcount=0;

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR crwcount$[rsp], 0

; 114  : int devlock_obtained;
; 115  : 
; 116  :     /* Just return if shutting down */
; 117  :     if (sysblk.shutdown)

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002d	c1 e8 0b	 shr	 eax, 11
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 05		 je	 SHORT $LN8@build_deta

; 118  :         return;

  00037	e9 68 01 00 00	 jmp	 $LN1@build_deta
$LN8@build_deta:

; 119  : 
; 120  :     /* Retrieve Source IDs */
; 121  :     devlock_obtained = (try_obtain_lock( &dev->lock ) == 0);

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 83 c0 38	 add	 rax, 56			; 00000038H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168192
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $LN15@build_deta
  00059	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN16@build_deta
$LN15@build_deta:
  00063	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN16@build_deta:
  0006b	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006f	89 44 24 2c	 mov	 DWORD PTR devlock_obtained$[rsp], eax

; 122  :     {
; 123  :         ssid    = ((U32)SSID_TO_LCSS( dev->ssid )) & CRW_RSID_MASK;

  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00078	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007c	d1 f8		 sar	 eax, 1
  0007e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00083	89 44 24 34	 mov	 DWORD PTR ssid$[rsp], eax

; 124  :         subchan = ((U32)dev->subchan)              & CRW_RSID_MASK;

  00087	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	0f b7 40 46	 movzx	 eax, WORD PTR [rax+70]
  00090	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00095	89 44 24 30	 mov	 DWORD PTR subchan$[rsp], eax

; 125  :     }
; 126  :     if (devlock_obtained)

  00099	83 7c 24 2c 00	 cmp	 DWORD PTR devlock_obtained$[rsp], 0
  0009e	74 19		 je	 SHORT $LN9@build_deta

; 127  :         release_lock( &dev->lock );

  000a0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168194
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN9@build_deta:

; 128  : 
; 129  :     /* Build Subchannel Alert Channel Report */
; 130  :     crwarray[crwcount++] =

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	83 b8 00 12 00
	00 00		 cmp	 DWORD PTR [rax+4608], 0
  000c7	74 0a		 je	 SHORT $LN17@build_deta
  000c9	c7 44 24 28 00
	00 00 10	 mov	 DWORD PTR tv91[rsp], 268435456 ; 10000000H
  000d1	eb 08		 jmp	 SHORT $LN18@build_deta
$LN17@build_deta:
  000d3	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN18@build_deta:
  000db	8b 44 24 28	 mov	 eax, DWORD PTR tv91[rsp]
  000df	0d 00 00 00 03	 or	 eax, 50331648		; 03000000H
  000e4	0f ba e8 17	 bts	 eax, 23
  000e8	0f ba e8 12	 bts	 eax, 18
  000ec	0b 44 24 30	 or	 eax, DWORD PTR subchan$[rsp]
  000f0	8b 4c 24 20	 mov	 ecx, DWORD PTR crwcount$[rsp]
  000f4	89 44 8c 38	 mov	 DWORD PTR crwarray$[rsp+rcx*4], eax
  000f8	8b 44 24 20	 mov	 eax, DWORD PTR crwcount$[rsp]
  000fc	ff c0		 inc	 eax
  000fe	89 44 24 20	 mov	 DWORD PTR crwcount$[rsp], eax

; 131  :         0
; 132  :         | (sysblk.mss ? CRW_CHAIN : 0)
; 133  :         | CRW_RSC_SUBCH
; 134  :         | CRW_AR
; 135  :         | CRW_ERC_ALERT
; 136  :         | subchan
; 137  :         ;
; 138  :     if (sysblk.mss)

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	83 b8 00 12 00
	00 00		 cmp	 DWORD PTR [rax+4608], 0
  00110	74 1e		 je	 SHORT $LN10@build_deta

; 139  :         crwarray[crwcount++] =

  00112	8b 44 24 34	 mov	 eax, DWORD PTR ssid$[rsp]
  00116	c1 e0 08	 shl	 eax, 8
  00119	0d 00 00 84 03	 or	 eax, 58982400		; 03840000H
  0011e	8b 4c 24 20	 mov	 ecx, DWORD PTR crwcount$[rsp]
  00122	89 44 8c 38	 mov	 DWORD PTR crwarray$[rsp+rcx*4], eax
  00126	8b 44 24 20	 mov	 eax, DWORD PTR crwcount$[rsp]
  0012a	ff c0		 inc	 eax
  0012c	89 44 24 20	 mov	 DWORD PTR crwcount$[rsp], eax
$LN10@build_deta:
$LN4@build_deta:

; 140  :             0
; 141  :             | CRW_RSC_SUBCH
; 142  :             | CRW_AR
; 143  :             | CRW_ERC_ALERT
; 144  :             | (ssid << 8)
; 145  :             ;
; 146  : 
; 147  :     /* Queue the Channel Report */
; 148  :     VERIFY( queue_channel_report( crwarray, crwcount ) == 0 );

  00130	8b 54 24 20	 mov	 edx, DWORD PTR crwcount$[rsp]
  00134	48 8d 4c 24 38	 lea	 rcx, QWORD PTR crwarray$[rsp]
  00139	e8 00 00 00 00	 call	 queue_channel_report
  0013e	85 c0		 test	 eax, eax
  00140	74 5c		 je	 SHORT $LN11@build_deta
$LN7@build_deta:
  00142	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168197
  00149	41 b8 94 00 00
	00		 mov	 r8d, 148		; 00000094H
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168198
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168199
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00169	85 c0		 test	 eax, eax
  0016b	74 20		 je	 SHORT $LN12@build_deta
  0016d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168201
  00174	41 b8 94 00 00
	00		 mov	 r8d, 148		; 00000094H
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168202
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168203
  00188	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@build_deta:
  0018d	33 c0		 xor	 eax, eax
  0018f	85 c0		 test	 eax, eax
  00191	75 af		 jne	 SHORT $LN7@build_deta
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00199	85 c0		 test	 eax, eax
  0019b	74 01		 je	 SHORT $LN13@build_deta
  0019d	cc		 int	 3
$LN13@build_deta:
$LN11@build_deta:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 8c		 jne	 SHORT $LN4@build_deta
$LN1@build_deta:

; 149  : }

  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a9	48 33 cc	 xor	 rcx, rsp
  001ac	e8 00 00 00 00	 call	 __security_check_cookie
  001b1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b5	c3		 ret	 0
build_detach_chrpt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
crwcount$ = 32
tv73 = 36
tv91 = 40
devlock_obtained$ = 44
subchan$ = 48
ssid$ = 52
crwarray$ = 56
__$ArrayPad$ = 88
dev$ = 112
build_attach_chrpt PROC

; 68   : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 69   : U32 ssid, subchan, crwarray[8], crwcount=0;

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR crwcount$[rsp], 0

; 70   : int devlock_obtained;
; 71   : 
; 72   :     /* Just return if shutting down */
; 73   :     if (sysblk.shutdown)

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002d	c1 e8 0b	 shr	 eax, 11
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 05		 je	 SHORT $LN8@build_atta

; 74   :         return;

  00037	e9 68 01 00 00	 jmp	 $LN1@build_atta
$LN8@build_atta:

; 75   : 
; 76   :     /* Retrieve Source IDs */
; 77   :     devlock_obtained = (try_obtain_lock( &dev->lock ) == 0);

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 83 c0 38	 add	 rax, 56			; 00000038H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168162
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $LN15@build_atta
  00059	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN16@build_atta
$LN15@build_atta:
  00063	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN16@build_atta:
  0006b	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006f	89 44 24 2c	 mov	 DWORD PTR devlock_obtained$[rsp], eax

; 78   :     {
; 79   :         ssid    = ((U32)SSID_TO_LCSS( dev->ssid )) & CRW_RSID_MASK;

  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00078	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007c	d1 f8		 sar	 eax, 1
  0007e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00083	89 44 24 34	 mov	 DWORD PTR ssid$[rsp], eax

; 80   :         subchan = ((U32)dev->subchan)              & CRW_RSID_MASK;

  00087	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	0f b7 40 46	 movzx	 eax, WORD PTR [rax+70]
  00090	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00095	89 44 24 30	 mov	 DWORD PTR subchan$[rsp], eax

; 81   :     }
; 82   :     if (devlock_obtained)

  00099	83 7c 24 2c 00	 cmp	 DWORD PTR devlock_obtained$[rsp], 0
  0009e	74 19		 je	 SHORT $LN9@build_atta

; 83   :         release_lock( &dev->lock );

  000a0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168164
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN9@build_atta:

; 84   : 
; 85   :     /* Build Subchannel Alert Channel Report */
; 86   :     crwarray[crwcount++] =

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	83 b8 00 12 00
	00 00		 cmp	 DWORD PTR [rax+4608], 0
  000c7	74 0a		 je	 SHORT $LN17@build_atta
  000c9	c7 44 24 28 00
	00 00 10	 mov	 DWORD PTR tv91[rsp], 268435456 ; 10000000H
  000d1	eb 08		 jmp	 SHORT $LN18@build_atta
$LN17@build_atta:
  000d3	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN18@build_atta:
  000db	8b 44 24 28	 mov	 eax, DWORD PTR tv91[rsp]
  000df	0d 00 00 00 03	 or	 eax, 50331648		; 03000000H
  000e4	0f ba e8 17	 bts	 eax, 23
  000e8	0f ba e8 12	 bts	 eax, 18
  000ec	0b 44 24 30	 or	 eax, DWORD PTR subchan$[rsp]
  000f0	8b 4c 24 20	 mov	 ecx, DWORD PTR crwcount$[rsp]
  000f4	89 44 8c 38	 mov	 DWORD PTR crwarray$[rsp+rcx*4], eax
  000f8	8b 44 24 20	 mov	 eax, DWORD PTR crwcount$[rsp]
  000fc	ff c0		 inc	 eax
  000fe	89 44 24 20	 mov	 DWORD PTR crwcount$[rsp], eax

; 87   :         0
; 88   :         | (sysblk.mss ? CRW_CHAIN : 0)
; 89   :         | CRW_RSC_SUBCH
; 90   :         | CRW_AR
; 91   :         | CRW_ERC_ALERT
; 92   :         | subchan
; 93   :         ;
; 94   :     if (sysblk.mss)

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	83 b8 00 12 00
	00 00		 cmp	 DWORD PTR [rax+4608], 0
  00110	74 1e		 je	 SHORT $LN10@build_atta

; 95   :         crwarray[crwcount++] =

  00112	8b 44 24 34	 mov	 eax, DWORD PTR ssid$[rsp]
  00116	c1 e0 08	 shl	 eax, 8
  00119	0d 00 00 84 03	 or	 eax, 58982400		; 03840000H
  0011e	8b 4c 24 20	 mov	 ecx, DWORD PTR crwcount$[rsp]
  00122	89 44 8c 38	 mov	 DWORD PTR crwarray$[rsp+rcx*4], eax
  00126	8b 44 24 20	 mov	 eax, DWORD PTR crwcount$[rsp]
  0012a	ff c0		 inc	 eax
  0012c	89 44 24 20	 mov	 DWORD PTR crwcount$[rsp], eax
$LN10@build_atta:
$LN4@build_atta:

; 96   :             0
; 97   :             | CRW_RSC_SUBCH
; 98   :             | CRW_AR
; 99   :             | CRW_ERC_ALERT
; 100  :             | (ssid << 8)
; 101  :             ;
; 102  : 
; 103  :     /* Queue the Channel Report(s) */
; 104  :     VERIFY( queue_channel_report( crwarray, crwcount ) == 0 );

  00130	8b 54 24 20	 mov	 edx, DWORD PTR crwcount$[rsp]
  00134	48 8d 4c 24 38	 lea	 rcx, QWORD PTR crwarray$[rsp]
  00139	e8 00 00 00 00	 call	 queue_channel_report
  0013e	85 c0		 test	 eax, eax
  00140	74 5c		 je	 SHORT $LN11@build_atta
$LN7@build_atta:
  00142	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168167
  00149	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168168
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168169
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00169	85 c0		 test	 eax, eax
  0016b	74 20		 je	 SHORT $LN12@build_atta
  0016d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168171
  00174	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168172
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168173
  00188	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@build_atta:
  0018d	33 c0		 xor	 eax, eax
  0018f	85 c0		 test	 eax, eax
  00191	75 af		 jne	 SHORT $LN7@build_atta
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00199	85 c0		 test	 eax, eax
  0019b	74 01		 je	 SHORT $LN13@build_atta
  0019d	cc		 int	 3
$LN13@build_atta:
$LN11@build_atta:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 8c		 jne	 SHORT $LN4@build_atta
$LN1@build_atta:

; 105  : }

  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a9	48 33 cc	 xor	 rcx, rsp
  001ac	e8 00 00 00 00	 call	 __security_check_cookie
  001b1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b5	c3		 ret	 0
build_attach_chrpt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
i$1 = 32
have_lock$ = 36
mask$2 = 40
machine_check_crwpend PROC

; 202  : {

$LN15:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 203  :     /* Signal waiting CPUs that a Channel Report is pending */
; 204  :     int  have_lock  = have_lock( &sysblk.intlock );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00011	48 8b c8	 mov	 rcx, rax
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_have_lock
  0001a	89 44 24 24	 mov	 DWORD PTR have_lock$[rsp], eax

; 205  :     if (!have_lock)

  0001e	83 7c 24 24 00	 cmp	 DWORD PTR have_lock$[rsp], 0
  00023	75 0e		 jne	 SHORT $LN8@machine_ch

; 206  :         OBTAIN_INTLOCK( NULL );

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168242
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN8@machine_ch:
$LN4@machine_ch:

; 207  :     ON_IC_CHANRPT;

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00040	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00045	85 c0		 test	 eax, eax
  00047	0f 85 fc 00 00
	00		 jne	 $LN9@machine_ch
  0004d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00054	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0005a	0f ba e8 1c	 bts	 eax, 28
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00065	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0006b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00072	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00079	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00086	eb 0a		 jmp	 SHORT $LN7@machine_ch
$LN5@machine_ch:
  00088	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@machine_ch:
  00092	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00098	0f 84 ab 00 00
	00		 je	 $LN6@machine_ch
  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  000a3	48 83 e0 01	 and	 rax, 1
  000a7	48 85 c0	 test	 rax, rax
  000aa	0f 84 87 00 00
	00		 je	 $LN10@machine_ch
  000b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000bc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000c4	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c7	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000cc	85 c0		 test	 eax, eax
  000ce	74 35		 je	 SHORT $LN11@machine_ch
  000d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000dc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000e4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000e7	0d 00 00 00 90	 or	 eax, -1879048192	; 90000000H
  000ec	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  000f1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000f8	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00100	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00103	eb 32		 jmp	 SHORT $LN12@machine_ch
$LN11@machine_ch:
  00105	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0010a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00111	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00119	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0011c	0f ba e8 1c	 bts	 eax, 28
  00120	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00125	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0012c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00134	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN12@machine_ch:
$LN10@machine_ch:
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  0013c	48 d1 e8	 shr	 rax, 1
  0013f	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  00144	e9 3f ff ff ff	 jmp	 $LN5@machine_ch
$LN6@machine_ch:
$LN9@machine_ch:
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	0f 85 e0 fe ff
	ff		 jne	 $LN4@machine_ch

; 208  :     WAKEUP_CPUS_MASK (sysblk.waiting_mask);

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168247
  0015a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00161	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00168	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 209  :     if (!have_lock)

  0016d	83 7c 24 24 00	 cmp	 DWORD PTR have_lock$[rsp], 0
  00172	75 0e		 jne	 SHORT $LN13@machine_ch

; 210  :         RELEASE_INTLOCK(NULL);

  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168249
  0017b	33 c9		 xor	 ecx, ecx
  0017d	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN13@machine_ch:

; 211  : 
; 212  : } /* end function machine_check_crwpend */

  00182	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00186	c3		 ret	 0
machine_check_crwpend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machchk.c
_TEXT	SEGMENT
i$1 = 0
rc$ = 4
mask$2 = 8
regs$ = 32
mcic$ = 40
xdmg$ = 48
fsta$ = 56
s370_present_mck_interrupt PROC

; 264  : {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 265  : int rc = 0;

  00018	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@s370_prese:

; 266  : 
; 267  :     UNREFERENCED_370(regs);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN4@s370_prese
$LN7@s370_prese:

; 268  :     UNREFERENCED_370(mcic);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN7@s370_prese
$LN10@s370_prese:

; 269  :     UNREFERENCED_370(xdmg);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN10@s370_prese
$LN13@s370_prese:

; 270  :     UNREFERENCED_370(fsta);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN13@s370_prese
$LN16@s370_prese:

; 271  : 
; 272  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 273  :     /* If there is a crw pending and we are enabled for the channel
; 274  :        report interrupt subclass then process the interrupt */
; 275  :     if( OPEN_IC_CHANRPT(regs) )
; 276  :     {
; 277  :         *mcic =  MCIC_CP |
; 278  :                MCIC_WP |
; 279  :                MCIC_MS |
; 280  :                MCIC_PM |
; 281  :                MCIC_IA |
; 282  : #ifdef FEATURE_HEXADECIMAL_FLOATING_POINT
; 283  :                MCIC_FP |
; 284  : #endif /*FEATURE_HEXADECIMAL_FLOATING_POINT*/
; 285  :                MCIC_GR |
; 286  :                MCIC_CR |
; 287  :                MCIC_ST |
; 288  : #ifdef FEATURE_ACCESS_REGISTERS
; 289  :                MCIC_AR |
; 290  : #endif /*FEATURE_ACCESS_REGISTERS*/
; 291  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)
; 292  :                MCIC_PR |
; 293  : #endif /*defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) && defined(FEATURE_EXTENDED_TOD_CLOCK)*/
; 294  : #if defined(FEATURE_BINARY_FLOATING_POINT)
; 295  :                MCIC_XF |
; 296  : #endif /*defined(FEATURE_BINARY_FLOATING_POINT)*/
; 297  :                MCIC_AP |
; 298  :                MCIC_CT |
; 299  :                MCIC_CC ;
; 300  :         *xdmg = 0;
; 301  :         *fsta = 0;
; 302  :         OFF_IC_CHANRPT;
; 303  :         rc = 1;
; 304  :     }
; 305  : 
; 306  :     if(!IS_IC_CHANRPT)
; 307  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 308  :         OFF_IC_CHANRPT;

  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00045	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 97 00 00
	00		 je	 $LN20@s370_prese
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0005f	0f ba f0 1c	 btr	 eax, 28
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006a	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00077	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0007e	48 89 44 24 08	 mov	 QWORD PTR mask$2[rsp], rax
  00083	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  0008a	eb 08		 jmp	 SHORT $LN19@s370_prese
$LN17@s370_prese:
  0008c	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN19@s370_prese:
  00094	48 83 7c 24 08
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  0009a	74 4d		 je	 SHORT $LN18@s370_prese
  0009c	48 8b 44 24 08	 mov	 rax, QWORD PTR mask$2[rsp]
  000a1	48 83 e0 01	 and	 rax, 1
  000a5	48 85 c0	 test	 rax, rax
  000a8	74 30		 je	 SHORT $LN21@s370_prese
  000aa	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b5	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000bd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000c0	0f ba f0 1c	 btr	 eax, 28
  000c4	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  000c8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000cf	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000d7	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN21@s370_prese:
  000da	48 8b 44 24 08	 mov	 rax, QWORD PTR mask$2[rsp]
  000df	48 d1 e8	 shr	 rax, 1
  000e2	48 89 44 24 08	 mov	 QWORD PTR mask$2[rsp], rax
  000e7	eb a3		 jmp	 SHORT $LN17@s370_prese
$LN18@s370_prese:
$LN20@s370_prese:
  000e9	33 c0		 xor	 eax, eax
  000eb	85 c0		 test	 eax, eax
  000ed	0f 85 45 ff ff
	ff		 jne	 $LN16@s370_prese

; 309  : 
; 310  :     return rc;

  000f3	8b 44 24 04	 mov	 eax, DWORD PTR rc$[rsp]

; 311  : } /* end function present_mck_interrupt */

  000f7	48 83 c4 18	 add	 rsp, 24
  000fb	c3		 ret	 0
s370_present_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
