; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	main
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_string_to_upper:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_create_ckd64:PROC
EXTRN	__imp_create_fba64:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG159748 DB	01H DUP (?)
$SG159749 DB	01H DUP (?)
$SG159750 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$argexit DD imagerel argexit
	DD	imagerel argexit+1156
	DD	imagerel $unwind$argexit
$pdata$main DD	imagerel $LN50
	DD	imagerel $LN50+2589
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159630 DB	'64-bit DASD image file creation program', 00H
$SG159631 DB	'dasdinit64', 00H
	ORG $+1
$SG159634 DB	'-v', 00H
	ORG $+1
$SG159637 DB	'0', 00H
	ORG $+2
$SG159640 DB	'a', 00H
	ORG $+2
$SG159643 DB	'r', 00H
	ORG $+2
$SG159646 DB	'lfs', 00H
$SG159649 DB	'linux', 00H
	ORG $+2
$SG159652 DB	'b', 00H
	ORG $+2
$SG159655 DB	'm', 00H
	ORG $+2
$SG159673 DB	'%d%c', 00H
	ORG $+3
$SG159681 DB	'I', 00H
	ORG $+2
$SG159685 DB	'E', 00H
	ORG $+2
$SG159682 DB	'HHC02423%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG159683 DB	'main', 00H
	ORG $+3
$SG159684 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159686 DB	'HHC02449%s DASD operation failed', 0aH, 00H
	ORG $+2
$SG159687 DB	'main', 00H
	ORG $+3
$SG159703 DB	'(null)', 00H
	ORG $+1
$SG159705 DB	'E', 00H
	ORG $+2
$SG159688 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159704 DB	'option', 00H
	ORG $+1
$SG159706 DB	'HHC02445%s Invalid, unsupported or missing %s: %s', 0aH, 00H
	ORG $+1
$SG159712 DB	'E', 00H
	ORG $+2
$SG159707 DB	'argexit', 00H
$SG159708 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159710 DB	'(null)', 00H
	ORG $+1
$SG159711 DB	'filename', 00H
	ORG $+3
$SG159717 DB	'(null)', 00H
	ORG $+1
$SG159719 DB	'E', 00H
	ORG $+2
$SG159713 DB	'HHC02445%s Invalid, unsupported or missing %s: %s', 0aH, 00H
	ORG $+1
$SG159726 DB	'E', 00H
	ORG $+2
$SG159714 DB	'argexit', 00H
$SG159715 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159718 DB	'device type', 00H
$SG159733 DB	'E', 00H
	ORG $+2
$SG159720 DB	'HHC02445%s Invalid, unsupported or missing %s: %s', 0aH, 00H
	ORG $+1
$SG159738 DB	'E', 00H
	ORG $+2
$SG159721 DB	'argexit', 00H
$SG159722 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159724 DB	'(null)', 00H
	ORG $+1
$SG159725 DB	'volser', 00H
	ORG $+1
$SG159727 DB	'HHC02445%s Invalid, unsupported or missing %s: %s', 0aH, 00H
	ORG $+1
$SG159743 DB	'E', 00H
	ORG $+2
$SG159728 DB	'argexit', 00H
$SG159729 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159731 DB	'(null)', 00H
	ORG $+1
$SG159732 DB	'size', 00H
	ORG $+3
$SG159734 DB	'HHC02445%s Invalid, unsupported or missing %s: %s', 0aH, 00H
	ORG $+1
$SG159753 DB	'I', 00H
	ORG $+2
$SG159735 DB	'argexit', 00H
$SG159736 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159739 DB	'HHC02446%s Invalid number of arguments', 0aH, 00H
$SG159740 DB	'argexit', 00H
$SG159741 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159745 DB	'argexit', 00H
$SG159744 DB	'HHC02447%s Option ''-linux'' is only supported fo device'
	DB	' type 3390', 0aH, 00H
	ORG $+6
$SG159746 DB	'dasdinit64.c', 00H
	ORG $+3
$SG159755 DB	'argexit', 00H
$SG159752 DB	'HHC02448I   -lfs      build a large (uncompressed) dasd '
	DB	'file (if supported)', 0aH, 00H
	ORG $+3
$SG159754 DB	'HHC02448%s Usage: %s [-options] filename devtype[-model]'
	DB	' [volser] [size]', 0aH, 'HHC02448I Builds an empty dasd image'
	DB	' file', 0aH, 'HHC02448I options:', 0aH, 'HHC02448I', 0aH, '%s'
	DB	'%sHHC02448I   -0        build compressed dasd image file with'
	DB	' no compression', 0aH, '%sHHC02448I   -a        build dasd im'
	DB	'age file that includes alternate cylinders', 0aH, 'HHC02448I '
	DB	'            (option ignored if size is manually specified)', 0aH
	DB	'HHC02448I   -r        build ''raw'' dasd image file', 0aH, 'H'
	DB	'HC02448I             (no VOL1 or IPL track)', 0aH, 'HHC02448I'
	DB	'   -b        make wait PSW in IPL1 record a BC-mode PSW', 0aH
	DB	'HHC02448I             (default is EC-mode PSW)', 0aH, 'HHC024'
	DB	'48I   -m        enable wait PSW in IPL1 record for machine ch'
	DB	'ecks', 0aH, 'HHC02448I             (default is disabled for m'
	DB	'achine checks)', 0aH, 'HHC02448I   -linux    null track image'
	DB	's will look like Linux dasdfmt''ed images', 0aH, 'HHC02448I  '
	DB	'           (3390 device type only)', 0aH, 'HHC02448I', 0aH, 'H'
	DB	'HC02448I   filename  name of dasd image file to be created', 0aH
	DB	'HHC02448I   devtype   CKD: 2305, 2311, 2314, 3330, 3340, 3350'
	DB	', 3375, 3380, 3390, 9345', 0aH, 'HHC02448I             FBA: 0'
	DB	'671, 3310, 3370, 9313, 9332, 9335, 9336', 0aH, 'HHC02448I', 0aH
	DB	'HHC02448I   model     device model (implies size) (opt)', 0aH
	DB	'HHC02448I   volser    volume serial number (1-6 characters)', 0aH
	DB	'HHC02448I             (specified only if ''-r'' option not us'
	DB	'ed)', 0aH, 'HHC02448I   size      number of CKD cylinders or '
	DB	'512-byte FBA sectors', 0aH, 'HHC02448I             (required '
	DB	'if model not specified else optional)', 0aH, 00H
	ORG $+7
$SG159756 DB	'dasdinit64.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	0a05H
voltbl	ENDS
xdata	SEGMENT
$unwind$argexit DD 021501H
	DD	0170115H
$unwind$main DD	022219H
	DD	09f0110H
	DD	imagerel __GSHandlerCheck
	DD	04e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdinit64.c
_TEXT	SEGMENT
type$ = 112
comp$ = 113
devtype$ = 116
volsize_argnum$ = 120
size$ = 124
rawflag$ = 128
signed_size$1 = 132
pgm$ = 136
c$ = 144
altcylflag$ = 148
altsize$ = 152
nullfmt$ = 156
lfs$ = 160
rc$ = 164
ckd$ = 168
tv185 = 176
tv188 = 180
flagMachinecheck$ = 184
flagECmode$ = 188
maxdlen$ = 192
heads$ = 196
sectsize$ = 200
fba$ = 208
volser$ = 216
fname$ = 224
__$ArrayPad$ = 1248
argc$ = 1280
argv$ = 1288
main	PROC

; 71   : {

$LN50:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec f8 04
	00 00		 sub	 rsp, 1272		; 000004f8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 72   : char   *pgm;                            /* less any extension (.ext) */
; 73   : int     altcylflag = 0;                 /* Alternate cylinders flag  */

  00022	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR altcylflag$[rsp], 0

; 74   : int     rawflag = 0;                    /* Raw format flag           */

  0002d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rawflag$[rsp], 0

; 75   : int     volsize_argnum = 4;             /* argc value of size option */

  00038	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR volsize_argnum$[rsp], 4

; 76   : int     flagECmode = 1;                 /* IPL PSW mode flag         */

  00040	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR flagECmode$[rsp], 1

; 77   : int     flagMachinecheck   = 0;         /* IPL PSW machine check flag*/

  0004b	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR flagMachinecheck$[rsp], 0

; 78   : U32     size = 0;                       /* Volume size               */

  00056	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 79   : U32     altsize = 0;                    /* Alternate cylinders       */

  0005e	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR altsize$[rsp], 0

; 80   : U32     heads = 0;                      /* Number of tracks/cylinder */

  00069	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR heads$[rsp], 0

; 81   : U32     maxdlen = 0;                    /* Maximum R1 data length    */

  00074	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR maxdlen$[rsp], 0

; 82   : U32     sectsize = 0;                   /* Sector size               */

  0007f	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sectsize$[rsp], 0

; 83   : U16     devtype = 0;                    /* Device type               */

  0008a	33 c0		 xor	 eax, eax
  0008c	66 89 44 24 74	 mov	 WORD PTR devtype$[rsp], ax

; 84   : BYTE    comp = 0xff;                    /* Compression algoritm      */

  00091	c6 44 24 71 ff	 mov	 BYTE PTR comp$[rsp], 255 ; 000000ffH

; 85   : BYTE    type = 0;                       /* C=CKD, F=FBA              */

  00096	c6 44 24 70 00	 mov	 BYTE PTR type$[rsp], 0

; 86   : char    fname[1024];                    /* File name                 */
; 87   : char    volser[6+1];                    /* Volume serial number      */
; 88   : BYTE    c;                              /* Character work area       */
; 89   : CKDDEV *ckd;                            /* -> CKD device table entry */
; 90   : FBADEV *fba;                            /* -> FBA device table entry */
; 91   : int     lfs = 0;                        /* 1 = Build large file      */

  0009b	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 92   : int     nullfmt = CKD_NULLTRK_FMT1;     /* Null track format type    */

  000a6	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 1

; 93   : int     rc;                             /* Return code               */
; 94   : 
; 95   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  000b1	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159630
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159631
  000cc	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000d4	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  000e1	89 84 24 00 05
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 96   : 
; 97   :     /* Display help if needed or requested */
; 98   :     if (argc <= 1 || (argc == 2 && !strcmp(argv[1], "-v")))

  000e8	83 bc 24 00 05
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000f0	7e 2f		 jle	 SHORT $LN6@main
  000f2	83 bc 24 00 05
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000fa	75 39		 jne	 SHORT $LN5@main
  000fc	b8 08 00 00 00	 mov	 eax, 8
  00101	48 6b c0 01	 imul	 rax, rax, 1
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159634
  0010c	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00114	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00118	e8 00 00 00 00	 call	 strcmp
  0011d	85 c0		 test	 eax, eax
  0011f	75 14		 jne	 SHORT $LN5@main
$LN6@main:

; 99   :         argexit( -1, NULL, pgm );

  00121	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00129	33 d2		 xor	 edx, edx
  0012b	b9 ff ff ff ff	 mov	 ecx, -1
  00130	e8 00 00 00 00	 call	 argexit
$LN5@main:

; 100  : 
; 101  :     /* Process optional arguments */
; 102  :     for ( ; argc > 1 && argv[1][0] == '-'; argv++, argc--)

  00135	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  00137	48 8b 84 24 08
	05 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0013f	48 83 c0 08	 add	 rax, 8
  00143	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR argv$[rsp], rax
  0014b	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00152	ff c8		 dec	 eax
  00154	89 84 24 00 05
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN4@main:
  0015b	83 bc 24 00 05
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00163	0f 8e 2b 02 00
	00		 jle	 $LN3@main
  00169	b8 08 00 00 00	 mov	 eax, 8
  0016e	48 6b c0 01	 imul	 rax, rax, 1
  00172	b9 01 00 00 00	 mov	 ecx, 1
  00177	48 6b c9 00	 imul	 rcx, rcx, 0
  0017b	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00183	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00187	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0018b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0018e	0f 85 00 02 00
	00		 jne	 $LN3@main

; 103  :     {
; 104  :         if (strcmp("0", &argv[1][1]) == 0)

  00194	b8 08 00 00 00	 mov	 eax, 8
  00199	48 6b c0 01	 imul	 rax, rax, 1
  0019d	b9 01 00 00 00	 mov	 ecx, 1
  001a2	48 6b c9 01	 imul	 rcx, rcx, 1
  001a6	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001ae	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	48 8b d0	 mov	 rdx, rax
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159637
  001bf	e8 00 00 00 00	 call	 strcmp
  001c4	85 c0		 test	 eax, eax
  001c6	75 0a		 jne	 SHORT $LN7@main

; 105  :             comp = CCKD_COMPRESS_NONE;

  001c8	c6 44 24 71 00	 mov	 BYTE PTR comp$[rsp], 0
  001cd	e9 bd 01 00 00	 jmp	 $LN8@main
$LN7@main:

; 106  : #if defined( HAVE_ZLIB )
; 107  :         else if (strcmp("z", &argv[1][1]) == 0)
; 108  :             comp = CCKD_COMPRESS_ZLIB;
; 109  : #endif
; 110  : #if defined( CCKD_BZIP2 )
; 111  :         else if (strcmp("bz2", &argv[1][1]) == 0)
; 112  :             comp = CCKD_COMPRESS_BZIP2;
; 113  : #endif
; 114  :         else if (strcmp("a", &argv[1][1]) == 0)

  001d2	b8 08 00 00 00	 mov	 eax, 8
  001d7	48 6b c0 01	 imul	 rax, rax, 1
  001db	b9 01 00 00 00	 mov	 ecx, 1
  001e0	48 6b c9 01	 imul	 rcx, rcx, 1
  001e4	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001ec	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  001f0	48 8b c1	 mov	 rax, rcx
  001f3	48 8b d0	 mov	 rdx, rax
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159640
  001fd	e8 00 00 00 00	 call	 strcmp
  00202	85 c0		 test	 eax, eax
  00204	75 10		 jne	 SHORT $LN9@main

; 115  :             altcylflag = 1;

  00206	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR altcylflag$[rsp], 1
  00211	e9 79 01 00 00	 jmp	 $LN10@main
$LN9@main:

; 116  :         else if (strcmp("r", &argv[1][1]) == 0)

  00216	b8 08 00 00 00	 mov	 eax, 8
  0021b	48 6b c0 01	 imul	 rax, rax, 1
  0021f	b9 01 00 00 00	 mov	 ecx, 1
  00224	48 6b c9 01	 imul	 rcx, rcx, 1
  00228	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00230	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00234	48 8b c1	 mov	 rax, rcx
  00237	48 8b d0	 mov	 rdx, rax
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159643
  00241	e8 00 00 00 00	 call	 strcmp
  00246	85 c0		 test	 eax, eax
  00248	75 10		 jne	 SHORT $LN11@main

; 117  :             rawflag = 1;

  0024a	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR rawflag$[rsp], 1
  00255	e9 35 01 00 00	 jmp	 $LN12@main
$LN11@main:

; 118  :         else if (strcmp("lfs", &argv[1][1]) == 0 && sizeof(off_t) > 4)

  0025a	b8 08 00 00 00	 mov	 eax, 8
  0025f	48 6b c0 01	 imul	 rax, rax, 1
  00263	b9 01 00 00 00	 mov	 ecx, 1
  00268	48 6b c9 01	 imul	 rcx, rcx, 1
  0026c	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00274	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00278	48 8b c1	 mov	 rax, rcx
  0027b	48 8b d0	 mov	 rdx, rax
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159646
  00285	e8 00 00 00 00	 call	 strcmp
  0028a	85 c0		 test	 eax, eax
  0028c	75 17		 jne	 SHORT $LN13@main
  0028e	33 c0		 xor	 eax, eax
  00290	83 f8 01	 cmp	 eax, 1
  00293	74 10		 je	 SHORT $LN13@main

; 119  :             lfs = 1;

  00295	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  002a0	e9 ea 00 00 00	 jmp	 $LN14@main
$LN13@main:

; 120  :         else if (strcmp("linux", &argv[1][1]) == 0)

  002a5	b8 08 00 00 00	 mov	 eax, 8
  002aa	48 6b c0 01	 imul	 rax, rax, 1
  002ae	b9 01 00 00 00	 mov	 ecx, 1
  002b3	48 6b c9 01	 imul	 rcx, rcx, 1
  002b7	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002bf	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  002c3	48 8b c1	 mov	 rax, rcx
  002c6	48 8b d0	 mov	 rdx, rax
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159649
  002d0	e8 00 00 00 00	 call	 strcmp
  002d5	85 c0		 test	 eax, eax
  002d7	75 10		 jne	 SHORT $LN15@main

; 121  :             nullfmt = CKD_NULLTRK_FMT2;

  002d9	c7 84 24 9c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 2
  002e4	e9 a6 00 00 00	 jmp	 $LN16@main
$LN15@main:

; 122  :         else if (strcmp("b", &argv[1][1]) == 0)

  002e9	b8 08 00 00 00	 mov	 eax, 8
  002ee	48 6b c0 01	 imul	 rax, rax, 1
  002f2	b9 01 00 00 00	 mov	 ecx, 1
  002f7	48 6b c9 01	 imul	 rcx, rcx, 1
  002fb	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00303	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00307	48 8b c1	 mov	 rax, rcx
  0030a	48 8b d0	 mov	 rdx, rax
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159652
  00314	e8 00 00 00 00	 call	 strcmp
  00319	85 c0		 test	 eax, eax
  0031b	75 0d		 jne	 SHORT $LN17@main

; 123  :             flagECmode = 0;

  0031d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR flagECmode$[rsp], 0
  00328	eb 65		 jmp	 SHORT $LN18@main
$LN17@main:

; 124  :         else if (strcmp("m", &argv[1][1]) == 0)

  0032a	b8 08 00 00 00	 mov	 eax, 8
  0032f	48 6b c0 01	 imul	 rax, rax, 1
  00333	b9 01 00 00 00	 mov	 ecx, 1
  00338	48 6b c9 01	 imul	 rcx, rcx, 1
  0033c	48 8b 94 24 08
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00344	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00348	48 8b c1	 mov	 rax, rcx
  0034b	48 8b d0	 mov	 rdx, rax
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159655
  00355	e8 00 00 00 00	 call	 strcmp
  0035a	85 c0		 test	 eax, eax
  0035c	75 0d		 jne	 SHORT $LN19@main

; 125  :             flagMachinecheck = 1;

  0035e	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR flagMachinecheck$[rsp], 1
  00369	eb 24		 jmp	 SHORT $LN20@main
$LN19@main:

; 126  :         else argexit( 0, argv[1], pgm );

  0036b	b8 08 00 00 00	 mov	 eax, 8
  00370	48 6b c0 01	 imul	 rax, rax, 1
  00374	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  0037c	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00384	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00388	33 c9		 xor	 ecx, ecx
  0038a	e8 00 00 00 00	 call	 argexit
$LN20@main:
$LN18@main:
$LN16@main:
$LN14@main:
$LN12@main:
$LN10@main:
$LN8@main:

; 127  :     }

  0038f	e9 a3 fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 128  : 
; 129  :     /* Check remaining number of arguments */
; 130  :     if (argc < (rawflag ? 3 : 4) || argc > (rawflag ? 4 : 5))

  00394	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  0039c	74 0d		 je	 SHORT $LN46@main
  0039e	c7 84 24 b0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv185[rsp], 3
  003a9	eb 0b		 jmp	 SHORT $LN47@main
$LN46@main:
  003ab	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv185[rsp], 4
$LN47@main:
  003b6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv185[rsp]
  003bd	39 84 24 00 05
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  003c4	7c 32		 jl	 SHORT $LN22@main
  003c6	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  003ce	74 0d		 je	 SHORT $LN48@main
  003d0	c7 84 24 b4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv188[rsp], 4
  003db	eb 0b		 jmp	 SHORT $LN49@main
$LN48@main:
  003dd	c7 84 24 b4 00
	00 00 05 00 00
	00		 mov	 DWORD PTR tv188[rsp], 5
$LN49@main:
  003e8	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv188[rsp]
  003ef	39 84 24 00 05
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  003f6	7e 14		 jle	 SHORT $LN21@main
$LN22@main:

; 131  :         argexit( 5, NULL, pgm );

  003f8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00400	33 d2		 xor	 edx, edx
  00402	b9 05 00 00 00	 mov	 ecx, 5
  00407	e8 00 00 00 00	 call	 argexit
$LN21@main:

; 132  : 
; 133  :     /* The first argument is the file name */
; 134  :     if (argv[1] == NULL || strlen(argv[1]) == 0
; 135  :         || strlen(argv[1]) > sizeof(fname)-1)

  0040c	b8 08 00 00 00	 mov	 eax, 8
  00411	48 6b c0 01	 imul	 rax, rax, 1
  00415	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0041d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00422	74 41		 je	 SHORT $LN24@main
  00424	b8 08 00 00 00	 mov	 eax, 8
  00429	48 6b c0 01	 imul	 rax, rax, 1
  0042d	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00435	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00439	e8 00 00 00 00	 call	 strlen
  0043e	48 85 c0	 test	 rax, rax
  00441	74 22		 je	 SHORT $LN24@main
  00443	b8 08 00 00 00	 mov	 eax, 8
  00448	48 6b c0 01	 imul	 rax, rax, 1
  0044c	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00454	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00458	e8 00 00 00 00	 call	 strlen
  0045d	48 3d ff 03 00
	00		 cmp	 rax, 1023		; 000003ffH
  00463	76 27		 jbe	 SHORT $LN23@main
$LN24@main:

; 136  :         argexit( 1, argv[1], pgm );

  00465	b8 08 00 00 00	 mov	 eax, 8
  0046a	48 6b c0 01	 imul	 rax, rax, 1
  0046e	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00476	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0047e	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00482	b9 01 00 00 00	 mov	 ecx, 1
  00487	e8 00 00 00 00	 call	 argexit
$LN23@main:

; 137  : 
; 138  :     STRLCPY( fname, argv[1] );

  0048c	b8 08 00 00 00	 mov	 eax, 8
  00491	48 6b c0 01	 imul	 rax, rax, 1
  00495	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  0049b	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004a3	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  004a7	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 139  : 
; 140  :     /* The second argument is the device type.
; 141  :        Model number may also be specified */
; 142  :     if (argv[2] == NULL)

  004b5	b8 08 00 00 00	 mov	 eax, 8
  004ba	48 6b c0 02	 imul	 rax, rax, 2
  004be	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004c6	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  004cb	75 27		 jne	 SHORT $LN25@main

; 143  :         argexit( 2, argv[2], pgm );

  004cd	b8 08 00 00 00	 mov	 eax, 8
  004d2	48 6b c0 02	 imul	 rax, rax, 2
  004d6	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  004de	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004e6	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  004ea	b9 02 00 00 00	 mov	 ecx, 2
  004ef	e8 00 00 00 00	 call	 argexit
$LN25@main:

; 144  :     ckd = dasd_lookup (DASD_CKDDEV, argv[2], 0, 0);

  004f4	b8 08 00 00 00	 mov	 eax, 8
  004f9	48 6b c0 02	 imul	 rax, rax, 2
  004fd	45 33 c9	 xor	 r9d, r9d
  00500	45 33 c0	 xor	 r8d, r8d
  00503	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0050b	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0050f	b9 01 00 00 00	 mov	 ecx, 1
  00514	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  0051a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 145  :     if (ckd != NULL)

  00522	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  0052b	74 61		 je	 SHORT $LN26@main

; 146  :     {
; 147  :         type = 'C';

  0052d	c6 44 24 70 43	 mov	 BYTE PTR type$[rsp], 67	; 00000043H

; 148  :         devtype = ckd->devt;

  00532	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0053a	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0053e	66 89 44 24 74	 mov	 WORD PTR devtype$[rsp], ax

; 149  :         size = ckd->cyls;

  00543	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0054b	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  0054f	89 44 24 7c	 mov	 DWORD PTR size$[rsp], eax

; 150  :         altsize = ckd->altcyls;

  00553	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0055b	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0055f	89 84 24 98 00
	00 00		 mov	 DWORD PTR altsize$[rsp], eax

; 151  :         heads = ckd->heads;

  00566	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  0056e	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  00572	89 84 24 c4 00
	00 00		 mov	 DWORD PTR heads$[rsp], eax

; 152  :         maxdlen = ckd->r1;

  00579	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  00581	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  00585	89 84 24 c0 00
	00 00		 mov	 DWORD PTR maxdlen$[rsp], eax

; 153  :     }

  0058c	eb 7b		 jmp	 SHORT $LN27@main
$LN26@main:

; 154  :     else
; 155  :     {
; 156  :         fba = dasd_lookup (DASD_FBADEV, argv[2], 0, 0);

  0058e	b8 08 00 00 00	 mov	 eax, 8
  00593	48 6b c0 02	 imul	 rax, rax, 2
  00597	45 33 c9	 xor	 r9d, r9d
  0059a	45 33 c0	 xor	 r8d, r8d
  0059d	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005a5	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  005a9	b9 03 00 00 00	 mov	 ecx, 3
  005ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  005b4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 157  :         if (fba != NULL)

  005bc	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  005c5	74 42		 je	 SHORT $LN28@main

; 158  :         {
; 159  :             type = 'F';

  005c7	c6 44 24 70 46	 mov	 BYTE PTR type$[rsp], 70	; 00000046H

; 160  :             devtype = fba->devt;

  005cc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  005d4	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  005d8	66 89 44 24 74	 mov	 WORD PTR devtype$[rsp], ax

; 161  :             size = fba->blks;

  005dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  005e5	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  005e8	89 44 24 7c	 mov	 DWORD PTR size$[rsp], eax

; 162  :             altsize = 0;

  005ec	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR altsize$[rsp], 0

; 163  :             sectsize = fba->size;

  005f7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR fba$[rsp]
  005ff	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00602	89 84 24 c8 00
	00 00		 mov	 DWORD PTR sectsize$[rsp], eax
$LN28@main:
$LN27@main:

; 164  :         }
; 165  :     }
; 166  : 
; 167  :     if (!type)

  00609	0f b6 44 24 70	 movzx	 eax, BYTE PTR type$[rsp]
  0060e	85 c0		 test	 eax, eax
  00610	75 27		 jne	 SHORT $LN29@main

; 168  :         /* Specified model not found */
; 169  :         argexit( 2, argv[2], pgm );

  00612	b8 08 00 00 00	 mov	 eax, 8
  00617	48 6b c0 02	 imul	 rax, rax, 2
  0061b	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00623	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0062b	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0062f	b9 02 00 00 00	 mov	 ecx, 2
  00634	e8 00 00 00 00	 call	 argexit
$LN29@main:

; 170  : 
; 171  :     /* If -r option specified, then there is not volume serial
; 172  :        argument and volume size argument is actually argument
; 173  :        number 3 and not argument number 4 as otherwise */
; 174  :     if (rawflag)

  00639	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rawflag$[rsp], 0
  00641	74 0d		 je	 SHORT $LN30@main

; 175  :         volsize_argnum = 3;

  00643	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR volsize_argnum$[rsp], 3
  0064b	e9 bd 00 00 00	 jmp	 $LN31@main
$LN30@main:

; 176  :     else
; 177  :     {
; 178  :         volsize_argnum = 4;

  00650	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR volsize_argnum$[rsp], 4

; 179  : 
; 180  :         /* The third argument is the volume serial number */
; 181  :         if (argv[3] == NULL || strlen(argv[3]) == 0
; 182  :             || strlen(argv[3]) > sizeof(volser)-1)

  00658	b8 08 00 00 00	 mov	 eax, 8
  0065d	48 6b c0 03	 imul	 rax, rax, 3
  00661	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00669	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0066e	74 3f		 je	 SHORT $LN33@main
  00670	b8 08 00 00 00	 mov	 eax, 8
  00675	48 6b c0 03	 imul	 rax, rax, 3
  00679	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00681	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00685	e8 00 00 00 00	 call	 strlen
  0068a	48 85 c0	 test	 rax, rax
  0068d	74 20		 je	 SHORT $LN33@main
  0068f	b8 08 00 00 00	 mov	 eax, 8
  00694	48 6b c0 03	 imul	 rax, rax, 3
  00698	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006a0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  006a4	e8 00 00 00 00	 call	 strlen
  006a9	48 83 f8 06	 cmp	 rax, 6
  006ad	76 27		 jbe	 SHORT $LN32@main
$LN33@main:

; 183  :             argexit( 3, argv[3], pgm );

  006af	b8 08 00 00 00	 mov	 eax, 8
  006b4	48 6b c0 03	 imul	 rax, rax, 3
  006b8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  006c0	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006c8	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  006cc	b9 03 00 00 00	 mov	 ecx, 3
  006d1	e8 00 00 00 00	 call	 argexit
$LN32@main:

; 184  : 
; 185  :         STRLCPY( volser, argv[3] );

  006d6	b8 08 00 00 00	 mov	 eax, 8
  006db	48 6b c0 03	 imul	 rax, rax, 3
  006df	41 b8 07 00 00
	00		 mov	 r8d, 7
  006e5	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006ed	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  006f1	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 186  :         string_to_upper (volser);

  006ff	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  00707	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper
$LN31@main:

; 187  :     }
; 188  : 
; 189  :     /* The fourth argument (or third for -r) is the volume size */
; 190  :     if (argc > volsize_argnum)

  0070d	8b 44 24 78	 mov	 eax, DWORD PTR volsize_argnum$[rsp]
  00711	39 84 24 00 05
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  00718	0f 8e 0b 01 00
	00		 jle	 $LN34@main

; 191  :     {
; 192  :         S32 signed_size = 0;    /* SIGNED Volume size */

  0071e	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR signed_size$1[rsp], 0

; 193  : 
; 194  :         if (argc > (volsize_argnum+1))

  00729	8b 44 24 78	 mov	 eax, DWORD PTR volsize_argnum$[rsp]
  0072d	ff c0		 inc	 eax
  0072f	39 84 24 00 05
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  00736	7e 14		 jle	 SHORT $LN35@main

; 195  :             argexit( 5, NULL, pgm );

  00738	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00740	33 d2		 xor	 edx, edx
  00742	b9 05 00 00 00	 mov	 ecx, 5
  00747	e8 00 00 00 00	 call	 argexit
$LN35@main:

; 196  : 
; 197  :         if (0
; 198  :             || !argv      [volsize_argnum]
; 199  :             || strlen(argv[volsize_argnum]) == 0
; 200  :             || sscanf(argv[volsize_argnum], "%d%c", &signed_size, &c) != 1
; 201  :             || (type == 'C' && (signed_size < 1 || signed_size > 65536))
; 202  :             || (type == 'F' && signed_size < 64)

  0074c	33 c0		 xor	 eax, eax
  0074e	85 c0		 test	 eax, eax
  00750	0f 85 9a 00 00
	00		 jne	 $LN37@main
  00756	48 63 44 24 78	 movsxd	 rax, DWORD PTR volsize_argnum$[rsp]
  0075b	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00763	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00768	0f 84 82 00 00
	00		 je	 $LN37@main
  0076e	48 63 44 24 78	 movsxd	 rax, DWORD PTR volsize_argnum$[rsp]
  00773	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0077b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0077f	e8 00 00 00 00	 call	 strlen
  00784	48 85 c0	 test	 rax, rax
  00787	74 67		 je	 SHORT $LN37@main
  00789	48 63 44 24 78	 movsxd	 rax, DWORD PTR volsize_argnum$[rsp]
  0078e	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR c$[rsp]
  00796	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR signed_size$1[rsp]
  0079e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159673
  007a5	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007ad	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  007b1	e8 00 00 00 00	 call	 sscanf
  007b6	83 f8 01	 cmp	 eax, 1
  007b9	75 35		 jne	 SHORT $LN37@main
  007bb	0f b6 44 24 70	 movzx	 eax, BYTE PTR type$[rsp]
  007c0	83 f8 43	 cmp	 eax, 67			; 00000043H
  007c3	75 17		 jne	 SHORT $LN38@main
  007c5	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR signed_size$1[rsp], 1
  007cd	7c 21		 jl	 SHORT $LN37@main
  007cf	81 bc 24 84 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR signed_size$1[rsp], 65536 ; 00010000H
  007da	7f 14		 jg	 SHORT $LN37@main
$LN38@main:
  007dc	0f b6 44 24 70	 movzx	 eax, BYTE PTR type$[rsp]
  007e1	83 f8 46	 cmp	 eax, 70			; 00000046H
  007e4	75 2d		 jne	 SHORT $LN36@main
  007e6	83 bc 24 84 00
	00 00 40	 cmp	 DWORD PTR signed_size$1[rsp], 64 ; 00000040H
  007ee	7d 23		 jge	 SHORT $LN36@main
$LN37@main:

; 203  :         )
; 204  :             argexit( 4, argv[volsize_argnum], pgm );

  007f0	48 63 44 24 78	 movsxd	 rax, DWORD PTR volsize_argnum$[rsp]
  007f5	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  007fd	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00805	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00809	b9 04 00 00 00	 mov	 ecx, 4
  0080e	e8 00 00 00 00	 call	 argexit
$LN36@main:

; 205  : 
; 206  :         size = (U32) signed_size;

  00813	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR signed_size$1[rsp]
  0081a	89 44 24 7c	 mov	 DWORD PTR size$[rsp], eax

; 207  :         altcylflag = 0;

  0081e	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR altcylflag$[rsp], 0
$LN34@main:

; 208  :     }
; 209  : 
; 210  :     /* `-linux' only supported for 3390 device type */
; 211  :     if (nullfmt == CKD_NULLTRK_FMT2 && devtype != 0x3390)

  00829	83 bc 24 9c 00
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  00831	75 20		 jne	 SHORT $LN39@main
  00833	0f b7 44 24 74	 movzx	 eax, WORD PTR devtype$[rsp]
  00838	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  0083d	74 14		 je	 SHORT $LN39@main

; 212  :         argexit( 6, NULL, pgm );

  0083f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pgm$[rsp]
  00847	33 d2		 xor	 edx, edx
  00849	b9 06 00 00 00	 mov	 ecx, 6
  0084e	e8 00 00 00 00	 call	 argexit
$LN39@main:

; 213  : 
; 214  :     if (altcylflag)

  00853	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR altcylflag$[rsp], 0
  0085b	74 13		 je	 SHORT $LN40@main

; 215  :         size += altsize;

  0085d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR altsize$[rsp]
  00864	8b 4c 24 7c	 mov	 ecx, DWORD PTR size$[rsp]
  00868	03 c8		 add	 ecx, eax
  0086a	8b c1		 mov	 eax, ecx
  0086c	89 44 24 7c	 mov	 DWORD PTR size$[rsp], eax
$LN40@main:

; 216  : 
; 217  :     /* Create the device */
; 218  :     if (type == 'C')

  00870	0f b6 44 24 70	 movzx	 eax, BYTE PTR type$[rsp]
  00875	83 f8 43	 cmp	 eax, 67			; 00000043H
  00878	0f 85 8b 00 00
	00		 jne	 $LN41@main

; 219  :         rc = create_ckd64( fname, devtype, heads, maxdlen, size, volser,

  0087e	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR flagMachinecheck$[rsp]
  00886	88 44 24 60	 mov	 BYTE PTR [rsp+96], al
  0088a	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR flagECmode$[rsp]
  00892	88 44 24 58	 mov	 BYTE PTR [rsp+88], al
  00896	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR rawflag$[rsp]
  0089e	88 44 24 50	 mov	 BYTE PTR [rsp+80], al
  008a2	0f b6 84 24 9c
	00 00 00	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  008aa	88 44 24 48	 mov	 BYTE PTR [rsp+72], al
  008ae	c6 44 24 40 00	 mov	 BYTE PTR [rsp+64], 0
  008b3	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  008bb	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  008bf	0f b6 44 24 71	 movzx	 eax, BYTE PTR comp$[rsp]
  008c4	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  008c8	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  008d0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008d5	8b 44 24 7c	 mov	 eax, DWORD PTR size$[rsp]
  008d9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008dd	44 8b 8c 24 c0
	00 00 00	 mov	 r9d, DWORD PTR maxdlen$[rsp]
  008e5	44 8b 84 24 c4
	00 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  008ed	0f b7 54 24 74	 movzx	 edx, WORD PTR devtype$[rsp]
  008f2	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  008fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_ckd64
  00900	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00907	eb 5b		 jmp	 SHORT $LN42@main
$LN41@main:

; 220  :                            comp, (BYTE) lfs, (BYTE) 0, (BYTE) nullfmt,
; 221  :                            (BYTE) rawflag, (BYTE) flagECmode,
; 222  :                            (BYTE) flagMachinecheck );
; 223  :     else
; 224  :         rc = create_fba64( fname, devtype, sectsize, size, volser, comp,

  00909	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rawflag$[rsp]
  00910	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00914	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  0091c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR lfs$[rsp]
  00923	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00927	0f b6 44 24 71	 movzx	 eax, BYTE PTR comp$[rsp]
  0092c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00930	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  00938	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0093d	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR size$[rsp]
  00942	44 8b 84 24 c8
	00 00 00	 mov	 r8d, DWORD PTR sectsize$[rsp]
  0094a	0f b7 54 24 74	 movzx	 edx, WORD PTR devtype$[rsp]
  0094f	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00957	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_fba64
  0095d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN42@main:

; 225  :                            lfs, 0, rawflag );
; 226  : 
; 227  :     /* Display completion message */
; 228  :     if (rc == 0)

  00964	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0096c	75 49		 jne	 SHORT $LN43@main

; 229  :     {
; 230  :         // "DASD operation completed"
; 231  :         WRMSG( HHC02423, "I" );

  0096e	b9 01 00 00 00	 mov	 ecx, 1
  00973	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00979	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159681
  00980	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00985	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159682
  0098c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00991	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00996	41 b9 03 00 00
	00		 mov	 r9d, 3
  0099c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159683
  009a3	ba e7 00 00 00	 mov	 edx, 231		; 000000e7H
  009a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159684
  009af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 232  :     } else {

  009b5	eb 47		 jmp	 SHORT $LN44@main
$LN43@main:

; 233  :         // "DASD operation failed"
; 234  :         FWRMSG( stderr, HHC02449, "E" );

  009b7	b9 02 00 00 00	 mov	 ecx, 2
  009bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159685
  009c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159686
  009d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009df	41 b9 03 00 00
	00		 mov	 r9d, 3
  009e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159687
  009ec	ba ea 00 00 00	 mov	 edx, 234		; 000000eaH
  009f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159688
  009f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN44@main:

; 235  :     }
; 236  : 
; 237  :     return rc;

  009fe	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]

; 238  : 
; 239  : } /* end function main */

  00a05	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a0d	48 33 cc	 xor	 rcx, rsp
  00a10	e8 00 00 00 00	 call	 __security_check_cookie
  00a15	48 81 c4 f8 04
	00 00		 add	 rsp, 1272		; 000004f8H
  00a1c	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdinit64.c
_TEXT	SEGMENT
tv64 = 96
tv66 = 104
tv79 = 112
tv92 = 120
tv137 = 128
tv150 = 136
buflfs$1 = 144
bufbz$2 = 152
bufz$3 = 160
code$ = 192
m$ = 200
pgm$ = 208
argexit	PROC

; 245  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 246  :     // HHC02445: "Invalid, unsupported or missing %s: %s"
; 247  : 
; 248  :     switch (code) {

  00015	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR code$[rsp]
  0001c	89 44 24 60	 mov	 DWORD PTR tv64[rsp], eax
  00020	83 7c 24 60 06	 cmp	 DWORD PTR tv64[rsp], 6
  00025	0f 87 6a 03 00
	00		 ja	 $LN11@argexit
  0002b	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv64[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00037	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN24@argexit[rcx+rax*4]
  0003e	48 03 c1	 add	 rax, rcx
  00041	ff e0		 jmp	 rax
$LN4@argexit:

; 249  :     case 0:
; 250  :         FWRMSG( stderr, HHC02445, "E", "option",      m ? m : "(null)" );

  00043	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  0004c	74 0f		 je	 SHORT $LN14@argexit
  0004e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00056	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
  0005b	eb 0c		 jmp	 SHORT $LN15@argexit
$LN14@argexit:
  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159703
  00064	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
$LN15@argexit:
  00069	b9 02 00 00 00	 mov	 ecx, 2
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00074	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv66[rsp]
  00079	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159704
  00085	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159705
  00091	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159706
  0009d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159707
  000b4	ba fa 00 00 00	 mov	 edx, 250		; 000000faH
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159708
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 251  :         break;

  000c6	e9 88 03 00 00	 jmp	 $LN2@argexit
$LN5@argexit:

; 252  :     case 1:
; 253  :         FWRMSG( stderr, HHC02445, "E", "filename",    m ? m : "(null)" );

  000cb	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  000d4	74 0f		 je	 SHORT $LN16@argexit
  000d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  000de	48 89 44 24 70	 mov	 QWORD PTR tv79[rsp], rax
  000e3	eb 0c		 jmp	 SHORT $LN17@argexit
$LN16@argexit:
  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159710
  000ec	48 89 44 24 70	 mov	 QWORD PTR tv79[rsp], rax
$LN17@argexit:
  000f1	b9 02 00 00 00	 mov	 ecx, 2
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv79[rsp]
  00101	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159711
  0010d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159712
  00119	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159713
  00125	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00135	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159714
  0013c	ba fd 00 00 00	 mov	 edx, 253		; 000000fdH
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159715
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 254  :         break;

  0014e	e9 00 03 00 00	 jmp	 $LN2@argexit
$LN6@argexit:

; 255  :     case 2:
; 256  :         FWRMSG( stderr, HHC02445, "E", "device type", m ? m : "(null)" );

  00153	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  0015c	74 0f		 je	 SHORT $LN18@argexit
  0015e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00166	48 89 44 24 78	 mov	 QWORD PTR tv92[rsp], rax
  0016b	eb 0c		 jmp	 SHORT $LN19@argexit
$LN18@argexit:
  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159717
  00174	48 89 44 24 78	 mov	 QWORD PTR tv92[rsp], rax
$LN19@argexit:
  00179	b9 02 00 00 00	 mov	 ecx, 2
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00184	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv92[rsp]
  00189	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159718
  00195	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159719
  001a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159720
  001ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159721
  001c4	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159722
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 257  :         break;

  001d6	e9 78 02 00 00	 jmp	 $LN2@argexit
$LN7@argexit:

; 258  :     case 3:
; 259  :         FWRMSG( stderr, HHC02445, "E", "volser",      m ? m : "(null)" );

  001db	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  001e4	74 12		 je	 SHORT $LN20@argexit
  001e6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  001ee	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
  001f6	eb 0f		 jmp	 SHORT $LN21@argexit
$LN20@argexit:
  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159724
  001ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
$LN21@argexit:
  00207	b9 02 00 00 00	 mov	 ecx, 2
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv137[rsp]
  0021a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159725
  00226	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159726
  00232	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159727
  0023e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159728
  00255	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159729
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 260  :         break;

  00267	e9 e7 01 00 00	 jmp	 $LN2@argexit
$LN8@argexit:

; 261  :     case 4:
; 262  :         FWRMSG( stderr, HHC02445, "E", "size",        m ? m : "(null)" );

  0026c	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  00275	74 12		 je	 SHORT $LN22@argexit
  00277	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  0027f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  00287	eb 0f		 jmp	 SHORT $LN23@argexit
$LN22@argexit:
  00289	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159731
  00290	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
$LN23@argexit:
  00298	b9 02 00 00 00	 mov	 ecx, 2
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  002ab	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159732
  002b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159733
  002c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159734
  002cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  002df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159735
  002e6	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159736
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 263  :         break;

  002f8	e9 56 01 00 00	 jmp	 $LN2@argexit
$LN9@argexit:

; 264  :     case 5:
; 265  :         FWRMSG( stderr, HHC02446, "E" );

  002fd	b9 02 00 00 00	 mov	 ecx, 2
  00302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159738
  0030f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159739
  0031b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00320	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00325	41 b9 03 00 00
	00		 mov	 r9d, 3
  0032b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159740
  00332	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159741
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 266  :         break;

  00344	e9 0a 01 00 00	 jmp	 $LN2@argexit
$LN10@argexit:

; 267  :     case 6:
; 268  :         FWRMSG( stderr, HHC02447, "E" );

  00349	b9 02 00 00 00	 mov	 ecx, 2
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159743
  0035b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159744
  00367	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00371	41 b9 03 00 00
	00		 mov	 r9d, 3
  00377	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159745
  0037e	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159746
  0038a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 269  :         break;

  00390	e9 be 00 00 00	 jmp	 $LN2@argexit
$LN11@argexit:

; 270  :     default:
; 271  :         {
; 272  :             // HHC02448 "Usage: dasdinit64 ...."
; 273  : 
; 274  : #if defined( HAVE_ZLIB )
; 275  :             char *bufz = "HHC02448I   -z        build compressed dasd image file using zlib\n";
; 276  : #else
; 277  :             char *bufz = "";

  00395	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159748
  0039c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR bufz$3[rsp], rax

; 278  : #endif
; 279  : 
; 280  : #if defined( CCKD_BZIP2 )
; 281  :             char *bufbz = "HHC02448I   -bz2      build compressed dasd image file using bzip2\n";
; 282  : #else
; 283  :             char *bufbz = "";

  003a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159749
  003ab	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR bufbz$2[rsp], rax

; 284  : #endif
; 285  : 
; 286  :             char* buflfs = "";

  003b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159750
  003ba	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR buflfs$1[rsp], rax

; 287  : 
; 288  :             if (sizeof(off_t) > 4)

  003c2	33 c0		 xor	 eax, eax
  003c4	83 f8 01	 cmp	 eax, 1
  003c7	74 0f		 je	 SHORT $LN12@argexit

; 289  :                 buflfs = "HHC02448I   -lfs      build a large (uncompressed) dasd file (if supported)\n";

  003c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159752
  003d0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR buflfs$1[rsp], rax
$LN12@argexit:

; 290  : 
; 291  :             WRMSG( HHC02448, "I", pgm, bufz, bufbz, buflfs );

  003d8	b9 01 00 00 00	 mov	 ecx, 1
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR buflfs$1[rsp]
  003eb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003f0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR bufbz$2[rsp]
  003f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR bufz$3[rsp]
  00405	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0040a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00412	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00417	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159753
  0041e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159754
  0042a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0042f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00434	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159755
  00441	ba 23 01 00 00	 mov	 edx, 291		; 00000123H
  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159756
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@argexit:

; 292  :         }
; 293  :         break;
; 294  :     }
; 295  : 
; 296  :     exit(code);

  00453	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR code$[rsp]
  0045a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN13@argexit:

; 297  : 
; 298  : } /* end function argexit */

  00460	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00467	c3		 ret	 0
$LN24@argexit:
  00468	00 00 00 00	 DD	 $LN4@argexit
  0046c	00 00 00 00	 DD	 $LN5@argexit
  00470	00 00 00 00	 DD	 $LN6@argexit
  00474	00 00 00 00	 DD	 $LN7@argexit
  00478	00 00 00 00	 DD	 $LN8@argexit
  0047c	00 00 00 00	 DD	 $LN9@argexit
  00480	00 00 00 00	 DD	 $LN10@argexit
argexit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
