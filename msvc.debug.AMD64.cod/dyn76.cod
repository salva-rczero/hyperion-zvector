; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vstore4_full
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vstorec
PUBLIC	s370_vstore4
PUBLIC	s370_vfetchc
PUBLIC	s370_vfetch4
PUBLIC	s370_hdiagf18_FC
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore4_full
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vstorec
PUBLIC	s390_vstore4
PUBLIC	s390_vfetchc
PUBLIC	s390_vfetch4
PUBLIC	s390_hdiagf18_FC
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore4_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstore4
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetch4
PUBLIC	z900_hdiagf18_FC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp__lseek:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp_rename:PROC
EXTRN	__imp__unlink:PROC
EXTRN	__imp__setmode:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
fkpr_head DQ	01H DUP (?)
rst_head DQ	01H DUP (?)
nfile_lock DB	028H DUP (?)
nfile_id DD	01H DUP (?)
restart_id DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+313
	DD	imagerel $unwind$s370_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4 DD imagerel $LN27
	DD	imagerel $LN27+289
	DD	imagerel $unwind$s370_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$StrConverter DD imagerel StrConverter
	DD	imagerel StrConverter+88
	DD	imagerel $unwind$StrConverter
$pdata$MemConverter DD imagerel MemConverter
	DD	imagerel MemConverter+85
	DD	imagerel $unwind$MemConverter
$pdata$nfile_init DD imagerel nfile_init
	DD	imagerel nfile_init+22
	DD	imagerel $unwind$nfile_init
$pdata$FindFK DD imagerel FindFK
	DD	imagerel FindFK+116
	DD	imagerel $unwind$FindFK
$pdata$RemoveFKByID DD imagerel RemoveFKByID
	DD	imagerel RemoveFKByID+180
	DD	imagerel $unwind$RemoveFKByID
$pdata$RemoveFKByName DD imagerel RemoveFKByName
	DD	imagerel RemoveFKByName+243
	DD	imagerel $unwind$RemoveFKByName
$pdata$s370_hdiagf18_FC DD imagerel $LN90
	DD	imagerel $LN90+4544
	DD	imagerel $unwind$s370_hdiagf18_FC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$s390_hdiagf18_FC DD imagerel $LN90
	DD	imagerel $LN90+4596
	DD	imagerel $unwind$s390_hdiagf18_FC
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$z900_hdiagf18_FC DD imagerel $LN90
	DD	imagerel $LN90+4734
	DD	imagerel $unwind$z900_hdiagf18_FC
pdata	ENDS
_DATA	SEGMENT
DCCascii_to_ebcdic DB 00H, 01H, 02H, 03H, '7-./', 016H, 05H, 015H, 0bH, 0cH
	DB	0dH, 0eH, 0fH, 010H, 011H, 012H, 013H, '<=2&', 018H, 019H, '?'''
	DB	01cH, 01dH, 01eH, 01fH, '@Z', 07fH, '{[lP}M]\Nk`Ka', 0f0H, 0f1H
	DB	0f2H, 0f3H, 0f4H, 0f5H, 0f6H, 0f7H, 0f8H, 0f9H, 'z^L~no|', 0c1H
	DB	0c2H, 0c3H, 0c4H, 0c5H, 0c6H, 0c7H, 0c8H, 0c9H, 0d1H, 0d2H, 0d3H
	DB	0d4H, 0d5H, 0d6H, 0d7H, 0d8H, 0d9H, 0e2H, 0e3H, 0e4H, 0e5H, 0e6H
	DB	0e7H, 0e8H, 0e9H, 0adH, 0e0H, 0bdH, '_my', 081H, 082H, 083H, 084H
	DB	085H, 086H, 087H, 088H, 089H, 091H, 092H, 093H, 094H, 095H, 096H
	DB	097H, 098H, 099H, 0a2H, 0a3H, 0a4H, 0a5H, 0a6H, 0a7H, 0a8H, 0a9H
	DB	0c0H, 'O', 0d0H, 0a1H, 07H, ' !"#$%', 06H, 017H, '()*+,', 09H, 0aH
	DB	01bH, '01', 01aH, '3456', 08H, '89:;', 04H, 014H, '>', 0ffH, 'A'
	DB	0aaH, 'J', 0b1H, 09fH, 0b2H, 'j', 0b5H, 0bbH, 0b4H, 09aH, 08aH
	DB	0b0H, 0caH, 0afH, 0bcH, 090H, 08fH, 0eaH, 0faH, 0beH, 0a0H, 0b6H
	DB	0b3H, 09dH, 0daH, 09bH, 08bH, 0b7H, 0b8H, 0b9H, 0abH, 'debfcg', 09eH
	DB	'htqrsxuvw', 0acH, 'i', 0edH, 0eeH, 0ebH, 0efH, 0ecH, 0bfH, 080H
	DB	0fdH, 0feH, 0fbH, 0fcH, 0baH, 0aeH, 'YDEBFCG', 09cH, 'HTQRSXUV'
	DB	'W', 08cH, 'I', 0cdH, 0ceH, 0cbH, 0cfH, 0ccH, 0e1H, 'p', 0ddH, 0deH
	DB	0dbH, 0dcH, 08dH, 08eH, 0dfH, 00H
	ORG $+15
DCCebcdic_to_ascii DB 00H, 01H, 02H, 03H, 09cH, 09H, 086H, 07fH, 097H, 08dH
	DB	08eH, 0bH, 0cH, 0dH, 0eH, 0fH, 010H, 011H, 012H, 013H, 09dH, 0aH
	DB	08H, 087H, 018H, 019H, 092H, 08fH, 01cH, 01dH, 01eH, 01fH, 080H
	DB	081H, 082H, 083H, 084H, 085H, 017H, 01bH, 088H, 089H, 08aH, 08bH
	DB	08cH, 05H, 06H, 07H, 090H, 091H, 016H, 093H, 094H, 095H, 096H, 04H
	DB	098H, 099H, 09aH, 09bH, 014H, 015H, 09eH, 01aH, ' ', 0a0H, 0e2H
	DB	0e4H, 0e0H, 0e1H, 0e3H, 0e5H, 0e7H, 0f1H, 0a2H, '.<(+|&', 0e9H
	DB	0eaH, 0ebH, 0e8H, 0edH, 0eeH, 0efH, 0ecH, 0dfH, '!$*);^-/', 0c2H
	DB	0c4H, 0c0H, 0c1H, 0c3H, 0c5H, 0c7H, 0d1H, 0a6H, ',%_>?', 0f8H, 0c9H
	DB	0caH, 0cbH, 0c8H, 0cdH, 0ceH, 0cfH, 0ccH, '`:#@''="', 0d8H, 'a'
	DB	'bcdefghi', 0abH, 0bbH, 0f0H, 0fdH, 0feH, 0b1H, 0b0H, 'jklmnop'
	DB	'qr', 0aaH, 0baH, 0e6H, 0b8H, 0c6H, 0a4H, 0b5H, '~stuvwxyz', 0a1H
	DB	0bfH, 0d0H, '[', 0deH, 0aeH, 0acH, 0a3H, 0a5H, 0b7H, 0a9H, 0a7H
	DB	0b6H, 0bcH, 0bdH, 0beH, 0ddH, 0a8H, 0afH, ']', 0b4H, 0d7H, '{A'
	DB	'BCDEFGHI', 0adH, 0f4H, 0f6H, 0f2H, 0f3H, 0f5H, '}JKLMNOPQR', 0b9H
	DB	0fbH, 0fcH, 0f9H, 0faH, 0ffH, '\', 0f7H, 'STUVWXYZ', 0b2H, 0d4H
	DB	0d6H, 0d2H, 0d3H, 0d5H, '0123456789', 0b3H, 0dbH, 0dcH, 0d9H, 0daH
	DB	09fH, 00H
	ORG $+3
nfile_init_req DD 01H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
xdata	SEGMENT
$unwind$StrConverter DD 010e01H
	DD	0220eH
$unwind$MemConverter DD 011301H
	DD	02213H
$unwind$nfile_init DD 010401H
	DD	04204H
$unwind$FindFK DD 010d01H
	DD	0620dH
$unwind$RemoveFKByID DD 011201H
	DD	06212H
$unwind$RemoveFKByName DD 010901H
	DD	08209H
$unwind$s370_hdiagf18_FC DD 021401H
	DD	0110114H
$unwind$s390_hdiagf18_FC DD 021401H
	DD	0110114H
$unwind$z900_hdiagf18_FC DD 021501H
	DD	0110115H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4 DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
R15$ = 48
i$ = 52
rfk$ = 56
res$ = 64
R4$ = 68
R5$ = 72
R1$ = 76
R2$ = 80
R0$ = 84
R3$ = 88
handle$ = 92
space_ctl$ = 96
fk$ = 104
ghandle$ = 112
tv488 = 116
options$ = 144
cmpb$ = 152
regs$ = 160
z900_hdiagf18_FC PROC

; 345  : {

$LN90:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 346  :     int    space_ctl;           /* This is used to control address space selection */
; 347  :     int    i;
; 348  :     int    res;                 /* I/O integer results */
; 349  :     int    handle = 0;          /* Host file file handle for this file */

  00015	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR handle$[rsp], 0

; 350  :     U32    ghandle = 0;         /* Guest file descriptor */

  0001d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR ghandle$[rsp], 0

; 351  :     struct fkeeper *fk = NULL;  /* Host file structure */

  00025	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fk$[rsp], 0

; 352  :     struct fkeeper *rfk = NULL; /* Restart structure */

  0002e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 353  : #ifdef DYN76_DEBUG
; 354  :     int    io_error = 0;        /* Saves the errno for log messages */
; 355  : #endif
; 356  : 
; 357  :     /* Pseudo register contents are cached here once retrieved */
; 358  :     U32    R0;
; 359  :     U32    R1;
; 360  :     U32    R2;
; 361  :     U32    R3;
; 362  :     U32    R4;
; 363  :     U32    R5;
; 364  :     U32    R15;
; 365  : 
; 366  :     /* Initialise the LOCK on our first use */
; 367  :     if (nfile_init_req)

  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nfile_init_req, 0
  0003e	74 0f		 je	 SHORT $LN10@z900_hdiag

; 368  :     {
; 369  :         nfile_init_req = 0;

  00040	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nfile_init_req, 0

; 370  :         nfile_init ();

  0004a	e8 00 00 00 00	 call	 nfile_init
$LN10@z900_hdiag:

; 371  :     }
; 372  : 
; 373  : #ifdef DYN76_DEBUG
; 374  :     logmsg("DF18: CFILE Validating FOCPB Address %X\n", cmpb);
; 375  : #endif
; 376  : 
; 377  :     /* CPB must be on a doubleword and must not cross physical page boundary */
; 378  :     if ( ((cmpb & 0x7) != 0 ) ||

  0004f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00057	48 83 e0 07	 and	 rax, 7
  0005b	48 85 c0	 test	 rax, rax
  0005e	75 26		 jne	 SHORT $LN12@z900_hdiag
  00060	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00068	48 83 c0 3f	 add	 rax, 63			; 0000003fH
  0006c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00072	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cmpb$[rsp]
  0007a	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00081	48 3b c1	 cmp	 rax, rcx
  00084	74 12		 je	 SHORT $LN11@z900_hdiag
$LN12@z900_hdiag:

; 379  :          (((cmpb + 63) & STORAGE_KEY_PAGEMASK) != (cmpb & STORAGE_KEY_PAGEMASK)) )
; 380  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00086	ba 06 00 00 00	 mov	 edx, 6
  0008b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_hdiag:

; 381  : 
; 382  : #ifdef DYN76_DEBUG
; 383  :     logmsg("DF18: CFILE Validated FOCPB Address\n");
; 384  : #endif
; 385  : 
; 386  :     get_reg(R1, 1);     /* Retrieve the function number */

  00098	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  000a0	48 83 c0 04	 add	 rax, 4
  000a4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	ba fe ff ff ff	 mov	 edx, -2
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 z900_vfetch4
  000b9	89 44 24 4c	 mov	 DWORD PTR R1$[rsp], eax

; 387  :     if (R1 > 9)

  000bd	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  000c2	76 39		 jbe	 SHORT $LN13@z900_hdiag

; 388  :     {   /* Invalid Function - generate an exception */
; 389  :         R0 = 0;

  000c4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 390  :         set_reg(0,R0);  /* don't restart this */

  000cc	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d4	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  000da	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  000e2	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  000e6	e8 00 00 00 00	 call	 z900_vstore4

; 391  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  000eb	ba 15 00 00 00	 mov	 edx, 21
  000f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_hdiag:

; 392  :     }
; 393  : 
; 394  :     get_reg(R2, 2);  /* All functions use parameter 1, so fetch it */

  000fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00105	48 83 c0 08	 add	 rax, 8
  00109	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00111	ba fe ff ff ff	 mov	 edx, -2
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 z900_vfetch4
  0011e	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 395  : 
; 396  :     /* read, write, seek, commit, close and setmode use the file descriptor */
; 397  :     if (R1 >= 4 && R1 <= 9)

  00122	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00127	0f 82 d3 00 00
	00		 jb	 $LN14@z900_hdiag
  0012d	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  00132	0f 87 c8 00 00
	00		 ja	 $LN14@z900_hdiag

; 398  :     {
; 399  :         if (R1 == 4 || R1 == 5)

  00138	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  0013d	74 07		 je	 SHORT $LN17@z900_hdiag
  0013f	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  00144	75 2f		 jne	 SHORT $LN15@z900_hdiag
$LN17@z900_hdiag:

; 400  :         {   /* For read and write guest file descriptor is in pseudo R3 */
; 401  :             get_reg(R3, 3);

  00146	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0014e	48 83 c0 0c	 add	 rax, 12
  00152	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0015a	ba fe ff ff ff	 mov	 edx, -2
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 z900_vfetch4
  00167	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 402  :             ghandle = R3;

  0016b	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  0016f	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax

; 403  :         }

  00173	eb 08		 jmp	 SHORT $LN16@z900_hdiag
$LN15@z900_hdiag:

; 404  :         else
; 405  :         {   /* For seek, commit, close and setmode, file descriptor is in
; 406  :                previously fetched pseudo R2 */
; 407  :             ghandle = R2;

  00175	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00179	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax
$LN16@z900_hdiag:

; 408  :         }
; 409  : 
; 410  :         /* If read, write, seek, commit, close or setmode */
; 411  :         /* convert the file descriptor into a file handle */
; 412  : #ifdef DYN76_DEBUG_FKEEPER
; 413  :         logmsg("DF18: CFILE - looking for guest file descriptor %d\n", ghandle);
; 414  : #endif
; 415  :         fk = FindFK(ghandle, &fkpr_head);

  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  00184	8b 4c 24 70	 mov	 ecx, DWORD PTR ghandle$[rsp]
  00188	e8 00 00 00 00	 call	 FindFK
  0018d	48 89 44 24 68	 mov	 QWORD PTR fk$[rsp], rax

; 416  : #ifdef DYN76_DEBUG_FKEEPER
; 417  :         logmsg("DF18: CFILE - guest file descriptor %d found at %X\n",
; 418  :                ghandle, fk);
; 419  : #endif
; 420  :         if (!fk)

  00192	48 83 7c 24 68
	00		 cmp	 QWORD PTR fk$[rsp], 0
  00198	75 5a		 jne	 SHORT $LN18@z900_hdiag

; 421  :         {   /* Did not find the guest file descriptor.
; 422  :                Treat it as if it were a bad host file handle */
; 423  : #ifdef DYN76_DEBUG
; 424  :             logmsg("DF18: CFILE - guest file descriptor not found: %d\n", ghandle);
; 425  : #endif
; 426  :             R15 = -1 * EBADF;

  0019a	c7 44 24 30 f7
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -9	; fffffff7H

; 427  :             set_reg(15,R15);

  001a2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  001aa	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  001ae	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001bc	48 8b d0	 mov	 rdx, rax
  001bf	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  001c3	e8 00 00 00 00	 call	 z900_vstore4

; 428  :             R0 = 0;

  001c8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 429  :             set_reg(0,R0); /* No restart on a failure */

  001d0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001d8	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001de	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  001e6	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  001ea	e8 00 00 00 00	 call	 z900_vstore4

; 430  :             return;

  001ef	e9 82 10 00 00	 jmp	 $LN1@z900_hdiag
$LN18@z900_hdiag:

; 431  :         }
; 432  :         handle = fk->handle;  /* All host file accesses use this variable */

  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  001f9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001fc	89 44 24 5c	 mov	 DWORD PTR handle$[rsp], eax
$LN14@z900_hdiag:

; 433  : #ifdef DYN76_DEBUG_FKEEPER
; 434  :         logmsg("DF18: CFILE - host file handle: %d\n", handle);
; 435  : #endif
; 436  :     }
; 437  : 
; 438  : /* The following 4 functions are always ready to attempt
; 439  :    and they are not interruptible: CLOSE, COMMIT, SEEK, SETMODE
; 440  : */
; 441  : 
; 442  :     /*------------------------*/
; 443  :     /* SETMODE File Operation */
; 444  :     /*------------------------*/
; 445  : 
; 446  :     if (R1 == 9)

  00200	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  00205	0f 85 05 01 00
	00		 jne	 $LN19@z900_hdiag

; 447  :     {
; 448  : #ifdef DYN76_DEBUG
; 449  :         logmsg("DF18: CFILE - setmode file operation\n");
; 450  : #endif
; 451  :         get_reg(R3, 3);   /* Fetch parameter two - new file mode */

  0020b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00213	48 83 c0 0c	 add	 rax, 12
  00217	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0021f	ba fe ff ff ff	 mov	 edx, -2
  00224	48 8b c8	 mov	 rcx, rax
  00227	e8 00 00 00 00	 call	 z900_vfetch4
  0022c	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 452  :         if (R3 & 0x04)

  00230	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00234	83 e0 04	 and	 eax, 4
  00237	85 c0		 test	 eax, eax
  00239	74 0a		 je	 SHORT $LN21@z900_hdiag

; 453  :             i = _O_TEXT;

  0023b	c7 44 24 34 00
	40 00 00	 mov	 DWORD PTR i$[rsp], 16384 ; 00004000H
  00243	eb 08		 jmp	 SHORT $LN22@z900_hdiag
$LN21@z900_hdiag:

; 454  :         else
; 455  :             i = _O_BINARY;

  00245	c7 44 24 34 00
	80 00 00	 mov	 DWORD PTR i$[rsp], 32768 ; 00008000H
$LN22@z900_hdiag:

; 456  : #ifdef _MSVC_
; 457  :         i = _setmode (handle, i); /* Alter the Windows mode */

  0024d	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00251	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode
  0025b	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 458  :         if (i == -1)

  0025f	83 7c 24 34 ff	 cmp	 DWORD PTR i$[rsp], -1
  00264	75 39		 jne	 SHORT $LN23@z900_hdiag

; 459  :         {
; 460  :             R15 = -errno;

  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0026c	8b 00		 mov	 eax, DWORD PTR [rax]
  0026e	f7 d8		 neg	 eax
  00270	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 461  :             set_reg(15,R15);

  00274	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0027c	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00280	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00288	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0028e	48 8b d0	 mov	 rdx, rax
  00291	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00295	e8 00 00 00 00	 call	 z900_vstore4

; 462  :             return;

  0029a	e9 d7 0f 00 00	 jmp	 $LN1@z900_hdiag
$LN23@z900_hdiag:

; 463  :         }
; 464  : #else
; 465  :         get_reg(R3, 3);
; 466  :         /* *nix doesn't need handle updates */
; 467  :         if (fk->mode)
; 468  :             i = _O_TEXT;
; 469  :         else
; 470  :             i = _O_BINARY;
; 471  : #endif
; 472  :         if (i == _O_TEXT) /* Previous mode */

  0029f	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR i$[rsp], 16384 ; 00004000H
  002a7	75 0a		 jne	 SHORT $LN24@z900_hdiag

; 473  :             R15 = 0x04;

  002a9	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR R15$[rsp], 4
  002b1	eb 08		 jmp	 SHORT $LN25@z900_hdiag
$LN24@z900_hdiag:

; 474  :         else
; 475  :             R15 = 0x08;

  002b3	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR R15$[rsp], 8
$LN25@z900_hdiag:

; 476  :         set_reg(15,R15);

  002bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  002c3	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  002c7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002cf	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  002d5	48 8b d0	 mov	 rdx, rax
  002d8	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  002dc	e8 00 00 00 00	 call	 z900_vstore4

; 477  : 
; 478  :         if (R3 & 0x04) /* Update translation details: */

  002e1	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  002e5	83 e0 04	 and	 eax, 4
  002e8	85 c0		 test	 eax, eax
  002ea	74 0e		 je	 SHORT $LN26@z900_hdiag

; 479  :             fk->mode = 1;    /* yes, translate */

  002ec	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002f1	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
  002f8	eb 0c		 jmp	 SHORT $LN27@z900_hdiag
$LN26@z900_hdiag:

; 480  :         else
; 481  :             fk->mode = 0;    /* no, dont */

  002fa	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002ff	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN27@z900_hdiag:

; 482  :         return;

  00306	e9 6b 0f 00 00	 jmp	 $LN1@z900_hdiag

; 483  :     } else

  0030b	e9 d0 01 00 00	 jmp	 $LN20@z900_hdiag
$LN19@z900_hdiag:

; 484  : 
; 485  :     /*------------------------*/
; 486  :     /* CLOSE File Operation   */
; 487  :     /*------------------------*/
; 488  : 
; 489  :     if (R1 == 8)

  00310	83 7c 24 4c 08	 cmp	 DWORD PTR R1$[rsp], 8
  00315	0f 85 9d 00 00
	00		 jne	 $LN28@z900_hdiag

; 490  :     {
; 491  : #ifdef DYN76_DEBUG
; 492  :         logmsg("DF18: CFILE - _close(%d)\n", handle);
; 493  : #endif
; 494  :         res = _close (handle);

  0031b	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  00325	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 495  : #ifdef DYN76_DEBUG
; 496  :         logmsg("DF18: CFILE - _close result: %d\n", res);
; 497  : #endif
; 498  :         R15 = res;

  00329	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0032d	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 499  :         set_reg(15,R15);

  00331	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00339	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  0033d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00345	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0034b	48 8b d0	 mov	 rdx, rax
  0034e	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00352	e8 00 00 00 00	 call	 z900_vstore4

; 500  :         if (R15 == 0)

  00357	83 7c 24 30 00	 cmp	 DWORD PTR R15$[rsp], 0
  0035c	75 1c		 jne	 SHORT $LN30@z900_hdiag

; 501  :         {   RemoveFKByID (fk->id, &fkpr_head, DO_FREE);

  0035e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  0036b	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  00370	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00373	e8 00 00 00 00	 call	 RemoveFKByID

; 502  :         }

  00378	eb 34		 jmp	 SHORT $LN31@z900_hdiag
$LN30@z900_hdiag:

; 503  :         else
; 504  :         {   R15 = -errno;

  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00380	8b 00		 mov	 eax, DWORD PTR [rax]
  00382	f7 d8		 neg	 eax
  00384	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 505  :             set_reg(15,R15);

  00388	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00390	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00394	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0039c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  003a2	48 8b d0	 mov	 rdx, rax
  003a5	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  003a9	e8 00 00 00 00	 call	 z900_vstore4
$LN31@z900_hdiag:

; 506  :         }
; 507  :         return;

  003ae	e9 c3 0e 00 00	 jmp	 $LN1@z900_hdiag

; 508  :     } else

  003b3	e9 28 01 00 00	 jmp	 $LN29@z900_hdiag
$LN28@z900_hdiag:

; 509  : 
; 510  :     /*------------------------*/
; 511  :     /* COMMIT File Operation  */
; 512  :     /*------------------------*/
; 513  : 
; 514  :     if (R1 == 7)

  003b8	83 7c 24 4c 07	 cmp	 DWORD PTR R1$[rsp], 7
  003bd	75 64		 jne	 SHORT $LN32@z900_hdiag

; 515  :     {
; 516  : #ifdef DYN76_DEBUG
; 517  :         logmsg("DF18: CFILE - commit file operation\n");
; 518  : #endif
; 519  : 
; 520  : #ifdef _MSVC_
; 521  : #ifdef DYN76_DEBUG
; 522  :         logmsg("DF18: CFILE - _commit(%d)\n", handle);
; 523  : #endif
; 524  :         res =  _commit (handle);

  003bf	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  003c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  003c9	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 525  : #ifdef DYN76_DEBUG
; 526  :         logmsg("DF18: CFILE - _commit result: %d\n", res);
; 527  : #endif
; 528  : #else /* ifdef __MSVC__ */
; 529  : 
; 530  : #ifdef DYN76_DEBUG
; 531  :         logmsg("DF18: CFILE - fsync(%d)\n", handle);
; 532  : #endif
; 533  :         res = fsync (handle);
; 534  : #ifdef DYN76_DEBUG
; 535  :         logmsg("DF18: CFILE - fsync result: %d \n", res);
; 536  : #endif
; 537  : #endif /* ifdef __MSVC__ */
; 538  :         if (res != 0)

  003cd	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  003d2	74 17		 je	 SHORT $LN34@z900_hdiag

; 539  :         {
; 540  :             res = errno;

  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003da	8b 00		 mov	 eax, DWORD PTR [rax]
  003dc	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 541  : #ifdef DYN76_DEBUG
; 542  :         logmsg("DF18: CFILE - fsync/_commit errno: %d \n", res);
; 543  : #endif
; 544  :             R15 = -1 * res;

  003e0	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  003e5	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 545  :         }

  003e9	eb 08		 jmp	 SHORT $LN35@z900_hdiag
$LN34@z900_hdiag:

; 546  :         else
; 547  :         {
; 548  :             R15 = res;

  003eb	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  003ef	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN35@z900_hdiag:

; 549  :         }
; 550  :         set_reg(15,R15);

  003f3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  003fb	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  003ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00407	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0040d	48 8b d0	 mov	 rdx, rax
  00410	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00414	e8 00 00 00 00	 call	 z900_vstore4

; 551  :         return;

  00419	e9 58 0e 00 00	 jmp	 $LN1@z900_hdiag

; 552  :     } else

  0041e	e9 bd 00 00 00	 jmp	 $LN33@z900_hdiag
$LN32@z900_hdiag:

; 553  : 
; 554  :     /*------------------------*/
; 555  :     /* SEEK File Operation    */
; 556  :     /*------------------------*/
; 557  : 
; 558  :     if (R1 == 6)

  00423	83 7c 24 4c 06	 cmp	 DWORD PTR R1$[rsp], 6
  00428	0f 85 b2 00 00
	00		 jne	 $LN36@z900_hdiag

; 559  :     {
; 560  : #ifdef DYN76_DEBUG
; 561  :         logmsg("DF18: CFILE - seek\n");
; 562  : #endif
; 563  :         get_reg(R3,3);  /* offset in bytes */

  0042e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00436	48 83 c0 0c	 add	 rax, 12
  0043a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00442	ba fe ff ff ff	 mov	 edx, -2
  00447	48 8b c8	 mov	 rcx, rax
  0044a	e8 00 00 00 00	 call	 z900_vfetch4
  0044f	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 564  :         get_reg(R4,4);  /* origin of the seek */

  00453	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0045b	48 83 c0 10	 add	 rax, 16
  0045f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00467	ba fe ff ff ff	 mov	 edx, -2
  0046c	48 8b c8	 mov	 rcx, rax
  0046f	e8 00 00 00 00	 call	 z900_vfetch4
  00474	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 565  : #ifdef DYN76_DEBUG
; 566  :         logmsg("DF18: CFILE - _lseek(%d, %d, %d)\n", handle, (long)R3, (int)R4);
; 567  : #endif
; 568  :         res = _lseek (handle, (long)R3, (int)R4);

  00478	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  0047d	8b 54 24 58	 mov	 edx, DWORD PTR R3$[rsp]
  00481	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseek
  0048b	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 569  : #ifdef DYN76_DEBUG
; 570  :         logmsg("DF18: CFILE - _lseek result: %d\n", res);
; 571  : #endif
; 572  :         if (res == -1)

  0048f	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00494	75 17		 jne	 SHORT $LN37@z900_hdiag

; 573  :         {
; 574  :             res = errno;

  00496	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0049c	8b 00		 mov	 eax, DWORD PTR [rax]
  0049e	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 575  : #ifdef DYN76_DEBUG
; 576  :             logmsg("DF18: CFILE - _lseek errno: %d\n", res);
; 577  : #endif
; 578  :             R15 = -1 * res;

  004a2	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  004a7	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 579  :         }

  004ab	eb 08		 jmp	 SHORT $LN38@z900_hdiag
$LN37@z900_hdiag:

; 580  :         else
; 581  :         {
; 582  :             R15 = res;

  004ad	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  004b1	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN38@z900_hdiag:

; 583  :         }
; 584  :         set_reg(15,R15);

  004b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  004bd	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  004c1	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004c9	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  004cf	48 8b d0	 mov	 rdx, rax
  004d2	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  004d6	e8 00 00 00 00	 call	 z900_vstore4

; 585  :         return;

  004db	e9 96 0d 00 00	 jmp	 $LN1@z900_hdiag
$LN36@z900_hdiag:
$LN33@z900_hdiag:
$LN29@z900_hdiag:
$LN20@z900_hdiag:

; 586  :     }
; 587  : 
; 588  :     /*-------------------------------------------------------------*/
; 589  :     /* Interruptible operation initilization                       */
; 590  :     /*-------------------------------------------------------------*/
; 591  : 
; 592  :     if ( (options & SPACE_MASK) == DF18_REAL_SPACE)

  004e0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR options$[rsp]
  004e7	83 e0 70	 and	 eax, 112		; 00000070H
  004ea	83 f8 40	 cmp	 eax, 64			; 00000040H
  004ed	75 0a		 jne	 SHORT $LN39@z900_hdiag

; 593  :         space_ctl = USE_REAL_ADDR;

  004ef	c7 44 24 60 fe
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -2
  004f7	eb 08		 jmp	 SHORT $LN40@z900_hdiag
$LN39@z900_hdiag:

; 594  :     else
; 595  :         space_ctl = USE_PRIMARY_SPACE;

  004f9	c7 44 24 60 fd
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -3
$LN40@z900_hdiag:

; 596  : 
; 597  :     get_reg(R0,0);        /* Retrieve Restart Stage */

  00501	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00509	ba fe ff ff ff	 mov	 edx, -2
  0050e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cmpb$[rsp]
  00516	e8 00 00 00 00	 call	 z900_vfetch4
  0051b	89 44 24 54	 mov	 DWORD PTR R0$[rsp], eax

; 598  : 
; 599  :     if (R0 == 0)

  0051f	83 7c 24 54 00	 cmp	 DWORD PTR R0$[rsp], 0
  00524	0f 85 64 01 00
	00		 jne	 $LN41@z900_hdiag

; 600  :     {   /* New operation, not a restart.  Establish new operational state */
; 601  :         rfk = malloc (sizeof (struct fkeeper));

  0052a	b9 28 02 00 00	 mov	 ecx, 552		; 00000228H
  0052f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00535	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 602  :         if (rfk == NULL)

  0053a	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  00540	75 33		 jne	 SHORT $LN43@z900_hdiag

; 603  :         {
; 604  :             R15 = -1 * ENOMEM; /* Error */

  00542	c7 44 24 30 f4
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -12 ; fffffff4H

; 605  :             set_reg(15,R15);

  0054a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00552	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00556	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0055e	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00564	48 8b d0	 mov	 rdx, rax
  00567	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  0056b	e8 00 00 00 00	 call	 z900_vstore4

; 606  :             return;

  00570	e9 01 0d 00 00	 jmp	 $LN1@z900_hdiag
$LN43@z900_hdiag:

; 607  :         }
; 608  :         rfk->mode = -1;      /* mode is not initially set */

  00575	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0057a	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [rax+20], -1

; 609  :         rfk->data = 0;       /* Nothing in the buffer yet */

  00581	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00586	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 610  :         rfk->handle = 0;     /* No file handle yet either (could be an open) */

  0058d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00592	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 611  :         get_reg(R5,5);       /* Save pseudo R5 */

  00599	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  005a1	48 83 c0 14	 add	 rax, 20
  005a5	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005ad	ba fe ff ff ff	 mov	 edx, -2
  005b2	48 8b c8	 mov	 rcx, rax
  005b5	e8 00 00 00 00	 call	 z900_vfetch4
  005ba	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 612  :         rfk->SaveArea = R5;

  005be	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  005c3	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005c7	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 613  : 
; 614  :         /* Set this state's id for the guest and increment
; 615  :            and link the structure to the list even if not yet open.
; 616  :            This is required to allow open to be restarted based upon the
; 617  :            id.  If the file does not successfully open, then the linked entry
; 618  :            must be removed in stage 3
; 619  :         */
; 620  :         dolock (nfile_lock);    /* Take ownership of the list */

  005ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 621  : 
; 622  :         R5 = restart_id++;        /* safely increment the id counter */

  005d7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005dd	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax
  005e1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005e7	ff c0		 inc	 eax
  005e9	89 05 00 00 00
	00		 mov	 DWORD PTR restart_id, eax

; 623  : #ifdef DYN76_DEBUG_FKEEPER
; 624  :         logmsg("DF18: CFILE - adding restart fkeeper to rst_head list\n");
; 625  : #endif
; 626  :         AddFKByID(R5, rfk, &rst_head);

  005ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:rst_head
  005f6	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  005fb	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005ff	e8 00 00 00 00	 call	 AddFKByID

; 627  : 
; 628  :         unlock (nfile_lock);    /* Release ownership of the list */

  00604	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  0060b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 629  :         set_reg(5,R5);          /* Set the restart state for this new operation */

  00611	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00619	48 83 c0 14	 add	 rax, 20
  0061d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00625	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0062b	48 8b d0	 mov	 rdx, rax
  0062e	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00632	e8 00 00 00 00	 call	 z900_vstore4

; 630  : 
; 631  :         /* For read/write we need this cleared here */
; 632  :         R15 = 0;

  00637	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR R15$[rsp], 0

; 633  :         set_reg(15,R15);

  0063f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00647	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  0064b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00653	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00659	48 8b d0	 mov	 rdx, rax
  0065c	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00660	e8 00 00 00 00	 call	 z900_vstore4

; 634  : 
; 635  :         /* Set the restart stage in case the next stage is interrupted */
; 636  :         R0 = 1;                /* Set work stage 1 on restart */

  00665	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR R0$[rsp], 1

; 637  :         set_reg(0,R0);

  0066d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00675	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0067b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  00683	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  00687	e8 00 00 00 00	 call	 z900_vstore4

; 638  :     } else

  0068c	eb 7b		 jmp	 SHORT $LN42@z900_hdiag
$LN41@z900_hdiag:

; 639  : 
; 640  :     /*-------------------------------------------------------------*/
; 641  :     /* Interruptible operation restart                             */
; 642  :     /*-------------------------------------------------------------*/
; 643  : 
; 644  :     {   /* Must have restarted, refresh fk */
; 645  :         get_reg(R5,5);    /* R5 contains the previous restart id */

  0068e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00696	48 83 c0 14	 add	 rax, 20
  0069a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  006a2	ba fe ff ff ff	 mov	 edx, -2
  006a7	48 8b c8	 mov	 rcx, rax
  006aa	e8 00 00 00 00	 call	 z900_vfetch4
  006af	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 646  :         rfk = FindFK(R5, &rst_head);

  006b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  006ba	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  006be	e8 00 00 00 00	 call	 FindFK
  006c3	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 647  :         if (!rfk)

  006c8	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  006ce	75 39		 jne	 SHORT $LN44@z900_hdiag

; 648  :         {   /* Did not find the restart - generate an exception */
; 649  :             R0 = 0;

  006d0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 650  :             set_reg(0,R0); /* restart failed, so don't do it again */

  006d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006e0	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  006e6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  006ee	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  006f2	e8 00 00 00 00	 call	 z900_vstore4

; 651  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  006f7	ba 13 00 00 00	 mov	 edx, 19
  006fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00704	e8 00 00 00 00	 call	 z900_program_interrupt
$LN44@z900_hdiag:
$LN42@z900_hdiag:

; 652  :         }
; 653  :     }
; 654  : 
; 655  :     /*-------------------------------------------------------------*/
; 656  :     /* Work Stage 1 Initial or Restart                             */
; 657  :     /*-------------------------------------------------------------*/
; 658  : 
; 659  :     if (R0 == 1)

  00709	83 7c 24 54 01	 cmp	 DWORD PTR R0$[rsp], 1
  0070e	0f 85 2b 01 00
	00		 jne	 $LN45@z900_hdiag

; 660  :     {
; 661  :         if (R1 == 0)

  00714	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  00719	0f 85 f9 00 00
	00		 jne	 $LN46@z900_hdiag
$LN2@z900_hdiag:

; 662  :         { /* rename - need to get 2 filenames */
; 663  :             while ((rfk->data == 0) ||                    /* Started? */

  0071f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00724	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00728	74 1e		 je	 SHORT $LN47@z900_hdiag
  0072a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0072f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00732	ff c8		 dec	 eax
  00734	48 98		 cdqe
  00736	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0073b	0f be 44 01 1c	 movsx	 eax, BYTE PTR [rcx+rax+28]
  00740	85 c0		 test	 eax, eax
  00742	0f 84 ac 00 00
	00		 je	 $LN3@z900_hdiag
$LN47@z900_hdiag:

; 664  :                    (rfk->oldname [rfk->data - 1] != 0))
; 665  :             {   /* Not Finished */
; 666  : 
; 667  :                 /* WARNING: This is where interruption might occur */
; 668  :                 ARCH_DEP(wfetchc)

  00748	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  0074c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00754	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0075b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00760	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  00764	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00769	48 8d 4c 0a 1c	 lea	 rcx, QWORD PTR [rdx+rcx+28]
  0076e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00776	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0077b	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00780	4c 8b c0	 mov	 r8, rax
  00783	33 d2		 xor	 edx, edx
  00785	e8 00 00 00 00	 call	 z900_vfetchc

; 669  :                     (&(rfk->oldname [rfk->data]),
; 670  :                      0,
; 671  :                      R2,
; 672  :                      space_ctl,
; 673  :                      regs);
; 674  : 
; 675  :                 /* Exception, can recalculate if/when restart */
; 676  :                 R2 += 1;

  0078a	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  0078e	ff c0		 inc	 eax
  00790	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 677  :                 set_reg(2,R2);

  00794	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0079c	48 83 c0 08	 add	 rax, 8
  007a0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  007a8	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  007ae	48 8b d0	 mov	 rdx, rax
  007b1	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  007b5	e8 00 00 00 00	 call	 z900_vstore4

; 678  :                 rfk->data += 1;  /* Next host byte location */

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007bf	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  007c2	ff c0		 inc	 eax
  007c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  007c9	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 679  :                 if (rfk->data >= 259)

  007cc	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007d1	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  007d8	7c 15		 jl	 SHORT $LN48@z900_hdiag

; 680  :                 {
; 681  :                     rfk->oldname [fk->data] = 0;

  007da	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  007df	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  007e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  007e8	c6 44 01 1c 00	 mov	 BYTE PTR [rcx+rax+28], 0

; 682  :                     break;

  007ed	eb 05		 jmp	 SHORT $LN3@z900_hdiag
$LN48@z900_hdiag:

; 683  :                 }
; 684  :             }

  007ef	e9 2b ff ff ff	 jmp	 $LN2@z900_hdiag
$LN3@z900_hdiag:

; 685  :             StrConverter (rfk->oldname, DCCebcdic_to_ascii);

  007f4	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007f9	48 83 c0 1c	 add	 rax, 28
  007fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  00804	48 8b c8	 mov	 rcx, rax
  00807	e8 00 00 00 00	 call	 StrConverter

; 686  :             rfk->data = 0; /* Get ready for newname */

  0080c	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00811	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
$LN46@z900_hdiag:

; 687  :         }
; 688  :         R0 = 2;               /* Set work stage 2 */

  00818	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR R0$[rsp], 2

; 689  :         set_reg(0,R0);

  00820	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00828	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0082e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  00836	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  0083a	e8 00 00 00 00	 call	 z900_vstore4
$LN45@z900_hdiag:

; 690  :     }
; 691  : 
; 692  :     /*-------------------------------------------------------------*/
; 693  :     /* Work Stage 2 Initial or Restart                             */
; 694  :     /*-------------------------------------------------------------*/
; 695  : 
; 696  :     if (R0 == 2)

  0083f	83 7c 24 54 02	 cmp	 DWORD PTR R0$[rsp], 2
  00844	0f 85 2a 01 00
	00		 jne	 $LN49@z900_hdiag

; 697  :     {
; 698  :         if (R1 <= 3)

  0084a	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  0084f	0f 87 f8 00 00
	00		 ja	 $LN50@z900_hdiag
$LN4@z900_hdiag:

; 699  :         {   /* unlink/open/close - need to get 1 filename */
; 700  :             /* rename - needs to get 2nd filename */
; 701  :             while ((rfk->data == 0)                        /* Starting */
; 702  :                    || (rfk->filename [rfk->data - 1] != 0)) /* Not Finished */

  00855	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0085a	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0085e	74 21		 je	 SHORT $LN51@z900_hdiag
  00860	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00865	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00868	ff c8		 dec	 eax
  0086a	48 98		 cdqe
  0086c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00871	0f be 84 01 20
	01 00 00	 movsx	 eax, BYTE PTR [rcx+rax+288]
  00879	85 c0		 test	 eax, eax
  0087b	0f 84 b2 00 00
	00		 je	 $LN5@z900_hdiag
$LN51@z900_hdiag:

; 703  :             {
; 704  :                 /* WARNING: This is where interruption might occur */
; 705  :                 ARCH_DEP(wfetchc)

  00881	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00885	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00894	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00899	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  0089d	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  008a2	48 8d 8c 0a 20
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+288]
  008aa	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008b2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  008b7	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  008bc	4c 8b c0	 mov	 r8, rax
  008bf	33 d2		 xor	 edx, edx
  008c1	e8 00 00 00 00	 call	 z900_vfetchc

; 706  :                     (&(rfk->filename [rfk->data]),
; 707  :                      0,
; 708  :                      R2,
; 709  :                      space_ctl,
; 710  :                      regs);
; 711  : 
; 712  :                 /* Exception, can recalculate if/when restart */
; 713  :                 R2 += 1;

  008c6	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  008ca	ff c0		 inc	 eax
  008cc	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 714  :                 set_reg(2,R2);

  008d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  008d8	48 83 c0 08	 add	 rax, 8
  008dc	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008e4	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  008ea	48 8b d0	 mov	 rdx, rax
  008ed	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  008f1	e8 00 00 00 00	 call	 z900_vstore4

; 715  :                 rfk->data += 1;  /* Next host byte location */

  008f6	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008fb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008fe	ff c0		 inc	 eax
  00900	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00905	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 716  :                 if (rfk->data >= 259)

  00908	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0090d	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  00914	7c 18		 jl	 SHORT $LN52@z900_hdiag

; 717  :                 {
; 718  :                     rfk->filename [rfk->data] = 0;

  00916	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0091b	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  0091f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00924	c6 84 01 20 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+288], 0

; 719  :                     break;

  0092c	eb 05		 jmp	 SHORT $LN5@z900_hdiag
$LN52@z900_hdiag:

; 720  :                 }
; 721  :             }

  0092e	e9 22 ff ff ff	 jmp	 $LN4@z900_hdiag
$LN5@z900_hdiag:

; 722  :             StrConverter (rfk->filename, DCCebcdic_to_ascii);

  00933	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00938	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  0093e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  00945	48 8b c8	 mov	 rcx, rax
  00948	e8 00 00 00 00	 call	 StrConverter
$LN50@z900_hdiag:

; 723  :         }
; 724  :         R0 = 3;               /* Set work stage */

  0094d	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR R0$[rsp], 3

; 725  :         set_reg(0,R0);

  00955	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0095d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00963	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  0096b	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  0096f	e8 00 00 00 00	 call	 z900_vstore4
$LN49@z900_hdiag:

; 726  :     }
; 727  : 
; 728  :     /*---------------------------------------------------------------------*/
; 729  :     /* Work Stage 3 Initial or Restart - Interruptible Operation & Results */
; 730  :     /*---------------------------------------------------------------------*/
; 731  : 
; 732  :     /*------------------------*/
; 733  :     /* RENAME File Operation  */
; 734  :     /*------------------------*/
; 735  : 
; 736  :     if (R1 == 0)

  00974	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  00979	0f 85 a4 00 00
	00		 jne	 $LN53@z900_hdiag

; 737  :     {
; 738  : #ifdef DYN76_DEBUG
; 739  :         logmsg("DF18: CFILE - rename\n");
; 740  : #endif
; 741  :         /* This is safe to restore early here */
; 742  :         R5 = rfk->SaveArea;

  0097f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00984	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00987	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 743  :         set_reg(5,R5);

  0098b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00993	48 83 c0 14	 add	 rax, 20
  00997	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0099f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  009a5	48 8b d0	 mov	 rdx, rax
  009a8	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  009ac	e8 00 00 00 00	 call	 z900_vstore4

; 744  : #ifdef DYN76_DEBUG
; 745  :         logmsg("DF18: CFILE - rename(from='%s',to='%s')\n",
; 746  :                 rfk->oldname, rfk->filename);
; 747  : #endif
; 748  :         res = rename (rfk->oldname, rfk->filename);

  009b1	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  009b6	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  009bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  009c1	48 83 c1 1c	 add	 rcx, 28
  009c5	48 8b d0	 mov	 rdx, rax
  009c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rename
  009ce	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 749  : #ifdef DYN76_DEBUG
; 750  :         logmsg("DF18: CFILE - rename result: %d\n", res);
; 751  : #endif
; 752  :         if (res != 0)

  009d2	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  009d7	74 17		 je	 SHORT $LN55@z900_hdiag

; 753  :         {
; 754  :             res = errno;

  009d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009df	8b 00		 mov	 eax, DWORD PTR [rax]
  009e1	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 755  : #ifdef DYN76_DEBUG
; 756  :         logmsg("DF18: CFILE - rename errno: %d\n", res);
; 757  : #endif
; 758  :             R15 = -1 * res;

  009e5	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  009ea	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 759  :         }

  009ee	eb 08		 jmp	 SHORT $LN56@z900_hdiag
$LN55@z900_hdiag:

; 760  :         else
; 761  :         {
; 762  :             R15 = res;

  009f0	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  009f4	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN56@z900_hdiag:

; 763  :         }
; 764  :         set_reg(15,R15);

  009f8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00a00	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00a04	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a0c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a12	48 8b d0	 mov	 rdx, rax
  00a15	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00a19	e8 00 00 00 00	 call	 z900_vstore4

; 765  :     } else

  00a1e	e9 0a 08 00 00	 jmp	 $LN54@z900_hdiag
$LN53@z900_hdiag:

; 766  : 
; 767  :     /*------------------------*/
; 768  :     /* UNLINK File Operation  */
; 769  :     /*------------------------*/
; 770  : 
; 771  :     if (R1 == 1)

  00a23	83 7c 24 4c 01	 cmp	 DWORD PTR R1$[rsp], 1
  00a28	0f 85 9b 00 00
	00		 jne	 $LN57@z900_hdiag

; 772  :     {
; 773  : #ifdef DYN76_DEBUG
; 774  :         logmsg("DF18: CFILE - unlink\n");
; 775  : #endif
; 776  :         /* This is safe to restore early here */
; 777  :         R5 = rfk->SaveArea;

  00a2e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00a33	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a36	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 778  :         set_reg(5,R5);

  00a3a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00a42	48 83 c0 14	 add	 rax, 20
  00a46	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a4e	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a54	48 8b d0	 mov	 rdx, rax
  00a57	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00a5b	e8 00 00 00 00	 call	 z900_vstore4

; 779  : 
; 780  : #ifdef _MSVC_
; 781  : #ifdef DYN76_DEBUG
; 782  :         logmsg("DF18: CFILE - _unkink('%s')\n", rfk->filename);
; 783  : #endif
; 784  :         res = _unlink (rfk->filename);

  00a60	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00a65	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00a6b	48 8b c8	 mov	 rcx, rax
  00a6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__unlink
  00a74	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 785  : #ifdef DYN76_DEBUG
; 786  :         logmsg("DF18: CFILE - _unlink result: %d\n", res);
; 787  : #endif
; 788  : #else
; 789  : #ifdef DYN76_DEBUG
; 790  :         logmsg("DF18: CFILE - remove('%s')\n", rfk->filename);
; 791  : #endif
; 792  :         res = remove (rfk->filename);
; 793  : #ifdef DYN76_DEBUG
; 794  :         logmsg("DF18: CFILE - remove result: %d\n", res);
; 795  : #endif
; 796  : #endif
; 797  :         if (res != 0)

  00a78	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  00a7d	74 17		 je	 SHORT $LN59@z900_hdiag

; 798  :         {
; 799  :             res = errno;

  00a7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a85	8b 00		 mov	 eax, DWORD PTR [rax]
  00a87	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 800  : #ifdef DYN76_DEBUG
; 801  :             logmsg("DF18: CFILE - remove/_unlink errno: %d\n", res);
; 802  : #endif
; 803  :             R15 = -1 * res;

  00a8b	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00a90	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 804  :         }

  00a94	eb 08		 jmp	 SHORT $LN60@z900_hdiag
$LN59@z900_hdiag:

; 805  :         else
; 806  :         {
; 807  :             R15 = res;

  00a96	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00a9a	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN60@z900_hdiag:

; 808  :         }
; 809  :         set_reg(15,R15);

  00a9e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00aa6	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00aaa	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00ab2	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00ab8	48 8b d0	 mov	 rdx, rax
  00abb	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00abf	e8 00 00 00 00	 call	 z900_vstore4

; 810  :     } else

  00ac4	e9 64 07 00 00	 jmp	 $LN58@z900_hdiag
$LN57@z900_hdiag:

; 811  : 
; 812  :     /*------------------------*/
; 813  :     /* OPEN File Operation    */
; 814  :     /*------------------------*/
; 815  : 
; 816  :     if (R1 == 2)

  00ac9	83 7c 24 4c 02	 cmp	 DWORD PTR R1$[rsp], 2
  00ace	0f 85 99 02 00
	00		 jne	 $LN61@z900_hdiag

; 817  :     {
; 818  : #ifdef DYN76_DEBUG
; 819  :         logmsg("DF18: CFILE - open\n");
; 820  : #endif
; 821  :         /* This is safe to restore early here */
; 822  :         R5 = rfk->SaveArea;

  00ad4	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00ad9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00adc	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 823  :         set_reg(5,R5);

  00ae0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00ae8	48 83 c0 14	 add	 rax, 20
  00aec	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00af4	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00afa	48 8b d0	 mov	 rdx, rax
  00afd	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00b01	e8 00 00 00 00	 call	 z900_vstore4

; 824  : 
; 825  :         /* Convert to host platform native open flags */
; 826  :         i = 0;

  00b06	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 827  :         get_reg(R3,3);

  00b0e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00b16	48 83 c0 0c	 add	 rax, 12
  00b1a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00b22	ba fe ff ff ff	 mov	 edx, -2
  00b27	48 8b c8	 mov	 rcx, rax
  00b2a	e8 00 00 00 00	 call	 z900_vfetch4
  00b2f	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 828  :         if (R3 & 0x01)

  00b33	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b37	83 e0 01	 and	 eax, 1
  00b3a	85 c0		 test	 eax, eax
  00b3c	74 0b		 je	 SHORT $LN63@z900_hdiag

; 829  :             i |= _O_WRONLY;

  00b3e	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b42	83 c8 01	 or	 eax, 1
  00b45	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN63@z900_hdiag:

; 830  :         if (R3 & 0x02)

  00b49	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b4d	83 e0 02	 and	 eax, 2
  00b50	85 c0		 test	 eax, eax
  00b52	74 0b		 je	 SHORT $LN64@z900_hdiag

; 831  :             i |= _O_RDWR;

  00b54	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b58	83 c8 02	 or	 eax, 2
  00b5b	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN64@z900_hdiag:

; 832  :         if ((R3 & 0x03) == 0)

  00b5f	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b63	83 e0 03	 and	 eax, 3
  00b66	85 c0		 test	 eax, eax
  00b68	75 08		 jne	 SHORT $LN65@z900_hdiag

; 833  :             i |= _O_RDONLY;

  00b6a	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b6e	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN65@z900_hdiag:

; 834  :         if (R3 & 0x04)

  00b72	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b76	83 e0 04	 and	 eax, 4
  00b79	85 c0		 test	 eax, eax
  00b7b	74 1a		 je	 SHORT $LN66@z900_hdiag

; 835  :         {
; 836  :             rfk->mode = 1; /* Record the desire to translate codepages */

  00b7d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b82	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 837  : #ifdef _MSVC_
; 838  :             i |= _O_TEXT; /* Windows can translate newlines to CRLF pairs */

  00b89	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b8d	0f ba e8 0e	 bts	 eax, 14
  00b91	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 839  : #endif
; 840  :         }

  00b95	eb 0c		 jmp	 SHORT $LN67@z900_hdiag
$LN66@z900_hdiag:

; 841  :         else
; 842  :         {
; 843  :             rfk->mode = 0; /* Binary mode (untranslated) */

  00b97	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b9c	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN67@z900_hdiag:

; 844  :         }
; 845  :         if (R3 & 0x10)

  00ba3	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00ba7	83 e0 10	 and	 eax, 16
  00baa	85 c0		 test	 eax, eax
  00bac	74 0b		 je	 SHORT $LN68@z900_hdiag

; 846  :             i |= _O_APPEND;

  00bae	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00bb2	83 c8 08	 or	 eax, 8
  00bb5	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN68@z900_hdiag:

; 847  :         if (R3 & 0x20)

  00bb9	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00bbd	83 e0 20	 and	 eax, 32			; 00000020H
  00bc0	85 c0		 test	 eax, eax
  00bc2	74 0c		 je	 SHORT $LN69@z900_hdiag

; 848  :             i |= _O_TRUNC;

  00bc4	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00bc8	0f ba e8 09	 bts	 eax, 9
  00bcc	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN69@z900_hdiag:

; 849  :         if (R3 & 0x40)

  00bd0	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00bd4	83 e0 40	 and	 eax, 64			; 00000040H
  00bd7	85 c0		 test	 eax, eax
  00bd9	74 66		 je	 SHORT $LN70@z900_hdiag

; 850  :         {
; 851  :             i |= _O_CREAT;

  00bdb	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00bdf	0f ba e8 08	 bts	 eax, 8
  00be3	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 852  : #ifdef _MSVC_
; 853  :             get_reg(R4,4);

  00be7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00bef	48 83 c0 10	 add	 rax, 16
  00bf3	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00bfb	ba fe ff ff ff	 mov	 edx, -2
  00c00	48 8b c8	 mov	 rcx, rax
  00c03	e8 00 00 00 00	 call	 z900_vfetch4
  00c08	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 854  :             if (R4 == 0) /* Pass 0x100 in Windows for readonly */

  00c0c	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00c11	75 2e		 jne	 SHORT $LN71@z900_hdiag

; 855  :             {
; 856  :                 /* Set a Windows default */
; 857  :                 R4 = _S_IWRITE;

  00c13	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR R4$[rsp], 128	; 00000080H

; 858  :                 set_reg(4,R4);

  00c1b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00c23	48 83 c0 10	 add	 rax, 16
  00c27	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00c2f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00c35	48 8b d0	 mov	 rdx, rax
  00c38	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00c3c	e8 00 00 00 00	 call	 z900_vstore4
$LN71@z900_hdiag:
$LN70@z900_hdiag:

; 859  :             }
; 860  : #endif
; 861  :         }
; 862  :         if (R3 & 0x80)

  00c41	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00c45	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c4a	85 c0		 test	 eax, eax
  00c4c	74 0c		 je	 SHORT $LN72@z900_hdiag

; 863  :         {
; 864  :             i |= _O_EXCL;

  00c4e	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00c52	0f ba e8 0a	 bts	 eax, 10
  00c56	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN72@z900_hdiag:

; 865  :         }
; 866  : #ifndef _MSVC_
; 867  :         get_reg(R4,4);
; 868  :         if (R4 == 0)
; 869  :         {   /* Set a *nix default */
; 870  :             R4 = 0666;  /* Note octal value */
; 871  :             set_reg(4,R4);
; 872  :         }
; 873  : #endif
; 874  : #ifdef DYN76_DEBUG
; 875  :         logmsg("DF18: CFILE - _open('%s', 0x%X, 0%o)\n", rfk->filename, i, R4);
; 876  : #endif
; 877  :         res = _open (rfk->filename, i, (mode_t)R4);

  00c5a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c5f	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00c65	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  00c6a	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00c6e	48 8b c8	 mov	 rcx, rax
  00c71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00c77	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 878  : #ifdef DYN76_DEBUG
; 879  :         logmsg("DF18: CFILE - _open result: %d\n", res);
; 880  : #endif
; 881  :         if (res != -1)

  00c7b	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00c80	0f 84 a7 00 00
	00		 je	 $LN73@z900_hdiag

; 882  :         {   /* Successful host file open */
; 883  : 
; 884  :             /* Save the handle for use in other operations */
; 885  :             rfk->handle = res;  /* Save the host handle */

  00c86	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c8b	8b 4c 24 40	 mov	 ecx, DWORD PTR res$[rsp]
  00c8f	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 886  : 
; 887  :             /* Transfer the restart fkeeper to the open file fkeeper list */
; 888  : #ifdef DYN76_DEBUG_FKEEPER
; 889  :             logmsg("DF18: CFILE - removing  w/o freeing fkeeper from restart list rst_head\n");
; 890  : #endif
; 891  :             RemoveFKByID (rfk->id, &rst_head, NO_FREE);

  00c92	45 33 c0	 xor	 r8d, r8d
  00c95	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  00c9c	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00ca1	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00ca4	e8 00 00 00 00	 call	 RemoveFKByID

; 892  :             dolock(nfile_lock);

  00ca9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00cb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 893  : #ifdef DYN76_DEBUG_FKEEPER
; 894  :             logmsg("DF18: CFILE - adding fkeeper to open file list with fkpr_head\n");
; 895  : #endif
; 896  :             AddFKByID(nfile_id++, rfk, &fkpr_head);

  00cb6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00cbc	89 44 24 74	 mov	 DWORD PTR tv488[rsp], eax
  00cc0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00cc6	ff c0		 inc	 eax
  00cc8	89 05 00 00 00
	00		 mov	 DWORD PTR nfile_id, eax
  00cce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:fkpr_head
  00cd5	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00cda	8b 4c 24 74	 mov	 ecx, DWORD PTR tv488[rsp]
  00cde	e8 00 00 00 00	 call	 AddFKByID

; 897  : #ifdef DYN76_DEBUG
; 898  :             logmsg("DF18: CFILE - opened guest file descriptor %d, host handle: %d\n",
; 899  :                     rfk->id, rfk->handle);
; 900  : #endif
; 901  :             unlock(nfile_lock);

  00ce3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 902  : 
; 903  :             R15 = rfk->id;

  00cf0	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00cf5	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00cf8	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 904  :             set_reg(15,R15);

  00cfc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00d04	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00d08	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d10	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d16	48 8b d0	 mov	 rdx, rax
  00d19	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00d1d	e8 00 00 00 00	 call	 z900_vstore4

; 905  :             rfk = NULL;

  00d22	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 906  :             /* Note: during the start of the interruptable open operation the
; 907  :                fkeeper structure was linked to the fkeeper list to allow restart
; 908  :                of the operation from the restart id.  Now that we have been
; 909  :                successful in opening the file, we will leave the restart fkeeper
; 910  :                on the list as the link to the host file from the guest.
; 911  :             */
; 912  :         }

  00d2b	eb 3b		 jmp	 SHORT $LN74@z900_hdiag
$LN73@z900_hdiag:

; 913  :         else
; 914  :         {   /* Failed host file open */
; 915  : 
; 916  :             res = errno;

  00d2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d33	8b 00		 mov	 eax, DWORD PTR [rax]
  00d35	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 917  : #ifdef DYN76_DEBUG
; 918  :             logmsg("DF18: CFILE - _open errno: %X\n", res);
; 919  : #endif
; 920  :             R15 = -1 * res;

  00d39	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00d3e	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 921  :             set_reg(15,R15);

  00d42	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00d4a	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00d4e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d56	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d5c	48 8b d0	 mov	 rdx, rax
  00d5f	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00d63	e8 00 00 00 00	 call	 z900_vstore4
$LN74@z900_hdiag:

; 922  :             /* Note: during start of the interruptable open operation the
; 923  :                fkeeper structure was linked to the fkeeper list to allow restart
; 924  :                of the operation from the restart id.  On a failure to actually open
; 925  :                the file, the structure needs to be removed from the list and that
; 926  :                will happen below just before returning to hdiagf18.c
; 927  :             */
; 928  :         }
; 929  :     } else

  00d68	e9 c0 04 00 00	 jmp	 $LN62@z900_hdiag
$LN61@z900_hdiag:

; 930  : 
; 931  :     /*-----------------------------*/
; 932  :     /* ORPHAN CLOSE File Operation */
; 933  :     /*-----------------------------*/
; 934  : 
; 935  :     if (R1 == 3)

  00d6d	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  00d72	75 74		 jne	 SHORT $LN75@z900_hdiag

; 936  :     {
; 937  : #ifdef DYN76_DEBUG
; 938  :         logmsg("DF18: CFILE - orphan close: '%s'\n", rfk->filename);
; 939  : #endif
; 940  :         /* This is safe to restore early here */
; 941  :         R5 = rfk->SaveArea;

  00d74	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00d79	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00d7c	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 942  :         set_reg(5,R5);

  00d80	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00d88	48 83 c0 14	 add	 rax, 20
  00d8c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d94	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d9a	48 8b d0	 mov	 rdx, rax
  00d9d	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00da1	e8 00 00 00 00	 call	 z900_vstore4

; 943  : 
; 944  :         R15 = RemoveFKByName (rfk->filename);

  00da6	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00dab	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00db1	48 8b c8	 mov	 rcx, rax
  00db4	e8 00 00 00 00	 call	 RemoveFKByName
  00db9	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 945  :         set_reg(15,R15);

  00dbd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00dc5	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00dc9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00dd1	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00dd7	48 8b d0	 mov	 rdx, rax
  00dda	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00dde	e8 00 00 00 00	 call	 z900_vstore4

; 946  :     } else

  00de3	e9 45 04 00 00	 jmp	 $LN76@z900_hdiag
$LN75@z900_hdiag:

; 947  : 
; 948  :     /*-----------------------------*/
; 949  :     /* READ File Operation         */
; 950  :     /*-----------------------------*/
; 951  : 
; 952  :     if (R1 == 4)

  00de8	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00ded	0f 85 37 02 00
	00		 jne	 $LN77@z900_hdiag

; 953  :     {
; 954  : #ifdef DYN76_DEBUG
; 955  :         logmsg("DF18: CFILE - read\n");
; 956  : #endif
; 957  :         get_reg(R4,4);

  00df3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00dfb	48 83 c0 10	 add	 rax, 16
  00dff	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00e07	ba fe ff ff ff	 mov	 edx, -2
  00e0c	48 8b c8	 mov	 rcx, rax
  00e0f	e8 00 00 00 00	 call	 z900_vfetch4
  00e14	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN6@z900_hdiag:

; 958  :         /* Note: R15 has been set to zero above during operation initialization */
; 959  : #ifdef DYN76_DEBUG
; 960  :         logmsg("DF18: CFILE - read requested bytes: %d\n", R4);
; 961  : #endif
; 962  :         while (R4 != 0)

  00e18	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00e1d	0f 84 d0 01 00
	00		 je	 $LN7@z900_hdiag

; 963  :         {
; 964  :             if (rfk->data == 0)

  00e23	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e28	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e2c	75 6d		 jne	 SHORT $LN79@z900_hdiag

; 965  :             { /* Need to fill our buffer with some data? */
; 966  :                 i = R4;

  00e2e	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  00e32	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 967  : 
; 968  :                 if (i > 256)

  00e36	81 7c 24 34 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  00e3e	7e 08		 jle	 SHORT $LN80@z900_hdiag

; 969  :                     i = 256;

  00e40	c7 44 24 34 00
	01 00 00	 mov	 DWORD PTR i$[rsp], 256	; 00000100H
$LN80@z900_hdiag:

; 970  : 
; 971  :                 rfk->data = _read (handle, rfk->filename, i);

  00e48	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e4d	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00e53	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  00e58	48 8b d0	 mov	 rdx, rax
  00e5b	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00e5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read
  00e65	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00e6a	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 972  : #ifdef DYN76_DEBUG
; 973  :                 logmsg("DF18: CFILE - host read result: %d\n", rfk->data);
; 974  : #endif
; 975  :                 if (fk->mode)

  00e6d	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  00e72	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00e76	74 23		 je	 SHORT $LN81@z900_hdiag

; 976  :                     MemConverter (rfk->filename, DCCascii_to_ebcdic, rfk->data);

  00e78	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e7d	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00e83	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00e88	44 8b 41 18	 mov	 r8d, DWORD PTR [rcx+24]
  00e8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCascii_to_ebcdic
  00e93	48 8b c8	 mov	 rcx, rax
  00e96	e8 00 00 00 00	 call	 MemConverter
$LN81@z900_hdiag:
$LN79@z900_hdiag:

; 977  :             }
; 978  :             if (rfk->data < 0)

  00e9b	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00ea0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00ea4	7d 34		 jge	 SHORT $LN82@z900_hdiag

; 979  :             {
; 980  :                 R15 = -errno;

  00ea6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00eac	8b 00		 mov	 eax, DWORD PTR [rax]
  00eae	f7 d8		 neg	 eax
  00eb0	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 981  :                 set_reg(15,R15);

  00eb4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00ebc	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00ec0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00ec8	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00ece	48 8b d0	 mov	 rdx, rax
  00ed1	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00ed5	e8 00 00 00 00	 call	 z900_vstore4
$LN82@z900_hdiag:

; 982  :             }
; 983  :             if (rfk->data <= 0)

  00eda	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00edf	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00ee3	7f 05		 jg	 SHORT $LN83@z900_hdiag

; 984  :             {   /* All done, we reached EOF (or an error occured) */
; 985  :                 break;

  00ee5	e9 09 01 00 00	 jmp	 $LN7@z900_hdiag
$LN83@z900_hdiag:

; 986  :             }
; 987  : 
; 988  :             /* Move the data read to the guest's storage */
; 989  :             i = rfk->data - 1;

  00eea	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00eef	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00ef2	ff c8		 dec	 eax
  00ef4	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 990  :             /* wstorec was designed to operate with storage-to-storage instructions.
; 991  :                The instruction length field is always one less than the number of
; 992  :                bytes involved in the instruction.  Hence the number of bytes to be
; 993  :                moved to storage is decremented by 1 to conform with this behavior. */
; 994  : 
; 995  :             /* WARNING: This is where an interruption might occur.  An exception
; 996  :                will "nullify" the storing operation.
; 997  :                On restart, the read above will be bypassed and the entire sequence
; 998  :                of bytes, upto 256, will be restored */
; 999  :             ARCH_DEP(wstorec)

  00ef8	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00efc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f04	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00f0b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00f10	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  00f17	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00f1f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f24	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00f29	4c 8b c0	 mov	 r8, rax
  00f2c	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  00f31	e8 00 00 00 00	 call	 z900_vstorec

; 1000 :                 (rfk->filename,  /* This member is used as a buffer */
; 1001 :                  (unsigned char)i,
; 1002 :                  R2,
; 1003 :                  space_ctl,
; 1004 :                  regs);
; 1005 :             i++;

  00f36	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f3a	ff c0		 inc	 eax
  00f3c	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1006 : 
; 1007 :             /* Exception, can recalculate if/when restart */
; 1008 :             R2 += i;

  00f40	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f44	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00f48	03 c8		 add	 ecx, eax
  00f4a	8b c1		 mov	 eax, ecx
  00f4c	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1009 :             set_reg(2,R2);

  00f50	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00f58	48 83 c0 08	 add	 rax, 8
  00f5c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f64	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f6a	48 8b d0	 mov	 rdx, rax
  00f6d	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00f71	e8 00 00 00 00	 call	 z900_vstore4

; 1010 : 
; 1011 :             /* Remember to stop when enough is read */
; 1012 :             R4 -= i;

  00f76	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f7a	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00f7e	2b c8		 sub	 ecx, eax
  00f80	8b c1		 mov	 eax, ecx
  00f82	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1013 :             set_reg(4,R4);

  00f86	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00f8e	48 83 c0 10	 add	 rax, 16
  00f92	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f9a	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00fa0	48 8b d0	 mov	 rdx, rax
  00fa3	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00fa7	e8 00 00 00 00	 call	 z900_vstore4

; 1014 : 
; 1015 :             /* Return accumulated total */
; 1016 :             R15 += i;

  00fac	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00fb0	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00fb4	03 c8		 add	 ecx, eax
  00fb6	8b c1		 mov	 eax, ecx
  00fb8	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1017 :             set_reg(15,R15);

  00fbc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  00fc4	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00fc8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00fd0	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00fd6	48 8b d0	 mov	 rdx, rax
  00fd9	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00fdd	e8 00 00 00 00	 call	 z900_vstore4

; 1018 : 
; 1019 :             rfk->data = 0;

  00fe2	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00fe7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1020 :         }

  00fee	e9 25 fe ff ff	 jmp	 $LN6@z900_hdiag
$LN7@z900_hdiag:

; 1021 :         R5 = rfk->SaveArea;

  00ff3	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00ff8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00ffb	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1022 :         set_reg(5,R5);

  00fff	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  01007	48 83 c0 14	 add	 rax, 20
  0100b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  01013	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01019	48 8b d0	 mov	 rdx, rax
  0101c	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  01020	e8 00 00 00 00	 call	 z900_vstore4

; 1023 :     } else

  01025	e9 03 02 00 00	 jmp	 $LN78@z900_hdiag
$LN77@z900_hdiag:

; 1024 : 
; 1025 :     /*-----------------------------*/
; 1026 :     /* WRITE File Operation        */
; 1027 :     /*-----------------------------*/
; 1028 : 
; 1029 :     if (R1 == 5)

  0102a	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  0102f	0f 85 f8 01 00
	00		 jne	 $LN84@z900_hdiag

; 1030 :     {
; 1031 : #ifdef DYN76_DEBUG
; 1032 :         logmsg("DF18: CFILE - write\n");
; 1033 : #endif
; 1034 :         get_reg(R4,4);

  01035	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0103d	48 83 c0 10	 add	 rax, 16
  01041	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01049	ba fe ff ff ff	 mov	 edx, -2
  0104e	48 8b c8	 mov	 rcx, rax
  01051	e8 00 00 00 00	 call	 z900_vfetch4
  01056	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN8@z900_hdiag:

; 1035 :         /* Note: R15 has been set to zero above during operation initialization */
; 1036 : 
; 1037 :         while (R4 != 0)

  0105a	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  0105f	0f 84 96 01 00
	00		 je	 $LN9@z900_hdiag

; 1038 :         {
; 1039 :             i = R4 - 1;

  01065	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  01069	ff c8		 dec	 eax
  0106b	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1040 :             /* wfetchc was designed to operate with storage-to-storage instructions.
; 1041 :                The instruction length field is always one less than the number of
; 1042 :                bytes involved in the instruction.  Hence the number of bytes to be
; 1043 :                retrieved from storage  is decremented by 1 to conform with this
; 1044 :                behavior. */
; 1045 : 
; 1046 :             /* Move guest's write data to the internal buffer */
; 1047 :             if (i > 255)

  0106f	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR i$[rsp], 255	; 000000ffH
  01077	7e 08		 jle	 SHORT $LN85@z900_hdiag

; 1048 :             {
; 1049 :                 i = 255;

  01079	c7 44 24 34 ff
	00 00 00	 mov	 DWORD PTR i$[rsp], 255	; 000000ffH
$LN85@z900_hdiag:

; 1050 :             }
; 1051 : 
; 1052 :             /* WARNING: This is where interruption might occur.  The exception
; 1053 :                "nullifies" the fetch operation.
; 1054 :                On restart, the entire sequence of up to 256 bytes will be refetched
; 1055 :                from storage */
; 1056 :             ARCH_DEP(wfetchc)

  01081	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  01085	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0108d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01094	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  01099	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  010a0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  010a8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  010ad	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  010b2	4c 8b c0	 mov	 r8, rax
  010b5	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  010ba	e8 00 00 00 00	 call	 z900_vfetchc

; 1057 :                 (rfk->filename,
; 1058 :                  (unsigned char)i,
; 1059 :                  R2,
; 1060 :                  space_ctl,
; 1061 :                  regs);
; 1062 :             i++;  /* Fix up number of bytes stored to actual count */

  010bf	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  010c3	ff c0		 inc	 eax
  010c5	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1063 : 
; 1064 :             if (fk->mode)

  010c9	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  010ce	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  010d2	74 1f		 je	 SHORT $LN86@z900_hdiag

; 1065 :                 MemConverter (rfk->filename, DCCebcdic_to_ascii, i);

  010d4	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  010d9	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  010df	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  010e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  010eb	48 8b c8	 mov	 rcx, rax
  010ee	e8 00 00 00 00	 call	 MemConverter
$LN86@z900_hdiag:

; 1066 :                 /* rfk->filename is being used as a data buffer here */
; 1067 : 
; 1068 :             /* Write to the host file from the internal buffer */
; 1069 : #ifdef DYN76_DEBUG
; 1070 :             logmsg("DF18: CFILE - _write(%d, rfk->filename, %d)\n", handle, i);
; 1071 : #endif
; 1072 :             res = _write (handle, rfk->filename, (size_t)i);

  010f3	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  010f8	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  010fe	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  01103	48 8b d0	 mov	 rdx, rax
  01106	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0110a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  01110	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 1073 : #ifdef DYN76_DEBUG
; 1074 :             logmsg("DF18: CFILE - _write result: %d\n", res);
; 1075 : #endif
; 1076 :             if (res < 0)

  01114	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  01119	7d 39		 jge	 SHORT $LN87@z900_hdiag

; 1077 :             {
; 1078 : #ifdef DYN76_DEBUG
; 1079 :                 io_error = errno;
; 1080 :                 logmsg("DF18: CFILE - write errno: %d\n", io_error);
; 1081 : #endif
; 1082 :                 R15 = -errno;

  0111b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01121	8b 00		 mov	 eax, DWORD PTR [rax]
  01123	f7 d8		 neg	 eax
  01125	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1083 :                 set_reg(15,R15);

  01129	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  01131	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  01135	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0113d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01143	48 8b d0	 mov	 rdx, rax
  01146	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  0114a	e8 00 00 00 00	 call	 z900_vstore4

; 1084 :                 break;

  0114f	e9 a7 00 00 00	 jmp	 $LN9@z900_hdiag
$LN87@z900_hdiag:

; 1085 :             }
; 1086 : 
; 1087 :             /* Not an error, so 'res' is the number of bytes actually written */
; 1088 :             /* Update the address pointer and remaining bytes to write */
; 1089 :             R2 += res;

  01154	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  01158	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  0115c	03 c8		 add	 ecx, eax
  0115e	8b c1		 mov	 eax, ecx
  01160	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1090 :             set_reg(2,R2);

  01164	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0116c	48 83 c0 08	 add	 rax, 8
  01170	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  01178	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0117e	48 8b d0	 mov	 rdx, rax
  01181	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  01185	e8 00 00 00 00	 call	 z900_vstore4

; 1091 :             R4 -= res;

  0118a	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0118e	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  01192	2b c8		 sub	 ecx, eax
  01194	8b c1		 mov	 eax, ecx
  01196	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1092 :             set_reg(4,R4);

  0119a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  011a2	48 83 c0 10	 add	 rax, 16
  011a6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  011ae	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  011b4	48 8b d0	 mov	 rdx, rax
  011b7	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  011bb	e8 00 00 00 00	 call	 z900_vstore4

; 1093 :             /* update the accumlated total */
; 1094 :             R15 += res;

  011c0	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  011c4	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  011c8	03 c8		 add	 ecx, eax
  011ca	8b c1		 mov	 eax, ecx
  011cc	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1095 :             set_reg(15,R15);

  011d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  011d8	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  011dc	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  011e4	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  011ea	48 8b d0	 mov	 rdx, rax
  011ed	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  011f1	e8 00 00 00 00	 call	 z900_vstore4

; 1096 :         }

  011f6	e9 5f fe ff ff	 jmp	 $LN8@z900_hdiag
$LN9@z900_hdiag:

; 1097 :         R5 = rfk->SaveArea;

  011fb	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  01200	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01203	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1098 :         set_reg(5,R5);

  01207	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cmpb$[rsp]
  0120f	48 83 c0 14	 add	 rax, 20
  01213	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0121b	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01221	48 8b d0	 mov	 rdx, rax
  01224	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  01228	e8 00 00 00 00	 call	 z900_vstore4
$LN84@z900_hdiag:
$LN78@z900_hdiag:
$LN76@z900_hdiag:
$LN62@z900_hdiag:
$LN58@z900_hdiag:
$LN54@z900_hdiag:

; 1099 :     }
; 1100 : 
; 1101 :     if (rfk) /* clean up, unless open already has */

  0122d	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  01233	74 1a		 je	 SHORT $LN88@z900_hdiag

; 1102 :     {
; 1103 : #ifdef DYN76_DEBUG_FKEEPER
; 1104 :         logmsg("DF18: CFILE - removing and freeing restart fkeeper in rst_head list\n");
; 1105 : #endif
; 1106 :         /* Safely remove from the restart state */
; 1107 :         RemoveFKByID (rfk->id, &rst_head, DO_FREE);

  01235	41 b8 01 00 00
	00		 mov	 r8d, 1
  0123b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  01242	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  01247	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0124a	e8 00 00 00 00	 call	 RemoveFKByID
$LN88@z900_hdiag:

; 1108 :     }
; 1109 : 
; 1110 :     /* Make sure we do not restart this operation */
; 1111 :     R0 = 0;

  0124f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 1112 :     set_reg(0,R0);

  01257	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0125f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01265	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cmpb$[rsp]
  0126d	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  01271	e8 00 00 00 00	 call	 z900_vstore4
$LN1@z900_hdiag:

; 1113 : }

  01276	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0127d	c3		 ret	 0
z900_hdiagf18_FC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
R15$ = 48
i$ = 52
rfk$ = 56
res$ = 64
R4$ = 68
R5$ = 72
R1$ = 76
R2$ = 80
R0$ = 84
R3$ = 88
handle$ = 92
space_ctl$ = 96
fk$ = 104
ghandle$ = 112
tv486 = 116
options$ = 144
cmpb$ = 152
regs$ = 160
s390_hdiagf18_FC PROC

; 345  : {

$LN90:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 346  :     int    space_ctl;           /* This is used to control address space selection */
; 347  :     int    i;
; 348  :     int    res;                 /* I/O integer results */
; 349  :     int    handle = 0;          /* Host file file handle for this file */

  00014	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR handle$[rsp], 0

; 350  :     U32    ghandle = 0;         /* Guest file descriptor */

  0001c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR ghandle$[rsp], 0

; 351  :     struct fkeeper *fk = NULL;  /* Host file structure */

  00024	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fk$[rsp], 0

; 352  :     struct fkeeper *rfk = NULL; /* Restart structure */

  0002d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 353  : #ifdef DYN76_DEBUG
; 354  :     int    io_error = 0;        /* Saves the errno for log messages */
; 355  : #endif
; 356  : 
; 357  :     /* Pseudo register contents are cached here once retrieved */
; 358  :     U32    R0;
; 359  :     U32    R1;
; 360  :     U32    R2;
; 361  :     U32    R3;
; 362  :     U32    R4;
; 363  :     U32    R5;
; 364  :     U32    R15;
; 365  : 
; 366  :     /* Initialise the LOCK on our first use */
; 367  :     if (nfile_init_req)

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nfile_init_req, 0
  0003d	74 0f		 je	 SHORT $LN10@s390_hdiag

; 368  :     {
; 369  :         nfile_init_req = 0;

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nfile_init_req, 0

; 370  :         nfile_init ();

  00049	e8 00 00 00 00	 call	 nfile_init
$LN10@s390_hdiag:

; 371  :     }
; 372  : 
; 373  : #ifdef DYN76_DEBUG
; 374  :     logmsg("DF18: CFILE Validating FOCPB Address %X\n", cmpb);
; 375  : #endif
; 376  : 
; 377  :     /* CPB must be on a doubleword and must not cross physical page boundary */
; 378  :     if ( ((cmpb & 0x7) != 0 ) ||

  0004e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00055	83 e0 07	 and	 eax, 7
  00058	85 c0		 test	 eax, eax
  0005a	75 20		 jne	 SHORT $LN12@s390_hdiag
  0005c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00063	83 c0 3f	 add	 eax, 63			; 0000003fH
  00066	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0006b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cmpb$[rsp]
  00072	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00078	3b c1		 cmp	 eax, ecx
  0007a	74 12		 je	 SHORT $LN11@s390_hdiag
$LN12@s390_hdiag:

; 379  :          (((cmpb + 63) & STORAGE_KEY_PAGEMASK) != (cmpb & STORAGE_KEY_PAGEMASK)) )
; 380  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0007c	ba 06 00 00 00	 mov	 edx, 6
  00081	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	e8 00 00 00 00	 call	 s390_program_interrupt
$LN11@s390_hdiag:

; 381  : 
; 382  : #ifdef DYN76_DEBUG
; 383  :     logmsg("DF18: CFILE Validated FOCPB Address\n");
; 384  : #endif
; 385  : 
; 386  :     get_reg(R1, 1);     /* Retrieve the function number */

  0008e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00095	83 c0 04	 add	 eax, 4
  00098	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a0	ba fe ff ff ff	 mov	 edx, -2
  000a5	8b c8		 mov	 ecx, eax
  000a7	e8 00 00 00 00	 call	 s390_vfetch4
  000ac	89 44 24 4c	 mov	 DWORD PTR R1$[rsp], eax

; 387  :     if (R1 > 9)

  000b0	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  000b5	76 38		 jbe	 SHORT $LN13@s390_hdiag

; 388  :     {   /* Invalid Function - generate an exception */
; 389  :         R0 = 0;

  000b7	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 390  :         set_reg(0,R0);  /* don't restart this */

  000bf	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  000cd	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  000d4	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  000d8	e8 00 00 00 00	 call	 s390_vstore4

; 391  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  000dd	ba 15 00 00 00	 mov	 edx, 21
  000e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 s390_program_interrupt
$LN13@s390_hdiag:

; 392  :     }
; 393  : 
; 394  :     get_reg(R2, 2);  /* All functions use parameter 1, so fetch it */

  000ef	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  000f6	83 c0 08	 add	 eax, 8
  000f9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00101	ba fe ff ff ff	 mov	 edx, -2
  00106	8b c8		 mov	 ecx, eax
  00108	e8 00 00 00 00	 call	 s390_vfetch4
  0010d	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 395  : 
; 396  :     /* read, write, seek, commit, close and setmode use the file descriptor */
; 397  :     if (R1 >= 4 && R1 <= 9)

  00111	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00116	0f 82 cc 00 00
	00		 jb	 $LN14@s390_hdiag
  0011c	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  00121	0f 87 c1 00 00
	00		 ja	 $LN14@s390_hdiag

; 398  :     {
; 399  :         if (R1 == 4 || R1 == 5)

  00127	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  0012c	74 07		 je	 SHORT $LN17@s390_hdiag
  0012e	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  00133	75 2c		 jne	 SHORT $LN15@s390_hdiag
$LN17@s390_hdiag:

; 400  :         {   /* For read and write guest file descriptor is in pseudo R3 */
; 401  :             get_reg(R3, 3);

  00135	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0013c	83 c0 0c	 add	 eax, 12
  0013f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00147	ba fe ff ff ff	 mov	 edx, -2
  0014c	8b c8		 mov	 ecx, eax
  0014e	e8 00 00 00 00	 call	 s390_vfetch4
  00153	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 402  :             ghandle = R3;

  00157	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  0015b	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax

; 403  :         }

  0015f	eb 08		 jmp	 SHORT $LN16@s390_hdiag
$LN15@s390_hdiag:

; 404  :         else
; 405  :         {   /* For seek, commit, close and setmode, file descriptor is in
; 406  :                previously fetched pseudo R2 */
; 407  :             ghandle = R2;

  00161	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00165	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax
$LN16@s390_hdiag:

; 408  :         }
; 409  : 
; 410  :         /* If read, write, seek, commit, close or setmode */
; 411  :         /* convert the file descriptor into a file handle */
; 412  : #ifdef DYN76_DEBUG_FKEEPER
; 413  :         logmsg("DF18: CFILE - looking for guest file descriptor %d\n", ghandle);
; 414  : #endif
; 415  :         fk = FindFK(ghandle, &fkpr_head);

  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  00170	8b 4c 24 70	 mov	 ecx, DWORD PTR ghandle$[rsp]
  00174	e8 00 00 00 00	 call	 FindFK
  00179	48 89 44 24 68	 mov	 QWORD PTR fk$[rsp], rax

; 416  : #ifdef DYN76_DEBUG_FKEEPER
; 417  :         logmsg("DF18: CFILE - guest file descriptor %d found at %X\n",
; 418  :                ghandle, fk);
; 419  : #endif
; 420  :         if (!fk)

  0017e	48 83 7c 24 68
	00		 cmp	 QWORD PTR fk$[rsp], 0
  00184	75 56		 jne	 SHORT $LN18@s390_hdiag

; 421  :         {   /* Did not find the guest file descriptor.
; 422  :                Treat it as if it were a bad host file handle */
; 423  : #ifdef DYN76_DEBUG
; 424  :             logmsg("DF18: CFILE - guest file descriptor not found: %d\n", ghandle);
; 425  : #endif
; 426  :             R15 = -1 * EBADF;

  00186	c7 44 24 30 f7
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -9	; fffffff7H

; 427  :             set_reg(15,R15);

  0018e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00195	83 c0 3c	 add	 eax, 60			; 0000003cH
  00198	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001a0	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001a6	8b d0		 mov	 edx, eax
  001a8	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  001ac	e8 00 00 00 00	 call	 s390_vstore4

; 428  :             R0 = 0;

  001b1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 429  :             set_reg(0,R0); /* No restart on a failure */

  001b9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001c1	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001c7	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  001ce	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  001d2	e8 00 00 00 00	 call	 s390_vstore4

; 430  :             return;

  001d7	e9 10 10 00 00	 jmp	 $LN1@s390_hdiag
$LN18@s390_hdiag:

; 431  :         }
; 432  :         handle = fk->handle;  /* All host file accesses use this variable */

  001dc	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  001e1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001e4	89 44 24 5c	 mov	 DWORD PTR handle$[rsp], eax
$LN14@s390_hdiag:

; 433  : #ifdef DYN76_DEBUG_FKEEPER
; 434  :         logmsg("DF18: CFILE - host file handle: %d\n", handle);
; 435  : #endif
; 436  :     }
; 437  : 
; 438  : /* The following 4 functions are always ready to attempt
; 439  :    and they are not interruptible: CLOSE, COMMIT, SEEK, SETMODE
; 440  : */
; 441  : 
; 442  :     /*------------------------*/
; 443  :     /* SETMODE File Operation */
; 444  :     /*------------------------*/
; 445  : 
; 446  :     if (R1 == 9)

  001e8	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  001ed	0f 85 fc 00 00
	00		 jne	 $LN19@s390_hdiag

; 447  :     {
; 448  : #ifdef DYN76_DEBUG
; 449  :         logmsg("DF18: CFILE - setmode file operation\n");
; 450  : #endif
; 451  :         get_reg(R3, 3);   /* Fetch parameter two - new file mode */

  001f3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  001fa	83 c0 0c	 add	 eax, 12
  001fd	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00205	ba fe ff ff ff	 mov	 edx, -2
  0020a	8b c8		 mov	 ecx, eax
  0020c	e8 00 00 00 00	 call	 s390_vfetch4
  00211	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 452  :         if (R3 & 0x04)

  00215	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00219	83 e0 04	 and	 eax, 4
  0021c	85 c0		 test	 eax, eax
  0021e	74 0a		 je	 SHORT $LN21@s390_hdiag

; 453  :             i = _O_TEXT;

  00220	c7 44 24 34 00
	40 00 00	 mov	 DWORD PTR i$[rsp], 16384 ; 00004000H
  00228	eb 08		 jmp	 SHORT $LN22@s390_hdiag
$LN21@s390_hdiag:

; 454  :         else
; 455  :             i = _O_BINARY;

  0022a	c7 44 24 34 00
	80 00 00	 mov	 DWORD PTR i$[rsp], 32768 ; 00008000H
$LN22@s390_hdiag:

; 456  : #ifdef _MSVC_
; 457  :         i = _setmode (handle, i); /* Alter the Windows mode */

  00232	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00236	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode
  00240	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 458  :         if (i == -1)

  00244	83 7c 24 34 ff	 cmp	 DWORD PTR i$[rsp], -1
  00249	75 36		 jne	 SHORT $LN23@s390_hdiag

; 459  :         {
; 460  :             R15 = -errno;

  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00251	8b 00		 mov	 eax, DWORD PTR [rax]
  00253	f7 d8		 neg	 eax
  00255	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 461  :             set_reg(15,R15);

  00259	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00260	83 c0 3c	 add	 eax, 60			; 0000003cH
  00263	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0026b	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00271	8b d0		 mov	 edx, eax
  00273	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00277	e8 00 00 00 00	 call	 s390_vstore4

; 462  :             return;

  0027c	e9 6b 0f 00 00	 jmp	 $LN1@s390_hdiag
$LN23@s390_hdiag:

; 463  :         }
; 464  : #else
; 465  :         get_reg(R3, 3);
; 466  :         /* *nix doesn't need handle updates */
; 467  :         if (fk->mode)
; 468  :             i = _O_TEXT;
; 469  :         else
; 470  :             i = _O_BINARY;
; 471  : #endif
; 472  :         if (i == _O_TEXT) /* Previous mode */

  00281	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR i$[rsp], 16384 ; 00004000H
  00289	75 0a		 jne	 SHORT $LN24@s390_hdiag

; 473  :             R15 = 0x04;

  0028b	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR R15$[rsp], 4
  00293	eb 08		 jmp	 SHORT $LN25@s390_hdiag
$LN24@s390_hdiag:

; 474  :         else
; 475  :             R15 = 0x08;

  00295	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR R15$[rsp], 8
$LN25@s390_hdiag:

; 476  :         set_reg(15,R15);

  0029d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  002a4	83 c0 3c	 add	 eax, 60			; 0000003cH
  002a7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002af	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  002b5	8b d0		 mov	 edx, eax
  002b7	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  002bb	e8 00 00 00 00	 call	 s390_vstore4

; 477  : 
; 478  :         if (R3 & 0x04) /* Update translation details: */

  002c0	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  002c4	83 e0 04	 and	 eax, 4
  002c7	85 c0		 test	 eax, eax
  002c9	74 0e		 je	 SHORT $LN26@s390_hdiag

; 479  :             fk->mode = 1;    /* yes, translate */

  002cb	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002d0	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
  002d7	eb 0c		 jmp	 SHORT $LN27@s390_hdiag
$LN26@s390_hdiag:

; 480  :         else
; 481  :             fk->mode = 0;    /* no, dont */

  002d9	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002de	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN27@s390_hdiag:

; 482  :         return;

  002e5	e9 02 0f 00 00	 jmp	 $LN1@s390_hdiag

; 483  :     } else

  002ea	e9 be 01 00 00	 jmp	 $LN20@s390_hdiag
$LN19@s390_hdiag:

; 484  : 
; 485  :     /*------------------------*/
; 486  :     /* CLOSE File Operation   */
; 487  :     /*------------------------*/
; 488  : 
; 489  :     if (R1 == 8)

  002ef	83 7c 24 4c 08	 cmp	 DWORD PTR R1$[rsp], 8
  002f4	0f 85 97 00 00
	00		 jne	 $LN28@s390_hdiag

; 490  :     {
; 491  : #ifdef DYN76_DEBUG
; 492  :         logmsg("DF18: CFILE - _close(%d)\n", handle);
; 493  : #endif
; 494  :         res = _close (handle);

  002fa	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  00304	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 495  : #ifdef DYN76_DEBUG
; 496  :         logmsg("DF18: CFILE - _close result: %d\n", res);
; 497  : #endif
; 498  :         R15 = res;

  00308	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0030c	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 499  :         set_reg(15,R15);

  00310	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00317	83 c0 3c	 add	 eax, 60			; 0000003cH
  0031a	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00322	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00328	8b d0		 mov	 edx, eax
  0032a	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  0032e	e8 00 00 00 00	 call	 s390_vstore4

; 500  :         if (R15 == 0)

  00333	83 7c 24 30 00	 cmp	 DWORD PTR R15$[rsp], 0
  00338	75 1c		 jne	 SHORT $LN30@s390_hdiag

; 501  :         {   RemoveFKByID (fk->id, &fkpr_head, DO_FREE);

  0033a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00340	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  00347	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  0034c	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0034f	e8 00 00 00 00	 call	 RemoveFKByID

; 502  :         }

  00354	eb 31		 jmp	 SHORT $LN31@s390_hdiag
$LN30@s390_hdiag:

; 503  :         else
; 504  :         {   R15 = -errno;

  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0035c	8b 00		 mov	 eax, DWORD PTR [rax]
  0035e	f7 d8		 neg	 eax
  00360	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 505  :             set_reg(15,R15);

  00364	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0036b	83 c0 3c	 add	 eax, 60			; 0000003cH
  0036e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00376	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0037c	8b d0		 mov	 edx, eax
  0037e	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00382	e8 00 00 00 00	 call	 s390_vstore4
$LN31@s390_hdiag:

; 506  :         }
; 507  :         return;

  00387	e9 60 0e 00 00	 jmp	 $LN1@s390_hdiag

; 508  :     } else

  0038c	e9 1c 01 00 00	 jmp	 $LN29@s390_hdiag
$LN28@s390_hdiag:

; 509  : 
; 510  :     /*------------------------*/
; 511  :     /* COMMIT File Operation  */
; 512  :     /*------------------------*/
; 513  : 
; 514  :     if (R1 == 7)

  00391	83 7c 24 4c 07	 cmp	 DWORD PTR R1$[rsp], 7
  00396	75 61		 jne	 SHORT $LN32@s390_hdiag

; 515  :     {
; 516  : #ifdef DYN76_DEBUG
; 517  :         logmsg("DF18: CFILE - commit file operation\n");
; 518  : #endif
; 519  : 
; 520  : #ifdef _MSVC_
; 521  : #ifdef DYN76_DEBUG
; 522  :         logmsg("DF18: CFILE - _commit(%d)\n", handle);
; 523  : #endif
; 524  :         res =  _commit (handle);

  00398	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  003a2	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 525  : #ifdef DYN76_DEBUG
; 526  :         logmsg("DF18: CFILE - _commit result: %d\n", res);
; 527  : #endif
; 528  : #else /* ifdef __MSVC__ */
; 529  : 
; 530  : #ifdef DYN76_DEBUG
; 531  :         logmsg("DF18: CFILE - fsync(%d)\n", handle);
; 532  : #endif
; 533  :         res = fsync (handle);
; 534  : #ifdef DYN76_DEBUG
; 535  :         logmsg("DF18: CFILE - fsync result: %d \n", res);
; 536  : #endif
; 537  : #endif /* ifdef __MSVC__ */
; 538  :         if (res != 0)

  003a6	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  003ab	74 17		 je	 SHORT $LN34@s390_hdiag

; 539  :         {
; 540  :             res = errno;

  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003b3	8b 00		 mov	 eax, DWORD PTR [rax]
  003b5	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 541  : #ifdef DYN76_DEBUG
; 542  :         logmsg("DF18: CFILE - fsync/_commit errno: %d \n", res);
; 543  : #endif
; 544  :             R15 = -1 * res;

  003b9	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  003be	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 545  :         }

  003c2	eb 08		 jmp	 SHORT $LN35@s390_hdiag
$LN34@s390_hdiag:

; 546  :         else
; 547  :         {
; 548  :             R15 = res;

  003c4	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  003c8	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN35@s390_hdiag:

; 549  :         }
; 550  :         set_reg(15,R15);

  003cc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  003d3	83 c0 3c	 add	 eax, 60			; 0000003cH
  003d6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003de	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  003e4	8b d0		 mov	 edx, eax
  003e6	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  003ea	e8 00 00 00 00	 call	 s390_vstore4

; 551  :         return;

  003ef	e9 f8 0d 00 00	 jmp	 $LN1@s390_hdiag

; 552  :     } else

  003f4	e9 b4 00 00 00	 jmp	 $LN33@s390_hdiag
$LN32@s390_hdiag:

; 553  : 
; 554  :     /*------------------------*/
; 555  :     /* SEEK File Operation    */
; 556  :     /*------------------------*/
; 557  : 
; 558  :     if (R1 == 6)

  003f9	83 7c 24 4c 06	 cmp	 DWORD PTR R1$[rsp], 6
  003fe	0f 85 a9 00 00
	00		 jne	 $LN36@s390_hdiag

; 559  :     {
; 560  : #ifdef DYN76_DEBUG
; 561  :         logmsg("DF18: CFILE - seek\n");
; 562  : #endif
; 563  :         get_reg(R3,3);  /* offset in bytes */

  00404	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0040b	83 c0 0c	 add	 eax, 12
  0040e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00416	ba fe ff ff ff	 mov	 edx, -2
  0041b	8b c8		 mov	 ecx, eax
  0041d	e8 00 00 00 00	 call	 s390_vfetch4
  00422	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 564  :         get_reg(R4,4);  /* origin of the seek */

  00426	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0042d	83 c0 10	 add	 eax, 16
  00430	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00438	ba fe ff ff ff	 mov	 edx, -2
  0043d	8b c8		 mov	 ecx, eax
  0043f	e8 00 00 00 00	 call	 s390_vfetch4
  00444	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 565  : #ifdef DYN76_DEBUG
; 566  :         logmsg("DF18: CFILE - _lseek(%d, %d, %d)\n", handle, (long)R3, (int)R4);
; 567  : #endif
; 568  :         res = _lseek (handle, (long)R3, (int)R4);

  00448	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  0044d	8b 54 24 58	 mov	 edx, DWORD PTR R3$[rsp]
  00451	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseek
  0045b	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 569  : #ifdef DYN76_DEBUG
; 570  :         logmsg("DF18: CFILE - _lseek result: %d\n", res);
; 571  : #endif
; 572  :         if (res == -1)

  0045f	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00464	75 17		 jne	 SHORT $LN37@s390_hdiag

; 573  :         {
; 574  :             res = errno;

  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0046c	8b 00		 mov	 eax, DWORD PTR [rax]
  0046e	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 575  : #ifdef DYN76_DEBUG
; 576  :             logmsg("DF18: CFILE - _lseek errno: %d\n", res);
; 577  : #endif
; 578  :             R15 = -1 * res;

  00472	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00477	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 579  :         }

  0047b	eb 08		 jmp	 SHORT $LN38@s390_hdiag
$LN37@s390_hdiag:

; 580  :         else
; 581  :         {
; 582  :             R15 = res;

  0047d	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00481	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN38@s390_hdiag:

; 583  :         }
; 584  :         set_reg(15,R15);

  00485	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0048c	83 c0 3c	 add	 eax, 60			; 0000003cH
  0048f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00497	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0049d	8b d0		 mov	 edx, eax
  0049f	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  004a3	e8 00 00 00 00	 call	 s390_vstore4

; 585  :         return;

  004a8	e9 3f 0d 00 00	 jmp	 $LN1@s390_hdiag
$LN36@s390_hdiag:
$LN33@s390_hdiag:
$LN29@s390_hdiag:
$LN20@s390_hdiag:

; 586  :     }
; 587  : 
; 588  :     /*-------------------------------------------------------------*/
; 589  :     /* Interruptible operation initilization                       */
; 590  :     /*-------------------------------------------------------------*/
; 591  : 
; 592  :     if ( (options & SPACE_MASK) == DF18_REAL_SPACE)

  004ad	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR options$[rsp]
  004b4	83 e0 70	 and	 eax, 112		; 00000070H
  004b7	83 f8 40	 cmp	 eax, 64			; 00000040H
  004ba	75 0a		 jne	 SHORT $LN39@s390_hdiag

; 593  :         space_ctl = USE_REAL_ADDR;

  004bc	c7 44 24 60 fe
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -2
  004c4	eb 08		 jmp	 SHORT $LN40@s390_hdiag
$LN39@s390_hdiag:

; 594  :     else
; 595  :         space_ctl = USE_PRIMARY_SPACE;

  004c6	c7 44 24 60 fd
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -3
$LN40@s390_hdiag:

; 596  : 
; 597  :     get_reg(R0,0);        /* Retrieve Restart Stage */

  004ce	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004d6	ba fe ff ff ff	 mov	 edx, -2
  004db	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cmpb$[rsp]
  004e2	e8 00 00 00 00	 call	 s390_vfetch4
  004e7	89 44 24 54	 mov	 DWORD PTR R0$[rsp], eax

; 598  : 
; 599  :     if (R0 == 0)

  004eb	83 7c 24 54 00	 cmp	 DWORD PTR R0$[rsp], 0
  004f0	0f 85 57 01 00
	00		 jne	 $LN41@s390_hdiag

; 600  :     {   /* New operation, not a restart.  Establish new operational state */
; 601  :         rfk = malloc (sizeof (struct fkeeper));

  004f6	b9 28 02 00 00	 mov	 ecx, 552		; 00000228H
  004fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00501	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 602  :         if (rfk == NULL)

  00506	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  0050c	75 30		 jne	 SHORT $LN43@s390_hdiag

; 603  :         {
; 604  :             R15 = -1 * ENOMEM; /* Error */

  0050e	c7 44 24 30 f4
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -12 ; fffffff4H

; 605  :             set_reg(15,R15);

  00516	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0051d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00520	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00528	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0052e	8b d0		 mov	 edx, eax
  00530	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00534	e8 00 00 00 00	 call	 s390_vstore4

; 606  :             return;

  00539	e9 ae 0c 00 00	 jmp	 $LN1@s390_hdiag
$LN43@s390_hdiag:

; 607  :         }
; 608  :         rfk->mode = -1;      /* mode is not initially set */

  0053e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00543	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [rax+20], -1

; 609  :         rfk->data = 0;       /* Nothing in the buffer yet */

  0054a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0054f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 610  :         rfk->handle = 0;     /* No file handle yet either (could be an open) */

  00556	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0055b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 611  :         get_reg(R5,5);       /* Save pseudo R5 */

  00562	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00569	83 c0 14	 add	 eax, 20
  0056c	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00574	ba fe ff ff ff	 mov	 edx, -2
  00579	8b c8		 mov	 ecx, eax
  0057b	e8 00 00 00 00	 call	 s390_vfetch4
  00580	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 612  :         rfk->SaveArea = R5;

  00584	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00589	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0058d	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 613  : 
; 614  :         /* Set this state's id for the guest and increment
; 615  :            and link the structure to the list even if not yet open.
; 616  :            This is required to allow open to be restarted based upon the
; 617  :            id.  If the file does not successfully open, then the linked entry
; 618  :            must be removed in stage 3
; 619  :         */
; 620  :         dolock (nfile_lock);    /* Take ownership of the list */

  00590	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 621  : 
; 622  :         R5 = restart_id++;        /* safely increment the id counter */

  0059d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005a3	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax
  005a7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005ad	ff c0		 inc	 eax
  005af	89 05 00 00 00
	00		 mov	 DWORD PTR restart_id, eax

; 623  : #ifdef DYN76_DEBUG_FKEEPER
; 624  :         logmsg("DF18: CFILE - adding restart fkeeper to rst_head list\n");
; 625  : #endif
; 626  :         AddFKByID(R5, rfk, &rst_head);

  005b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:rst_head
  005bc	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  005c1	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005c5	e8 00 00 00 00	 call	 AddFKByID

; 627  : 
; 628  :         unlock (nfile_lock);    /* Release ownership of the list */

  005ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 629  :         set_reg(5,R5);          /* Set the restart state for this new operation */

  005d7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  005de	83 c0 14	 add	 eax, 20
  005e1	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005e9	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  005ef	8b d0		 mov	 edx, eax
  005f1	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005f5	e8 00 00 00 00	 call	 s390_vstore4

; 630  : 
; 631  :         /* For read/write we need this cleared here */
; 632  :         R15 = 0;

  005fa	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR R15$[rsp], 0

; 633  :         set_reg(15,R15);

  00602	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00609	83 c0 3c	 add	 eax, 60			; 0000003cH
  0060c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00614	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0061a	8b d0		 mov	 edx, eax
  0061c	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00620	e8 00 00 00 00	 call	 s390_vstore4

; 634  : 
; 635  :         /* Set the restart stage in case the next stage is interrupted */
; 636  :         R0 = 1;                /* Set work stage 1 on restart */

  00625	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR R0$[rsp], 1

; 637  :         set_reg(0,R0);

  0062d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00635	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0063b	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  00642	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  00646	e8 00 00 00 00	 call	 s390_vstore4

; 638  :     } else

  0064b	eb 77		 jmp	 SHORT $LN42@s390_hdiag
$LN41@s390_hdiag:

; 639  : 
; 640  :     /*-------------------------------------------------------------*/
; 641  :     /* Interruptible operation restart                             */
; 642  :     /*-------------------------------------------------------------*/
; 643  : 
; 644  :     {   /* Must have restarted, refresh fk */
; 645  :         get_reg(R5,5);    /* R5 contains the previous restart id */

  0064d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00654	83 c0 14	 add	 eax, 20
  00657	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0065f	ba fe ff ff ff	 mov	 edx, -2
  00664	8b c8		 mov	 ecx, eax
  00666	e8 00 00 00 00	 call	 s390_vfetch4
  0066b	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 646  :         rfk = FindFK(R5, &rst_head);

  0066f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  00676	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0067a	e8 00 00 00 00	 call	 FindFK
  0067f	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 647  :         if (!rfk)

  00684	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  0068a	75 38		 jne	 SHORT $LN44@s390_hdiag

; 648  :         {   /* Did not find the restart - generate an exception */
; 649  :             R0 = 0;

  0068c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 650  :             set_reg(0,R0); /* restart failed, so don't do it again */

  00694	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0069c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  006a2	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  006a9	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  006ad	e8 00 00 00 00	 call	 s390_vstore4

; 651  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  006b2	ba 13 00 00 00	 mov	 edx, 19
  006b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bf	e8 00 00 00 00	 call	 s390_program_interrupt
$LN44@s390_hdiag:
$LN42@s390_hdiag:

; 652  :         }
; 653  :     }
; 654  : 
; 655  :     /*-------------------------------------------------------------*/
; 656  :     /* Work Stage 1 Initial or Restart                             */
; 657  :     /*-------------------------------------------------------------*/
; 658  : 
; 659  :     if (R0 == 1)

  006c4	83 7c 24 54 01	 cmp	 DWORD PTR R0$[rsp], 1
  006c9	0f 85 2a 01 00
	00		 jne	 $LN45@s390_hdiag

; 660  :     {
; 661  :         if (R1 == 0)

  006cf	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  006d4	0f 85 f9 00 00
	00		 jne	 $LN46@s390_hdiag
$LN2@s390_hdiag:

; 662  :         { /* rename - need to get 2 filenames */
; 663  :             while ((rfk->data == 0) ||                    /* Started? */

  006da	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  006df	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006e3	74 1e		 je	 SHORT $LN47@s390_hdiag
  006e5	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  006ea	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  006ed	ff c8		 dec	 eax
  006ef	48 98		 cdqe
  006f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  006f6	0f be 44 01 1c	 movsx	 eax, BYTE PTR [rcx+rax+28]
  006fb	85 c0		 test	 eax, eax
  006fd	0f 84 ac 00 00
	00		 je	 $LN3@s390_hdiag
$LN47@s390_hdiag:

; 664  :                    (rfk->oldname [rfk->data - 1] != 0))
; 665  :             {   /* Not Finished */
; 666  : 
; 667  :                 /* WARNING: This is where interruption might occur */
; 668  :                 ARCH_DEP(wfetchc)

  00703	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070b	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00711	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00715	23 c8		 and	 ecx, eax
  00717	8b c1		 mov	 eax, ecx
  00719	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0071e	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  00722	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00727	48 8d 4c 0a 1c	 lea	 rcx, QWORD PTR [rdx+rcx+28]
  0072c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00734	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00739	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  0073e	44 8b c0	 mov	 r8d, eax
  00741	33 d2		 xor	 edx, edx
  00743	e8 00 00 00 00	 call	 s390_vfetchc

; 669  :                     (&(rfk->oldname [rfk->data]),
; 670  :                      0,
; 671  :                      R2,
; 672  :                      space_ctl,
; 673  :                      regs);
; 674  : 
; 675  :                 /* Exception, can recalculate if/when restart */
; 676  :                 R2 += 1;

  00748	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  0074c	ff c0		 inc	 eax
  0074e	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 677  :                 set_reg(2,R2);

  00752	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00759	83 c0 08	 add	 eax, 8
  0075c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00764	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0076a	8b d0		 mov	 edx, eax
  0076c	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00770	e8 00 00 00 00	 call	 s390_vstore4

; 678  :                 rfk->data += 1;  /* Next host byte location */

  00775	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0077a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0077d	ff c0		 inc	 eax
  0077f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00784	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 679  :                 if (rfk->data >= 259)

  00787	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0078c	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  00793	7c 15		 jl	 SHORT $LN48@s390_hdiag

; 680  :                 {
; 681  :                     rfk->oldname [fk->data] = 0;

  00795	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  0079a	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  0079e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  007a3	c6 44 01 1c 00	 mov	 BYTE PTR [rcx+rax+28], 0

; 682  :                     break;

  007a8	eb 05		 jmp	 SHORT $LN3@s390_hdiag
$LN48@s390_hdiag:

; 683  :                 }
; 684  :             }

  007aa	e9 2b ff ff ff	 jmp	 $LN2@s390_hdiag
$LN3@s390_hdiag:

; 685  :             StrConverter (rfk->oldname, DCCebcdic_to_ascii);

  007af	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007b4	48 83 c0 1c	 add	 rax, 28
  007b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  007bf	48 8b c8	 mov	 rcx, rax
  007c2	e8 00 00 00 00	 call	 StrConverter

; 686  :             rfk->data = 0; /* Get ready for newname */

  007c7	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007cc	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
$LN46@s390_hdiag:

; 687  :         }
; 688  :         R0 = 2;               /* Set work stage 2 */

  007d3	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR R0$[rsp], 2

; 689  :         set_reg(0,R0);

  007db	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  007e3	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  007e9	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  007f0	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  007f4	e8 00 00 00 00	 call	 s390_vstore4
$LN45@s390_hdiag:

; 690  :     }
; 691  : 
; 692  :     /*-------------------------------------------------------------*/
; 693  :     /* Work Stage 2 Initial or Restart                             */
; 694  :     /*-------------------------------------------------------------*/
; 695  : 
; 696  :     if (R0 == 2)

  007f9	83 7c 24 54 02	 cmp	 DWORD PTR R0$[rsp], 2
  007fe	0f 85 29 01 00
	00		 jne	 $LN49@s390_hdiag

; 697  :     {
; 698  :         if (R1 <= 3)

  00804	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  00809	0f 87 f8 00 00
	00		 ja	 $LN50@s390_hdiag
$LN4@s390_hdiag:

; 699  :         {   /* unlink/open/close - need to get 1 filename */
; 700  :             /* rename - needs to get 2nd filename */
; 701  :             while ((rfk->data == 0)                        /* Starting */
; 702  :                    || (rfk->filename [rfk->data - 1] != 0)) /* Not Finished */

  0080f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00814	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00818	74 21		 je	 SHORT $LN51@s390_hdiag
  0081a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0081f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00822	ff c8		 dec	 eax
  00824	48 98		 cdqe
  00826	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0082b	0f be 84 01 20
	01 00 00	 movsx	 eax, BYTE PTR [rcx+rax+288]
  00833	85 c0		 test	 eax, eax
  00835	0f 84 b2 00 00
	00		 je	 $LN5@s390_hdiag
$LN51@s390_hdiag:

; 703  :             {
; 704  :                 /* WARNING: This is where interruption might occur */
; 705  :                 ARCH_DEP(wfetchc)

  0083b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00843	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00849	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  0084d	23 c8		 and	 ecx, eax
  0084f	8b c1		 mov	 eax, ecx
  00851	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00856	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  0085a	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  0085f	48 8d 8c 0a 20
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+288]
  00867	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0086f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00874	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00879	44 8b c0	 mov	 r8d, eax
  0087c	33 d2		 xor	 edx, edx
  0087e	e8 00 00 00 00	 call	 s390_vfetchc

; 706  :                     (&(rfk->filename [rfk->data]),
; 707  :                      0,
; 708  :                      R2,
; 709  :                      space_ctl,
; 710  :                      regs);
; 711  : 
; 712  :                 /* Exception, can recalculate if/when restart */
; 713  :                 R2 += 1;

  00883	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00887	ff c0		 inc	 eax
  00889	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 714  :                 set_reg(2,R2);

  0088d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00894	83 c0 08	 add	 eax, 8
  00897	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0089f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  008a5	8b d0		 mov	 edx, eax
  008a7	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  008ab	e8 00 00 00 00	 call	 s390_vstore4

; 715  :                 rfk->data += 1;  /* Next host byte location */

  008b0	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008b5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008b8	ff c0		 inc	 eax
  008ba	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  008bf	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 716  :                 if (rfk->data >= 259)

  008c2	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008c7	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  008ce	7c 18		 jl	 SHORT $LN52@s390_hdiag

; 717  :                 {
; 718  :                     rfk->filename [rfk->data] = 0;

  008d0	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008d5	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  008d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  008de	c6 84 01 20 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+288], 0

; 719  :                     break;

  008e6	eb 05		 jmp	 SHORT $LN5@s390_hdiag
$LN52@s390_hdiag:

; 720  :                 }
; 721  :             }

  008e8	e9 22 ff ff ff	 jmp	 $LN4@s390_hdiag
$LN5@s390_hdiag:

; 722  :             StrConverter (rfk->filename, DCCebcdic_to_ascii);

  008ed	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008f2	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  008f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  008ff	48 8b c8	 mov	 rcx, rax
  00902	e8 00 00 00 00	 call	 StrConverter
$LN50@s390_hdiag:

; 723  :         }
; 724  :         R0 = 3;               /* Set work stage */

  00907	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR R0$[rsp], 3

; 725  :         set_reg(0,R0);

  0090f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00917	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0091d	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  00924	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  00928	e8 00 00 00 00	 call	 s390_vstore4
$LN49@s390_hdiag:

; 726  :     }
; 727  : 
; 728  :     /*---------------------------------------------------------------------*/
; 729  :     /* Work Stage 3 Initial or Restart - Interruptible Operation & Results */
; 730  :     /*---------------------------------------------------------------------*/
; 731  : 
; 732  :     /*------------------------*/
; 733  :     /* RENAME File Operation  */
; 734  :     /*------------------------*/
; 735  : 
; 736  :     if (R1 == 0)

  0092d	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  00932	0f 85 9e 00 00
	00		 jne	 $LN53@s390_hdiag

; 737  :     {
; 738  : #ifdef DYN76_DEBUG
; 739  :         logmsg("DF18: CFILE - rename\n");
; 740  : #endif
; 741  :         /* This is safe to restore early here */
; 742  :         R5 = rfk->SaveArea;

  00938	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0093d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00940	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 743  :         set_reg(5,R5);

  00944	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0094b	83 c0 14	 add	 eax, 20
  0094e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00956	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0095c	8b d0		 mov	 edx, eax
  0095e	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00962	e8 00 00 00 00	 call	 s390_vstore4

; 744  : #ifdef DYN76_DEBUG
; 745  :         logmsg("DF18: CFILE - rename(from='%s',to='%s')\n",
; 746  :                 rfk->oldname, rfk->filename);
; 747  : #endif
; 748  :         res = rename (rfk->oldname, rfk->filename);

  00967	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0096c	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00972	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00977	48 83 c1 1c	 add	 rcx, 28
  0097b	48 8b d0	 mov	 rdx, rax
  0097e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rename
  00984	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 749  : #ifdef DYN76_DEBUG
; 750  :         logmsg("DF18: CFILE - rename result: %d\n", res);
; 751  : #endif
; 752  :         if (res != 0)

  00988	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  0098d	74 17		 je	 SHORT $LN55@s390_hdiag

; 753  :         {
; 754  :             res = errno;

  0098f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00995	8b 00		 mov	 eax, DWORD PTR [rax]
  00997	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 755  : #ifdef DYN76_DEBUG
; 756  :         logmsg("DF18: CFILE - rename errno: %d\n", res);
; 757  : #endif
; 758  :             R15 = -1 * res;

  0099b	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  009a0	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 759  :         }

  009a4	eb 08		 jmp	 SHORT $LN56@s390_hdiag
$LN55@s390_hdiag:

; 760  :         else
; 761  :         {
; 762  :             R15 = res;

  009a6	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  009aa	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN56@s390_hdiag:

; 763  :         }
; 764  :         set_reg(15,R15);

  009ae	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  009b5	83 c0 3c	 add	 eax, 60			; 0000003cH
  009b8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009c0	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  009c6	8b d0		 mov	 edx, eax
  009c8	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  009cc	e8 00 00 00 00	 call	 s390_vstore4

; 765  :     } else

  009d1	e9 ce 07 00 00	 jmp	 $LN54@s390_hdiag
$LN53@s390_hdiag:

; 766  : 
; 767  :     /*------------------------*/
; 768  :     /* UNLINK File Operation  */
; 769  :     /*------------------------*/
; 770  : 
; 771  :     if (R1 == 1)

  009d6	83 7c 24 4c 01	 cmp	 DWORD PTR R1$[rsp], 1
  009db	0f 85 95 00 00
	00		 jne	 $LN57@s390_hdiag

; 772  :     {
; 773  : #ifdef DYN76_DEBUG
; 774  :         logmsg("DF18: CFILE - unlink\n");
; 775  : #endif
; 776  :         /* This is safe to restore early here */
; 777  :         R5 = rfk->SaveArea;

  009e1	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  009e6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  009e9	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 778  :         set_reg(5,R5);

  009ed	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  009f4	83 c0 14	 add	 eax, 20
  009f7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009ff	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a05	8b d0		 mov	 edx, eax
  00a07	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00a0b	e8 00 00 00 00	 call	 s390_vstore4

; 779  : 
; 780  : #ifdef _MSVC_
; 781  : #ifdef DYN76_DEBUG
; 782  :         logmsg("DF18: CFILE - _unkink('%s')\n", rfk->filename);
; 783  : #endif
; 784  :         res = _unlink (rfk->filename);

  00a10	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00a15	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00a1b	48 8b c8	 mov	 rcx, rax
  00a1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__unlink
  00a24	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 785  : #ifdef DYN76_DEBUG
; 786  :         logmsg("DF18: CFILE - _unlink result: %d\n", res);
; 787  : #endif
; 788  : #else
; 789  : #ifdef DYN76_DEBUG
; 790  :         logmsg("DF18: CFILE - remove('%s')\n", rfk->filename);
; 791  : #endif
; 792  :         res = remove (rfk->filename);
; 793  : #ifdef DYN76_DEBUG
; 794  :         logmsg("DF18: CFILE - remove result: %d\n", res);
; 795  : #endif
; 796  : #endif
; 797  :         if (res != 0)

  00a28	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  00a2d	74 17		 je	 SHORT $LN59@s390_hdiag

; 798  :         {
; 799  :             res = errno;

  00a2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a35	8b 00		 mov	 eax, DWORD PTR [rax]
  00a37	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 800  : #ifdef DYN76_DEBUG
; 801  :             logmsg("DF18: CFILE - remove/_unlink errno: %d\n", res);
; 802  : #endif
; 803  :             R15 = -1 * res;

  00a3b	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00a40	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 804  :         }

  00a44	eb 08		 jmp	 SHORT $LN60@s390_hdiag
$LN59@s390_hdiag:

; 805  :         else
; 806  :         {
; 807  :             R15 = res;

  00a46	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00a4a	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN60@s390_hdiag:

; 808  :         }
; 809  :         set_reg(15,R15);

  00a4e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00a55	83 c0 3c	 add	 eax, 60			; 0000003cH
  00a58	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a60	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a66	8b d0		 mov	 edx, eax
  00a68	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00a6c	e8 00 00 00 00	 call	 s390_vstore4

; 810  :     } else

  00a71	e9 2e 07 00 00	 jmp	 $LN58@s390_hdiag
$LN57@s390_hdiag:

; 811  : 
; 812  :     /*------------------------*/
; 813  :     /* OPEN File Operation    */
; 814  :     /*------------------------*/
; 815  : 
; 816  :     if (R1 == 2)

  00a76	83 7c 24 4c 02	 cmp	 DWORD PTR R1$[rsp], 2
  00a7b	0f 85 87 02 00
	00		 jne	 $LN61@s390_hdiag

; 817  :     {
; 818  : #ifdef DYN76_DEBUG
; 819  :         logmsg("DF18: CFILE - open\n");
; 820  : #endif
; 821  :         /* This is safe to restore early here */
; 822  :         R5 = rfk->SaveArea;

  00a81	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00a86	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a89	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 823  :         set_reg(5,R5);

  00a8d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00a94	83 c0 14	 add	 eax, 20
  00a97	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a9f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00aa5	8b d0		 mov	 edx, eax
  00aa7	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00aab	e8 00 00 00 00	 call	 s390_vstore4

; 824  : 
; 825  :         /* Convert to host platform native open flags */
; 826  :         i = 0;

  00ab0	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 827  :         get_reg(R3,3);

  00ab8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00abf	83 c0 0c	 add	 eax, 12
  00ac2	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00aca	ba fe ff ff ff	 mov	 edx, -2
  00acf	8b c8		 mov	 ecx, eax
  00ad1	e8 00 00 00 00	 call	 s390_vfetch4
  00ad6	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 828  :         if (R3 & 0x01)

  00ada	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00ade	83 e0 01	 and	 eax, 1
  00ae1	85 c0		 test	 eax, eax
  00ae3	74 0b		 je	 SHORT $LN63@s390_hdiag

; 829  :             i |= _O_WRONLY;

  00ae5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ae9	83 c8 01	 or	 eax, 1
  00aec	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN63@s390_hdiag:

; 830  :         if (R3 & 0x02)

  00af0	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00af4	83 e0 02	 and	 eax, 2
  00af7	85 c0		 test	 eax, eax
  00af9	74 0b		 je	 SHORT $LN64@s390_hdiag

; 831  :             i |= _O_RDWR;

  00afb	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00aff	83 c8 02	 or	 eax, 2
  00b02	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN64@s390_hdiag:

; 832  :         if ((R3 & 0x03) == 0)

  00b06	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b0a	83 e0 03	 and	 eax, 3
  00b0d	85 c0		 test	 eax, eax
  00b0f	75 08		 jne	 SHORT $LN65@s390_hdiag

; 833  :             i |= _O_RDONLY;

  00b11	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b15	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN65@s390_hdiag:

; 834  :         if (R3 & 0x04)

  00b19	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b1d	83 e0 04	 and	 eax, 4
  00b20	85 c0		 test	 eax, eax
  00b22	74 1a		 je	 SHORT $LN66@s390_hdiag

; 835  :         {
; 836  :             rfk->mode = 1; /* Record the desire to translate codepages */

  00b24	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b29	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 837  : #ifdef _MSVC_
; 838  :             i |= _O_TEXT; /* Windows can translate newlines to CRLF pairs */

  00b30	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b34	0f ba e8 0e	 bts	 eax, 14
  00b38	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 839  : #endif
; 840  :         }

  00b3c	eb 0c		 jmp	 SHORT $LN67@s390_hdiag
$LN66@s390_hdiag:

; 841  :         else
; 842  :         {
; 843  :             rfk->mode = 0; /* Binary mode (untranslated) */

  00b3e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b43	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN67@s390_hdiag:

; 844  :         }
; 845  :         if (R3 & 0x10)

  00b4a	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b4e	83 e0 10	 and	 eax, 16
  00b51	85 c0		 test	 eax, eax
  00b53	74 0b		 je	 SHORT $LN68@s390_hdiag

; 846  :             i |= _O_APPEND;

  00b55	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b59	83 c8 08	 or	 eax, 8
  00b5c	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN68@s390_hdiag:

; 847  :         if (R3 & 0x20)

  00b60	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b64	83 e0 20	 and	 eax, 32			; 00000020H
  00b67	85 c0		 test	 eax, eax
  00b69	74 0c		 je	 SHORT $LN69@s390_hdiag

; 848  :             i |= _O_TRUNC;

  00b6b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b6f	0f ba e8 09	 bts	 eax, 9
  00b73	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN69@s390_hdiag:

; 849  :         if (R3 & 0x40)

  00b77	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b7b	83 e0 40	 and	 eax, 64			; 00000040H
  00b7e	85 c0		 test	 eax, eax
  00b80	74 60		 je	 SHORT $LN70@s390_hdiag

; 850  :         {
; 851  :             i |= _O_CREAT;

  00b82	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b86	0f ba e8 08	 bts	 eax, 8
  00b8a	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 852  : #ifdef _MSVC_
; 853  :             get_reg(R4,4);

  00b8e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00b95	83 c0 10	 add	 eax, 16
  00b98	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00ba0	ba fe ff ff ff	 mov	 edx, -2
  00ba5	8b c8		 mov	 ecx, eax
  00ba7	e8 00 00 00 00	 call	 s390_vfetch4
  00bac	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 854  :             if (R4 == 0) /* Pass 0x100 in Windows for readonly */

  00bb0	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00bb5	75 2b		 jne	 SHORT $LN71@s390_hdiag

; 855  :             {
; 856  :                 /* Set a Windows default */
; 857  :                 R4 = _S_IWRITE;

  00bb7	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR R4$[rsp], 128	; 00000080H

; 858  :                 set_reg(4,R4);

  00bbf	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00bc6	83 c0 10	 add	 eax, 16
  00bc9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00bd1	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00bd7	8b d0		 mov	 edx, eax
  00bd9	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00bdd	e8 00 00 00 00	 call	 s390_vstore4
$LN71@s390_hdiag:
$LN70@s390_hdiag:

; 859  :             }
; 860  : #endif
; 861  :         }
; 862  :         if (R3 & 0x80)

  00be2	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00be6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00beb	85 c0		 test	 eax, eax
  00bed	74 0c		 je	 SHORT $LN72@s390_hdiag

; 863  :         {
; 864  :             i |= _O_EXCL;

  00bef	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00bf3	0f ba e8 0a	 bts	 eax, 10
  00bf7	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN72@s390_hdiag:

; 865  :         }
; 866  : #ifndef _MSVC_
; 867  :         get_reg(R4,4);
; 868  :         if (R4 == 0)
; 869  :         {   /* Set a *nix default */
; 870  :             R4 = 0666;  /* Note octal value */
; 871  :             set_reg(4,R4);
; 872  :         }
; 873  : #endif
; 874  : #ifdef DYN76_DEBUG
; 875  :         logmsg("DF18: CFILE - _open('%s', 0x%X, 0%o)\n", rfk->filename, i, R4);
; 876  : #endif
; 877  :         res = _open (rfk->filename, i, (mode_t)R4);

  00bfb	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c00	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00c06	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  00c0b	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00c0f	48 8b c8	 mov	 rcx, rax
  00c12	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00c18	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 878  : #ifdef DYN76_DEBUG
; 879  :         logmsg("DF18: CFILE - _open result: %d\n", res);
; 880  : #endif
; 881  :         if (res != -1)

  00c1c	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00c21	0f 84 a4 00 00
	00		 je	 $LN73@s390_hdiag

; 882  :         {   /* Successful host file open */
; 883  : 
; 884  :             /* Save the handle for use in other operations */
; 885  :             rfk->handle = res;  /* Save the host handle */

  00c27	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c2c	8b 4c 24 40	 mov	 ecx, DWORD PTR res$[rsp]
  00c30	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 886  : 
; 887  :             /* Transfer the restart fkeeper to the open file fkeeper list */
; 888  : #ifdef DYN76_DEBUG_FKEEPER
; 889  :             logmsg("DF18: CFILE - removing  w/o freeing fkeeper from restart list rst_head\n");
; 890  : #endif
; 891  :             RemoveFKByID (rfk->id, &rst_head, NO_FREE);

  00c33	45 33 c0	 xor	 r8d, r8d
  00c36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  00c3d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c42	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00c45	e8 00 00 00 00	 call	 RemoveFKByID

; 892  :             dolock(nfile_lock);

  00c4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00c51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 893  : #ifdef DYN76_DEBUG_FKEEPER
; 894  :             logmsg("DF18: CFILE - adding fkeeper to open file list with fkpr_head\n");
; 895  : #endif
; 896  :             AddFKByID(nfile_id++, rfk, &fkpr_head);

  00c57	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00c5d	89 44 24 74	 mov	 DWORD PTR tv486[rsp], eax
  00c61	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00c67	ff c0		 inc	 eax
  00c69	89 05 00 00 00
	00		 mov	 DWORD PTR nfile_id, eax
  00c6f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:fkpr_head
  00c76	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00c7b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv486[rsp]
  00c7f	e8 00 00 00 00	 call	 AddFKByID

; 897  : #ifdef DYN76_DEBUG
; 898  :             logmsg("DF18: CFILE - opened guest file descriptor %d, host handle: %d\n",
; 899  :                     rfk->id, rfk->handle);
; 900  : #endif
; 901  :             unlock(nfile_lock);

  00c84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00c8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 902  : 
; 903  :             R15 = rfk->id;

  00c91	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c96	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00c99	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 904  :             set_reg(15,R15);

  00c9d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ca4	83 c0 3c	 add	 eax, 60			; 0000003cH
  00ca7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00caf	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00cb5	8b d0		 mov	 edx, eax
  00cb7	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00cbb	e8 00 00 00 00	 call	 s390_vstore4

; 905  :             rfk = NULL;

  00cc0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 906  :             /* Note: during the start of the interruptable open operation the
; 907  :                fkeeper structure was linked to the fkeeper list to allow restart
; 908  :                of the operation from the restart id.  Now that we have been
; 909  :                successful in opening the file, we will leave the restart fkeeper
; 910  :                on the list as the link to the host file from the guest.
; 911  :             */
; 912  :         }

  00cc9	eb 38		 jmp	 SHORT $LN74@s390_hdiag
$LN73@s390_hdiag:

; 913  :         else
; 914  :         {   /* Failed host file open */
; 915  : 
; 916  :             res = errno;

  00ccb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00cd1	8b 00		 mov	 eax, DWORD PTR [rax]
  00cd3	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 917  : #ifdef DYN76_DEBUG
; 918  :             logmsg("DF18: CFILE - _open errno: %X\n", res);
; 919  : #endif
; 920  :             R15 = -1 * res;

  00cd7	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00cdc	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 921  :             set_reg(15,R15);

  00ce0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ce7	83 c0 3c	 add	 eax, 60			; 0000003cH
  00cea	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00cf2	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00cf8	8b d0		 mov	 edx, eax
  00cfa	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00cfe	e8 00 00 00 00	 call	 s390_vstore4
$LN74@s390_hdiag:

; 922  :             /* Note: during start of the interruptable open operation the
; 923  :                fkeeper structure was linked to the fkeeper list to allow restart
; 924  :                of the operation from the restart id.  On a failure to actually open
; 925  :                the file, the structure needs to be removed from the list and that
; 926  :                will happen below just before returning to hdiagf18.c
; 927  :             */
; 928  :         }
; 929  :     } else

  00d03	e9 9c 04 00 00	 jmp	 $LN62@s390_hdiag
$LN61@s390_hdiag:

; 930  : 
; 931  :     /*-----------------------------*/
; 932  :     /* ORPHAN CLOSE File Operation */
; 933  :     /*-----------------------------*/
; 934  : 
; 935  :     if (R1 == 3)

  00d08	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  00d0d	75 6e		 jne	 SHORT $LN75@s390_hdiag

; 936  :     {
; 937  : #ifdef DYN76_DEBUG
; 938  :         logmsg("DF18: CFILE - orphan close: '%s'\n", rfk->filename);
; 939  : #endif
; 940  :         /* This is safe to restore early here */
; 941  :         R5 = rfk->SaveArea;

  00d0f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00d14	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00d17	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 942  :         set_reg(5,R5);

  00d1b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d22	83 c0 14	 add	 eax, 20
  00d25	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d2d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d33	8b d0		 mov	 edx, eax
  00d35	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00d39	e8 00 00 00 00	 call	 s390_vstore4

; 943  : 
; 944  :         R15 = RemoveFKByName (rfk->filename);

  00d3e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00d43	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00d49	48 8b c8	 mov	 rcx, rax
  00d4c	e8 00 00 00 00	 call	 RemoveFKByName
  00d51	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 945  :         set_reg(15,R15);

  00d55	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d5c	83 c0 3c	 add	 eax, 60			; 0000003cH
  00d5f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d67	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d6d	8b d0		 mov	 edx, eax
  00d6f	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00d73	e8 00 00 00 00	 call	 s390_vstore4

; 946  :     } else

  00d78	e9 27 04 00 00	 jmp	 $LN76@s390_hdiag
$LN75@s390_hdiag:

; 947  : 
; 948  :     /*-----------------------------*/
; 949  :     /* READ File Operation         */
; 950  :     /*-----------------------------*/
; 951  : 
; 952  :     if (R1 == 4)

  00d7d	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00d82	0f 85 28 02 00
	00		 jne	 $LN77@s390_hdiag

; 953  :     {
; 954  : #ifdef DYN76_DEBUG
; 955  :         logmsg("DF18: CFILE - read\n");
; 956  : #endif
; 957  :         get_reg(R4,4);

  00d88	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d8f	83 c0 10	 add	 eax, 16
  00d92	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00d9a	ba fe ff ff ff	 mov	 edx, -2
  00d9f	8b c8		 mov	 ecx, eax
  00da1	e8 00 00 00 00	 call	 s390_vfetch4
  00da6	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN6@s390_hdiag:

; 958  :         /* Note: R15 has been set to zero above during operation initialization */
; 959  : #ifdef DYN76_DEBUG
; 960  :         logmsg("DF18: CFILE - read requested bytes: %d\n", R4);
; 961  : #endif
; 962  :         while (R4 != 0)

  00daa	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00daf	0f 84 c7 01 00
	00		 je	 $LN7@s390_hdiag

; 963  :         {
; 964  :             if (rfk->data == 0)

  00db5	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00dba	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00dbe	75 6d		 jne	 SHORT $LN79@s390_hdiag

; 965  :             { /* Need to fill our buffer with some data? */
; 966  :                 i = R4;

  00dc0	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  00dc4	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 967  : 
; 968  :                 if (i > 256)

  00dc8	81 7c 24 34 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  00dd0	7e 08		 jle	 SHORT $LN80@s390_hdiag

; 969  :                     i = 256;

  00dd2	c7 44 24 34 00
	01 00 00	 mov	 DWORD PTR i$[rsp], 256	; 00000100H
$LN80@s390_hdiag:

; 970  : 
; 971  :                 rfk->data = _read (handle, rfk->filename, i);

  00dda	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00ddf	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00de5	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  00dea	48 8b d0	 mov	 rdx, rax
  00ded	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00df1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read
  00df7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00dfc	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 972  : #ifdef DYN76_DEBUG
; 973  :                 logmsg("DF18: CFILE - host read result: %d\n", rfk->data);
; 974  : #endif
; 975  :                 if (fk->mode)

  00dff	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  00e04	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00e08	74 23		 je	 SHORT $LN81@s390_hdiag

; 976  :                     MemConverter (rfk->filename, DCCascii_to_ebcdic, rfk->data);

  00e0a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e0f	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00e15	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00e1a	44 8b 41 18	 mov	 r8d, DWORD PTR [rcx+24]
  00e1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCascii_to_ebcdic
  00e25	48 8b c8	 mov	 rcx, rax
  00e28	e8 00 00 00 00	 call	 MemConverter
$LN81@s390_hdiag:
$LN79@s390_hdiag:

; 977  :             }
; 978  :             if (rfk->data < 0)

  00e2d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e32	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e36	7d 31		 jge	 SHORT $LN82@s390_hdiag

; 979  :             {
; 980  :                 R15 = -errno;

  00e38	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e3e	8b 00		 mov	 eax, DWORD PTR [rax]
  00e40	f7 d8		 neg	 eax
  00e42	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 981  :                 set_reg(15,R15);

  00e46	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00e4d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00e50	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00e58	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00e5e	8b d0		 mov	 edx, eax
  00e60	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00e64	e8 00 00 00 00	 call	 s390_vstore4
$LN82@s390_hdiag:

; 982  :             }
; 983  :             if (rfk->data <= 0)

  00e69	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e6e	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e72	7f 05		 jg	 SHORT $LN83@s390_hdiag

; 984  :             {   /* All done, we reached EOF (or an error occured) */
; 985  :                 break;

  00e74	e9 03 01 00 00	 jmp	 $LN7@s390_hdiag
$LN83@s390_hdiag:

; 986  :             }
; 987  : 
; 988  :             /* Move the data read to the guest's storage */
; 989  :             i = rfk->data - 1;

  00e79	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e7e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e81	ff c8		 dec	 eax
  00e83	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 990  :             /* wstorec was designed to operate with storage-to-storage instructions.
; 991  :                The instruction length field is always one less than the number of
; 992  :                bytes involved in the instruction.  Hence the number of bytes to be
; 993  :                moved to storage is decremented by 1 to conform with this behavior. */
; 994  : 
; 995  :             /* WARNING: This is where an interruption might occur.  An exception
; 996  :                will "nullify" the storing operation.
; 997  :                On restart, the read above will be bypassed and the entire sequence
; 998  :                of bytes, upto 256, will be restored */
; 999  :             ARCH_DEP(wstorec)

  00e87	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e8f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00e95	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00e99	23 c8		 and	 ecx, eax
  00e9b	8b c1		 mov	 eax, ecx
  00e9d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00ea2	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  00ea9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00eb1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00eb6	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00ebb	44 8b c0	 mov	 r8d, eax
  00ebe	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  00ec3	e8 00 00 00 00	 call	 s390_vstorec

; 1000 :                 (rfk->filename,  /* This member is used as a buffer */
; 1001 :                  (unsigned char)i,
; 1002 :                  R2,
; 1003 :                  space_ctl,
; 1004 :                  regs);
; 1005 :             i++;

  00ec8	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ecc	ff c0		 inc	 eax
  00ece	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1006 : 
; 1007 :             /* Exception, can recalculate if/when restart */
; 1008 :             R2 += i;

  00ed2	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ed6	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00eda	03 c8		 add	 ecx, eax
  00edc	8b c1		 mov	 eax, ecx
  00ede	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1009 :             set_reg(2,R2);

  00ee2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ee9	83 c0 08	 add	 eax, 8
  00eec	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00ef4	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00efa	8b d0		 mov	 edx, eax
  00efc	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00f00	e8 00 00 00 00	 call	 s390_vstore4

; 1010 : 
; 1011 :             /* Remember to stop when enough is read */
; 1012 :             R4 -= i;

  00f05	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f09	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00f0d	2b c8		 sub	 ecx, eax
  00f0f	8b c1		 mov	 eax, ecx
  00f11	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1013 :             set_reg(4,R4);

  00f15	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f1c	83 c0 10	 add	 eax, 16
  00f1f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f27	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f2d	8b d0		 mov	 edx, eax
  00f2f	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00f33	e8 00 00 00 00	 call	 s390_vstore4

; 1014 : 
; 1015 :             /* Return accumulated total */
; 1016 :             R15 += i;

  00f38	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f3c	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00f40	03 c8		 add	 ecx, eax
  00f42	8b c1		 mov	 eax, ecx
  00f44	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1017 :             set_reg(15,R15);

  00f48	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f4f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00f52	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f5a	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f60	8b d0		 mov	 edx, eax
  00f62	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00f66	e8 00 00 00 00	 call	 s390_vstore4

; 1018 : 
; 1019 :             rfk->data = 0;

  00f6b	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00f70	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1020 :         }

  00f77	e9 2e fe ff ff	 jmp	 $LN6@s390_hdiag
$LN7@s390_hdiag:

; 1021 :         R5 = rfk->SaveArea;

  00f7c	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00f81	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00f84	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1022 :         set_reg(5,R5);

  00f88	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f8f	83 c0 14	 add	 eax, 20
  00f92	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f9a	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00fa0	8b d0		 mov	 edx, eax
  00fa2	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00fa6	e8 00 00 00 00	 call	 s390_vstore4

; 1023 :     } else

  00fab	e9 f4 01 00 00	 jmp	 $LN78@s390_hdiag
$LN77@s390_hdiag:

; 1024 : 
; 1025 :     /*-----------------------------*/
; 1026 :     /* WRITE File Operation        */
; 1027 :     /*-----------------------------*/
; 1028 : 
; 1029 :     if (R1 == 5)

  00fb0	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  00fb5	0f 85 e9 01 00
	00		 jne	 $LN84@s390_hdiag

; 1030 :     {
; 1031 : #ifdef DYN76_DEBUG
; 1032 :         logmsg("DF18: CFILE - write\n");
; 1033 : #endif
; 1034 :         get_reg(R4,4);

  00fbb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00fc2	83 c0 10	 add	 eax, 16
  00fc5	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00fcd	ba fe ff ff ff	 mov	 edx, -2
  00fd2	8b c8		 mov	 ecx, eax
  00fd4	e8 00 00 00 00	 call	 s390_vfetch4
  00fd9	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN8@s390_hdiag:

; 1035 :         /* Note: R15 has been set to zero above during operation initialization */
; 1036 : 
; 1037 :         while (R4 != 0)

  00fdd	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00fe2	0f 84 8d 01 00
	00		 je	 $LN9@s390_hdiag

; 1038 :         {
; 1039 :             i = R4 - 1;

  00fe8	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  00fec	ff c8		 dec	 eax
  00fee	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1040 :             /* wfetchc was designed to operate with storage-to-storage instructions.
; 1041 :                The instruction length field is always one less than the number of
; 1042 :                bytes involved in the instruction.  Hence the number of bytes to be
; 1043 :                retrieved from storage  is decremented by 1 to conform with this
; 1044 :                behavior. */
; 1045 : 
; 1046 :             /* Move guest's write data to the internal buffer */
; 1047 :             if (i > 255)

  00ff2	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR i$[rsp], 255	; 000000ffH
  00ffa	7e 08		 jle	 SHORT $LN85@s390_hdiag

; 1048 :             {
; 1049 :                 i = 255;

  00ffc	c7 44 24 34 ff
	00 00 00	 mov	 DWORD PTR i$[rsp], 255	; 000000ffH
$LN85@s390_hdiag:

; 1050 :             }
; 1051 : 
; 1052 :             /* WARNING: This is where interruption might occur.  The exception
; 1053 :                "nullifies" the fetch operation.
; 1054 :                On restart, the entire sequence of up to 256 bytes will be refetched
; 1055 :                from storage */
; 1056 :             ARCH_DEP(wfetchc)

  01004	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0100c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  01012	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  01016	23 c8		 and	 ecx, eax
  01018	8b c1		 mov	 eax, ecx
  0101a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0101f	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  01026	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0102e	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01033	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  01038	44 8b c0	 mov	 r8d, eax
  0103b	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  01040	e8 00 00 00 00	 call	 s390_vfetchc

; 1057 :                 (rfk->filename,
; 1058 :                  (unsigned char)i,
; 1059 :                  R2,
; 1060 :                  space_ctl,
; 1061 :                  regs);
; 1062 :             i++;  /* Fix up number of bytes stored to actual count */

  01045	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  01049	ff c0		 inc	 eax
  0104b	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1063 : 
; 1064 :             if (fk->mode)

  0104f	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  01054	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  01058	74 1f		 je	 SHORT $LN86@s390_hdiag

; 1065 :                 MemConverter (rfk->filename, DCCebcdic_to_ascii, i);

  0105a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0105f	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  01065	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  0106a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  01071	48 8b c8	 mov	 rcx, rax
  01074	e8 00 00 00 00	 call	 MemConverter
$LN86@s390_hdiag:

; 1066 :                 /* rfk->filename is being used as a data buffer here */
; 1067 : 
; 1068 :             /* Write to the host file from the internal buffer */
; 1069 : #ifdef DYN76_DEBUG
; 1070 :             logmsg("DF18: CFILE - _write(%d, rfk->filename, %d)\n", handle, i);
; 1071 : #endif
; 1072 :             res = _write (handle, rfk->filename, (size_t)i);

  01079	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0107e	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  01084	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  01089	48 8b d0	 mov	 rdx, rax
  0108c	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  01090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  01096	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 1073 : #ifdef DYN76_DEBUG
; 1074 :             logmsg("DF18: CFILE - _write result: %d\n", res);
; 1075 : #endif
; 1076 :             if (res < 0)

  0109a	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  0109f	7d 36		 jge	 SHORT $LN87@s390_hdiag

; 1077 :             {
; 1078 : #ifdef DYN76_DEBUG
; 1079 :                 io_error = errno;
; 1080 :                 logmsg("DF18: CFILE - write errno: %d\n", io_error);
; 1081 : #endif
; 1082 :                 R15 = -errno;

  010a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  010a7	8b 00		 mov	 eax, DWORD PTR [rax]
  010a9	f7 d8		 neg	 eax
  010ab	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1083 :                 set_reg(15,R15);

  010af	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  010b6	83 c0 3c	 add	 eax, 60			; 0000003cH
  010b9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  010c1	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  010c7	8b d0		 mov	 edx, eax
  010c9	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  010cd	e8 00 00 00 00	 call	 s390_vstore4

; 1084 :                 break;

  010d2	e9 9e 00 00 00	 jmp	 $LN9@s390_hdiag
$LN87@s390_hdiag:

; 1085 :             }
; 1086 : 
; 1087 :             /* Not an error, so 'res' is the number of bytes actually written */
; 1088 :             /* Update the address pointer and remaining bytes to write */
; 1089 :             R2 += res;

  010d7	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  010db	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  010df	03 c8		 add	 ecx, eax
  010e1	8b c1		 mov	 eax, ecx
  010e3	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1090 :             set_reg(2,R2);

  010e7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  010ee	83 c0 08	 add	 eax, 8
  010f1	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  010f9	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  010ff	8b d0		 mov	 edx, eax
  01101	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  01105	e8 00 00 00 00	 call	 s390_vstore4

; 1091 :             R4 -= res;

  0110a	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0110e	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  01112	2b c8		 sub	 ecx, eax
  01114	8b c1		 mov	 eax, ecx
  01116	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1092 :             set_reg(4,R4);

  0111a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01121	83 c0 10	 add	 eax, 16
  01124	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0112c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01132	8b d0		 mov	 edx, eax
  01134	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  01138	e8 00 00 00 00	 call	 s390_vstore4

; 1093 :             /* update the accumlated total */
; 1094 :             R15 += res;

  0113d	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  01141	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  01145	03 c8		 add	 ecx, eax
  01147	8b c1		 mov	 eax, ecx
  01149	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1095 :             set_reg(15,R15);

  0114d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01154	83 c0 3c	 add	 eax, 60			; 0000003cH
  01157	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0115f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01165	8b d0		 mov	 edx, eax
  01167	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  0116b	e8 00 00 00 00	 call	 s390_vstore4

; 1096 :         }

  01170	e9 68 fe ff ff	 jmp	 $LN8@s390_hdiag
$LN9@s390_hdiag:

; 1097 :         R5 = rfk->SaveArea;

  01175	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0117a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0117d	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1098 :         set_reg(5,R5);

  01181	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01188	83 c0 14	 add	 eax, 20
  0118b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  01193	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01199	8b d0		 mov	 edx, eax
  0119b	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0119f	e8 00 00 00 00	 call	 s390_vstore4
$LN84@s390_hdiag:
$LN78@s390_hdiag:
$LN76@s390_hdiag:
$LN62@s390_hdiag:
$LN58@s390_hdiag:
$LN54@s390_hdiag:

; 1099 :     }
; 1100 : 
; 1101 :     if (rfk) /* clean up, unless open already has */

  011a4	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  011aa	74 1a		 je	 SHORT $LN88@s390_hdiag

; 1102 :     {
; 1103 : #ifdef DYN76_DEBUG_FKEEPER
; 1104 :         logmsg("DF18: CFILE - removing and freeing restart fkeeper in rst_head list\n");
; 1105 : #endif
; 1106 :         /* Safely remove from the restart state */
; 1107 :         RemoveFKByID (rfk->id, &rst_head, DO_FREE);

  011ac	41 b8 01 00 00
	00		 mov	 r8d, 1
  011b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  011b9	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  011be	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  011c1	e8 00 00 00 00	 call	 RemoveFKByID
$LN88@s390_hdiag:

; 1108 :     }
; 1109 : 
; 1110 :     /* Make sure we do not restart this operation */
; 1111 :     R0 = 0;

  011c6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 1112 :     set_reg(0,R0);

  011ce	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  011d6	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  011dc	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  011e3	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  011e7	e8 00 00 00 00	 call	 s390_vstore4
$LN1@s390_hdiag:

; 1113 : }

  011ec	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  011f3	c3		 ret	 0
s390_hdiagf18_FC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
R15$ = 48
i$ = 52
rfk$ = 56
res$ = 64
R4$ = 68
R5$ = 72
R1$ = 76
R2$ = 80
R0$ = 84
R3$ = 88
handle$ = 92
space_ctl$ = 96
fk$ = 104
ghandle$ = 112
tv484 = 116
options$ = 144
cmpb$ = 152
regs$ = 160
s370_hdiagf18_FC PROC

; 345  : {

$LN90:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 346  :     int    space_ctl;           /* This is used to control address space selection */
; 347  :     int    i;
; 348  :     int    res;                 /* I/O integer results */
; 349  :     int    handle = 0;          /* Host file file handle for this file */

  00014	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR handle$[rsp], 0

; 350  :     U32    ghandle = 0;         /* Guest file descriptor */

  0001c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR ghandle$[rsp], 0

; 351  :     struct fkeeper *fk = NULL;  /* Host file structure */

  00024	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fk$[rsp], 0

; 352  :     struct fkeeper *rfk = NULL; /* Restart structure */

  0002d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 353  : #ifdef DYN76_DEBUG
; 354  :     int    io_error = 0;        /* Saves the errno for log messages */
; 355  : #endif
; 356  : 
; 357  :     /* Pseudo register contents are cached here once retrieved */
; 358  :     U32    R0;
; 359  :     U32    R1;
; 360  :     U32    R2;
; 361  :     U32    R3;
; 362  :     U32    R4;
; 363  :     U32    R5;
; 364  :     U32    R15;
; 365  : 
; 366  :     /* Initialise the LOCK on our first use */
; 367  :     if (nfile_init_req)

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR nfile_init_req, 0
  0003d	74 0f		 je	 SHORT $LN10@s370_hdiag

; 368  :     {
; 369  :         nfile_init_req = 0;

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR nfile_init_req, 0

; 370  :         nfile_init ();

  00049	e8 00 00 00 00	 call	 nfile_init
$LN10@s370_hdiag:

; 371  :     }
; 372  : 
; 373  : #ifdef DYN76_DEBUG
; 374  :     logmsg("DF18: CFILE Validating FOCPB Address %X\n", cmpb);
; 375  : #endif
; 376  : 
; 377  :     /* CPB must be on a doubleword and must not cross physical page boundary */
; 378  :     if ( ((cmpb & 0x7) != 0 ) ||

  0004e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00055	83 e0 07	 and	 eax, 7
  00058	85 c0		 test	 eax, eax
  0005a	75 20		 jne	 SHORT $LN12@s370_hdiag
  0005c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00063	83 c0 3f	 add	 eax, 63			; 0000003fH
  00066	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0006b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cmpb$[rsp]
  00072	81 e1 00 f8 ff
	7f		 and	 ecx, 2147481600		; 7ffff800H
  00078	3b c1		 cmp	 eax, ecx
  0007a	74 12		 je	 SHORT $LN11@s370_hdiag
$LN12@s370_hdiag:

; 379  :          (((cmpb + 63) & STORAGE_KEY_PAGEMASK) != (cmpb & STORAGE_KEY_PAGEMASK)) )
; 380  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0007c	ba 06 00 00 00	 mov	 edx, 6
  00081	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_hdiag:

; 381  : 
; 382  : #ifdef DYN76_DEBUG
; 383  :     logmsg("DF18: CFILE Validated FOCPB Address\n");
; 384  : #endif
; 385  : 
; 386  :     get_reg(R1, 1);     /* Retrieve the function number */

  0008e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00095	83 c0 04	 add	 eax, 4
  00098	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a0	ba fe ff ff ff	 mov	 edx, -2
  000a5	8b c8		 mov	 ecx, eax
  000a7	e8 00 00 00 00	 call	 s370_vfetch4
  000ac	89 44 24 4c	 mov	 DWORD PTR R1$[rsp], eax

; 387  :     if (R1 > 9)

  000b0	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  000b5	76 38		 jbe	 SHORT $LN13@s370_hdiag

; 388  :     {   /* Invalid Function - generate an exception */
; 389  :         R0 = 0;

  000b7	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 390  :         set_reg(0,R0);  /* don't restart this */

  000bf	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  000cd	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  000d4	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  000d8	e8 00 00 00 00	 call	 s370_vstore4

; 391  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  000dd	ba 15 00 00 00	 mov	 edx, 21
  000e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 s370_program_interrupt
$LN13@s370_hdiag:

; 392  :     }
; 393  : 
; 394  :     get_reg(R2, 2);  /* All functions use parameter 1, so fetch it */

  000ef	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  000f6	83 c0 08	 add	 eax, 8
  000f9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00101	ba fe ff ff ff	 mov	 edx, -2
  00106	8b c8		 mov	 ecx, eax
  00108	e8 00 00 00 00	 call	 s370_vfetch4
  0010d	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 395  : 
; 396  :     /* read, write, seek, commit, close and setmode use the file descriptor */
; 397  :     if (R1 >= 4 && R1 <= 9)

  00111	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00116	0f 82 cc 00 00
	00		 jb	 $LN14@s370_hdiag
  0011c	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  00121	0f 87 c1 00 00
	00		 ja	 $LN14@s370_hdiag

; 398  :     {
; 399  :         if (R1 == 4 || R1 == 5)

  00127	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  0012c	74 07		 je	 SHORT $LN17@s370_hdiag
  0012e	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  00133	75 2c		 jne	 SHORT $LN15@s370_hdiag
$LN17@s370_hdiag:

; 400  :         {   /* For read and write guest file descriptor is in pseudo R3 */
; 401  :             get_reg(R3, 3);

  00135	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0013c	83 c0 0c	 add	 eax, 12
  0013f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00147	ba fe ff ff ff	 mov	 edx, -2
  0014c	8b c8		 mov	 ecx, eax
  0014e	e8 00 00 00 00	 call	 s370_vfetch4
  00153	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 402  :             ghandle = R3;

  00157	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  0015b	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax

; 403  :         }

  0015f	eb 08		 jmp	 SHORT $LN16@s370_hdiag
$LN15@s370_hdiag:

; 404  :         else
; 405  :         {   /* For seek, commit, close and setmode, file descriptor is in
; 406  :                previously fetched pseudo R2 */
; 407  :             ghandle = R2;

  00161	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00165	89 44 24 70	 mov	 DWORD PTR ghandle$[rsp], eax
$LN16@s370_hdiag:

; 408  :         }
; 409  : 
; 410  :         /* If read, write, seek, commit, close or setmode */
; 411  :         /* convert the file descriptor into a file handle */
; 412  : #ifdef DYN76_DEBUG_FKEEPER
; 413  :         logmsg("DF18: CFILE - looking for guest file descriptor %d\n", ghandle);
; 414  : #endif
; 415  :         fk = FindFK(ghandle, &fkpr_head);

  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  00170	8b 4c 24 70	 mov	 ecx, DWORD PTR ghandle$[rsp]
  00174	e8 00 00 00 00	 call	 FindFK
  00179	48 89 44 24 68	 mov	 QWORD PTR fk$[rsp], rax

; 416  : #ifdef DYN76_DEBUG_FKEEPER
; 417  :         logmsg("DF18: CFILE - guest file descriptor %d found at %X\n",
; 418  :                ghandle, fk);
; 419  : #endif
; 420  :         if (!fk)

  0017e	48 83 7c 24 68
	00		 cmp	 QWORD PTR fk$[rsp], 0
  00184	75 56		 jne	 SHORT $LN18@s370_hdiag

; 421  :         {   /* Did not find the guest file descriptor.
; 422  :                Treat it as if it were a bad host file handle */
; 423  : #ifdef DYN76_DEBUG
; 424  :             logmsg("DF18: CFILE - guest file descriptor not found: %d\n", ghandle);
; 425  : #endif
; 426  :             R15 = -1 * EBADF;

  00186	c7 44 24 30 f7
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -9	; fffffff7H

; 427  :             set_reg(15,R15);

  0018e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00195	83 c0 3c	 add	 eax, 60			; 0000003cH
  00198	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001a0	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001a6	8b d0		 mov	 edx, eax
  001a8	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  001ac	e8 00 00 00 00	 call	 s370_vstore4

; 428  :             R0 = 0;

  001b1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 429  :             set_reg(0,R0); /* No restart on a failure */

  001b9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001c1	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  001c7	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  001ce	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  001d2	e8 00 00 00 00	 call	 s370_vstore4

; 430  :             return;

  001d7	e9 dc 0f 00 00	 jmp	 $LN1@s370_hdiag
$LN18@s370_hdiag:

; 431  :         }
; 432  :         handle = fk->handle;  /* All host file accesses use this variable */

  001dc	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  001e1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001e4	89 44 24 5c	 mov	 DWORD PTR handle$[rsp], eax
$LN14@s370_hdiag:

; 433  : #ifdef DYN76_DEBUG_FKEEPER
; 434  :         logmsg("DF18: CFILE - host file handle: %d\n", handle);
; 435  : #endif
; 436  :     }
; 437  : 
; 438  : /* The following 4 functions are always ready to attempt
; 439  :    and they are not interruptible: CLOSE, COMMIT, SEEK, SETMODE
; 440  : */
; 441  : 
; 442  :     /*------------------------*/
; 443  :     /* SETMODE File Operation */
; 444  :     /*------------------------*/
; 445  : 
; 446  :     if (R1 == 9)

  001e8	83 7c 24 4c 09	 cmp	 DWORD PTR R1$[rsp], 9
  001ed	0f 85 fc 00 00
	00		 jne	 $LN19@s370_hdiag

; 447  :     {
; 448  : #ifdef DYN76_DEBUG
; 449  :         logmsg("DF18: CFILE - setmode file operation\n");
; 450  : #endif
; 451  :         get_reg(R3, 3);   /* Fetch parameter two - new file mode */

  001f3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  001fa	83 c0 0c	 add	 eax, 12
  001fd	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00205	ba fe ff ff ff	 mov	 edx, -2
  0020a	8b c8		 mov	 ecx, eax
  0020c	e8 00 00 00 00	 call	 s370_vfetch4
  00211	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 452  :         if (R3 & 0x04)

  00215	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00219	83 e0 04	 and	 eax, 4
  0021c	85 c0		 test	 eax, eax
  0021e	74 0a		 je	 SHORT $LN21@s370_hdiag

; 453  :             i = _O_TEXT;

  00220	c7 44 24 34 00
	40 00 00	 mov	 DWORD PTR i$[rsp], 16384 ; 00004000H
  00228	eb 08		 jmp	 SHORT $LN22@s370_hdiag
$LN21@s370_hdiag:

; 454  :         else
; 455  :             i = _O_BINARY;

  0022a	c7 44 24 34 00
	80 00 00	 mov	 DWORD PTR i$[rsp], 32768 ; 00008000H
$LN22@s370_hdiag:

; 456  : #ifdef _MSVC_
; 457  :         i = _setmode (handle, i); /* Alter the Windows mode */

  00232	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00236	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode
  00240	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 458  :         if (i == -1)

  00244	83 7c 24 34 ff	 cmp	 DWORD PTR i$[rsp], -1
  00249	75 36		 jne	 SHORT $LN23@s370_hdiag

; 459  :         {
; 460  :             R15 = -errno;

  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00251	8b 00		 mov	 eax, DWORD PTR [rax]
  00253	f7 d8		 neg	 eax
  00255	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 461  :             set_reg(15,R15);

  00259	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00260	83 c0 3c	 add	 eax, 60			; 0000003cH
  00263	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0026b	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00271	8b d0		 mov	 edx, eax
  00273	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00277	e8 00 00 00 00	 call	 s370_vstore4

; 462  :             return;

  0027c	e9 37 0f 00 00	 jmp	 $LN1@s370_hdiag
$LN23@s370_hdiag:

; 463  :         }
; 464  : #else
; 465  :         get_reg(R3, 3);
; 466  :         /* *nix doesn't need handle updates */
; 467  :         if (fk->mode)
; 468  :             i = _O_TEXT;
; 469  :         else
; 470  :             i = _O_BINARY;
; 471  : #endif
; 472  :         if (i == _O_TEXT) /* Previous mode */

  00281	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR i$[rsp], 16384 ; 00004000H
  00289	75 0a		 jne	 SHORT $LN24@s370_hdiag

; 473  :             R15 = 0x04;

  0028b	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR R15$[rsp], 4
  00293	eb 08		 jmp	 SHORT $LN25@s370_hdiag
$LN24@s370_hdiag:

; 474  :         else
; 475  :             R15 = 0x08;

  00295	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR R15$[rsp], 8
$LN25@s370_hdiag:

; 476  :         set_reg(15,R15);

  0029d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  002a4	83 c0 3c	 add	 eax, 60			; 0000003cH
  002a7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002af	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  002b5	8b d0		 mov	 edx, eax
  002b7	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  002bb	e8 00 00 00 00	 call	 s370_vstore4

; 477  : 
; 478  :         if (R3 & 0x04) /* Update translation details: */

  002c0	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  002c4	83 e0 04	 and	 eax, 4
  002c7	85 c0		 test	 eax, eax
  002c9	74 0e		 je	 SHORT $LN26@s370_hdiag

; 479  :             fk->mode = 1;    /* yes, translate */

  002cb	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002d0	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
  002d7	eb 0c		 jmp	 SHORT $LN27@s370_hdiag
$LN26@s370_hdiag:

; 480  :         else
; 481  :             fk->mode = 0;    /* no, dont */

  002d9	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  002de	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN27@s370_hdiag:

; 482  :         return;

  002e5	e9 ce 0e 00 00	 jmp	 $LN1@s370_hdiag

; 483  :     } else

  002ea	e9 be 01 00 00	 jmp	 $LN20@s370_hdiag
$LN19@s370_hdiag:

; 484  : 
; 485  :     /*------------------------*/
; 486  :     /* CLOSE File Operation   */
; 487  :     /*------------------------*/
; 488  : 
; 489  :     if (R1 == 8)

  002ef	83 7c 24 4c 08	 cmp	 DWORD PTR R1$[rsp], 8
  002f4	0f 85 97 00 00
	00		 jne	 $LN28@s370_hdiag

; 490  :     {
; 491  : #ifdef DYN76_DEBUG
; 492  :         logmsg("DF18: CFILE - _close(%d)\n", handle);
; 493  : #endif
; 494  :         res = _close (handle);

  002fa	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  00304	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 495  : #ifdef DYN76_DEBUG
; 496  :         logmsg("DF18: CFILE - _close result: %d\n", res);
; 497  : #endif
; 498  :         R15 = res;

  00308	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0030c	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 499  :         set_reg(15,R15);

  00310	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00317	83 c0 3c	 add	 eax, 60			; 0000003cH
  0031a	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00322	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00328	8b d0		 mov	 edx, eax
  0032a	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  0032e	e8 00 00 00 00	 call	 s370_vstore4

; 500  :         if (R15 == 0)

  00333	83 7c 24 30 00	 cmp	 DWORD PTR R15$[rsp], 0
  00338	75 1c		 jne	 SHORT $LN30@s370_hdiag

; 501  :         {   RemoveFKByID (fk->id, &fkpr_head, DO_FREE);

  0033a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00340	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fkpr_head
  00347	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  0034c	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0034f	e8 00 00 00 00	 call	 RemoveFKByID

; 502  :         }

  00354	eb 31		 jmp	 SHORT $LN31@s370_hdiag
$LN30@s370_hdiag:

; 503  :         else
; 504  :         {   R15 = -errno;

  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0035c	8b 00		 mov	 eax, DWORD PTR [rax]
  0035e	f7 d8		 neg	 eax
  00360	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 505  :             set_reg(15,R15);

  00364	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0036b	83 c0 3c	 add	 eax, 60			; 0000003cH
  0036e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00376	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0037c	8b d0		 mov	 edx, eax
  0037e	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00382	e8 00 00 00 00	 call	 s370_vstore4
$LN31@s370_hdiag:

; 506  :         }
; 507  :         return;

  00387	e9 2c 0e 00 00	 jmp	 $LN1@s370_hdiag

; 508  :     } else

  0038c	e9 1c 01 00 00	 jmp	 $LN29@s370_hdiag
$LN28@s370_hdiag:

; 509  : 
; 510  :     /*------------------------*/
; 511  :     /* COMMIT File Operation  */
; 512  :     /*------------------------*/
; 513  : 
; 514  :     if (R1 == 7)

  00391	83 7c 24 4c 07	 cmp	 DWORD PTR R1$[rsp], 7
  00396	75 61		 jne	 SHORT $LN32@s370_hdiag

; 515  :     {
; 516  : #ifdef DYN76_DEBUG
; 517  :         logmsg("DF18: CFILE - commit file operation\n");
; 518  : #endif
; 519  : 
; 520  : #ifdef _MSVC_
; 521  : #ifdef DYN76_DEBUG
; 522  :         logmsg("DF18: CFILE - _commit(%d)\n", handle);
; 523  : #endif
; 524  :         res =  _commit (handle);

  00398	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  003a2	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 525  : #ifdef DYN76_DEBUG
; 526  :         logmsg("DF18: CFILE - _commit result: %d\n", res);
; 527  : #endif
; 528  : #else /* ifdef __MSVC__ */
; 529  : 
; 530  : #ifdef DYN76_DEBUG
; 531  :         logmsg("DF18: CFILE - fsync(%d)\n", handle);
; 532  : #endif
; 533  :         res = fsync (handle);
; 534  : #ifdef DYN76_DEBUG
; 535  :         logmsg("DF18: CFILE - fsync result: %d \n", res);
; 536  : #endif
; 537  : #endif /* ifdef __MSVC__ */
; 538  :         if (res != 0)

  003a6	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  003ab	74 17		 je	 SHORT $LN34@s370_hdiag

; 539  :         {
; 540  :             res = errno;

  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003b3	8b 00		 mov	 eax, DWORD PTR [rax]
  003b5	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 541  : #ifdef DYN76_DEBUG
; 542  :         logmsg("DF18: CFILE - fsync/_commit errno: %d \n", res);
; 543  : #endif
; 544  :             R15 = -1 * res;

  003b9	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  003be	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 545  :         }

  003c2	eb 08		 jmp	 SHORT $LN35@s370_hdiag
$LN34@s370_hdiag:

; 546  :         else
; 547  :         {
; 548  :             R15 = res;

  003c4	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  003c8	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN35@s370_hdiag:

; 549  :         }
; 550  :         set_reg(15,R15);

  003cc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  003d3	83 c0 3c	 add	 eax, 60			; 0000003cH
  003d6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003de	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  003e4	8b d0		 mov	 edx, eax
  003e6	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  003ea	e8 00 00 00 00	 call	 s370_vstore4

; 551  :         return;

  003ef	e9 c4 0d 00 00	 jmp	 $LN1@s370_hdiag

; 552  :     } else

  003f4	e9 b4 00 00 00	 jmp	 $LN33@s370_hdiag
$LN32@s370_hdiag:

; 553  : 
; 554  :     /*------------------------*/
; 555  :     /* SEEK File Operation    */
; 556  :     /*------------------------*/
; 557  : 
; 558  :     if (R1 == 6)

  003f9	83 7c 24 4c 06	 cmp	 DWORD PTR R1$[rsp], 6
  003fe	0f 85 a9 00 00
	00		 jne	 $LN36@s370_hdiag

; 559  :     {
; 560  : #ifdef DYN76_DEBUG
; 561  :         logmsg("DF18: CFILE - seek\n");
; 562  : #endif
; 563  :         get_reg(R3,3);  /* offset in bytes */

  00404	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0040b	83 c0 0c	 add	 eax, 12
  0040e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00416	ba fe ff ff ff	 mov	 edx, -2
  0041b	8b c8		 mov	 ecx, eax
  0041d	e8 00 00 00 00	 call	 s370_vfetch4
  00422	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 564  :         get_reg(R4,4);  /* origin of the seek */

  00426	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0042d	83 c0 10	 add	 eax, 16
  00430	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00438	ba fe ff ff ff	 mov	 edx, -2
  0043d	8b c8		 mov	 ecx, eax
  0043f	e8 00 00 00 00	 call	 s370_vfetch4
  00444	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 565  : #ifdef DYN76_DEBUG
; 566  :         logmsg("DF18: CFILE - _lseek(%d, %d, %d)\n", handle, (long)R3, (int)R4);
; 567  : #endif
; 568  :         res = _lseek (handle, (long)R3, (int)R4);

  00448	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  0044d	8b 54 24 58	 mov	 edx, DWORD PTR R3$[rsp]
  00451	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseek
  0045b	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 569  : #ifdef DYN76_DEBUG
; 570  :         logmsg("DF18: CFILE - _lseek result: %d\n", res);
; 571  : #endif
; 572  :         if (res == -1)

  0045f	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00464	75 17		 jne	 SHORT $LN37@s370_hdiag

; 573  :         {
; 574  :             res = errno;

  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0046c	8b 00		 mov	 eax, DWORD PTR [rax]
  0046e	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 575  : #ifdef DYN76_DEBUG
; 576  :             logmsg("DF18: CFILE - _lseek errno: %d\n", res);
; 577  : #endif
; 578  :             R15 = -1 * res;

  00472	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00477	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 579  :         }

  0047b	eb 08		 jmp	 SHORT $LN38@s370_hdiag
$LN37@s370_hdiag:

; 580  :         else
; 581  :         {
; 582  :             R15 = res;

  0047d	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00481	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN38@s370_hdiag:

; 583  :         }
; 584  :         set_reg(15,R15);

  00485	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0048c	83 c0 3c	 add	 eax, 60			; 0000003cH
  0048f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00497	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0049d	8b d0		 mov	 edx, eax
  0049f	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  004a3	e8 00 00 00 00	 call	 s370_vstore4

; 585  :         return;

  004a8	e9 0b 0d 00 00	 jmp	 $LN1@s370_hdiag
$LN36@s370_hdiag:
$LN33@s370_hdiag:
$LN29@s370_hdiag:
$LN20@s370_hdiag:

; 586  :     }
; 587  : 
; 588  :     /*-------------------------------------------------------------*/
; 589  :     /* Interruptible operation initilization                       */
; 590  :     /*-------------------------------------------------------------*/
; 591  : 
; 592  :     if ( (options & SPACE_MASK) == DF18_REAL_SPACE)

  004ad	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR options$[rsp]
  004b4	83 e0 70	 and	 eax, 112		; 00000070H
  004b7	83 f8 40	 cmp	 eax, 64			; 00000040H
  004ba	75 0a		 jne	 SHORT $LN39@s370_hdiag

; 593  :         space_ctl = USE_REAL_ADDR;

  004bc	c7 44 24 60 fe
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -2
  004c4	eb 08		 jmp	 SHORT $LN40@s370_hdiag
$LN39@s370_hdiag:

; 594  :     else
; 595  :         space_ctl = USE_PRIMARY_SPACE;

  004c6	c7 44 24 60 fd
	ff ff ff	 mov	 DWORD PTR space_ctl$[rsp], -3
$LN40@s370_hdiag:

; 596  : 
; 597  :     get_reg(R0,0);        /* Retrieve Restart Stage */

  004ce	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004d6	ba fe ff ff ff	 mov	 edx, -2
  004db	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cmpb$[rsp]
  004e2	e8 00 00 00 00	 call	 s370_vfetch4
  004e7	89 44 24 54	 mov	 DWORD PTR R0$[rsp], eax

; 598  : 
; 599  :     if (R0 == 0)

  004eb	83 7c 24 54 00	 cmp	 DWORD PTR R0$[rsp], 0
  004f0	0f 85 57 01 00
	00		 jne	 $LN41@s370_hdiag

; 600  :     {   /* New operation, not a restart.  Establish new operational state */
; 601  :         rfk = malloc (sizeof (struct fkeeper));

  004f6	b9 28 02 00 00	 mov	 ecx, 552		; 00000228H
  004fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00501	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 602  :         if (rfk == NULL)

  00506	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  0050c	75 30		 jne	 SHORT $LN43@s370_hdiag

; 603  :         {
; 604  :             R15 = -1 * ENOMEM; /* Error */

  0050e	c7 44 24 30 f4
	ff ff ff	 mov	 DWORD PTR R15$[rsp], -12 ; fffffff4H

; 605  :             set_reg(15,R15);

  00516	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0051d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00520	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00528	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0052e	8b d0		 mov	 edx, eax
  00530	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00534	e8 00 00 00 00	 call	 s370_vstore4

; 606  :             return;

  00539	e9 7a 0c 00 00	 jmp	 $LN1@s370_hdiag
$LN43@s370_hdiag:

; 607  :         }
; 608  :         rfk->mode = -1;      /* mode is not initially set */

  0053e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00543	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [rax+20], -1

; 609  :         rfk->data = 0;       /* Nothing in the buffer yet */

  0054a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0054f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 610  :         rfk->handle = 0;     /* No file handle yet either (could be an open) */

  00556	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0055b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 611  :         get_reg(R5,5);       /* Save pseudo R5 */

  00562	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00569	83 c0 14	 add	 eax, 20
  0056c	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00574	ba fe ff ff ff	 mov	 edx, -2
  00579	8b c8		 mov	 ecx, eax
  0057b	e8 00 00 00 00	 call	 s370_vfetch4
  00580	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 612  :         rfk->SaveArea = R5;

  00584	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00589	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0058d	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 613  : 
; 614  :         /* Set this state's id for the guest and increment
; 615  :            and link the structure to the list even if not yet open.
; 616  :            This is required to allow open to be restarted based upon the
; 617  :            id.  If the file does not successfully open, then the linked entry
; 618  :            must be removed in stage 3
; 619  :         */
; 620  :         dolock (nfile_lock);    /* Take ownership of the list */

  00590	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 621  : 
; 622  :         R5 = restart_id++;        /* safely increment the id counter */

  0059d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005a3	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax
  005a7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR restart_id
  005ad	ff c0		 inc	 eax
  005af	89 05 00 00 00
	00		 mov	 DWORD PTR restart_id, eax

; 623  : #ifdef DYN76_DEBUG_FKEEPER
; 624  :         logmsg("DF18: CFILE - adding restart fkeeper to rst_head list\n");
; 625  : #endif
; 626  :         AddFKByID(R5, rfk, &rst_head);

  005b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:rst_head
  005bc	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  005c1	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005c5	e8 00 00 00 00	 call	 AddFKByID

; 627  : 
; 628  :         unlock (nfile_lock);    /* Release ownership of the list */

  005ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 629  :         set_reg(5,R5);          /* Set the restart state for this new operation */

  005d7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  005de	83 c0 14	 add	 eax, 20
  005e1	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005e9	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  005ef	8b d0		 mov	 edx, eax
  005f1	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  005f5	e8 00 00 00 00	 call	 s370_vstore4

; 630  : 
; 631  :         /* For read/write we need this cleared here */
; 632  :         R15 = 0;

  005fa	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR R15$[rsp], 0

; 633  :         set_reg(15,R15);

  00602	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00609	83 c0 3c	 add	 eax, 60			; 0000003cH
  0060c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00614	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0061a	8b d0		 mov	 edx, eax
  0061c	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00620	e8 00 00 00 00	 call	 s370_vstore4

; 634  : 
; 635  :         /* Set the restart stage in case the next stage is interrupted */
; 636  :         R0 = 1;                /* Set work stage 1 on restart */

  00625	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR R0$[rsp], 1

; 637  :         set_reg(0,R0);

  0062d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00635	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0063b	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  00642	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  00646	e8 00 00 00 00	 call	 s370_vstore4

; 638  :     } else

  0064b	eb 77		 jmp	 SHORT $LN42@s370_hdiag
$LN41@s370_hdiag:

; 639  : 
; 640  :     /*-------------------------------------------------------------*/
; 641  :     /* Interruptible operation restart                             */
; 642  :     /*-------------------------------------------------------------*/
; 643  : 
; 644  :     {   /* Must have restarted, refresh fk */
; 645  :         get_reg(R5,5);    /* R5 contains the previous restart id */

  0064d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00654	83 c0 14	 add	 eax, 20
  00657	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0065f	ba fe ff ff ff	 mov	 edx, -2
  00664	8b c8		 mov	 ecx, eax
  00666	e8 00 00 00 00	 call	 s370_vfetch4
  0066b	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 646  :         rfk = FindFK(R5, &rst_head);

  0066f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  00676	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0067a	e8 00 00 00 00	 call	 FindFK
  0067f	48 89 44 24 38	 mov	 QWORD PTR rfk$[rsp], rax

; 647  :         if (!rfk)

  00684	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  0068a	75 38		 jne	 SHORT $LN44@s370_hdiag

; 648  :         {   /* Did not find the restart - generate an exception */
; 649  :             R0 = 0;

  0068c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 650  :             set_reg(0,R0); /* restart failed, so don't do it again */

  00694	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0069c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  006a2	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  006a9	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  006ad	e8 00 00 00 00	 call	 s370_vstore4

; 651  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIAL_OPERATION_EXCEPTION);

  006b2	ba 13 00 00 00	 mov	 edx, 19
  006b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bf	e8 00 00 00 00	 call	 s370_program_interrupt
$LN44@s370_hdiag:
$LN42@s370_hdiag:

; 652  :         }
; 653  :     }
; 654  : 
; 655  :     /*-------------------------------------------------------------*/
; 656  :     /* Work Stage 1 Initial or Restart                             */
; 657  :     /*-------------------------------------------------------------*/
; 658  : 
; 659  :     if (R0 == 1)

  006c4	83 7c 24 54 01	 cmp	 DWORD PTR R0$[rsp], 1
  006c9	0f 85 1d 01 00
	00		 jne	 $LN45@s370_hdiag

; 660  :     {
; 661  :         if (R1 == 0)

  006cf	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  006d4	0f 85 ec 00 00
	00		 jne	 $LN46@s370_hdiag
$LN2@s370_hdiag:

; 662  :         { /* rename - need to get 2 filenames */
; 663  :             while ((rfk->data == 0) ||                    /* Started? */

  006da	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  006df	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006e3	74 1e		 je	 SHORT $LN47@s370_hdiag
  006e5	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  006ea	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  006ed	ff c8		 dec	 eax
  006ef	48 98		 cdqe
  006f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  006f6	0f be 44 01 1c	 movsx	 eax, BYTE PTR [rcx+rax+28]
  006fb	85 c0		 test	 eax, eax
  006fd	0f 84 9f 00 00
	00		 je	 $LN3@s370_hdiag
$LN47@s370_hdiag:

; 664  :                    (rfk->oldname [rfk->data - 1] != 0))
; 665  :             {   /* Not Finished */
; 666  : 
; 667  :                 /* WARNING: This is where interruption might occur */
; 668  :                 ARCH_DEP(wfetchc)

  00703	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00707	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0070c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00711	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  00715	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  0071a	48 8d 4c 0a 1c	 lea	 rcx, QWORD PTR [rdx+rcx+28]
  0071f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00727	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0072c	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00731	44 8b c0	 mov	 r8d, eax
  00734	33 d2		 xor	 edx, edx
  00736	e8 00 00 00 00	 call	 s370_vfetchc

; 669  :                     (&(rfk->oldname [rfk->data]),
; 670  :                      0,
; 671  :                      R2,
; 672  :                      space_ctl,
; 673  :                      regs);
; 674  : 
; 675  :                 /* Exception, can recalculate if/when restart */
; 676  :                 R2 += 1;

  0073b	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  0073f	ff c0		 inc	 eax
  00741	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 677  :                 set_reg(2,R2);

  00745	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0074c	83 c0 08	 add	 eax, 8
  0074f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00757	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0075d	8b d0		 mov	 edx, eax
  0075f	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00763	e8 00 00 00 00	 call	 s370_vstore4

; 678  :                 rfk->data += 1;  /* Next host byte location */

  00768	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0076d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00770	ff c0		 inc	 eax
  00772	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00777	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 679  :                 if (rfk->data >= 259)

  0077a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0077f	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  00786	7c 15		 jl	 SHORT $LN48@s370_hdiag

; 680  :                 {
; 681  :                     rfk->oldname [fk->data] = 0;

  00788	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  0078d	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  00791	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00796	c6 44 01 1c 00	 mov	 BYTE PTR [rcx+rax+28], 0

; 682  :                     break;

  0079b	eb 05		 jmp	 SHORT $LN3@s370_hdiag
$LN48@s370_hdiag:

; 683  :                 }
; 684  :             }

  0079d	e9 38 ff ff ff	 jmp	 $LN2@s370_hdiag
$LN3@s370_hdiag:

; 685  :             StrConverter (rfk->oldname, DCCebcdic_to_ascii);

  007a2	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007a7	48 83 c0 1c	 add	 rax, 28
  007ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  007b2	48 8b c8	 mov	 rcx, rax
  007b5	e8 00 00 00 00	 call	 StrConverter

; 686  :             rfk->data = 0; /* Get ready for newname */

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  007bf	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
$LN46@s370_hdiag:

; 687  :         }
; 688  :         R0 = 2;               /* Set work stage 2 */

  007c6	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR R0$[rsp], 2

; 689  :         set_reg(0,R0);

  007ce	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  007d6	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  007dc	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  007e3	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  007e7	e8 00 00 00 00	 call	 s370_vstore4
$LN45@s370_hdiag:

; 690  :     }
; 691  : 
; 692  :     /*-------------------------------------------------------------*/
; 693  :     /* Work Stage 2 Initial or Restart                             */
; 694  :     /*-------------------------------------------------------------*/
; 695  : 
; 696  :     if (R0 == 2)

  007ec	83 7c 24 54 02	 cmp	 DWORD PTR R0$[rsp], 2
  007f1	0f 85 1c 01 00
	00		 jne	 $LN49@s370_hdiag

; 697  :     {
; 698  :         if (R1 <= 3)

  007f7	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  007fc	0f 87 eb 00 00
	00		 ja	 $LN50@s370_hdiag
$LN4@s370_hdiag:

; 699  :         {   /* unlink/open/close - need to get 1 filename */
; 700  :             /* rename - needs to get 2nd filename */
; 701  :             while ((rfk->data == 0)                        /* Starting */
; 702  :                    || (rfk->filename [rfk->data - 1] != 0)) /* Not Finished */

  00802	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00807	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0080b	74 21		 je	 SHORT $LN51@s370_hdiag
  0080d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00812	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00815	ff c8		 dec	 eax
  00817	48 98		 cdqe
  00819	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0081e	0f be 84 01 20
	01 00 00	 movsx	 eax, BYTE PTR [rcx+rax+288]
  00826	85 c0		 test	 eax, eax
  00828	0f 84 a5 00 00
	00		 je	 $LN5@s370_hdiag
$LN51@s370_hdiag:

; 703  :             {
; 704  :                 /* WARNING: This is where interruption might occur */
; 705  :                 ARCH_DEP(wfetchc)

  0082e	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00832	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00837	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0083c	48 63 49 18	 movsxd	 rcx, DWORD PTR [rcx+24]
  00840	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00845	48 8d 8c 0a 20
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+288]
  0084d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00855	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0085a	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  0085f	44 8b c0	 mov	 r8d, eax
  00862	33 d2		 xor	 edx, edx
  00864	e8 00 00 00 00	 call	 s370_vfetchc

; 706  :                     (&(rfk->filename [rfk->data]),
; 707  :                      0,
; 708  :                      R2,
; 709  :                      space_ctl,
; 710  :                      regs);
; 711  : 
; 712  :                 /* Exception, can recalculate if/when restart */
; 713  :                 R2 += 1;

  00869	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  0086d	ff c0		 inc	 eax
  0086f	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 714  :                 set_reg(2,R2);

  00873	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0087a	83 c0 08	 add	 eax, 8
  0087d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00885	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0088b	8b d0		 mov	 edx, eax
  0088d	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00891	e8 00 00 00 00	 call	 s370_vstore4

; 715  :                 rfk->data += 1;  /* Next host byte location */

  00896	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0089b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0089e	ff c0		 inc	 eax
  008a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  008a5	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 716  :                 if (rfk->data >= 259)

  008a8	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008ad	81 78 18 03 01
	00 00		 cmp	 DWORD PTR [rax+24], 259	; 00000103H
  008b4	7c 18		 jl	 SHORT $LN52@s370_hdiag

; 717  :                 {
; 718  :                     rfk->filename [rfk->data] = 0;

  008b6	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008bb	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  008bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  008c4	c6 84 01 20 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+288], 0

; 719  :                     break;

  008cc	eb 05		 jmp	 SHORT $LN5@s370_hdiag
$LN52@s370_hdiag:

; 720  :                 }
; 721  :             }

  008ce	e9 2f ff ff ff	 jmp	 $LN4@s370_hdiag
$LN5@s370_hdiag:

; 722  :             StrConverter (rfk->filename, DCCebcdic_to_ascii);

  008d3	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  008d8	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  008de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  008e5	48 8b c8	 mov	 rcx, rax
  008e8	e8 00 00 00 00	 call	 StrConverter
$LN50@s370_hdiag:

; 723  :         }
; 724  :         R0 = 3;               /* Set work stage */

  008ed	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR R0$[rsp], 3

; 725  :         set_reg(0,R0);

  008f5	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008fd	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00903	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  0090a	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  0090e	e8 00 00 00 00	 call	 s370_vstore4
$LN49@s370_hdiag:

; 726  :     }
; 727  : 
; 728  :     /*---------------------------------------------------------------------*/
; 729  :     /* Work Stage 3 Initial or Restart - Interruptible Operation & Results */
; 730  :     /*---------------------------------------------------------------------*/
; 731  : 
; 732  :     /*------------------------*/
; 733  :     /* RENAME File Operation  */
; 734  :     /*------------------------*/
; 735  : 
; 736  :     if (R1 == 0)

  00913	83 7c 24 4c 00	 cmp	 DWORD PTR R1$[rsp], 0
  00918	0f 85 9e 00 00
	00		 jne	 $LN53@s370_hdiag

; 737  :     {
; 738  : #ifdef DYN76_DEBUG
; 739  :         logmsg("DF18: CFILE - rename\n");
; 740  : #endif
; 741  :         /* This is safe to restore early here */
; 742  :         R5 = rfk->SaveArea;

  0091e	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00923	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00926	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 743  :         set_reg(5,R5);

  0092a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00931	83 c0 14	 add	 eax, 20
  00934	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0093c	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00942	8b d0		 mov	 edx, eax
  00944	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00948	e8 00 00 00 00	 call	 s370_vstore4

; 744  : #ifdef DYN76_DEBUG
; 745  :         logmsg("DF18: CFILE - rename(from='%s',to='%s')\n",
; 746  :                 rfk->oldname, rfk->filename);
; 747  : #endif
; 748  :         res = rename (rfk->oldname, rfk->filename);

  0094d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00952	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00958	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  0095d	48 83 c1 1c	 add	 rcx, 28
  00961	48 8b d0	 mov	 rdx, rax
  00964	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rename
  0096a	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 749  : #ifdef DYN76_DEBUG
; 750  :         logmsg("DF18: CFILE - rename result: %d\n", res);
; 751  : #endif
; 752  :         if (res != 0)

  0096e	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  00973	74 17		 je	 SHORT $LN55@s370_hdiag

; 753  :         {
; 754  :             res = errno;

  00975	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0097b	8b 00		 mov	 eax, DWORD PTR [rax]
  0097d	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 755  : #ifdef DYN76_DEBUG
; 756  :         logmsg("DF18: CFILE - rename errno: %d\n", res);
; 757  : #endif
; 758  :             R15 = -1 * res;

  00981	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00986	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 759  :         }

  0098a	eb 08		 jmp	 SHORT $LN56@s370_hdiag
$LN55@s370_hdiag:

; 760  :         else
; 761  :         {
; 762  :             R15 = res;

  0098c	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00990	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN56@s370_hdiag:

; 763  :         }
; 764  :         set_reg(15,R15);

  00994	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  0099b	83 c0 3c	 add	 eax, 60			; 0000003cH
  0099e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009a6	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  009ac	8b d0		 mov	 edx, eax
  009ae	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  009b2	e8 00 00 00 00	 call	 s370_vstore4

; 765  :     } else

  009b7	e9 b4 07 00 00	 jmp	 $LN54@s370_hdiag
$LN53@s370_hdiag:

; 766  : 
; 767  :     /*------------------------*/
; 768  :     /* UNLINK File Operation  */
; 769  :     /*------------------------*/
; 770  : 
; 771  :     if (R1 == 1)

  009bc	83 7c 24 4c 01	 cmp	 DWORD PTR R1$[rsp], 1
  009c1	0f 85 95 00 00
	00		 jne	 $LN57@s370_hdiag

; 772  :     {
; 773  : #ifdef DYN76_DEBUG
; 774  :         logmsg("DF18: CFILE - unlink\n");
; 775  : #endif
; 776  :         /* This is safe to restore early here */
; 777  :         R5 = rfk->SaveArea;

  009c7	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  009cc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  009cf	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 778  :         set_reg(5,R5);

  009d3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  009da	83 c0 14	 add	 eax, 20
  009dd	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009e5	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  009eb	8b d0		 mov	 edx, eax
  009ed	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  009f1	e8 00 00 00 00	 call	 s370_vstore4

; 779  : 
; 780  : #ifdef _MSVC_
; 781  : #ifdef DYN76_DEBUG
; 782  :         logmsg("DF18: CFILE - _unkink('%s')\n", rfk->filename);
; 783  : #endif
; 784  :         res = _unlink (rfk->filename);

  009f6	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  009fb	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00a01	48 8b c8	 mov	 rcx, rax
  00a04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__unlink
  00a0a	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 785  : #ifdef DYN76_DEBUG
; 786  :         logmsg("DF18: CFILE - _unlink result: %d\n", res);
; 787  : #endif
; 788  : #else
; 789  : #ifdef DYN76_DEBUG
; 790  :         logmsg("DF18: CFILE - remove('%s')\n", rfk->filename);
; 791  : #endif
; 792  :         res = remove (rfk->filename);
; 793  : #ifdef DYN76_DEBUG
; 794  :         logmsg("DF18: CFILE - remove result: %d\n", res);
; 795  : #endif
; 796  : #endif
; 797  :         if (res != 0)

  00a0e	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  00a13	74 17		 je	 SHORT $LN59@s370_hdiag

; 798  :         {
; 799  :             res = errno;

  00a15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a1b	8b 00		 mov	 eax, DWORD PTR [rax]
  00a1d	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 800  : #ifdef DYN76_DEBUG
; 801  :             logmsg("DF18: CFILE - remove/_unlink errno: %d\n", res);
; 802  : #endif
; 803  :             R15 = -1 * res;

  00a21	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00a26	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 804  :         }

  00a2a	eb 08		 jmp	 SHORT $LN60@s370_hdiag
$LN59@s370_hdiag:

; 805  :         else
; 806  :         {
; 807  :             R15 = res;

  00a2c	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  00a30	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax
$LN60@s370_hdiag:

; 808  :         }
; 809  :         set_reg(15,R15);

  00a34	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00a3b	83 c0 3c	 add	 eax, 60			; 0000003cH
  00a3e	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a46	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a4c	8b d0		 mov	 edx, eax
  00a4e	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00a52	e8 00 00 00 00	 call	 s370_vstore4

; 810  :     } else

  00a57	e9 14 07 00 00	 jmp	 $LN58@s370_hdiag
$LN57@s370_hdiag:

; 811  : 
; 812  :     /*------------------------*/
; 813  :     /* OPEN File Operation    */
; 814  :     /*------------------------*/
; 815  : 
; 816  :     if (R1 == 2)

  00a5c	83 7c 24 4c 02	 cmp	 DWORD PTR R1$[rsp], 2
  00a61	0f 85 87 02 00
	00		 jne	 $LN61@s370_hdiag

; 817  :     {
; 818  : #ifdef DYN76_DEBUG
; 819  :         logmsg("DF18: CFILE - open\n");
; 820  : #endif
; 821  :         /* This is safe to restore early here */
; 822  :         R5 = rfk->SaveArea;

  00a67	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00a6c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a6f	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 823  :         set_reg(5,R5);

  00a73	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00a7a	83 c0 14	 add	 eax, 20
  00a7d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a85	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00a8b	8b d0		 mov	 edx, eax
  00a8d	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00a91	e8 00 00 00 00	 call	 s370_vstore4

; 824  : 
; 825  :         /* Convert to host platform native open flags */
; 826  :         i = 0;

  00a96	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 827  :         get_reg(R3,3);

  00a9e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00aa5	83 c0 0c	 add	 eax, 12
  00aa8	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00ab0	ba fe ff ff ff	 mov	 edx, -2
  00ab5	8b c8		 mov	 ecx, eax
  00ab7	e8 00 00 00 00	 call	 s370_vfetch4
  00abc	89 44 24 58	 mov	 DWORD PTR R3$[rsp], eax

; 828  :         if (R3 & 0x01)

  00ac0	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00ac4	83 e0 01	 and	 eax, 1
  00ac7	85 c0		 test	 eax, eax
  00ac9	74 0b		 je	 SHORT $LN63@s370_hdiag

; 829  :             i |= _O_WRONLY;

  00acb	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00acf	83 c8 01	 or	 eax, 1
  00ad2	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN63@s370_hdiag:

; 830  :         if (R3 & 0x02)

  00ad6	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00ada	83 e0 02	 and	 eax, 2
  00add	85 c0		 test	 eax, eax
  00adf	74 0b		 je	 SHORT $LN64@s370_hdiag

; 831  :             i |= _O_RDWR;

  00ae1	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ae5	83 c8 02	 or	 eax, 2
  00ae8	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN64@s370_hdiag:

; 832  :         if ((R3 & 0x03) == 0)

  00aec	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00af0	83 e0 03	 and	 eax, 3
  00af3	85 c0		 test	 eax, eax
  00af5	75 08		 jne	 SHORT $LN65@s370_hdiag

; 833  :             i |= _O_RDONLY;

  00af7	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00afb	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN65@s370_hdiag:

; 834  :         if (R3 & 0x04)

  00aff	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b03	83 e0 04	 and	 eax, 4
  00b06	85 c0		 test	 eax, eax
  00b08	74 1a		 je	 SHORT $LN66@s370_hdiag

; 835  :         {
; 836  :             rfk->mode = 1; /* Record the desire to translate codepages */

  00b0a	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b0f	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 837  : #ifdef _MSVC_
; 838  :             i |= _O_TEXT; /* Windows can translate newlines to CRLF pairs */

  00b16	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b1a	0f ba e8 0e	 bts	 eax, 14
  00b1e	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 839  : #endif
; 840  :         }

  00b22	eb 0c		 jmp	 SHORT $LN67@s370_hdiag
$LN66@s370_hdiag:

; 841  :         else
; 842  :         {
; 843  :             rfk->mode = 0; /* Binary mode (untranslated) */

  00b24	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00b29	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN67@s370_hdiag:

; 844  :         }
; 845  :         if (R3 & 0x10)

  00b30	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b34	83 e0 10	 and	 eax, 16
  00b37	85 c0		 test	 eax, eax
  00b39	74 0b		 je	 SHORT $LN68@s370_hdiag

; 846  :             i |= _O_APPEND;

  00b3b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b3f	83 c8 08	 or	 eax, 8
  00b42	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN68@s370_hdiag:

; 847  :         if (R3 & 0x20)

  00b46	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b4a	83 e0 20	 and	 eax, 32			; 00000020H
  00b4d	85 c0		 test	 eax, eax
  00b4f	74 0c		 je	 SHORT $LN69@s370_hdiag

; 848  :             i |= _O_TRUNC;

  00b51	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b55	0f ba e8 09	 bts	 eax, 9
  00b59	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN69@s370_hdiag:

; 849  :         if (R3 & 0x40)

  00b5d	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00b61	83 e0 40	 and	 eax, 64			; 00000040H
  00b64	85 c0		 test	 eax, eax
  00b66	74 60		 je	 SHORT $LN70@s370_hdiag

; 850  :         {
; 851  :             i |= _O_CREAT;

  00b68	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00b6c	0f ba e8 08	 bts	 eax, 8
  00b70	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 852  : #ifdef _MSVC_
; 853  :             get_reg(R4,4);

  00b74	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00b7b	83 c0 10	 add	 eax, 16
  00b7e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00b86	ba fe ff ff ff	 mov	 edx, -2
  00b8b	8b c8		 mov	 ecx, eax
  00b8d	e8 00 00 00 00	 call	 s370_vfetch4
  00b92	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 854  :             if (R4 == 0) /* Pass 0x100 in Windows for readonly */

  00b96	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00b9b	75 2b		 jne	 SHORT $LN71@s370_hdiag

; 855  :             {
; 856  :                 /* Set a Windows default */
; 857  :                 R4 = _S_IWRITE;

  00b9d	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR R4$[rsp], 128	; 00000080H

; 858  :                 set_reg(4,R4);

  00ba5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00bac	83 c0 10	 add	 eax, 16
  00baf	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00bb7	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00bbd	8b d0		 mov	 edx, eax
  00bbf	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00bc3	e8 00 00 00 00	 call	 s370_vstore4
$LN71@s370_hdiag:
$LN70@s370_hdiag:

; 859  :             }
; 860  : #endif
; 861  :         }
; 862  :         if (R3 & 0x80)

  00bc8	8b 44 24 58	 mov	 eax, DWORD PTR R3$[rsp]
  00bcc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00bd1	85 c0		 test	 eax, eax
  00bd3	74 0c		 je	 SHORT $LN72@s370_hdiag

; 863  :         {
; 864  :             i |= _O_EXCL;

  00bd5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00bd9	0f ba e8 0a	 bts	 eax, 10
  00bdd	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN72@s370_hdiag:

; 865  :         }
; 866  : #ifndef _MSVC_
; 867  :         get_reg(R4,4);
; 868  :         if (R4 == 0)
; 869  :         {   /* Set a *nix default */
; 870  :             R4 = 0666;  /* Note octal value */
; 871  :             set_reg(4,R4);
; 872  :         }
; 873  : #endif
; 874  : #ifdef DYN76_DEBUG
; 875  :         logmsg("DF18: CFILE - _open('%s', 0x%X, 0%o)\n", rfk->filename, i, R4);
; 876  : #endif
; 877  :         res = _open (rfk->filename, i, (mode_t)R4);

  00be1	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00be6	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00bec	44 8b 44 24 44	 mov	 r8d, DWORD PTR R4$[rsp]
  00bf1	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00bf5	48 8b c8	 mov	 rcx, rax
  00bf8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00bfe	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 878  : #ifdef DYN76_DEBUG
; 879  :         logmsg("DF18: CFILE - _open result: %d\n", res);
; 880  : #endif
; 881  :         if (res != -1)

  00c02	83 7c 24 40 ff	 cmp	 DWORD PTR res$[rsp], -1
  00c07	0f 84 a4 00 00
	00		 je	 $LN73@s370_hdiag

; 882  :         {   /* Successful host file open */
; 883  : 
; 884  :             /* Save the handle for use in other operations */
; 885  :             rfk->handle = res;  /* Save the host handle */

  00c0d	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c12	8b 4c 24 40	 mov	 ecx, DWORD PTR res$[rsp]
  00c16	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 886  : 
; 887  :             /* Transfer the restart fkeeper to the open file fkeeper list */
; 888  : #ifdef DYN76_DEBUG_FKEEPER
; 889  :             logmsg("DF18: CFILE - removing  w/o freeing fkeeper from restart list rst_head\n");
; 890  : #endif
; 891  :             RemoveFKByID (rfk->id, &rst_head, NO_FREE);

  00c19	45 33 c0	 xor	 r8d, r8d
  00c1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  00c23	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c28	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00c2b	e8 00 00 00 00	 call	 RemoveFKByID

; 892  :             dolock(nfile_lock);

  00c30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00c37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 893  : #ifdef DYN76_DEBUG_FKEEPER
; 894  :             logmsg("DF18: CFILE - adding fkeeper to open file list with fkpr_head\n");
; 895  : #endif
; 896  :             AddFKByID(nfile_id++, rfk, &fkpr_head);

  00c3d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00c43	89 44 24 74	 mov	 DWORD PTR tv484[rsp], eax
  00c47	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nfile_id
  00c4d	ff c0		 inc	 eax
  00c4f	89 05 00 00 00
	00		 mov	 DWORD PTR nfile_id, eax
  00c55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:fkpr_head
  00c5c	48 8b 54 24 38	 mov	 rdx, QWORD PTR rfk$[rsp]
  00c61	8b 4c 24 74	 mov	 ecx, DWORD PTR tv484[rsp]
  00c65	e8 00 00 00 00	 call	 AddFKByID

; 897  : #ifdef DYN76_DEBUG
; 898  :             logmsg("DF18: CFILE - opened guest file descriptor %d, host handle: %d\n",
; 899  :                     rfk->id, rfk->handle);
; 900  : #endif
; 901  :             unlock(nfile_lock);

  00c6a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00c71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 902  : 
; 903  :             R15 = rfk->id;

  00c77	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00c7c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00c7f	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 904  :             set_reg(15,R15);

  00c83	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00c8a	83 c0 3c	 add	 eax, 60			; 0000003cH
  00c8d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00c95	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00c9b	8b d0		 mov	 edx, eax
  00c9d	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00ca1	e8 00 00 00 00	 call	 s370_vstore4

; 905  :             rfk = NULL;

  00ca6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR rfk$[rsp], 0

; 906  :             /* Note: during the start of the interruptable open operation the
; 907  :                fkeeper structure was linked to the fkeeper list to allow restart
; 908  :                of the operation from the restart id.  Now that we have been
; 909  :                successful in opening the file, we will leave the restart fkeeper
; 910  :                on the list as the link to the host file from the guest.
; 911  :             */
; 912  :         }

  00caf	eb 38		 jmp	 SHORT $LN74@s370_hdiag
$LN73@s370_hdiag:

; 913  :         else
; 914  :         {   /* Failed host file open */
; 915  : 
; 916  :             res = errno;

  00cb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00cb7	8b 00		 mov	 eax, DWORD PTR [rax]
  00cb9	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 917  : #ifdef DYN76_DEBUG
; 918  :             logmsg("DF18: CFILE - _open errno: %X\n", res);
; 919  : #endif
; 920  :             R15 = -1 * res;

  00cbd	6b 44 24 40 ff	 imul	 eax, DWORD PTR res$[rsp], -1
  00cc2	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 921  :             set_reg(15,R15);

  00cc6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ccd	83 c0 3c	 add	 eax, 60			; 0000003cH
  00cd0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00cd8	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00cde	8b d0		 mov	 edx, eax
  00ce0	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00ce4	e8 00 00 00 00	 call	 s370_vstore4
$LN74@s370_hdiag:

; 922  :             /* Note: during start of the interruptable open operation the
; 923  :                fkeeper structure was linked to the fkeeper list to allow restart
; 924  :                of the operation from the restart id.  On a failure to actually open
; 925  :                the file, the structure needs to be removed from the list and that
; 926  :                will happen below just before returning to hdiagf18.c
; 927  :             */
; 928  :         }
; 929  :     } else

  00ce9	e9 82 04 00 00	 jmp	 $LN62@s370_hdiag
$LN61@s370_hdiag:

; 930  : 
; 931  :     /*-----------------------------*/
; 932  :     /* ORPHAN CLOSE File Operation */
; 933  :     /*-----------------------------*/
; 934  : 
; 935  :     if (R1 == 3)

  00cee	83 7c 24 4c 03	 cmp	 DWORD PTR R1$[rsp], 3
  00cf3	75 6e		 jne	 SHORT $LN75@s370_hdiag

; 936  :     {
; 937  : #ifdef DYN76_DEBUG
; 938  :         logmsg("DF18: CFILE - orphan close: '%s'\n", rfk->filename);
; 939  : #endif
; 940  :         /* This is safe to restore early here */
; 941  :         R5 = rfk->SaveArea;

  00cf5	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00cfa	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00cfd	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 942  :         set_reg(5,R5);

  00d01	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d08	83 c0 14	 add	 eax, 20
  00d0b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d13	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d19	8b d0		 mov	 edx, eax
  00d1b	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00d1f	e8 00 00 00 00	 call	 s370_vstore4

; 943  : 
; 944  :         R15 = RemoveFKByName (rfk->filename);

  00d24	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00d29	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00d2f	48 8b c8	 mov	 rcx, rax
  00d32	e8 00 00 00 00	 call	 RemoveFKByName
  00d37	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 945  :         set_reg(15,R15);

  00d3b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d42	83 c0 3c	 add	 eax, 60			; 0000003cH
  00d45	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00d4d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00d53	8b d0		 mov	 edx, eax
  00d55	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00d59	e8 00 00 00 00	 call	 s370_vstore4

; 946  :     } else

  00d5e	e9 0d 04 00 00	 jmp	 $LN76@s370_hdiag
$LN75@s370_hdiag:

; 947  : 
; 948  :     /*-----------------------------*/
; 949  :     /* READ File Operation         */
; 950  :     /*-----------------------------*/
; 951  : 
; 952  :     if (R1 == 4)

  00d63	83 7c 24 4c 04	 cmp	 DWORD PTR R1$[rsp], 4
  00d68	0f 85 1b 02 00
	00		 jne	 $LN77@s370_hdiag

; 953  :     {
; 954  : #ifdef DYN76_DEBUG
; 955  :         logmsg("DF18: CFILE - read\n");
; 956  : #endif
; 957  :         get_reg(R4,4);

  00d6e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00d75	83 c0 10	 add	 eax, 16
  00d78	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00d80	ba fe ff ff ff	 mov	 edx, -2
  00d85	8b c8		 mov	 ecx, eax
  00d87	e8 00 00 00 00	 call	 s370_vfetch4
  00d8c	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN6@s370_hdiag:

; 958  :         /* Note: R15 has been set to zero above during operation initialization */
; 959  : #ifdef DYN76_DEBUG
; 960  :         logmsg("DF18: CFILE - read requested bytes: %d\n", R4);
; 961  : #endif
; 962  :         while (R4 != 0)

  00d90	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00d95	0f 84 ba 01 00
	00		 je	 $LN7@s370_hdiag

; 963  :         {
; 964  :             if (rfk->data == 0)

  00d9b	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00da0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00da4	75 6d		 jne	 SHORT $LN79@s370_hdiag

; 965  :             { /* Need to fill our buffer with some data? */
; 966  :                 i = R4;

  00da6	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  00daa	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 967  : 
; 968  :                 if (i > 256)

  00dae	81 7c 24 34 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  00db6	7e 08		 jle	 SHORT $LN80@s370_hdiag

; 969  :                     i = 256;

  00db8	c7 44 24 34 00
	01 00 00	 mov	 DWORD PTR i$[rsp], 256	; 00000100H
$LN80@s370_hdiag:

; 970  : 
; 971  :                 rfk->data = _read (handle, rfk->filename, i);

  00dc0	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00dc5	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00dcb	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  00dd0	48 8b d0	 mov	 rdx, rax
  00dd3	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  00dd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read
  00ddd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00de2	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 972  : #ifdef DYN76_DEBUG
; 973  :                 logmsg("DF18: CFILE - host read result: %d\n", rfk->data);
; 974  : #endif
; 975  :                 if (fk->mode)

  00de5	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  00dea	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00dee	74 23		 je	 SHORT $LN81@s370_hdiag

; 976  :                     MemConverter (rfk->filename, DCCascii_to_ebcdic, rfk->data);

  00df0	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00df5	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00dfb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00e00	44 8b 41 18	 mov	 r8d, DWORD PTR [rcx+24]
  00e04	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCascii_to_ebcdic
  00e0b	48 8b c8	 mov	 rcx, rax
  00e0e	e8 00 00 00 00	 call	 MemConverter
$LN81@s370_hdiag:
$LN79@s370_hdiag:

; 977  :             }
; 978  :             if (rfk->data < 0)

  00e13	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e18	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e1c	7d 31		 jge	 SHORT $LN82@s370_hdiag

; 979  :             {
; 980  :                 R15 = -errno;

  00e1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e24	8b 00		 mov	 eax, DWORD PTR [rax]
  00e26	f7 d8		 neg	 eax
  00e28	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 981  :                 set_reg(15,R15);

  00e2c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00e33	83 c0 3c	 add	 eax, 60			; 0000003cH
  00e36	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00e3e	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00e44	8b d0		 mov	 edx, eax
  00e46	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00e4a	e8 00 00 00 00	 call	 s370_vstore4
$LN82@s370_hdiag:

; 982  :             }
; 983  :             if (rfk->data <= 0)

  00e4f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e54	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e58	7f 05		 jg	 SHORT $LN83@s370_hdiag

; 984  :             {   /* All done, we reached EOF (or an error occured) */
; 985  :                 break;

  00e5a	e9 f6 00 00 00	 jmp	 $LN7@s370_hdiag
$LN83@s370_hdiag:

; 986  :             }
; 987  : 
; 988  :             /* Move the data read to the guest's storage */
; 989  :             i = rfk->data - 1;

  00e5f	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00e64	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e67	ff c8		 dec	 eax
  00e69	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 990  :             /* wstorec was designed to operate with storage-to-storage instructions.
; 991  :                The instruction length field is always one less than the number of
; 992  :                bytes involved in the instruction.  Hence the number of bytes to be
; 993  :                moved to storage is decremented by 1 to conform with this behavior. */
; 994  : 
; 995  :             /* WARNING: This is where an interruption might occur.  An exception
; 996  :                will "nullify" the storing operation.
; 997  :                On restart, the read above will be bypassed and the entire sequence
; 998  :                of bytes, upto 256, will be restored */
; 999  :             ARCH_DEP(wstorec)

  00e6d	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00e71	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00e76	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00e7b	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  00e82	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e8a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00e8f	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  00e94	44 8b c0	 mov	 r8d, eax
  00e97	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  00e9c	e8 00 00 00 00	 call	 s370_vstorec

; 1000 :                 (rfk->filename,  /* This member is used as a buffer */
; 1001 :                  (unsigned char)i,
; 1002 :                  R2,
; 1003 :                  space_ctl,
; 1004 :                  regs);
; 1005 :             i++;

  00ea1	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ea5	ff c0		 inc	 eax
  00ea7	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1006 : 
; 1007 :             /* Exception, can recalculate if/when restart */
; 1008 :             R2 += i;

  00eab	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00eaf	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00eb3	03 c8		 add	 ecx, eax
  00eb5	8b c1		 mov	 eax, ecx
  00eb7	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1009 :             set_reg(2,R2);

  00ebb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ec2	83 c0 08	 add	 eax, 8
  00ec5	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00ecd	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00ed3	8b d0		 mov	 edx, eax
  00ed5	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  00ed9	e8 00 00 00 00	 call	 s370_vstore4

; 1010 : 
; 1011 :             /* Remember to stop when enough is read */
; 1012 :             R4 -= i;

  00ede	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00ee2	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00ee6	2b c8		 sub	 ecx, eax
  00ee8	8b c1		 mov	 eax, ecx
  00eea	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1013 :             set_reg(4,R4);

  00eee	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00ef5	83 c0 10	 add	 eax, 16
  00ef8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f00	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f06	8b d0		 mov	 edx, eax
  00f08	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  00f0c	e8 00 00 00 00	 call	 s370_vstore4

; 1014 : 
; 1015 :             /* Return accumulated total */
; 1016 :             R15 += i;

  00f11	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00f15	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00f19	03 c8		 add	 ecx, eax
  00f1b	8b c1		 mov	 eax, ecx
  00f1d	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1017 :             set_reg(15,R15);

  00f21	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f28	83 c0 3c	 add	 eax, 60			; 0000003cH
  00f2b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f33	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f39	8b d0		 mov	 edx, eax
  00f3b	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  00f3f	e8 00 00 00 00	 call	 s370_vstore4

; 1018 : 
; 1019 :             rfk->data = 0;

  00f44	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00f49	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1020 :         }

  00f50	e9 3b fe ff ff	 jmp	 $LN6@s370_hdiag
$LN7@s370_hdiag:

; 1021 :         R5 = rfk->SaveArea;

  00f55	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  00f5a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00f5d	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1022 :         set_reg(5,R5);

  00f61	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f68	83 c0 14	 add	 eax, 20
  00f6b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00f73	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00f79	8b d0		 mov	 edx, eax
  00f7b	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  00f7f	e8 00 00 00 00	 call	 s370_vstore4

; 1023 :     } else

  00f84	e9 e7 01 00 00	 jmp	 $LN78@s370_hdiag
$LN77@s370_hdiag:

; 1024 : 
; 1025 :     /*-----------------------------*/
; 1026 :     /* WRITE File Operation        */
; 1027 :     /*-----------------------------*/
; 1028 : 
; 1029 :     if (R1 == 5)

  00f89	83 7c 24 4c 05	 cmp	 DWORD PTR R1$[rsp], 5
  00f8e	0f 85 dc 01 00
	00		 jne	 $LN84@s370_hdiag

; 1030 :     {
; 1031 : #ifdef DYN76_DEBUG
; 1032 :         logmsg("DF18: CFILE - write\n");
; 1033 : #endif
; 1034 :         get_reg(R4,4);

  00f94	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  00f9b	83 c0 10	 add	 eax, 16
  00f9e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00fa6	ba fe ff ff ff	 mov	 edx, -2
  00fab	8b c8		 mov	 ecx, eax
  00fad	e8 00 00 00 00	 call	 s370_vfetch4
  00fb2	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax
$LN8@s370_hdiag:

; 1035 :         /* Note: R15 has been set to zero above during operation initialization */
; 1036 : 
; 1037 :         while (R4 != 0)

  00fb6	83 7c 24 44 00	 cmp	 DWORD PTR R4$[rsp], 0
  00fbb	0f 84 80 01 00
	00		 je	 $LN9@s370_hdiag

; 1038 :         {
; 1039 :             i = R4 - 1;

  00fc1	8b 44 24 44	 mov	 eax, DWORD PTR R4$[rsp]
  00fc5	ff c8		 dec	 eax
  00fc7	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1040 :             /* wfetchc was designed to operate with storage-to-storage instructions.
; 1041 :                The instruction length field is always one less than the number of
; 1042 :                bytes involved in the instruction.  Hence the number of bytes to be
; 1043 :                retrieved from storage  is decremented by 1 to conform with this
; 1044 :                behavior. */
; 1045 : 
; 1046 :             /* Move guest's write data to the internal buffer */
; 1047 :             if (i > 255)

  00fcb	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR i$[rsp], 255	; 000000ffH
  00fd3	7e 08		 jle	 SHORT $LN85@s370_hdiag

; 1048 :             {
; 1049 :                 i = 255;

  00fd5	c7 44 24 34 ff
	00 00 00	 mov	 DWORD PTR i$[rsp], 255	; 000000ffH
$LN85@s370_hdiag:

; 1050 :             }
; 1051 : 
; 1052 :             /* WARNING: This is where interruption might occur.  The exception
; 1053 :                "nullifies" the fetch operation.
; 1054 :                On restart, the entire sequence of up to 256 bytes will be refetched
; 1055 :                from storage */
; 1056 :             ARCH_DEP(wfetchc)

  00fdd	8b 44 24 50	 mov	 eax, DWORD PTR R2$[rsp]
  00fe1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00fe6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rfk$[rsp]
  00feb	48 81 c1 20 01
	00 00		 add	 rcx, 288		; 00000120H
  00ff2	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ffa	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00fff	44 8b 4c 24 60	 mov	 r9d, DWORD PTR space_ctl$[rsp]
  01004	44 8b c0	 mov	 r8d, eax
  01007	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  0100c	e8 00 00 00 00	 call	 s370_vfetchc

; 1057 :                 (rfk->filename,
; 1058 :                  (unsigned char)i,
; 1059 :                  R2,
; 1060 :                  space_ctl,
; 1061 :                  regs);
; 1062 :             i++;  /* Fix up number of bytes stored to actual count */

  01011	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  01015	ff c0		 inc	 eax
  01017	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 1063 : 
; 1064 :             if (fk->mode)

  0101b	48 8b 44 24 68	 mov	 rax, QWORD PTR fk$[rsp]
  01020	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  01024	74 1f		 je	 SHORT $LN86@s370_hdiag

; 1065 :                 MemConverter (rfk->filename, DCCebcdic_to_ascii, i);

  01026	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0102b	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  01031	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  01036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DCCebcdic_to_ascii
  0103d	48 8b c8	 mov	 rcx, rax
  01040	e8 00 00 00 00	 call	 MemConverter
$LN86@s370_hdiag:

; 1066 :                 /* rfk->filename is being used as a data buffer here */
; 1067 : 
; 1068 :             /* Write to the host file from the internal buffer */
; 1069 : #ifdef DYN76_DEBUG
; 1070 :             logmsg("DF18: CFILE - _write(%d, rfk->filename, %d)\n", handle, i);
; 1071 : #endif
; 1072 :             res = _write (handle, rfk->filename, (size_t)i);

  01045	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0104a	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  01050	44 8b 44 24 34	 mov	 r8d, DWORD PTR i$[rsp]
  01055	48 8b d0	 mov	 rdx, rax
  01058	8b 4c 24 5c	 mov	 ecx, DWORD PTR handle$[rsp]
  0105c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  01062	89 44 24 40	 mov	 DWORD PTR res$[rsp], eax

; 1073 : #ifdef DYN76_DEBUG
; 1074 :             logmsg("DF18: CFILE - _write result: %d\n", res);
; 1075 : #endif
; 1076 :             if (res < 0)

  01066	83 7c 24 40 00	 cmp	 DWORD PTR res$[rsp], 0
  0106b	7d 36		 jge	 SHORT $LN87@s370_hdiag

; 1077 :             {
; 1078 : #ifdef DYN76_DEBUG
; 1079 :                 io_error = errno;
; 1080 :                 logmsg("DF18: CFILE - write errno: %d\n", io_error);
; 1081 : #endif
; 1082 :                 R15 = -errno;

  0106d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01073	8b 00		 mov	 eax, DWORD PTR [rax]
  01075	f7 d8		 neg	 eax
  01077	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1083 :                 set_reg(15,R15);

  0107b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01082	83 c0 3c	 add	 eax, 60			; 0000003cH
  01085	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0108d	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01093	8b d0		 mov	 edx, eax
  01095	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  01099	e8 00 00 00 00	 call	 s370_vstore4

; 1084 :                 break;

  0109e	e9 9e 00 00 00	 jmp	 $LN9@s370_hdiag
$LN87@s370_hdiag:

; 1085 :             }
; 1086 : 
; 1087 :             /* Not an error, so 'res' is the number of bytes actually written */
; 1088 :             /* Update the address pointer and remaining bytes to write */
; 1089 :             R2 += res;

  010a3	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  010a7	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  010ab	03 c8		 add	 ecx, eax
  010ad	8b c1		 mov	 eax, ecx
  010af	89 44 24 50	 mov	 DWORD PTR R2$[rsp], eax

; 1090 :             set_reg(2,R2);

  010b3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  010ba	83 c0 08	 add	 eax, 8
  010bd	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  010c5	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  010cb	8b d0		 mov	 edx, eax
  010cd	8b 4c 24 50	 mov	 ecx, DWORD PTR R2$[rsp]
  010d1	e8 00 00 00 00	 call	 s370_vstore4

; 1091 :             R4 -= res;

  010d6	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  010da	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  010de	2b c8		 sub	 ecx, eax
  010e0	8b c1		 mov	 eax, ecx
  010e2	89 44 24 44	 mov	 DWORD PTR R4$[rsp], eax

; 1092 :             set_reg(4,R4);

  010e6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  010ed	83 c0 10	 add	 eax, 16
  010f0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  010f8	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  010fe	8b d0		 mov	 edx, eax
  01100	8b 4c 24 44	 mov	 ecx, DWORD PTR R4$[rsp]
  01104	e8 00 00 00 00	 call	 s370_vstore4

; 1093 :             /* update the accumlated total */
; 1094 :             R15 += res;

  01109	8b 44 24 40	 mov	 eax, DWORD PTR res$[rsp]
  0110d	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  01111	03 c8		 add	 ecx, eax
  01113	8b c1		 mov	 eax, ecx
  01115	89 44 24 30	 mov	 DWORD PTR R15$[rsp], eax

; 1095 :             set_reg(15,R15);

  01119	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01120	83 c0 3c	 add	 eax, 60			; 0000003cH
  01123	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0112b	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01131	8b d0		 mov	 edx, eax
  01133	8b 4c 24 30	 mov	 ecx, DWORD PTR R15$[rsp]
  01137	e8 00 00 00 00	 call	 s370_vstore4

; 1096 :         }

  0113c	e9 75 fe ff ff	 jmp	 $LN8@s370_hdiag
$LN9@s370_hdiag:

; 1097 :         R5 = rfk->SaveArea;

  01141	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  01146	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01149	89 44 24 48	 mov	 DWORD PTR R5$[rsp], eax

; 1098 :         set_reg(5,R5);

  0114d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cmpb$[rsp]
  01154	83 c0 14	 add	 eax, 20
  01157	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0115f	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  01165	8b d0		 mov	 edx, eax
  01167	8b 4c 24 48	 mov	 ecx, DWORD PTR R5$[rsp]
  0116b	e8 00 00 00 00	 call	 s370_vstore4
$LN84@s370_hdiag:
$LN78@s370_hdiag:
$LN76@s370_hdiag:
$LN62@s370_hdiag:
$LN58@s370_hdiag:
$LN54@s370_hdiag:

; 1099 :     }
; 1100 : 
; 1101 :     if (rfk) /* clean up, unless open already has */

  01170	48 83 7c 24 38
	00		 cmp	 QWORD PTR rfk$[rsp], 0
  01176	74 1a		 je	 SHORT $LN88@s370_hdiag

; 1102 :     {
; 1103 : #ifdef DYN76_DEBUG_FKEEPER
; 1104 :         logmsg("DF18: CFILE - removing and freeing restart fkeeper in rst_head list\n");
; 1105 : #endif
; 1106 :         /* Safely remove from the restart state */
; 1107 :         RemoveFKByID (rfk->id, &rst_head, DO_FREE);

  01178	41 b8 01 00 00
	00		 mov	 r8d, 1
  0117e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rst_head
  01185	48 8b 44 24 38	 mov	 rax, QWORD PTR rfk$[rsp]
  0118a	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0118d	e8 00 00 00 00	 call	 RemoveFKByID
$LN88@s370_hdiag:

; 1108 :     }
; 1109 : 
; 1110 :     /* Make sure we do not restart this operation */
; 1111 :     R0 = 0;

  01192	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR R0$[rsp], 0

; 1112 :     set_reg(0,R0);

  0119a	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  011a2	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  011a8	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cmpb$[rsp]
  011af	8b 4c 24 54	 mov	 ecx, DWORD PTR R0$[rsp]
  011b3	e8 00 00 00 00	 call	 s370_vstore4
$LN1@s370_hdiag:

; 1113 : }

  011b8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  011bf	c3		 ret	 0
s370_hdiagf18_FC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
i$ = 32
fk$ = 40
pfk$ = 48
filename$ = 80
RemoveFKByName PROC

; 269  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 270  :     int i = -1 * EBADF;

  00009	c7 44 24 20 f7
	ff ff ff	 mov	 DWORD PTR i$[rsp], -9

; 271  :     struct fkeeper *pfk;
; 272  :     struct fkeeper *fk;
; 273  : 
; 274  :     dolock (nfile_lock); /* Take ownership of the list */

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 275  :     pfk = NULL;

  0001e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pfk$[rsp], 0

; 276  :     fk = fkpr_head; /* Search the list */

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR fkpr_head
  0002e	48 89 44 24 28	 mov	 QWORD PTR fk$[rsp], rax
$LN2@RemoveFKBy:

; 277  :     while (fk)

  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR fk$[rsp], 0
  00039	0f 84 9e 00 00
	00		 je	 $LN3@RemoveFKBy

; 278  :     {
; 279  :         if (strcmp (fk->filename, filename) == 0)

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR fk$[rsp]
  00044	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  0004a	48 8b 54 24 50	 mov	 rdx, QWORD PTR filename$[rsp]
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 strcmp
  00057	85 c0		 test	 eax, eax
  00059	75 66		 jne	 SHORT $LN4@RemoveFKBy

; 280  :         {   /* Found the entry! */
; 281  : #ifdef DYN76_DEBUG
; 282  :         logmsg("DF18: CFILE - orphan _close(%d)\n", fk->handle);
; 283  : #endif
; 284  :             i = _close (fk->handle); /* Additional step here is to close the file too */

  0005b	48 8b 44 24 28	 mov	 rax, QWORD PTR fk$[rsp]
  00060	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  00069	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 285  : #ifdef DYN76_DEBUG
; 286  :             logmsg("DF18: CFILE - orphan _close result: %d\n", i);
; 287  : #endif
; 288  :             if (i == -1)

  0006d	83 7c 24 20 ff	 cmp	 DWORD PTR i$[rsp], -1
  00072	75 17		 jne	 SHORT $LN5@RemoveFKBy

; 289  :             {
; 290  :                 i = errno;

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007a	8b 00		 mov	 eax, DWORD PTR [rax]
  0007c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 291  : #ifdef DYN76_DEBUG
; 292  :             logmsg("DF18: CFILE - orphan _close errno: %d\n", i);
; 293  : #endif
; 294  :                 i = -1 * i;

  00080	6b 44 24 20 ff	 imul	 eax, DWORD PTR i$[rsp], -1
  00085	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 295  :             }

  00089	eb 34		 jmp	 SHORT $LN6@RemoveFKBy
$LN5@RemoveFKBy:

; 296  :             else
; 297  :             {
; 298  :                 if (pfk) /* Wasn't the head entry */

  0008b	48 83 7c 24 30
	00		 cmp	 QWORD PTR pfk$[rsp], 0
  00091	74 12		 je	 SHORT $LN7@RemoveFKBy

; 299  :                 {
; 300  :                     pfk->next = fk->next;

  00093	48 8b 44 24 30	 mov	 rax, QWORD PTR pfk$[rsp]
  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fk$[rsp]
  0009d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 301  :                 }

  000a3	eb 0f		 jmp	 SHORT $LN8@RemoveFKBy
$LN7@RemoveFKBy:

; 302  :                 else     /* Was the head entry */
; 303  :                 {
; 304  :                     fkpr_head = fk->next;

  000a5	48 8b 44 24 28	 mov	 rax, QWORD PTR fk$[rsp]
  000aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ad	48 89 05 00 00
	00 00		 mov	 QWORD PTR fkpr_head, rax
$LN8@RemoveFKBy:

; 305  :                 }
; 306  :                 free (fk);

  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fk$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@RemoveFKBy:

; 307  :             }
; 308  :             break;

  000bf	eb 1c		 jmp	 SHORT $LN3@RemoveFKBy
$LN4@RemoveFKBy:

; 309  :         }
; 310  :         pfk = fk;

  000c1	48 8b 44 24 28	 mov	 rax, QWORD PTR fk$[rsp]
  000c6	48 89 44 24 30	 mov	 QWORD PTR pfk$[rsp], rax

; 311  :         fk = fk->next;

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR fk$[rsp]
  000d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d3	48 89 44 24 28	 mov	 QWORD PTR fk$[rsp], rax

; 312  :     }

  000d8	e9 56 ff ff ff	 jmp	 $LN2@RemoveFKBy
$LN3@RemoveFKBy:

; 313  :     unlock (nfile_lock); /* Release ownership of the list */

  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 314  :     return (i);

  000ea	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]

; 315  : }

  000ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f2	c3		 ret	 0
RemoveFKByName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
fk$ = 32
pfk$ = 40
id$ = 64
list$ = 72
free_entry$ = 80
RemoveFKByID PROC

; 229  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 230  :     struct fkeeper *pfk;
; 231  :     struct fkeeper *fk;
; 232  : #ifdef DYN76_DEBUG_FKEEPER
; 233  :     logmsg("DF18: RemoveFKByID id %d from list head at=%X\n", id, list);
; 234  : #endif
; 235  :     dolock (nfile_lock); /* Take ownership of the list */

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 236  :     pfk = NULL;

  0001f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pfk$[rsp], 0

; 237  :     fk = *list;

  00028	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 20	 mov	 QWORD PTR fk$[rsp], rax
$LN2@RemoveFKBy:

; 238  :     while (fk)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR fk$[rsp], 0
  0003b	74 65		 je	 SHORT $LN3@RemoveFKBy

; 239  :     {
; 240  : #ifdef DYN76_DEBUG_FKEEPER
; 241  :         logmsg("DF18: RemoveFKByID id=%d (0x%X) is at: %X\n", fk->id, fk->id, fk);
; 242  : #endif
; 243  :         if (fk->id == id)

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  00042	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  00046	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  00049	75 3e		 jne	 SHORT $LN4@RemoveFKBy

; 244  :         {   /* Found the entry */
; 245  :             if (pfk) /* Wasn't the head entry */

  0004b	48 83 7c 24 28
	00		 cmp	 QWORD PTR pfk$[rsp], 0
  00051	74 12		 je	 SHORT $LN5@RemoveFKBy

; 246  :             {
; 247  :                 pfk->next = fk->next;

  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR pfk$[rsp]
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fk$[rsp]
  0005d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00060	48 89 08	 mov	 QWORD PTR [rax], rcx

; 248  :             }

  00063	eb 10		 jmp	 SHORT $LN6@RemoveFKBy
$LN5@RemoveFKBy:

; 249  :             else     /* Was the head entry */
; 250  :             {
; 251  :                 *list = fk->next;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fk$[rsp]
  0006f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00072	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@RemoveFKBy:

; 252  :             }
; 253  :             if (free_entry)

  00075	83 7c 24 50 00	 cmp	 DWORD PTR free_entry$[rsp], 0
  0007a	74 0b		 je	 SHORT $LN7@RemoveFKBy

; 254  :             {
; 255  : #ifdef DYN76_DEBUG_FKEEPER
; 256  :                 logmsg("DF18: RemoveFKByID freeing id=%d at: %X\n", fk->id, fk);
; 257  : #endif
; 258  :                 free (fk);

  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fk$[rsp]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@RemoveFKBy:

; 259  :             }
; 260  :             break;

  00087	eb 19		 jmp	 SHORT $LN3@RemoveFKBy
$LN4@RemoveFKBy:

; 261  :         }
; 262  :         pfk = fk;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  0008e	48 89 44 24 28	 mov	 QWORD PTR pfk$[rsp], rax

; 263  :         fk = fk->next;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 89 44 24 20	 mov	 QWORD PTR fk$[rsp], rax

; 264  :     }

  000a0	eb 93		 jmp	 SHORT $LN2@RemoveFKBy
$LN3@RemoveFKBy:

; 265  :     unlock (nfile_lock); /* Release ownership of the list */

  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 266  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
RemoveFKByID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
fk$ = 32
id$ = 64
list$ = 72
FindFK	PROC

; 199  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 200  :     struct fkeeper *fk;
; 201  : #ifdef DYN76_DEBUG_FKEEPER
; 202  :     logmsg("DF18: FindFK id=%d in list head at=%X\n", id, list);
; 203  : #endif
; 204  :     dolock (nfile_lock); /* Take ownership of the list */

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 205  : 
; 206  :     fk = *list;          /* Search the list */

  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 20	 mov	 QWORD PTR fk$[rsp], rax
$LN2@FindFK:

; 207  : 
; 208  : #ifdef DYN76_DEBUG_FKEEPER
; 209  :     logmsg("DF18: FindFK list head points to first entry at %X\n", fk);
; 210  : #endif
; 211  :     while (fk)

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR fk$[rsp], 0
  0002d	74 31		 je	 SHORT $LN3@FindFK

; 212  :     {
; 213  : #ifdef DYN76_DEBUG_FKEEPER
; 214  :         logmsg("DF18: FindFK id=%d (0x%X) is at: %X\n", fk->id, fk->id, fk);
; 215  : #endif
; 216  :         if (fk->id == id)

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  00034	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  00038	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  0003b	75 14		 jne	 SHORT $LN4@FindFK

; 217  :         {   /* Found the entry */
; 218  :             unlock (nfile_lock);

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 219  :             return fk;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  0004f	eb 1e		 jmp	 SHORT $LN1@FindFK
$LN4@FindFK:

; 220  :         }
; 221  :         fk = fk->next;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR fk$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 89 44 24 20	 mov	 QWORD PTR fk$[rsp], rax

; 222  :     }

  0005e	eb c7		 jmp	 SHORT $LN2@FindFK
$LN3@FindFK:

; 223  :     unlock (nfile_lock); /* Release ownership of the list */

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 224  :     /* Reached the end of the list without finding the id */
; 225  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN1@FindFK:

; 226  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
FindFK	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
id$ = 8
item$ = 16
list$ = 24
AddFKByID PROC

; 187  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 188  :     /* struct fkeeper * head = list; */
; 189  :     item->id = id;

  0000e	48 8b 44 24 10	 mov	 rax, QWORD PTR item$[rsp]
  00013	8b 4c 24 08	 mov	 ecx, DWORD PTR id$[rsp]
  00017	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 190  :     item->next = *list;

  0001a	48 8b 44 24 10	 mov	 rax, QWORD PTR item$[rsp]
  0001f	48 8b 4c 24 18	 mov	 rcx, QWORD PTR list$[rsp]
  00024	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00027	48 89 08	 mov	 QWORD PTR [rax], rcx

; 191  :     *list = item;

  0002a	48 8b 44 24 18	 mov	 rax, QWORD PTR list$[rsp]
  0002f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR item$[rsp]
  00034	48 89 08	 mov	 QWORD PTR [rax], rcx

; 192  : #ifdef DYN76_DEBUG_FKEEPER
; 193  :     logmsg("DF18: AddFKByID added id=%d at %X with next item at %X to list head=%X at %X\n",
; 194  :            item->id, item, item->next, *list, list);
; 195  : #endif
; 196  : }

  00037	c3		 ret	 0
AddFKByID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
nfile_init PROC

; 154  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 155  :     initialize_lock(&nfile_lock);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nfile_lock
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 156  : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
nfile_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
i$ = 0
s$ = 32
cct$ = 40
len$ = 48
MemConverter PROC

; 120  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 121  :     int i = 0;

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN2@MemConvert:

; 122  :     while (i < len)

  0001a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0001e	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00021	7d 2d		 jge	 SHORT $LN3@MemConvert

; 123  :     {
; 124  :         s [i] = (signed char)cct [(unsigned char)s [i]];

  00023	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00030	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00034	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00039	4c 8b 44 24 28	 mov	 r8, QWORD PTR cct$[rsp]
  0003e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00043	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 125  :         i++;

  00046	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 126  :     }

  0004e	eb ca		 jmp	 SHORT $LN2@MemConvert
$LN3@MemConvert:

; 127  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
MemConverter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyn76.c
_TEXT	SEGMENT
i$ = 0
s$ = 32
cct$ = 40
StrConverter PROC

; 110  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 111  :     int i = 0;

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN2@StrConvert:

; 112  :     while (s [i])

  00015	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0001e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00022	85 c0		 test	 eax, eax
  00024	74 2d		 je	 SHORT $LN3@StrConvert

; 113  :     {
; 114  :         s [i] = (signed char)cct [(unsigned char)s [i]];

  00026	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00033	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00037	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0003c	4c 8b 44 24 28	 mov	 r8, QWORD PTR cct$[rsp]
  00041	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00046	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 115  :         i++;

  00049	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 116  :     }

  00051	eb c2		 jmp	 SHORT $LN2@StrConvert
$LN3@StrConvert:

; 117  : }

  00053	48 83 c4 18	 add	 rsp, 24
  00057	c3		 ret	 0
StrConverter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv92 = 56
tv136 = 60
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore4 PROC					; COMDAT

; 559  : {

$LN27:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN10@s370_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vstor
$LN10@s370_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN11@s370_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN14@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN15@s370_vstor
$LN14@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN15@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 14		 jne	 SHORT $LN7@s370_vstor
  00053	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0005c	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  00061	0f 87 9e 00 00
	00		 ja	 $LN5@s370_vstor
$LN7@s370_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00070	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00074	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00081	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_maddr_l
  00094	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00099	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  0009d	e8 00 00 00 00	 call	 _byteswap_ulong
  000a2	8b d0		 mov	 edx, eax
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a9	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@s370_vstor:

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );

  000ae	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b3	73 0a		 jae	 SHORT $LN18@s370_vstor
  000b5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000bd	eb 08		 jmp	 SHORT $LN19@s370_vstor
$LN18@s370_vstor:
  000bf	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN19@s370_vstor:
  000c7	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000cc	74 16		 je	 SHORT $LN20@s370_vstor
  000ce	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000d2	83 c0 03	 add	 eax, 3
  000d5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d8	72 0a		 jb	 SHORT $LN20@s370_vstor
  000da	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000e2	eb 08		 jmp	 SHORT $LN26@s370_vstor
$LN20@s370_vstor:
  000e4	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN26@s370_vstor:
  000ec	83 7c 24 3c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000f1	74 0a		 je	 SHORT $LN8@s370_vstor
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN8@s370_vstor:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 ab		 jne	 SHORT $LN4@s370_vstor

; 568  :     }

  00103	eb 17		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  00105	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0010a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00113	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  00117	e8 00 00 00 00	 call	 s370_vstore4_full
$LN6@s370_vstor:

; 571  : }

  0011c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00120	c3		 ret	 0
s370_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s370_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00021	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s370_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0009d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000a9	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ad	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000bd	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	e8 00 00 00 00	 call	 s370_maddr_l
  000cd	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	83 c8 06	 or	 eax, 6
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000e2	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000e4	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000f4	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  000f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000fe	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00103	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00108	48 8b f1	 mov	 rsi, rcx
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00119	48 98		 cdqe
  0011b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00120	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00125	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0012a	48 8b f1	 mov	 rsi, rcx
  0012d	48 8b c8	 mov	 rcx, rax
  00130	f3 a4		 rep movsb

; 350  : }

  00132	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
s370_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
END
