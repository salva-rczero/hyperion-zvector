; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159583 DB	'IGC0001I', 00H
	ORG $+7
$SG159584 DB	'IGC0002{', 00H
	ORG $+3
$SG159598 DB	'IFG019', 00H
	ORG $+5
$SG159585 DB	'IGC0002A', 00H
	ORG $+3
$SG159599 DB	'IGG019', 00H
	ORG $+5
$SG159586 DB	'IGC0002B', 00H
	ORG $+3
$SG159600 DB	'IFG020', 00H
	ORG $+5
$SG159587 DB	'IGC0002C', 00H
	ORG $+3
$SG159601 DB	'IGG020', 00H
	ORG $+5
$SG159588 DB	'IGC0002I', 00H
	ORG $+3
$SG159602 DB	'IGG021', 00H
	ORG $+5
$SG159589 DB	'IGC0003A', 00H
	ORG $+3
$SG159603 DB	'IFG023', 00H
	ORG $+5
$SG159590 DB	'IGC0003B', 00H
	ORG $+3
$SG159604 DB	'IGG023', 00H
	ORG $+5
$SG159591 DB	'IGC0005E', 00H
	ORG $+3
$SG159605 DB	'IGG029', 00H
	ORG $+5
$SG159592 DB	'IGC0008A', 00H
	ORG $+3
$SG159606 DB	'IGG032', 00H
	ORG $+5
$SG159593 DB	'IGC0008F', 00H
	ORG $+3
$SG159607 DB	'IFG055', 00H
	ORG $+5
$SG159594 DB	'IGC0009C', 00H
	ORG $+3
$SG159608 DB	'IGG055', 00H
	ORG $+5
$SG159595 DB	'IGC0009D', 00H
	ORG $+3
$SG159609 DB	'IGG081', 00H
	ORG $+1
$SG159610 DB	'IGG086', 00H
	ORG $+1
$SG159611 DB	'IGG093', 00H
	ORG $+1
$SG159612 DB	'IGG094', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_convert_to_ebcdic:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_read_block:PROC
EXTRN	__imp_convert_tt:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_build_extent_array:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG159923 DB	01H DUP (?)
$SG159931 DB	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$process_dirblk DD imagerel process_dirblk
	DD	imagerel process_dirblk+1872
	DD	imagerel $unwind$process_dirblk
$pdata$resolve_xctltab DD imagerel resolve_xctltab
	DD	imagerel resolve_xctltab+3853
	DD	imagerel $unwind$resolve_xctltab
$pdata$main DD	imagerel $LN30
	DD	imagerel $LN30+1262
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
	ORG $+13
firstload DQ	FLAT:$SG159583
	DQ	FLAT:$SG159584
	DQ	FLAT:$SG159585
	DQ	FLAT:$SG159586
	DQ	FLAT:$SG159587
	DQ	FLAT:$SG159588
	DQ	FLAT:$SG159589
	DQ	FLAT:$SG159590
	DQ	FLAT:$SG159591
	DQ	FLAT:$SG159592
	DQ	FLAT:$SG159593
	DQ	FLAT:$SG159594
	DQ	FLAT:$SG159595
	DQ	0000000000000000H
secondload DQ	FLAT:$SG159598
	DQ	FLAT:$SG159599
	DQ	FLAT:$SG159600
	DQ	FLAT:$SG159601
	DQ	FLAT:$SG159602
	DQ	FLAT:$SG159603
	DQ	FLAT:$SG159604
	DQ	FLAT:$SG159605
	DQ	FLAT:$SG159606
	DQ	FLAT:$SG159607
	DQ	FLAT:$SG159608
	DQ	FLAT:$SG159609
	DQ	FLAT:$SG159610
	DQ	FLAT:$SG159611
	DQ	FLAT:$SG159612
	DQ	0000000000000000H
$SG159683 DB	'IEHIOSUP', 00H
	ORG $+3
$SG159687 DB	'I', 00H
	ORG $+2
$SG159684 DB	'dasdisup', 00H
	ORG $+7
$SG159688 DB	'HHC02463%s Usage: %s [-option [-option ... ]] ckdfile [s'
	DB	'f=sfile]  [...]', 0aH, 'HHC02463I   ckdfile:      input dasd '
	DB	'image file', 0aH, 'HHC02463I   sfile:        optional dasd im'
	DB	'age shadow file', 0aH, 'HHC02463I options:', 0aH, 'HHC02463I '
	DB	'  -hdr          show column headers', 0aH, 'HHC02463I   -dsnl'
	DB	'[=n]     restrict dsname width', 0aH, 'HHC02463I   -info     '
	DB	'    show F1 info', 0aH, 'HHC02463I   -caldt        calendar d'
	DB	'ate format', 0aH, 'HHC02463I   -refdt        show last-refere'
	DB	'nce date', 0aH, 'HHC02463I   -expdt        show expiry date', 0aH
	DB	'HHC02463I   -yroffs[=n]   year offset', 0aH, 'HHC02463I Note:'
	DB	0aH, 'HHC02463I   Multiple images can be processed in the same'
	DB	' run,', 0aH, 'HHC02463I   but options must be specified ahead'
	DB	' of each image.', 0aH, 00H
	ORG $+1
$SG159689 DB	'main', 00H
	ORG $+3
$SG159695 DB	'E', 00H
	ORG $+2
$SG159690 DB	'dasdisup.c', 00H
	ORG $+1
$SG159708 DB	'I', 00H
	ORG $+2
$SG159694 DB	'calloc(%d,%d)', 00H
	ORG $+2
$SG159696 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159697 DB	'main', 00H
	ORG $+3
$SG159698 DB	'dasdisup.c', 00H
	ORG $+1
$SG159766 DB	'E', 00H
	ORG $+2
$SG159700 DB	'SYS1.SVCLIB', 00H
$SG159778 DB	'I', 00H
	ORG $+2
$SG159709 DB	'HHC02464%s End of directory, %d members selected', 0aH, 00H
	ORG $+2
$SG159710 DB	'main', 00H
	ORG $+3
$SG159776 DB	'alias', 00H
	ORG $+2
$SG159777 DB	'member', 00H
	ORG $+1
$SG159783 DB	'W', 00H
	ORG $+2
$SG159711 DB	'dasdisup.c', 00H
	ORG $+1
$SG159788 DB	'E', 00H
	ORG $+2
$SG159713 DB	'NMEM=%d', 0aH, 00H
	ORG $+3
$SG159793 DB	'W', 00H
	ORG $+2
$SG159715 DB	'MEM=%d', 0aH, 00H
$SG159767 DB	'HHC02400%s Directory block byte count is invalid', 0aH, 00H
	ORG $+2
$SG159798 DB	'W', 00H
	ORG $+2
$SG159768 DB	'process_dirblk', 00H
	ORG $+1
$SG159769 DB	'dasdisup.c', 00H
	ORG $+1
$SG159803 DB	'W', 00H
	ORG $+2
$SG159779 DB	'HHC02450%s Member %s type %s skipped', 0aH, 00H
	ORG $+2
$SG159780 DB	'process_dirblk', 00H
	ORG $+1
$SG159781 DB	'dasdisup.c', 00H
	ORG $+1
$SG159854 DB	'I', 00H
	ORG $+2
$SG159784 DB	'HHC02451%s Too many members', 0aH, 00H
	ORG $+3
$SG159785 DB	'process_dirblk', 00H
	ORG $+1
$SG159786 DB	'dasdisup.c', 00H
	ORG $+1
$SG159860 DB	'I', 00H
	ORG $+2
$SG159789 DB	'HHC02452%s Member %s has TTR count zero', 0aH, 00H
	ORG $+3
$SG159853 DB	'alias', 00H
	ORG $+2
$SG159859 DB	'member', 00H
	ORG $+1
$SG159865 DB	'E', 00H
	ORG $+2
$SG159790 DB	'process_dirblk', 00H
	ORG $+1
$SG159791 DB	'dasdisup.c', 00H
	ORG $+1
$SG159870 DB	'E', 00H
	ORG $+2
$SG159794 DB	'HHC02453%s Member %s is not a single text record', 0aH, 00H
	ORG $+2
$SG159874 DB	'I', 00H
	ORG $+2
$SG159795 DB	'process_dirblk', 00H
	ORG $+1
$SG159796 DB	'dasdisup.c', 00H
	ORG $+1
$SG159879 DB	'E', 00H
	ORG $+2
$SG159799 DB	'HHC02454%s Member %s size %04X exceeds limit 07F8', 0aH, 00H
	ORG $+1
$SG159885 DB	'E', 00H
	ORG $+2
$SG159800 DB	'process_dirblk', 00H
	ORG $+1
$SG159801 DB	'dasdisup.c', 00H
	ORG $+1
$SG159890 DB	'E', 00H
	ORG $+2
$SG159804 DB	'HHC02455%s Member %s size %04X is not a multiple of 8', 0aH
	DB	00H
	ORG $+1
$SG159805 DB	'process_dirblk', 00H
	ORG $+1
$SG159806 DB	'dasdisup.c', 00H
	ORG $+1
$SG159898 DB	'IGC', 00H
$SG159855 DB	'HHC02450%s Member %s type %s skipped', 0aH, 00H
	ORG $+2
$SG159856 DB	'resolve_xctltab', 00H
$SG159857 DB	'dasdisup.c', 00H
	ORG $+1
$SG159899 DB	0f0H, 0f1H, 0f9H, 00H
$SG159861 DB	'HHC02450%s Member %s type %s skipped', 0aH, 00H
	ORG $+2
$SG159862 DB	'resolve_xctltab', 00H
$SG159863 DB	'dasdisup.c', 00H
	ORG $+1
$SG159900 DB	0f0H, 0f2H, 0f0H, 00H
$SG159866 DB	'HHC02444%s Member %s is not a single text record', 0aH, 00H
	ORG $+2
$SG159901 DB	0f0H, 0f2H, 0f3H, 00H
$SG159867 DB	'resolve_xctltab', 00H
$SG159868 DB	'dasdisup.c', 00H
	ORG $+1
$SG159902 DB	0f0H, 0f5H, 0f5H, 00H
$SG159871 DB	'HHC02456%s Member %s has invalid TTR %04X%02X', 0aH, 00H
	ORG $+1
$SG159872 DB	'resolve_xctltab', 00H
$SG159873 DB	'dasdisup.c', 00H
	ORG $+5
$SG159875 DB	'HHC02457%s Member %s text record TTR %04X%02X CCHHR %04X'
	DB	'%04X%02X in progress', 0aH, 00H
	ORG $+2
$SG159876 DB	'resolve_xctltab', 00H
$SG159877 DB	'dasdisup.c', 00H
	ORG $+1
$SG159903 DB	'IFG', 00H
$SG159880 DB	'HHC02458%s Member %s error reading TTR %04X%02X', 0aH, 00H
	ORG $+3
$SG159904 DB	'IFG', 00H
$SG159881 DB	'resolve_xctltab', 00H
$SG159882 DB	'dasdisup.c', 00H
	ORG $+5
$SG159887 DB	'resolve_xctltab', 00H
$SG159905 DB	'IGG', 00H
	ORG $+4
$SG159886 DB	'HHC02459%s Member %s TTR %04X%02X text record length %X '
	DB	'is invalid', 0aH, 00H
$SG159908 DB	'IGG', 00H
$SG159888 DB	'dasdisup.c', 00H
	ORG $+5
$SG159892 DB	'resolve_xctltab', 00H
$SG159910 DB	'E', 00H
	ORG $+6
$SG159891 DB	'HHC02460%s Member %s TTR %04X%02X text record length %X '
	DB	'does not match %X in directory', 0aH, 00H
$SG159893 DB	'dasdisup.c', 00H
	ORG $+5
$SG159912 DB	'resolve_xctltab', 00H
$SG159917 DB	' member ''%s'' not found', 00H
	ORG $+1
$SG159911 DB	'HHC02461%s Member %s TTR %04X%02X XCTL table improperly '
	DB	'terminated', 0aH, 00H
$SG159918 DB	'I', 00H
	ORG $+2
$SG159913 DB	'dasdisup.c', 00H
	ORG $+1
$SG159924 DB	'I', 00H
	ORG $+2
$SG159919 DB	'HHC02462%s Member %s %s TTRL %02X%02X%02X%02X: %s', 0aH, 00H
	ORG $+1
$SG159933 DB	'I', 00H
	ORG $+2
$SG159920 DB	'resolve_xctltab', 00H
$SG159921 DB	'dasdisup.c', 00H
	ORG $+5
$SG159925 DB	'HHC02462%s Member %s %s TTRL %02X%02X%02X%02X: %s', 0aH, 00H
	ORG $+5
$SG159926 DB	'resolve_xctltab', 00H
$SG159927 DB	'dasdisup.c', 00H
	ORG $+1
$SG159930 DB	'****', 00H
	ORG $+7
$SG159932 DB	' replaced by TTRL=%02X%02X%02X%02X %s', 00H
	ORG $+2
$SG159934 DB	'HHC02462%s Member %s %s TTRL %02X%02X%02X%02X: %s', 0aH, 00H
	ORG $+5
$SG159935 DB	'resolve_xctltab', 00H
$SG159936 DB	'dasdisup.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	04d6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:resolve_xctltab
	DD	026H
	DD	0ef3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_dirblk
	DD	026H
	DD	0736H
voltbl	ENDS
xdata	SEGMENT
$unwind$process_dirblk DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$resolve_xctltab DD 042e19H
	DD	03d011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$main DD	022219H
	DD	0370110H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdisup.c
_TEXT	SEGMENT
rec$ = 80
rc$ = 84
head$ = 88
i$ = 92
nmem$ = 96
len$ = 100
trk$ = 104
noext$ = 108
cif$ = 112
memtab$ = 120
cyl$ = 128
sfname$ = 136
pgm$ = 144
tv94 = 152
fname$ = 160
blkptr$ = 168
extent$ = 176
buf$1 = 336
__$ArrayPad$ = 416
argc$ = 448
argv$ = 456
main	PROC

; 93   : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 94   : char           *pgm;                    /* less any extension (.ext) */
; 95   : int             rc;                     /* Return code               */
; 96   : int             i;                      /* Array subscript           */
; 97   : U16             len;                    /* Record length             */
; 98   : U32             cyl;                    /* Cylinder number           */
; 99   : U8              head;                   /* Head number               */
; 100  : U8              rec;                    /* Record number             */
; 101  : u_int           trk;                    /* Relative track number     */
; 102  : char           *fname;                  /* -> CKD image file name    */
; 103  : char           *sfname;                 /* -> CKD shadow file name   */
; 104  : int             noext;                  /* Number of extents         */
; 105  : DSXTENT         extent[16];             /* Extent descriptor array   */
; 106  : BYTE           *blkptr;                 /* -> PDS directory block    */
; 107  : CIFBLK         *cif;                    /* CKD image file descriptor */
; 108  : MEMINFO        *memtab;                 /* -> Member info array      */
; 109  : int             nmem = 0;               /* Number of array entries   */

  00022	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR nmem$[rsp], 0

; 110  : 
; 111  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  0002a	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159683
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159684
  00045	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0004d	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  0005a	89 84 24 c0 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 112  : 
; 113  :     /* Check the number of arguments */
; 114  :     if (argc < 2 || argc > 3)

  00061	83 bc 24 c0 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00069	7c 0a		 jl	 SHORT $LN14@main
  0006b	83 bc 24 c0 01
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00073	7e 5e		 jle	 SHORT $LN13@main
$LN14@main:

; 115  :     {
; 116  :         // "Usage: %s ...
; 117  :         WRMSG( HHC02463, "I", pgm );

  00075	b9 01 00 00 00	 mov	 ecx, 1
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00080	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00088	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159687
  00094	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159688
  000a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159689
  000b7	ba 75 00 00 00	 mov	 edx, 117		; 00000075H
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159690
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 118  :         return -1;

  000c9	b8 ff ff ff ff	 mov	 eax, -1
  000ce	e9 03 04 00 00	 jmp	 $LN1@main
$LN13@main:

; 119  :     }
; 120  : 
; 121  :     /* The first argument is the name of the CKD image file */
; 122  :     fname = argv[1];

  000d3	b8 08 00 00 00	 mov	 eax, 8
  000d8	48 6b c0 01	 imul	 rax, rax, 1
  000dc	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000e4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000e8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR fname$[rsp], rax

; 123  : 
; 124  :     /* The next argument, if there, is the name of the shadow file */
; 125  :     if (argc > 2) sfname = argv[2];

  000f0	83 bc 24 c0 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000f8	7e 1f		 jle	 SHORT $LN15@main
  000fa	b8 08 00 00 00	 mov	 eax, 8
  000ff	48 6b c0 02	 imul	 rax, rax, 2
  00103	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0010b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0010f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sfname$[rsp], rax
  00117	eb 0c		 jmp	 SHORT $LN16@main
$LN15@main:

; 126  :     else sfname = NULL;

  00119	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR sfname$[rsp], 0
$LN16@main:

; 127  : 
; 128  :     /* Obtain storage for the member information array */
; 129  :     memtab = (MEMINFO*) calloc( MAX_MEMBERS, sizeof(MEMINFO) );

  00125	ba 0f 00 00 00	 mov	 edx, 15
  0012a	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00135	48 89 44 24 78	 mov	 QWORD PTR memtab$[rsp], rax

; 130  :     if (memtab == NULL)

  0013a	48 83 7c 24 78
	00		 cmp	 QWORD PTR memtab$[rsp], 0
  00140	0f 85 a9 00 00
	00		 jne	 $LN17@main

; 131  :     {
; 132  :         char buf[80];
; 133  :         MSGBUF( buf, "calloc(%d,%d)", MAX_MEMBERS, (int)(sizeof( MEMINFO )));

  00146	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR [rsp+32], 15
  0014e	41 b9 e8 03 00
	00		 mov	 r9d, 1000		; 000003e8H
  00154	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159694
  0015b	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00160	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 134  :         // "Error in function %s: %s"
; 135  :         FWRMSG( stderr, HHC02412, "E", buf, strerror( errno ));

  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00174	8b 08		 mov	 ecx, DWORD PTR [rax]
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0017c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  00184	b9 02 00 00 00	 mov	 ecx, 2
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  00197	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0019c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159695
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159696
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159697
  001d3	ba 87 00 00 00	 mov	 edx, 135		; 00000087H
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159698
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 136  :         return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	e9 e7 02 00 00	 jmp	 $LN1@main
$LN17@main:

; 137  :     }
; 138  : 
; 139  :     /* Open the CKD image file */
; 140  :     cif = open_ckd_image (fname, sfname, O_RDWR|O_BINARY, IMAGE_OPEN_NORMAL);

  001ef	45 33 c9	 xor	 r9d, r9d
  001f2	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  001f8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR sfname$[rsp]
  00200	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  0020e	48 89 44 24 70	 mov	 QWORD PTR cif$[rsp], rax

; 141  :     if (cif == NULL) return -1;

  00213	48 83 7c 24 70
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00219	75 0a		 jne	 SHORT $LN18@main
  0021b	b8 ff ff ff ff	 mov	 eax, -1
  00220	e9 b1 02 00 00	 jmp	 $LN1@main
$LN18@main:

; 142  : 
; 143  :     /* Build the extent array for the SVCLIB dataset */
; 144  :     rc = build_extent_array (cif, "SYS1.SVCLIB", extent, &noext);

  00225	4c 8d 4c 24 6c	 lea	 r9, QWORD PTR noext$[rsp]
  0022a	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  00232	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159700
  00239	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cif$[rsp]
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_build_extent_array
  00244	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 145  :     if (rc < 0) return -1;

  00248	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0024d	7d 0a		 jge	 SHORT $LN19@main
  0024f	b8 ff ff ff ff	 mov	 eax, -1
  00254	e9 7d 02 00 00	 jmp	 $LN1@main
$LN19@main:

; 146  : 
; 147  :     /* Point to the start of the directory */
; 148  :     trk = 0;

  00259	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 149  :     rec = 1;

  00261	c6 44 24 50 01	 mov	 BYTE PTR rec$[rsp], 1
$LN29@main:
$LN2@main:

; 150  : 
; 151  :     /* Read the directory */
; 152  :     while (1)

  00266	33 c0		 xor	 eax, eax
  00268	83 f8 01	 cmp	 eax, 1
  0026b	0f 84 2e 01 00
	00		 je	 $LN3@main

; 153  :     {
; 154  :         /* Convert relative track to cylinder and head */
; 155  :         rc = convert_tt (trk, noext, extent, cif->heads, &cyl, &head);

  00271	48 8d 44 24 58	 lea	 rax, QWORD PTR head$[rsp]
  00276	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0027b	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  00283	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00288	48 8b 44 24 70	 mov	 rax, QWORD PTR cif$[rsp]
  0028d	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  00292	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  0029a	8b 54 24 6c	 mov	 edx, DWORD PTR noext$[rsp]
  0029e	8b 4c 24 68	 mov	 ecx, DWORD PTR trk$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  002a8	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 156  :         if (rc < 0) return -1;

  002ac	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  002b1	7d 0a		 jge	 SHORT $LN20@main
  002b3	b8 ff ff ff ff	 mov	 eax, -1
  002b8	e9 19 02 00 00	 jmp	 $LN1@main
$LN20@main:

; 157  : 
; 158  :         /* Read a directory block */
; 159  :         rc = read_block (cif, cyl, head, rec,

  002bd	48 8d 44 24 64	 lea	 rax, QWORD PTR len$[rsp]
  002c2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002c7	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR blkptr$[rsp]
  002cf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002dd	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  002e6	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR rec$[rsp]
  002ec	44 0f b6 44 24
	58		 movzx	 r8d, BYTE PTR head$[rsp]
  002f2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  002f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cif$[rsp]
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00304	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 160  :                         NULL, NULL, &blkptr, &len);
; 161  :         if (rc < 0) return -1;

  00308	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0030d	7d 0a		 jge	 SHORT $LN21@main
  0030f	b8 ff ff ff ff	 mov	 eax, -1
  00314	e9 bd 01 00 00	 jmp	 $LN1@main
$LN21@main:

; 162  : 
; 163  :         /* Move to next track if block not found */
; 164  :         if (rc > 0)

  00319	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0031e	7e 14		 jle	 SHORT $LN22@main

; 165  :         {
; 166  :             trk++;

  00320	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00324	ff c0		 inc	 eax
  00326	89 44 24 68	 mov	 DWORD PTR trk$[rsp], eax

; 167  :             rec = 1;

  0032a	c6 44 24 50 01	 mov	 BYTE PTR rec$[rsp], 1

; 168  :             continue;

  0032f	e9 32 ff ff ff	 jmp	 $LN2@main
$LN22@main:

; 169  :         }
; 170  : 
; 171  :         /* Exit at end of directory */
; 172  :         if (len == 0) break;

  00334	0f b7 44 24 64	 movzx	 eax, WORD PTR len$[rsp]
  00339	85 c0		 test	 eax, eax
  0033b	75 02		 jne	 SHORT $LN23@main
  0033d	eb 60		 jmp	 SHORT $LN3@main
$LN23@main:

; 173  : 
; 174  :         /* Extract information for each member in directory block */
; 175  :         rc = process_dirblk (cif, noext, extent, blkptr,

  0033f	48 8d 44 24 60	 lea	 rax, QWORD PTR nmem$[rsp]
  00344	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00349	48 8b 44 24 78	 mov	 rax, QWORD PTR memtab$[rsp]
  0034e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00353	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR blkptr$[rsp]
  0035b	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  00363	8b 54 24 6c	 mov	 edx, DWORD PTR noext$[rsp]
  00367	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cif$[rsp]
  0036c	e8 00 00 00 00	 call	 process_dirblk
  00371	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 176  :                             memtab, &nmem);
; 177  :         if (rc < 0) return -1;

  00375	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0037a	7d 0a		 jge	 SHORT $LN24@main
  0037c	b8 ff ff ff ff	 mov	 eax, -1
  00381	e9 50 01 00 00	 jmp	 $LN1@main
$LN24@main:

; 178  :         if (rc > 0) break;

  00386	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0038b	7e 02		 jle	 SHORT $LN25@main
  0038d	eb 10		 jmp	 SHORT $LN3@main
$LN25@main:

; 179  : 
; 180  :         /* Point to the next directory block */
; 181  :         rec++;

  0038f	0f b6 44 24 50	 movzx	 eax, BYTE PTR rec$[rsp]
  00394	fe c0		 inc	 al
  00396	88 44 24 50	 mov	 BYTE PTR rec$[rsp], al

; 182  : 
; 183  :     } /* end while */

  0039a	e9 c7 fe ff ff	 jmp	 $LN29@main
$LN3@main:

; 184  : 
; 185  :     // "End of directory, %d members selected"
; 186  :     WRMSG( HHC02464, "I", nmem );

  0039f	b9 01 00 00 00	 mov	 ecx, 1
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003aa	8b 4c 24 60	 mov	 ecx, DWORD PTR nmem$[rsp]
  003ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159708
  003b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159709
  003c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159710
  003dc	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159711
  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@main:

; 187  : 
; 188  :     EXTGUIMSG( "NMEM=%d\n", nmem );

  003ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  003f5	83 38 00	 cmp	 DWORD PTR [rax], 0
  003f8	74 20		 je	 SHORT $LN26@main
  003fa	b9 02 00 00 00	 mov	 ecx, 2
  003ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00405	44 8b 44 24 60	 mov	 r8d, DWORD PTR nmem$[rsp]
  0040a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159713
  00411	48 8b c8	 mov	 rcx, rax
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN26@main:
  0041a	33 c0		 xor	 eax, eax
  0041c	85 c0		 test	 eax, eax
  0041e	75 ce		 jne	 SHORT $LN6@main

; 189  : 
; 190  :     /* Read each member and resolve the embedded TTRs */
; 191  :     for (i = 0; i < nmem; i++)

  00420	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00428	eb 0a		 jmp	 SHORT $LN9@main
$LN7@main:
  0042a	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  0042e	ff c0		 inc	 eax
  00430	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN9@main:
  00434	8b 44 24 60	 mov	 eax, DWORD PTR nmem$[rsp]
  00438	39 44 24 5c	 cmp	 DWORD PTR i$[rsp], eax
  0043c	7d 7a		 jge	 SHORT $LN8@main
$LN12@main:

; 192  :     {
; 193  :         EXTGUIMSG( "MEM=%d\n", i );

  0043e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00445	83 38 00	 cmp	 DWORD PTR [rax], 0
  00448	74 20		 je	 SHORT $LN27@main
  0044a	b9 02 00 00 00	 mov	 ecx, 2
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00455	44 8b 44 24 5c	 mov	 r8d, DWORD PTR i$[rsp]
  0045a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159715
  00461	48 8b c8	 mov	 rcx, rax
  00464	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN27@main:
  0046a	33 c0		 xor	 eax, eax
  0046c	85 c0		 test	 eax, eax
  0046e	75 ce		 jne	 SHORT $LN12@main

; 194  :         rc = resolve_xctltab (cif, noext, extent, memtab+i,

  00470	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  00475	48 6b c0 0f	 imul	 rax, rax, 15
  00479	48 8b 4c 24 78	 mov	 rcx, QWORD PTR memtab$[rsp]
  0047e	48 03 c8	 add	 rcx, rax
  00481	48 8b c1	 mov	 rax, rcx
  00484	8b 4c 24 60	 mov	 ecx, DWORD PTR nmem$[rsp]
  00488	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0048c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR memtab$[rsp]
  00491	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00496	4c 8b c8	 mov	 r9, rax
  00499	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  004a1	8b 54 24 6c	 mov	 edx, DWORD PTR noext$[rsp]
  004a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cif$[rsp]
  004aa	e8 00 00 00 00	 call	 resolve_xctltab
  004af	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 195  :                                 memtab, nmem);
; 196  : 
; 197  :     } /* end for(i) */

  004b3	e9 72 ff ff ff	 jmp	 $LN7@main
$LN8@main:

; 198  : 
; 199  :     /* Close the CKD image file and exit */
; 200  :     rc = close_ckd_image (cif);

  004b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cif$[rsp]
  004bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image
  004c3	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 201  :     free (memtab);

  004c7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR memtab$[rsp]
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 202  :     return rc;

  004d2	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 203  : 
; 204  : } /* end function main */

  004d6	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004de	48 33 cc	 xor	 rcx, rsp
  004e1	e8 00 00 00 00	 call	 __security_check_cookie
  004e6	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  004ed	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdisup.c
_TEXT	SEGMENT
xctloff$ = 112
rec$ = 116
len$ = 120
blkptr$ = 128
head$ = 136
i$ = 140
svcnum$ = 144
trk$ = 148
prefix$ = 152
rc$ = 156
cyl$ = 160
warn$ = 164
tv184 = 168
tv186 = 172
tv189 = 176
tv212 = 180
tv232 = 184
tv234 = 188
tv254 = 192
tv256 = 196
tv258 = 200
tv398 = 204
tv475 = 208
tv481 = 212
tv487 = 216
tv537 = 220
tv543 = 224
tv549 = 228
tv637 = 232
tv643 = 236
tv649 = 240
tv171 = 244
tv604 = 248
tv849 = 256
memnama$ = 264
refname$ = 280
refnama$ = 288
buf$1 = 304
buf$2 = 384
__$ArrayPad$ = 464
cif$ = 512
noext$ = 520
extent$ = 528
memp$ = 536
memtab$ = 544
nmem$ = 552
resolve_xctltab PROC

; 384  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 385  : int             rc;                     /* Return code               */
; 386  : int             i;                      /* Array subscript           */
; 387  : U16             len;                    /* Record length             */
; 388  : U32             cyl;                    /* Cylinder number           */
; 389  : U8              head;                   /* Head number               */
; 390  : U8              rec;                    /* Record number             */
; 391  : u_int           trk;                    /* Relative track number     */
; 392  : int             xctloff;                /* Offset to XCTL table      */
; 393  : int             warn;                   /* 1=Flag TTRL difference    */
; 394  : BYTE           *blkptr;                 /* -> Text record data       */
; 395  : char            memnama[9];             /* Member name (ASCIIZ)      */
; 396  : BYTE            svcnum[3];              /* SVC number (EBCDIC)       */
; 397  : BYTE            prefix[3];              /* IGG/IFG prefix (EBCDIC)   */
; 398  : BYTE            refname[8];             /* Referred name (EBCDIC)    */
; 399  : char            refnama[9];             /* Referred name (ASCIIZ)    */
; 400  : 
; 401  :     /* Extract the member name */
; 402  :     make_asciiz (memnama, sizeof(memnama), memp->memname, 8);

  0002e	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR memp$[rsp]
  00036	41 b9 08 00 00
	00		 mov	 r9d, 8
  0003c	4c 8b c0	 mov	 r8, rax
  0003f	ba 09 00 00 00	 mov	 edx, 9
  00044	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 403  :     if (memp->memname[7] == OVERPUNCH_ZERO)

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	48 6b c0 07	 imul	 rax, rax, 7
  0005b	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR memp$[rsp]
  00063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00067	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0006c	75 11		 jne	 SHORT $LN7@resolve_xc

; 404  :         memnama[7] = '{';

  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	48 6b c0 07	 imul	 rax, rax, 7
  00077	c6 84 04 08 01
	00 00 7b	 mov	 BYTE PTR memnama$[rsp+rax], 123 ; 0000007bH
$LN7@resolve_xc:

; 405  : 
; 406  :     /* Skip the member if it is an alias */
; 407  :     if (memp->alias)

  0007f	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR memp$[rsp]
  00087	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  0008b	85 c0		 test	 eax, eax
  0008d	74 67		 je	 SHORT $LN8@resolve_xc

; 408  :     {
; 409  :         // "Member %s type %s skipped"
; 410  :         WRMSG( HHC02450, "I", memnama, "alias" );

  0008f	b9 01 00 00 00	 mov	 ecx, 1
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159853
  000a1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000a6	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  000ae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159854
  000ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159855
  000c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159856
  000dd	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159857
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 411  :         return 0;

  000ef	33 c0		 xor	 eax, eax
  000f1	e9 fd 0d 00 00	 jmp	 $LN1@resolve_xc
$LN8@resolve_xc:

; 412  :     }
; 413  : 
; 414  :     /* Skip the member if it has no XCTL table */
; 415  :     if (memp->notable)

  000f6	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR memp$[rsp]
  000fe	0f b6 40 0d	 movzx	 eax, BYTE PTR [rax+13]
  00102	85 c0		 test	 eax, eax
  00104	74 67		 je	 SHORT $LN9@resolve_xc

; 416  :     {
; 417  :         // "Member %s type %s skipped"
; 418  :         WRMSG( HHC02450, "I", memnama, "member" );

  00106	b9 01 00 00 00	 mov	 ecx, 1
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159859
  00118	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0011d	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00125	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159860
  00131	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159861
  0013d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00142	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00147	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159862
  00154	ba a2 01 00 00	 mov	 edx, 418		; 000001a2H
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159863
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 419  :         return 0;

  00166	33 c0		 xor	 eax, eax
  00168	e9 86 0d 00 00	 jmp	 $LN1@resolve_xc
$LN9@resolve_xc:

; 420  :     }
; 421  : 
; 422  :     /* Error if member is not a single text record */
; 423  :     if (memp->multitxt)

  0016d	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR memp$[rsp]
  00175	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  00179	85 c0		 test	 eax, eax
  0017b	74 5e		 je	 SHORT $LN10@resolve_xc

; 424  :     {
; 425  :         // "Member %s is not a single text record"
; 426  :         FWRMSG( stderr, HHC02444, "E", memnama );

  0017d	b9 02 00 00 00	 mov	 ecx, 2
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00188	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00190	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159865
  0019c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159866
  001a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159867
  001bf	ba aa 01 00 00	 mov	 edx, 426		; 000001aaH
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159868
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 427  :         return -1;

  001d1	b8 ff ff ff ff	 mov	 eax, -1
  001d6	e9 18 0d 00 00	 jmp	 $LN1@resolve_xc
$LN10@resolve_xc:

; 428  :     }
; 429  : 
; 430  :     /* Convert relative track to cylinder and head */
; 431  :     trk = (memp->ttrtext[0] << 8) | memp->ttrtext[1];

  001db	b8 01 00 00 00	 mov	 eax, 1
  001e0	48 6b c0 00	 imul	 rax, rax, 0
  001e4	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR memp$[rsp]
  001ec	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  001f1	c1 e0 08	 shl	 eax, 8
  001f4	b9 01 00 00 00	 mov	 ecx, 1
  001f9	48 6b c9 01	 imul	 rcx, rcx, 1
  001fd	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR memp$[rsp]
  00205	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  0020a	0b c1		 or	 eax, ecx
  0020c	89 84 24 94 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 432  :     rec = memp->ttrtext[2];

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 02	 imul	 rax, rax, 2
  0021c	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR memp$[rsp]
  00224	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  00229	88 44 24 74	 mov	 BYTE PTR rec$[rsp], al

; 433  :     rc = convert_tt (trk, noext, extent, cif->heads, &cyl, &head);

  0022d	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR head$[rsp]
  00235	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  00242	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00247	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0024f	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  00254	4c 8b 84 24 10
	02 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  0025c	8b 94 24 08 02
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  00263	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  00270	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 434  :     if (rc < 0)

  00277	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0027f	0f 8d 80 00 00
	00		 jge	 $LN11@resolve_xc

; 435  :     {
; 436  :         // "Member %s has invalid TTR %04X%02X"
; 437  :         FWRMSG( stderr, HHC02456, "E", memnama, trk, rec );

  00285	0f b6 44 24 74	 movzx	 eax, BYTE PTR rec$[rsp]
  0028a	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  00291	b9 02 00 00 00	 mov	 ecx, 2
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029c	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  002a3	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002a7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  002ae	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002b2	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  002ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159870
  002c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159871
  002d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159872
  002e9	ba b5 01 00 00	 mov	 edx, 437		; 000001b5H
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159873
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 438  :         return -1;

  002fb	b8 ff ff ff ff	 mov	 eax, -1
  00300	e9 ee 0b 00 00	 jmp	 $LN1@resolve_xc
$LN11@resolve_xc:

; 439  :     }
; 440  : 
; 441  :     // "Member %s text record TTR %04X%02X CCHHR %04X%04X%02X in progress"
; 442  :     WRMSG( HHC02457, "I", memnama, trk, rec, cyl, head, rec );

  00305	0f b6 44 24 74	 movzx	 eax, BYTE PTR rec$[rsp]
  0030a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
  00311	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  00319	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv186[rsp], ecx
  00320	0f b6 54 24 74	 movzx	 edx, BYTE PTR rec$[rsp]
  00325	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv189[rsp], edx
  0032c	b9 01 00 00 00	 mov	 ecx, 1
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00337	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  0033e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00342	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  00349	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0034d	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00354	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00358	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  0035f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00363	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0036a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036e	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00376	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159874
  00382	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159875
  0038e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00393	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00398	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159876
  003a5	ba ba 01 00 00	 mov	 edx, 442		; 000001baH
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159877
  003b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 443  : 
; 444  :     /* Read the text record */
; 445  :     rc = read_block (cif, cyl, head, rec,

  003b7	48 8d 44 24 78	 lea	 rax, QWORD PTR len$[rsp]
  003bc	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003c1	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR blkptr$[rsp]
  003c9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003ce	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003d7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  003e0	44 0f b6 4c 24
	74		 movzx	 r9d, BYTE PTR rec$[rsp]
  003e6	44 0f b6 84 24
	88 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  003ef	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  003f6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00404	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 446  :                     NULL, NULL, &blkptr, &len);
; 447  :     if (rc != 0)

  0040b	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00413	0f 84 80 00 00
	00		 je	 $LN12@resolve_xc

; 448  :     {
; 449  :         // "Member %s error reading TTR %04X%02X"
; 450  :         FWRMSG( stderr, HHC02458, "E", memnama, trk, rec );

  00419	0f b6 44 24 74	 movzx	 eax, BYTE PTR rec$[rsp]
  0041e	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  00425	b9 02 00 00 00	 mov	 ecx, 2
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00430	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  00437	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0043b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00442	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00446	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0044e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159879
  0045a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159880
  00466	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00470	41 b9 03 00 00
	00		 mov	 r9d, 3
  00476	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159881
  0047d	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159882
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 451  :         return -1;

  0048f	b8 ff ff ff ff	 mov	 eax, -1
  00494	e9 5a 0a 00 00	 jmp	 $LN1@resolve_xc
$LN12@resolve_xc:

; 452  :     }
; 453  : 
; 454  :     /* Check for incorrect length record */
; 455  :     if (len < 8 || len > 1024 || (len & 0x7))

  00499	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  0049e	83 f8 08	 cmp	 eax, 8
  004a1	7c 1c		 jl	 SHORT $LN14@resolve_xc
  004a3	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  004a8	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  004ad	7f 10		 jg	 SHORT $LN14@resolve_xc
  004af	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  004b4	83 e0 07	 and	 eax, 7
  004b7	85 c0		 test	 eax, eax
  004b9	0f 84 97 00 00
	00		 je	 $LN13@resolve_xc
$LN14@resolve_xc:

; 456  :     {
; 457  :         // "Member %s TTR %04X%02X text record length %X is invalid"
; 458  :         FWRMSG( stderr, HHC02459, "E", memnama, trk, rec, len );

  004bf	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  004c4	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv232[rsp], eax
  004cb	0f b6 4c 24 74	 movzx	 ecx, BYTE PTR rec$[rsp]
  004d0	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv234[rsp], ecx
  004d7	b9 02 00 00 00	 mov	 ecx, 2
  004dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004e2	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  004e9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004ed	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  004f4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004f8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  004ff	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00503	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0050b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00510	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159885
  00517	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0051c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159886
  00523	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00528	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0052d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00533	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159887
  0053a	ba ca 01 00 00	 mov	 edx, 458		; 000001caH
  0053f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159888
  00546	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 459  :         return -1;

  0054c	b8 ff ff ff ff	 mov	 eax, -1
  00551	e9 9d 09 00 00	 jmp	 $LN1@resolve_xc
$LN13@resolve_xc:

; 460  :     }
; 461  : 
; 462  :     /* Check that text record length matches directory entry */
; 463  :     if (len != memp->dwdsize * 8)

  00556	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  0055b	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR memp$[rsp]
  00563	0f b6 49 0b	 movzx	 ecx, BYTE PTR [rcx+11]
  00567	c1 e1 03	 shl	 ecx, 3
  0056a	3b c1		 cmp	 eax, ecx
  0056c	0f 84 b8 00 00
	00		 je	 $LN15@resolve_xc

; 464  :     {
; 465  :         // "Member %s TTR %04X%02X text record length %X does not match %X in directory"
; 466  :         FWRMSG( stderr, HHC02460, "E",

  00572	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR memp$[rsp]
  0057a	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0057e	c1 e0 03	 shl	 eax, 3
  00581	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv254[rsp], eax
  00588	0f b7 4c 24 78	 movzx	 ecx, WORD PTR len$[rsp]
  0058d	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv256[rsp], ecx
  00594	0f b6 54 24 74	 movzx	 edx, BYTE PTR rec$[rsp]
  00599	89 94 24 c8 00
	00 00		 mov	 DWORD PTR tv258[rsp], edx
  005a0	b9 02 00 00 00	 mov	 ecx, 2
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ab	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv254[rsp]
  005b2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005b6	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  005bd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005c1	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  005c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005cc	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  005d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005d7	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  005df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159890
  005eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159891
  005f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00601	41 b9 03 00 00
	00		 mov	 r9d, 3
  00607	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159892
  0060e	ba d3 01 00 00	 mov	 edx, 467		; 000001d3H
  00613	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159893
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 467  :                 memnama, trk, rec, len, memp->dwdsize * 8 );
; 468  :         return -1;

  00620	b8 ff ff ff ff	 mov	 eax, -1
  00625	e9 c9 08 00 00	 jmp	 $LN1@resolve_xc
$LN15@resolve_xc:

; 469  :     }
; 470  : 
; 471  :     /* Extract the SVC number and the XCTL table offset
; 472  :        from the last 4 bytes of the text record */
; 473  :     memcpy (svcnum, blkptr + len - 4, sizeof(svcnum));

  0062a	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  0062f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  00637	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  0063f	48 8b f9	 mov	 rdi, rcx
  00642	48 8d 74 02 fc	 lea	 rsi, QWORD PTR [rdx+rax-4]
  00647	b9 03 00 00 00	 mov	 ecx, 3
  0064c	f3 a4		 rep movsb

; 474  :     xctloff = blkptr[len-1] * 8;

  0064e	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  00653	ff c8		 dec	 eax
  00655	48 98		 cdqe
  00657	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  0065f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00663	c1 e0 03	 shl	 eax, 3
  00666	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 475  : 
; 476  :     /* For the first load of SVC 19, 20, 23, and 55, and for
; 477  :        IFG modules, the table is in two parts.  The parts are
; 478  :        separated by a X'FFFF' delimiter.  The first part refers
; 479  :        to IFG modules, the second part refers to IGG modules */
; 480  :     if ((memcmp(memnama, "IGC", 3) == 0
; 481  :          && (memcmp(svcnum, "\xF0\xF1\xF9", 3) == 0
; 482  :             || memcmp(svcnum, "\xF0\xF2\xF0", 3) == 0
; 483  :             || memcmp(svcnum, "\xF0\xF2\xF3", 3) == 0
; 484  :             || memcmp(svcnum, "\xF0\xF5\xF5", 3) == 0))
; 485  :         || memcmp(memnama, "IFG", 3) == 0)

  0066a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00670	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159898
  00677	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0067f	e8 00 00 00 00	 call	 memcmp
  00684	85 c0		 test	 eax, eax
  00686	75 78		 jne	 SHORT $LN19@resolve_xc
  00688	41 b8 03 00 00
	00		 mov	 r8d, 3
  0068e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159899
  00695	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  0069d	e8 00 00 00 00	 call	 memcmp
  006a2	85 c0		 test	 eax, eax
  006a4	74 78		 je	 SHORT $LN18@resolve_xc
  006a6	41 b8 03 00 00
	00		 mov	 r8d, 3
  006ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159900
  006b3	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  006bb	e8 00 00 00 00	 call	 memcmp
  006c0	85 c0		 test	 eax, eax
  006c2	74 5a		 je	 SHORT $LN18@resolve_xc
  006c4	41 b8 03 00 00
	00		 mov	 r8d, 3
  006ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159901
  006d1	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  006d9	e8 00 00 00 00	 call	 memcmp
  006de	85 c0		 test	 eax, eax
  006e0	74 3c		 je	 SHORT $LN18@resolve_xc
  006e2	41 b8 03 00 00
	00		 mov	 r8d, 3
  006e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159902
  006ef	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  006f7	e8 00 00 00 00	 call	 memcmp
  006fc	85 c0		 test	 eax, eax
  006fe	74 1e		 je	 SHORT $LN18@resolve_xc
$LN19@resolve_xc:
  00700	41 b8 03 00 00
	00		 mov	 r8d, 3
  00706	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159903
  0070d	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00715	e8 00 00 00 00	 call	 memcmp
  0071a	85 c0		 test	 eax, eax
  0071c	75 1c		 jne	 SHORT $LN16@resolve_xc
$LN18@resolve_xc:

; 486  :         convert_to_ebcdic (prefix, sizeof(prefix), "IFG");

  0071e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159904
  00725	ba 03 00 00 00	 mov	 edx, 3
  0072a	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  00732	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic
  00738	eb 1a		 jmp	 SHORT $LN17@resolve_xc
$LN16@resolve_xc:

; 487  :     else
; 488  :         convert_to_ebcdic (prefix, sizeof(prefix), "IGG");

  0073a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159905
  00741	ba 03 00 00 00	 mov	 edx, 3
  00746	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  0074e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic
$LN17@resolve_xc:
$LN35@resolve_xc:
$LN34@resolve_xc:
$LN33@resolve_xc:
$LN32@resolve_xc:
$LN2@resolve_xc:

; 489  : 
; 490  :     /* Process each entry in the XCTL table */
; 491  :     while (1)

  00754	33 c0		 xor	 eax, eax
  00756	83 f8 01	 cmp	 eax, 1
  00759	0f 84 92 07 00
	00		 je	 $LN3@resolve_xc

; 492  :     {
; 493  :         /* Exit at end of XCTL table */
; 494  :         if (blkptr[xctloff] == HEX00 && blkptr[xctloff+1] == HEX00)

  0075f	48 63 44 24 70	 movsxd	 rax, DWORD PTR xctloff$[rsp]
  00764	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  0076c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00770	85 c0		 test	 eax, eax
  00772	75 1d		 jne	 SHORT $LN20@resolve_xc
  00774	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00778	ff c0		 inc	 eax
  0077a	48 98		 cdqe
  0077c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00784	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00788	85 c0		 test	 eax, eax
  0078a	75 05		 jne	 SHORT $LN20@resolve_xc

; 495  :             break;

  0078c	e9 60 07 00 00	 jmp	 $LN3@resolve_xc
$LN20@resolve_xc:

; 496  : 
; 497  :         /* Switch prefix at end of first part of table */
; 498  :         if (blkptr[xctloff] == HEXFF && blkptr[xctloff+1] == HEXFF)

  00791	48 63 44 24 70	 movsxd	 rax, DWORD PTR xctloff$[rsp]
  00796	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  0079e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007a2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007a7	75 45		 jne	 SHORT $LN21@resolve_xc
  007a9	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  007ad	ff c0		 inc	 eax
  007af	48 98		 cdqe
  007b1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  007b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007bd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007c2	75 2a		 jne	 SHORT $LN21@resolve_xc

; 499  :         {
; 500  :             xctloff += 2;

  007c4	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  007c8	83 c0 02	 add	 eax, 2
  007cb	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 501  :             convert_to_ebcdic (prefix, sizeof(prefix), "IGG");

  007cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159908
  007d6	ba 03 00 00 00	 mov	 edx, 3
  007db	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 502  :             continue;

  007e9	e9 66 ff ff ff	 jmp	 $LN2@resolve_xc
$LN21@resolve_xc:

; 503  :         }
; 504  : 
; 505  :         /* Error if XCTL table overflows text record */
; 506  :         if (xctloff >= len - 10)

  007ee	0f b7 44 24 78	 movzx	 eax, WORD PTR len$[rsp]
  007f3	83 e8 0a	 sub	 eax, 10
  007f6	39 44 24 70	 cmp	 DWORD PTR xctloff$[rsp], eax
  007fa	0f 8c 80 00 00
	00		 jl	 $LN22@resolve_xc

; 507  :         {
; 508  :             // "Member %s TTR %04X%02X XCTL table improperly terminated"
; 509  :             FWRMSG( stderr, HHC02461, "E", memnama, trk, rec );

  00800	0f b6 44 24 74	 movzx	 eax, BYTE PTR rec$[rsp]
  00805	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv398[rsp], eax
  0080c	b9 02 00 00 00	 mov	 ecx, 2
  00811	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00817	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  0081e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00822	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00829	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0082d	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00835	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0083a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159910
  00841	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00846	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159911
  0084d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00852	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00857	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159912
  00864	ba fd 01 00 00	 mov	 edx, 509		; 000001fdH
  00869	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159913
  00870	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 510  :             return -1;

  00876	b8 ff ff ff ff	 mov	 eax, -1
  0087b	e9 73 06 00 00	 jmp	 $LN1@resolve_xc
$LN22@resolve_xc:

; 511  :         }
; 512  : 
; 513  :         /* Skip this entry if the suffix is blank */
; 514  :         if (blkptr[xctloff] == HEX40
; 515  :             && blkptr[xctloff+1] == HEX40)

  00880	48 63 44 24 70	 movsxd	 rax, DWORD PTR xctloff$[rsp]
  00885	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  0088d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00891	83 f8 40	 cmp	 eax, 64			; 00000040H
  00894	75 29		 jne	 SHORT $LN23@resolve_xc
  00896	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  0089a	ff c0		 inc	 eax
  0089c	48 98		 cdqe
  0089e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  008a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008aa	83 f8 40	 cmp	 eax, 64			; 00000040H
  008ad	75 10		 jne	 SHORT $LN23@resolve_xc

; 516  :         {
; 517  :             xctloff += 6;

  008af	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  008b3	83 c0 06	 add	 eax, 6
  008b6	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 518  :             continue;

  008ba	e9 95 fe ff ff	 jmp	 $LN32@resolve_xc
$LN23@resolve_xc:

; 519  :         }
; 520  : 
; 521  :         /* Build the name of the member referred to */
; 522  :         memcpy (refname, prefix, 3);

  008bf	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR refname$[rsp]
  008c7	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  008cf	48 8b f8	 mov	 rdi, rax
  008d2	48 8b f1	 mov	 rsi, rcx
  008d5	b9 03 00 00 00	 mov	 ecx, 3
  008da	f3 a4		 rep movsb

; 523  :         memcpy (refname + 3, svcnum, 3);

  008dc	48 8d 84 24 1b
	01 00 00	 lea	 rax, QWORD PTR refname$[rsp+3]
  008e4	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR svcnum$[rsp]
  008ec	48 8b f8	 mov	 rdi, rax
  008ef	48 8b f1	 mov	 rsi, rcx
  008f2	b9 03 00 00 00	 mov	 ecx, 3
  008f7	f3 a4		 rep movsb

; 524  :         memcpy (refname + 6, blkptr+xctloff, 2);

  008f9	48 63 44 24 70	 movsxd	 rax, DWORD PTR xctloff$[rsp]
  008fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00906	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0090a	66 89 84 24 1e
	01 00 00	 mov	 WORD PTR refname$[rsp+6], ax

; 525  :         make_asciiz (refnama, sizeof(refnama), refname, 8);

  00912	41 b9 08 00 00
	00		 mov	 r9d, 8
  00918	4c 8d 84 24 18
	01 00 00	 lea	 r8, QWORD PTR refname$[rsp]
  00920	ba 09 00 00 00	 mov	 edx, 9
  00925	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR refnama$[rsp]
  0092d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 526  : 
; 527  :         /* Find the referred member in the member array */
; 528  :         for (i = 0; i < nmem; i++)

  00933	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0093e	eb 10		 jmp	 SHORT $LN6@resolve_xc
$LN4@resolve_xc:
  00940	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00947	ff c0		 inc	 eax
  00949	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN6@resolve_xc:
  00950	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR nmem$[rsp]
  00957	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0095e	7d 38		 jge	 SHORT $LN5@resolve_xc

; 529  :         {
; 530  :             if (memcmp(memtab[i].memname, refname, 8) == 0)

  00960	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00968	48 6b c0 0f	 imul	 rax, rax, 15
  0096c	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  00974	48 03 c8	 add	 rcx, rax
  00977	48 8b c1	 mov	 rax, rcx
  0097a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00980	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR refname$[rsp]
  00988	48 8b c8	 mov	 rcx, rax
  0098b	e8 00 00 00 00	 call	 memcmp
  00990	85 c0		 test	 eax, eax
  00992	75 02		 jne	 SHORT $LN24@resolve_xc

; 531  :                 break;

  00994	eb 02		 jmp	 SHORT $LN5@resolve_xc
$LN24@resolve_xc:

; 532  :         } /* end for(i) */

  00996	eb a8		 jmp	 SHORT $LN4@resolve_xc
$LN5@resolve_xc:

; 533  : 
; 534  :         /* Loop if member not found */
; 535  :         if (i == nmem)

  00998	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR nmem$[rsp]
  0099f	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  009a6	0f 85 31 01 00
	00		 jne	 $LN25@resolve_xc

; 536  :         {
; 537  :             char buf[80];
; 538  :             MSGBUF( buf, " member '%s' not found", refnama);

  009ac	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR refnama$[rsp]
  009b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159917
  009bb	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  009c0	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  009c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 539  : 
; 540  :             /* Display XCTL table entry */
; 541  :             // "Member %s %s TTRL %02X%02X%02X%02X: %s"
; 542  :             WRMSG( HHC02462, "I", memnama, refnama,

  009ce	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  009d2	83 c0 05	 add	 eax, 5
  009d5	48 98		 cdqe
  009d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  009df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009e3	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv475[rsp], eax
  009ea	8b 4c 24 70	 mov	 ecx, DWORD PTR xctloff$[rsp]
  009ee	83 c1 04	 add	 ecx, 4
  009f1	48 63 c9	 movsxd	 rcx, ecx
  009f4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  009fc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00a00	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv481[rsp], ecx
  00a07	8b 54 24 70	 mov	 edx, DWORD PTR xctloff$[rsp]
  00a0b	83 c2 03	 add	 edx, 3
  00a0e	48 63 d2	 movsxd	 rdx, edx
  00a11	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR blkptr$[rsp]
  00a19	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00a1d	89 94 24 d8 00
	00 00		 mov	 DWORD PTR tv487[rsp], edx
  00a24	8b 7c 24 70	 mov	 edi, DWORD PTR xctloff$[rsp]
  00a28	83 c7 02	 add	 edi, 2
  00a2b	48 63 ff	 movsxd	 rdi, edi
  00a2e	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR blkptr$[rsp]
  00a36	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00a3a	b9 01 00 00 00	 mov	 ecx, 1
  00a3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a45	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00a4d	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00a52	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv475[rsp]
  00a59	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00a5d	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv481[rsp]
  00a64	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a68	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv487[rsp]
  00a6f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a73	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00a77	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR refnama$[rsp]
  00a7f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a84	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00a8c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a91	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159918
  00a98	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159919
  00aa4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aae	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ab4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159920
  00abb	ba 20 02 00 00	 mov	 edx, 544		; 00000220H
  00ac0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159921
  00ac7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 543  :                 blkptr[xctloff+2], blkptr[xctloff+3],
; 544  :                 blkptr[xctloff+4], blkptr[xctloff+5], buf );
; 545  : 
; 546  :             xctloff += 6;

  00acd	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00ad1	83 c0 06	 add	 eax, 6
  00ad4	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 547  :             continue;

  00ad8	e9 77 fc ff ff	 jmp	 $LN33@resolve_xc
$LN25@resolve_xc:

; 548  :         }
; 549  : 
; 550  :         /* Loop if TTRL in the XCTL table matches actual TTRL */
; 551  :         if (memcmp(blkptr+xctloff+2, memtab[i].ttrtext, 3) == 0
; 552  :             && blkptr[xctloff+5] == memtab[i].dwdsize)

  00add	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00ae5	48 6b c0 0f	 imul	 rax, rax, 15
  00ae9	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  00af1	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00af6	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR xctloff$[rsp]
  00afb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00b03	48 8d 4c 0a 02	 lea	 rcx, QWORD PTR [rdx+rcx+2]
  00b08	41 b8 03 00 00
	00		 mov	 r8d, 3
  00b0e	48 8b d0	 mov	 rdx, rax
  00b11	e8 00 00 00 00	 call	 memcmp
  00b16	85 c0		 test	 eax, eax
  00b18	0f 85 44 01 00
	00		 jne	 $LN26@resolve_xc
  00b1e	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00b22	83 c0 05	 add	 eax, 5
  00b25	48 98		 cdqe
  00b27	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00b2f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b33	48 63 8c 24 8c
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00b3b	48 6b c9 0f	 imul	 rcx, rcx, 15
  00b3f	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR memtab$[rsp]
  00b47	0f b6 4c 0a 0b	 movzx	 ecx, BYTE PTR [rdx+rcx+11]
  00b4c	3b c1		 cmp	 eax, ecx
  00b4e	0f 85 0e 01 00
	00		 jne	 $LN26@resolve_xc

; 553  :         {
; 554  :             /* Display XCTL table entry */
; 555  :             // "Member %s %s TTRL %02X%02X%02X%02X: %s"
; 556  :             WRMSG( HHC02462, "I", memnama, refnama,

  00b54	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00b58	83 c0 05	 add	 eax, 5
  00b5b	48 98		 cdqe
  00b5d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00b65	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b69	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv537[rsp], eax
  00b70	8b 4c 24 70	 mov	 ecx, DWORD PTR xctloff$[rsp]
  00b74	83 c1 04	 add	 ecx, 4
  00b77	48 63 c9	 movsxd	 rcx, ecx
  00b7a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00b82	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b86	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv543[rsp], ecx
  00b8d	8b 54 24 70	 mov	 edx, DWORD PTR xctloff$[rsp]
  00b91	83 c2 03	 add	 edx, 3
  00b94	48 63 d2	 movsxd	 rdx, edx
  00b97	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR blkptr$[rsp]
  00b9f	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00ba3	89 94 24 e4 00
	00 00		 mov	 DWORD PTR tv549[rsp], edx
  00baa	8b 7c 24 70	 mov	 edi, DWORD PTR xctloff$[rsp]
  00bae	83 c7 02	 add	 edi, 2
  00bb1	48 63 ff	 movsxd	 rdi, edi
  00bb4	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR blkptr$[rsp]
  00bbc	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00bc0	b9 01 00 00 00	 mov	 ecx, 1
  00bc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bcb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159923
  00bd2	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00bd7	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv537[rsp]
  00bde	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00be2	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv543[rsp]
  00be9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bed	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv549[rsp]
  00bf4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00bf8	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00bfc	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR refnama$[rsp]
  00c04	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00c09	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00c11	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159924
  00c1d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159925
  00c29	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c2e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c33	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c39	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159926
  00c40	ba 2e 02 00 00	 mov	 edx, 558		; 0000022eH
  00c45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159927
  00c4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 557  :                 blkptr[xctloff+2], blkptr[xctloff+3],
; 558  :                 blkptr[xctloff+4], blkptr[xctloff+5], "" );
; 559  : 
; 560  :             xctloff += 6;

  00c52	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00c56	83 c0 06	 add	 eax, 6
  00c59	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 561  :             continue;

  00c5d	e9 f2 fa ff ff	 jmp	 $LN34@resolve_xc
$LN26@resolve_xc:

; 562  :         }
; 563  : 
; 564  :         /* Flag entries whose L differs */
; 565  :         if (blkptr[xctloff+5] != memtab[i].dwdsize)

  00c62	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00c66	83 c0 05	 add	 eax, 5
  00c69	48 98		 cdqe
  00c6b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00c73	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c77	48 63 8c 24 8c
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c7f	48 6b c9 0f	 imul	 rcx, rcx, 15
  00c83	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR memtab$[rsp]
  00c8b	0f b6 4c 0a 0b	 movzx	 ecx, BYTE PTR [rdx+rcx+11]
  00c90	3b c1		 cmp	 eax, ecx
  00c92	74 0d		 je	 SHORT $LN27@resolve_xc

; 566  :             warn = 1;

  00c94	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR warn$[rsp], 1
  00c9f	eb 0b		 jmp	 SHORT $LN28@resolve_xc
$LN27@resolve_xc:

; 567  :         else
; 568  :             warn = 0;

  00ca1	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR warn$[rsp], 0
$LN28@resolve_xc:

; 569  : 
; 570  :         /* Replace TTRL in the XCTL table by the actual TTRL */
; 571  :         memcpy (blkptr+xctloff+2, memtab[i].ttrtext, 3);

  00cac	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00cb4	48 6b c0 0f	 imul	 rax, rax, 15
  00cb8	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR xctloff$[rsp]
  00cbd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00cc5	48 8b bc 24 20
	02 00 00	 mov	 rdi, QWORD PTR memtab$[rsp]
  00ccd	48 89 bc 24 00
	01 00 00	 mov	 QWORD PTR tv849[rsp], rdi
  00cd5	48 8d 7c 0a 02	 lea	 rdi, QWORD PTR [rdx+rcx+2]
  00cda	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv849[rsp]
  00ce2	48 8d 74 01 08	 lea	 rsi, QWORD PTR [rcx+rax+8]
  00ce7	b9 03 00 00 00	 mov	 ecx, 3
  00cec	f3 a4		 rep movsb

; 572  :         blkptr[xctloff+5] = memtab[i].dwdsize;

  00cee	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00cf6	48 6b c0 0f	 imul	 rax, rax, 15
  00cfa	8b 4c 24 70	 mov	 ecx, DWORD PTR xctloff$[rsp]
  00cfe	83 c1 05	 add	 ecx, 5
  00d01	48 63 c9	 movsxd	 rcx, ecx
  00d04	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00d0c	48 8b bc 24 20
	02 00 00	 mov	 rdi, QWORD PTR memtab$[rsp]
  00d14	0f b6 44 07 0b	 movzx	 eax, BYTE PTR [rdi+rax+11]
  00d19	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 573  : 
; 574  :         {
; 575  :             char buf[80];
; 576  :             MSGBUF( buf, " replaced by TTRL=%02X%02X%02X%02X %s",

  00d1c	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR warn$[rsp], 0
  00d24	74 11		 je	 SHORT $LN30@resolve_xc
  00d26	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159930
  00d2d	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv604[rsp], rax
  00d35	eb 0f		 jmp	 SHORT $LN31@resolve_xc
$LN30@resolve_xc:
  00d37	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159931
  00d3e	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv604[rsp], rax
$LN31@resolve_xc:
  00d46	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00d4a	83 c0 05	 add	 eax, 5
  00d4d	48 98		 cdqe
  00d4f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00d57	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d5b	8b 4c 24 70	 mov	 ecx, DWORD PTR xctloff$[rsp]
  00d5f	83 c1 04	 add	 ecx, 4
  00d62	48 63 c9	 movsxd	 rcx, ecx
  00d65	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00d6d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d71	8b 54 24 70	 mov	 edx, DWORD PTR xctloff$[rsp]
  00d75	83 c2 03	 add	 edx, 3
  00d78	48 63 d2	 movsxd	 rdx, edx
  00d7b	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR blkptr$[rsp]
  00d83	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00d87	8b 7c 24 70	 mov	 edi, DWORD PTR xctloff$[rsp]
  00d8b	83 c7 02	 add	 edi, 2
  00d8e	48 63 ff	 movsxd	 rdi, edi
  00d91	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR blkptr$[rsp]
  00d99	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00d9d	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR tv604[rsp]
  00da5	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00daa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00dae	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00db2	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00db6	44 8b cf	 mov	 r9d, edi
  00db9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159932
  00dc0	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00dc5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00dcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 577  :                 blkptr[xctloff+2], blkptr[xctloff+3],
; 578  :                 blkptr[xctloff+4], blkptr[xctloff+5],
; 579  :                 (warn ? "****" : ""));
; 580  :             /* Display XCTL table entry */
; 581  :             // "Member %s %s TTRL %02X%02X%02X%02X: %s"
; 582  :             WRMSG( HHC02462, "I", memnama, refnama,

  00dd3	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00dd7	83 c0 05	 add	 eax, 5
  00dda	48 98		 cdqe
  00ddc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00de4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00de8	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv637[rsp], eax
  00def	8b 4c 24 70	 mov	 ecx, DWORD PTR xctloff$[rsp]
  00df3	83 c1 04	 add	 ecx, 4
  00df6	48 63 c9	 movsxd	 rcx, ecx
  00df9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR blkptr$[rsp]
  00e01	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e05	89 8c 24 ec 00
	00 00		 mov	 DWORD PTR tv643[rsp], ecx
  00e0c	8b 54 24 70	 mov	 edx, DWORD PTR xctloff$[rsp]
  00e10	83 c2 03	 add	 edx, 3
  00e13	48 63 d2	 movsxd	 rdx, edx
  00e16	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR blkptr$[rsp]
  00e1e	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00e22	89 94 24 f0 00
	00 00		 mov	 DWORD PTR tv649[rsp], edx
  00e29	8b 7c 24 70	 mov	 edi, DWORD PTR xctloff$[rsp]
  00e2d	83 c7 02	 add	 edi, 2
  00e30	48 63 ff	 movsxd	 rdi, edi
  00e33	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR blkptr$[rsp]
  00e3b	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00e3f	b9 01 00 00 00	 mov	 ecx, 1
  00e44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e4a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00e52	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00e57	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv637[rsp]
  00e5e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00e62	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv643[rsp]
  00e69	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00e6d	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv649[rsp]
  00e74	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00e78	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00e7c	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR refnama$[rsp]
  00e84	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e89	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00e91	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159933
  00e9d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ea2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159934
  00ea9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00eae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00eb3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00eb9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159935
  00ec0	ba 48 02 00 00	 mov	 edx, 584		; 00000248H
  00ec5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159936
  00ecc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 583  :                 blkptr[xctloff+2], blkptr[xctloff+3],
; 584  :                 blkptr[xctloff+4], blkptr[xctloff+5], buf );
; 585  :         }
; 586  : 
; 587  :         /* Flag the track as modified to force rewrite */
; 588  :         cif->trkmodif = 1;

  00ed2	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00eda	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 589  : 
; 590  :         /* Point to next entry in XCTL table */
; 591  :         xctloff += 6;

  00ee1	8b 44 24 70	 mov	 eax, DWORD PTR xctloff$[rsp]
  00ee5	83 c0 06	 add	 eax, 6
  00ee8	89 44 24 70	 mov	 DWORD PTR xctloff$[rsp], eax

; 592  : 
; 593  :     } /* end while */

  00eec	e9 63 f8 ff ff	 jmp	 $LN35@resolve_xc
$LN3@resolve_xc:

; 594  : 
; 595  :     return 0;

  00ef1	33 c0		 xor	 eax, eax
$LN1@resolve_xc:

; 596  : } /* end function resolve_xctltab */

  00ef3	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00efb	48 33 cc	 xor	 rcx, rsp
  00efe	e8 00 00 00 00	 call	 __security_check_cookie
  00f03	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  00f0a	5f		 pop	 rdi
  00f0b	5e		 pop	 rsi
  00f0c	c3		 ret	 0
resolve_xctltab ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdisup.c
_TEXT	SEGMENT
i$ = 80
n$ = 84
dirrem$ = 88
dirent$ = 96
totlen$ = 104
dirptr$ = 112
size$ = 120
tv290 = 124
tv304 = 128
tv317 = 132
k$ = 136
txtlen$ = 140
tv188 = 144
memnama$ = 152
__$ArrayPad$ = 168
cif$ = 208
noext$ = 216
extent$ = 224
dirblk$ = 232
memtab$ = 240
nmem$ = 248
process_dirblk PROC

; 225  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@process_di:

; 226  : int             n;                      /* Member array subscript    */
; 227  : int             i;                      /* Array subscript           */
; 228  : int             totlen;                 /* Total module length       */
; 229  : int             txtlen;                 /* Length of 1st text block  */
; 230  : int             size;                   /* Size of directory entry   */
; 231  : int             k;                      /* Userdata halfword count   */
; 232  : BYTE           *dirptr;                 /* -> Next byte within block */
; 233  : int             dirrem;                 /* Number of bytes remaining */
; 234  : PDSDIR         *dirent;                 /* -> Directory entry        */
; 235  : char            memnama[9];             /* Member name (ASCIIZ)      */
; 236  : 
; 237  :     UNREFERENCED(cif);

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN4@process_di
$LN7@process_di:

; 238  :     UNREFERENCED(noext);

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN7@process_di
$LN10@process_di:

; 239  :     UNREFERENCED(extent);

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 fa		 jne	 SHORT $LN10@process_di

; 240  : 
; 241  :     /* Load number of bytes in directory block */
; 242  :     dirptr = dirblk;

  00040	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dirblk$[rsp]
  00048	48 89 44 24 70	 mov	 QWORD PTR dirptr$[rsp], rax

; 243  :     dirrem = (dirptr[0] << 8) | dirptr[1];

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 00	 imul	 rax, rax, 0
  00056	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0005b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005f	c1 e0 08	 shl	 eax, 8
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	48 6b c9 01	 imul	 rcx, rcx, 1
  0006b	48 8b 54 24 70	 mov	 rdx, QWORD PTR dirptr$[rsp]
  00070	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00074	0b c1		 or	 eax, ecx
  00076	89 44 24 58	 mov	 DWORD PTR dirrem$[rsp], eax

; 244  :     if (dirrem < 2 || dirrem > 256)

  0007a	83 7c 24 58 02	 cmp	 DWORD PTR dirrem$[rsp], 2
  0007f	7c 0a		 jl	 SHORT $LN21@process_di
  00081	81 7c 24 58 00
	01 00 00	 cmp	 DWORD PTR dirrem$[rsp], 256 ; 00000100H
  00089	7e 51		 jle	 SHORT $LN20@process_di
$LN21@process_di:

; 245  :     {
; 246  :         // "Directory block byte count is invalid"
; 247  :         FWRMSG( stderr, HHC02400, "E" );

  0008b	b9 02 00 00 00	 mov	 ecx, 2
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159766
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159767
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159768
  000c0	ba f7 00 00 00	 mov	 edx, 247		; 000000f7H
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159769
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 248  :         return -1;

  000d2	b8 ff ff ff ff	 mov	 eax, -1
  000d7	e9 5a 06 00 00	 jmp	 $LN1@process_di
$LN20@process_di:

; 249  :     }
; 250  : 
; 251  :     /* Point to first directory entry */
; 252  :     dirptr += 2;

  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR dirptr$[rsp]
  000e1	48 83 c0 02	 add	 rax, 2
  000e5	48 89 44 24 70	 mov	 QWORD PTR dirptr$[rsp], rax

; 253  :     dirrem -= 2;

  000ea	8b 44 24 58	 mov	 eax, DWORD PTR dirrem$[rsp]
  000ee	83 e8 02	 sub	 eax, 2
  000f1	89 44 24 58	 mov	 DWORD PTR dirrem$[rsp], eax

; 254  : 
; 255  :     /* Process each directory entry */
; 256  :     for (n = *nmem; dirrem > 0; )

  000f5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR nmem$[rsp]
  000fd	8b 00		 mov	 eax, DWORD PTR [rax]
  000ff	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
$LN11@process_di:
  00103	83 7c 24 58 00	 cmp	 DWORD PTR dirrem$[rsp], 0
  00108	0f 8e 26 06 00
	00		 jle	 $LN12@process_di

; 257  :     {
; 258  :         /* Point to next directory entry */
; 259  :         dirent = (PDSDIR*)dirptr;

  0010e	48 8b 44 24 70	 mov	 rax, QWORD PTR dirptr$[rsp]
  00113	48 89 44 24 60	 mov	 QWORD PTR dirent$[rsp], rax

; 260  : 
; 261  :         /* Test for end of directory */
; 262  :         if (memcmp( dirent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  0011d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	e8 00 00 00 00	 call	 memcmp
  00132	85 c0		 test	 eax, eax
  00134	75 0a		 jne	 SHORT $LN22@process_di

; 263  :             return +1;

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	e9 f6 05 00 00	 jmp	 $LN1@process_di
$LN22@process_di:

; 264  : 
; 265  :         /* Load the user data halfword count */
; 266  :         k = dirent->pds2indc & PDS2INDC_LUSR;

  00140	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  00145	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00149	83 e0 1f	 and	 eax, 31
  0014c	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 267  : 
; 268  :         /* Point to next directory entry */
; 269  :         size = 12 + k*2;

  00153	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0015a	8d 44 00 0c	 lea	 eax, DWORD PTR [rax+rax+12]
  0015e	89 44 24 78	 mov	 DWORD PTR size$[rsp], eax

; 270  :         dirptr += size;

  00162	48 63 44 24 78	 movsxd	 rax, DWORD PTR size$[rsp]
  00167	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 89 44 24 70	 mov	 QWORD PTR dirptr$[rsp], rax

; 271  :         dirrem -= size;

  00177	8b 44 24 78	 mov	 eax, DWORD PTR size$[rsp]
  0017b	8b 4c 24 58	 mov	 ecx, DWORD PTR dirrem$[rsp]
  0017f	2b c8		 sub	 ecx, eax
  00181	8b c1		 mov	 eax, ecx
  00183	89 44 24 58	 mov	 DWORD PTR dirrem$[rsp], eax

; 272  : 
; 273  :         /* Extract the member name */
; 274  :         make_asciiz (memnama, sizeof(memnama), dirent->pds2name, 8);

  00187	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  0018c	41 b9 08 00 00
	00		 mov	 r9d, 8
  00192	4c 8b c0	 mov	 r8, rax
  00195	ba 09 00 00 00	 mov	 edx, 9
  0019a	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 275  :         if (dirent->pds2name[7] == OVERPUNCH_ZERO)

  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 07	 imul	 rax, rax, 7
  001b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirent$[rsp]
  001b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ba	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  001bf	75 11		 jne	 SHORT $LN23@process_di

; 276  :             memnama[7] = '{';

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	48 6b c0 07	 imul	 rax, rax, 7
  001ca	c6 84 04 98 00
	00 00 7b	 mov	 BYTE PTR memnama$[rsp+rax], 123 ; 0000007bH
$LN23@process_di:

; 277  : 
; 278  :         /* Find member in first load table */
; 279  :         for (i = 0; firstload[i] != NULL; i++)

  001d2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001da	eb 0a		 jmp	 SHORT $LN16@process_di
$LN14@process_di:
  001dc	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  001e0	ff c0		 inc	 eax
  001e2	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN16@process_di:
  001e6	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstload
  001f2	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  001f7	74 25		 je	 SHORT $LN15@process_di

; 280  :             if (strcmp(memnama, firstload[i]) == 0) break;

  001f9	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstload
  00205	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00209	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00211	e8 00 00 00 00	 call	 strcmp
  00216	85 c0		 test	 eax, eax
  00218	75 02		 jne	 SHORT $LN24@process_di
  0021a	eb 02		 jmp	 SHORT $LN15@process_di
$LN24@process_di:
  0021c	eb be		 jmp	 SHORT $LN14@process_di
$LN15@process_di:

; 281  : 
; 282  :         /* If not in first table, find in second table */
; 283  :         if (firstload[i] == NULL)

  0021e	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstload
  0022a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0022f	0f 85 01 01 00
	00		 jne	 $LN25@process_di

; 284  :         {
; 285  :             for (i = 0; secondload[i] != NULL; i++)

  00235	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0023d	eb 0a		 jmp	 SHORT $LN19@process_di
$LN17@process_di:
  0023f	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00243	ff c0		 inc	 eax
  00245	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN19@process_di:
  00249	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:secondload
  00255	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0025a	74 2b		 je	 SHORT $LN18@process_di

; 286  :                 if (memcmp(memnama, secondload[i], 6) == 0) break;

  0025c	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:secondload
  00268	41 b8 06 00 00
	00		 mov	 r8d, 6
  0026e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00272	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0027a	e8 00 00 00 00	 call	 memcmp
  0027f	85 c0		 test	 eax, eax
  00281	75 02		 jne	 SHORT $LN26@process_di
  00283	eb 02		 jmp	 SHORT $LN18@process_di
$LN26@process_di:
  00285	eb b8		 jmp	 SHORT $LN17@process_di
$LN18@process_di:

; 287  : 
; 288  :             /* If not in second table then skip member */
; 289  :             if (secondload[i] == NULL)

  00287	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:secondload
  00293	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00298	0f 85 98 00 00
	00		 jne	 $LN27@process_di

; 290  :             {
; 291  :                 // "Member %s type %s skipped"
; 292  :                 WRMSG( HHC02450, "I", memnama,

  0029e	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  002a3	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  002a7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ac	85 c0		 test	 eax, eax
  002ae	74 11		 je	 SHORT $LN34@process_di
  002b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159776
  002b7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  002bf	eb 0f		 jmp	 SHORT $LN35@process_di
$LN34@process_di:
  002c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159777
  002c8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
$LN35@process_di:
  002d0	b9 01 00 00 00	 mov	 ecx, 1
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002db	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv188[rsp]
  002e3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002e8	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  002f0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159778
  002fc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159779
  00308	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00312	41 b9 03 00 00
	00		 mov	 r9d, 3
  00318	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159780
  0031f	ba 26 01 00 00	 mov	 edx, 294		; 00000126H
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159781
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 293  :                         ((dirent->pds2indc & PDS2INDC_ALIAS) ?
; 294  :                         "alias" : "member" ));
; 295  :                 continue;

  00331	e9 cd fd ff ff	 jmp	 $LN11@process_di
$LN27@process_di:
$LN25@process_di:

; 296  :             }
; 297  : 
; 298  :         } /* end if(firstload[i]==NULL) */
; 299  : 
; 300  :         /* Check that member information array is not full */
; 301  :         if (n >= MAX_MEMBERS)

  00336	81 7c 24 54 e8
	03 00 00	 cmp	 DWORD PTR n$[rsp], 1000	; 000003e8H
  0033e	7c 51		 jl	 SHORT $LN28@process_di

; 302  :         {
; 303  :             // "Too many members"
; 304  :             FWRMSG( stderr, HHC02451, "W" );

  00340	b9 02 00 00 00	 mov	 ecx, 2
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159783
  00352	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159784
  0035e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00363	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00368	41 b9 03 00 00
	00		 mov	 r9d, 3
  0036e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159785
  00375	ba 30 01 00 00	 mov	 edx, 304		; 00000130H
  0037a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159786
  00381	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 305  :             return -1;

  00387	b8 ff ff ff ff	 mov	 eax, -1
  0038c	e9 a5 03 00 00	 jmp	 $LN1@process_di
$LN28@process_di:

; 306  :         }
; 307  : 
; 308  :         /* Check that user data contains at least 1 TTR */
; 309  :         if (((dirent->pds2indc & PDS2INDC_NTTR) >> PDS2INDC_NTTR_SHIFT)
; 310  :                 < 1)

  00391	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  00396	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0039a	83 e0 60	 and	 eax, 96			; 00000060H
  0039d	c1 f8 05	 sar	 eax, 5
  003a0	83 f8 01	 cmp	 eax, 1
  003a3	7d 5e		 jge	 SHORT $LN29@process_di

; 311  :         {
; 312  :             // "Member %s has TTR count zero"
; 313  :             FWRMSG( stderr, HHC02452, "E", memnama );

  003a5	b9 02 00 00 00	 mov	 ecx, 2
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b0	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  003b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159788
  003c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159789
  003d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003da	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159790
  003e7	ba 39 01 00 00	 mov	 edx, 313		; 00000139H
  003ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159791
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 314  :             return -1;

  003f9	b8 ff ff ff ff	 mov	 eax, -1
  003fe	e9 33 03 00 00	 jmp	 $LN1@process_di
$LN29@process_di:

; 315  :         }
; 316  : 
; 317  :         /* Extract the total module length */
; 318  :         totlen = (dirent->pds2usrd[10] << 16)

  00403	b8 01 00 00 00	 mov	 eax, 1
  00408	48 6b c0 0a	 imul	 rax, rax, 10
  0040c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirent$[rsp]
  00411	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  00416	c1 e0 10	 shl	 eax, 16
  00419	b9 01 00 00 00	 mov	 ecx, 1
  0041e	48 6b c9 0b	 imul	 rcx, rcx, 11
  00422	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirent$[rsp]
  00427	0f b6 4c 0a 0c	 movzx	 ecx, BYTE PTR [rdx+rcx+12]
  0042c	c1 e1 08	 shl	 ecx, 8
  0042f	0b c1		 or	 eax, ecx
  00431	b9 01 00 00 00	 mov	 ecx, 1
  00436	48 6b c9 0c	 imul	 rcx, rcx, 12
  0043a	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirent$[rsp]
  0043f	0f b6 4c 0a 0c	 movzx	 ecx, BYTE PTR [rdx+rcx+12]
  00444	0b c1		 or	 eax, ecx
  00446	89 44 24 68	 mov	 DWORD PTR totlen$[rsp], eax

; 319  :                 | (dirent->pds2usrd[11] << 8)
; 320  :                 | dirent->pds2usrd[12];
; 321  : 
; 322  :         /* Extract the length of the first text block */
; 323  :         txtlen = (dirent->pds2usrd[13] << 8)

  0044a	b8 01 00 00 00	 mov	 eax, 1
  0044f	48 6b c0 0d	 imul	 rax, rax, 13
  00453	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirent$[rsp]
  00458	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0045d	c1 e0 08	 shl	 eax, 8
  00460	b9 01 00 00 00	 mov	 ecx, 1
  00465	48 6b c9 0e	 imul	 rcx, rcx, 14
  00469	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirent$[rsp]
  0046e	0f b6 4c 0a 0c	 movzx	 ecx, BYTE PTR [rdx+rcx+12]
  00473	0b c1		 or	 eax, ecx
  00475	89 84 24 8c 00
	00 00		 mov	 DWORD PTR txtlen$[rsp], eax

; 324  :                 | dirent->pds2usrd[14];
; 325  : 
; 326  :         /* Save member information in the array */
; 327  :         memcpy (memtab[n].memname, dirent->pds2name, 8);

  0047c	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00481	48 6b c0 0f	 imul	 rax, rax, 15
  00485	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  0048d	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirent$[rsp]
  00492	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00495	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 328  :         memcpy (memtab[n].ttrtext, dirent->pds2usrd + 0, 3);

  00499	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0049e	48 6b c0 0f	 imul	 rax, rax, 15
  004a2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  004aa	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirent$[rsp]
  004af	48 8d 7c 01 08	 lea	 rdi, QWORD PTR [rcx+rax+8]
  004b4	48 8d 72 0c	 lea	 rsi, QWORD PTR [rdx+12]
  004b8	b9 03 00 00 00	 mov	 ecx, 3
  004bd	f3 a4		 rep movsb

; 329  :         memtab[n].dwdsize = totlen / 8;

  004bf	8b 44 24 68	 mov	 eax, DWORD PTR totlen$[rsp]
  004c3	99		 cdq
  004c4	83 e2 07	 and	 edx, 7
  004c7	03 c2		 add	 eax, edx
  004c9	c1 f8 03	 sar	 eax, 3
  004cc	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR n$[rsp]
  004d1	48 6b c9 0f	 imul	 rcx, rcx, 15
  004d5	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR memtab$[rsp]
  004dd	88 44 0a 0b	 mov	 BYTE PTR [rdx+rcx+11], al

; 330  : 
; 331  :         /* Flag the member if it is an alias */
; 332  :         memtab[n].alias = (dirent->pds2indc & PDS2INDC_ALIAS) ? 1 : 0;

  004e1	48 8b 44 24 60	 mov	 rax, QWORD PTR dirent$[rsp]
  004e6	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  004ea	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004ef	85 c0		 test	 eax, eax
  004f1	74 0a		 je	 SHORT $LN36@process_di
  004f3	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
  004fb	eb 08		 jmp	 SHORT $LN37@process_di
$LN36@process_di:
  004fd	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
$LN37@process_di:
  00505	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0050a	48 6b c0 0f	 imul	 rax, rax, 15
  0050e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  00516	0f b6 54 24 7c	 movzx	 edx, BYTE PTR tv290[rsp]
  0051b	88 54 01 0c	 mov	 BYTE PTR [rcx+rax+12], dl

; 333  : 
; 334  :         /* Flag member if 7th character of name is non-numeric */
; 335  :         memtab[n].notable = (memnama[6] < '0' || memnama[6] > '9') ?

  0051f	b8 01 00 00 00	 mov	 eax, 1
  00524	48 6b c0 06	 imul	 rax, rax, 6
  00528	0f be 84 04 98
	00 00 00	 movsx	 eax, BYTE PTR memnama$[rsp+rax]
  00530	83 f8 30	 cmp	 eax, 48			; 00000030H
  00533	7c 23		 jl	 SHORT $LN38@process_di
  00535	b8 01 00 00 00	 mov	 eax, 1
  0053a	48 6b c0 06	 imul	 rax, rax, 6
  0053e	0f be 84 04 98
	00 00 00	 movsx	 eax, BYTE PTR memnama$[rsp+rax]
  00546	83 f8 39	 cmp	 eax, 57			; 00000039H
  00549	7f 0d		 jg	 SHORT $LN38@process_di
  0054b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv304[rsp], 0
  00556	eb 0b		 jmp	 SHORT $LN39@process_di
$LN38@process_di:
  00558	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv304[rsp], 1
$LN39@process_di:
  00563	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00568	48 6b c0 0f	 imul	 rax, rax, 15
  0056c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  00574	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR tv304[rsp]
  0057c	88 54 01 0d	 mov	 BYTE PTR [rcx+rax+13], dl

; 336  :                                                                 1 : 0;
; 337  : 
; 338  :         /* Check that the member has a single text record */
; 339  :         memtab[n].multitxt = ((dirent->pds2usrd[8] & 0x01) == 0 || totlen != txtlen) ? 1 : 0;

  00580	b8 01 00 00 00	 mov	 eax, 1
  00585	48 6b c0 08	 imul	 rax, rax, 8
  00589	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirent$[rsp]
  0058e	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  00593	83 e0 01	 and	 eax, 1
  00596	85 c0		 test	 eax, eax
  00598	74 1a		 je	 SHORT $LN40@process_di
  0059a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR txtlen$[rsp]
  005a1	39 44 24 68	 cmp	 DWORD PTR totlen$[rsp], eax
  005a5	75 0d		 jne	 SHORT $LN40@process_di
  005a7	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv317[rsp], 0
  005b2	eb 0b		 jmp	 SHORT $LN41@process_di
$LN40@process_di:
  005b4	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv317[rsp], 1
$LN41@process_di:
  005bf	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  005c4	48 6b c0 0f	 imul	 rax, rax, 15
  005c8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  005d0	0f b6 94 24 84
	00 00 00	 movzx	 edx, BYTE PTR tv317[rsp]
  005d8	88 54 01 0e	 mov	 BYTE PTR [rcx+rax+14], dl

; 340  :         if (memtab[n].multitxt)

  005dc	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  005e1	48 6b c0 0f	 imul	 rax, rax, 15
  005e5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR memtab$[rsp]
  005ed	0f b6 44 01 0e	 movzx	 eax, BYTE PTR [rcx+rax+14]
  005f2	85 c0		 test	 eax, eax
  005f4	74 54		 je	 SHORT $LN30@process_di

; 341  :         {
; 342  :             // "Member %s is not a single text record"
; 343  :             FWRMSG( stderr, HHC02453, "W", memnama );

  005f6	b9 02 00 00 00	 mov	 ecx, 2
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00601	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  00609	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0060e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159793
  00615	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0061a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159794
  00621	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00626	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0062b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00631	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159795
  00638	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  0063d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159796
  00644	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@process_di:

; 344  :         }
; 345  : 
; 346  :         /* Check that the total module length does not exceed X'7F8' */
; 347  :         if (totlen > 255*8)

  0064a	81 7c 24 68 f8
	07 00 00	 cmp	 DWORD PTR totlen$[rsp], 2040 ; 000007f8H
  00652	7e 5c		 jle	 SHORT $LN31@process_di

; 348  :         {
; 349  :             // "Member %s size %04X exceeds limit 07F8"
; 350  :             FWRMSG( stderr, HHC02454, "W", memnama, totlen );

  00654	b9 02 00 00 00	 mov	 ecx, 2
  00659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0065f	8b 4c 24 68	 mov	 ecx, DWORD PTR totlen$[rsp]
  00663	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00667	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  0066f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00674	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159798
  0067b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00680	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159799
  00687	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0068c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00691	41 b9 03 00 00
	00		 mov	 r9d, 3
  00697	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159800
  0069e	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  006a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159801
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@process_di:

; 351  :         }
; 352  : 
; 353  :         /* Check that the total module length is a multiple of 8 */
; 354  :         if (totlen & 0x7)

  006b0	8b 44 24 68	 mov	 eax, DWORD PTR totlen$[rsp]
  006b4	83 e0 07	 and	 eax, 7
  006b7	85 c0		 test	 eax, eax
  006b9	74 5c		 je	 SHORT $LN32@process_di

; 355  :         {
; 356  :             // "Member %s size %04X is not a multiple of 8"
; 357  :             FWRMSG( stderr, HHC02455, "W", memnama, totlen );

  006bb	b9 02 00 00 00	 mov	 ecx, 2
  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c6	8b 4c 24 68	 mov	 ecx, DWORD PTR totlen$[rsp]
  006ca	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006ce	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR memnama$[rsp]
  006d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159803
  006e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159804
  006ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  006fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159805
  00705	ba 65 01 00 00	 mov	 edx, 357		; 00000165H
  0070a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159806
  00711	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@process_di:

; 358  :         }
; 359  : 
; 360  :         /* Increment number of entries in table */
; 361  :         *nmem = ++n;

  00717	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  0071b	ff c0		 inc	 eax
  0071d	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
  00721	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR nmem$[rsp]
  00729	8b 4c 24 54	 mov	 ecx, DWORD PTR n$[rsp]
  0072d	89 08		 mov	 DWORD PTR [rax], ecx

; 362  : 
; 363  :     } /* end for */

  0072f	e9 cf f9 ff ff	 jmp	 $LN11@process_di
$LN12@process_di:

; 364  : 
; 365  :     return 0;

  00734	33 c0		 xor	 eax, eax
$LN1@process_di:

; 366  : 
; 367  : } /* end function process_dirblk */

  00736	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0073e	48 33 cc	 xor	 rcx, rsp
  00741	e8 00 00 00 00	 call	 __security_check_cookie
  00746	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0074d	5f		 pop	 rdi
  0074e	5e		 pop	 rsi
  0074f	c3		 ret	 0
process_dirblk ENDP
_TEXT	ENDS
END
