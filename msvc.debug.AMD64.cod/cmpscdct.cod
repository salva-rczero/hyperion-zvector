; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_maddr_l
PUBLIC	s370_GetDCT
PUBLIC	s370_GetECE
PUBLIC	s370_GetCCE
PUBLIC	s370_GetSD0
PUBLIC	s370_GetSD1
PUBLIC	s390_maddr_l
PUBLIC	s390_GetDCT
PUBLIC	s390_GetECE
PUBLIC	s390_GetCCE
PUBLIC	s390_GetSD0
PUBLIC	s390_GetSD1
PUBLIC	z900_maddr_l
PUBLIC	z900_GetDCT
PUBLIC	z900_GetECE
PUBLIC	z900_GetCCE
PUBLIC	z900_GetSD0
PUBLIC	z900_GetSD1
EXTRN	_byteswap_uint64:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$s370_GetDCT DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$s370_GetDCT
$pdata$s370_GetECE DD imagerel $LN10
	DD	imagerel $LN10+403
	DD	imagerel $unwind$s370_GetECE
$pdata$s370_GetCCE DD imagerel $LN17
	DD	imagerel $LN17+930
	DD	imagerel $unwind$s370_GetCCE
$pdata$s370_GetSD0 DD imagerel $LN9
	DD	imagerel $LN9+386
	DD	imagerel $unwind$s370_GetSD0
$pdata$s370_GetSD1 DD imagerel $LN11
	DD	imagerel $LN11+507
	DD	imagerel $unwind$s370_GetSD1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$s390_GetDCT DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$s390_GetDCT
$pdata$s390_GetECE DD imagerel $LN10
	DD	imagerel $LN10+403
	DD	imagerel $unwind$s390_GetECE
$pdata$s390_GetCCE DD imagerel $LN17
	DD	imagerel $LN17+930
	DD	imagerel $unwind$s390_GetCCE
$pdata$s390_GetSD0 DD imagerel $LN9
	DD	imagerel $LN9+386
	DD	imagerel $unwind$s390_GetSD0
$pdata$s390_GetSD1 DD imagerel $LN11
	DD	imagerel $LN11+507
	DD	imagerel $unwind$s390_GetSD1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
pdata	SEGMENT
$pdata$z900_GetDCT DD imagerel $LN4
	DD	imagerel $LN4+188
	DD	imagerel $unwind$z900_GetDCT
$pdata$z900_GetECE DD imagerel $LN10
	DD	imagerel $LN10+403
	DD	imagerel $unwind$z900_GetECE
$pdata$z900_GetCCE DD imagerel $LN17
	DD	imagerel $LN17+930
	DD	imagerel $unwind$z900_GetCCE
$pdata$z900_GetSD0 DD imagerel $LN9
	DD	imagerel $LN9+386
	DD	imagerel $unwind$z900_GetSD0
$pdata$z900_GetSD1 DD imagerel $LN11
	DD	imagerel $LN11+507
	DD	imagerel $unwind$z900_GetSD1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_GetDCT DD 010e01H
	DD	0820eH
$unwind$s370_GetECE DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$s370_GetCCE DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s370_GetSD0 DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$s370_GetSD1 DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$s390_GetDCT DD 010e01H
	DD	0820eH
$unwind$s390_GetECE DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$s390_GetCCE DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$s390_GetSD0 DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$s390_GetSD1 DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$z900_GetDCT DD 010e01H
	DD	0820eH
$unwind$z900_GetECE DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$z900_GetCCE DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$z900_GetSD0 DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$z900_GetSD1 DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
sd2$1 = 48
tv84 = 56
index$ = 96
pSDEBLK$ = 104
z900_GetSD1 PROC

; 231  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 232  :     register U64 sd1;
; 233  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 234  : 
; 235  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@z900_GetSD

; 236  :     {
; 237  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 238  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 99 01 00 00	 jmp	 $LN1@z900_GetSD
$LN2@z900_GetSD:

; 239  :     }
; 240  : 
; 241  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 z900_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 242  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 243  : 
; 244  :     if (!(pSDE->sct = SD1_U8R( 0, 4 )) || pSDE->sct >= 15)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3c	 shr	 rax, 60			; 0000003cH
  00084	48 83 e0 0f	 and	 rax, 15
  00088	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@z900_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 0f	 cmp	 eax, 15
  000af	7c 12		 jl	 SHORT $LN3@z900_GetSD
$LN4@z900_GetSD:

; 245  :     {
; 246  :         pSDE->sct = 14;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 0e	 mov	 BYTE PTR [rax+18], 14

; 247  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@z900_GetSD:

; 248  :     }
; 249  : 
; 250  :     // Examine child bits for children 1 to 12
; 251  : 
; 252  :     pSDE->ecb = SD1_U16L( 4, 12 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2c	 shr	 rax, 44			; 0000002cH
  000cc	48 25 f0 ff 00
	00		 and	 rax, 65520		; 0000fff0H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 253  : 
; 254  :     // If children exist append examine child bits for
; 255  :     // children 13 and 14 which are in the parent CCE
; 256  :     // so they are all in one place (simpler testing).
; 257  :     //
; 258  :     // Note: this only applies for the FIRST sibling
; 259  :     // of the parent. Examine child bits for children
; 260  :     // 13 and 14 do not exist for subsequent siblings
; 261  :     // of parent and thus must ALWAYS be examined.
; 262  : 
; 263  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@z900_GetSD

; 264  :     {
; 265  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@z900_GetSD

; 266  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 12;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 0c	 sar	 eax, 12
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@z900_GetSD:

; 267  :     }

  0011f	eb 15		 jmp	 SHORT $LN6@z900_GetSD
$LN5@z900_GetSD:

; 268  :     else // (force child to ALWAYS be examined)
; 269  :     {
; 270  :         pSDE->ecb |= 0xFFFF >> 12;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	83 c8 0f	 or	 eax, 15
  0012d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00132	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@z900_GetSD:

; 271  :     }
; 272  : 
; 273  :     sd1 <<= 16;                               // (first 6 bytes)

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013b	48 c1 e0 10	 shl	 rax, 16
  0013f	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 274  : 
; 275  :     if (pSDE->sct <= 6)

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00149	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  0014d	83 f8 06	 cmp	 eax, 6
  00150	7f 14		 jg	 SHORT $LN8@z900_GetSD

; 276  :         pSDE->sc_dw = CSWAP64( sd1 );         // (only 6 bytes)

  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  00157	e8 00 00 00 00	 call	 _byteswap_uint64
  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00161	48 89 01	 mov	 QWORD PTR [rcx], rax
  00164	eb 64		 jmp	 SHORT $LN9@z900_GetSD
$LN8@z900_GetSD:

; 277  :     else
; 278  :     {
; 279  :         register U64 sd2 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK2 );

  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  0016b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0016f	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00174	e8 00 00 00 00	 call	 z900_GetDCT
  00179	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 280  : 
; 281  :         sd1 |= sd2 >> (64-16);                // (append 2 more)

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  00183	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00187	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0018c	48 0b c8	 or	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 282  :         pSDE->sc_dw= CSWAP64( sd1 );          // (store first 8)

  00197	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_uint64
  001a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001a6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 283  : 
; 284  :         sd2 <<= 16;                           // (next 6 bytes)

  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  001ae	48 c1 e0 10	 shl	 rax, 16
  001b2	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 285  :         pSDE->sc_dw2 = CSWAP64( sd2 );        // (store next 6)

  001b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sd2$1[rsp]
  001bc	e8 00 00 00 00	 call	 _byteswap_uint64
  001c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001c6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN9@z900_GetSD:

; 286  :     }
; 287  : 
; 288  :     pSDE->cached = TRUE;

  001ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  001cf	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 289  :     pSDEBLK->sde[ index ] = *pSDE;

  001d3	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  001d8	48 6b c0 18	 imul	 rax, rax, 24
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  001e1	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  001e6	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  001eb	b9 18 00 00 00	 mov	 ecx, 24
  001f0	f3 a4		 rep movsb

; 290  : 
; 291  :     return TRUE;

  001f2	b0 01		 mov	 al, 1
$LN1@z900_GetSD:

; 292  : }

  001f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f8	5f		 pop	 rdi
  001f9	5e		 pop	 rsi
  001fa	c3		 ret	 0
z900_GetSD1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
tv84 = 48
index$ = 96
pSDEBLK$ = 104
z900_GetSD0 PROC

; 175  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 176  :     register U64 sd1;
; 177  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 178  : 
; 179  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@z900_GetSD

; 180  :     {
; 181  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 182  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 20 01 00 00	 jmp	 $LN1@z900_GetSD
$LN2@z900_GetSD:

; 183  :     }
; 184  : 
; 185  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 z900_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 186  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 187  : 
; 188  :     if (!(pSDE->sct = SD1_U8R( 0, 3 )) || pSDE->sct >= 7)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00084	48 83 e0 07	 and	 rax, 7
  00088	48 89 44 24 30	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@z900_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 07	 cmp	 eax, 7
  000af	7c 12		 jl	 SHORT $LN3@z900_GetSD
$LN4@z900_GetSD:

; 189  :     {
; 190  :         pSDE->sct = 7;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 07	 mov	 BYTE PTR [rax+18], 7

; 191  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@z900_GetSD:

; 192  :     }
; 193  : 
; 194  :     // Examine child bits for children 1 to 5
; 195  : 
; 196  :     pSDE->ecb = SD1_U16L( 3, 5 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  000cc	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 197  : 
; 198  :     // If children exist append examine child bits for
; 199  :     // children 6 and 7 which are in the parent CCE so
; 200  :     // they're all in one place (makes things easier).
; 201  :     //
; 202  :     // Note: this only applies for the FIRST sibling
; 203  :     // of the parent. Examine child bits for children
; 204  :     // 6 and 7 do not exist for subsequent siblings
; 205  :     // of parent and thus must ALWAYS be examined.
; 206  : 
; 207  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@z900_GetSD

; 208  :     {
; 209  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@z900_GetSD

; 210  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 5;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 05	 sar	 eax, 5
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@z900_GetSD:

; 211  :     }

  0011f	eb 17		 jmp	 SHORT $LN6@z900_GetSD
$LN5@z900_GetSD:

; 212  :     else // (force child to ALWAYS be examined)
; 213  :     {
; 214  :         pSDE->ecb |= 0xFFFF >> 5;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	0d ff 07 00 00	 or	 eax, 2047		; 000007ffH
  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00134	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@z900_GetSD:

; 215  :     }
; 216  : 
; 217  :     pSDE->sc_dw = CSWAP64( sd1 << 8 );

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013d	48 c1 e0 08	 shl	 rax, 8
  00141	48 8b c8	 mov	 rcx, rax
  00144	e8 00 00 00 00	 call	 _byteswap_uint64
  00149	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0014e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 218  : 
; 219  :     pSDE->cached = TRUE;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00156	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 220  :     pSDEBLK->sde[ index ] = *pSDE;

  0015a	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0015f	48 6b c0 18	 imul	 rax, rax, 24
  00163	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00168	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  0016d	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  00172	b9 18 00 00 00	 mov	 ecx, 24
  00177	f3 a4		 rep movsb

; 221  : 
; 222  :     return TRUE;

  00179	b0 01		 mov	 al, 1
$LN1@z900_GetSD:

; 223  : }

  0017b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017f	5f		 pop	 rdi
  00180	5e		 pop	 rsi
  00181	c3		 ret	 0
z900_GetSD0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
wrk$1 = 32
pCCE$ = 40
wrk$2 = 48
cce$ = 56
tv234 = 64
tv84 = 72
tv90 = 80
tv144 = 88
tv179 = 96
index$ = 144
pCCEBLK$ = 152
z900_GetCCE PROC

; 90   : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 91   :     register U64 cce;
; 92   :     register CCE* pCCE = pCCEBLK->pCCE;

  00010	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 28	 mov	 QWORD PTR pCCE$[rsp], rax

; 93   : 
; 94   :     if (pCCEBLK->cce[ index ].cached)

  00021	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00029	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0002d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00035	0f b6 44 01 31	 movzx	 eax, BYTE PTR [rcx+rax+49]
  0003a	85 c0		 test	 eax, eax
  0003c	74 2c		 je	 SHORT $LN2@z900_GetCC

; 95   :     {
; 96   :         *pCCE = pCCEBLK->cce[ index ];

  0003e	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00046	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00052	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pCCE$[rsp]
  00057	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0005c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00061	f3 a4		 rep movsb

; 97   :         return TRUE;

  00063	b0 01		 mov	 al, 1
  00065	e9 31 03 00 00	 jmp	 $LN1@z900_GetCC
$LN2@z900_GetCC:

; 98   :     }
; 99   : 
; 100  :     cce = ARCH_DEP( GetDCT )( index, pCCEBLK->pDCTBLK );

  0006a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00072	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00075	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR index$[rsp]
  0007d	e8 00 00 00 00	 call	 z900_GetDCT
  00082	48 89 44 24 38	 mov	 QWORD PTR cce$[rsp], rax

; 101  :     pCCE->mc = FALSE;

  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0008c	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 102  : 
; 103  :     if (!(pCCE->cct = CCE_U8R( 0, 3 )))  // (no children)

  00090	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00095	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00099	48 83 e0 07	 and	 rax, 7
  0009d	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000a7	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv84[rsp]
  000ac	88 48 16	 mov	 BYTE PTR [rax+22], cl
  000af	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv84[rsp]
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 8b 00 00
	00		 jne	 $LN3@z900_GetCC

; 104  :     {
; 105  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 5)

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000c1	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  000c5	48 83 e0 07	 and	 rax, 7
  000c9	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000d3	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv90[rsp]
  000d8	88 48 17	 mov	 BYTE PTR [rax+23], cl
  000db	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv90[rsp]
  000e0	83 f8 05	 cmp	 eax, 5
  000e3	7e 07		 jle	 SHORT $LN4@z900_GetCC

; 106  :             return FALSE;

  000e5	32 c0		 xor	 al, al
  000e7	e9 af 02 00 00	 jmp	 $LN1@z900_GetCC
$LN4@z900_GetCC:

; 107  : 
; 108  :         if (pCCE->act)

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000f1	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  000f5	85 c0		 test	 eax, eax
  000f7	74 19		 je	 SHORT $LN5@z900_GetCC

; 109  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  000f9	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000fe	48 c1 e0 18	 shl	 rax, 24
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 _byteswap_uint64
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0010f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@z900_GetCC:

; 110  : 
; 111  :         pCCE->cached = TRUE;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00117	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 112  :         pCCEBLK->cce[ index ] = *pCCE;

  0011b	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00123	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00127	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0012f	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  00134	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00139	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0013e	f3 a4		 rep movsb

; 113  : 
; 114  :         return TRUE;

  00140	b0 01		 mov	 al, 1
  00142	e9 54 02 00 00	 jmp	 $LN1@z900_GetCC
$LN3@z900_GetCC:

; 115  :     }
; 116  : 
; 117  :     if (pCCE->cct == 1)  // (only one child)

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0014c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00150	83 f8 01	 cmp	 eax, 1
  00153	0f 85 cf 00 00
	00		 jne	 $LN6@z900_GetCC

; 118  :     {
; 119  :         register U8 wrk;
; 120  : 
; 121  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 4)

  00159	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0015e	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00162	48 83 e0 07	 and	 rax, 7
  00166	48 89 44 24 58	 mov	 QWORD PTR tv144[rsp], rax
  0016b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00170	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv144[rsp]
  00175	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00178	0f b6 44 24 58	 movzx	 eax, BYTE PTR tv144[rsp]
  0017d	83 f8 04	 cmp	 eax, 4
  00180	7e 07		 jle	 SHORT $LN8@z900_GetCC

; 122  :             return FALSE;

  00182	32 c0		 xor	 al, al
  00184	e9 12 02 00 00	 jmp	 $LN1@z900_GetCC
$LN8@z900_GetCC:

; 123  : 
; 124  :         wrk = (pCCE->act << 3);

  00189	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0018e	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  00192	c1 e0 03	 shl	 eax, 3
  00195	88 44 24 30	 mov	 BYTE PTR wrk$2[rsp], al

; 125  :         pCCE->cc[0] = CCE_U8R( 24 + wrk, 8 );

  00199	0f b6 44 24 30	 movzx	 eax, BYTE PTR wrk$2[rsp]
  0019e	83 c0 20	 add	 eax, 32			; 00000020H
  001a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a6	2b c8		 sub	 ecx, eax
  001a8	8b c1		 mov	 eax, ecx
  001aa	0f b6 c8	 movzx	 ecx, al
  001ad	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001b2	48 d3 e8	 shr	 rax, cl
  001b5	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	48 6b c9 00	 imul	 rcx, rcx, 0
  001c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  001c9	88 44 0a 08	 mov	 BYTE PTR [rdx+rcx+8], al

; 126  : 
; 127  :         if (pCCE->act)

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  001d2	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  001d6	85 c0		 test	 eax, eax
  001d8	74 19		 je	 SHORT $LN9@z900_GetCC

; 128  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  001da	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001df	48 c1 e0 18	 shl	 rax, 24
  001e3	48 8b c8	 mov	 rcx, rax
  001e6	e8 00 00 00 00	 call	 _byteswap_uint64
  001eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  001f0	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@z900_GetCC:

; 129  : 
; 130  :         pCCE->cptr = CCE_U16R( 11, 13 );

  001f3	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001f8	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  001fc	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00202	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00207	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 131  :         pCCE->ecb  = CCE_U16L(  3,  1 );

  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00210	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00214	48 25 00 80 00
	00		 and	 rax, 32768		; 00008000H
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0021f	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 132  :     }

  00223	e9 15 01 00 00	 jmp	 $LN7@z900_GetCC
$LN6@z900_GetCC:

; 133  :     else // (many children)
; 134  :     {
; 135  :         register U8 wrk; // (max cct)
; 136  : 
; 137  :         if (!(pCCE->act = CCE_U8R( 10, 1 ))) // (act == 0)

  00228	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0022d	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00231	48 83 e0 01	 and	 rax, 1
  00235	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0023f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR tv179[rsp]
  00244	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00247	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv179[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	75 07		 jne	 SHORT $LN10@z900_GetCC

; 138  :             wrk = 5;

  00250	c6 44 24 20 05	 mov	 BYTE PTR wrk$1[rsp], 5
  00255	eb 25		 jmp	 SHORT $LN11@z900_GetCC
$LN10@z900_GetCC:

; 139  :         else // (act == 1)
; 140  :         {
; 141  :             wrk = 4;

  00257	c6 44 24 20 04	 mov	 BYTE PTR wrk$1[rsp], 4

; 142  :             pCCE->ec[0] = CCE_U8R( 24, 8 );

  0025c	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00261	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00265	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0026b	b9 01 00 00 00	 mov	 ecx, 1
  00270	48 6b c9 00	 imul	 rcx, rcx, 0
  00274	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  00279	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN11@z900_GetCC:

; 143  :         }
; 144  : 
; 145  :         if (pCCE->cct > (wrk + 1))   // (data exception?)

  0027c	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00281	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00285	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  0028a	ff c1		 inc	 ecx
  0028c	3b c1		 cmp	 eax, ecx
  0028e	7e 07		 jle	 SHORT $LN12@z900_GetCC

; 146  :             return FALSE;

  00290	32 c0		 xor	 al, al
  00292	e9 04 01 00 00	 jmp	 $LN1@z900_GetCC
$LN12@z900_GetCC:

; 147  : 
; 148  :         if (pCCE->cct == (wrk + 1))  // (more children?)

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0029c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  002a0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002a5	ff c1		 inc	 ecx
  002a7	3b c1		 cmp	 eax, ecx
  002a9	75 16		 jne	 SHORT $LN13@z900_GetCC

; 149  :         {
; 150  :             pCCE->mc = TRUE;         // (set flag)

  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b0	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1

; 151  :             pCCE->cct = wrk;         // (fix cct)

  002b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002be	88 48 16	 mov	 BYTE PTR [rax+22], cl
$LN13@z900_GetCC:

; 152  :         }
; 153  : 
; 154  :         wrk = (pCCE->act << 3);      // (cc start bit - 24)

  002c1	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002c6	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  002ca	c1 e0 03	 shl	 eax, 3
  002cd	88 44 24 20	 mov	 BYTE PTR wrk$1[rsp], al

; 155  : 
; 156  :         pCCE->cc_dw = CSWAP64( cce << (24 + wrk) );

  002d1	0f b6 44 24 20	 movzx	 eax, BYTE PTR wrk$1[rsp]
  002d6	83 c0 18	 add	 eax, 24
  002d9	0f b6 c8	 movzx	 ecx, al
  002dc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002e1	48 d3 e0	 shl	 rax, cl
  002e4	48 8b c8	 mov	 rcx, rax
  002e7	e8 00 00 00 00	 call	 _byteswap_uint64
  002ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  002f1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 157  : 
; 158  :         pCCE->cptr = CCE_U16R( 11, 13 );

  002f5	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002fa	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  002fe	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00304	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00309	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 159  :         pCCE->ecb  = CCE_U16L(  3,  5 );

  0030d	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00312	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00316	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  0031c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00321	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 160  :         pCCE->yy   = CCE_U16L(  8,  2 );

  00325	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0032a	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0032e	48 25 00 c0 00
	00		 and	 rax, 49152		; 0000c000H
  00334	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00339	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN7@z900_GetCC:

; 161  :     }
; 162  : 
; 163  :     pCCE->cached = TRUE;

  0033d	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00342	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 164  :     pCCEBLK->cce[ index ] = *pCCE;

  00346	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  0034e	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00352	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0035a	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0035f	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00364	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00369	f3 a4		 rep movsb

; 165  : 
; 166  :     return (pCCE->cptr > pCCEBLK->max_index) ? FALSE : TRUE;

  0036b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00370	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00374	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0037c	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00380	3b c1		 cmp	 eax, ecx
  00382	7e 0a		 jle	 SHORT $LN15@z900_GetCC
  00384	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
  0038c	eb 08		 jmp	 SHORT $LN16@z900_GetCC
$LN15@z900_GetCC:
  0038e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
$LN16@z900_GetCC:
  00396	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv234[rsp]
$LN1@z900_GetCC:

; 167  : }

  0039b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0039f	5f		 pop	 rdi
  003a0	5e		 pop	 rsi
  003a1	c3		 ret	 0
z900_GetCCE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pECE$ = 32
ece$ = 40
tv83 = 48
tv89 = 56
tv134 = 64
index$ = 112
pECEBLK$ = 120
z900_GetECE PROC

; 49   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 50   :     register U64 ece;
; 51   :     register ECE* pECE = pECEBLK->pECE;

  00010	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00015	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00019	48 89 44 24 20	 mov	 QWORD PTR pECE$[rsp], rax

; 52   : 
; 53   :     if (pECEBLK->ece[ index ].cached)

  0001e	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 10	 imul	 rax, rax, 16
  00027	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  0002c	0f b6 44 01 25	 movzx	 eax, BYTE PTR [rcx+rax+37]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@z900_GetEC

; 54   :     {
; 55   :         *pECE = pECEBLK->ece[ index ];

  00035	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 10	 imul	 rax, rax, 16
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pECE$[rsp]
  00048	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0004d	b9 10 00 00 00	 mov	 ecx, 16
  00052	f3 a4		 rep movsb

; 56   :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 31 01 00 00	 jmp	 $LN1@z900_GetEC
$LN2@z900_GetEC:

; 57   :     }
; 58   : 
; 59   :     ece = ARCH_DEP( GetDCT )( index, pECEBLK->pDCTBLK );

  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 70	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 z900_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR ece$[rsp], rax

; 60   : 
; 61   :     if (!(pECE->psl = ECE_U8R( 0, 3 )))

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00077	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  0007b	48 83 e0 07	 and	 rax, 7
  0007f	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00089	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv83[rsp]
  0008e	88 48 0b	 mov	 BYTE PTR [rax+11], cl
  00091	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv83[rsp]
  00096	85 c0		 test	 eax, eax
  00098	75 4a		 jne	 SHORT $LN3@z900_GetEC

; 62   :     {
; 63   :         if (!(pECE->csl = ECE_U8R( 5, 3 )))

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  0009f	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  000a3	48 83 e0 07	 and	 rax, 7
  000a7	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000b1	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv89[rsp]
  000b6	88 48 0a	 mov	 BYTE PTR [rax+10], cl
  000b9	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv89[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 07		 jne	 SHORT $LN5@z900_GetEC

; 64   :             return FALSE;

  000c2	32 c0		 xor	 al, al
  000c4	e9 c3 00 00 00	 jmp	 $LN1@z900_GetEC
$LN5@z900_GetEC:

; 65   :         pECE->ec_dw = CSWAP64( ece << 8 );

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  000ce	48 c1 e0 08	 shl	 rax, 8
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 _byteswap_uint64
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  000df	48 89 01	 mov	 QWORD PTR [rcx], rax

; 66   :     }

  000e2	eb 7e		 jmp	 SHORT $LN4@z900_GetEC
$LN3@z900_GetEC:

; 67   :     else if (pECE->psl > 5)

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000e9	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  000ed	83 f8 05	 cmp	 eax, 5
  000f0	7e 09		 jle	 SHORT $LN6@z900_GetEC

; 68   :         return FALSE;

  000f2	32 c0		 xor	 al, al
  000f4	e9 93 00 00 00	 jmp	 $LN1@z900_GetEC
  000f9	eb 67		 jmp	 SHORT $LN7@z900_GetEC
$LN6@z900_GetEC:

; 69   :     else
; 70   :     {
; 71   :         if ((pECE->pptr = ECE_U16R( 3, 13 )) > pECEBLK->max_index)

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00100	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00104	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  0010a	48 89 44 24 40	 mov	 QWORD PTR tv134[rsp], rax
  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00114	0f b7 4c 24 40	 movzx	 ecx, WORD PTR tv134[rsp]
  00119	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0011d	0f b7 44 24 40	 movzx	 eax, WORD PTR tv134[rsp]
  00122	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00127	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  0012b	3b c1		 cmp	 eax, ecx
  0012d	7e 04		 jle	 SHORT $LN8@z900_GetEC

; 72   :             return FALSE;

  0012f	32 c0		 xor	 al, al
  00131	eb 59		 jmp	 SHORT $LN1@z900_GetEC
$LN8@z900_GetEC:

; 73   :         pECE->ofst = (U8)(ece);

  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00138	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR ece$[rsp]
  0013d	88 48 0c	 mov	 BYTE PTR [rax+12], cl

; 74   :         pECE->ec_dw = CSWAP64( ece << 16 );

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00145	48 c1 e0 10	 shl	 rax, 16
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 _byteswap_uint64
  00151	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  00156	48 89 01	 mov	 QWORD PTR [rcx], rax

; 75   :         pECE->csl = 0;

  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  0015e	c6 40 0a 00	 mov	 BYTE PTR [rax+10], 0
$LN7@z900_GetEC:
$LN4@z900_GetEC:

; 76   :     }
; 77   : 
; 78   :     pECE->cached = TRUE;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00167	c6 40 0d 01	 mov	 BYTE PTR [rax+13], 1

; 79   :     pECEBLK->ece[ index ] = *pECE;

  0016b	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00170	48 6b c0 10	 imul	 rax, rax, 16
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00179	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0017e	48 8b 74 24 20	 mov	 rsi, QWORD PTR pECE$[rsp]
  00183	b9 10 00 00 00	 mov	 ecx, 16
  00188	f3 a4		 rep movsb

; 80   : 
; 81   :     return TRUE;

  0018a	b0 01		 mov	 al, 1
$LN1@z900_GetEC:

; 82   : }

  0018c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00190	5f		 pop	 rdi
  00191	5e		 pop	 rsi
  00192	c3		 ret	 0
z900_GetECE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pagenum$ = 48
pageidx$ = 52
index$ = 80
pDCTBLK$ = 88
z900_GetDCT PROC

; 25   : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 26   :     register U16  pagenum  = INDEX_TO_PAGENUM( index );

  0000e	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00013	c1 f8 09	 sar	 eax, 9
  00016	66 89 44 24 30	 mov	 WORD PTR pagenum$[rsp], ax

; 27   :     register U16  pageidx  = INDEX_TO_PAGEIDX( index );

  0001b	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00020	c1 e0 03	 shl	 eax, 3
  00023	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00028	66 89 44 24 34	 mov	 WORD PTR pageidx$[rsp], ax

; 28   : 
; 29   :     if (!pDCTBLK->maddr[ pagenum ])

  0002d	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00037	48 83 7c c1 10
	00		 cmp	 QWORD PTR [rcx+rax*8+16], 0
  0003d	75 5b		 jne	 SHORT $LN2@z900_GetDC

; 30   :     {
; 31   :         pDCTBLK->maddr[ pagenum ] = MADDR

  0003f	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00044	c1 e0 0c	 shl	 eax, 12
  00047	8b c0		 mov	 eax, eax
  00049	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0004e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00057	0f b6 89 14 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+276]
  0005e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00062	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0006f	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00077	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 z900_maddr_l
  0008b	0f b7 4c 24 30	 movzx	 ecx, WORD PTR pagenum$[rsp]
  00090	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  00095	48 89 44 ca 10	 mov	 QWORD PTR [rdx+rcx*8+16], rax
$LN2@z900_GetDC:

; 32   :         (
; 33   :             pDCTBLK->pDict + PAGENUM_TO_BYTES( pagenum ),
; 34   :             pDCTBLK->arn,
; 35   :             pDCTBLK->regs,
; 36   :             ACCTYPE_READ,
; 37   :             pDCTBLK->pkey
; 38   :         );
; 39   :     }
; 40   :     return CSWAP64(*(U64*)(uintptr_t)(&pDCTBLK->maddr[ pagenum ][ pageidx ]));

  0009a	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  0009f	0f b7 4c 24 34	 movzx	 ecx, WORD PTR pageidx$[rsp]
  000a4	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  000a9	48 8b 44 c2 10	 mov	 rax, QWORD PTR [rdx+rax*8+16]
  000ae	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  000b2	e8 00 00 00 00	 call	 _byteswap_uint64

; 41   : }

  000b7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bb	c3		 ret	 0
z900_GetDCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
sd2$1 = 48
tv84 = 56
index$ = 96
pSDEBLK$ = 104
s390_GetSD1 PROC

; 231  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 232  :     register U64 sd1;
; 233  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 234  : 
; 235  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s390_GetSD

; 236  :     {
; 237  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 238  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 99 01 00 00	 jmp	 $LN1@s390_GetSD
$LN2@s390_GetSD:

; 239  :     }
; 240  : 
; 241  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s390_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 242  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 243  : 
; 244  :     if (!(pSDE->sct = SD1_U8R( 0, 4 )) || pSDE->sct >= 15)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3c	 shr	 rax, 60			; 0000003cH
  00084	48 83 e0 0f	 and	 rax, 15
  00088	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@s390_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 0f	 cmp	 eax, 15
  000af	7c 12		 jl	 SHORT $LN3@s390_GetSD
$LN4@s390_GetSD:

; 245  :     {
; 246  :         pSDE->sct = 14;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 0e	 mov	 BYTE PTR [rax+18], 14

; 247  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@s390_GetSD:

; 248  :     }
; 249  : 
; 250  :     // Examine child bits for children 1 to 12
; 251  : 
; 252  :     pSDE->ecb = SD1_U16L( 4, 12 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2c	 shr	 rax, 44			; 0000002cH
  000cc	48 25 f0 ff 00
	00		 and	 rax, 65520		; 0000fff0H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 253  : 
; 254  :     // If children exist append examine child bits for
; 255  :     // children 13 and 14 which are in the parent CCE
; 256  :     // so they are all in one place (simpler testing).
; 257  :     //
; 258  :     // Note: this only applies for the FIRST sibling
; 259  :     // of the parent. Examine child bits for children
; 260  :     // 13 and 14 do not exist for subsequent siblings
; 261  :     // of parent and thus must ALWAYS be examined.
; 262  : 
; 263  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@s390_GetSD

; 264  :     {
; 265  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@s390_GetSD

; 266  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 12;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 0c	 sar	 eax, 12
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@s390_GetSD:

; 267  :     }

  0011f	eb 15		 jmp	 SHORT $LN6@s390_GetSD
$LN5@s390_GetSD:

; 268  :     else // (force child to ALWAYS be examined)
; 269  :     {
; 270  :         pSDE->ecb |= 0xFFFF >> 12;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	83 c8 0f	 or	 eax, 15
  0012d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00132	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@s390_GetSD:

; 271  :     }
; 272  : 
; 273  :     sd1 <<= 16;                               // (first 6 bytes)

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013b	48 c1 e0 10	 shl	 rax, 16
  0013f	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 274  : 
; 275  :     if (pSDE->sct <= 6)

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00149	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  0014d	83 f8 06	 cmp	 eax, 6
  00150	7f 14		 jg	 SHORT $LN8@s390_GetSD

; 276  :         pSDE->sc_dw = CSWAP64( sd1 );         // (only 6 bytes)

  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  00157	e8 00 00 00 00	 call	 _byteswap_uint64
  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00161	48 89 01	 mov	 QWORD PTR [rcx], rax
  00164	eb 64		 jmp	 SHORT $LN9@s390_GetSD
$LN8@s390_GetSD:

; 277  :     else
; 278  :     {
; 279  :         register U64 sd2 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK2 );

  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  0016b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0016f	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00174	e8 00 00 00 00	 call	 s390_GetDCT
  00179	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 280  : 
; 281  :         sd1 |= sd2 >> (64-16);                // (append 2 more)

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  00183	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00187	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0018c	48 0b c8	 or	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 282  :         pSDE->sc_dw= CSWAP64( sd1 );          // (store first 8)

  00197	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_uint64
  001a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001a6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 283  : 
; 284  :         sd2 <<= 16;                           // (next 6 bytes)

  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  001ae	48 c1 e0 10	 shl	 rax, 16
  001b2	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 285  :         pSDE->sc_dw2 = CSWAP64( sd2 );        // (store next 6)

  001b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sd2$1[rsp]
  001bc	e8 00 00 00 00	 call	 _byteswap_uint64
  001c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001c6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN9@s390_GetSD:

; 286  :     }
; 287  : 
; 288  :     pSDE->cached = TRUE;

  001ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  001cf	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 289  :     pSDEBLK->sde[ index ] = *pSDE;

  001d3	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  001d8	48 6b c0 18	 imul	 rax, rax, 24
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  001e1	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  001e6	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  001eb	b9 18 00 00 00	 mov	 ecx, 24
  001f0	f3 a4		 rep movsb

; 290  : 
; 291  :     return TRUE;

  001f2	b0 01		 mov	 al, 1
$LN1@s390_GetSD:

; 292  : }

  001f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f8	5f		 pop	 rdi
  001f9	5e		 pop	 rsi
  001fa	c3		 ret	 0
s390_GetSD1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
tv84 = 48
index$ = 96
pSDEBLK$ = 104
s390_GetSD0 PROC

; 175  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 176  :     register U64 sd1;
; 177  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 178  : 
; 179  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s390_GetSD

; 180  :     {
; 181  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 182  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 20 01 00 00	 jmp	 $LN1@s390_GetSD
$LN2@s390_GetSD:

; 183  :     }
; 184  : 
; 185  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s390_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 186  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 187  : 
; 188  :     if (!(pSDE->sct = SD1_U8R( 0, 3 )) || pSDE->sct >= 7)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00084	48 83 e0 07	 and	 rax, 7
  00088	48 89 44 24 30	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@s390_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 07	 cmp	 eax, 7
  000af	7c 12		 jl	 SHORT $LN3@s390_GetSD
$LN4@s390_GetSD:

; 189  :     {
; 190  :         pSDE->sct = 7;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 07	 mov	 BYTE PTR [rax+18], 7

; 191  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@s390_GetSD:

; 192  :     }
; 193  : 
; 194  :     // Examine child bits for children 1 to 5
; 195  : 
; 196  :     pSDE->ecb = SD1_U16L( 3, 5 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  000cc	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 197  : 
; 198  :     // If children exist append examine child bits for
; 199  :     // children 6 and 7 which are in the parent CCE so
; 200  :     // they're all in one place (makes things easier).
; 201  :     //
; 202  :     // Note: this only applies for the FIRST sibling
; 203  :     // of the parent. Examine child bits for children
; 204  :     // 6 and 7 do not exist for subsequent siblings
; 205  :     // of parent and thus must ALWAYS be examined.
; 206  : 
; 207  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@s390_GetSD

; 208  :     {
; 209  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@s390_GetSD

; 210  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 5;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 05	 sar	 eax, 5
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@s390_GetSD:

; 211  :     }

  0011f	eb 17		 jmp	 SHORT $LN6@s390_GetSD
$LN5@s390_GetSD:

; 212  :     else // (force child to ALWAYS be examined)
; 213  :     {
; 214  :         pSDE->ecb |= 0xFFFF >> 5;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	0d ff 07 00 00	 or	 eax, 2047		; 000007ffH
  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00134	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@s390_GetSD:

; 215  :     }
; 216  : 
; 217  :     pSDE->sc_dw = CSWAP64( sd1 << 8 );

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013d	48 c1 e0 08	 shl	 rax, 8
  00141	48 8b c8	 mov	 rcx, rax
  00144	e8 00 00 00 00	 call	 _byteswap_uint64
  00149	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0014e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 218  : 
; 219  :     pSDE->cached = TRUE;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00156	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 220  :     pSDEBLK->sde[ index ] = *pSDE;

  0015a	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0015f	48 6b c0 18	 imul	 rax, rax, 24
  00163	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00168	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  0016d	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  00172	b9 18 00 00 00	 mov	 ecx, 24
  00177	f3 a4		 rep movsb

; 221  : 
; 222  :     return TRUE;

  00179	b0 01		 mov	 al, 1
$LN1@s390_GetSD:

; 223  : }

  0017b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017f	5f		 pop	 rdi
  00180	5e		 pop	 rsi
  00181	c3		 ret	 0
s390_GetSD0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
wrk$1 = 32
pCCE$ = 40
wrk$2 = 48
cce$ = 56
tv234 = 64
tv84 = 72
tv90 = 80
tv144 = 88
tv179 = 96
index$ = 144
pCCEBLK$ = 152
s390_GetCCE PROC

; 90   : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 91   :     register U64 cce;
; 92   :     register CCE* pCCE = pCCEBLK->pCCE;

  00010	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 28	 mov	 QWORD PTR pCCE$[rsp], rax

; 93   : 
; 94   :     if (pCCEBLK->cce[ index ].cached)

  00021	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00029	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0002d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00035	0f b6 44 01 31	 movzx	 eax, BYTE PTR [rcx+rax+49]
  0003a	85 c0		 test	 eax, eax
  0003c	74 2c		 je	 SHORT $LN2@s390_GetCC

; 95   :     {
; 96   :         *pCCE = pCCEBLK->cce[ index ];

  0003e	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00046	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00052	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pCCE$[rsp]
  00057	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0005c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00061	f3 a4		 rep movsb

; 97   :         return TRUE;

  00063	b0 01		 mov	 al, 1
  00065	e9 31 03 00 00	 jmp	 $LN1@s390_GetCC
$LN2@s390_GetCC:

; 98   :     }
; 99   : 
; 100  :     cce = ARCH_DEP( GetDCT )( index, pCCEBLK->pDCTBLK );

  0006a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00072	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00075	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR index$[rsp]
  0007d	e8 00 00 00 00	 call	 s390_GetDCT
  00082	48 89 44 24 38	 mov	 QWORD PTR cce$[rsp], rax

; 101  :     pCCE->mc = FALSE;

  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0008c	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 102  : 
; 103  :     if (!(pCCE->cct = CCE_U8R( 0, 3 )))  // (no children)

  00090	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00095	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00099	48 83 e0 07	 and	 rax, 7
  0009d	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000a7	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv84[rsp]
  000ac	88 48 16	 mov	 BYTE PTR [rax+22], cl
  000af	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv84[rsp]
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 8b 00 00
	00		 jne	 $LN3@s390_GetCC

; 104  :     {
; 105  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 5)

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000c1	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  000c5	48 83 e0 07	 and	 rax, 7
  000c9	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000d3	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv90[rsp]
  000d8	88 48 17	 mov	 BYTE PTR [rax+23], cl
  000db	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv90[rsp]
  000e0	83 f8 05	 cmp	 eax, 5
  000e3	7e 07		 jle	 SHORT $LN4@s390_GetCC

; 106  :             return FALSE;

  000e5	32 c0		 xor	 al, al
  000e7	e9 af 02 00 00	 jmp	 $LN1@s390_GetCC
$LN4@s390_GetCC:

; 107  : 
; 108  :         if (pCCE->act)

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000f1	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  000f5	85 c0		 test	 eax, eax
  000f7	74 19		 je	 SHORT $LN5@s390_GetCC

; 109  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  000f9	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000fe	48 c1 e0 18	 shl	 rax, 24
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 _byteswap_uint64
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0010f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@s390_GetCC:

; 110  : 
; 111  :         pCCE->cached = TRUE;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00117	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 112  :         pCCEBLK->cce[ index ] = *pCCE;

  0011b	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00123	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00127	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0012f	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  00134	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00139	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0013e	f3 a4		 rep movsb

; 113  : 
; 114  :         return TRUE;

  00140	b0 01		 mov	 al, 1
  00142	e9 54 02 00 00	 jmp	 $LN1@s390_GetCC
$LN3@s390_GetCC:

; 115  :     }
; 116  : 
; 117  :     if (pCCE->cct == 1)  // (only one child)

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0014c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00150	83 f8 01	 cmp	 eax, 1
  00153	0f 85 cf 00 00
	00		 jne	 $LN6@s390_GetCC

; 118  :     {
; 119  :         register U8 wrk;
; 120  : 
; 121  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 4)

  00159	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0015e	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00162	48 83 e0 07	 and	 rax, 7
  00166	48 89 44 24 58	 mov	 QWORD PTR tv144[rsp], rax
  0016b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00170	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv144[rsp]
  00175	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00178	0f b6 44 24 58	 movzx	 eax, BYTE PTR tv144[rsp]
  0017d	83 f8 04	 cmp	 eax, 4
  00180	7e 07		 jle	 SHORT $LN8@s390_GetCC

; 122  :             return FALSE;

  00182	32 c0		 xor	 al, al
  00184	e9 12 02 00 00	 jmp	 $LN1@s390_GetCC
$LN8@s390_GetCC:

; 123  : 
; 124  :         wrk = (pCCE->act << 3);

  00189	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0018e	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  00192	c1 e0 03	 shl	 eax, 3
  00195	88 44 24 30	 mov	 BYTE PTR wrk$2[rsp], al

; 125  :         pCCE->cc[0] = CCE_U8R( 24 + wrk, 8 );

  00199	0f b6 44 24 30	 movzx	 eax, BYTE PTR wrk$2[rsp]
  0019e	83 c0 20	 add	 eax, 32			; 00000020H
  001a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a6	2b c8		 sub	 ecx, eax
  001a8	8b c1		 mov	 eax, ecx
  001aa	0f b6 c8	 movzx	 ecx, al
  001ad	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001b2	48 d3 e8	 shr	 rax, cl
  001b5	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	48 6b c9 00	 imul	 rcx, rcx, 0
  001c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  001c9	88 44 0a 08	 mov	 BYTE PTR [rdx+rcx+8], al

; 126  : 
; 127  :         if (pCCE->act)

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  001d2	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  001d6	85 c0		 test	 eax, eax
  001d8	74 19		 je	 SHORT $LN9@s390_GetCC

; 128  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  001da	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001df	48 c1 e0 18	 shl	 rax, 24
  001e3	48 8b c8	 mov	 rcx, rax
  001e6	e8 00 00 00 00	 call	 _byteswap_uint64
  001eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  001f0	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@s390_GetCC:

; 129  : 
; 130  :         pCCE->cptr = CCE_U16R( 11, 13 );

  001f3	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001f8	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  001fc	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00202	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00207	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 131  :         pCCE->ecb  = CCE_U16L(  3,  1 );

  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00210	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00214	48 25 00 80 00
	00		 and	 rax, 32768		; 00008000H
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0021f	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 132  :     }

  00223	e9 15 01 00 00	 jmp	 $LN7@s390_GetCC
$LN6@s390_GetCC:

; 133  :     else // (many children)
; 134  :     {
; 135  :         register U8 wrk; // (max cct)
; 136  : 
; 137  :         if (!(pCCE->act = CCE_U8R( 10, 1 ))) // (act == 0)

  00228	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0022d	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00231	48 83 e0 01	 and	 rax, 1
  00235	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0023f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR tv179[rsp]
  00244	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00247	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv179[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	75 07		 jne	 SHORT $LN10@s390_GetCC

; 138  :             wrk = 5;

  00250	c6 44 24 20 05	 mov	 BYTE PTR wrk$1[rsp], 5
  00255	eb 25		 jmp	 SHORT $LN11@s390_GetCC
$LN10@s390_GetCC:

; 139  :         else // (act == 1)
; 140  :         {
; 141  :             wrk = 4;

  00257	c6 44 24 20 04	 mov	 BYTE PTR wrk$1[rsp], 4

; 142  :             pCCE->ec[0] = CCE_U8R( 24, 8 );

  0025c	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00261	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00265	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0026b	b9 01 00 00 00	 mov	 ecx, 1
  00270	48 6b c9 00	 imul	 rcx, rcx, 0
  00274	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  00279	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN11@s390_GetCC:

; 143  :         }
; 144  : 
; 145  :         if (pCCE->cct > (wrk + 1))   // (data exception?)

  0027c	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00281	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00285	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  0028a	ff c1		 inc	 ecx
  0028c	3b c1		 cmp	 eax, ecx
  0028e	7e 07		 jle	 SHORT $LN12@s390_GetCC

; 146  :             return FALSE;

  00290	32 c0		 xor	 al, al
  00292	e9 04 01 00 00	 jmp	 $LN1@s390_GetCC
$LN12@s390_GetCC:

; 147  : 
; 148  :         if (pCCE->cct == (wrk + 1))  // (more children?)

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0029c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  002a0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002a5	ff c1		 inc	 ecx
  002a7	3b c1		 cmp	 eax, ecx
  002a9	75 16		 jne	 SHORT $LN13@s390_GetCC

; 149  :         {
; 150  :             pCCE->mc = TRUE;         // (set flag)

  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b0	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1

; 151  :             pCCE->cct = wrk;         // (fix cct)

  002b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002be	88 48 16	 mov	 BYTE PTR [rax+22], cl
$LN13@s390_GetCC:

; 152  :         }
; 153  : 
; 154  :         wrk = (pCCE->act << 3);      // (cc start bit - 24)

  002c1	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002c6	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  002ca	c1 e0 03	 shl	 eax, 3
  002cd	88 44 24 20	 mov	 BYTE PTR wrk$1[rsp], al

; 155  : 
; 156  :         pCCE->cc_dw = CSWAP64( cce << (24 + wrk) );

  002d1	0f b6 44 24 20	 movzx	 eax, BYTE PTR wrk$1[rsp]
  002d6	83 c0 18	 add	 eax, 24
  002d9	0f b6 c8	 movzx	 ecx, al
  002dc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002e1	48 d3 e0	 shl	 rax, cl
  002e4	48 8b c8	 mov	 rcx, rax
  002e7	e8 00 00 00 00	 call	 _byteswap_uint64
  002ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  002f1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 157  : 
; 158  :         pCCE->cptr = CCE_U16R( 11, 13 );

  002f5	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002fa	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  002fe	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00304	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00309	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 159  :         pCCE->ecb  = CCE_U16L(  3,  5 );

  0030d	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00312	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00316	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  0031c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00321	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 160  :         pCCE->yy   = CCE_U16L(  8,  2 );

  00325	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0032a	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0032e	48 25 00 c0 00
	00		 and	 rax, 49152		; 0000c000H
  00334	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00339	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN7@s390_GetCC:

; 161  :     }
; 162  : 
; 163  :     pCCE->cached = TRUE;

  0033d	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00342	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 164  :     pCCEBLK->cce[ index ] = *pCCE;

  00346	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  0034e	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00352	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0035a	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0035f	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00364	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00369	f3 a4		 rep movsb

; 165  : 
; 166  :     return (pCCE->cptr > pCCEBLK->max_index) ? FALSE : TRUE;

  0036b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00370	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00374	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0037c	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00380	3b c1		 cmp	 eax, ecx
  00382	7e 0a		 jle	 SHORT $LN15@s390_GetCC
  00384	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
  0038c	eb 08		 jmp	 SHORT $LN16@s390_GetCC
$LN15@s390_GetCC:
  0038e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
$LN16@s390_GetCC:
  00396	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv234[rsp]
$LN1@s390_GetCC:

; 167  : }

  0039b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0039f	5f		 pop	 rdi
  003a0	5e		 pop	 rsi
  003a1	c3		 ret	 0
s390_GetCCE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pECE$ = 32
ece$ = 40
tv83 = 48
tv89 = 56
tv134 = 64
index$ = 112
pECEBLK$ = 120
s390_GetECE PROC

; 49   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 50   :     register U64 ece;
; 51   :     register ECE* pECE = pECEBLK->pECE;

  00010	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00015	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00019	48 89 44 24 20	 mov	 QWORD PTR pECE$[rsp], rax

; 52   : 
; 53   :     if (pECEBLK->ece[ index ].cached)

  0001e	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 10	 imul	 rax, rax, 16
  00027	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  0002c	0f b6 44 01 25	 movzx	 eax, BYTE PTR [rcx+rax+37]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s390_GetEC

; 54   :     {
; 55   :         *pECE = pECEBLK->ece[ index ];

  00035	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 10	 imul	 rax, rax, 16
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pECE$[rsp]
  00048	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0004d	b9 10 00 00 00	 mov	 ecx, 16
  00052	f3 a4		 rep movsb

; 56   :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 31 01 00 00	 jmp	 $LN1@s390_GetEC
$LN2@s390_GetEC:

; 57   :     }
; 58   : 
; 59   :     ece = ARCH_DEP( GetDCT )( index, pECEBLK->pDCTBLK );

  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 70	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s390_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR ece$[rsp], rax

; 60   : 
; 61   :     if (!(pECE->psl = ECE_U8R( 0, 3 )))

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00077	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  0007b	48 83 e0 07	 and	 rax, 7
  0007f	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00089	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv83[rsp]
  0008e	88 48 0b	 mov	 BYTE PTR [rax+11], cl
  00091	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv83[rsp]
  00096	85 c0		 test	 eax, eax
  00098	75 4a		 jne	 SHORT $LN3@s390_GetEC

; 62   :     {
; 63   :         if (!(pECE->csl = ECE_U8R( 5, 3 )))

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  0009f	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  000a3	48 83 e0 07	 and	 rax, 7
  000a7	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000b1	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv89[rsp]
  000b6	88 48 0a	 mov	 BYTE PTR [rax+10], cl
  000b9	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv89[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 07		 jne	 SHORT $LN5@s390_GetEC

; 64   :             return FALSE;

  000c2	32 c0		 xor	 al, al
  000c4	e9 c3 00 00 00	 jmp	 $LN1@s390_GetEC
$LN5@s390_GetEC:

; 65   :         pECE->ec_dw = CSWAP64( ece << 8 );

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  000ce	48 c1 e0 08	 shl	 rax, 8
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 _byteswap_uint64
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  000df	48 89 01	 mov	 QWORD PTR [rcx], rax

; 66   :     }

  000e2	eb 7e		 jmp	 SHORT $LN4@s390_GetEC
$LN3@s390_GetEC:

; 67   :     else if (pECE->psl > 5)

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000e9	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  000ed	83 f8 05	 cmp	 eax, 5
  000f0	7e 09		 jle	 SHORT $LN6@s390_GetEC

; 68   :         return FALSE;

  000f2	32 c0		 xor	 al, al
  000f4	e9 93 00 00 00	 jmp	 $LN1@s390_GetEC
  000f9	eb 67		 jmp	 SHORT $LN7@s390_GetEC
$LN6@s390_GetEC:

; 69   :     else
; 70   :     {
; 71   :         if ((pECE->pptr = ECE_U16R( 3, 13 )) > pECEBLK->max_index)

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00100	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00104	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  0010a	48 89 44 24 40	 mov	 QWORD PTR tv134[rsp], rax
  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00114	0f b7 4c 24 40	 movzx	 ecx, WORD PTR tv134[rsp]
  00119	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0011d	0f b7 44 24 40	 movzx	 eax, WORD PTR tv134[rsp]
  00122	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00127	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  0012b	3b c1		 cmp	 eax, ecx
  0012d	7e 04		 jle	 SHORT $LN8@s390_GetEC

; 72   :             return FALSE;

  0012f	32 c0		 xor	 al, al
  00131	eb 59		 jmp	 SHORT $LN1@s390_GetEC
$LN8@s390_GetEC:

; 73   :         pECE->ofst = (U8)(ece);

  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00138	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR ece$[rsp]
  0013d	88 48 0c	 mov	 BYTE PTR [rax+12], cl

; 74   :         pECE->ec_dw = CSWAP64( ece << 16 );

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00145	48 c1 e0 10	 shl	 rax, 16
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 _byteswap_uint64
  00151	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  00156	48 89 01	 mov	 QWORD PTR [rcx], rax

; 75   :         pECE->csl = 0;

  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  0015e	c6 40 0a 00	 mov	 BYTE PTR [rax+10], 0
$LN7@s390_GetEC:
$LN4@s390_GetEC:

; 76   :     }
; 77   : 
; 78   :     pECE->cached = TRUE;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00167	c6 40 0d 01	 mov	 BYTE PTR [rax+13], 1

; 79   :     pECEBLK->ece[ index ] = *pECE;

  0016b	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00170	48 6b c0 10	 imul	 rax, rax, 16
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00179	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0017e	48 8b 74 24 20	 mov	 rsi, QWORD PTR pECE$[rsp]
  00183	b9 10 00 00 00	 mov	 ecx, 16
  00188	f3 a4		 rep movsb

; 80   : 
; 81   :     return TRUE;

  0018a	b0 01		 mov	 al, 1
$LN1@s390_GetEC:

; 82   : }

  0018c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00190	5f		 pop	 rdi
  00191	5e		 pop	 rsi
  00192	c3		 ret	 0
s390_GetECE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pagenum$ = 48
pageidx$ = 52
index$ = 80
pDCTBLK$ = 88
s390_GetDCT PROC

; 25   : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 26   :     register U16  pagenum  = INDEX_TO_PAGENUM( index );

  0000e	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00013	c1 f8 09	 sar	 eax, 9
  00016	66 89 44 24 30	 mov	 WORD PTR pagenum$[rsp], ax

; 27   :     register U16  pageidx  = INDEX_TO_PAGEIDX( index );

  0001b	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00020	c1 e0 03	 shl	 eax, 3
  00023	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00028	66 89 44 24 34	 mov	 WORD PTR pageidx$[rsp], ax

; 28   : 
; 29   :     if (!pDCTBLK->maddr[ pagenum ])

  0002d	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00037	48 83 7c c1 10
	00		 cmp	 QWORD PTR [rcx+rax*8+16], 0
  0003d	75 5a		 jne	 SHORT $LN2@s390_GetDC

; 30   :     {
; 31   :         pDCTBLK->maddr[ pagenum ] = MADDR

  0003f	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00044	c1 e0 0c	 shl	 eax, 12
  00047	8b c0		 mov	 eax, eax
  00049	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0004e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00057	0f b6 89 14 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+276]
  0005e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00062	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0006f	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00077	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 s390_maddr_l
  0008a	0f b7 4c 24 30	 movzx	 ecx, WORD PTR pagenum$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  00094	48 89 44 ca 10	 mov	 QWORD PTR [rdx+rcx*8+16], rax
$LN2@s390_GetDC:

; 32   :         (
; 33   :             pDCTBLK->pDict + PAGENUM_TO_BYTES( pagenum ),
; 34   :             pDCTBLK->arn,
; 35   :             pDCTBLK->regs,
; 36   :             ACCTYPE_READ,
; 37   :             pDCTBLK->pkey
; 38   :         );
; 39   :     }
; 40   :     return CSWAP64(*(U64*)(uintptr_t)(&pDCTBLK->maddr[ pagenum ][ pageidx ]));

  00099	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  0009e	0f b7 4c 24 34	 movzx	 ecx, WORD PTR pageidx$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  000a8	48 8b 44 c2 10	 mov	 rax, QWORD PTR [rdx+rax*8+16]
  000ad	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  000b1	e8 00 00 00 00	 call	 _byteswap_uint64

; 41   : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
s390_GetDCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
sd2$1 = 48
tv84 = 56
index$ = 96
pSDEBLK$ = 104
s370_GetSD1 PROC

; 231  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 232  :     register U64 sd1;
; 233  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 234  : 
; 235  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s370_GetSD

; 236  :     {
; 237  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 238  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 99 01 00 00	 jmp	 $LN1@s370_GetSD
$LN2@s370_GetSD:

; 239  :     }
; 240  : 
; 241  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s370_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 242  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 243  : 
; 244  :     if (!(pSDE->sct = SD1_U8R( 0, 4 )) || pSDE->sct >= 15)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3c	 shr	 rax, 60			; 0000003cH
  00084	48 83 e0 0f	 and	 rax, 15
  00088	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@s370_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 0f	 cmp	 eax, 15
  000af	7c 12		 jl	 SHORT $LN3@s370_GetSD
$LN4@s370_GetSD:

; 245  :     {
; 246  :         pSDE->sct = 14;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 0e	 mov	 BYTE PTR [rax+18], 14

; 247  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@s370_GetSD:

; 248  :     }
; 249  : 
; 250  :     // Examine child bits for children 1 to 12
; 251  : 
; 252  :     pSDE->ecb = SD1_U16L( 4, 12 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2c	 shr	 rax, 44			; 0000002cH
  000cc	48 25 f0 ff 00
	00		 and	 rax, 65520		; 0000fff0H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 253  : 
; 254  :     // If children exist append examine child bits for
; 255  :     // children 13 and 14 which are in the parent CCE
; 256  :     // so they are all in one place (simpler testing).
; 257  :     //
; 258  :     // Note: this only applies for the FIRST sibling
; 259  :     // of the parent. Examine child bits for children
; 260  :     // 13 and 14 do not exist for subsequent siblings
; 261  :     // of parent and thus must ALWAYS be examined.
; 262  : 
; 263  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@s370_GetSD

; 264  :     {
; 265  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@s370_GetSD

; 266  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 12;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 0c	 sar	 eax, 12
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@s370_GetSD:

; 267  :     }

  0011f	eb 15		 jmp	 SHORT $LN6@s370_GetSD
$LN5@s370_GetSD:

; 268  :     else // (force child to ALWAYS be examined)
; 269  :     {
; 270  :         pSDE->ecb |= 0xFFFF >> 12;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	83 c8 0f	 or	 eax, 15
  0012d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00132	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@s370_GetSD:

; 271  :     }
; 272  : 
; 273  :     sd1 <<= 16;                               // (first 6 bytes)

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013b	48 c1 e0 10	 shl	 rax, 16
  0013f	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 274  : 
; 275  :     if (pSDE->sct <= 6)

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00149	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  0014d	83 f8 06	 cmp	 eax, 6
  00150	7f 14		 jg	 SHORT $LN8@s370_GetSD

; 276  :         pSDE->sc_dw = CSWAP64( sd1 );         // (only 6 bytes)

  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  00157	e8 00 00 00 00	 call	 _byteswap_uint64
  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00161	48 89 01	 mov	 QWORD PTR [rcx], rax
  00164	eb 64		 jmp	 SHORT $LN9@s370_GetSD
$LN8@s370_GetSD:

; 277  :     else
; 278  :     {
; 279  :         register U64 sd2 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK2 );

  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  0016b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0016f	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00174	e8 00 00 00 00	 call	 s370_GetDCT
  00179	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 280  : 
; 281  :         sd1 |= sd2 >> (64-16);                // (append 2 more)

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  00183	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00187	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0018c	48 0b c8	 or	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 282  :         pSDE->sc_dw= CSWAP64( sd1 );          // (store first 8)

  00197	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sd1$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_uint64
  001a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001a6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 283  : 
; 284  :         sd2 <<= 16;                           // (next 6 bytes)

  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR sd2$1[rsp]
  001ae	48 c1 e0 10	 shl	 rax, 16
  001b2	48 89 44 24 30	 mov	 QWORD PTR sd2$1[rsp], rax

; 285  :         pSDE->sc_dw2 = CSWAP64( sd2 );        // (store next 6)

  001b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sd2$1[rsp]
  001bc	e8 00 00 00 00	 call	 _byteswap_uint64
  001c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  001c6	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN9@s370_GetSD:

; 286  :     }
; 287  : 
; 288  :     pSDE->cached = TRUE;

  001ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  001cf	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 289  :     pSDEBLK->sde[ index ] = *pSDE;

  001d3	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  001d8	48 6b c0 18	 imul	 rax, rax, 24
  001dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  001e1	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  001e6	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  001eb	b9 18 00 00 00	 mov	 ecx, 24
  001f0	f3 a4		 rep movsb

; 290  : 
; 291  :     return TRUE;

  001f2	b0 01		 mov	 al, 1
$LN1@s370_GetSD:

; 292  : }

  001f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f8	5f		 pop	 rdi
  001f9	5e		 pop	 rsi
  001fa	c3		 ret	 0
s370_GetSD1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pSDE$ = 32
sd1$ = 40
tv84 = 48
index$ = 96
pSDEBLK$ = 104
s370_GetSD0 PROC

; 175  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 176  :     register U64 sd1;
; 177  :     register SDE* pSDE = pSDEBLK->pSDE;

  00010	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00015	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00019	48 89 44 24 20	 mov	 QWORD PTR pSDE$[rsp], rax

; 178  : 
; 179  :     if (pSDEBLK->sde[ index ].cached)

  0001e	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 18	 imul	 rax, rax, 24
  00027	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  0002c	0f b6 44 01 34	 movzx	 eax, BYTE PTR [rcx+rax+52]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s370_GetSD

; 180  :     {
; 181  :         *pSDE = pSDEBLK->sde[ index ];

  00035	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 18	 imul	 rax, rax, 24
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pSDE$[rsp]
  00048	48 8d 74 01 20	 lea	 rsi, QWORD PTR [rcx+rax+32]
  0004d	b9 18 00 00 00	 mov	 ecx, 24
  00052	f3 a4		 rep movsb

; 182  :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 20 01 00 00	 jmp	 $LN1@s370_GetSD
$LN2@s370_GetSD:

; 183  :     }
; 184  : 
; 185  :     sd1 = ARCH_DEP( GetDCT )( index, pSDEBLK->pDCTBLK );

  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 60	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s370_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR sd1$[rsp], rax

; 186  :     pSDE->ms = FALSE;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00077	c6 40 13 00	 mov	 BYTE PTR [rax+19], 0

; 187  : 
; 188  :     if (!(pSDE->sct = SD1_U8R( 0, 3 )) || pSDE->sct >= 7)

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  00080	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00084	48 83 e0 07	 and	 rax, 7
  00088	48 89 44 24 30	 mov	 QWORD PTR tv84[rsp], rax
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00092	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv84[rsp]
  00097	88 48 12	 mov	 BYTE PTR [rax+18], cl
  0009a	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv84[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	74 0e		 je	 SHORT $LN4@s370_GetSD
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000a8	0f b6 40 12	 movzx	 eax, BYTE PTR [rax+18]
  000ac	83 f8 07	 cmp	 eax, 7
  000af	7c 12		 jl	 SHORT $LN3@s370_GetSD
$LN4@s370_GetSD:

; 189  :     {
; 190  :         pSDE->sct = 7;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000b6	c6 40 12 07	 mov	 BYTE PTR [rax+18], 7

; 191  :         pSDE->ms = TRUE;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  000bf	c6 40 13 01	 mov	 BYTE PTR [rax+19], 1
$LN3@s370_GetSD:

; 192  :     }
; 193  : 
; 194  :     // Examine child bits for children 1 to 5
; 195  : 
; 196  :     pSDE->ecb = SD1_U16L( 3, 5 );

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  000c8	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  000cc	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  000d7	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 197  : 
; 198  :     // If children exist append examine child bits for
; 199  :     // children 6 and 7 which are in the parent CCE so
; 200  :     // they're all in one place (makes things easier).
; 201  :     //
; 202  :     // Note: this only applies for the FIRST sibling
; 203  :     // of the parent. Examine child bits for children
; 204  :     // 6 and 7 do not exist for subsequent siblings
; 205  :     // of parent and thus must ALWAYS be examined.
; 206  : 
; 207  :     if (pSDEBLK->pCCE)  // (first sibling of parent?)

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000e0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e5	74 3a		 je	 SHORT $LN5@s370_GetSD

; 208  :     {
; 209  :         if (pSDEBLK->pCCE->cct > 1)

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000ec	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f0	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	7e 26		 jle	 SHORT $LN7@s370_GetSD

; 210  :             pSDE->ecb |= pSDEBLK->pCCE->yy >> 5;

  000f9	48 8b 44 24 68	 mov	 rax, QWORD PTR pSDEBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00106	c1 f8 05	 sar	 eax, 5
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0010e	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00112	0b c8		 or	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0011b	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN7@s370_GetSD:

; 211  :     }

  0011f	eb 17		 jmp	 SHORT $LN6@s370_GetSD
$LN5@s370_GetSD:

; 212  :     else // (force child to ALWAYS be examined)
; 213  :     {
; 214  :         pSDE->ecb |= 0xFFFF >> 5;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00126	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  0012a	0d ff 07 00 00	 or	 eax, 2047		; 000007ffH
  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  00134	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN6@s370_GetSD:

; 215  :     }
; 216  : 
; 217  :     pSDE->sc_dw = CSWAP64( sd1 << 8 );

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR sd1$[rsp]
  0013d	48 c1 e0 08	 shl	 rax, 8
  00141	48 8b c8	 mov	 rcx, rax
  00144	e8 00 00 00 00	 call	 _byteswap_uint64
  00149	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSDE$[rsp]
  0014e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 218  : 
; 219  :     pSDE->cached = TRUE;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR pSDE$[rsp]
  00156	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 220  :     pSDEBLK->sde[ index ] = *pSDE;

  0015a	0f b7 44 24 60	 movzx	 eax, WORD PTR index$[rsp]
  0015f	48 6b c0 18	 imul	 rax, rax, 24
  00163	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pSDEBLK$[rsp]
  00168	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  0016d	48 8b 74 24 20	 mov	 rsi, QWORD PTR pSDE$[rsp]
  00172	b9 18 00 00 00	 mov	 ecx, 24
  00177	f3 a4		 rep movsb

; 221  : 
; 222  :     return TRUE;

  00179	b0 01		 mov	 al, 1
$LN1@s370_GetSD:

; 223  : }

  0017b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017f	5f		 pop	 rdi
  00180	5e		 pop	 rsi
  00181	c3		 ret	 0
s370_GetSD0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
wrk$1 = 32
pCCE$ = 40
wrk$2 = 48
cce$ = 56
tv234 = 64
tv84 = 72
tv90 = 80
tv144 = 88
tv179 = 96
index$ = 144
pCCEBLK$ = 152
s370_GetCCE PROC

; 90   : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 91   :     register U64 cce;
; 92   :     register CCE* pCCE = pCCEBLK->pCCE;

  00010	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 28	 mov	 QWORD PTR pCCE$[rsp], rax

; 93   : 
; 94   :     if (pCCEBLK->cce[ index ].cached)

  00021	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00029	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0002d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00035	0f b6 44 01 31	 movzx	 eax, BYTE PTR [rcx+rax+49]
  0003a	85 c0		 test	 eax, eax
  0003c	74 2c		 je	 SHORT $LN2@s370_GetCC

; 95   :     {
; 96   :         *pCCE = pCCEBLK->cce[ index ];

  0003e	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00046	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0004a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  00052	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pCCE$[rsp]
  00057	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0005c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00061	f3 a4		 rep movsb

; 97   :         return TRUE;

  00063	b0 01		 mov	 al, 1
  00065	e9 31 03 00 00	 jmp	 $LN1@s370_GetCC
$LN2@s370_GetCC:

; 98   :     }
; 99   : 
; 100  :     cce = ARCH_DEP( GetDCT )( index, pCCEBLK->pDCTBLK );

  0006a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pCCEBLK$[rsp]
  00072	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00075	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR index$[rsp]
  0007d	e8 00 00 00 00	 call	 s370_GetDCT
  00082	48 89 44 24 38	 mov	 QWORD PTR cce$[rsp], rax

; 101  :     pCCE->mc = FALSE;

  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0008c	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 102  : 
; 103  :     if (!(pCCE->cct = CCE_U8R( 0, 3 )))  // (no children)

  00090	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00095	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  00099	48 83 e0 07	 and	 rax, 7
  0009d	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000a7	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv84[rsp]
  000ac	88 48 16	 mov	 BYTE PTR [rax+22], cl
  000af	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv84[rsp]
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 8b 00 00
	00		 jne	 $LN3@s370_GetCC

; 104  :     {
; 105  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 5)

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000c1	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  000c5	48 83 e0 07	 and	 rax, 7
  000c9	48 89 44 24 50	 mov	 QWORD PTR tv90[rsp], rax
  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000d3	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv90[rsp]
  000d8	88 48 17	 mov	 BYTE PTR [rax+23], cl
  000db	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv90[rsp]
  000e0	83 f8 05	 cmp	 eax, 5
  000e3	7e 07		 jle	 SHORT $LN4@s370_GetCC

; 106  :             return FALSE;

  000e5	32 c0		 xor	 al, al
  000e7	e9 af 02 00 00	 jmp	 $LN1@s370_GetCC
$LN4@s370_GetCC:

; 107  : 
; 108  :         if (pCCE->act)

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  000f1	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  000f5	85 c0		 test	 eax, eax
  000f7	74 19		 je	 SHORT $LN5@s370_GetCC

; 109  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  000f9	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  000fe	48 c1 e0 18	 shl	 rax, 24
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 _byteswap_uint64
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0010f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@s370_GetCC:

; 110  : 
; 111  :         pCCE->cached = TRUE;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00117	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 112  :         pCCEBLK->cce[ index ] = *pCCE;

  0011b	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  00123	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00127	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0012f	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  00134	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00139	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0013e	f3 a4		 rep movsb

; 113  : 
; 114  :         return TRUE;

  00140	b0 01		 mov	 al, 1
  00142	e9 54 02 00 00	 jmp	 $LN1@s370_GetCC
$LN3@s370_GetCC:

; 115  :     }
; 116  : 
; 117  :     if (pCCE->cct == 1)  // (only one child)

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0014c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00150	83 f8 01	 cmp	 eax, 1
  00153	0f 85 cf 00 00
	00		 jne	 $LN6@s370_GetCC

; 118  :     {
; 119  :         register U8 wrk;
; 120  : 
; 121  :         if ((pCCE->act = CCE_U8R( 8, 3 )) > 4)

  00159	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0015e	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00162	48 83 e0 07	 and	 rax, 7
  00166	48 89 44 24 58	 mov	 QWORD PTR tv144[rsp], rax
  0016b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00170	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv144[rsp]
  00175	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00178	0f b6 44 24 58	 movzx	 eax, BYTE PTR tv144[rsp]
  0017d	83 f8 04	 cmp	 eax, 4
  00180	7e 07		 jle	 SHORT $LN8@s370_GetCC

; 122  :             return FALSE;

  00182	32 c0		 xor	 al, al
  00184	e9 12 02 00 00	 jmp	 $LN1@s370_GetCC
$LN8@s370_GetCC:

; 123  : 
; 124  :         wrk = (pCCE->act << 3);

  00189	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0018e	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  00192	c1 e0 03	 shl	 eax, 3
  00195	88 44 24 30	 mov	 BYTE PTR wrk$2[rsp], al

; 125  :         pCCE->cc[0] = CCE_U8R( 24 + wrk, 8 );

  00199	0f b6 44 24 30	 movzx	 eax, BYTE PTR wrk$2[rsp]
  0019e	83 c0 20	 add	 eax, 32			; 00000020H
  001a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a6	2b c8		 sub	 ecx, eax
  001a8	8b c1		 mov	 eax, ecx
  001aa	0f b6 c8	 movzx	 ecx, al
  001ad	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001b2	48 d3 e8	 shr	 rax, cl
  001b5	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	48 6b c9 00	 imul	 rcx, rcx, 0
  001c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  001c9	88 44 0a 08	 mov	 BYTE PTR [rdx+rcx+8], al

; 126  : 
; 127  :         if (pCCE->act)

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  001d2	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  001d6	85 c0		 test	 eax, eax
  001d8	74 19		 je	 SHORT $LN9@s370_GetCC

; 128  :             pCCE->ec_dw = CSWAP64( cce << 24 );

  001da	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001df	48 c1 e0 18	 shl	 rax, 24
  001e3	48 8b c8	 mov	 rcx, rax
  001e6	e8 00 00 00 00	 call	 _byteswap_uint64
  001eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  001f0	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@s370_GetCC:

; 129  : 
; 130  :         pCCE->cptr = CCE_U16R( 11, 13 );

  001f3	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  001f8	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  001fc	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00202	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00207	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 131  :         pCCE->ecb  = CCE_U16L(  3,  1 );

  0020b	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00210	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00214	48 25 00 80 00
	00		 and	 rax, 32768		; 00008000H
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  0021f	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 132  :     }

  00223	e9 15 01 00 00	 jmp	 $LN7@s370_GetCC
$LN6@s370_GetCC:

; 133  :     else // (many children)
; 134  :     {
; 135  :         register U8 wrk; // (max cct)
; 136  : 
; 137  :         if (!(pCCE->act = CCE_U8R( 10, 1 ))) // (act == 0)

  00228	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0022d	48 c1 e8 35	 shr	 rax, 53			; 00000035H
  00231	48 83 e0 01	 and	 rax, 1
  00235	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0023f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR tv179[rsp]
  00244	88 48 17	 mov	 BYTE PTR [rax+23], cl
  00247	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv179[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	75 07		 jne	 SHORT $LN10@s370_GetCC

; 138  :             wrk = 5;

  00250	c6 44 24 20 05	 mov	 BYTE PTR wrk$1[rsp], 5
  00255	eb 25		 jmp	 SHORT $LN11@s370_GetCC
$LN10@s370_GetCC:

; 139  :         else // (act == 1)
; 140  :         {
; 141  :             wrk = 4;

  00257	c6 44 24 20 04	 mov	 BYTE PTR wrk$1[rsp], 4

; 142  :             pCCE->ec[0] = CCE_U8R( 24, 8 );

  0025c	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00261	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00265	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0026b	b9 01 00 00 00	 mov	 ecx, 1
  00270	48 6b c9 00	 imul	 rcx, rcx, 0
  00274	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCCE$[rsp]
  00279	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN11@s370_GetCC:

; 143  :         }
; 144  : 
; 145  :         if (pCCE->cct > (wrk + 1))   // (data exception?)

  0027c	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00281	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  00285	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  0028a	ff c1		 inc	 ecx
  0028c	3b c1		 cmp	 eax, ecx
  0028e	7e 07		 jle	 SHORT $LN12@s370_GetCC

; 146  :             return FALSE;

  00290	32 c0		 xor	 al, al
  00292	e9 04 01 00 00	 jmp	 $LN1@s370_GetCC
$LN12@s370_GetCC:

; 147  : 
; 148  :         if (pCCE->cct == (wrk + 1))  // (more children?)

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  0029c	0f b6 40 16	 movzx	 eax, BYTE PTR [rax+22]
  002a0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002a5	ff c1		 inc	 ecx
  002a7	3b c1		 cmp	 eax, ecx
  002a9	75 16		 jne	 SHORT $LN13@s370_GetCC

; 149  :         {
; 150  :             pCCE->mc = TRUE;         // (set flag)

  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b0	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1

; 151  :             pCCE->cct = wrk;         // (fix cct)

  002b4	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002b9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR wrk$1[rsp]
  002be	88 48 16	 mov	 BYTE PTR [rax+22], cl
$LN13@s370_GetCC:

; 152  :         }
; 153  : 
; 154  :         wrk = (pCCE->act << 3);      // (cc start bit - 24)

  002c1	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  002c6	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  002ca	c1 e0 03	 shl	 eax, 3
  002cd	88 44 24 20	 mov	 BYTE PTR wrk$1[rsp], al

; 155  : 
; 156  :         pCCE->cc_dw = CSWAP64( cce << (24 + wrk) );

  002d1	0f b6 44 24 20	 movzx	 eax, BYTE PTR wrk$1[rsp]
  002d6	83 c0 18	 add	 eax, 24
  002d9	0f b6 c8	 movzx	 ecx, al
  002dc	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002e1	48 d3 e0	 shl	 rax, cl
  002e4	48 8b c8	 mov	 rcx, rax
  002e7	e8 00 00 00 00	 call	 _byteswap_uint64
  002ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  002f1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 157  : 
; 158  :         pCCE->cptr = CCE_U16R( 11, 13 );

  002f5	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  002fa	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  002fe	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  00304	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00309	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 159  :         pCCE->ecb  = CCE_U16L(  3,  5 );

  0030d	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  00312	48 c1 e8 2d	 shr	 rax, 45			; 0000002dH
  00316	48 25 00 f8 00
	00		 and	 rax, 63488		; 0000f800H
  0031c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00321	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 160  :         pCCE->yy   = CCE_U16L(  8,  2 );

  00325	48 8b 44 24 38	 mov	 rax, QWORD PTR cce$[rsp]
  0032a	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0032e	48 25 00 c0 00
	00		 and	 rax, 49152		; 0000c000H
  00334	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCCE$[rsp]
  00339	66 89 41 14	 mov	 WORD PTR [rcx+20], ax
$LN7@s370_GetCC:

; 161  :     }
; 162  : 
; 163  :     pCCE->cached = TRUE;

  0033d	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00342	c6 40 19 01	 mov	 BYTE PTR [rax+25], 1

; 164  :     pCCEBLK->cce[ index ] = *pCCE;

  00346	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR index$[rsp]
  0034e	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00352	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0035a	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0035f	48 8b 74 24 28	 mov	 rsi, QWORD PTR pCCE$[rsp]
  00364	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00369	f3 a4		 rep movsb

; 165  : 
; 166  :     return (pCCE->cptr > pCCEBLK->max_index) ? FALSE : TRUE;

  0036b	48 8b 44 24 28	 mov	 rax, QWORD PTR pCCE$[rsp]
  00370	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00374	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pCCEBLK$[rsp]
  0037c	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00380	3b c1		 cmp	 eax, ecx
  00382	7e 0a		 jle	 SHORT $LN15@s370_GetCC
  00384	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
  0038c	eb 08		 jmp	 SHORT $LN16@s370_GetCC
$LN15@s370_GetCC:
  0038e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
$LN16@s370_GetCC:
  00396	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv234[rsp]
$LN1@s370_GetCC:

; 167  : }

  0039b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0039f	5f		 pop	 rdi
  003a0	5e		 pop	 rsi
  003a1	c3		 ret	 0
s370_GetCCE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pECE$ = 32
ece$ = 40
tv83 = 48
tv89 = 56
tv134 = 64
index$ = 112
pECEBLK$ = 120
s370_GetECE PROC

; 49   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 50   :     register U64 ece;
; 51   :     register ECE* pECE = pECEBLK->pECE;

  00010	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00015	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00019	48 89 44 24 20	 mov	 QWORD PTR pECE$[rsp], rax

; 52   : 
; 53   :     if (pECEBLK->ece[ index ].cached)

  0001e	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00023	48 6b c0 10	 imul	 rax, rax, 16
  00027	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  0002c	0f b6 44 01 25	 movzx	 eax, BYTE PTR [rcx+rax+37]
  00031	85 c0		 test	 eax, eax
  00033	74 26		 je	 SHORT $LN2@s370_GetEC

; 54   :     {
; 55   :         *pECE = pECEBLK->ece[ index ];

  00035	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  0003a	48 6b c0 10	 imul	 rax, rax, 16
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pECE$[rsp]
  00048	48 8d 74 01 18	 lea	 rsi, QWORD PTR [rcx+rax+24]
  0004d	b9 10 00 00 00	 mov	 ecx, 16
  00052	f3 a4		 rep movsb

; 56   :         return TRUE;

  00054	b0 01		 mov	 al, 1
  00056	e9 31 01 00 00	 jmp	 $LN1@s370_GetEC
$LN2@s370_GetEC:

; 57   :     }
; 58   : 
; 59   :     ece = ARCH_DEP( GetDCT )( index, pECEBLK->pDCTBLK );

  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR pECEBLK$[rsp]
  00060	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00063	0f b7 4c 24 70	 movzx	 ecx, WORD PTR index$[rsp]
  00068	e8 00 00 00 00	 call	 s370_GetDCT
  0006d	48 89 44 24 28	 mov	 QWORD PTR ece$[rsp], rax

; 60   : 
; 61   :     if (!(pECE->psl = ECE_U8R( 0, 3 )))

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00077	48 c1 e8 3d	 shr	 rax, 61			; 0000003dH
  0007b	48 83 e0 07	 and	 rax, 7
  0007f	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00089	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv83[rsp]
  0008e	88 48 0b	 mov	 BYTE PTR [rax+11], cl
  00091	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv83[rsp]
  00096	85 c0		 test	 eax, eax
  00098	75 4a		 jne	 SHORT $LN3@s370_GetEC

; 62   :     {
; 63   :         if (!(pECE->csl = ECE_U8R( 5, 3 )))

  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  0009f	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  000a3	48 83 e0 07	 and	 rax, 7
  000a7	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000b1	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv89[rsp]
  000b6	88 48 0a	 mov	 BYTE PTR [rax+10], cl
  000b9	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv89[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 07		 jne	 SHORT $LN5@s370_GetEC

; 64   :             return FALSE;

  000c2	32 c0		 xor	 al, al
  000c4	e9 c3 00 00 00	 jmp	 $LN1@s370_GetEC
$LN5@s370_GetEC:

; 65   :         pECE->ec_dw = CSWAP64( ece << 8 );

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  000ce	48 c1 e0 08	 shl	 rax, 8
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 _byteswap_uint64
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  000df	48 89 01	 mov	 QWORD PTR [rcx], rax

; 66   :     }

  000e2	eb 7e		 jmp	 SHORT $LN4@s370_GetEC
$LN3@s370_GetEC:

; 67   :     else if (pECE->psl > 5)

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  000e9	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  000ed	83 f8 05	 cmp	 eax, 5
  000f0	7e 09		 jle	 SHORT $LN6@s370_GetEC

; 68   :         return FALSE;

  000f2	32 c0		 xor	 al, al
  000f4	e9 93 00 00 00	 jmp	 $LN1@s370_GetEC
  000f9	eb 67		 jmp	 SHORT $LN7@s370_GetEC
$LN6@s370_GetEC:

; 69   :     else
; 70   :     {
; 71   :         if ((pECE->pptr = ECE_U16R( 3, 13 )) > pECEBLK->max_index)

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00100	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00104	48 25 ff 1f 00
	00		 and	 rax, 8191		; 00001fffH
  0010a	48 89 44 24 40	 mov	 QWORD PTR tv134[rsp], rax
  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00114	0f b7 4c 24 40	 movzx	 ecx, WORD PTR tv134[rsp]
  00119	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0011d	0f b7 44 24 40	 movzx	 eax, WORD PTR tv134[rsp]
  00122	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00127	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  0012b	3b c1		 cmp	 eax, ecx
  0012d	7e 04		 jle	 SHORT $LN8@s370_GetEC

; 72   :             return FALSE;

  0012f	32 c0		 xor	 al, al
  00131	eb 59		 jmp	 SHORT $LN1@s370_GetEC
$LN8@s370_GetEC:

; 73   :         pECE->ofst = (U8)(ece);

  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00138	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR ece$[rsp]
  0013d	88 48 0c	 mov	 BYTE PTR [rax+12], cl

; 74   :         pECE->ec_dw = CSWAP64( ece << 16 );

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR ece$[rsp]
  00145	48 c1 e0 10	 shl	 rax, 16
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 _byteswap_uint64
  00151	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pECE$[rsp]
  00156	48 89 01	 mov	 QWORD PTR [rcx], rax

; 75   :         pECE->csl = 0;

  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  0015e	c6 40 0a 00	 mov	 BYTE PTR [rax+10], 0
$LN7@s370_GetEC:
$LN4@s370_GetEC:

; 76   :     }
; 77   : 
; 78   :     pECE->cached = TRUE;

  00162	48 8b 44 24 20	 mov	 rax, QWORD PTR pECE$[rsp]
  00167	c6 40 0d 01	 mov	 BYTE PTR [rax+13], 1

; 79   :     pECEBLK->ece[ index ] = *pECE;

  0016b	0f b7 44 24 70	 movzx	 eax, WORD PTR index$[rsp]
  00170	48 6b c0 10	 imul	 rax, rax, 16
  00174	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pECEBLK$[rsp]
  00179	48 8d 7c 01 18	 lea	 rdi, QWORD PTR [rcx+rax+24]
  0017e	48 8b 74 24 20	 mov	 rsi, QWORD PTR pECE$[rsp]
  00183	b9 10 00 00 00	 mov	 ecx, 16
  00188	f3 a4		 rep movsb

; 80   : 
; 81   :     return TRUE;

  0018a	b0 01		 mov	 al, 1
$LN1@s370_GetEC:

; 82   : }

  0018c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00190	5f		 pop	 rdi
  00191	5e		 pop	 rsi
  00192	c3		 ret	 0
s370_GetECE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpscdct.c
_TEXT	SEGMENT
pagenum$ = 48
pageidx$ = 52
index$ = 80
pDCTBLK$ = 88
s370_GetDCT PROC

; 25   : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 26   :     register U16  pagenum  = INDEX_TO_PAGENUM( index );

  0000e	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00013	c1 f8 08	 sar	 eax, 8
  00016	66 89 44 24 30	 mov	 WORD PTR pagenum$[rsp], ax

; 27   :     register U16  pageidx  = INDEX_TO_PAGEIDX( index );

  0001b	0f b7 44 24 50	 movzx	 eax, WORD PTR index$[rsp]
  00020	c1 e0 03	 shl	 eax, 3
  00023	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00028	66 89 44 24 34	 mov	 WORD PTR pageidx$[rsp], ax

; 28   : 
; 29   :     if (!pDCTBLK->maddr[ pagenum ])

  0002d	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00037	48 83 7c c1 10
	00		 cmp	 QWORD PTR [rcx+rax*8+16], 0
  0003d	75 5a		 jne	 SHORT $LN2@s370_GetDC

; 30   :     {
; 31   :         pDCTBLK->maddr[ pagenum ] = MADDR

  0003f	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  00044	c1 e0 0b	 shl	 eax, 11
  00047	8b c0		 mov	 eax, eax
  00049	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0004e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00057	0f b6 89 14 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+276]
  0005e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00062	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0006a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  0006f	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDCTBLK$[rsp]
  00077	44 8b 81 10 01
	00 00		 mov	 r8d, DWORD PTR [rcx+272]
  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 s370_maddr_l
  0008a	0f b7 4c 24 30	 movzx	 ecx, WORD PTR pagenum$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  00094	48 89 44 ca 10	 mov	 QWORD PTR [rdx+rcx*8+16], rax
$LN2@s370_GetDC:

; 32   :         (
; 33   :             pDCTBLK->pDict + PAGENUM_TO_BYTES( pagenum ),
; 34   :             pDCTBLK->arn,
; 35   :             pDCTBLK->regs,
; 36   :             ACCTYPE_READ,
; 37   :             pDCTBLK->pkey
; 38   :         );
; 39   :     }
; 40   :     return CSWAP64(*(U64*)(uintptr_t)(&pDCTBLK->maddr[ pagenum ][ pageidx ]));

  00099	0f b7 44 24 30	 movzx	 eax, WORD PTR pagenum$[rsp]
  0009e	0f b7 4c 24 34	 movzx	 ecx, WORD PTR pageidx$[rsp]
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDCTBLK$[rsp]
  000a8	48 8b 44 c2 10	 mov	 rax, QWORD PTR [rdx+rax*8+16]
  000ad	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  000b1	e8 00 00 00 00	 call	 _byteswap_uint64

; 41   : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
s370_GetDCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
END
